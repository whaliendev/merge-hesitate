[
    {
        "a_contents": "/******************************************************************************\n * Copyright 2017 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *****************************************************************************/\n\n#include \"modules/prediction/container/obstacles/obstacle.h\"\n\n#include <iomanip>\n#include <cmath>\n\n#include \"modules/common/log.h\"\n\nnamespace apollo {\nnamespace prediction {\n\nusing apollo::perception::PerceptionObstacle;\nusing apollo::common::math::KalmanFilter;\nusing apollo::common::ErrorCode;\n\nstd::mutex Obstacle::mutex_;\n\nObstacle::Obstacle() : \n    id_(-1),\n    type_(PerceptionObstacle::UNKNOWN_MOVABLE),\n    feature_history_(0),\n    kf_motion_tracker_(),\n    is_motion_tracker_enabled_(false),\n    kf_lane_tracker_map_(0) {\n\n}\n\nObstacle::~Obstacle() {\n  id_ = -1;\n  type_ = PerceptionObstacle::UNKNOWN_UNMOVABLE;\n  feature_history_.clear();\n  is_motion_tracker_enabled_ = false;\n  kf_lane_tracker_map_.clear();\n  // TODO(author) current_lanes_.clear();\n}\n\nint Obstacle::id() const {\n  std::lock_guard<std::mutex> lock(mutex_);\n  return id_;\n}\n\ndouble Obstacle::timestamp() const {\n  std::lock_guard<std::mutex> lock(mutex_);\n  if (feature_history_.size() > 0) {\n    return feature_history_.front().timestamp();\n  } else {\n    return 0.0;\n  }\n}\n\nconst Feature& Obstacle::feature(size_t i) {\n  std::lock_guard<std::mutex> lock(mutex_);\n  CHECK(i < feature_history_.size());\n  return feature_history_[i];\n}\n\nFeature* Obstacle::mutable_feature(size_t i) {\n  std::lock_guard<std::mutex> lock(mutex_);\n  CHECK(i < feature_history_.size());\n  return &feature_history_[i];\n}\n\nconst Feature& Obstacle::latest_feature() {\n  std::lock_guard<std::mutex> lock(mutex_);\n  CHECK(feature_history_.size() > 0);\n  return feature_history_.front();\n}\n\nFeature* Obstacle::mutable_latest_feature() {\n  std::lock_guard<std::mutex> lock(mutex_);\n\n  CHECK(feature_history_.size() > 0);\n  return &(feature_history_.front());\n}\n\nsize_t Obstacle::history_size() const {\n  std::lock_guard<std::mutex> lock(mutex_);\n  return feature_history_.size();\n}\n\nconst KalmanFilter<double, 4, 2, 0>& Obstacle::kf_lane_tracker(\n      const std::string& lane_id) {\n    CHECK(kf_lane_tracker_map_.find(lane_id) != kf_lane_tracker_map_.end());\n    return kf_lane_tracker_map_[lane_id];\n}\n\nvoid Obstacle::Insert(const PerceptionObstacle& perception_obstacle,\n                      const double timestamp) {\n  std::lock_guard<std::mutex> lock(mutex_);\n  if (feature_history_.size() > 0 &&\n      timestamp <= feature_history_.front().timestamp()) {\n    AINFO << \"Obstacle [\" << id_ << \"] received an older frame [\"\n          << timestamp << \"] than the most recent timestamp [ \"\n          << feature_history_.front().timestamp() << \"].\";\n    return;\n  }\n\n  Feature feature;\n  if (SetId(perception_obstacle, &feature) == ErrorCode::PREDICTION_ERROR) {\n    return;\n  }\n  if (SetType(perception_obstacle) == ErrorCode::PREDICTION_ERROR) {\n    return;\n  }\n  SetTimestamp(perception_obstacle, timestamp, &feature);\n  SetPosition(perception_obstacle, &feature);\n  SetVelocity(perception_obstacle, &feature);\n}\n\nErrorCode Obstacle::SetId(const PerceptionObstacle& perception_obstacle,\n                          Feature* feature) {\n  if (!perception_obstacle.has_id()) {\n    AERROR << \"Obstacle has no ID.\";\n    return ErrorCode::PREDICTION_ERROR;\n  }\n\n  int id = perception_obstacle.id();\n  if (id_ < 0) {\n    id_ = id;\n    AINFO << \"Obstacle set id [\" << id_ << \"].\";\n  } else {\n    if (id_ != id) {\n      AERROR << \"Obstacle [\" << id_ << \"] has a mismatched ID [\" << id\n             << \"] from perception obstacle.\";\n      return ErrorCode::PREDICTION_ERROR;\n    } else {\n      feature->set_id(id);\n    }\n  }\n  return ErrorCode::OK;\n}\n\nErrorCode Obstacle::SetType(const PerceptionObstacle& perception_obstacle) {\n  if (perception_obstacle.has_type()) {\n    type_ = perception_obstacle.type();\n    AINFO << \"Obstacle [\" << id_ << \"] set type [\" << type_ << \"].\";\n  } else {\n    AERROR << \"Obstacle [\" << id_ << \"] has no type.\";\n    return ErrorCode::PREDICTION_ERROR;\n  }\n  return ErrorCode::OK;\n}\n\nvoid Obstacle::SetTimestamp(const PerceptionObstacle& perception_obstacle,\n                            const double timestamp, Feature* feature) {\n  double ts = timestamp;\n  if (perception_obstacle.has_timestamp() &&\n      perception_obstacle.timestamp() > 0.0) {\n    ts = perception_obstacle.timestamp();\n  }\n  feature->set_timestamp(ts);\n\n  AINFO << \"Obstacle [\" << id_ << \"] set timestamp [\" << std::fixed\n        << std::setprecision(6) << ts << \"].\";\n}\n\n\nvoid Obstacle::SetPosition(const PerceptionObstacle& perception_obstacle,\n                           Feature* feature) {\n  double x = 0.0;\n  double y = 0.0;\n\n  if (perception_obstacle.has_position()) {\n    if (perception_obstacle.position().has_x()) {\n      x = perception_obstacle.position().x();\n    }\n    if (perception_obstacle.position().has_y()) {\n      y = perception_obstacle.position().y();\n    }\n  }\n\n  feature->mutable_position()->set_x(x);\n  feature->mutable_position()->set_y(y);\n\n  AINFO << \"Obstacle [\" << id_ << \"] set position [\" << std::fixed\n        << std::setprecision(6) << x << \", \" << std::fixed\n        << std::setprecision(6) << y << \"].\";\n}\n\nvoid Obstacle::SetVelocity(const PerceptionObstacle& perception_obstacle,\n                           Feature* feature) {\n  double x = 0.0;\n  double y = 0.0;\n\n  if (perception_obstacle.has_velocity()) {\n    if (perception_obstacle.velocity().has_x()) {\n      x = perception_obstacle.velocity().x();\n    }\n    if (perception_obstacle.velocity().has_y()) {\n      y = perception_obstacle.velocity().y();\n    }\n  }\n\n  feature->mutable_velocity()->set_x(x);\n  feature->mutable_velocity()->set_y(y);\n\n  double speed = std::hypot(x, y);\n  double velocity_heading = std::atan2(y, x);\n  feature->set_velocity_heading(velocity_heading);\n  feature->set_speed(speed);\n\n  AINFO << \"Obstacle [\" << id_ << \"] set velocity [\" << std::fixed\n        << std::setprecision(6) << x << \", \" << std::fixed\n        << std::setprecision(6) << y << \"], \"\n        << \"velocity heading [\" << velocity_heading << \"] and speed [\" << speed\n        << \"].\";\n}\n\n}  // namespace prediction\n}  // namespace apollo",
        "b_contents": "/******************************************************************************\n * Copyright 2017 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *****************************************************************************/\n\n#include \"modules/prediction/container/obstacles/obstacle.h\"\n\n#include <iomanip>\n#include <cmath>\n\n#include \"modules/common/log.h\"\n\nnamespace apollo {\nnamespace prediction {\n\nusing apollo::perception::PerceptionObstacle;\nusing apollo::common::math::KalmanFilter;\nusing apollo::common::ErrorCode;\nusing apollo::common::Point3D;\n\nstd::mutex Obstacle::mutex_;\n\nnamespace {\n\ndouble Damp(const double x, const double sigma) {\n    return 1 / (1 + exp(1 / (std::fabs(x) + sigma)));\n}\n\n}  // namespace\n\nObstacle::Obstacle() : \n    id_(-1),\n    type_(PerceptionObstacle::UNKNOWN_MOVABLE),\n    feature_history_(0),\n    kf_motion_tracker_(),\n    is_motion_tracker_enabled_(false),\n    kf_lane_tracker_map_(0) {\n\n}\n\nObstacle::~Obstacle() {\n  id_ = -1;\n  type_ = PerceptionObstacle::UNKNOWN_UNMOVABLE;\n  feature_history_.clear();\n  is_motion_tracker_enabled_ = false;\n  kf_lane_tracker_map_.clear();\n  // TODO(author) current_lanes_.clear();\n}\n\nint Obstacle::id() const {\n  std::lock_guard<std::mutex> lock(mutex_);\n  return id_;\n}\n\ndouble Obstacle::timestamp() const {\n  std::lock_guard<std::mutex> lock(mutex_);\n  if (feature_history_.size() > 0) {\n    return feature_history_.front().timestamp();\n  } else {\n    return 0.0;\n  }\n}\n\nconst Feature& Obstacle::feature(size_t i) {\n  std::lock_guard<std::mutex> lock(mutex_);\n  CHECK(i < feature_history_.size());\n  return feature_history_[i];\n}\n\nFeature* Obstacle::mutable_feature(size_t i) {\n  std::lock_guard<std::mutex> lock(mutex_);\n  CHECK(i < feature_history_.size());\n  return &feature_history_[i];\n}\n\nconst Feature& Obstacle::latest_feature() {\n  std::lock_guard<std::mutex> lock(mutex_);\n  CHECK(feature_history_.size() > 0);\n  return feature_history_.front();\n}\n\nFeature* Obstacle::mutable_latest_feature() {\n  std::lock_guard<std::mutex> lock(mutex_);\n\n  CHECK(feature_history_.size() > 0);\n  return &(feature_history_.front());\n}\n\nsize_t Obstacle::history_size() const {\n  std::lock_guard<std::mutex> lock(mutex_);\n  return feature_history_.size();\n}\n\nconst KalmanFilter<double, 4, 2, 0>& Obstacle::kf_lane_tracker(\n      const std::string& lane_id) {\n    CHECK(kf_lane_tracker_map_.find(lane_id) != kf_lane_tracker_map_.end());\n    return kf_lane_tracker_map_[lane_id];\n}\n\nvoid Obstacle::Insert(const PerceptionObstacle& perception_obstacle,\n                      const double timestamp) {\n  std::lock_guard<std::mutex> lock(mutex_);\n  if (feature_history_.size() > 0 &&\n      timestamp <= feature_history_.front().timestamp()) {\n    AINFO << \"Obstacle [\" << id_ << \"] received an older frame [\"\n          << timestamp << \"] than the most recent timestamp [ \"\n          << feature_history_.front().timestamp() << \"].\";\n    return;\n  }\n\n  Feature feature;\n  if (SetId(perception_obstacle, &feature) == ErrorCode::PREDICTION_ERROR) {\n    return;\n  }\n  if (SetType(perception_obstacle) == ErrorCode::PREDICTION_ERROR) {\n    return;\n  }\n  SetTimestamp(perception_obstacle, timestamp, &feature);\n  SetPosition(perception_obstacle, &feature);\n  SetVelocity(perception_obstacle, &feature);\n  SetAcceleration(&feature);\n  SetTheta(perception_obstacle, &feature);\n}\n\nErrorCode Obstacle::SetId(const PerceptionObstacle& perception_obstacle,\n                          Feature* feature) {\n  if (!perception_obstacle.has_id()) {\n    AERROR << \"Obstacle has no ID.\";\n    return ErrorCode::PREDICTION_ERROR;\n  }\n\n  int id = perception_obstacle.id();\n  if (id_ < 0) {\n    id_ = id;\n    AINFO << \"Obstacle set id [\" << id_ << \"].\";\n  } else {\n    if (id_ != id) {\n      AERROR << \"Obstacle [\" << id_ << \"] has a mismatched ID [\" << id\n             << \"] from perception obstacle.\";\n      return ErrorCode::PREDICTION_ERROR;\n    } else {\n      feature->set_id(id);\n    }\n  }\n  return ErrorCode::OK;\n}\n\nErrorCode Obstacle::SetType(const PerceptionObstacle& perception_obstacle) {\n  if (perception_obstacle.has_type()) {\n    type_ = perception_obstacle.type();\n    AINFO << \"Obstacle [\" << id_ << \"] set type [\" << type_ << \"].\";\n  } else {\n    AERROR << \"Obstacle [\" << id_ << \"] has no type.\";\n    return ErrorCode::PREDICTION_ERROR;\n  }\n  return ErrorCode::OK;\n}\n\nvoid Obstacle::SetTimestamp(const PerceptionObstacle& perception_obstacle,\n                            const double timestamp, Feature* feature) {\n  double ts = timestamp;\n  if (perception_obstacle.has_timestamp() &&\n      perception_obstacle.timestamp() > 0.0) {\n    ts = perception_obstacle.timestamp();\n  }\n  feature->set_timestamp(ts);\n\n  AINFO << \"Obstacle [\" << id_ << \"] set timestamp [\" << std::fixed\n        << std::setprecision(6) << ts << \"].\";\n}\n\n\nvoid Obstacle::SetPosition(const PerceptionObstacle& perception_obstacle,\n                           Feature* feature) {\n  double x = 0.0;\n  double y = 0.0;\n  double z = 0.0;\n\n  if (perception_obstacle.has_position()) {\n    if (perception_obstacle.position().has_x()) {\n      x = perception_obstacle.position().x();\n    }\n    if (perception_obstacle.position().has_y()) {\n      y = perception_obstacle.position().y();\n    }\n    if (perception_obstacle.position().has_z()) {\n      y = perception_obstacle.position().z();\n    }\n  }\n\n  feature->mutable_position()->set_x(x);\n  feature->mutable_position()->set_y(y);\n  feature->mutable_position()->set_z(z);\n\n  AINFO << \"Obstacle [\" << id_ << \"] set position [\" << std::fixed\n        << std::setprecision(6) << x << \", \" << std::fixed\n        << std::setprecision(6) << y << \", \" << std::fixed\n        << std::setprecision(6) << z << \"].\";\n}\n\nvoid Obstacle::SetVelocity(const PerceptionObstacle& perception_obstacle,\n                           Feature* feature) {\n  double velocity_x = 0.0;\n  double velocity_y = 0.0;\n  double velocity_z = 0.0;\n\n  if (perception_obstacle.has_velocity()) {\n    if (perception_obstacle.velocity().has_x()) {\n      velocity_x = perception_obstacle.velocity().x();\n    }\n    if (perception_obstacle.velocity().has_y()) {\n      velocity_y = perception_obstacle.velocity().y();\n    }\n    if (perception_obstacle.velocity().has_z()) {\n      velocity_z = perception_obstacle.velocity().z();\n    }\n  }\n\n  feature->mutable_velocity()->set_x(velocity_x);\n  feature->mutable_velocity()->set_y(velocity_y);\n  feature->mutable_velocity()->set_z(velocity_z);\n\n  double speed = std::hypot(std::hypot(velocity_x, velocity_y), velocity_z);\n  double velocity_heading = std::atan2(velocity_y, velocity_x);\n  feature->set_velocity_heading(velocity_heading);\n  feature->set_speed(speed);\n\n  AINFO << \"Obstacle [\" << id_ << \"] set velocity [\" << std::fixed\n        << std::setprecision(6) << velocity_x << \", \" << std::fixed\n        << std::setprecision(6) << velocity_y << \", \" << std::fixed\n        << std::setprecision(6) << velocity_z << \"], \"\n        << \"velocity heading [\" << velocity_heading << \"] and speed [\" << speed\n        << \"].\";\n}\n\nvoid Obstacle::SetAcceleration(Feature* feature) {\n  double acc_x = 0.0;\n  double acc_y = 0.0;\n  double acc_z = 0.0;\n\n  if (feature_history_.size() > 0) {\n    double curr_ts = feature->timestamp();\n    double prev_ts = feature_history_.front().timestamp();\n\n    const Point3D& curr_velocity = feature->velocity();\n    const Point3D& prev_velocity = feature_history_.front().velocity();\n\n    // TODO(kechxu) add a gflag of double precision\n    if (curr_ts > prev_ts) {\n      double damping_x = Damp(curr_velocity.x(), 0.001);\n      double damping_y = Damp(curr_velocity.y(), 0.001);\n      double damping_z = Damp(curr_velocity.z(), 0.001);\n\n      acc_x = (curr_velocity.x() - prev_velocity.x()) / (curr_ts - prev_ts);\n      acc_y = (curr_velocity.y() - prev_velocity.y()) / (curr_ts - prev_ts);\n      acc_z = (curr_velocity.z() - prev_velocity.z()) / (curr_ts - prev_ts);\n      // TODO(kechxu) clamp the acc\n      acc_x *= damping_x;\n      acc_y *= damping_y;\n      acc_z *= damping_z;\n    }\n  }\n\n  feature->mutable_acceleration()->set_x(acc_x);\n  feature->mutable_acceleration()->set_y(acc_y);\n  feature->mutable_acceleration()->set_z(acc_z);\n  double acc = std::hypot(std::hypot(acc_x, acc_y), acc_z);\n  feature->set_acc(acc);\n\n  LOG(INFO) << \"Obstacle [\" << id_ << \"] set acc [\" << std::fixed\n            << std::setprecision(6) << acc_x << \", \" << std::fixed\n            << std::setprecision(6) << acc_y << \", \" << std::fixed\n            << std::setprecision(6) << acc_z << \"], \"\n            << \"and acc [\" << acc << \"].\";\n}\n\n\nvoid Obstacle::SetTheta(const PerceptionObstacle& perception_obstacle,\n                        Feature* feature) {\n  double theta = 0.0;\n  if (perception_obstacle.has_theta()) {\n    theta = perception_obstacle.theta();\n  }\n  feature->set_theta(theta);\n\n  AINFO << \"Obstacle [\" << id_ << \"] set theta [\" << std::fixed\n        << std::setprecision(6) << theta << \"].\";\n}\n\n\n}  // namespace prediction\n}  // namespace apollo",
        "base_contents": "",
        "res_region": "/******************************************************************************\n * Copyright 2017 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *****************************************************************************/\n\n#include \"modules/prediction/container/obstacles/obstacle.h\"\n\n#include <iomanip>\n#include <cmath>\n\n#include \"modules/common/log.h\"\n\nnamespace apollo {\nnamespace prediction {\n\nusing apollo::perception::PerceptionObstacle;\nusing apollo::common::math::KalmanFilter;\nusing apollo::common::ErrorCode;\nusing apollo::common::Point3D;\n\nstd::mutex Obstacle::mutex_;\n\nnamespace {\n\ndouble Damp(const double x, const double sigma) {\n    return 1 / (1 + exp(1 / (std::fabs(x) + sigma)));\n}\n\n}  // namespace\n\nObstacle::Obstacle() : \n    id_(-1),\n    type_(PerceptionObstacle::UNKNOWN_MOVABLE),\n    feature_history_(0),\n    kf_motion_tracker_(),\n    is_motion_tracker_enabled_(false),\n    kf_lane_tracker_map_(0) {\n\n}\n\nObstacle::~Obstacle() {\n  id_ = -1;\n  type_ = PerceptionObstacle::UNKNOWN_UNMOVABLE;\n  feature_history_.clear();\n  is_motion_tracker_enabled_ = false;\n  kf_lane_tracker_map_.clear();\n  // TODO(author) current_lanes_.clear();\n}\n\nint Obstacle::id() const {\n  std::lock_guard<std::mutex> lock(mutex_);\n  return id_;\n}\n\ndouble Obstacle::timestamp() const {\n  std::lock_guard<std::mutex> lock(mutex_);\n  if (feature_history_.size() > 0) {\n    return feature_history_.front().timestamp();\n  } else {\n    return 0.0;\n  }\n}\n\nconst Feature& Obstacle::feature(size_t i) {\n  std::lock_guard<std::mutex> lock(mutex_);\n  CHECK(i < feature_history_.size());\n  return feature_history_[i];\n}\n\nFeature* Obstacle::mutable_feature(size_t i) {\n  std::lock_guard<std::mutex> lock(mutex_);\n  CHECK(i < feature_history_.size());\n  return &feature_history_[i];\n}\n\nconst Feature& Obstacle::latest_feature() {\n  std::lock_guard<std::mutex> lock(mutex_);\n  CHECK(feature_history_.size() > 0);\n  return feature_history_.front();\n}\n\nFeature* Obstacle::mutable_latest_feature() {\n  std::lock_guard<std::mutex> lock(mutex_);\n\n  CHECK(feature_history_.size() > 0);\n  return &(feature_history_.front());\n}\n\nsize_t Obstacle::history_size() const {\n  std::lock_guard<std::mutex> lock(mutex_);\n  return feature_history_.size();\n}\n\nconst KalmanFilter<double, 4, 2, 0>& Obstacle::kf_lane_tracker(\n      const std::string& lane_id) {\n    CHECK(kf_lane_tracker_map_.find(lane_id) != kf_lane_tracker_map_.end());\n    return kf_lane_tracker_map_[lane_id];\n}\n\nvoid Obstacle::Insert(const PerceptionObstacle& perception_obstacle,\n                      const double timestamp) {\n  std::lock_guard<std::mutex> lock(mutex_);\n  if (feature_history_.size() > 0 &&\n      timestamp <= feature_history_.front().timestamp()) {\n    AINFO << \"Obstacle [\" << id_ << \"] received an older frame [\"\n          << timestamp << \"] than the most recent timestamp [ \"\n          << feature_history_.front().timestamp() << \"].\";\n    return;\n  }\n\n  Feature feature;\n  if (SetId(perception_obstacle, &feature) == ErrorCode::PREDICTION_ERROR) {\n    return;\n  }\n  if (SetType(perception_obstacle) == ErrorCode::PREDICTION_ERROR) {\n    return;\n  }\n  SetTimestamp(perception_obstacle, timestamp, &feature);\n  SetPosition(perception_obstacle, &feature);\n  SetVelocity(perception_obstacle, &feature);\n  SetAcceleration(&feature);\n  SetTheta(perception_obstacle, &feature);\n}\n\nErrorCode Obstacle::SetId(const PerceptionObstacle& perception_obstacle,\n                          Feature* feature) {\n  if (!perception_obstacle.has_id()) {\n    AERROR << \"Obstacle has no ID.\";\n    return ErrorCode::PREDICTION_ERROR;\n  }\n\n  int id = perception_obstacle.id();\n  if (id_ < 0) {\n    id_ = id;\n    AINFO << \"Obstacle set id [\" << id_ << \"].\";\n  } else {\n    if (id_ != id) {\n      AERROR << \"Obstacle [\" << id_ << \"] has a mismatched ID [\" << id\n             << \"] from perception obstacle.\";\n      return ErrorCode::PREDICTION_ERROR;\n    } else {\n      feature->set_id(id);\n    }\n  }\n  return ErrorCode::OK;\n}\n\nErrorCode Obstacle::SetType(const PerceptionObstacle& perception_obstacle) {\n  if (perception_obstacle.has_type()) {\n    type_ = perception_obstacle.type();\n    AINFO << \"Obstacle [\" << id_ << \"] set type [\" << type_ << \"].\";\n  } else {\n    AERROR << \"Obstacle [\" << id_ << \"] has no type.\";\n    return ErrorCode::PREDICTION_ERROR;\n  }\n  return ErrorCode::OK;\n}\n\nvoid Obstacle::SetTimestamp(const PerceptionObstacle& perception_obstacle,\n                            const double timestamp, Feature* feature) {\n  double ts = timestamp;\n  if (perception_obstacle.has_timestamp() &&\n      perception_obstacle.timestamp() > 0.0) {\n    ts = perception_obstacle.timestamp();\n  }\n  feature->set_timestamp(ts);\n\n  AINFO << \"Obstacle [\" << id_ << \"] set timestamp [\" << std::fixed\n        << std::setprecision(6) << ts << \"].\";\n}\n\n\nvoid Obstacle::SetPosition(const PerceptionObstacle& perception_obstacle,\n                           Feature* feature) {\n  double x = 0.0;\n  double y = 0.0;\n  double z = 0.0;\n\n  if (perception_obstacle.has_position()) {\n    if (perception_obstacle.position().has_x()) {\n      x = perception_obstacle.position().x();\n    }\n    if (perception_obstacle.position().has_y()) {\n      y = perception_obstacle.position().y();\n    }\n    if (perception_obstacle.position().has_z()) {\n      z = perception_obstacle.position().z();\n    }\n  }\n\n  feature->mutable_position()->set_x(x);\n  feature->mutable_position()->set_y(y);\n  feature->mutable_position()->set_z(z);\n\n  AINFO << \"Obstacle [\" << id_ << \"] set position [\" << std::fixed\n        << std::setprecision(6) << x << \", \" << std::fixed\n        << std::setprecision(6) << y << \", \" << std::fixed\n        << std::setprecision(6) << z << \"].\";\n}\n\nvoid Obstacle::SetVelocity(const PerceptionObstacle& perception_obstacle,\n                           Feature* feature) {\n  double velocity_x = 0.0;\n  double velocity_y = 0.0;\n  double velocity_z = 0.0;\n\n  if (perception_obstacle.has_velocity()) {\n    if (perception_obstacle.velocity().has_x()) {\n      velocity_x = perception_obstacle.velocity().x();\n    }\n    if (perception_obstacle.velocity().has_y()) {\n      velocity_y = perception_obstacle.velocity().y();\n    }\n    if (perception_obstacle.velocity().has_z()) {\n      velocity_z = perception_obstacle.velocity().z();\n    }\n  }\n\n  feature->mutable_velocity()->set_x(velocity_x);\n  feature->mutable_velocity()->set_y(velocity_y);\n  feature->mutable_velocity()->set_z(velocity_z);\n\n  double speed = std::hypot(std::hypot(velocity_x, velocity_y), velocity_z);\n  double velocity_heading = std::atan2(velocity_y, velocity_x);\n  feature->set_velocity_heading(velocity_heading);\n  feature->set_speed(speed);\n\n  AINFO << \"Obstacle [\" << id_ << \"] set velocity [\" << std::fixed\n        << std::setprecision(6) << velocity_x << \", \" << std::fixed\n        << std::setprecision(6) << velocity_y << \", \" << std::fixed\n        << std::setprecision(6) << velocity_z << \"], \"\n        << \"velocity heading [\" << velocity_heading << \"] and speed [\" << speed\n        << \"].\";\n}\n\nvoid Obstacle::SetAcceleration(Feature* feature) {\n  double acc_x = 0.0;\n  double acc_y = 0.0;\n  double acc_z = 0.0;\n\n  if (feature_history_.size() > 0) {\n    double curr_ts = feature->timestamp();\n    double prev_ts = feature_history_.front().timestamp();\n\n    const Point3D& curr_velocity = feature->velocity();\n    const Point3D& prev_velocity = feature_history_.front().velocity();\n\n    // TODO(kechxu) add a gflag of double precision\n    if (curr_ts > prev_ts) {\n      double damping_x = Damp(curr_velocity.x(), 0.001);\n      double damping_y = Damp(curr_velocity.y(), 0.001);\n      double damping_z = Damp(curr_velocity.z(), 0.001);\n\n      acc_x = (curr_velocity.x() - prev_velocity.x()) / (curr_ts - prev_ts);\n      acc_y = (curr_velocity.y() - prev_velocity.y()) / (curr_ts - prev_ts);\n      acc_z = (curr_velocity.z() - prev_velocity.z()) / (curr_ts - prev_ts);\n      // TODO(kechxu) clamp the acc\n      acc_x *= damping_x;\n      acc_y *= damping_y;\n      acc_z *= damping_z;\n    }\n  }\n\n  feature->mutable_acceleration()->set_x(acc_x);\n  feature->mutable_acceleration()->set_y(acc_y);\n  feature->mutable_acceleration()->set_z(acc_z);\n  double acc = std::hypot(std::hypot(acc_x, acc_y), acc_z);\n  feature->set_acc(acc);\n\n  LOG(INFO) << \"Obstacle [\" << id_ << \"] set acc [\" << std::fixed\n            << std::setprecision(6) << acc_x << \", \" << std::fixed\n            << std::setprecision(6) << acc_y << \", \" << std::fixed\n            << std::setprecision(6) << acc_z << \"], \"\n            << \"and acc [\" << acc << \"].\";\n}\n\n\nvoid Obstacle::SetTheta(const PerceptionObstacle& perception_obstacle,\n                        Feature* feature) {\n  double theta = 0.0;\n  if (perception_obstacle.has_theta()) {\n    theta = perception_obstacle.theta();\n  }\n  feature->set_theta(theta);\n\n  AINFO << \"Obstacle [\" << id_ << \"] set theta [\" << std::fixed\n        << std::setprecision(6) << theta << \"].\";\n}\n\n}  // namespace prediction\n}  // namespace apollo",
        "lookback": " * Copyright 2017 The Apollo Authors. All Rights Reserved.",
        "lookahead": "",
        "label": [
            "newcode",
            "one_side_deletion"
        ],
        "start_line": 0,
        "end_line": 531,
        "merge_gen_region": " Copyright Thepol Authors All Reserved/****************************************************************************** Copyright Thepol Authors All Reserved * Licensed the Apache, 20theLicense *\"); you not this except in with the. You obtain copy the License * may a of License * may a of License * *://../licensesLICENSE20 * Unless by law agreed in,, * under License distributed anAS\" BASIS * WARRANTIES CONDITIONS ANY, express implied * the License the for specific governing and limitations the License *****************************************************************************/includemodulespredictioncontainerobsob.\"includeiomip # <>includecmath # \"/commonlogh namespacepol { namespace { alo usingpol::ceptionPerOb; alopol::::::::::::::::;man; alocommonErrorCode stdmutexstacle::_;stacle::stacleOb() id_(1 type_(ceptionOb::_MOVABLE featurehistory0 k____ ismotiontrackerenabledfalse k__trackermap0 { Ob::~stacle {_ -;_ PerOb::_MOVABLE featurehistoryclear ismotiontrackerenabled =;flanetrackermapclear //()_esclear } Ob::() const stdlockguardstdmutex lockmutex return_; doublestacletimestamp const stdlockguardstdmutex lockmutex iffeaturehistorysize >) return__.().",
        "confidence": 0.9408126473426819,
        "hesitated": false,
        "resolved": false
    }
]