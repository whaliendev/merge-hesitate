[
    {
        "a_contents": "/******************************************************************************\n * Copyright 2019 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *****************************************************************************/\n\n#include \"modules/dreamview/backend/sim_control_manager/core/sim_control_with_model_base.h\"\n\n#include \"modules/dreamview/backend/map/map_service.h\"\n\nnamespace apollo {\nnamespace dreamview {\n\nusing apollo::canbus::Chassis;\nusing apollo::common::Point3D;\nusing apollo::common::Quaternion;\nusing apollo::common::math::HeadingToQuaternion;\nusing apollo::common::math::InterpolateUsingLinearApproximation;\nusing apollo::common::math::InverseQuaternionRotate;\nusing apollo::common::math::NormalizeAngle;\nusing apollo::common::math::QuaternionToHeading;\nusing apollo::common::util::FillHeader;\nusing apollo::control::ControlCommand;\nusing apollo::localization::LocalizationEstimate;\nusing apollo::prediction::PredictionObstacles;\nusing apollo::routing::RoutingRequest;\nusing apollo::routing::RoutingResponse;\nusing apollo::sim_control::SimCarStatus;\nusing Json = nlohmann::json;\n\n/**\n * @brief Construct a new Sim Control With Model Base:: Sim Control With Model\n * Base object\n * @param node_name: depens on different dynamic model\n */\nSimControlWithModelBase::SimControlWithModelBase(const std::string& node_name)\n    : node_(cyber::CreateNode(node_name)),\n      gear_position_(0),\n      dt_(0.01),\n      map_service_(new MapService()) {\n  InitTimerAndIO();\n}\n\nvoid SimControlWithModelBase::InitTimerAndIO() {\n  // Setup  control result data callback.\n  cyber::ReaderConfig control_cmd_reader_config;\n  control_cmd_reader_config.channel_name = FLAGS_control_command_topic;\n  control_cmd_reader_config.pending_queue_size =\n      FLAGS_reader_pending_queue_size;\n  prediction_reader_ = node_->CreateReader<PredictionObstacles>(\n      FLAGS_prediction_topic,\n      [this](const std::shared_ptr<PredictionObstacles>& obstacles) {\n        this->OnPredictionObstacles(obstacles);\n      });\n  control_command_reader_ = node_->CreateReader<ControlCommand>(\n      control_cmd_reader_config,\n      [this](const std::shared_ptr<ControlCommand>& cmd) {\n        ADEBUG << \"Received control data: run canbus callback.\";\n        OnControlCommand(*cmd);\n      });\n  // Setup routing callback.\n  cyber::ReaderConfig routing_reader_config;\n  routing_reader_config.channel_name = FLAGS_routing_response_topic;\n  routing_reader_config.pending_queue_size = FLAGS_reader_pending_queue_size;\n  routing_reader_ = node_->CreateReader<RoutingResponse>(\n      routing_reader_config,\n      [this](const std::shared_ptr<RoutingResponse>& cmd) {\n        ADEBUG << \"Received routing data: run canbus callback.\";\n        OnRoutingResponse(*cmd);\n      });\n  routing_request_reader_ = node_->CreateReader<RoutingRequest>(\n      FLAGS_routing_request_topic,\n      [this](const std::shared_ptr<RoutingRequest>& routing_request) {\n        this->OnRoutingRequest(routing_request);\n      });\n\n  // Setup localization callback.\n  cyber::ReaderConfig localization_reader_config;\n  localization_reader_config.channel_name = FLAGS_localization_topic;\n  localization_reader_config.pending_queue_size =\n      FLAGS_reader_pending_queue_size;\n  localization_reader_ = node_->CreateReader<LocalizationEstimate>(\n      localization_reader_config, nullptr);\n\n  localization_writer_ =\n      node_->CreateWriter<LocalizationEstimate>(FLAGS_localization_topic);\n  chassis_writer_ = node_->CreateWriter<Chassis>(FLAGS_chassis_topic);\n  prediction_writer_ =\n      node_->CreateWriter<PredictionObstacles>(FLAGS_prediction_topic);\n\n  // Start timer to publish localization and chassis messages.\n  sim_control_timer_.reset(new cyber::Timer(\n      kModelIntervalMs, [this]() { this->RunOnce(); }, false));\n  sim_prediction_timer_.reset(new cyber::Timer(\n      kSimPredictionIntervalMs, [this]() { this->PublishDummyPrediction(); },\n      false));\n}\n\nvoid SimControlWithModelBase::UpdateGearPosition() {\n  // update gear location, 1 drive, -1 reverse, 0 for other states\n  if (control_cmd_.gear_location() == Chassis::GEAR_DRIVE) {\n    gear_position_ = 1;\n  } else if (control_cmd_.gear_location() == Chassis::GEAR_REVERSE) {\n    gear_position_ = -1;\n  } else {\n    gear_position_ = 0;\n  }\n  current_point_.set_gear_position(gear_position_);\n}\n\nvoid SimControlWithModelBase::OnPredictionObstacles(\n    const std::shared_ptr<PredictionObstacles>& obstacles) {\n  std::lock_guard<std::mutex> lock(mutex_);\n  if (!enabled_) {\n    return;\n  }\n  send_dummy_prediction_ =\n      obstacles->header().module_name() == \"SimDMPrediction\";\n}\n\nvoid SimControlWithModelBase::Start() {\n  std::lock_guard<std::mutex> lock(mutex_);\n  if (!enabled_) {\n    InternalReset();\n    // todo: Compatible with scenario conf and default value\n    Json start_point_attr({});\n    // start_point_attr:from scenario conf json or default value.here dm is\n    // divided from scenario use default value\n    start_point_attr[\"start_velocity\"] = 0.0;\n    start_point_attr[\"start_acceleration\"] = 0.0;\n    start_point_attr[\"start_heading\"] = std::numeric_limits<double>::max();\n    Init(true, start_point_attr);\n    sim_control_timer_->Start();\n    sim_prediction_timer_->Start();\n    enabled_ = true;\n  }\n}\n\nvoid SimControlWithModelBase::Start(double x, double y) {\n  std::lock_guard<std::mutex> lock(mutex_);\n  if (!enabled_) {\n    InternalReset();\n    Json start_point_attr({});\n    start_point_attr[\"start_velocity\"] = 0.0;\n    start_point_attr[\"start_acceleration\"] = 0.0;\n    start_point_attr[\"start_heading\"] = std::numeric_limits<double>::max();\n    start_point_attr[\"x\"] = x;\n    start_point_attr[\"y\"] = y;\n    Init(true, start_point_attr, true);\n    sim_control_timer_->Start();\n    sim_prediction_timer_->Start();\n    enabled_ = true;\n  }\n}\n\nvoid SimControlWithModelBase::Stop() {\n  std::lock_guard<std::mutex> lock(mutex_);\n\n  if (enabled_) {\n    sim_control_timer_->Stop();\n    sim_prediction_timer_->Stop();\n    enabled_ = false;\n  }\n}\n\nvoid SimControlWithModelBase::Reset() {\n  std::lock_guard<std::mutex> lock(mutex_);\n  InternalReset();\n}\n\nvoid SimControlWithModelBase::InternalReset() {\n  re_routing_triggered_ = false;\n  current_routing_header_.Clear();\n  start_auto_ = false;\n  send_dummy_prediction_ = true;\n}\n\nvoid SimControlWithModelBase::OnControlCommand(\n    const ControlCommand& control_cmd) {\n  std::lock_guard<std::mutex> lock(mutex_);\n  if (!enabled_) {\n    return;\n  }\n  control_cmd_ = control_cmd;\n}\n\nvoid SimControlWithModelBase::OnRoutingResponse(\n    const RoutingResponse& routing) {\n  std::lock_guard<std::mutex> lock(mutex_);\n  if (!enabled_) {\n    return;\n  }\n\n  CHECK_GE(routing.routing_request().waypoint_size(), 2)\n      << \"routing should have at least two waypoints\";\n\n  current_routing_header_ = routing.header();\n  // If this is from a planning re-routing request, or the start point has been\n  // initialized by an actual localization pose, don't reset the start point.\n  // re_routing_triggered_ =\n  //     routing.routing_request().header().module_name() == \"planning\";\n  // if (!re_routing_triggered_ && !start_point_from_localization_) {\n  //   CHECK_GE(routing.routing_request().waypoint_size(), 2)\n  //       << \"routing should have at least two waypoints\";\n  //   current_routing_header_ = routing.header();\n  //   const auto& start_pose = routing.routing_request().waypoint(0).pose();\n  //   SimCarStatus point;\n  //   point.set_x(start_pose.x());\n  //   point.set_y(start_pose.y());\n  //   point.set_acceleration_s(start_acceleration_);\n  //   point.set_speed(start_velocity_);\n  //   // Use configured heading if available, otherwise find heading based on\n  //   // first lane in routing response\n  //   double theta = 0.0;\n  //   if (start_heading_ < std::numeric_limits<double>::max()) {\n  //     theta = start_heading_;\n  //   } else if (routing.road_size() > 0) {\n  //     auto start_lane = routing.road(0).passage(0).segment(0);\n  //     theta =\n  //         map_service_->GetLaneHeading(start_lane.id(),\n  //         start_lane.start_s());\n  //   }\n  //   point.set_theta(theta);\n  //   SetStartPoint(point);\n  // }\n}\n\nvoid SimControlWithModelBase::OnRoutingRequest(\n    const std::shared_ptr<RoutingRequest>& routing_request) {\n  std::lock_guard<std::mutex> lock(mutex_);\n  if (!enabled_) {\n    return;\n  }\n\n  CHECK_GE(routing_request->waypoint_size(), 2)\n      << \"routing should have at least two waypoints\";\n  const auto& start_pose = routing_request->waypoint(0).pose();\n\n  SimCarStatus point;\n  point.set_x(start_pose.x());\n  point.set_y(start_pose.y());\n  point.set_acceleration_s(start_acceleration_);\n  point.set_speed(start_velocity_);\n  // Use configured heading if available, otherwise find heading based on\n  // first lane in routing response\n  double theta = 0.0;\n  double s = 0.0;\n  const auto& start_way_point = routing_request->waypoint().Get(0);\n  // If the lane id has been set, set theta as the lane heading.\n  if (start_way_point.has_id()) {\n    auto& hdmap = hdmap::HDMapUtil::BaseMap();\n    hdmap::Id lane_id = hdmap::MakeMapId(start_way_point.id());\n    auto lane = hdmap.GetLaneById(lane_id);\n    if (nullptr != lane) {\n      theta = lane->Heading(start_way_point.s());\n    } else {\n      map_service_->GetPoseWithRegardToLane(start_pose.x(), start_pose.y(),\n                                            &theta, &s);\n    }\n  } else {\n    // Find the lane nearest to the start pose and get its heading as theta.\n    map_service_->GetPoseWithRegardToLane(start_pose.x(), start_pose.y(),\n                                          &theta, &s);\n  }\n  point.set_theta(theta);\n  // if (start_heading_ < std::numeric_limits<double>::max()) {\n  //   theta = start_heading_;\n  // } else if (routing_request.road_size() > 0) {\n  //   auto start_lane = routing_request.road(0).passage(0).segment(0);\n  //   theta = map_service_->GetLaneHeading(start_lane.id(),\n  //   start_lane.start_s());\n  // }\n  // point.set_theta(theta);\n  SetStartPoint(point);\n}\n\nvoid SimControlWithModelBase::SetStartPoint(const SimCarStatus& point) {\n  previous_point_ = point;\n}\n\nvoid SimControlWithModelBase::InitStartPoint(nlohmann::json start_point_attr,\n                                             bool use_start_point_position) {\n  AINFO << \"Init start point with position!\";\n\n  start_velocity_ = start_point_attr[\"start_velocity\"];\n  start_acceleration_ = start_point_attr[\"start_acceleration\"];\n  start_heading_ = start_point_attr[\"start_heading\"];\n  SimCarStatus point;\n  localization_reader_->Observe();\n  if (use_start_point_position) {\n    // add start point position for dynamic model\n    // new add feature to keep same with simcontrol\n    start_point_from_localization_ = false;\n    point.set_x(start_point_attr[\"x\"]);\n    point.set_y(start_point_attr[\"y\"]);\n    // z use default 0\n    point.set_z(0);\n    // Todo(@lijin): tmp not support map service,support theta\n    // double theta = 0.0;\n    // double s = 0.0;\n    // map_service_->GetPoseWithRegardToLane(x, y, &theta, &s);\n    // point.set_theta();\n    point.set_speed(start_velocity_);\n    point.set_acceleration_s(start_acceleration_);\n  } else {\n    if (localization_reader_->Empty()) {\n      // Routing will provide all other pose info\n      start_point_from_localization_ = false;\n      point.set_speed(start_velocity_);\n      point.set_acceleration_s(start_acceleration_);\n    } else {\n      start_point_from_localization_ = true;\n      const auto& pose = localization_reader_->GetLatestObserved()->pose();\n\n      point.set_x(pose.position().x());\n      point.set_y(pose.position().y());\n      point.set_z(pose.position().z());\n      point.set_theta(pose.heading());\n      point.set_speed(\n          std::hypot(pose.linear_velocity().x(), pose.linear_velocity().y()));\n      // Calculates the dot product of acceleration and velocity. The sign\n      // of this projection indicates whether this is acceleration or\n      // deceleration.\n      double projection =\n          pose.linear_acceleration().x() * pose.linear_velocity().x() +\n          pose.linear_acceleration().y() * pose.linear_velocity().y();\n\n      // Calculates the magnitude of the acceleration. Negate the value if\n      // it is indeed a deceleration.\n      double magnitude = std::hypot(pose.linear_acceleration().x(),\n                                    pose.linear_acceleration().y());\n      point.set_acceleration_s(std::signbit(projection) ? -magnitude\n                                                        : magnitude);\n      // Set init gear to neutral position\n      point.set_gear_position(0);\n    }\n  }\n  SetStartPoint(point);\n}\n\n/**\n * @brief pubish chassis info\n *\n * @param model_name\n */\nvoid SimControlWithModelBase::PublishChassis(const std::string model_name) {\n  auto chassis = std::make_shared<Chassis>();\n  apollo::common::util::FillHeader(model_name, chassis.get());\n\n  chassis->set_engine_started(true);\n  chassis->set_speed_mps(current_point_.speed());\n  chassis->set_odometer_m(current_point_.odometer());\n\n  if (FLAGS_enable_steering_latency) {\n    chassis->set_steering_percentage(filtered_control_cmd_.steering_target());\n  } else {\n    chassis->set_steering_percentage(control_cmd_.steering_target());\n  }\n  chassis->set_throttle_percentage(control_cmd_.throttle());\n  chassis->set_brake_percentage(control_cmd_.brake());\n  if (start_auto_) {\n    chassis->set_driving_mode(Chassis::COMPLETE_AUTO_DRIVE);\n  } else {\n    chassis->set_driving_mode(Chassis::COMPLETE_MANUAL);\n  }\n  chassis->set_gear_location(control_cmd_.gear_location());\n  chassis_writer_->Write(chassis);\n}\n\n/**\n * @brief publish prediction info\n *\n */\nvoid SimControlWithModelBase::PublishDummyPrediction() {\n  auto prediction = std::make_shared<PredictionObstacles>();\n  {\n    std::lock_guard<std::mutex> lock(mutex_);\n    if (!send_dummy_prediction_) {\n      return;\n    }\n    FillHeader(\"SimDMPrediction\", prediction.get());\n  }\n  prediction_writer_->Write(prediction);\n}\n\nvoid SimControlWithModelBase::PublishLocalization(\n    const std::string model_name) {\n  auto localization = std::make_shared<LocalizationEstimate>();\n  FillHeader(model_name, localization.get());\n\n  auto* pose = localization->mutable_pose();\n\n  // Set position\n  pose->mutable_position()->set_x(current_point_.x());\n  pose->mutable_position()->set_y(current_point_.y());\n  pose->mutable_position()->set_z(0.0);\n  // Set orientation and heading\n  double cur_theta = current_point_.theta();\n\n  Eigen::Quaternion<double> cur_orientation =\n      HeadingToQuaternion<double>(cur_theta);\n  ADEBUG << \"cur_theta\" << cur_theta;\n  ADEBUG << \"cur_orientation_w\" << cur_orientation.w() << \"cur_orientation_x\"\n         << cur_orientation.x() << \"cur_orientation_y\" << cur_orientation.y()\n         << \"cur_orientation_z\" << cur_orientation.z();\n  pose->mutable_orientation()->set_qw(cur_orientation.w());\n  pose->mutable_orientation()->set_qx(cur_orientation.x());\n  pose->mutable_orientation()->set_qy(cur_orientation.y());\n  pose->mutable_orientation()->set_qz(cur_orientation.z());\n  pose->set_heading(cur_theta);\n\n  // Set linear_velocity\n  if (control_cmd_.gear_location() == Chassis::GEAR_REVERSE) {\n    pose->mutable_linear_velocity()->set_x(std::cos(cur_theta) * -1.0 *\n                                           current_point_.speed());\n    pose->mutable_linear_velocity()->set_y(std::sin(cur_theta) * -1.0 *\n                                           current_point_.speed());\n  } else {\n    pose->mutable_linear_velocity()->set_x(std::cos(cur_theta) *\n                                           current_point_.speed());\n    pose->mutable_linear_velocity()->set_y(std::sin(cur_theta) *\n                                           current_point_.speed());\n  }\n\n  pose->mutable_linear_velocity()->set_z(0);\n\n  // Set angular_velocity in both map reference frame and vehicle reference\n  // frame\n  double cur_curvature = std::tan(control_cmd_.steering_target() *\n                                  vehicle_param_.max_steer_angle() / 100.0 /\n                                  vehicle_param_.steer_ratio()) /\n                         vehicle_param_.wheel_base();\n\n  pose->mutable_angular_velocity()->set_x(0);\n  pose->mutable_angular_velocity()->set_y(0);\n  pose->mutable_angular_velocity()->set_z(current_point_.speed() *\n                                          cur_curvature);\n\n  TransformToVRF(pose->angular_velocity(), pose->orientation(),\n                 pose->mutable_angular_velocity_vrf());\n\n  // Set linear_acceleration in both map reference frame and vehicle reference\n  // frame\n  auto* linear_acceleration = pose->mutable_linear_acceleration();\n  linear_acceleration->set_x(std::cos(cur_theta) *\n                             current_point_.acceleration_s());\n  linear_acceleration->set_y(std::sin(cur_theta) *\n                             current_point_.acceleration_s());\n  linear_acceleration->set_z(0);\n\n  TransformToVRF(pose->linear_acceleration(), pose->orientation(),\n                 pose->mutable_linear_acceleration_vrf());\n\n  localization_writer_->Write(localization);\n\n  adc_position_.set_x(pose->position().x());\n  adc_position_.set_y(pose->position().y());\n  adc_position_.set_z(pose->position().z());\n}\n\n}  // namespace dreamview\n}  // namespace apollo",
        "b_contents": "/******************************************************************************\n * Copyright 2019 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *****************************************************************************/\n\n#include \"modules/dreamview/backend/sim_control_manager/core/sim_control_with_model_base.h\"\n#include \"modules/dreamview/backend/map/map_service.h\"\n\nnamespace apollo {\nnamespace dreamview {\n\nusing apollo::canbus::Chassis;\nusing apollo::common::Point3D;\nusing apollo::common::Quaternion;\nusing apollo::common::math::HeadingToQuaternion;\nusing apollo::common::math::InterpolateUsingLinearApproximation;\nusing apollo::common::math::InverseQuaternionRotate;\nusing apollo::common::math::NormalizeAngle;\nusing apollo::common::math::QuaternionToHeading;\nusing apollo::common::util::FillHeader;\nusing apollo::control::ControlCommand;\nusing apollo::localization::LocalizationEstimate;\nusing apollo::prediction::PredictionObstacles;\nusing apollo::routing::RoutingResponse;\nusing apollo::routing::RoutingRequest;\nusing apollo::sim_control::SimCarStatus;\nusing Json = nlohmann::json;\n\n/**\n * @brief Construct a new Sim Control With Model Base:: Sim Control With Model\n * Base object\n * @param node_name: depens on different dynamic model\n */\nSimControlWithModelBase::SimControlWithModelBase(const std::string& node_name)\n    : node_(cyber::CreateNode(node_name)),\n      gear_position_(0),\n      dt_(0.01),\n      map_service_(new MapService()) {\n  InitTimerAndIO();\n}\n\nvoid SimControlWithModelBase::InitTimerAndIO() {\n  // Setup  control result data callback.\n  cyber::ReaderConfig control_cmd_reader_config;\n  control_cmd_reader_config.channel_name = FLAGS_control_command_topic;\n  control_cmd_reader_config.pending_queue_size =\n      FLAGS_reader_pending_queue_size;\n  prediction_reader_ = node_->CreateReader<PredictionObstacles>(\n      FLAGS_prediction_topic,\n      [this](const std::shared_ptr<PredictionObstacles> &obstacles) {\n        this->OnPredictionObstacles(obstacles);\n      });\n  control_command_reader_ = node_->CreateReader<ControlCommand>(\n      control_cmd_reader_config,\n      [this](const std::shared_ptr<ControlCommand>& cmd) {\n        ADEBUG << \"Received control data: run canbus callback.\";\n        OnControlCommand(*cmd);\n      });\n  // Setup routing callback.\n  cyber::ReaderConfig routing_reader_config;\n  routing_reader_config.channel_name = FLAGS_routing_response_topic;\n  routing_reader_config.pending_queue_size = FLAGS_reader_pending_queue_size;\n  routing_reader_ = node_->CreateReader<RoutingResponse>(\n      routing_reader_config,\n      [this](const std::shared_ptr<RoutingResponse>& cmd) {\n        ADEBUG << \"Received routing data: run canbus callback.\";\n        OnRoutingResponse(*cmd);\n      });\n   routing_request_reader_ = node_->CreateReader<RoutingRequest>(\n      FLAGS_routing_request_topic,\n      [this](const std::shared_ptr<RoutingRequest>& routing_request) {\n        this->OnRoutingRequest(routing_request);\n      });\n\n  // Setup localization callback.\n  cyber::ReaderConfig localization_reader_config;\n  localization_reader_config.channel_name = FLAGS_localization_topic;\n  localization_reader_config.pending_queue_size =\n      FLAGS_reader_pending_queue_size;\n  localization_reader_ = node_->CreateReader<LocalizationEstimate>(\n      localization_reader_config, nullptr);\n\n  localization_writer_ =\n      node_->CreateWriter<LocalizationEstimate>(FLAGS_localization_topic);\n  chassis_writer_ = node_->CreateWriter<Chassis>(FLAGS_chassis_topic);\n  prediction_writer_ =\n      node_->CreateWriter<PredictionObstacles>(FLAGS_prediction_topic);\n\n  // Start timer to publish localization and chassis messages.\n  sim_control_timer_.reset(new cyber::Timer(\n      kModelIntervalMs, [this]() { this->RunOnce(); }, false));\n  sim_prediction_timer_.reset(new cyber::Timer(\n      kSimPredictionIntervalMs, [this]() { this->PublishDummyPrediction(); },\n      false));\n}\n\nvoid SimControlWithModelBase::UpdateGearPosition() {\n  // update gear location, 1 drive, -1 reverse, 0 for other states\n  if (control_cmd_.gear_location() == Chassis::GEAR_DRIVE) {\n    gear_position_ = 1;\n  } else if (control_cmd_.gear_location() == Chassis::GEAR_REVERSE) {\n    gear_position_ = -1;\n  } else {\n    gear_position_ = 0;\n  }\n  current_point_.set_gear_position(gear_position_);\n}\n\nvoid SimControlWithModelBase::OnPredictionObstacles(\n    const std::shared_ptr<PredictionObstacles> &obstacles) {\n  std::lock_guard<std::mutex> lock(mutex_);\n  if (!enabled_) {\n    return;\n  }\n  send_dummy_prediction_ = obstacles->header().module_name() == \"SimMlpPrediction\";\n}\n\nvoid SimControlWithModelBase::Start() {\n  std::lock_guard<std::mutex> lock(mutex_);\n  if (!enabled_) {\n    InternalReset();\n    // todo: Compatible with scenario conf and default value\n    Json start_point_attr({});\n    // start_point_attr:from scenario conf json or default value.here dm is\n    // divided from scenario use default value\n    start_point_attr[\"start_velocity\"] = 0.0;\n    start_point_attr[\"start_acceleration\"] = 0.0;\n    start_point_attr[\"start_heading\"] = std::numeric_limits<double>::max();\n    Init(true, start_point_attr);\n    sim_control_timer_->Start();\n    sim_prediction_timer_->Start();\n    enabled_ = true;\n  }\n}\n\nvoid SimControlWithModelBase::Start(double x, double y) {\n  std::lock_guard<std::mutex> lock(mutex_);\n  if (!enabled_) {\n    InternalReset();\n    Json start_point_attr({});\n    start_point_attr[\"start_velocity\"] = 0.0;\n    start_point_attr[\"start_acceleration\"] = 0.0;\n    start_point_attr[\"start_heading\"] = std::numeric_limits<double>::max();\n    start_point_attr[\"x\"] = x;\n    start_point_attr[\"y\"] = y;\n    Init(true, start_point_attr, true);\n    sim_control_timer_->Start();\n    sim_prediction_timer_->Start();\n    enabled_ = true;\n  }\n}\n\nvoid SimControlWithModelBase::Stop() {\n  std::lock_guard<std::mutex> lock(mutex_);\n\n  if (enabled_) {\n    sim_control_timer_->Stop();\n    sim_prediction_timer_->Stop();\n    enabled_ = false;\n  }\n}\n\nvoid SimControlWithModelBase::Reset() {\n  std::lock_guard<std::mutex> lock(mutex_);\n  InternalReset();\n}\n\nvoid SimControlWithModelBase::InternalReset() {\n  re_routing_triggered_ = false;\n  current_routing_header_.Clear();\n  start_auto_ = false;\n  send_dummy_prediction_ = true;\n}\n\nvoid SimControlWithModelBase::OnControlCommand(\n    const ControlCommand& control_cmd) {\n  std::lock_guard<std::mutex> lock(mutex_);\n  if (!enabled_) {\n    return;\n  }\n  control_cmd_ = control_cmd;\n}\n\nvoid SimControlWithModelBase::OnRoutingResponse(\n    const RoutingResponse& routing) {\n  std::lock_guard<std::mutex> lock(mutex_);\n  if (!enabled_) {\n    return;\n  }\n\n  CHECK_GE(routing.routing_request().waypoint_size(), 2)\n      << \"routing should have at least two waypoints\";\n\n  current_routing_header_ = routing.header();\n  // If this is from a planning re-routing request, or the start point has been\n  // initialized by an actual localization pose, don't reset the start point.\n  // re_routing_triggered_ =\n  //     routing.routing_request().header().module_name() == \"planning\";\n  // if (!re_routing_triggered_ && !start_point_from_localization_) {\n  //   CHECK_GE(routing.routing_request().waypoint_size(), 2)\n  //       << \"routing should have at least two waypoints\";\n  //   current_routing_header_ = routing.header();\n  //   const auto& start_pose = routing.routing_request().waypoint(0).pose();\n  //   SimCarStatus point;\n  //   point.set_x(start_pose.x());\n  //   point.set_y(start_pose.y());\n  //   point.set_acceleration_s(start_acceleration_);\n  //   point.set_speed(start_velocity_);\n  //   // Use configured heading if available, otherwise find heading based on\n  //   // first lane in routing response\n  //   double theta = 0.0;\n  //   if (start_heading_ < std::numeric_limits<double>::max()) {\n  //     theta = start_heading_;\n  //   } else if (routing.road_size() > 0) {\n  //     auto start_lane = routing.road(0).passage(0).segment(0);\n  //     theta =\n  //         map_service_->GetLaneHeading(start_lane.id(), start_lane.start_s());\n  //   }\n  //   point.set_theta(theta);\n  //   SetStartPoint(point);\n  // }\n\n}\n\nvoid SimControlWithModelBase::OnRoutingRequest(\n    const std::shared_ptr<RoutingRequest>& routing_request) {\n  std::lock_guard<std::mutex> lock(mutex_);\n  if (!enabled_) {\n    return;\n  }\n\n  CHECK_GE(routing_request->waypoint_size(), 2)\n      << \"routing should have at least two waypoints\";\n  const auto& start_pose = routing_request->waypoint(0).pose();\n\n  SimCarStatus point;\n  point.set_x(start_pose.x());\n  point.set_y(start_pose.y());\n  point.set_acceleration_s(start_acceleration_);\n  point.set_speed(start_velocity_);\n  // Use configured heading if available, otherwise find heading based on\n  // first lane in routing response\n  double theta = 0.0;\n  double s = 0.0;\n  const auto& start_way_point = routing_request->waypoint().Get(0);\n  // If the lane id has been set, set theta as the lane heading.\n  if (start_way_point.has_id()) {\n    auto& hdmap = hdmap::HDMapUtil::BaseMap();\n    hdmap::Id lane_id = hdmap::MakeMapId(start_way_point.id());\n    auto lane = hdmap.GetLaneById(lane_id);\n    if (nullptr != lane) {\n      theta = lane->Heading(start_way_point.s());\n    } else {\n      map_service_->GetPoseWithRegardToLane(start_pose.x(), start_pose.y(),\n                                            &theta, &s);\n    }\n  } else {\n    // Find the lane nearest to the start pose and get its heading as theta.\n    map_service_->GetPoseWithRegardToLane(start_pose.x(), start_pose.y(),\n                                          &theta, &s);\n  }\n  point.set_theta(theta);\n  // if (start_heading_ < std::numeric_limits<double>::max()) {\n  //   theta = start_heading_;\n  // } else if (routing_request.road_size() > 0) {\n  //   auto start_lane = routing_request.road(0).passage(0).segment(0);\n  //   theta = map_service_->GetLaneHeading(start_lane.id(), start_lane.start_s());\n  // }\n  // point.set_theta(theta);\n  SetStartPoint(point);\n}\n\nvoid SimControlWithModelBase::SetStartPoint(const SimCarStatus& point) {\n  previous_point_ = point;\n}\n\nvoid SimControlWithModelBase::InitStartPoint(nlohmann::json start_point_attr,\n                                             bool use_start_point_position) {\n  AINFO << \"Init start point with position!\";\n\n  start_velocity_ = start_point_attr[\"start_velocity\"];\n  start_acceleration_ = start_point_attr[\"start_acceleration\"];\n  start_heading_ = start_point_attr[\"start_heading\"];\n  SimCarStatus point;\n  localization_reader_->Observe();\n  if (use_start_point_position) {\n    // add start point position for dynamic model\n    // new add feature to keep same with simcontrol\n    start_point_from_localization_ = false;\n    point.set_x(start_point_attr[\"x\"]);\n    point.set_y(start_point_attr[\"y\"]);\n    // z use default 0\n    point.set_z(0);\n    // Todo(@lijin): tmp not support map service,support theta\n    // double theta = 0.0;\n    // double s = 0.0;\n    // map_service_->GetPoseWithRegardToLane(x, y, &theta, &s);\n    // point.set_theta();\n    point.set_speed(start_velocity_);\n    point.set_acceleration_s(start_acceleration_);\n  } else {\n    if (localization_reader_->Empty()) {\n      // Routing will provide all other pose info\n      start_point_from_localization_ = false;\n      point.set_speed(start_velocity_);\n      point.set_acceleration_s(start_acceleration_);\n    } else {\n      start_point_from_localization_ = true;\n      const auto& pose = localization_reader_->GetLatestObserved()->pose();\n\n      point.set_x(pose.position().x());\n      point.set_y(pose.position().y());\n      point.set_z(pose.position().z());\n      point.set_theta(pose.heading());\n      point.set_speed(\n          std::hypot(pose.linear_velocity().x(), pose.linear_velocity().y()));\n      // Calculates the dot product of acceleration and velocity. The sign\n      // of this projection indicates whether this is acceleration or\n      // deceleration.\n      double projection =\n          pose.linear_acceleration().x() * pose.linear_velocity().x() +\n          pose.linear_acceleration().y() * pose.linear_velocity().y();\n\n      // Calculates the magnitude of the acceleration. Negate the value if\n      // it is indeed a deceleration.\n      double magnitude = std::hypot(pose.linear_acceleration().x(),\n                                    pose.linear_acceleration().y());\n      point.set_acceleration_s(std::signbit(projection) ? -magnitude\n                                                        : magnitude);\n      // Set init gear to neutral position\n      point.set_gear_position(0);\n    }\n  }\n  SetStartPoint(point);\n}\n\n/**\n * @brief pubish chassis info\n *\n * @param model_name\n */\nvoid SimControlWithModelBase::PublishChassis(const std::string model_name) {\n  auto chassis = std::make_shared<Chassis>();\n  apollo::common::util::FillHeader(model_name, chassis.get());\n\n  chassis->set_engine_started(true);\n  chassis->set_speed_mps(current_point_.speed());\n  chassis->set_odometer_m(current_point_.odometer());\n\n  if (FLAGS_enable_steering_latency) {\n    chassis->set_steering_percentage(filtered_control_cmd_.steering_target());\n  } else {\n    chassis->set_steering_percentage(control_cmd_.steering_target());\n  }\n  chassis->set_throttle_percentage(control_cmd_.throttle());\n  chassis->set_brake_percentage(control_cmd_.brake());\n  if (start_auto_) {\n    chassis->set_driving_mode(Chassis::COMPLETE_AUTO_DRIVE);\n  } else {\n    chassis->set_driving_mode(Chassis::COMPLETE_MANUAL);\n  }\n  chassis->set_gear_location(control_cmd_.gear_location());\n  chassis_writer_->Write(chassis);\n}\n\n/**\n * @brief publish prediction info\n *\n */\nvoid SimControlWithModelBase::PublishDummyPrediction() {\n  auto prediction = std::make_shared<PredictionObstacles>();\n  {\n    std::lock_guard<std::mutex> lock(mutex_);\n    if (!send_dummy_prediction_) {\n      return;\n    }\n    FillHeader(\"SimMlpPrediction\", prediction.get());\n  }\n  prediction_writer_->Write(prediction);\n}\n\nvoid SimControlWithModelBase::PublishLocalization(\n    const std::string model_name) {\n  auto localization = std::make_shared<LocalizationEstimate>();\n  FillHeader(model_name, localization.get());\n\n  auto* pose = localization->mutable_pose();\n\n  // Set position\n  pose->mutable_position()->set_x(current_point_.x());\n  pose->mutable_position()->set_y(current_point_.y());\n  pose->mutable_position()->set_z(0.0);\n  // Set orientation and heading\n  double cur_theta = current_point_.theta();\n\n  Eigen::Quaternion<double> cur_orientation =\n      HeadingToQuaternion<double>(cur_theta);\n  ADEBUG << \"cur_theta\" << cur_theta;\n  ADEBUG << \"cur_orientation_w\" << cur_orientation.w() << \"cur_orientation_x\"\n         << cur_orientation.x() << \"cur_orientation_y\" << cur_orientation.y()\n         << \"cur_orientation_z\" << cur_orientation.z();\n  pose->mutable_orientation()->set_qw(cur_orientation.w());\n  pose->mutable_orientation()->set_qx(cur_orientation.x());\n  pose->mutable_orientation()->set_qy(cur_orientation.y());\n  pose->mutable_orientation()->set_qz(cur_orientation.z());\n  pose->set_heading(cur_theta);\n\n  // Set linear_velocity\n  if (control_cmd_.gear_location() == Chassis::GEAR_REVERSE) {\n    pose->mutable_linear_velocity()->set_x(std::cos(cur_theta) * -1.0 *\n                                           current_point_.speed());\n    pose->mutable_linear_velocity()->set_y(std::sin(cur_theta) * -1.0 *\n                                           current_point_.speed());\n  } else {\n    pose->mutable_linear_velocity()->set_x(std::cos(cur_theta) *\n                                           current_point_.speed());\n    pose->mutable_linear_velocity()->set_y(std::sin(cur_theta) *\n                                           current_point_.speed());\n  }\n\n  pose->mutable_linear_velocity()->set_z(0);\n\n  // Set angular_velocity in both map reference frame and vehicle reference\n  // frame\n  double cur_curvature = std::tan(control_cmd_.steering_target() *\n                                  vehicle_param_.max_steer_angle() / 100.0 /\n                                  vehicle_param_.steer_ratio()) /\n                         vehicle_param_.wheel_base();\n\n  pose->mutable_angular_velocity()->set_x(0);\n  pose->mutable_angular_velocity()->set_y(0);\n  pose->mutable_angular_velocity()->set_z(current_point_.speed() *\n                                          cur_curvature);\n\n  TransformToVRF(pose->angular_velocity(), pose->orientation(),\n                 pose->mutable_angular_velocity_vrf());\n\n  // Set linear_acceleration in both map reference frame and vehicle reference\n  // frame\n  auto* linear_acceleration = pose->mutable_linear_acceleration();\n  linear_acceleration->set_x(std::cos(cur_theta) *\n                             current_point_.acceleration_s());\n  linear_acceleration->set_y(std::sin(cur_theta) *\n                             current_point_.acceleration_s());\n  linear_acceleration->set_z(0);\n\n  TransformToVRF(pose->linear_acceleration(), pose->orientation(),\n                 pose->mutable_linear_acceleration_vrf());\n\n  localization_writer_->Write(localization);\n\n  adc_position_.set_x(pose->position().x());\n  adc_position_.set_y(pose->position().y());\n  adc_position_.set_z(pose->position().z());\n}\n\n}  // namespace dreamview\n}  // namespace apollo",
        "base_contents": "",
        "res_region": "/******************************************************************************\n * Copyright 2019 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *****************************************************************************/\n\n#include \"modules/dreamview/backend/sim_control_manager/core/sim_control_with_model_base.h\"\n\n#include \"modules/dreamview/backend/map/map_service.h\"\n\nnamespace apollo {\nnamespace dreamview {\n\nusing apollo::canbus::Chassis;\nusing apollo::common::Point3D;\nusing apollo::common::Quaternion;\nusing apollo::common::math::HeadingToQuaternion;\nusing apollo::common::math::InterpolateUsingLinearApproximation;\nusing apollo::common::math::InverseQuaternionRotate;\nusing apollo::common::math::NormalizeAngle;\nusing apollo::common::math::QuaternionToHeading;\nusing apollo::common::util::FillHeader;\nusing apollo::control::ControlCommand;\nusing apollo::localization::LocalizationEstimate;\nusing apollo::prediction::PredictionObstacles;\nusing apollo::routing::RoutingRequest;\nusing apollo::routing::RoutingResponse;\nusing apollo::sim_control::SimCarStatus;\nusing Json = nlohmann::json;\n\n/**\n * @brief Construct a new Sim Control With Model Base:: Sim Control With Model\n * Base object\n * @param node_name: depens on different dynamic model\n */\nSimControlWithModelBase::SimControlWithModelBase(const std::string& node_name)\n    : node_(cyber::CreateNode(node_name)),\n      gear_position_(0),\n      dt_(0.01),\n      map_service_(new MapService()) {\n  InitTimerAndIO();\n}\n\nvoid SimControlWithModelBase::InitTimerAndIO() {\n  // Setup  control result data callback.\n  cyber::ReaderConfig control_cmd_reader_config;\n  control_cmd_reader_config.channel_name = FLAGS_control_command_topic;\n  control_cmd_reader_config.pending_queue_size =\n      FLAGS_reader_pending_queue_size;\n  prediction_reader_ = node_->CreateReader<PredictionObstacles>(\n      FLAGS_prediction_topic,\n      [this](const std::shared_ptr<PredictionObstacles>& obstacles) {\n        this->OnPredictionObstacles(obstacles);\n      });\n  control_command_reader_ = node_->CreateReader<ControlCommand>(\n      control_cmd_reader_config,\n      [this](const std::shared_ptr<ControlCommand>& cmd) {\n        ADEBUG << \"Received control data: run canbus callback.\";\n        OnControlCommand(*cmd);\n      });\n  // Setup routing callback.\n  cyber::ReaderConfig routing_reader_config;\n  routing_reader_config.channel_name = FLAGS_routing_response_topic;\n  routing_reader_config.pending_queue_size = FLAGS_reader_pending_queue_size;\n  routing_reader_ = node_->CreateReader<RoutingResponse>(\n      routing_reader_config,\n      [this](const std::shared_ptr<RoutingResponse>& cmd) {\n        ADEBUG << \"Received routing data: run canbus callback.\";\n        OnRoutingResponse(*cmd);\n      });\n  routing_request_reader_ = node_->CreateReader<RoutingRequest>(\n      FLAGS_routing_request_topic,\n      [this](const std::shared_ptr<RoutingRequest>& routing_request) {\n        this->OnRoutingRequest(routing_request);\n      });\n\n  // Setup localization callback.\n  cyber::ReaderConfig localization_reader_config;\n  localization_reader_config.channel_name = FLAGS_localization_topic;\n  localization_reader_config.pending_queue_size =\n      FLAGS_reader_pending_queue_size;\n  localization_reader_ = node_->CreateReader<LocalizationEstimate>(\n      localization_reader_config, nullptr);\n\n  localization_writer_ =\n      node_->CreateWriter<LocalizationEstimate>(FLAGS_localization_topic);\n  chassis_writer_ = node_->CreateWriter<Chassis>(FLAGS_chassis_topic);\n  prediction_writer_ =\n      node_->CreateWriter<PredictionObstacles>(FLAGS_prediction_topic);\n\n  // Start timer to publish localization and chassis messages.\n  sim_control_timer_.reset(new cyber::Timer(\n      kModelIntervalMs, [this]() { this->RunOnce(); }, false));\n  sim_prediction_timer_.reset(new cyber::Timer(\n      kSimPredictionIntervalMs, [this]() { this->PublishDummyPrediction(); },\n      false));\n}\n\nvoid SimControlWithModelBase::UpdateGearPosition() {\n  // update gear location, 1 drive, -1 reverse, 0 for other states\n  if (control_cmd_.gear_location() == Chassis::GEAR_DRIVE) {\n    gear_position_ = 1;\n  } else if (control_cmd_.gear_location() == Chassis::GEAR_REVERSE) {\n    gear_position_ = -1;\n  } else {\n    gear_position_ = 0;\n  }\n  current_point_.set_gear_position(gear_position_);\n}\n\nvoid SimControlWithModelBase::OnPredictionObstacles(\n    const std::shared_ptr<PredictionObstacles>& obstacles) {\n  std::lock_guard<std::mutex> lock(mutex_);\n  if (!enabled_) {\n    return;\n  }\n  send_dummy_prediction_ =\n      obstacles->header().module_name() == \"SimDMPrediction\";\n}\n\nvoid SimControlWithModelBase::Start() {\n  std::lock_guard<std::mutex> lock(mutex_);\n  if (!enabled_) {\n    InternalReset();\n    // todo: Compatible with scenario conf and default value\n    Json start_point_attr({});\n    // start_point_attr:from scenario conf json or default value.here dm is\n    // divided from scenario use default value\n    start_point_attr[\"start_velocity\"] = 0.0;\n    start_point_attr[\"start_acceleration\"] = 0.0;\n    start_point_attr[\"start_heading\"] = std::numeric_limits<double>::max();\n    Init(true, start_point_attr);\n    sim_control_timer_->Start();\n    sim_prediction_timer_->Start();\n    enabled_ = true;\n  }\n}\n\nvoid SimControlWithModelBase::Start(double x, double y) {\n  std::lock_guard<std::mutex> lock(mutex_);\n  if (!enabled_) {\n    InternalReset();\n    Json start_point_attr({});\n    start_point_attr[\"start_velocity\"] = 0.0;\n    start_point_attr[\"start_acceleration\"] = 0.0;\n    start_point_attr[\"start_heading\"] = std::numeric_limits<double>::max();\n    start_point_attr[\"x\"] = x;\n    start_point_attr[\"y\"] = y;\n    Init(true, start_point_attr, true);\n    sim_control_timer_->Start();\n    sim_prediction_timer_->Start();\n    enabled_ = true;\n  }\n}\n\nvoid SimControlWithModelBase::Stop() {\n  std::lock_guard<std::mutex> lock(mutex_);\n\n  if (enabled_) {\n    sim_control_timer_->Stop();\n    sim_prediction_timer_->Stop();\n    enabled_ = false;\n  }\n}\n\nvoid SimControlWithModelBase::Reset() {\n  std::lock_guard<std::mutex> lock(mutex_);\n  InternalReset();\n}\n\nvoid SimControlWithModelBase::InternalReset() {\n  re_routing_triggered_ = false;\n  current_routing_header_.Clear();\n  start_auto_ = false;\n  send_dummy_prediction_ = true;\n}\n\nvoid SimControlWithModelBase::OnControlCommand(\n    const ControlCommand& control_cmd) {\n  std::lock_guard<std::mutex> lock(mutex_);\n  if (!enabled_) {\n    return;\n  }\n  control_cmd_ = control_cmd;\n}\n\nvoid SimControlWithModelBase::OnRoutingResponse(\n    const RoutingResponse& routing) {\n  std::lock_guard<std::mutex> lock(mutex_);\n  if (!enabled_) {\n    return;\n  }\n\n  CHECK_GE(routing.routing_request().waypoint_size(), 2)\n      << \"routing should have at least two waypoints\";\n\n  current_routing_header_ = routing.header();\n  // If this is from a planning re-routing request, or the start point has been\n  // initialized by an actual localization pose, don't reset the start point.\n  // re_routing_triggered_ =\n  //     routing.routing_request().header().module_name() == \"planning\";\n  // if (!re_routing_triggered_ && !start_point_from_localization_) {\n  //   CHECK_GE(routing.routing_request().waypoint_size(), 2)\n  //       << \"routing should have at least two waypoints\";\n  //   current_routing_header_ = routing.header();\n  //   const auto& start_pose = routing.routing_request().waypoint(0).pose();\n  //   SimCarStatus point;\n  //   point.set_x(start_pose.x());\n  //   point.set_y(start_pose.y());\n  //   point.set_acceleration_s(start_acceleration_);\n  //   point.set_speed(start_velocity_);\n  //   // Use configured heading if available, otherwise find heading based on\n  //   // first lane in routing response\n  //   double theta = 0.0;\n  //   if (start_heading_ < std::numeric_limits<double>::max()) {\n  //     theta = start_heading_;\n  //   } else if (routing.road_size() > 0) {\n  //     auto start_lane = routing.road(0).passage(0).segment(0);\n  //     theta =\n  //         map_service_->GetLaneHeading(start_lane.id(),\n  //         start_lane.start_s());\n  //   }\n  //   point.set_theta(theta);\n  //   SetStartPoint(point);\n  // }\n}\n\nvoid SimControlWithModelBase::OnRoutingRequest(\n    const std::shared_ptr<RoutingRequest>& routing_request) {\n  std::lock_guard<std::mutex> lock(mutex_);\n  if (!enabled_) {\n    return;\n  }\n\n  CHECK_GE(routing_request->waypoint_size(), 2)\n      << \"routing should have at least two waypoints\";\n  const auto& start_pose = routing_request->waypoint(0).pose();\n\n  SimCarStatus point;\n  point.set_x(start_pose.x());\n  point.set_y(start_pose.y());\n  point.set_acceleration_s(start_acceleration_);\n  point.set_speed(start_velocity_);\n  // Use configured heading if available, otherwise find heading based on\n  // first lane in routing response\n  double theta = 0.0;\n  double s = 0.0;\n  const auto& start_way_point = routing_request->waypoint().Get(0);\n  // If the lane id has been set, set theta as the lane heading.\n  if (start_way_point.has_id()) {\n    auto& hdmap = hdmap::HDMapUtil::BaseMap();\n    hdmap::Id lane_id = hdmap::MakeMapId(start_way_point.id());\n    auto lane = hdmap.GetLaneById(lane_id);\n    if (nullptr != lane) {\n      theta = lane->Heading(start_way_point.s());\n    } else {\n      map_service_->GetPoseWithRegardToLane(start_pose.x(), start_pose.y(),\n                                            &theta, &s);\n    }\n  } else {\n    // Find the lane nearest to the start pose and get its heading as theta.\n    map_service_->GetPoseWithRegardToLane(start_pose.x(), start_pose.y(),\n                                          &theta, &s);\n  }\n  point.set_theta(theta);\n  // if (start_heading_ < std::numeric_limits<double>::max()) {\n  //   theta = start_heading_;\n  // } else if (routing_request.road_size() > 0) {\n  //   auto start_lane = routing_request.road(0).passage(0).segment(0);\n  //   theta = map_service_->GetLaneHeading(start_lane.id(),\n  //   start_lane.start_s());\n  // }\n  // point.set_theta(theta);\n  SetStartPoint(point);\n}\n\nvoid SimControlWithModelBase::SetStartPoint(const SimCarStatus& point) {\n  previous_point_ = point;\n}\n\nvoid SimControlWithModelBase::InitStartPoint(nlohmann::json start_point_attr,\n                                             bool use_start_point_position) {\n  AINFO << \"Init start point with position!\";\n\n  start_velocity_ = start_point_attr[\"start_velocity\"];\n  start_acceleration_ = start_point_attr[\"start_acceleration\"];\n  start_heading_ = start_point_attr[\"start_heading\"];\n  SimCarStatus point;\n  localization_reader_->Observe();\n  if (use_start_point_position) {\n    // add start point position for dynamic model\n    // new add feature to keep same with simcontrol\n    start_point_from_localization_ = false;\n    point.set_x(start_point_attr[\"x\"]);\n    point.set_y(start_point_attr[\"y\"]);\n    // z use default 0\n    point.set_z(0);\n    // Todo(@lijin): tmp not support map service,support theta\n    // double theta = 0.0;\n    // double s = 0.0;\n    // map_service_->GetPoseWithRegardToLane(x, y, &theta, &s);\n    // point.set_theta();\n    point.set_speed(start_velocity_);\n    point.set_acceleration_s(start_acceleration_);\n  } else {\n    if (localization_reader_->Empty()) {\n      // Routing will provide all other pose info\n      start_point_from_localization_ = false;\n      point.set_speed(start_velocity_);\n      point.set_acceleration_s(start_acceleration_);\n    } else {\n      start_point_from_localization_ = true;\n      const auto& pose = localization_reader_->GetLatestObserved()->pose();\n\n      point.set_x(pose.position().x());\n      point.set_y(pose.position().y());\n      point.set_z(pose.position().z());\n      point.set_theta(pose.heading());\n      point.set_speed(\n          std::hypot(pose.linear_velocity().x(), pose.linear_velocity().y()));\n      // Calculates the dot product of acceleration and velocity. The sign\n      // of this projection indicates whether this is acceleration or\n      // deceleration.\n      double projection =\n          pose.linear_acceleration().x() * pose.linear_velocity().x() +\n          pose.linear_acceleration().y() * pose.linear_velocity().y();\n\n      // Calculates the magnitude of the acceleration. Negate the value if\n      // it is indeed a deceleration.\n      double magnitude = std::hypot(pose.linear_acceleration().x(),\n                                    pose.linear_acceleration().y());\n      point.set_acceleration_s(std::signbit(projection) ? -magnitude\n                                                        : magnitude);\n      // Set init gear to neutral position\n      point.set_gear_position(0);\n    }\n  }\n  SetStartPoint(point);\n}\n\n/**\n * @brief pubish chassis info\n *\n * @param model_name\n */\nvoid SimControlWithModelBase::PublishChassis(const std::string model_name) {\n  auto chassis = std::make_shared<Chassis>();\n  apollo::common::util::FillHeader(model_name, chassis.get());\n\n  chassis->set_engine_started(true);\n  chassis->set_speed_mps(current_point_.speed());\n  chassis->set_odometer_m(current_point_.odometer());\n\n  if (FLAGS_enable_steering_latency) {\n    chassis->set_steering_percentage(filtered_control_cmd_.steering_target());\n  } else {\n    chassis->set_steering_percentage(control_cmd_.steering_target());\n  }\n  chassis->set_throttle_percentage(control_cmd_.throttle());\n  chassis->set_brake_percentage(control_cmd_.brake());\n  if (start_auto_) {\n    chassis->set_driving_mode(Chassis::COMPLETE_AUTO_DRIVE);\n  } else {\n    chassis->set_driving_mode(Chassis::COMPLETE_MANUAL);\n  }\n  chassis->set_gear_location(control_cmd_.gear_location());\n  chassis_writer_->Write(chassis);\n}\n\n/**\n * @brief publish prediction info\n *\n */\nvoid SimControlWithModelBase::PublishDummyPrediction() {\n  auto prediction = std::make_shared<PredictionObstacles>();\n  {\n    std::lock_guard<std::mutex> lock(mutex_);\n    if (!send_dummy_prediction_) {\n      return;\n    }\n    FillHeader(\"SimDMPrediction\", prediction.get());\n  }\n  prediction_writer_->Write(prediction);\n}\n\nvoid SimControlWithModelBase::PublishLocalization(\n    const std::string model_name) {\n  auto localization = std::make_shared<LocalizationEstimate>();\n  FillHeader(model_name, localization.get());\n\n  auto* pose = localization->mutable_pose();\n\n  // Set position\n  pose->mutable_position()->set_x(current_point_.x());\n  pose->mutable_position()->set_y(current_point_.y());\n  pose->mutable_position()->set_z(0.0);\n  // Set orientation and heading\n  double cur_theta = current_point_.theta();\n\n  Eigen::Quaternion<double> cur_orientation =\n      HeadingToQuaternion<double>(cur_theta);\n  ADEBUG << \"cur_theta\" << cur_theta;\n  ADEBUG << \"cur_orientation_w\" << cur_orientation.w() << \"cur_orientation_x\"\n         << cur_orientation.x() << \"cur_orientation_y\" << cur_orientation.y()\n         << \"cur_orientation_z\" << cur_orientation.z();\n  pose->mutable_orientation()->set_qw(cur_orientation.w());\n  pose->mutable_orientation()->set_qx(cur_orientation.x());\n  pose->mutable_orientation()->set_qy(cur_orientation.y());\n  pose->mutable_orientation()->set_qz(cur_orientation.z());\n  pose->set_heading(cur_theta);\n\n  // Set linear_velocity\n  if (control_cmd_.gear_location() == Chassis::GEAR_REVERSE) {\n    pose->mutable_linear_velocity()->set_x(std::cos(cur_theta) * -1.0 *\n                                           current_point_.speed());\n    pose->mutable_linear_velocity()->set_y(std::sin(cur_theta) * -1.0 *\n                                           current_point_.speed());\n  } else {\n    pose->mutable_linear_velocity()->set_x(std::cos(cur_theta) *\n                                           current_point_.speed());\n    pose->mutable_linear_velocity()->set_y(std::sin(cur_theta) *\n                                           current_point_.speed());\n  }\n\n  pose->mutable_linear_velocity()->set_z(0);\n\n  // Set angular_velocity in both map reference frame and vehicle reference\n  // frame\n  double cur_curvature = std::tan(control_cmd_.steering_target() *\n                                  vehicle_param_.max_steer_angle() / 100.0 /\n                                  vehicle_param_.steer_ratio()) /\n                         vehicle_param_.wheel_base();\n\n  pose->mutable_angular_velocity()->set_x(0);\n  pose->mutable_angular_velocity()->set_y(0);\n  pose->mutable_angular_velocity()->set_z(current_point_.speed() *\n                                          cur_curvature);\n\n  TransformToVRF(pose->angular_velocity(), pose->orientation(),\n                 pose->mutable_angular_velocity_vrf());\n\n  // Set linear_acceleration in both map reference frame and vehicle reference\n  // frame\n  auto* linear_acceleration = pose->mutable_linear_acceleration();\n  linear_acceleration->set_x(std::cos(cur_theta) *\n                             current_point_.acceleration_s());\n  linear_acceleration->set_y(std::sin(cur_theta) *\n                             current_point_.acceleration_s());\n  linear_acceleration->set_z(0);\n\n  TransformToVRF(pose->linear_acceleration(), pose->orientation(),\n                 pose->mutable_linear_acceleration_vrf());\n\n  localization_writer_->Write(localization);\n\n  adc_position_.set_x(pose->position().x());\n  adc_position_.set_y(pose->position().y());\n  adc_position_.set_z(pose->position().z());\n}\n\n}  // namespace dreamview\n}  // namespace apollo",
        "lookback": " * Copyright 2019 The Apollo Authors. All Rights Reserved.",
        "lookahead": "",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 0,
        "end_line": 944,
        "merge_gen_region": " Copyright Thepol Authors All Reserved/****************************************************************************** Copyright Thepol Authors All Reserved * Licensed the Apache, 20theLicense * may use file in with the. * may a of License * may a of License * * httpwwwapacheorglicensesLICENSE20 * Unless by law agreed in,, * under License distributed anAS\" BASIS * WARRANTIES CONDITIONS ANY, either or. See License the for specific governing and limitations the License *****************************************************************************/includemodulesdrviewbackendsimcontrolmanagercoresimcontrolwithmodelbaseh # \"/eam////////////////////////////mapmapserviceh namespacepol { drview using alocan::ass; alocommonPointD usingpol::::; alocommonQuaternion usingpol::::::::::::ingQuaternion usingpol::::::polateLinearproximation usingpol::::::::::::3Rotate usingpol::::::::::::Angle usingpol::::::::To; alocommonmathInterUsingApimation usingpol::::::::::::::InfoUsingApimation usingpol::::::::::Info usingpol::::::Angle usingpol::::::Toing usingpol::::::",
        "confidence": 0.9490457773208618,
        "hesitated": false,
        "resolved": false
    }
]