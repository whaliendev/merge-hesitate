[
    {
        "a_contents": "/******************************************************************************\n * Copyright 2022 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *****************************************************************************/\n\n#include \"modules/perception/camera/lib/obstacle/preprocessor/get_image_data/get_image_data.h\"\n\n#include \"cyber/common/file.h\"\n#include \"cyber/common/log.h\"\n\nnamespace apollo {\nnamespace perception {\nnamespace camera {\n\nGetImageData::GetImageData(const PluginConfig& plugin_config) {\n  Init(plugin_config);\n}\n\nbool GetImageData::Init(const PluginConfig& plugin_config) {\n  ACHECK(plugin_config.has_get_image_data_config());\n\n  auto image_data_config = plugin_config.get_image_data_config();\n  image_origin_width_ = image_data_config.image_origin_width();\n  image_origin_height_ = image_data_config.image_origin_height();\n  image_origin_channel_ = image_data_config.image_origin_channel();\n  image_.reset(new base::Image8U(image_origin_height_, image_origin_width_,\n                                 base::Color::RGB));\n  return true;\n}\n\nbool GetImageData::Process(DataFrame* data_frame, float* k_inv,\n                           cv::Mat* image_cv) {\n  if (nullptr == data_frame) {\n    AERROR << \"Input null data_frame ptr.\";\n    return false;\n  }\n  if (nullptr == k_inv) {\n    AERROR << \"Input null k_inv ptr.\";\n    return false;\n  }\n  if (nullptr == image_cv) {\n    AERROR << \"Input null imag_cv ptr.\";\n    return false;\n  }\n  GetImage(*(data_frame->camera_frame), image_cv);\n  GetKInverse(*(data_frame->camera_frame), k_inv);\n\n  return true;\n}\n\nbool GetImageData::GetKInverse(const CameraFrame& frame, float* k_inv) {\n  const auto& camera_k_matrix = frame.camera_k_matrix.inverse();\n  for (size_t i = 0; i < 3; i++) {\n    size_t i3 = i * 3;\n    for (size_t j = 0; j < 3; j++) {\n      if (frame.data_provider->sensor_name() == \"front_12mm\") {\n        k_inv[i3 + j] = camera_k_matrix(i, j) * 2.f;\n      } else {\n        k_inv[i3 + j] = camera_k_matrix(i, j);\n      }\n    }\n  }\n  return true;\n}\n\nbool GetImageData::GetImage(const CameraFrame& frame, cv::Mat* image_cv) {\n  DataProvider::ImageOptions image_options;\n  image_options.target_color = base::Color::BGR;\n  image_options.crop_roi = base::RectI(\n      0, offset_y_, static_cast<int>(base_camera_model_->get_width()),\n      static_cast<int>(base_camera_model_->get_height()) - offset_y_);\n  image_options.do_crop = true;\n  frame.data_provider->GetImage(image_options, image_.get());\n\n  memcpy(image_cv->data, image_->cpu_data(),\n         image_origin_width_ * image_origin_height_ * image_origin_channel_ *\n             sizeof(uint8_t));\n\n  return true;\n}\n}  // namespace camera\n}  // namespace perception\n}  // namespace apollo",
        "b_contents": "/******************************************************************************\n * Copyright 2022 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *****************************************************************************/\n\n#include \"modules/perception/camera/lib/obstacle/preprocessor/get_image_data/get_image_data.h\"\n\n#include \"cyber/common/file.h\"\n#include \"cyber/common/log.h\"\n\nnamespace apollo {\nnamespace perception {\nnamespace camera {\n\nGetImageData::GetImageData(const PluginConfig& plugin_config) {\n  Init(plugin_config);\n}\n\nbool GetImageData::Init(const PluginConfig& plugin_config) {\n  ACHECK(plugin_config.has_get_image_data_config());\n\n  auto image_data_config = plugin_config.get_image_data_config();\n  image_origin_width_ = image_data_config.image_origin_width();\n  image_origin_height_ = image_data_config.image_origin_height();\n  image_origin_channel_ = image_data_config.image_origin_channel();\n  image_.reset(new base::Image8U(image_origin_height_, image_origin_width_,\n                                 base::Color::RGB));\n  return true;\n}\n\nbool GetImageData::Process(DataFrame* data_frame, float* k_inv,\n                           cv::Mat* image_cv) {\n  if (nullptr == data_frame) {\n    AERROR << \"Input null data_frame ptr.\";\n    return false;\n  }\n  if (nullptr == k_inv) {\n    AERROR << \"Input null k_inv ptr.\";\n    return false;\n  }\n  if (nullptr == image_cv) {\n    AERROR << \"Input null imag_cv ptr.\";\n    return false;\n  }\n  GetImage(*(data_frame->camera_frame), image_cv);\n  GetKInverse(*(data_frame->camera_frame), k_inv);\n\n  return true;\n}\n\nbool GetImageData::GetKInverse(const CameraFrame& frame, float* k_inv) {\n  const auto& camera_k_matrix = frame.camera_k_matrix.inverse();\n  for (size_t i = 0; i < 3; i++) {\n    size_t i3 = i * 3;\n    for (size_t j = 0; j < 3; j++) {\n      if (frame.data_provider->sensor_name() == \"front_12mm\") {\n        k_inv[i3 + j] = camera_k_matrix(i, j) * 2.f;\n      } else {\n        k_inv[i3 + j] = camera_k_matrix(i, j);\n      }\n    }\n  }\n  return true;\n}\n\nbool GetImageData::GetImage(const CameraFrame& frame, cv::Mat* image_cv) {\n  DataProvider::ImageOptions image_options;\n  image_options.target_color = base::Color::BGR;\n  image_options.crop_roi = base::RectI(\n      0, offset_y_, static_cast<int>(base_camera_model_->get_width()),\n      static_cast<int>(base_camera_model_->get_height()) - offset_y_);\n  image_options.do_crop = true;\n  frame.data_provider->GetImage(image_options, image_.get());\n\n  memcpy(image_cv->data, image_->cpu_data(),\n         image_origin_width_ * image_origin_height_ * image_origin_channel_ *\n             sizeof(uint8_t));\n\n  return true;\n}\n}  // namespace camera\n}  // namespace perception\n}  // namespace apollo",
        "base_contents": "",
        "res_region": "/******************************************************************************\n * Copyright 2022 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *****************************************************************************/\n\n#include \"modules/perception/camera/lib/obstacle/preprocessor/get_image_data/get_image_data.h\"\n\n#include \"cyber/common/file.h\"\n#include \"cyber/common/log.h\"\n\nnamespace apollo {\nnamespace perception {\nnamespace camera {\n\nGetImageData::GetImageData(const PluginConfig& plugin_config) {\n  Init(plugin_config);\n}\n\nbool GetImageData::Init(const PluginConfig& plugin_config) {\n  ACHECK(plugin_config.has_get_image_data_config());\n\n  auto image_data_config = plugin_config.get_image_data_config();\n  image_origin_width_ = image_data_config.image_origin_width();\n  image_origin_height_ = image_data_config.image_origin_height();\n  image_origin_channel_ = image_data_config.image_origin_channel();\n  image_.reset(new base::Image8U(image_origin_height_, image_origin_width_,\n                                 base::Color::RGB));\n  return true;\n}\n\nbool GetImageData::Process(DataFrame* data_frame, float* k_inv,\n                           cv::Mat* image_cv) {\n  if (nullptr == data_frame) {\n    AERROR << \"Input null data_frame ptr.\";\n    return false;\n  }\n  if (nullptr == k_inv) {\n    AERROR << \"Input null k_inv ptr.\";\n    return false;\n  }\n  if (nullptr == image_cv) {\n    AERROR << \"Input null imag_cv ptr.\";\n    return false;\n  }\n  GetImage(*(data_frame->camera_frame), image_cv);\n  GetKInverse(*(data_frame->camera_frame), k_inv);\n\n  return true;\n}\n\nbool GetImageData::GetKInverse(const CameraFrame& frame, float* k_inv) {\n  const auto& camera_k_matrix = frame.camera_k_matrix.inverse();\n  for (size_t i = 0; i < 3; i++) {\n    size_t i3 = i * 3;\n    for (size_t j = 0; j < 3; j++) {\n      if (frame.data_provider->sensor_name() == \"front_12mm\") {\n        k_inv[i3 + j] = camera_k_matrix(i, j) * 2.f;\n      } else {\n        k_inv[i3 + j] = camera_k_matrix(i, j);\n      }\n    }\n  }\n  return true;\n}\n\nbool GetImageData::GetImage(const CameraFrame& frame, cv::Mat* image_cv) {\n  DataProvider::ImageOptions image_options;\n  image_options.target_color = base::Color::BGR;\n  image_options.crop_roi = base::RectI(\n      0, offset_y_, static_cast<int>(base_camera_model_->get_width()),\n      static_cast<int>(base_camera_model_->get_height()) - offset_y_);\n  image_options.do_crop = true;\n  frame.data_provider->GetImage(image_options, image_.get());\n\n  memcpy(image_cv->data, image_->cpu_data(),\n         image_origin_width_ * image_origin_height_ * image_origin_channel_ *\n             sizeof(uint8_t));\n\n  return true;\n}\n}  // namespace camera\n}  // namespace perception\n}  // namespace apollo",
        "lookback": " * Copyright 2022 The Apollo Authors. All Rights Reserved.",
        "lookahead": "",
        "label": [
            "ours",
            "base_underutilized"
        ],
        "start_line": 0,
        "end_line": 191,
        "merge_gen_region": " Copyright022 Alo. Rights.scoped Copyright022 Apol Authors All Reserved * Licensed the Apache, 20theLicense *\"); you not this except in with the. * may a of License * may a of License * *://.///LICENSE20 * Unless by law agreed in writing software distributed the is on \" IS BASIS * WARRANTIES CONDITIONS ANY, express implied * the See License the for specific governing and limitations the License *****************************************************************************/includemodulesper///staclepre/___/___.\"includecy////.\"includecy/commonlogh namespacepol { namespaceception namespace {ImageData Get::DataconstConfig pluginconfig { Initpluginconfig } Get::InitconstConfig pluginconfig {CHECKpluginconfighasgetimagedataconfig auto__ =_.________()); imagedataconfig pluginconfiggetimagedataconfig imageoriginwidth_ imagedataconfigimageoriginwidth();_________________________ imagedataconfig imageoriginwidth_ imagedataconfigimageoriginwidth imageoriginheight = imagedataconfigimageoriginheight imageoriginchannel =__.._();_.( baseImageU",
        "confidence": 0.9288068413734436,
        "hesitated": false,
        "resolved": false
    }
]