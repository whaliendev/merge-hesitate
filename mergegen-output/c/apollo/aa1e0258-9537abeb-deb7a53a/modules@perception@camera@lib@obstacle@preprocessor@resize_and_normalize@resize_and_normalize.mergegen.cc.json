[
    {
        "a_contents": "/******************************************************************************\n * Copyright 2022 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *****************************************************************************/\n\n#include \"modules/perception/camera/lib/obstacle/preprocessor/resize_and_normalize/resize_and_normalize.h\"\n\n\nnamespace apollo {\nnamespace perception {\nnamespace camera {\n\nReSizeAndNormalize::ReSizeAndNormalize(const PluginConfig& plugin_config) {\n  Init(plugin_config);\n}\n\nbool ReSizeAndNormalize::Init(const PluginConfig &plugin_config) {\n  ACHECK(plugin_config.has_resize_and_normalize_config());\n\n  const auto& config = plugin_config.resize_and_normalize_config();\n  resized_width_ = config.resized_width();\n  resized_height_ = config.resized_height();\n  mean_[0] = config.mean_r();\n  mean_[1] = config.mean_g();\n  mean_[2] = config.mean_b();\n  std_[0] = config.std_r();\n  std_[1] = config.std_g();\n  std_[2] = config.std_b();\n  scale_ = config.scale();\n  return true;\n}\n\nbool ReSizeAndNormalize::Process(const cv::Mat &im, float *image_data_array) {\n  cv::Mat resized_image;\n  Resize(im, resized_height_, resized_width_, &resized_image);\n  Normalize(mean_, std_, scale_, &resized_image);\n  Mat2Vec(resized_image, image_data_array);\n  return true;\n}\n\nvoid ReSizeAndNormalize::Resize(const cv::Mat &img, int resized_h,\n                                int resized_w, cv::Mat *resize_img) {\n  cv::resize(img, *resize_img, cv::Size(resized_h, resized_w), 0, 0,\n             cv::INTER_LINEAR);\n}\n\nvoid ReSizeAndNormalize::Normalize(const std::vector<float> &mean,\n                                   const std::vector<float> &std, float scale,\n                                   cv::Mat *im) {\n  if (scale) {\n    (*im).convertTo(*im, CV_32FC3, scale);\n  }\n  for (int h = 0; h < im->rows; h++) {\n    for (int w = 0; w < im->cols; w++) {\n      im->at<cv::Vec3f>(h, w)[0] =\n          (im->at<cv::Vec3f>(h, w)[0] - mean[0]) / std[0];\n      im->at<cv::Vec3f>(h, w)[1] =\n          (im->at<cv::Vec3f>(h, w)[1] - mean[1]) / std[1];\n      im->at<cv::Vec3f>(h, w)[2] =\n          (im->at<cv::Vec3f>(h, w)[2] - mean[2]) / std[2];\n    }\n  }\n}\n\nvoid ReSizeAndNormalize::Mat2Vec(const cv::Mat &im, float *image_data_array) {\n  int rh = im.rows;\n  int rw = im.cols;\n  int rc = im.channels();\n  for (int i = 0; i < rc; ++i) {\n    cv::extractChannel(\n        im, cv::Mat(rh, rw, CV_32FC1, image_data_array + i * rh * rw), i);\n  }\n}\n\n}  // namespace camera\n}  // namespace perception\n}  // namespace apollo",
        "b_contents": "/******************************************************************************\n * Copyright 2022 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *****************************************************************************/\n\n#include \"modules/perception/camera/lib/obstacle/preprocessor/resize_and_normalize/resize_and_normalize.h\"\n\n\nnamespace apollo {\nnamespace perception {\nnamespace camera {\n\nReSizeAndNormalize::ReSizeAndNormalize(const PluginConfig& plugin_config) {\n  Init(plugin_config);\n}\n\nbool ReSizeAndNormalize::Init(const PluginConfig &plugin_config) {\n  ACHECK(plugin_config.has_resize_and_normalize_config());\n\n  const auto& config = plugin_config.resize_and_normalize_config();\n  resized_width_ = config.resized_width();\n  resized_height_ = config.resized_height();\n  mean_[0] = config.mean_r();\n  mean_[1] = config.mean_g();\n  mean_[2] = config.mean_b();\n  std_[0] = config.std_r();\n  std_[1] = config.std_g();\n  std_[2] = config.std_b();\n  scale_ = config.scale();\n  return true;\n}\n\nbool ReSizeAndNormalize::Process(cv::Mat &im, float *image_data_array) {\n  cv::Mat resized_image;\n  Resize(im, resized_height_, resized_width_, &resized_image);\n  Normalize(mean_, std_, scale_, &resized_image);\n  Mat2Vec(resized_image, image_data_array);\n  return true;\n}\n\nvoid ReSizeAndNormalize::Resize(const cv::Mat &img, int resized_h,\n                                int resized_w, cv::Mat *resize_img) {\n  cv::resize(img, *resize_img, cv::Size(resized_h, resized_w), 0, 0,\n             cv::INTER_LINEAR);\n}\n\nvoid ReSizeAndNormalize::Normalize(const std::vector<float> &mean,\n                                   const std::vector<float> &std, float scale,\n                                   cv::Mat *im) {\n  if (scale) {\n    (*im).convertTo(*im, CV_32FC3, scale);\n  }\n  for (int h = 0; h < im->rows; h++) {\n    for (int w = 0; w < im->cols; w++) {\n      im->at<cv::Vec3f>(h, w)[0] =\n          (im->at<cv::Vec3f>(h, w)[0] - mean[0]) / std[0];\n      im->at<cv::Vec3f>(h, w)[1] =\n          (im->at<cv::Vec3f>(h, w)[1] - mean[1]) / std[1];\n      im->at<cv::Vec3f>(h, w)[2] =\n          (im->at<cv::Vec3f>(h, w)[2] - mean[2]) / std[2];\n    }\n  }\n}\n\nvoid ReSizeAndNormalize::Mat2Vec(const cv::Mat &im, float *image_data_array) {\n  int rh = im.rows;\n  int rw = im.cols;\n  int rc = im.channels();\n  for (int i = 0; i < rc; ++i) {\n    cv::extractChannel(\n        im, cv::Mat(rh, rw, CV_32FC1, image_data_array + i * rh * rw), i);\n  }\n}\n\n}  // namespace camera\n}  // namespace perception\n}  // namespace apollo",
        "base_contents": "",
        "res_region": "/******************************************************************************\n * Copyright 2022 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *****************************************************************************/\n\n#include \"modules/perception/camera/lib/obstacle/preprocessor/resize_and_normalize/resize_and_normalize.h\"\n\n\nnamespace apollo {\nnamespace perception {\nnamespace camera {\n\nReSizeAndNormalize::ReSizeAndNormalize(const PluginConfig& plugin_config) {\n  Init(plugin_config);\n}\n\nbool ReSizeAndNormalize::Init(const PluginConfig &plugin_config) {\n  ACHECK(plugin_config.has_resize_and_normalize_config());\n\n  const auto& config = plugin_config.resize_and_normalize_config();\n  resized_width_ = config.resized_width();\n  resized_height_ = config.resized_height();\n  mean_[0] = config.mean_r();\n  mean_[1] = config.mean_g();\n  mean_[2] = config.mean_b();\n  std_[0] = config.std_r();\n  std_[1] = config.std_g();\n  std_[2] = config.std_b();\n  scale_ = config.scale();\n  return true;\n}\n\nbool ReSizeAndNormalize::Process(const cv::Mat &im, float *image_data_array) {\n  cv::Mat resized_image;\n  Resize(im, resized_height_, resized_width_, &resized_image);\n  Normalize(mean_, std_, scale_, &resized_image);\n  Mat2Vec(resized_image, image_data_array);\n  return true;\n}\n\nvoid ReSizeAndNormalize::Resize(const cv::Mat &img, int resized_h,\n                                int resized_w, cv::Mat *resize_img) {\n  cv::resize(img, *resize_img, cv::Size(resized_h, resized_w), 0, 0,\n             cv::INTER_LINEAR);\n}\n\nvoid ReSizeAndNormalize::Normalize(const std::vector<float> &mean,\n                                   const std::vector<float> &std, float scale,\n                                   cv::Mat *im) {\n  if (scale) {\n    (*im).convertTo(*im, CV_32FC3, scale);\n  }\n  for (int h = 0; h < im->rows; h++) {\n    for (int w = 0; w < im->cols; w++) {\n      im->at<cv::Vec3f>(h, w)[0] =\n          (im->at<cv::Vec3f>(h, w)[0] - mean[0]) / std[0];\n      im->at<cv::Vec3f>(h, w)[1] =\n          (im->at<cv::Vec3f>(h, w)[1] - mean[1]) / std[1];\n      im->at<cv::Vec3f>(h, w)[2] =\n          (im->at<cv::Vec3f>(h, w)[2] - mean[2]) / std[2];\n    }\n  }\n}\n\nvoid ReSizeAndNormalize::Mat2Vec(const cv::Mat &im, float *image_data_array) {\n  int rh = im.rows;\n  int rw = im.cols;\n  int rc = im.channels();\n  for (int i = 0; i < rc; ++i) {\n    cv::extractChannel(\n        im, cv::Mat(rh, rw, CV_32FC1, image_data_array + i * rh * rw), i);\n  }\n}\n\n}  // namespace camera\n}  // namespace perception\n}  // namespace apollo",
        "lookback": " * Copyright 2022 The Apollo Authors. All Rights Reserved.",
        "lookahead": "",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 0,
        "end_line": 179,
        "merge_gen_region": " Copyright022 Alo. Rights.scoped Licensed the License Version. (theLicense *\"); you not this except in with the. * may a of License * may a of License * *://..///-.0 * Unless by applicable or to writing software distributed the is on \" IS BASIS * WARRANTIES CONDITIONS ANY, express implied * the See License the for specific governing and limitations the License *****************************************************************************/includemodulesper///staclepre/__.///////staclepre/_.//////staclepre/_.////staclepre/_./////staclepre/_.///_//staclepre/_.//_//_///staclepre/__///_////staclepre/_.//_//staclepre/_.//_//_///_///staclepre/_.///_////staclepre/_.////_////_/////staclepre/_.////_//////staclepre/_.////",
        "confidence": 0.9220460653305054,
        "hesitated": false,
        "resolved": false
    }
]