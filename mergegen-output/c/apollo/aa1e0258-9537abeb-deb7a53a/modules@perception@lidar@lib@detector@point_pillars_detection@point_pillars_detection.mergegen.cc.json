[
    {
        "a_contents": "bool PointPillarsDetection::Init(const StageConfig& stage_config) {\n  if (!Initialize(stage_config)) {\n    return false;\n  }\n\n  // ACHECK(stage_config.has_pointpillars_detection());\n  point_pillars_detection_config_ =\n      stage_config.point_pillars_detection_config();\n\n  point_pillars_ptr_.reset(\n      new PointPillars(FLAGS_reproduce_result_mode, FLAGS_score_threshold,\n                       FLAGS_nms_overlap_threshold, FLAGS_pfe_torch_file,\n                       FLAGS_scattered_torch_file, FLAGS_backbone_torch_file,\n                       FLAGS_fpn_torch_file, FLAGS_bbox_head_torch_file));\n  return true;\n}\n\nbool PointPillarsDetection::Process(DataFrame* data_frame) {\n  if (data_frame == nullptr) return false;\n\n  LidarFrame* lidar_frame = data_frame->lidar_frame;\n  if (lidar_frame == nullptr) return false;\n\n  LidarDetectorOptions options;\n  bool res = Detect(options, lidar_frame);\n  return res;\n}\n\nbool PointPillarsDetection::Process(const std::vector<float>& points_array,\n                                    int num_points,\n                                    std::vector<float>* out_detections,\n                                    std::vector<int>* out_labels,\n                                    DataFrame* frame) {\n  if (nullptr == out_detections) {\n    AERROR << \"Input null out_detections ptr.\";\n    return false;\n  }\n\n  if (nullptr == out_labels) {\n    AERROR << \"Input null out_labels ptr.\";\n    return false;\n  }\n  auto lidar_frame = frame->lidar_frame;\n  Detect(points_array, num_points, out_detections, out_labels, lidar_frame);\n  return true;\n}\n",
        "b_contents": "bool PointPillarsDetection::Init(const StageConfig& stage_config) {\n  if (!Initialize(stage_config)) {\n    return false;\n  }\n\n  // ACHECK(stage_config.has_pointpillars_detection());\n  point_pillars_detection_config_ = stage_config.pointpillars_detection();\n\n  point_pillars_ptr_.reset(\n      new PointPillars(FLAGS_reproduce_result_mode, FLAGS_score_threshold,\n                       FLAGS_nms_overlap_threshold, FLAGS_pfe_torch_file,\n                       FLAGS_scattered_torch_file, FLAGS_backbone_torch_file,\n                       FLAGS_fpn_torch_file, FLAGS_bbox_head_torch_file));\n  return true;\n}\n\nbool PointPillarsDetection::Process(DataFrame* data_frame) {\n  if (data_frame == nullptr)\n    return false;\n\n  LidarFrame* lidar_frame = data_frame->lidar_frame;\n  if (lidar_frame == nullptr)\n    return false;\n\n  LidarDetectorOptions options;\n  bool res = Detect(options, lidar_frame);\n  return res;\n}\n\nbool PointPillarsDetection::Process(const std::vector<float>& points_array,\n                                    int num_points,\n                                    std::vector<float>* out_detections,\n                                    std::vector<int>* out_labels,\n                                    DataFrame* frame) {\n  if (nullptr == out_detections) {\n    AERROR << \"Input null out_detections ptr.\";\n    return false;\n  }\n\n  if (nullptr == out_labels) {\n    AERROR << \"Input null out_labels ptr.\";\n    return false;\n  }\n  auto lidar_frame = frame->lidar_frame;\n  Detect(points_array, num_points, out_detections, out_labels, lidar_frame);\n  return true;\n}\n",
        "base_contents": "",
        "res_region": "bool PointPillarsDetection::Init(const StageConfig& stage_config) {\n  if (!Initialize(stage_config)) {\n    return false;\n  }\n\n  // ACHECK(stage_config.has_pointpillars_detection());\n  point_pillars_detection_config_ =\n      stage_config.point_pillars_detection_config();\n\n  point_pillars_ptr_.reset(\n      new PointPillars(FLAGS_reproduce_result_mode, FLAGS_score_threshold,\n                       FLAGS_nms_overlap_threshold, FLAGS_pfe_torch_file,\n                       FLAGS_scattered_torch_file, FLAGS_backbone_torch_file,\n                       FLAGS_fpn_torch_file, FLAGS_bbox_head_torch_file));\n  return true;\n}\n\nbool PointPillarsDetection::Process(DataFrame* data_frame) {\n  if (data_frame == nullptr) return false;\n\n  LidarFrame* lidar_frame = data_frame->lidar_frame;\n  if (lidar_frame == nullptr) return false;\n\n  LidarDetectorOptions options;\n  bool res = Detect(options, lidar_frame);\n  return res;\n}\n\nbool PointPillarsDetection::Process(const std::vector<float>& points_array,\n                                    int num_points,\n                                    std::vector<float>* out_detections,\n                                    std::vector<int>* out_labels,\n                                    DataFrame* frame) {\n  if (nullptr == out_detections) {\n    AERROR << \"Input null out_detections ptr.\";\n    return false;\n  }\n\n  if (nullptr == out_labels) {\n    AERROR << \"Input null out_labels ptr.\";\n    return false;\n  }\n  auto lidar_frame = frame->lidar_frame;\n  Detect(points_array, num_points, out_detections, out_labels, lidar_frame);\n  return true;\n}\n",
        "lookback": "  if (!Initialize(stage_config)) {",
        "lookahead": "bool PointPillarsDetection::Detect(const LidarDetectorOptions& options,",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 60,
        "end_line": 158,
        "merge_gen_region": null,
        "confidence": 0.7832851409912109,
        "hesitated": true
    }
]