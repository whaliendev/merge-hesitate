[
    {
        "a_contents": "/******************************************************************************\n * Copyright 2018 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *****************************************************************************/\n#include \"modules/perception/onboard/component/lidar_tracking_component.h\"\n\n#include \"cyber/time/clock.h\"\n#include \"modules/common/util/perf_util.h\"\n#include \"modules/perception/base/object_pool_types.h\"\n#include \"modules/perception/common/sensor_manager/sensor_manager.h\"\n#include \"modules/perception/lidar/common/lidar_error_code.h\"\n#include \"modules/perception/lidar/common/lidar_log.h\"\n\nusing Clock = apollo::cyber::Clock;\n\nnamespace apollo {\nnamespace perception {\nnamespace onboard {\n\nusing apollo::cyber::common::GetAbsolutePath;\n\nbool LidarTrackingComponent::Init() {\n  LidarRecognitionComponentConfig comp_config;\n  if (!GetProtoConfig(&comp_config)) {\n    return false;\n  }\n  AINFO << \"Lidar Component Configs: \" << comp_config.DebugString();\n  output_channel_name_ = comp_config.output_channel_name();\n  main_sensor_name_ = comp_config.main_sensor_name();\n  writer_ = node_->CreateWriter<SensorFrameMessage>(output_channel_name_);\n\n  // read pipeline config\n  std::string lidar_tracking_conf_dir = comp_config.lidar_tracking_conf_dir();\n  std::string lidar_tracking_conf_file = comp_config.lidar_tracking_conf_file();\n\n  std::string work_root = \"\";\n  std::string lidar_tracking_config_path =\n      GetAbsolutePath(lidar_tracking_conf_dir, lidar_tracking_conf_file);\n  lidar_tracking_config_path =\n      GetAbsolutePath(work_root, lidar_tracking_config_path);\n\n  if (!cyber::common::GetProtoFromFile(\n          lidar_tracking_config_path, &lidar_tracking_config_)) {\n    AERROR << \"Read config failed: \" << lidar_tracking_config_path;\n    return false;\n  }\n\n  if (!InitAlgorithmPlugin()) {\n    AERROR << \"Failed to init recongnition component algorithm plugin.\";\n    return false;\n  }\n  return true;\n}\n\nbool LidarTrackingComponent::Proc(\n    const std::shared_ptr<LidarFrameMessage>& message) {\n  AINFO << std::setprecision(16)\n        << \"Enter Tracking component, message timestamp: \"\n        << message->timestamp_\n        << \" current timestamp: \" << Clock::NowInSeconds();\n\n  auto out_message = std::make_shared<SensorFrameMessage>();\n\n  if (InternalProc(message, out_message)) {\n    writer_->Write(out_message);\n    AINFO << \"Send lidar recognition output message.\";\n    return true;\n  }\n  return false;\n}\n\nbool LidarTrackingComponent::InitAlgorithmPlugin() {\n  tracker_.reset(new lidar::LidarObstacleTracking);\n  if (tracker_ == nullptr) {\n    AERROR << \"Failed to get tracking instance.\";\n    return false;\n  }\n\n  // lidar::LidarObstacleTrackingInitOptions init_options;\n  // init_options.sensor_name = main_sensor_name_;\n  // if (!tracker_->Init(init_options)) {\n  //   AERROR << \"Failed to init tracking.\";\n  //   return false;\n  // }\n\n  if (!tracker_->Init(lidar_tracking_config_)) {\n    AERROR << \"Failed to init tracking.\";\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarTrackingComponent::InternalProc(\n    const std::shared_ptr<const LidarFrameMessage>& in_message,\n    const std::shared_ptr<SensorFrameMessage>& out_message) {\n  auto& sensor_name = in_message->lidar_frame_->sensor_info.name;\n  PERF_FUNCTION_WITH_INDICATOR(sensor_name);\n  out_message->timestamp_ = in_message->timestamp_;\n  out_message->lidar_timestamp_ = in_message->lidar_timestamp_;\n  out_message->seq_num_ = in_message->seq_num_;\n  out_message->process_stage_ = ProcessStage::LIDAR_RECOGNITION;\n  out_message->sensor_id_ = sensor_name;\n\n  if (in_message->error_code_ != apollo::common::ErrorCode::OK) {\n    out_message->error_code_ = in_message->error_code_;\n    AERROR << \"Lidar recognition receive message with error code, skip it.\";\n    return true;\n  }\n\n  PERF_BLOCK_START();\n  auto& lidar_frame = in_message->lidar_frame_;\n  pipeline::DataFrame data_frame;\n  data_frame.lidar_frame = lidar_frame.get();\n  bool res = tracker_->Process(&data_frame);\n\n  PERF_BLOCK_END_WITH_INDICATOR(sensor_name, \"recognition_1::track_obstacle\");\n  if (!res) {\n    out_message->error_code_ =\n        apollo::common::ErrorCode::PERCEPTION_ERROR_PROCESS;\n    AERROR << \"Lidar recognition process error.\";\n    return true;\n  }\n\n  // PERF_BLOCK_START();\n  // auto& lidar_frame = in_message->lidar_frame_;\n  // lidar::LidarObstacleTrackingOptions track_options;\n  // track_options.sensor_name = sensor_name;\n  // lidar::LidarProcessResult ret =\n  //     tracker_->Process(track_options, lidar_frame.get());\n  // PERF_BLOCK_END_WITH_INDICATOR(sensor_name,\"recognition_1::track_obstacle\");\n  // if (ret.error_code != lidar::LidarErrorCode::Succeed) {\n  //   out_message->error_code_ =\n  //       apollo::common::ErrorCode::PERCEPTION_ERROR_PROCESS;\n  //   AERROR << \"Lidar recognition process error, \" << ret.log;\n  //   return true;\n  // }\n  // TODO(shigintmin)\n  out_message->hdmap_ = lidar_frame->hdmap_struct;\n  auto& frame = out_message->frame_;\n  frame = base::FramePool::Instance().Get();\n  frame->sensor_info = lidar_frame->sensor_info;\n  frame->timestamp = in_message->timestamp_;\n  frame->objects = lidar_frame->tracked_objects;\n  frame->sensor2world_pose = lidar_frame->lidar2world_pose;\n  frame->lidar_frame_supplement.on_use = true;\n  frame->lidar_frame_supplement.cloud_ptr = lidar_frame->cloud;\n  PERF_BLOCK_END_WITH_INDICATOR(sensor_name, \"recognition_2::fill_out_message\");\n\n  const double end_timestamp = Clock::NowInSeconds();\n  const double end_latency = (end_timestamp - in_message->timestamp_) * 1e3;\n  AINFO << std::setprecision(16) << \"FRAME_STATISTICS:Lidar:End:msg_time[\"\n        << in_message->timestamp_ << \"]:cur_time[\" << end_timestamp\n        << \"]:cur_latency[\" << end_latency << \"]\";\n  return true;\n}\n\n}  // namespace onboard\n}  // namespace perception\n}  // namespace apollo",
        "b_contents": "/******************************************************************************\n * Copyright 2018 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *****************************************************************************/\n#include \"modules/perception/onboard/component/lidar_tracking_component.h\"\n\n#include \"cyber/time/clock.h\"\n#include \"modules/common/util/perf_util.h\"\n#include \"modules/perception/base/object_pool_types.h\"\n#include \"modules/perception/common/sensor_manager/sensor_manager.h\"\n#include \"modules/perception/lidar/common/lidar_error_code.h\"\n#include \"modules/perception/lidar/common/lidar_log.h\"\n\nusing Clock = apollo::cyber::Clock;\n\nnamespace apollo {\nnamespace perception {\nnamespace onboard {\n\nusing apollo::cyber::common::GetAbsolutePath;\n\nbool LidarTrackingComponent::Init() {\n  LidarRecognitionComponentConfig comp_config;\n  if (!GetProtoConfig(&comp_config)) {\n    return false;\n  }\n  AINFO << \"Lidar Component Configs: \" << comp_config.DebugString();\n  output_channel_name_ = comp_config.output_channel_name();\n  main_sensor_name_ = comp_config.main_sensor_name();\n  writer_ = node_->CreateWriter<SensorFrameMessage>(output_channel_name_);\n\n  // read pipeline config\n  std::string lidar_tracking_conf_dir = comp_config.lidar_tracking_conf_dir();\n  std::string lidar_tracking_conf_file = comp_config.lidar_tracking_conf_file();\n\n  std::string work_root = \"\";\n  std::string lidar_tracking_config_path =\n      GetAbsolutePath(lidar_tracking_conf_dir, lidar_tracking_conf_file);\n  lidar_tracking_config_path =\n      GetAbsolutePath(work_root, lidar_tracking_config_path);\n\n  if (!cyber::common::GetProtoFromFile(\n          lidar_tracking_config_path, &lidar_tracking_config_)) {\n    AERROR << \"Read config failed: \" << lidar_tracking_config_path;\n    return false;\n  }\n\n  if (!InitAlgorithmPlugin()) {\n    AERROR << \"Failed to init recongnition component algorithm plugin.\";\n    return false;\n  }\n  return true;\n}\n\nbool LidarTrackingComponent::Proc(\n    const std::shared_ptr<LidarFrameMessage>& message) {\n  AINFO << std::setprecision(16)\n        << \"Enter Tracking component, message timestamp: \"\n        << message->timestamp_\n        << \" current timestamp: \" << Clock::NowInSeconds();\n\n  auto out_message = std::make_shared<SensorFrameMessage>();\n\n  if (InternalProc(message, out_message)) {\n    writer_->Write(out_message);\n    AINFO << \"Send lidar recognition output message.\";\n    return true;\n  }\n  return false;\n}\n\nbool LidarTrackingComponent::InitAlgorithmPlugin() {\n  tracker_.reset(new lidar::LidarObstacleTracking);\n  if (tracker_ == nullptr) {\n    AERROR << \"Failed to get tracking instance.\";\n    return false;\n  }\n\n  // lidar::LidarObstacleTrackingInitOptions init_options;\n  // init_options.sensor_name = main_sensor_name_;\n  // if (!tracker_->Init(init_options)) {\n  //   AERROR << \"Failed to init tracking.\";\n  //   return false;\n  // }\n\n  if (!tracker_->Init(lidar_tracking_config_)) {\n    AERROR << \"Failed to init tracking.\";\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarTrackingComponent::InternalProc(\n    const std::shared_ptr<const LidarFrameMessage>& in_message,\n    const std::shared_ptr<SensorFrameMessage>& out_message) {\n  auto& sensor_name = in_message->lidar_frame_->sensor_info.name;\n  PERF_FUNCTION_WITH_INDICATOR(sensor_name);\n  out_message->timestamp_ = in_message->timestamp_;\n  out_message->lidar_timestamp_ = in_message->lidar_timestamp_;\n  out_message->seq_num_ = in_message->seq_num_;\n  out_message->process_stage_ = ProcessStage::LIDAR_RECOGNITION;\n  out_message->sensor_id_ = sensor_name;\n\n  if (in_message->error_code_ != apollo::common::ErrorCode::OK) {\n    out_message->error_code_ = in_message->error_code_;\n    AERROR << \"Lidar recognition receive message with error code, skip it.\";\n    return true;\n  }\n\n  PERF_BLOCK_START();\n  auto& lidar_frame = in_message->lidar_frame_;\n  pipeline::DataFrame data_frame;\n  data_frame.lidar_frame = lidar_frame.get();\n  bool res = tracker_->Process(&data_frame);\n\n  PERF_BLOCK_END_WITH_INDICATOR(sensor_name, \"recognition_1::track_obstacle\");\n  if (!res) {\n    out_message->error_code_ =\n        apollo::common::ErrorCode::PERCEPTION_ERROR_PROCESS;\n    AERROR << \"Lidar recognition process error.\";\n    return true;\n  }\n\n  // PERF_BLOCK_START();\n  // auto& lidar_frame = in_message->lidar_frame_;\n  // lidar::LidarObstacleTrackingOptions track_options;\n  // track_options.sensor_name = sensor_name;\n  // lidar::LidarProcessResult ret =\n  //     tracker_->Process(track_options, lidar_frame.get());\n  // PERF_BLOCK_END_WITH_INDICATOR(sensor_name, \"recognition_1::track_obstacle\");\n  // if (ret.error_code != lidar::LidarErrorCode::Succeed) {\n  //   out_message->error_code_ =\n  //       apollo::common::ErrorCode::PERCEPTION_ERROR_PROCESS;\n  //   AERROR << \"Lidar recognition process error, \" << ret.log;\n  //   return true;\n  // }\n  // TODO(shigintmin)\n  out_message->hdmap_ = lidar_frame->hdmap_struct;\n  auto& frame = out_message->frame_;\n  frame = base::FramePool::Instance().Get();\n  frame->sensor_info = lidar_frame->sensor_info;\n  frame->timestamp = in_message->timestamp_;\n  frame->objects = lidar_frame->tracked_objects;\n  frame->sensor2world_pose = lidar_frame->lidar2world_pose;\n  frame->lidar_frame_supplement.on_use = true;\n  frame->lidar_frame_supplement.cloud_ptr = lidar_frame->cloud;\n  PERF_BLOCK_END_WITH_INDICATOR(sensor_name, \"recognition_2::fill_out_message\");\n\n  const double end_timestamp = Clock::NowInSeconds();\n  const double end_latency = (end_timestamp - in_message->timestamp_) * 1e3;\n  AINFO << std::setprecision(16) << \"FRAME_STATISTICS:Lidar:End:msg_time[\"\n        << in_message->timestamp_ << \"]:cur_time[\" << end_timestamp\n        << \"]:cur_latency[\" << end_latency << \"]\";\n  return true;\n}\n\n}  // namespace onboard\n}  // namespace perception\n}  // namespace apollo",
        "base_contents": "",
        "res_region": "/******************************************************************************\n * Copyright 2018 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *****************************************************************************/\n#include \"modules/perception/onboard/component/lidar_tracking_component.h\"\n\n#include \"cyber/time/clock.h\"\n#include \"modules/common/util/perf_util.h\"\n#include \"modules/perception/base/object_pool_types.h\"\n#include \"modules/perception/common/sensor_manager/sensor_manager.h\"\n#include \"modules/perception/lidar/common/lidar_error_code.h\"\n#include \"modules/perception/lidar/common/lidar_log.h\"\n\nusing Clock = apollo::cyber::Clock;\n\nnamespace apollo {\nnamespace perception {\nnamespace onboard {\n\nusing apollo::cyber::common::GetAbsolutePath;\n\nbool LidarTrackingComponent::Init() {\n  LidarRecognitionComponentConfig comp_config;\n  if (!GetProtoConfig(&comp_config)) {\n    return false;\n  }\n  AINFO << \"Lidar Component Configs: \" << comp_config.DebugString();\n  output_channel_name_ = comp_config.output_channel_name();\n  main_sensor_name_ = comp_config.main_sensor_name();\n  writer_ = node_->CreateWriter<SensorFrameMessage>(output_channel_name_);\n\n  // read pipeline config\n  std::string lidar_tracking_conf_dir = comp_config.lidar_tracking_conf_dir();\n  std::string lidar_tracking_conf_file = comp_config.lidar_tracking_conf_file();\n\n  std::string work_root = \"\";\n  std::string lidar_tracking_config_path =\n      GetAbsolutePath(lidar_tracking_conf_dir, lidar_tracking_conf_file);\n  lidar_tracking_config_path =\n      GetAbsolutePath(work_root, lidar_tracking_config_path);\n\n  if (!cyber::common::GetProtoFromFile(\n          lidar_tracking_config_path, &lidar_tracking_config_)) {\n    AERROR << \"Read config failed: \" << lidar_tracking_config_path;\n    return false;\n  }\n\n  if (!InitAlgorithmPlugin()) {\n    AERROR << \"Failed to init recongnition component algorithm plugin.\";\n    return false;\n  }\n  return true;\n}\n\nbool LidarTrackingComponent::Proc(\n    const std::shared_ptr<LidarFrameMessage>& message) {\n  AINFO << std::setprecision(16)\n        << \"Enter Tracking component, message timestamp: \"\n        << message->timestamp_\n        << \" current timestamp: \" << Clock::NowInSeconds();\n\n  auto out_message = std::make_shared<SensorFrameMessage>();\n\n  if (InternalProc(message, out_message)) {\n    writer_->Write(out_message);\n    AINFO << \"Send lidar recognition output message.\";\n    return true;\n  }\n  return false;\n}\n\nbool LidarTrackingComponent::InitAlgorithmPlugin() {\n  tracker_.reset(new lidar::LidarObstacleTracking);\n  if (tracker_ == nullptr) {\n    AERROR << \"Failed to get tracking instance.\";\n    return false;\n  }\n\n  // lidar::LidarObstacleTrackingInitOptions init_options;\n  // init_options.sensor_name = main_sensor_name_;\n  // if (!tracker_->Init(init_options)) {\n  //   AERROR << \"Failed to init tracking.\";\n  //   return false;\n  // }\n\n  if (!tracker_->Init(lidar_tracking_config_)) {\n    AERROR << \"Failed to init tracking.\";\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarTrackingComponent::InternalProc(\n    const std::shared_ptr<const LidarFrameMessage>& in_message,\n    const std::shared_ptr<SensorFrameMessage>& out_message) {\n  auto& sensor_name = in_message->lidar_frame_->sensor_info.name;\n  PERF_FUNCTION_WITH_INDICATOR(sensor_name);\n  out_message->timestamp_ = in_message->timestamp_;\n  out_message->lidar_timestamp_ = in_message->lidar_timestamp_;\n  out_message->seq_num_ = in_message->seq_num_;\n  out_message->process_stage_ = ProcessStage::LIDAR_RECOGNITION;\n  out_message->sensor_id_ = sensor_name;\n\n  if (in_message->error_code_ != apollo::common::ErrorCode::OK) {\n    out_message->error_code_ = in_message->error_code_;\n    AERROR << \"Lidar recognition receive message with error code, skip it.\";\n    return true;\n  }\n\n  PERF_BLOCK_START();\n  auto& lidar_frame = in_message->lidar_frame_;\n  pipeline::DataFrame data_frame;\n  data_frame.lidar_frame = lidar_frame.get();\n  bool res = tracker_->Process(&data_frame);\n\n  PERF_BLOCK_END_WITH_INDICATOR(sensor_name, \"recognition_1::track_obstacle\");\n  if (!res) {\n    out_message->error_code_ =\n        apollo::common::ErrorCode::PERCEPTION_ERROR_PROCESS;\n    AERROR << \"Lidar recognition process error.\";\n    return true;\n  }\n\n  // PERF_BLOCK_START();\n  // auto& lidar_frame = in_message->lidar_frame_;\n  // lidar::LidarObstacleTrackingOptions track_options;\n  // track_options.sensor_name = sensor_name;\n  // lidar::LidarProcessResult ret =\n  //     tracker_->Process(track_options, lidar_frame.get());\n  // PERF_BLOCK_END_WITH_INDICATOR(sensor_name, \"recognition_1::track_obstacle\");\n  // if (ret.error_code != lidar::LidarErrorCode::Succeed) {\n  //   out_message->error_code_ =\n  //       apollo::common::ErrorCode::PERCEPTION_ERROR_PROCESS;\n  //   AERROR << \"Lidar recognition process error, \" << ret.log;\n  //   return true;\n  // }\n  // TODO(shigintmin)\n  out_message->hdmap_ = lidar_frame->hdmap_struct;\n  auto& frame = out_message->frame_;\n  frame = base::FramePool::Instance().Get();\n  frame->sensor_info = lidar_frame->sensor_info;\n  frame->timestamp = in_message->timestamp_;\n  frame->objects = lidar_frame->tracked_objects;\n  frame->sensor2world_pose = lidar_frame->lidar2world_pose;\n  frame->lidar_frame_supplement.on_use = true;\n  frame->lidar_frame_supplement.cloud_ptr = lidar_frame->cloud;\n  PERF_BLOCK_END_WITH_INDICATOR(sensor_name, \"recognition_2::fill_out_message\");\n\n  const double end_timestamp = Clock::NowInSeconds();\n  const double end_latency = (end_timestamp - in_message->timestamp_) * 1e3;\n  AINFO << std::setprecision(16) << \"FRAME_STATISTICS:Lidar:End:msg_time[\"\n        << in_message->timestamp_ << \"]:cur_time[\" << end_timestamp\n        << \"]:cur_latency[\" << end_latency << \"]\";\n  return true;\n}\n\n}  // namespace onboard\n}  // namespace perception\n}  // namespace apollo",
        "lookback": " * Copyright 2018 The Apollo Authors. All Rights Reserved.",
        "lookahead": "",
        "label": [
            "ours",
            "base_underutilized"
        ],
        "start_line": 0,
        "end_line": 345,
        "merge_gen_region": " Copyright Thepol Authors All Reserved/****************************************************************************** Copyright Thepol Authors All Reserved * Licensed the Apache, 20theLicense *\"); you not this except in with the. You obtain copy the License * may a of License * *://.///LICENSE20 * Unless by applicable or to writing software distributed the is on \" IS BASIS * WARRANTIES CONDITIONS ANY, express implied * the License the for specific governing and limitations the License *****************************************************************************/includemodulesper/boardcomponentlid____.\"includecy///////perfutilh # \"/per///__.\"includemodulesper///___.\"includemodulesper//__.\"includemodulesper//__.\"includemodulesper//__.\"includemodulesper//arerrorcodeh # \"/per/arcommonlid//arlogh using =pol::bercy::;; alo namespaceception namespaceboard usingpol::bercommonGetPath boolidTracking::() LarcognitionConfig compconfig ifGetConfig(&_)) return; A <<Lar Config: \" comp_.(); outputchannelname =_ compconfigoutputchannelname mainsensorname =_..____",
        "confidence": 0.9396733641624451,
        "hesitated": false,
        "resolved": false
    }
]