[
    {
        "a_contents": "/******************************************************************************\n * Copyright 2017 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *****************************************************************************/\n\n#include \"modules/dreamview/backend/sim_control_manager/dynamic_model/perfect_control/sim_perfect_control.h\"\n\n#include \"cyber/common/file.h\"\n#include \"cyber/time/clock.h\"\n#include \"modules/common/adapters/adapter_gflags.h\"\n#include \"modules/common/math/linear_interpolation.h\"\n#include \"modules/common/math/math_utils.h\"\n#include \"modules/common/math/quaternion.h\"\n#include \"modules/common/util/message_util.h\"\n#include \"modules/common/util/util.h\"\n\nnamespace apollo {\nnamespace dreamview {\n\nusing apollo::canbus::Chassis;\nusing apollo::common::Header;\nusing apollo::common::Point3D;\nusing apollo::common::Quaternion;\nusing apollo::common::TrajectoryPoint;\nusing apollo::common::math::HeadingToQuaternion;\nusing apollo::common::math::InterpolateUsingLinearApproximation;\nusing apollo::common::math::InverseQuaternionRotate;\nusing apollo::common::util::FillHeader;\nusing apollo::cyber::Clock;\nusing apollo::localization::LocalizationEstimate;\nusing apollo::planning::ADCTrajectory;\nusing apollo::prediction::PredictionObstacles;\nusing apollo::relative_map::NavigationInfo;\nusing apollo::routing::RoutingResponse;\nusing apollo::routing::RoutingRequest;\nusing Json = nlohmann::json;\n\nnamespace {\n\nvoid TransformToVRF(const Point3D &point_mrf, const Quaternion &orientation,\n                    Point3D *point_vrf) {\n  Eigen::Vector3d v_mrf(point_mrf.x(), point_mrf.y(), point_mrf.z());\n  auto v_vrf = InverseQuaternionRotate(orientation, v_mrf);\n  point_vrf->set_x(v_vrf.x());\n  point_vrf->set_y(v_vrf.y());\n  point_vrf->set_z(v_vrf.z());\n}\n\nbool IsSameHeader(const Header &lhs, const Header &rhs) {\n  return lhs.sequence_num() == rhs.sequence_num() &&\n         lhs.timestamp_sec() == rhs.timestamp_sec();\n}\n\n}  // namespace\n\nSimPerfectControl::SimPerfectControl(const MapService *map_service)\n    : SimControlBase(),\n      map_service_(map_service),\n      node_(cyber::CreateNode(\"sim_perfect_control\")),\n      current_trajectory_(std::make_shared<ADCTrajectory>()) {\n  InitTimerAndIO();\n}\n\nvoid SimPerfectControl::InitTimerAndIO() {\n  localization_reader_ =\n      node_->CreateReader<LocalizationEstimate>(FLAGS_localization_topic);\n  planning_reader_ = node_->CreateReader<ADCTrajectory>(\n      FLAGS_planning_trajectory_topic,\n      [this](const std::shared_ptr<ADCTrajectory> &trajectory) {\n        this->OnPlanning(trajectory);\n      });\n  routing_request_reader_ = node_->CreateReader<RoutingRequest>(\n      FLAGS_routing_request_topic,\n      [this](const std::shared_ptr<RoutingRequest> &routing_request) {\n        this->OnRoutingRequest(routing_request);\n      });\n  routing_response_reader_ = node_->CreateReader<RoutingResponse>(\n      FLAGS_routing_response_topic,\n      [this](const std::shared_ptr<RoutingResponse> &routing) {\n        this->OnRoutingResponse(routing);\n      });\n  navigation_reader_ = node_->CreateReader<NavigationInfo>(\n      FLAGS_navigation_topic,\n      [this](const std::shared_ptr<NavigationInfo> &navigation_info) {\n        this->OnReceiveNavigationInfo(navigation_info);\n      });\n  prediction_reader_ = node_->CreateReader<PredictionObstacles>(\n      FLAGS_prediction_topic,\n      [this](const std::shared_ptr<PredictionObstacles> &obstacles) {\n        this->OnPredictionObstacles(obstacles);\n      });\n\n  localization_writer_ =\n      node_->CreateWriter<LocalizationEstimate>(FLAGS_localization_topic);\n  chassis_writer_ = node_->CreateWriter<Chassis>(FLAGS_chassis_topic);\n  prediction_writer_ =\n      node_->CreateWriter<PredictionObstacles>(FLAGS_prediction_topic);\n\n  // Start timer to publish localization and chassis messages.\n  sim_control_timer_.reset(new cyber::Timer(\n      kSimControlIntervalMs, [this]() { this->RunOnce(); }, false));\n  sim_prediction_timer_.reset(\n      new cyber::Timer(kSimPredictionIntervalMs,\n                       [this]() { this->PublishDummyPrediction(); }, false));\n}\n\nvoid SimPerfectControl::Init(bool set_start_point,\n                             nlohmann::json start_point_attr,\n                             bool use_start_point_position) {\n  if (set_start_point && !FLAGS_use_navigation_mode) {\n    InitStartPoint(start_point_attr[\"start_velocity\"],\n                   start_point_attr[\"start_acceleration\"]);\n  }\n}\n\nvoid SimPerfectControl::InitStartPoint(double x, double y,\n                                       double start_velocity,\n                                       double start_acceleration) {\n  TrajectoryPoint point;\n  // Use the scenario start point as start point,\n  start_point_from_localization_ = false;\n  point.mutable_path_point()->set_x(x);\n  point.mutable_path_point()->set_y(y);\n  // z use default 0\n  point.mutable_path_point()->set_z(0);\n  double theta = 0.0;\n  double s = 0.0;\n  map_service_->GetPoseWithRegardToLane(x, y, &theta, &s);\n  point.mutable_path_point()->set_theta(theta);\n  point.set_v(start_velocity);\n  point.set_a(start_acceleration);\n  SetStartPoint(point);\n}\n\nvoid SimPerfectControl::InitStartPoint(double start_velocity,\n                                       double start_acceleration) {\n  TrajectoryPoint point;\n  // Use the latest localization position as start point,\n  // fall back to a dummy point from map\n  localization_reader_->Observe();\n  start_point_from_localization_ = false;\n  if (!localization_reader_->Empty()) {\n    const auto &localization = localization_reader_->GetLatestObserved();\n    const auto &pose = localization->pose();\n    if (map_service_->PointIsValid(pose.position().x(), pose.position().y())) {\n      point.mutable_path_point()->set_x(pose.position().x());\n      point.mutable_path_point()->set_y(pose.position().y());\n      point.mutable_path_point()->set_z(pose.position().z());\n      point.mutable_path_point()->set_theta(pose.heading());\n      point.set_v(\n          std::hypot(pose.linear_velocity().x(), pose.linear_velocity().y()));\n      // Calculates the dot product of acceleration and velocity. The sign\n      // of this projection indicates whether this is acceleration or\n      // deceleration.\n      double projection =\n          pose.linear_acceleration().x() * pose.linear_velocity().x() +\n          pose.linear_acceleration().y() * pose.linear_velocity().y();\n\n      // Calculates the magnitude of the acceleration. Negate the value if\n      // it is indeed a deceleration.\n      double magnitude = std::hypot(pose.linear_acceleration().x(),\n                                    pose.linear_acceleration().y());\n      point.set_a(std::signbit(projection) ? -magnitude : magnitude);\n      start_point_from_localization_ = true;\n    }\n  }\n  if (!start_point_from_localization_) {\n    apollo::common::PointENU start_point;\n    if (!map_service_->GetStartPoint(&start_point)) {\n      AWARN << \"Failed to get a dummy start point from map!\";\n      return;\n    }\n    point.mutable_path_point()->set_x(start_point.x());\n    point.mutable_path_point()->set_y(start_point.y());\n    point.mutable_path_point()->set_z(start_point.z());\n    double theta = 0.0;\n    double s = 0.0;\n    map_service_->GetPoseWithRegardToLane(start_point.x(), start_point.y(),\n                                          &theta, &s);\n    point.mutable_path_point()->set_theta(theta);\n    point.set_v(start_velocity);\n    point.set_a(start_acceleration);\n  }\n  SetStartPoint(point);\n}\n\nvoid SimPerfectControl::SetStartPoint(const TrajectoryPoint &start_point) {\n  next_point_ = start_point;\n  prev_point_index_ = next_point_index_ = 0;\n  received_planning_ = false;\n}\n\nvoid SimPerfectControl::Reset() {\n  std::lock_guard<std::mutex> lock(mutex_);\n  InternalReset();\n}\n\nvoid SimPerfectControl::Stop() {\n  std::lock_guard<std::mutex> lock(mutex_);\n\n  if (enabled_) {\n    sim_control_timer_->Stop();\n    sim_prediction_timer_->Stop();\n    enabled_ = false;\n  }\n}\n\nvoid SimPerfectControl::InternalReset() {\n  current_routing_header_.Clear();\n  re_routing_triggered_ = false;\n  send_dummy_prediction_ = true;\n  ClearPlanning();\n}\n\nvoid SimPerfectControl::ClearPlanning() {\n  current_trajectory_->Clear();\n  received_planning_ = false;\n}\n\nvoid SimPerfectControl::OnReceiveNavigationInfo(\n    const std::shared_ptr<NavigationInfo> &navigation_info) {\n  std::lock_guard<std::mutex> lock(mutex_);\n\n  if (navigation_info->navigation_path_size() > 0) {\n    const auto &path = navigation_info->navigation_path(0).path();\n    if (path.path_point_size() > 0) {\n      adc_position_ = path.path_point(0);\n    }\n  }\n}\n\nvoid SimPerfectControl::OnRoutingResponse(\n    const std::shared_ptr<RoutingResponse> &routing) {\n  std::lock_guard<std::mutex> lock(mutex_);\n  if (!enabled_) {\n    return;\n  }\n\n  CHECK_GE(routing->routing_request().waypoint_size(), 2)\n      << \"routing should have at least two waypoints\";\n\n  current_routing_header_ = routing->header();\n\n  // // If this is from a planning re-routing request, or the start point has\n  // // been\n  // // initialized by an actual localization pose, don't reset the start point.\n  // re_routing_triggered_ =\n  //     routing->routing_request().header().module_name() == \"planning\";\n  // if (!re_routing_triggered_ && !start_point_from_localization_) {\n  //   ClearPlanning();\n  //   TrajectoryPoint point;\n  //   point.mutable_path_point()->set_x(start_pose.x());\n  //   point.mutable_path_point()->set_y(start_pose.y());\n  //   point.set_a(next_point_.has_a() ? next_point_.a() : 0.0);\n  //   point.set_v(next_point_.has_v() ? next_point_.v() : 0.0);\n  //   double theta = 0.0;\n  //   double s = 0.0;\n  //   map_service_->GetPoseWithRegardToLane(start_pose.x(), start_pose.y(),\n  //                                         &theta, &s);\n  //   point.mutable_path_point()->set_theta(theta);\n  //   SetStartPoint(point);\n  // }\n}\n\nvoid SimPerfectControl::OnRoutingRequest(\n    const std::shared_ptr<RoutingRequest> &routing_request) {\n  std::lock_guard<std::mutex> lock(mutex_);\n  if (!enabled_) {\n    return;\n  }\n\n  CHECK_GE(routing_request->waypoint_size(), 2)\n      << \"routing should have at least two waypoints\";\n  const auto &start_pose = routing_request->waypoint(0).pose();\n\n  ClearPlanning();\n  TrajectoryPoint point;\n  point.mutable_path_point()->set_x(start_pose.x());\n  point.mutable_path_point()->set_y(start_pose.y());\n  point.set_a(next_point_.has_a() ? next_point_.a() : 0.0);\n  point.set_v(next_point_.has_v() ? next_point_.v() : 0.0);\n  double theta = 0.0;\n  double s = 0.0;\n  const auto &start_way_point = routing_request->waypoint().Get(0);\n  // If the lane id has been set, set theta as the lane heading.\n  if (start_way_point.has_id()) {\n    auto &hdmap = hdmap::HDMapUtil::BaseMap();\n    hdmap::Id lane_id = hdmap::MakeMapId(start_way_point.id());\n    auto lane = hdmap.GetLaneById(lane_id);\n    if (nullptr != lane) {\n      theta = lane->Heading(start_way_point.s());\n    } else {\n      map_service_->GetPoseWithRegardToLane(start_pose.x(), start_pose.y(),\n                                            &theta, &s);\n    }\n  } else {\n    // Find the lane nearest to the start pose and get its heading as theta.\n    map_service_->GetPoseWithRegardToLane(start_pose.x(), start_pose.y(),\n                                          &theta, &s);\n  }\n\n  point.mutable_path_point()->set_theta(theta);\n  SetStartPoint(point);\n}\n\nvoid SimPerfectControl::OnPredictionObstacles(\n    const std::shared_ptr<PredictionObstacles> &obstacles) {\n  std::lock_guard<std::mutex> lock(mutex_);\n\n  if (!enabled_) {\n    return;\n  }\n\n  send_dummy_prediction_ = obstacles->header().module_name() == \"SimPrediction\";\n}\n\nvoid SimPerfectControl::Start() {\n  std::lock_guard<std::mutex> lock(mutex_);\n\n  if (!enabled_) {\n    // When there is no localization yet, Init(true) will use a\n    // dummy point from the current map as an arbitrary start.\n    // When localization is already available, we do not need to\n    // reset/override the start point.\n    localization_reader_->Observe();\n    Json start_point_attr({});\n    start_point_attr[\"start_velocity\"] =\n        next_point_.has_v() ? next_point_.v() : 0.0;\n    start_point_attr[\"start_acceleration\"] =\n        next_point_.has_a() ? next_point_.a() : 0.0;\n    Init(true, start_point_attr);\n    InternalReset();\n    sim_control_timer_->Start();\n    sim_prediction_timer_->Start();\n    enabled_ = true;\n  }\n}\n\nvoid SimPerfectControl::Start(double x, double y) {\n  std::lock_guard<std::mutex> lock(mutex_);\n  if (!enabled_) {\n    // Do not use localization info. use scenario start point to init start\n    // point.\n    InitStartPoint(x, y, 0, 0);\n    InternalReset();\n    sim_control_timer_->Start();\n    sim_prediction_timer_->Start();\n    enabled_ = true;\n  }\n}\n\nvoid SimPerfectControl::OnPlanning(\n    const std::shared_ptr<ADCTrajectory> &trajectory) {\n  std::lock_guard<std::mutex> lock(mutex_);\n\n  if (!enabled_) {\n    return;\n  }\n\n  // Reset current trajectory and the indices upon receiving a new trajectory.\n  // The routing SimPerfectControl owns must match with the one Planning has.\n  if (re_routing_triggered_ ||\n      IsSameHeader(trajectory->routing_header(), current_routing_header_)) {\n    current_trajectory_ = trajectory;\n    prev_point_index_ = 0;\n    next_point_index_ = 0;\n    received_planning_ = true;\n  } else {\n    ClearPlanning();\n  }\n}\n\nvoid SimPerfectControl::Freeze() {\n  next_point_.set_v(0.0);\n  next_point_.set_a(0.0);\n  prev_point_ = next_point_;\n}\n\nvoid SimPerfectControl::RunOnce() {\n  std::lock_guard<std::mutex> lock(mutex_);\n\n  TrajectoryPoint trajectory_point;\n  Chassis::GearPosition gear_position;\n  if (!PerfectControlModel(&trajectory_point, &gear_position)) {\n    AERROR << \"Failed to calculate next point with perfect control model\";\n    return;\n  }\n\n  PublishChassis(trajectory_point.v(), gear_position);\n  PublishLocalization(trajectory_point);\n}\n\nbool SimPerfectControl::PerfectControlModel(\n    TrajectoryPoint *point, Chassis::GearPosition *gear_position) {\n  // Result of the interpolation.\n  auto current_time = Clock::NowInSeconds();\n  const auto &trajectory = current_trajectory_->trajectory_point();\n  *gear_position = current_trajectory_->gear();\n\n  if (!received_planning_) {\n    prev_point_ = next_point_;\n  } else {\n    if (current_trajectory_->estop().is_estop() ||\n        next_point_index_ >= trajectory.size()) {\n      // Freeze the car when there's an estop or the current trajectory has\n      // been exhausted.\n      Freeze();\n    } else {\n      // Determine the status of the car based on received planning message.\n      while (next_point_index_ < trajectory.size() &&\n             current_time > trajectory.Get(next_point_index_).relative_time() +\n                                current_trajectory_->header().timestamp_sec()) {\n        ++next_point_index_;\n      }\n\n      if (next_point_index_ >= trajectory.size()) {\n        next_point_index_ = trajectory.size() - 1;\n      }\n\n      if (next_point_index_ == 0) {\n        AERROR << \"First trajectory point is a future point!\";\n        return false;\n      }\n\n      prev_point_index_ = next_point_index_ - 1;\n\n      next_point_ = trajectory.Get(next_point_index_);\n      prev_point_ = trajectory.Get(prev_point_index_);\n    }\n  }\n\n  if (current_time > next_point_.relative_time() +\n                         current_trajectory_->header().timestamp_sec()) {\n    // Don't try to extrapolate if relative_time passes last point\n    *point = next_point_;\n  } else {\n    *point = InterpolateUsingLinearApproximation(\n        prev_point_, next_point_,\n        current_time - current_trajectory_->header().timestamp_sec());\n  }\n  return true;\n}\n\nvoid SimPerfectControl::PublishChassis(double cur_speed,\n                                       Chassis::GearPosition gear_position) {\n  auto chassis = std::make_shared<Chassis>();\n  FillHeader(\"SimPerfectControl\", chassis.get());\n\n  chassis->set_engine_started(true);\n  chassis->set_driving_mode(Chassis::COMPLETE_AUTO_DRIVE);\n  chassis->set_gear_location(gear_position);\n\n  chassis->set_speed_mps(static_cast<float>(cur_speed));\n  if (gear_position == canbus::Chassis::GEAR_REVERSE) {\n    chassis->set_speed_mps(-chassis->speed_mps());\n  }\n\n  chassis->set_throttle_percentage(0.0);\n  chassis->set_brake_percentage(0.0);\n\n  chassis_writer_->Write(chassis);\n}\n\nvoid SimPerfectControl::PublishLocalization(const TrajectoryPoint &point) {\n  auto localization = std::make_shared<LocalizationEstimate>();\n  FillHeader(\"SimPerfectControl\", localization.get());\n\n  auto *pose = localization->mutable_pose();\n  auto prev = prev_point_.path_point();\n  auto next = next_point_.path_point();\n\n  // Set position\n  pose->mutable_position()->set_x(point.path_point().x());\n  pose->mutable_position()->set_y(point.path_point().y());\n  pose->mutable_position()->set_z(point.path_point().z());\n  // Set orientation and heading\n  double cur_theta = point.path_point().theta();\n\n  if (FLAGS_use_navigation_mode) {\n    double flu_x = point.path_point().x();\n    double flu_y = point.path_point().y();\n\n    Eigen::Vector2d enu_coordinate =\n        common::math::RotateVector2d({flu_x, flu_y}, cur_theta);\n\n    enu_coordinate.x() += adc_position_.x();\n    enu_coordinate.y() += adc_position_.y();\n    pose->mutable_position()->set_x(enu_coordinate.x());\n    pose->mutable_position()->set_y(enu_coordinate.y());\n  }\n\n  Eigen::Quaternion<double> cur_orientation =\n      HeadingToQuaternion<double>(cur_theta);\n  pose->mutable_orientation()->set_qw(cur_orientation.w());\n  pose->mutable_orientation()->set_qx(cur_orientation.x());\n  pose->mutable_orientation()->set_qy(cur_orientation.y());\n  pose->mutable_orientation()->set_qz(cur_orientation.z());\n  pose->set_heading(cur_theta);\n\n  // Set linear_velocity\n  pose->mutable_linear_velocity()->set_x(std::cos(cur_theta) * point.v());\n  pose->mutable_linear_velocity()->set_y(std::sin(cur_theta) * point.v());\n  pose->mutable_linear_velocity()->set_z(0);\n\n  // Set angular_velocity in both map reference frame and vehicle reference\n  // frame\n  pose->mutable_angular_velocity()->set_x(0);\n  pose->mutable_angular_velocity()->set_y(0);\n  pose->mutable_angular_velocity()->set_z(point.v() *\n                                          point.path_point().kappa());\n\n  TransformToVRF(pose->angular_velocity(), pose->orientation(),\n                 pose->mutable_angular_velocity_vrf());\n\n  // Set linear_acceleration in both map reference frame and vehicle reference\n  // frame\n  auto *linear_acceleration = pose->mutable_linear_acceleration();\n  linear_acceleration->set_x(std::cos(cur_theta) * point.a());\n  linear_acceleration->set_y(std::sin(cur_theta) * point.a());\n  linear_acceleration->set_z(0);\n\n  TransformToVRF(pose->linear_acceleration(), pose->orientation(),\n                 pose->mutable_linear_acceleration_vrf());\n\n  localization_writer_->Write(localization);\n\n  adc_position_.set_x(pose->position().x());\n  adc_position_.set_y(pose->position().y());\n  adc_position_.set_z(pose->position().z());\n}\n\nvoid SimPerfectControl::PublishDummyPrediction() {\n  auto prediction = std::make_shared<PredictionObstacles>();\n  {\n    std::lock_guard<std::mutex> lock(mutex_);\n    if (!send_dummy_prediction_) {\n      return;\n    }\n    FillHeader(\"SimPrediction\", prediction.get());\n  }\n  prediction_writer_->Write(prediction);\n}\n\n}  // namespace dreamview\n}  // namespace apollo",
        "b_contents": "/******************************************************************************\n * Copyright 2017 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *****************************************************************************/\n\n#include \"modules/dreamview/backend/sim_control_manager/dynamic_model/perfect_control/sim_perfect_control.h\"\n\n#include \"cyber/common/file.h\"\n#include \"cyber/time/clock.h\"\n#include \"modules/common/adapters/adapter_gflags.h\"\n#include \"modules/common/math/linear_interpolation.h\"\n#include \"modules/common/math/math_utils.h\"\n#include \"modules/common/math/quaternion.h\"\n#include \"modules/common/util/message_util.h\"\n#include \"modules/common/util/util.h\"\n\nnamespace apollo {\nnamespace dreamview {\n\nusing apollo::canbus::Chassis;\nusing apollo::common::Header;\nusing apollo::common::Point3D;\nusing apollo::common::Quaternion;\nusing apollo::common::TrajectoryPoint;\nusing apollo::common::math::HeadingToQuaternion;\nusing apollo::common::math::InterpolateUsingLinearApproximation;\nusing apollo::common::math::InverseQuaternionRotate;\nusing apollo::common::util::FillHeader;\nusing apollo::cyber::Clock;\nusing apollo::localization::LocalizationEstimate;\nusing apollo::planning::ADCTrajectory;\nusing apollo::prediction::PredictionObstacles;\nusing apollo::relative_map::NavigationInfo;\nusing apollo::routing::RoutingResponse;\nusing apollo::routing::RoutingRequest;\nusing Json = nlohmann::json;\n\nnamespace {\n\nvoid TransformToVRF(const Point3D &point_mrf, const Quaternion &orientation,\n                    Point3D *point_vrf) {\n  Eigen::Vector3d v_mrf(point_mrf.x(), point_mrf.y(), point_mrf.z());\n  auto v_vrf = InverseQuaternionRotate(orientation, v_mrf);\n  point_vrf->set_x(v_vrf.x());\n  point_vrf->set_y(v_vrf.y());\n  point_vrf->set_z(v_vrf.z());\n}\n\nbool IsSameHeader(const Header &lhs, const Header &rhs) {\n  return lhs.sequence_num() == rhs.sequence_num() &&\n         lhs.timestamp_sec() == rhs.timestamp_sec();\n}\n\n}  // namespace\n\nSimPerfectControl::SimPerfectControl(const MapService *map_service)\n    : SimControlBase(),\n      map_service_(map_service),\n      node_(cyber::CreateNode(\"sim_perfect_control\")),\n      current_trajectory_(std::make_shared<ADCTrajectory>()) {\n  InitTimerAndIO();\n}\n\nvoid SimPerfectControl::InitTimerAndIO() {\n  localization_reader_ =\n      node_->CreateReader<LocalizationEstimate>(FLAGS_localization_topic);\n  planning_reader_ = node_->CreateReader<ADCTrajectory>(\n      FLAGS_planning_trajectory_topic,\n      [this](const std::shared_ptr<ADCTrajectory> &trajectory) {\n        this->OnPlanning(trajectory);\n      });\n  routing_request_reader_ = node_->CreateReader<RoutingRequest>(\n      FLAGS_routing_request_topic,\n      [this](const std::shared_ptr<RoutingRequest>& routing_request) {\n        this->OnRoutingRequest(routing_request);\n      });\n  routing_response_reader_ = node_->CreateReader<RoutingResponse>(\n      FLAGS_routing_response_topic,\n      [this](const std::shared_ptr<RoutingResponse> &routing) {\n        this->OnRoutingResponse(routing);\n      });\n  navigation_reader_ = node_->CreateReader<NavigationInfo>(\n      FLAGS_navigation_topic,\n      [this](const std::shared_ptr<NavigationInfo> &navigation_info) {\n        this->OnReceiveNavigationInfo(navigation_info);\n      });\n  prediction_reader_ = node_->CreateReader<PredictionObstacles>(\n      FLAGS_prediction_topic,\n      [this](const std::shared_ptr<PredictionObstacles> &obstacles) {\n        this->OnPredictionObstacles(obstacles);\n      });\n\n  localization_writer_ =\n      node_->CreateWriter<LocalizationEstimate>(FLAGS_localization_topic);\n  chassis_writer_ = node_->CreateWriter<Chassis>(FLAGS_chassis_topic);\n  prediction_writer_ =\n      node_->CreateWriter<PredictionObstacles>(FLAGS_prediction_topic);\n\n  // Start timer to publish localization and chassis messages.\n  sim_control_timer_.reset(new cyber::Timer(\n      kSimControlIntervalMs, [this]() { this->RunOnce(); }, false));\n  sim_prediction_timer_.reset(new cyber::Timer(\n      kSimPredictionIntervalMs, [this]() { this->PublishDummyPrediction(); },\n      false));\n}\n\nvoid SimPerfectControl::Init(bool set_start_point,\n                             nlohmann::json start_point_attr,\n                             bool use_start_point_position) {\n  if (set_start_point && !FLAGS_use_navigation_mode) {\n    InitStartPoint(start_point_attr[\"start_velocity\"],\n                   start_point_attr[\"start_acceleration\"]);\n  }\n}\n\nvoid SimPerfectControl::InitStartPoint(double x, double y,\n                                       double start_velocity,\n                                       double start_acceleration) {\n  TrajectoryPoint point;\n  // Use the scenario start point as start point,\n  start_point_from_localization_ = false;\n  point.mutable_path_point()->set_x(x);\n  point.mutable_path_point()->set_y(y);\n  // z use default 0\n  point.mutable_path_point()->set_z(0);\n  double theta = 0.0;\n  double s = 0.0;\n  map_service_->GetPoseWithRegardToLane(x, y, &theta, &s);\n  point.mutable_path_point()->set_theta(theta);\n  point.set_v(start_velocity);\n  point.set_a(start_acceleration);\n  SetStartPoint(point);\n}\n\nvoid SimPerfectControl::InitStartPoint(double start_velocity,\n                                       double start_acceleration) {\n  TrajectoryPoint point;\n  // Use the latest localization position as start point,\n  // fall back to a dummy point from map\n  localization_reader_->Observe();\n  if (localization_reader_->Empty()) {\n    start_point_from_localization_ = false;\n    apollo::common::PointENU start_point;\n    if (!map_service_->GetStartPoint(&start_point)) {\n      AWARN << \"Failed to get a dummy start point from map!\";\n      return;\n    }\n    point.mutable_path_point()->set_x(start_point.x());\n    point.mutable_path_point()->set_y(start_point.y());\n    point.mutable_path_point()->set_z(start_point.z());\n    double theta = 0.0;\n    double s = 0.0;\n    map_service_->GetPoseWithRegardToLane(start_point.x(), start_point.y(),\n                                          &theta, &s);\n    point.mutable_path_point()->set_theta(theta);\n    point.set_v(start_velocity);\n    point.set_a(start_acceleration);\n  } else {\n    start_point_from_localization_ = true;\n    const auto &localization = localization_reader_->GetLatestObserved();\n    const auto &pose = localization->pose();\n    point.mutable_path_point()->set_x(pose.position().x());\n    point.mutable_path_point()->set_y(pose.position().y());\n    point.mutable_path_point()->set_z(pose.position().z());\n    point.mutable_path_point()->set_theta(pose.heading());\n    point.set_v(\n        std::hypot(pose.linear_velocity().x(), pose.linear_velocity().y()));\n    // Calculates the dot product of acceleration and velocity. The sign\n    // of this projection indicates whether this is acceleration or\n    // deceleration.\n    double projection =\n        pose.linear_acceleration().x() * pose.linear_velocity().x() +\n        pose.linear_acceleration().y() * pose.linear_velocity().y();\n\n    // Calculates the magnitude of the acceleration. Negate the value if\n    // it is indeed a deceleration.\n    double magnitude = std::hypot(pose.linear_acceleration().x(),\n                                  pose.linear_acceleration().y());\n    point.set_a(std::signbit(projection) ? -magnitude : magnitude);\n  }\n  SetStartPoint(point);\n}\n\nvoid SimPerfectControl::SetStartPoint(const TrajectoryPoint &start_point) {\n  next_point_ = start_point;\n  prev_point_index_ = next_point_index_ = 0;\n  received_planning_ = false;\n}\n\nvoid SimPerfectControl::Reset() {\n  std::lock_guard<std::mutex> lock(mutex_);\n  InternalReset();\n}\n\nvoid SimPerfectControl::Stop() {\n  std::lock_guard<std::mutex> lock(mutex_);\n\n  if (enabled_) {\n    sim_control_timer_->Stop();\n    sim_prediction_timer_->Stop();\n    enabled_ = false;\n  }\n}\n\nvoid SimPerfectControl::InternalReset() {\n  current_routing_header_.Clear();\n  re_routing_triggered_ = false;\n  send_dummy_prediction_ = true;\n  ClearPlanning();\n}\n\nvoid SimPerfectControl::ClearPlanning() {\n  current_trajectory_->Clear();\n  received_planning_ = false;\n}\n\nvoid SimPerfectControl::OnReceiveNavigationInfo(\n    const std::shared_ptr<NavigationInfo> &navigation_info) {\n  std::lock_guard<std::mutex> lock(mutex_);\n\n  if (navigation_info->navigation_path_size() > 0) {\n    const auto &path = navigation_info->navigation_path(0).path();\n    if (path.path_point_size() > 0) {\n      adc_position_ = path.path_point(0);\n    }\n  }\n}\n\nvoid SimPerfectControl::OnRoutingResponse(\n    const std::shared_ptr<RoutingResponse> &routing) {\n  std::lock_guard<std::mutex> lock(mutex_);\n  if (!enabled_) {\n    return;\n  }\n\n  CHECK_GE(routing->routing_request().waypoint_size(), 2)\n      << \"routing should have at least two waypoints\";\n\n  current_routing_header_ = routing->header();\n\n  // // If this is from a planning re-routing request, or the start point has\n  // // been\n  // // initialized by an actual localization pose, don't reset the start point.\n  // re_routing_triggered_ =\n  //     routing->routing_request().header().module_name() == \"planning\";\n  // if (!re_routing_triggered_ && !start_point_from_localization_) {\n  //   ClearPlanning();\n  //   TrajectoryPoint point;\n  //   point.mutable_path_point()->set_x(start_pose.x());\n  //   point.mutable_path_point()->set_y(start_pose.y());\n  //   point.set_a(next_point_.has_a() ? next_point_.a() : 0.0);\n  //   point.set_v(next_point_.has_v() ? next_point_.v() : 0.0);\n  //   double theta = 0.0;\n  //   double s = 0.0;\n  //   map_service_->GetPoseWithRegardToLane(start_pose.x(), start_pose.y(),\n  //                                         &theta, &s);\n  //   point.mutable_path_point()->set_theta(theta);\n  //   SetStartPoint(point);\n  // }\n}\n\nvoid SimPerfectControl::OnRoutingRequest(\n    const std::shared_ptr<RoutingRequest>& routing_request) {\n  std::lock_guard<std::mutex> lock(mutex_);\n  if (!enabled_) {\n    return;\n  }\n\n  CHECK_GE(routing_request->waypoint_size(), 2)\n      << \"routing should have at least two waypoints\";\n  const auto& start_pose = routing_request->waypoint(0).pose();\n\n  ClearPlanning();\n  TrajectoryPoint point;\n  point.mutable_path_point()->set_x(start_pose.x());\n  point.mutable_path_point()->set_y(start_pose.y());\n  point.set_a(next_point_.has_a() ? next_point_.a() : 0.0);\n  point.set_v(next_point_.has_v() ? next_point_.v() : 0.0);\n  double theta = 0.0;\n  double s = 0.0;\n  const auto& start_way_point = routing_request->waypoint().Get(0);\n  // If the lane id has been set, set theta as the lane heading.\n  if (start_way_point.has_id()) {\n    auto& hdmap = hdmap::HDMapUtil::BaseMap();\n    hdmap::Id lane_id = hdmap::MakeMapId(start_way_point.id());\n    auto lane = hdmap.GetLaneById(lane_id);\n    if (nullptr != lane) {\n      theta = lane->Heading(start_way_point.s());\n    } else {\n      map_service_->GetPoseWithRegardToLane(start_pose.x(), start_pose.y(),\n                                            &theta, &s);\n    }\n  } else {\n    // Find the lane nearest to the start pose and get its heading as theta.\n    map_service_->GetPoseWithRegardToLane(start_pose.x(), start_pose.y(),\n                                          &theta, &s);\n  }\n\n  point.mutable_path_point()->set_theta(theta);\n  SetStartPoint(point);\n}\n\nvoid SimPerfectControl::OnPredictionObstacles(\n    const std::shared_ptr<PredictionObstacles> &obstacles) {\n  std::lock_guard<std::mutex> lock(mutex_);\n\n  if (!enabled_) {\n    return;\n  }\n\n  send_dummy_prediction_ = obstacles->header().module_name() == \"SimPrediction\";\n}\n\nvoid SimPerfectControl::Start() {\n  std::lock_guard<std::mutex> lock(mutex_);\n\n  if (!enabled_) {\n    // When there is no localization yet, Init(true) will use a\n    // dummy point from the current map as an arbitrary start.\n    // When localization is already available, we do not need to\n    // reset/override the start point.\n    localization_reader_->Observe();\n    Json start_point_attr({});\n    start_point_attr[\"start_velocity\"] =\n        next_point_.has_v() ? next_point_.v() : 0.0;\n    start_point_attr[\"start_acceleration\"] =\n        next_point_.has_a() ? next_point_.a() : 0.0;\n    Init(true, start_point_attr);\n    InternalReset();\n    sim_control_timer_->Start();\n    sim_prediction_timer_->Start();\n    enabled_ = true;\n  }\n}\n\nvoid SimPerfectControl::Start(double x, double y) {\n  std::lock_guard<std::mutex> lock(mutex_);\n  if (!enabled_) {\n    // Do not use localization info. use scenario start point to init start\n    // point.\n    InitStartPoint(x, y, 0, 0);\n    InternalReset();\n    sim_control_timer_->Start();\n    sim_prediction_timer_->Start();\n    enabled_ = true;\n  }\n}\n\nvoid SimPerfectControl::OnPlanning(\n    const std::shared_ptr<ADCTrajectory> &trajectory) {\n  std::lock_guard<std::mutex> lock(mutex_);\n\n  if (!enabled_) {\n    return;\n  }\n\n  // Reset current trajectory and the indices upon receiving a new trajectory.\n  // The routing SimPerfectControl owns must match with the one Planning has.\n  if (re_routing_triggered_ ||\n      IsSameHeader(trajectory->routing_header(), current_routing_header_)) {\n    current_trajectory_ = trajectory;\n    prev_point_index_ = 0;\n    next_point_index_ = 0;\n    received_planning_ = true;\n  } else {\n    ClearPlanning();\n  }\n}\n\nvoid SimPerfectControl::Freeze() {\n  next_point_.set_v(0.0);\n  next_point_.set_a(0.0);\n  prev_point_ = next_point_;\n}\n\nvoid SimPerfectControl::RunOnce() {\n  std::lock_guard<std::mutex> lock(mutex_);\n\n  TrajectoryPoint trajectory_point;\n  Chassis::GearPosition gear_position;\n  if (!PerfectControlModel(&trajectory_point, &gear_position)) {\n    AERROR << \"Failed to calculate next point with perfect control model\";\n    return;\n  }\n\n  PublishChassis(trajectory_point.v(), gear_position);\n  PublishLocalization(trajectory_point);\n}\n\nbool SimPerfectControl::PerfectControlModel(\n    TrajectoryPoint *point, Chassis::GearPosition *gear_position) {\n  // Result of the interpolation.\n  auto current_time = Clock::NowInSeconds();\n  const auto &trajectory = current_trajectory_->trajectory_point();\n  *gear_position = current_trajectory_->gear();\n\n  if (!received_planning_) {\n    prev_point_ = next_point_;\n  } else {\n    if (current_trajectory_->estop().is_estop() ||\n        next_point_index_ >= trajectory.size()) {\n      // Freeze the car when there's an estop or the current trajectory has\n      // been exhausted.\n      Freeze();\n    } else {\n      // Determine the status of the car based on received planning message.\n      while (next_point_index_ < trajectory.size() &&\n             current_time > trajectory.Get(next_point_index_).relative_time() +\n                                current_trajectory_->header().timestamp_sec()) {\n        ++next_point_index_;\n      }\n\n      if (next_point_index_ >= trajectory.size()) {\n        next_point_index_ = trajectory.size() - 1;\n      }\n\n      if (next_point_index_ == 0) {\n        AERROR << \"First trajectory point is a future point!\";\n        return false;\n      }\n\n      prev_point_index_ = next_point_index_ - 1;\n\n      next_point_ = trajectory.Get(next_point_index_);\n      prev_point_ = trajectory.Get(prev_point_index_);\n    }\n  }\n\n  if (current_time > next_point_.relative_time() +\n                         current_trajectory_->header().timestamp_sec()) {\n    // Don't try to extrapolate if relative_time passes last point\n    *point = next_point_;\n  } else {\n    *point = InterpolateUsingLinearApproximation(\n        prev_point_, next_point_,\n        current_time - current_trajectory_->header().timestamp_sec());\n  }\n  return true;\n}\n\nvoid SimPerfectControl::PublishChassis(double cur_speed,\n                                       Chassis::GearPosition gear_position) {\n  auto chassis = std::make_shared<Chassis>();\n  FillHeader(\"SimPerfectControl\", chassis.get());\n\n  chassis->set_engine_started(true);\n  chassis->set_driving_mode(Chassis::COMPLETE_AUTO_DRIVE);\n  chassis->set_gear_location(gear_position);\n\n  chassis->set_speed_mps(static_cast<float>(cur_speed));\n  if (gear_position == canbus::Chassis::GEAR_REVERSE) {\n    chassis->set_speed_mps(-chassis->speed_mps());\n  }\n\n  chassis->set_throttle_percentage(0.0);\n  chassis->set_brake_percentage(0.0);\n\n  chassis_writer_->Write(chassis);\n}\n\nvoid SimPerfectControl::PublishLocalization(const TrajectoryPoint &point) {\n  auto localization = std::make_shared<LocalizationEstimate>();\n  FillHeader(\"SimPerfectControl\", localization.get());\n\n  auto *pose = localization->mutable_pose();\n  auto prev = prev_point_.path_point();\n  auto next = next_point_.path_point();\n\n  // Set position\n  pose->mutable_position()->set_x(point.path_point().x());\n  pose->mutable_position()->set_y(point.path_point().y());\n  pose->mutable_position()->set_z(point.path_point().z());\n  // Set orientation and heading\n  double cur_theta = point.path_point().theta();\n\n  if (FLAGS_use_navigation_mode) {\n    double flu_x = point.path_point().x();\n    double flu_y = point.path_point().y();\n\n    Eigen::Vector2d enu_coordinate =\n        common::math::RotateVector2d({flu_x, flu_y}, cur_theta);\n\n    enu_coordinate.x() += adc_position_.x();\n    enu_coordinate.y() += adc_position_.y();\n    pose->mutable_position()->set_x(enu_coordinate.x());\n    pose->mutable_position()->set_y(enu_coordinate.y());\n  }\n\n  Eigen::Quaternion<double> cur_orientation =\n      HeadingToQuaternion<double>(cur_theta);\n  pose->mutable_orientation()->set_qw(cur_orientation.w());\n  pose->mutable_orientation()->set_qx(cur_orientation.x());\n  pose->mutable_orientation()->set_qy(cur_orientation.y());\n  pose->mutable_orientation()->set_qz(cur_orientation.z());\n  pose->set_heading(cur_theta);\n\n  // Set linear_velocity\n  pose->mutable_linear_velocity()->set_x(std::cos(cur_theta) * point.v());\n  pose->mutable_linear_velocity()->set_y(std::sin(cur_theta) * point.v());\n  pose->mutable_linear_velocity()->set_z(0);\n\n  // Set angular_velocity in both map reference frame and vehicle reference\n  // frame\n  pose->mutable_angular_velocity()->set_x(0);\n  pose->mutable_angular_velocity()->set_y(0);\n  pose->mutable_angular_velocity()->set_z(point.v() *\n                                          point.path_point().kappa());\n\n  TransformToVRF(pose->angular_velocity(), pose->orientation(),\n                 pose->mutable_angular_velocity_vrf());\n\n  // Set linear_acceleration in both map reference frame and vehicle reference\n  // frame\n  auto *linear_acceleration = pose->mutable_linear_acceleration();\n  linear_acceleration->set_x(std::cos(cur_theta) * point.a());\n  linear_acceleration->set_y(std::sin(cur_theta) * point.a());\n  linear_acceleration->set_z(0);\n\n  TransformToVRF(pose->linear_acceleration(), pose->orientation(),\n                 pose->mutable_linear_acceleration_vrf());\n\n  localization_writer_->Write(localization);\n\n  adc_position_.set_x(pose->position().x());\n  adc_position_.set_y(pose->position().y());\n  adc_position_.set_z(pose->position().z());\n}\n\nvoid SimPerfectControl::PublishDummyPrediction() {\n  auto prediction = std::make_shared<PredictionObstacles>();\n  {\n    std::lock_guard<std::mutex> lock(mutex_);\n    if (!send_dummy_prediction_) {\n      return;\n    }\n    FillHeader(\"SimPrediction\", prediction.get());\n  }\n  prediction_writer_->Write(prediction);\n}\n\n}  // namespace dreamview\n}  // namespace apollo",
        "base_contents": "",
        "res_region": "/******************************************************************************\n * Copyright 2017 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *****************************************************************************/\n\n#include \"modules/dreamview/backend/sim_control_manager/dynamic_model/perfect_control/sim_perfect_control.h\"\n\n#include \"cyber/common/file.h\"\n#include \"cyber/time/clock.h\"\n#include \"modules/common/adapters/adapter_gflags.h\"\n#include \"modules/common/math/linear_interpolation.h\"\n#include \"modules/common/math/math_utils.h\"\n#include \"modules/common/math/quaternion.h\"\n#include \"modules/common/util/message_util.h\"\n#include \"modules/common/util/util.h\"\n\nnamespace apollo {\nnamespace dreamview {\n\nusing apollo::canbus::Chassis;\nusing apollo::common::Header;\nusing apollo::common::Point3D;\nusing apollo::common::Quaternion;\nusing apollo::common::TrajectoryPoint;\nusing apollo::common::math::HeadingToQuaternion;\nusing apollo::common::math::InterpolateUsingLinearApproximation;\nusing apollo::common::math::InverseQuaternionRotate;\nusing apollo::common::util::FillHeader;\nusing apollo::cyber::Clock;\nusing apollo::localization::LocalizationEstimate;\nusing apollo::planning::ADCTrajectory;\nusing apollo::prediction::PredictionObstacles;\nusing apollo::relative_map::NavigationInfo;\nusing apollo::routing::RoutingResponse;\nusing apollo::routing::RoutingRequest;\nusing Json = nlohmann::json;\n\nnamespace {\n\nvoid TransformToVRF(const Point3D &point_mrf, const Quaternion &orientation,\n                    Point3D *point_vrf) {\n  Eigen::Vector3d v_mrf(point_mrf.x(), point_mrf.y(), point_mrf.z());\n  auto v_vrf = InverseQuaternionRotate(orientation, v_mrf);\n  point_vrf->set_x(v_vrf.x());\n  point_vrf->set_y(v_vrf.y());\n  point_vrf->set_z(v_vrf.z());\n}\n\nbool IsSameHeader(const Header &lhs, const Header &rhs) {\n  return lhs.sequence_num() == rhs.sequence_num() &&\n         lhs.timestamp_sec() == rhs.timestamp_sec();\n}\n\n}  // namespace\n\nSimPerfectControl::SimPerfectControl(const MapService *map_service)\n    : SimControlBase(),\n      map_service_(map_service),\n      node_(cyber::CreateNode(\"sim_perfect_control\")),\n      current_trajectory_(std::make_shared<ADCTrajectory>()) {\n  InitTimerAndIO();\n}\n\nvoid SimPerfectControl::InitTimerAndIO() {\n  localization_reader_ =\n      node_->CreateReader<LocalizationEstimate>(FLAGS_localization_topic);\n  planning_reader_ = node_->CreateReader<ADCTrajectory>(\n      FLAGS_planning_trajectory_topic,\n      [this](const std::shared_ptr<ADCTrajectory> &trajectory) {\n        this->OnPlanning(trajectory);\n      });\n  routing_request_reader_ = node_->CreateReader<RoutingRequest>(\n      FLAGS_routing_request_topic,\n      [this](const std::shared_ptr<RoutingRequest> &routing_request) {\n        this->OnRoutingRequest(routing_request);\n      });\n  routing_response_reader_ = node_->CreateReader<RoutingResponse>(\n      FLAGS_routing_response_topic,\n      [this](const std::shared_ptr<RoutingResponse> &routing) {\n        this->OnRoutingResponse(routing);\n      });\n  navigation_reader_ = node_->CreateReader<NavigationInfo>(\n      FLAGS_navigation_topic,\n      [this](const std::shared_ptr<NavigationInfo> &navigation_info) {\n        this->OnReceiveNavigationInfo(navigation_info);\n      });\n  prediction_reader_ = node_->CreateReader<PredictionObstacles>(\n      FLAGS_prediction_topic,\n      [this](const std::shared_ptr<PredictionObstacles> &obstacles) {\n        this->OnPredictionObstacles(obstacles);\n      });\n\n  localization_writer_ =\n      node_->CreateWriter<LocalizationEstimate>(FLAGS_localization_topic);\n  chassis_writer_ = node_->CreateWriter<Chassis>(FLAGS_chassis_topic);\n  prediction_writer_ =\n      node_->CreateWriter<PredictionObstacles>(FLAGS_prediction_topic);\n\n  // Start timer to publish localization and chassis messages.\n  sim_control_timer_.reset(new cyber::Timer(\n      kSimControlIntervalMs, [this]() { this->RunOnce(); }, false));\n  sim_prediction_timer_.reset(\n      new cyber::Timer(kSimPredictionIntervalMs,\n                       [this]() { this->PublishDummyPrediction(); }, false));\n}\n\nvoid SimPerfectControl::Init(bool set_start_point,\n                             nlohmann::json start_point_attr,\n                             bool use_start_point_position) {\n  if (set_start_point && !FLAGS_use_navigation_mode) {\n    InitStartPoint(start_point_attr[\"start_velocity\"],\n                   start_point_attr[\"start_acceleration\"]);\n  }\n}\n\nvoid SimPerfectControl::InitStartPoint(double x, double y,\n                                       double start_velocity,\n                                       double start_acceleration) {\n  TrajectoryPoint point;\n  // Use the scenario start point as start point,\n  start_point_from_localization_ = false;\n  point.mutable_path_point()->set_x(x);\n  point.mutable_path_point()->set_y(y);\n  // z use default 0\n  point.mutable_path_point()->set_z(0);\n  double theta = 0.0;\n  double s = 0.0;\n  map_service_->GetPoseWithRegardToLane(x, y, &theta, &s);\n  point.mutable_path_point()->set_theta(theta);\n  point.set_v(start_velocity);\n  point.set_a(start_acceleration);\n  SetStartPoint(point);\n}\n\nvoid SimPerfectControl::InitStartPoint(double start_velocity,\n                                       double start_acceleration) {\n  TrajectoryPoint point;\n  // Use the latest localization position as start point,\n  // fall back to a dummy point from map\n  localization_reader_->Observe();\n  start_point_from_localization_ = false;\n  if (!localization_reader_->Empty()) {\n    const auto &localization = localization_reader_->GetLatestObserved();\n    const auto &pose = localization->pose();\n    if (map_service_->PointIsValid(pose.position().x(), pose.position().y())) {\n      point.mutable_path_point()->set_x(pose.position().x());\n      point.mutable_path_point()->set_y(pose.position().y());\n      point.mutable_path_point()->set_z(pose.position().z());\n      point.mutable_path_point()->set_theta(pose.heading());\n      point.set_v(\n          std::hypot(pose.linear_velocity().x(), pose.linear_velocity().y()));\n      // Calculates the dot product of acceleration and velocity. The sign\n      // of this projection indicates whether this is acceleration or\n      // deceleration.\n      double projection =\n          pose.linear_acceleration().x() * pose.linear_velocity().x() +\n          pose.linear_acceleration().y() * pose.linear_velocity().y();\n\n      // Calculates the magnitude of the acceleration. Negate the value if\n      // it is indeed a deceleration.\n      double magnitude = std::hypot(pose.linear_acceleration().x(),\n                                    pose.linear_acceleration().y());\n      point.set_a(std::signbit(projection) ? -magnitude : magnitude);\n      start_point_from_localization_ = true;\n    }\n  }\n  if (!start_point_from_localization_) {\n    apollo::common::PointENU start_point;\n    if (!map_service_->GetStartPoint(&start_point)) {\n      AWARN << \"Failed to get a dummy start point from map!\";\n      return;\n    }\n    point.mutable_path_point()->set_x(start_point.x());\n    point.mutable_path_point()->set_y(start_point.y());\n    point.mutable_path_point()->set_z(start_point.z());\n    double theta = 0.0;\n    double s = 0.0;\n    map_service_->GetPoseWithRegardToLane(start_point.x(), start_point.y(),\n                                          &theta, &s);\n    point.mutable_path_point()->set_theta(theta);\n    point.set_v(start_velocity);\n    point.set_a(start_acceleration);\n  }\n  SetStartPoint(point);\n}\n\nvoid SimPerfectControl::SetStartPoint(const TrajectoryPoint &start_point) {\n  next_point_ = start_point;\n  prev_point_index_ = next_point_index_ = 0;\n  received_planning_ = false;\n}\n\nvoid SimPerfectControl::Reset() {\n  std::lock_guard<std::mutex> lock(mutex_);\n  InternalReset();\n}\n\nvoid SimPerfectControl::Stop() {\n  std::lock_guard<std::mutex> lock(mutex_);\n\n  if (enabled_) {\n    sim_control_timer_->Stop();\n    sim_prediction_timer_->Stop();\n    enabled_ = false;\n  }\n}\n\nvoid SimPerfectControl::InternalReset() {\n  current_routing_header_.Clear();\n  re_routing_triggered_ = false;\n  send_dummy_prediction_ = true;\n  ClearPlanning();\n}\n\nvoid SimPerfectControl::ClearPlanning() {\n  current_trajectory_->Clear();\n  received_planning_ = false;\n}\n\nvoid SimPerfectControl::OnReceiveNavigationInfo(\n    const std::shared_ptr<NavigationInfo> &navigation_info) {\n  std::lock_guard<std::mutex> lock(mutex_);\n\n  if (navigation_info->navigation_path_size() > 0) {\n    const auto &path = navigation_info->navigation_path(0).path();\n    if (path.path_point_size() > 0) {\n      adc_position_ = path.path_point(0);\n    }\n  }\n}\n\nvoid SimPerfectControl::OnRoutingResponse(\n    const std::shared_ptr<RoutingResponse> &routing) {\n  std::lock_guard<std::mutex> lock(mutex_);\n  if (!enabled_) {\n    return;\n  }\n\n  CHECK_GE(routing->routing_request().waypoint_size(), 2)\n      << \"routing should have at least two waypoints\";\n\n  current_routing_header_ = routing->header();\n\n  // // If this is from a planning re-routing request, or the start point has\n  // // been\n  // // initialized by an actual localization pose, don't reset the start point.\n  // re_routing_triggered_ =\n  //     routing->routing_request().header().module_name() == \"planning\";\n  // if (!re_routing_triggered_ && !start_point_from_localization_) {\n  //   ClearPlanning();\n  //   TrajectoryPoint point;\n  //   point.mutable_path_point()->set_x(start_pose.x());\n  //   point.mutable_path_point()->set_y(start_pose.y());\n  //   point.set_a(next_point_.has_a() ? next_point_.a() : 0.0);\n  //   point.set_v(next_point_.has_v() ? next_point_.v() : 0.0);\n  //   double theta = 0.0;\n  //   double s = 0.0;\n  //   map_service_->GetPoseWithRegardToLane(start_pose.x(), start_pose.y(),\n  //                                         &theta, &s);\n  //   point.mutable_path_point()->set_theta(theta);\n  //   SetStartPoint(point);\n  // }\n}\n\nvoid SimPerfectControl::OnRoutingRequest(\n    const std::shared_ptr<RoutingRequest> &routing_request) {\n  std::lock_guard<std::mutex> lock(mutex_);\n  if (!enabled_) {\n    return;\n  }\n\n  CHECK_GE(routing_request->waypoint_size(), 2)\n      << \"routing should have at least two waypoints\";\n  const auto &start_pose = routing_request->waypoint(0).pose();\n\n  ClearPlanning();\n  TrajectoryPoint point;\n  point.mutable_path_point()->set_x(start_pose.x());\n  point.mutable_path_point()->set_y(start_pose.y());\n  point.set_a(next_point_.has_a() ? next_point_.a() : 0.0);\n  point.set_v(next_point_.has_v() ? next_point_.v() : 0.0);\n  double theta = 0.0;\n  double s = 0.0;\n  const auto &start_way_point = routing_request->waypoint().Get(0);\n  // If the lane id has been set, set theta as the lane heading.\n  if (start_way_point.has_id()) {\n    auto &hdmap = hdmap::HDMapUtil::BaseMap();\n    hdmap::Id lane_id = hdmap::MakeMapId(start_way_point.id());\n    auto lane = hdmap.GetLaneById(lane_id);\n    if (nullptr != lane) {\n      theta = lane->Heading(start_way_point.s());\n    } else {\n      map_service_->GetPoseWithRegardToLane(start_pose.x(), start_pose.y(),\n                                            &theta, &s);\n    }\n  } else {\n    // Find the lane nearest to the start pose and get its heading as theta.\n    map_service_->GetPoseWithRegardToLane(start_pose.x(), start_pose.y(),\n                                          &theta, &s);\n  }\n\n  point.mutable_path_point()->set_theta(theta);\n  SetStartPoint(point);\n}\n\nvoid SimPerfectControl::OnPredictionObstacles(\n    const std::shared_ptr<PredictionObstacles> &obstacles) {\n  std::lock_guard<std::mutex> lock(mutex_);\n\n  if (!enabled_) {\n    return;\n  }\n\n  send_dummy_prediction_ = obstacles->header().module_name() == \"SimPrediction\";\n}\n\nvoid SimPerfectControl::Start() {\n  std::lock_guard<std::mutex> lock(mutex_);\n\n  if (!enabled_) {\n    // When there is no localization yet, Init(true) will use a\n    // dummy point from the current map as an arbitrary start.\n    // When localization is already available, we do not need to\n    // reset/override the start point.\n    localization_reader_->Observe();\n    Json start_point_attr({});\n    start_point_attr[\"start_velocity\"] =\n        next_point_.has_v() ? next_point_.v() : 0.0;\n    start_point_attr[\"start_acceleration\"] =\n        next_point_.has_a() ? next_point_.a() : 0.0;\n    Init(true, start_point_attr);\n    InternalReset();\n    sim_control_timer_->Start();\n    sim_prediction_timer_->Start();\n    enabled_ = true;\n  }\n}\n\nvoid SimPerfectControl::Start(double x, double y) {\n  std::lock_guard<std::mutex> lock(mutex_);\n  if (!enabled_) {\n    // Do not use localization info. use scenario start point to init start\n    // point.\n    InitStartPoint(x, y, 0, 0);\n    InternalReset();\n    sim_control_timer_->Start();\n    sim_prediction_timer_->Start();\n    enabled_ = true;\n  }\n}\n\nvoid SimPerfectControl::OnPlanning(\n    const std::shared_ptr<ADCTrajectory> &trajectory) {\n  std::lock_guard<std::mutex> lock(mutex_);\n\n  if (!enabled_) {\n    return;\n  }\n\n  // Reset current trajectory and the indices upon receiving a new trajectory.\n  // The routing SimPerfectControl owns must match with the one Planning has.\n  if (re_routing_triggered_ ||\n      IsSameHeader(trajectory->routing_header(), current_routing_header_)) {\n    current_trajectory_ = trajectory;\n    prev_point_index_ = 0;\n    next_point_index_ = 0;\n    received_planning_ = true;\n  } else {\n    ClearPlanning();\n  }\n}\n\nvoid SimPerfectControl::Freeze() {\n  next_point_.set_v(0.0);\n  next_point_.set_a(0.0);\n  prev_point_ = next_point_;\n}\n\nvoid SimPerfectControl::RunOnce() {\n  std::lock_guard<std::mutex> lock(mutex_);\n\n  TrajectoryPoint trajectory_point;\n  Chassis::GearPosition gear_position;\n  if (!PerfectControlModel(&trajectory_point, &gear_position)) {\n    AERROR << \"Failed to calculate next point with perfect control model\";\n    return;\n  }\n\n  PublishChassis(trajectory_point.v(), gear_position);\n  PublishLocalization(trajectory_point);\n}\n\nbool SimPerfectControl::PerfectControlModel(\n    TrajectoryPoint *point, Chassis::GearPosition *gear_position) {\n  // Result of the interpolation.\n  auto current_time = Clock::NowInSeconds();\n  const auto &trajectory = current_trajectory_->trajectory_point();\n  *gear_position = current_trajectory_->gear();\n\n  if (!received_planning_) {\n    prev_point_ = next_point_;\n  } else {\n    if (current_trajectory_->estop().is_estop() ||\n        next_point_index_ >= trajectory.size()) {\n      // Freeze the car when there's an estop or the current trajectory has\n      // been exhausted.\n      Freeze();\n    } else {\n      // Determine the status of the car based on received planning message.\n      while (next_point_index_ < trajectory.size() &&\n             current_time > trajectory.Get(next_point_index_).relative_time() +\n                                current_trajectory_->header().timestamp_sec()) {\n        ++next_point_index_;\n      }\n\n      if (next_point_index_ >= trajectory.size()) {\n        next_point_index_ = trajectory.size() - 1;\n      }\n\n      if (next_point_index_ == 0) {\n        AERROR << \"First trajectory point is a future point!\";\n        return false;\n      }\n\n      prev_point_index_ = next_point_index_ - 1;\n\n      next_point_ = trajectory.Get(next_point_index_);\n      prev_point_ = trajectory.Get(prev_point_index_);\n    }\n  }\n\n  if (current_time > next_point_.relative_time() +\n                         current_trajectory_->header().timestamp_sec()) {\n    // Don't try to extrapolate if relative_time passes last point\n    *point = next_point_;\n  } else {\n    *point = InterpolateUsingLinearApproximation(\n        prev_point_, next_point_,\n        current_time - current_trajectory_->header().timestamp_sec());\n  }\n  return true;\n}\n\nvoid SimPerfectControl::PublishChassis(double cur_speed,\n                                       Chassis::GearPosition gear_position) {\n  auto chassis = std::make_shared<Chassis>();\n  FillHeader(\"SimPerfectControl\", chassis.get());\n\n  chassis->set_engine_started(true);\n  chassis->set_driving_mode(Chassis::COMPLETE_AUTO_DRIVE);\n  chassis->set_gear_location(gear_position);\n\n  chassis->set_speed_mps(static_cast<float>(cur_speed));\n  if (gear_position == canbus::Chassis::GEAR_REVERSE) {\n    chassis->set_speed_mps(-chassis->speed_mps());\n  }\n\n  chassis->set_throttle_percentage(0.0);\n  chassis->set_brake_percentage(0.0);\n\n  chassis_writer_->Write(chassis);\n}\n\nvoid SimPerfectControl::PublishLocalization(const TrajectoryPoint &point) {\n  auto localization = std::make_shared<LocalizationEstimate>();\n  FillHeader(\"SimPerfectControl\", localization.get());\n\n  auto *pose = localization->mutable_pose();\n  auto prev = prev_point_.path_point();\n  auto next = next_point_.path_point();\n\n  // Set position\n  pose->mutable_position()->set_x(point.path_point().x());\n  pose->mutable_position()->set_y(point.path_point().y());\n  pose->mutable_position()->set_z(point.path_point().z());\n  // Set orientation and heading\n  double cur_theta = point.path_point().theta();\n\n  if (FLAGS_use_navigation_mode) {\n    double flu_x = point.path_point().x();\n    double flu_y = point.path_point().y();\n\n    Eigen::Vector2d enu_coordinate =\n        common::math::RotateVector2d({flu_x, flu_y}, cur_theta);\n\n    enu_coordinate.x() += adc_position_.x();\n    enu_coordinate.y() += adc_position_.y();\n    pose->mutable_position()->set_x(enu_coordinate.x());\n    pose->mutable_position()->set_y(enu_coordinate.y());\n  }\n\n  Eigen::Quaternion<double> cur_orientation =\n      HeadingToQuaternion<double>(cur_theta);\n  pose->mutable_orientation()->set_qw(cur_orientation.w());\n  pose->mutable_orientation()->set_qx(cur_orientation.x());\n  pose->mutable_orientation()->set_qy(cur_orientation.y());\n  pose->mutable_orientation()->set_qz(cur_orientation.z());\n  pose->set_heading(cur_theta);\n\n  // Set linear_velocity\n  pose->mutable_linear_velocity()->set_x(std::cos(cur_theta) * point.v());\n  pose->mutable_linear_velocity()->set_y(std::sin(cur_theta) * point.v());\n  pose->mutable_linear_velocity()->set_z(0);\n\n  // Set angular_velocity in both map reference frame and vehicle reference\n  // frame\n  pose->mutable_angular_velocity()->set_x(0);\n  pose->mutable_angular_velocity()->set_y(0);\n  pose->mutable_angular_velocity()->set_z(point.v() *\n                                          point.path_point().kappa());\n\n  TransformToVRF(pose->angular_velocity(), pose->orientation(),\n                 pose->mutable_angular_velocity_vrf());\n\n  // Set linear_acceleration in both map reference frame and vehicle reference\n  // frame\n  auto *linear_acceleration = pose->mutable_linear_acceleration();\n  linear_acceleration->set_x(std::cos(cur_theta) * point.a());\n  linear_acceleration->set_y(std::sin(cur_theta) * point.a());\n  linear_acceleration->set_z(0);\n\n  TransformToVRF(pose->linear_acceleration(), pose->orientation(),\n                 pose->mutable_linear_acceleration_vrf());\n\n  localization_writer_->Write(localization);\n\n  adc_position_.set_x(pose->position().x());\n  adc_position_.set_y(pose->position().y());\n  adc_position_.set_z(pose->position().z());\n}\n\nvoid SimPerfectControl::PublishDummyPrediction() {\n  auto prediction = std::make_shared<PredictionObstacles>();\n  {\n    std::lock_guard<std::mutex> lock(mutex_);\n    if (!send_dummy_prediction_) {\n      return;\n    }\n    FillHeader(\"SimPrediction\", prediction.get());\n  }\n  prediction_writer_->Write(prediction);\n}\n\n}  // namespace dreamview\n}  // namespace apollo",
        "lookback": " * Copyright 2017 The Apollo Authors. All Rights Reserved.",
        "lookahead": "",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 0,
        "end_line": 1112,
        "merge_gen_region": " Copyright Thepol Authors All Reserved/****************************************************************************** Copyright Thepol Authors All Reserved * Licensed the Apache, 20theLicense *\"); you not this except in with the. * may a of License * may a of License * * httpwwwapacheorglicensesLICENSE20 * Unless by law agreed in,, * under License distributed anAS\" BASIS * WARRANTIES CONDITIONS ANY, either or. See License the language permissions * under License *****************************************************************************/includemodulesdrviewbackendsimcontrolmanagerdynamicmodelperf_/simperf_ectcontrolh # \"bercommonfileh # \"bertimeclockh # \"/commonadapt/ersadapterg.\"includemodulescommonmathlinearinter.\"includemodulescommonmathmath_..\"includemodulescommonmathqu.\"includemodulescommonutilmessageutilh # \"modulescommonutilutilh namespacepol { drview using alocan::assis usingpol::::; alocommonHeader usingpol::::::3; alocommonQuaternion usingpol::::TrPoint usingpol::::::::3; alocommonQuaternion usingpol::::ajectory; alolocommoncommonmathHeadTo; alolocal::izationLocalEstimate usingpol::ningADCTj; alopredictionPredObs usingpol::::",
        "confidence": 0.9443941116333008,
        "hesitated": false,
        "resolved": false
    }
]