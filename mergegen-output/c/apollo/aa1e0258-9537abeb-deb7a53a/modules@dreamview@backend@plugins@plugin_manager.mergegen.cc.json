[
    {
        "a_contents": "/******************************************************************************\n * Copyright 2019 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *****************************************************************************/\n#include \"modules/dreamview/backend/plugins/plugin_manager.h\"\n\n#include <dirent.h>\n\n#include <limits>\n#include <string>\n\n#include \"google/protobuf/util/json_util.h\"\n\n#include \"cyber/common/file.h\"\n#include \"modules/common/util/json_util.h\"\n#include \"modules/common/util/message_util.h\"\n#include \"modules/dreamview/backend/common/dreamview_gflags.h\"\n\nusing apollo::common::util::FillHeader;\nusing apollo::common::util::JsonUtil;\nusing google::protobuf::util::JsonStringToMessage;\nusing Json = nlohmann::json;\nusing std::string;\n\n// scenario_set: update one scenario set from studio to local\n// scenarios: update all scenarios\nnamespace {\nstd::map<string, int> data_type_dict = {{\n                                            \"scenario_set\", 0,\n                                        },\n                                        {\n                                            \"scenarios\", 1,\n                                        },\n                                        {\n                                            \"dynamic_model\", 2,\n                                        },\n                                        {\n                                            \"records\", 3,\n                                        },\n                                        {\n                                            \"vehicles\", 4,\n                                        }};\n}  // namespace\nnamespace apollo {     // namespace apollo\nnamespace dreamview {  // namespace dreamview\nPluginManager::PluginManager(WebSocketHandler* plugin_ws)\n    : node_(cyber::CreateNode(\"PluginManager\")),\n      enabled_(false),\n      plugin_ws_(plugin_ws) {\n  RegisterDvSupportApis();\n  RegisterPlugins();\n}\n\nvoid PluginManager::Start(DvCallback callback_api) {\n  callback_api_ = callback_api;\n  enabled_ = true;\n  return;\n}\n\nvoid PluginManager::Stop() {\n  if (enabled_) {\n    std::string stop_command;\n    for (auto iter = plugins_.begin(); iter != plugins_.end(); iter++) {\n      stop_command = iter->second.stop_command;\n      const int ret = std::system(stop_command.data());\n      if (ret != 0) {\n        AERROR << \"Failed to stop plugin! ret: \" << ret;\n      }\n    }\n    plugins_.clear();\n    // need kill all plugin process\n  }\n  enabled_ = false;\n}\n\nauto PluginManager::InitPluginReader(const ChannelConf& channel_conf,\n                                     const string& channel_prefix,\n                                     const string& plugin_name)\n    -> std::shared_ptr<cyber::Reader<DvPluginMsg>> {\n  if (!channel_conf.has_location()) {\n    AERROR << \"Failed to init reader for plugins for missing required file \"\n              \"location\";\n    return nullptr;\n  }\n  const string channel_location = channel_conf.location();\n  // Plugin related channel name should follow the plugin specification\n  if (channel_location.find(channel_prefix) != 0) {\n    AERROR << \"Plugin related channel should observe channel name conventions!\";\n    return nullptr;\n  }\n  if (plugins_[plugin_name].readers.find(channel_location) !=\n      plugins_[plugin_name].readers.end()) {\n    AERROR << \"Plugin has already register this channel: \" << channel_location;\n    return nullptr;\n  }\n  cyber::ReaderConfig reader_config;\n  reader_config.channel_name = channel_location;\n  reader_config.pending_queue_size = channel_conf.pending_queue_size();\n  auto reader = node_->CreateReader<DvPluginMsg>(\n      reader_config, [this](const std::shared_ptr<DvPluginMsg>& msg) {\n        if (!ReceiveMsgFromPlugin(*msg)) {\n          AERROR << \"Failed to handle received msg from plugin\";\n        }\n        return;\n      });\n  return reader;\n};\n\nauto PluginManager::InitPluginWriterAndMsg(const ChannelConf& channel_conf,\n                                           const string& channel_prefix,\n                                           const string& plugin_name)\n    -> std::shared_ptr<cyber::Writer<DvPluginMsg>> {\n  if (!channel_conf.has_location()) {\n    AERROR << \"Failed to init writer for plugins for missing required file \"\n              \"location\";\n    return nullptr;\n  }\n  const string channel_location = channel_conf.location();\n  // Plugin related channel name should follow the plugin specification\n  if (channel_location.find(channel_prefix) != 0) {\n    AERROR << \"Plugin related channel should observe channel name conventions!\";\n    return nullptr;\n  }\n  if (plugins_[plugin_name].writers.find(channel_location) !=\n      plugins_[plugin_name].writers.end()) {\n    AERROR << \"Plugin has already register this channel!\";\n    return nullptr;\n  }\n  auto writer = node_->CreateWriter<DvPluginMsg>(channel_location);\n  if (!writer) {\n    AERROR << \"Failed to create writer!\";\n    return nullptr;\n  }\n  plugins_[plugin_name].writers[channel_location] = writer;\n  if (channel_conf.support_msg_name_size()) {\n    for (auto& support_msg : channel_conf.support_msg_name()) {\n      if (plugins_[plugin_name].plugin_accept_msg.find(support_msg) !=\n          plugins_[plugin_name].plugin_accept_msg.end()) {\n        AERROR << \"One-to-one message and channel, no repetition is allowed\";\n        return nullptr;\n      }\n      plugins_[plugin_name].plugin_accept_msg[support_msg] = channel_location;\n    }\n  }\n  return writer;\n};\n\nbool PluginManager::RegisterPlugin(\n    const std::shared_ptr<PluginConfig>& plugin_config) {\n  if (!plugin_config->has_name() || !plugin_config->has_launch_command() ||\n      !plugin_config->process_command_keywords_size() ||\n      !plugin_config->has_stop_command()) {\n    AERROR << \"Failed to register plugin for required fields missing!\";\n    return false;\n  }\n  string plugin_name = plugin_config->name();\n  string launch_command = plugin_config->launch_command();\n  if (plugins_.find(plugin_name) != plugins_.end()) {\n    AERROR << \"This plugin has already registered! Don't install the plugin \"\n              \"again!\";\n    return false;\n  }\n  struct PluginInfo plugin_info;\n  plugins_[plugin_name] = {};\n  plugins_[plugin_name].launch_command = launch_command;\n  plugins_[plugin_name].stop_command = plugin_config->stop_command();\n  string channel_prefix = FLAGS_plugin_channel_prefix + plugin_name + \"/\";\n  for (auto reader_channel_conf : plugin_config->reader_channel_conf()) {\n    auto plugin_reader =\n        InitPluginReader(reader_channel_conf, channel_prefix, plugin_name);\n    if (plugin_reader == nullptr) {\n      AERROR << \"Failed to register plugin reader!\";\n      plugins_.erase(plugin_name);\n      return false;\n    }\n  }\n  for (auto writer_channel_conf : plugin_config->writer_channel_conf()) {\n    auto plugin_writer = InitPluginWriterAndMsg(writer_channel_conf,\n                                                channel_prefix, plugin_name);\n    if (plugin_writer == nullptr) {\n      AERROR << \"Failed to register plugin writer!\";\n      plugins_.erase(plugin_name);\n      return false;\n    }\n  }\n  const int ret = std::system((\"nohup \" + launch_command + \" &\").data());\n  if (ret == 0) {\n    AINFO << \"SUCCESS to launch plugin: \" << plugin_name;\n  } else {\n    AERROR << \"Failed to launch plugin: \" << plugin_name << \" ret: \" << ret;\n    plugins_.erase(plugin_name);\n    return false;\n  }\n  for (auto command_keyword : plugin_config->process_command_keywords()) {\n    plugins_[plugin_name].process_command_keywords.push_back(command_keyword);\n  }\n  return true;\n}\n\nbool PluginManager::RegisterPlugins() {\n  const std::string plugin_path =\n      (cyber::common::GetEnv(\"HOME\")) + FLAGS_plugin_path;\n  DIR* directory = opendir(plugin_path.c_str());\n  if (directory == nullptr) {\n    AERROR << \"Cannot open directory \" << FLAGS_plugin_path;\n    return false;\n  }\n  struct dirent* entry;\n  bool register_res = true;\n  while ((entry = readdir(directory)) != nullptr && register_res) {\n    // skip directory_path/. and directory_path/..\n    if (!strcmp(entry->d_name, \".\") || !strcmp(entry->d_name, \"..\")) {\n      continue;\n    }\n    if (entry->d_type != DT_DIR) {\n      // skip not directory\n      continue;\n    }\n    const string plugin_config_file_name =\n        entry->d_name + FLAGS_plugin_config_file_name_suffix;\n    const string plugin_config_file_path =\n        (cyber::common::GetEnv(\"HOME\")) + FLAGS_plugin_path + \"/\" +\n        entry->d_name + \"/\" + plugin_config_file_name;\n    if (!cyber::common::PathExists(plugin_config_file_path)) {\n      AERROR << \"Cannot find plugin:\" << entry->d_name\n             << \" plugin config file, jump it!\";\n      continue;\n    }\n    auto plugin_config = std::make_shared<PluginConfig>();\n    if (!cyber::common::GetProtoFromFile(plugin_config_file_path,\n                                         plugin_config.get())) {\n      AWARN << \"Unable to read plugin config from file: \"\n            << plugin_config_file_path;\n      return false;\n    }\n    register_res = RegisterPlugin(plugin_config);\n  }\n  return register_res;\n}\n\nbool PluginManager::CheckPluginStatus(const string& plugin_name) {\n  if (plugins_.find(plugin_name) == plugins_.end()) {\n    AERROR << \"Failed to register this plugin, cann't check!\";\n    return false;\n  }\n  // todo: Extract the logic for monitoring plugin status\n  std::vector<string> running_processes;\n  for (const auto& cmd_file : cyber::common::Glob(\"/proc/*/cmdline\")) {\n    // Get process command string.\n    string cmd_string;\n    if (cyber::common::GetContent(cmd_file, &cmd_string) &&\n        !cmd_string.empty()) {\n      // In /proc/<PID>/cmdline, the parts are separated with \\0, which will be\n      // converted back to whitespaces here.\n      std::replace(cmd_string.begin(), cmd_string.end(), '\\0', ' ');\n      running_processes.push_back(cmd_string);\n    }\n  }\n  bool command_found = false;\n  for (const string& command : running_processes) {\n    bool all_keywords_matched = true;\n    for (const string& keyword :\n         plugins_[plugin_name].process_command_keywords) {\n      all_keywords_matched &= (command.find(keyword) != string::npos);\n      if (!all_keywords_matched) {\n        break;\n      }\n    }\n    command_found |= all_keywords_matched;\n  }\n  if (!command_found) {\n    AERROR << \"Failed to pass plugin status check!\";\n    return false;\n  }\n  // Process command keywords are all matched. The process is running.\n  return true;\n}\n\nbool PluginManager::SendMsgToPlugin(const string& json_str) {\n  auto plugin_msg = std::make_shared<DvPluginMsg>();\n  if (!JsonStringToMessage(json_str, plugin_msg.get()).ok()) {\n    AERROR << \"Failed to parse DvPluginMsg from json!\";\n    return false;\n  }\n  if (!plugin_msg->has_target() || !plugin_msg->has_name()) {\n    AERROR << \"Missing required field for DvPluginMsg.\";\n    return false;\n  }\n  const string plugin_name = plugin_msg->target();\n  if (!CheckPluginStatus(plugin_name)) {\n    return false;\n  }\n  const string msg_name = plugin_msg->name();\n\n  if (plugins_[plugin_name].plugin_accept_msg.find(msg_name) ==\n      plugins_[plugin_name].plugin_accept_msg.end()) {\n    AERROR << \"Plugin not accept this msg!\";\n    return false;\n  }\n  const string channel_location =\n      plugins_[plugin_name].plugin_accept_msg[msg_name];\n  if (plugins_[plugin_name].writers.find(channel_location) ==\n      plugins_[plugin_name].writers.end()) {\n    AERROR << \"The plugin does not support communication on this channel\";\n    return false;\n  }\n  FillHeader(\"PluginManager\", plugin_msg.get());\n  plugins_[plugin_name].writers[channel_location]->Write(plugin_msg);\n  return true;\n}\n\nvoid PluginManager::RegisterDvSupportApi(const string& api_name,\n                                         const DvApi& api) {\n  dv_support_apis_[api_name] = api;\n}\n\nvoid PluginManager::RegisterDvSupportApis() {\n  RegisterDvSupportApi(\"UpdateScenarioSetList\", &PluginManager::UpdateData);\n  RegisterDvSupportApi(\"UpdateDynamicModelList\", &PluginManager::UpdateData);\n  RegisterDvSupportApi(\"UpdateRecordToStatus\", &PluginManager::UpdateData);\n  RegisterDvSupportApi(\"ResetVehicleConfigSuccess\", &PluginManager::UpdateData);\n  RegisterDvSupportApi(\n    \"RefreshVehicleConfigSuccess\", &PluginManager::UpdateData);\n}\n\nbool PluginManager::ReceiveMsgFromPlugin(const DvPluginMsg& msg) {\n  if (!msg.has_name()) {\n    return false;\n  }\n  const string msg_name = msg.name();\n  if (dv_support_apis_.find(msg_name) != dv_support_apis_.end()) {\n    string json_res;\n    bool result = (this->*dv_support_apis_[msg_name])(msg, json_res);\n    if (!result) {\n      AERROR << \"Failed to handle msg!\";\n      return false;\n    }\n  }\n  Json response = JsonUtil::ProtoToTypedJson(\"PluginMsg\", msg);\n  plugin_ws_->BroadcastData(response.dump());\n  return true;\n}\n\nbool PluginManager::UpdateData(const DvPluginMsg& msg, const string& json_str) {\n  if (!msg.has_info()) {\n    AERROR << \"Failed to get data type!\";\n    return false;\n  }\n  const string info_str = msg.info();\n  Json info;\n  info = Json::parse(info_str);\n  if (!info.contains(\"data_type\")) {\n    AERROR << \"Failed to get data type!\";\n    return false;\n  }\n  const string data_type = info[\"data_type\"];\n  if (data_type_dict.find(data_type) == data_type_dict.end()) {\n    AERROR << \"Dv don't support this kind of data type!\";\n    return false;\n  }\n  const int data_type_index = data_type_dict[data_type];\n  bool update_data_res = false;\n  switch (data_type_index) {\n    case 0: {\n      update_data_res = callback_api_(\"UpdateScenarioSetToStatus\", info);\n      break;\n    }\n    case 2: {\n      // \u4e0b\u8f7d\u6210\u529f-\u65b0\u589e\u6587\u4ef6+register+\u672c\u5730hmistatus\n      // \u5220\u9664-\u5220\u9664\u6587\u4ef6+unregister+\u672c\u5730Hmistatus\n      update_data_res = callback_api_(\"UpdateDynamicModelToStatus\", info);\n      break;\n    }\n    case 3: {\n      update_data_res = callback_api_(\"UpdateRecordToStatus\", info);\n      break;\n    }\n    case 4: {\n      update_data_res = callback_api_(\"UpdateVehicleToStatus\", info);\n    }\n    default:\n      break;\n  }\n  if (!update_data_res) {\n    AERROR << \"Failed to update data!\";\n    return false;\n  }\n  return true;\n}\n\n}  // namespace dreamview\n}  // namespace apollo",
        "b_contents": "/******************************************************************************\n * Copyright 2019 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *****************************************************************************/\n#include \"modules/dreamview/backend/plugins/plugin_manager.h\"\n\n#include <dirent.h>\n\n#include <limits>\n#include <string>\n\n#include \"google/protobuf/util/json_util.h\"\n\n#include \"cyber/common/file.h\"\n#include \"modules/common/util/json_util.h\"\n#include \"modules/common/util/message_util.h\"\n#include \"modules/dreamview/backend/common/dreamview_gflags.h\"\n\nusing apollo::common::util::FillHeader;\nusing apollo::common::util::JsonUtil;\nusing google::protobuf::util::JsonStringToMessage;\nusing Json = nlohmann::json;\nusing std::string;\n\n// scenario_set: update one scenario set from studio to local\n// scenarios: update all scenarios\nnamespace {\nstd::map<string, int> data_type_dict = {{\n                                            \"scenario_set\",\n                                            0,\n                                        },\n                                        {\n                                            \"scenarios\",\n                                            1,\n                                        },\n                                        {\n                                            \"dynamic_model\",\n                                            2,\n                                        },\n                                        {\n                                          \"records\",\n                                          3,\n\n                                        }};\n}\nnamespace apollo {\nnamespace dreamview {\nPluginManager::PluginManager(WebSocketHandler* plugin_ws)\n    : node_(cyber::CreateNode(\"PluginManager\")),\n      enabled_(false),\n      plugin_ws_(plugin_ws) {\n  RegisterDvSupportApis();\n  RegisterPlugins();\n}\n\nvoid PluginManager::Start(DvCallback callback_api) {\n  callback_api_ = callback_api;\n  enabled_ = true;\n  return;\n}\n\nvoid PluginManager::Stop() {\n  if (enabled_) {\n    std::string stop_command;\n    for (auto iter = plugins_.begin(); iter != plugins_.end(); iter++) {\n      stop_command = iter->second.stop_command;\n      const int ret = std::system(stop_command.data());\n      if (ret != 0) {\n        AERROR << \"Failed to stop plugin! ret: \" << ret;\n      }\n    }\n    plugins_.clear();\n    // need kill all plugin process\n  }\n  enabled_ = false;\n}\n\nauto PluginManager::InitPluginReader(ChannelConf& channel_conf,\n                                     const string& channel_prefix,\n                                     const string& plugin_name)\n    -> std::shared_ptr<cyber::Reader<DvPluginMsg>> {\n  if (!channel_conf.has_location()) {\n    AERROR << \"Failed to init reader for plugins for missing required file \"\n              \"location\";\n    return nullptr;\n  }\n  const string channel_location = channel_conf.location();\n  // Plugin related channel name should follow the plugin specification\n  if (channel_location.find(channel_prefix) != 0) {\n    AERROR << \"Plugin related channel should observe channel name conventions!\";\n    return nullptr;\n  }\n  if (plugins_[plugin_name].readers.find(channel_location) !=\n      plugins_[plugin_name].readers.end()) {\n    AERROR << \"Plugin has already register this channel: \" << channel_location;\n    return nullptr;\n  }\n  cyber::ReaderConfig reader_config;\n  reader_config.channel_name = channel_location;\n  reader_config.pending_queue_size = channel_conf.pending_queue_size();\n  auto reader = node_->CreateReader<DvPluginMsg>(\n      reader_config, [this](const std::shared_ptr<DvPluginMsg>& msg) {\n        if (!ReceiveMsgFromPlugin(*msg)) {\n          AERROR << \"Failed to handle received msg from plugin\";\n        }\n        return;\n      });\n  return reader;\n};\n\nauto PluginManager::InitPluginWriterAndMsg(ChannelConf& channel_conf,\n                                           const string& channel_prefix,\n                                           const string& plugin_name)\n    -> std::shared_ptr<cyber::Writer<DvPluginMsg>> {\n  if (!channel_conf.has_location()) {\n    AERROR << \"Failed to init writer for plugins for missing required file \"\n              \"location\";\n    return nullptr;\n  }\n  const string channel_location = channel_conf.location();\n  // Plugin related channel name should follow the plugin specification\n  if (channel_location.find(channel_prefix) != 0) {\n    AERROR << \"Plugin related channel should observe channel name conventions!\";\n    return nullptr;\n  }\n  if (plugins_[plugin_name].writers.find(channel_location) !=\n      plugins_[plugin_name].writers.end()) {\n    AERROR << \"Plugin has already register this channel!\";\n    return nullptr;\n  }\n  auto writer = node_->CreateWriter<DvPluginMsg>(channel_location);\n  if (!writer) {\n    AERROR << \"Failed to create writer!\";\n    return nullptr;\n  }\n  plugins_[plugin_name].writers[channel_location] = writer;\n  if (channel_conf.support_msg_name_size()) {\n    for (auto& support_msg : channel_conf.support_msg_name()) {\n      if (plugins_[plugin_name].plugin_accept_msg.find(support_msg) !=\n          plugins_[plugin_name].plugin_accept_msg.end()) {\n        AERROR << \"One-to-one message and channel, no repetition is allowed\";\n        return nullptr;\n      }\n      plugins_[plugin_name].plugin_accept_msg[support_msg] = channel_location;\n    }\n  }\n  return writer;\n};\n\nbool PluginManager::RegisterPlugin(\n    const std::shared_ptr<PluginConfig>& plugin_config) {\n  if (!plugin_config->has_name() || !plugin_config->has_launch_command() ||\n      !plugin_config->process_command_keywords_size() ||\n      !plugin_config->has_stop_command()) {\n    AERROR << \"Failed to register plugin for required fields missing!\";\n    return false;\n  }\n  string plugin_name = plugin_config->name();\n  string launch_command = plugin_config->launch_command();\n  if (plugins_.find(plugin_name) != plugins_.end()) {\n    AERROR << \"This plugin has already registered! Don't install the plugin \"\n              \"again!\";\n    return false;\n  }\n  struct PluginInfo plugin_info;\n  plugins_[plugin_name] = {};\n  plugins_[plugin_name].launch_command = launch_command;\n  plugins_[plugin_name].stop_command = plugin_config->stop_command();\n  string channel_prefix = FLAGS_plugin_channel_prefix + plugin_name + \"/\";\n  for (auto reader_channel_conf : plugin_config->reader_channel_conf()) {\n    auto plugin_reader =\n        InitPluginReader(reader_channel_conf, channel_prefix, plugin_name);\n    if (plugin_reader == nullptr) {\n      AERROR << \"Failed to register plugin reader!\";\n      plugins_.erase(plugin_name);\n      return false;\n    }\n  }\n  for (auto writer_channel_conf : plugin_config->writer_channel_conf()) {\n    auto plugin_writer = InitPluginWriterAndMsg(writer_channel_conf,\n                                                channel_prefix, plugin_name);\n    if (plugin_writer == nullptr) {\n      AERROR << \"Failed to register plugin writer!\";\n      plugins_.erase(plugin_name);\n      return false;\n    }\n  }\n  const int ret = std::system((\"nohup \" + launch_command + \" &\").data());\n  if (ret == 0) {\n    AINFO << \"SUCCESS to launch plugin: \" << plugin_name;\n  } else {\n    AERROR << \"Failed to launch plugin: \" << plugin_name << \" ret: \" << ret;\n    plugins_.erase(plugin_name);\n    return false;\n  }\n  for (auto command_keyword : plugin_config->process_command_keywords()) {\n    plugins_[plugin_name].process_command_keywords.push_back(command_keyword);\n  }\n  return true;\n}\n\nbool PluginManager::RegisterPlugins() {\n  const std::string plugin_path =\n      (cyber::common::GetEnv(\"HOME\")) + FLAGS_plugin_path;\n  DIR* directory = opendir(plugin_path.c_str());\n  if (directory == nullptr) {\n    AERROR << \"Cannot open directory \" << FLAGS_plugin_path;\n    return false;\n  }\n  struct dirent* entry;\n  bool register_res = true;\n  while ((entry = readdir(directory)) != nullptr && register_res) {\n    // skip directory_path/. and directory_path/..\n    if (!strcmp(entry->d_name, \".\") || !strcmp(entry->d_name, \"..\")) {\n      continue;\n    }\n    if (entry->d_type != DT_DIR) {\n      // skip not directory\n      continue;\n    }\n    const string plugin_config_file_name =\n        entry->d_name + FLAGS_plugin_config_file_name_suffix;\n    const string plugin_config_file_path =\n        (cyber::common::GetEnv(\"HOME\")) + FLAGS_plugin_path + \"/\" +\n        entry->d_name + \"/\" + plugin_config_file_name;\n    if (!cyber::common::PathExists(plugin_config_file_path)) {\n      AERROR << \"Cannot find plugin:\" << entry->d_name\n             << \" plugin config file, jump it!\";\n      continue;\n    }\n    auto plugin_config = std::make_shared<PluginConfig>();\n    if (!cyber::common::GetProtoFromFile(plugin_config_file_path,\n                                         plugin_config.get())) {\n      AWARN << \"Unable to read plugin config from file: \"\n            << plugin_config_file_path;\n      return false;\n    }\n    register_res = RegisterPlugin(plugin_config);\n  }\n  return register_res;\n}\n\nbool PluginManager::CheckPluginStatus(const string& plugin_name) {\n  if (plugins_.find(plugin_name) == plugins_.end()) {\n    AERROR << \"Failed to register this plugin, cann't check!\";\n    return false;\n  }\n  // todo: Extract the logic for monitoring plugin status\n  std::vector<string> running_processes;\n  for (const auto& cmd_file : cyber::common::Glob(\"/proc/*/cmdline\")) {\n    // Get process command string.\n    string cmd_string;\n    if (cyber::common::GetContent(cmd_file, &cmd_string) &&\n        !cmd_string.empty()) {\n      // In /proc/<PID>/cmdline, the parts are separated with \\0, which will be\n      // converted back to whitespaces here.\n      std::replace(cmd_string.begin(), cmd_string.end(), '\\0', ' ');\n      running_processes.push_back(cmd_string);\n    }\n  }\n  bool command_found = false;\n  for (const string& command : running_processes) {\n    bool all_keywords_matched = true;\n    for (const string& keyword :\n         plugins_[plugin_name].process_command_keywords) {\n      all_keywords_matched &= (command.find(keyword) != string::npos);\n      if (!all_keywords_matched) {\n        break;\n      }\n    }\n    command_found |= all_keywords_matched;\n  }\n  if (!command_found) {\n    AERROR << \"Failed to pass plugin status check!\";\n    return false;\n  }\n  // Process command keywords are all matched. The process is running.\n  return true;\n}\n\nbool PluginManager::SendMsgToPlugin(const string& json_str) {\n  AERROR << \"send message to plugin start\";\n  auto plugin_msg = std::make_shared<DvPluginMsg>();\n  if (!JsonStringToMessage(json_str, plugin_msg.get()).ok()) {\n    AERROR << \"Failed to parse DvPluginMsg from json!\";\n    return false;\n  }\n  if (!plugin_msg->has_target() || !plugin_msg->has_name()) {\n    AERROR << \"Missing required field for DvPluginMsg.\";\n    return false;\n  }\n  const string plugin_name = plugin_msg->target();\n  if (!CheckPluginStatus(plugin_name)) {\n    return false;\n  }\n  const string msg_name = plugin_msg->name();\n  if (plugins_[plugin_name].plugin_accept_msg.find(msg_name) ==\n      plugins_[plugin_name].plugin_accept_msg.end()) {\n    AERROR << \"Plugin not accept this msg!\";\n    return false;\n  }\n  const string channel_location =\n      plugins_[plugin_name].plugin_accept_msg[msg_name];\n  if (plugins_[plugin_name].writers.find(channel_location) ==\n      plugins_[plugin_name].writers.end()) {\n    AERROR << \"The plugin does not support communication on this channel\";\n    return false;\n  }\n  FillHeader(\"PluginManager\", plugin_msg.get());\n  plugins_[plugin_name].writers[channel_location]->Write(plugin_msg);\n  return true;\n}\n\nvoid PluginManager::RegisterDvSupportApi(const string& api_name,\n                                         const DvApi& api) {\n  dv_support_apis_[api_name] = api;\n}\n\nvoid PluginManager::RegisterDvSupportApis() {\n  RegisterDvSupportApi(\"UpdateScenarioSetList\", &PluginManager::UpdateData);\n  RegisterDvSupportApi(\"UpdateDynamicModelList\", &PluginManager::UpdateData);\n  RegisterDvSupportApi(\"UpdateRecordList\", &PluginManager::UpdateData);\n // RegisterDvSupportApi(\"DownloadRecordSuccess\", &PluginManager::UpdateData);\n}\n\nbool PluginManager::ReceiveMsgFromPlugin(const DvPluginMsg& msg) {\n  if (!msg.has_name()) {\n    return false;\n  }\n  const string msg_name = msg.name();\n  if (dv_support_apis_.find(msg_name) != dv_support_apis_.end()) {\n    string json_res;\n    bool result = (this->*dv_support_apis_[msg_name])(msg, json_res);\n    if (!result) {\n      AERROR << \"Failed to handle msg!\";\n      return false;\n    }\n  }\n  Json response = JsonUtil::ProtoToTypedJson(\"PluginMsg\", msg);\n  plugin_ws_->BroadcastData(response.dump());\n  return true;\n}\n\nbool PluginManager::UpdateData(const DvPluginMsg& msg, string& json_str) {\n  if (!msg.has_info()) {\n    AERROR << \"Failed to get data type!\";\n    return false;\n  }\n  const string info_str = msg.info();\n  Json info;\n  info = Json::parse(info_str);\n  if (!info.contains(\"data_type\")) {\n    AERROR << \"Failed to get data type!\";\n    return false;\n  }\n  const string data_type = info[\"data_type\"];\n  if (data_type_dict.find(data_type) == data_type_dict.end()) {\n    AERROR << \"Dv don't support this kind of data type!\";\n    return false;\n  }\n  const int data_type_index = data_type_dict[data_type];\n  bool update_data_res = false;\n  switch (data_type_index) {\n    case 0: {\n      update_data_res = callback_api_(\"UpdateScenarioSetToStatus\", info);\n      break;\n    }\n    case 2:{\n      // \u4e0b\u8f7d\u6210\u529f-\u65b0\u589e\u6587\u4ef6+register+\u672c\u5730hmistatus\n      // \u5220\u9664-\u5220\u9664\u6587\u4ef6+unregister+\u672c\u5730Hmistatus\n      update_data_res = callback_api_(\"UpdateDynamicModelToStatus\", info);\n      break;\n    }\n    // case 3:{\n    //   update_data_res = callback_api_(\"UpdateRecordToStatus\", info);\n    //   break;\n    // }\n    default:\n      break;\n  }\n  if (!update_data_res) {\n    AERROR << \"Failed to update data!\";\n    return false;\n  }\n  return true;\n}\n\n}  // namespace dreamview\n}  // namespace apollo",
        "base_contents": "",
        "res_region": "/******************************************************************************\n * Copyright 2019 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *****************************************************************************/\n#include \"modules/dreamview/backend/plugins/plugin_manager.h\"\n\n#include <dirent.h>\n\n#include <limits>\n#include <string>\n\n#include \"google/protobuf/util/json_util.h\"\n\n#include \"cyber/common/file.h\"\n#include \"modules/common/util/json_util.h\"\n#include \"modules/common/util/message_util.h\"\n#include \"modules/dreamview/backend/common/dreamview_gflags.h\"\n\nusing apollo::common::util::FillHeader;\nusing apollo::common::util::JsonUtil;\nusing google::protobuf::util::JsonStringToMessage;\nusing Json = nlohmann::json;\nusing std::string;\n\n// scenario_set: update one scenario set from studio to local\n// scenarios: update all scenarios\nnamespace {\nstd::map<string, int> data_type_dict = {{\n                                            \"scenario_set\", 0,\n                                        },\n                                        {\n                                            \"scenarios\", 1,\n                                        },\n                                        {\n                                            \"dynamic_model\", 2,\n                                        },\n                                        {\n                                            \"records\", 3,\n                                        },\n                                        {\n                                            \"vehicles\", 4,\n                                        }};\n}  // namespace\nnamespace apollo {     // namespace apollo\nnamespace dreamview {  // namespace dreamview\nPluginManager::PluginManager(WebSocketHandler* plugin_ws)\n    : node_(cyber::CreateNode(\"PluginManager\")),\n      enabled_(false),\n      plugin_ws_(plugin_ws) {\n  RegisterDvSupportApis();\n  RegisterPlugins();\n}\n\nvoid PluginManager::Start(DvCallback callback_api) {\n  callback_api_ = callback_api;\n  enabled_ = true;\n  return;\n}\n\nvoid PluginManager::Stop() {\n  if (enabled_) {\n    std::string stop_command;\n    for (auto iter = plugins_.begin(); iter != plugins_.end(); iter++) {\n      stop_command = iter->second.stop_command;\n      const int ret = std::system(stop_command.data());\n      if (ret != 0) {\n        AERROR << \"Failed to stop plugin! ret: \" << ret;\n      }\n    }\n    plugins_.clear();\n    // need kill all plugin process\n  }\n  enabled_ = false;\n}\n\nauto PluginManager::InitPluginReader(const ChannelConf& channel_conf,\n                                     const string& channel_prefix,\n                                     const string& plugin_name)\n    -> std::shared_ptr<cyber::Reader<DvPluginMsg>> {\n  if (!channel_conf.has_location()) {\n    AERROR << \"Failed to init reader for plugins for missing required file \"\n              \"location\";\n    return nullptr;\n  }\n  const string channel_location = channel_conf.location();\n  // Plugin related channel name should follow the plugin specification\n  if (channel_location.find(channel_prefix) != 0) {\n    AERROR << \"Plugin related channel should observe channel name conventions!\";\n    return nullptr;\n  }\n  if (plugins_[plugin_name].readers.find(channel_location) !=\n      plugins_[plugin_name].readers.end()) {\n    AERROR << \"Plugin has already register this channel: \" << channel_location;\n    return nullptr;\n  }\n  cyber::ReaderConfig reader_config;\n  reader_config.channel_name = channel_location;\n  reader_config.pending_queue_size = channel_conf.pending_queue_size();\n  auto reader = node_->CreateReader<DvPluginMsg>(\n      reader_config, [this](const std::shared_ptr<DvPluginMsg>& msg) {\n        if (!ReceiveMsgFromPlugin(*msg)) {\n          AERROR << \"Failed to handle received msg from plugin\";\n        }\n        return;\n      });\n  return reader;\n};\n\nauto PluginManager::InitPluginWriterAndMsg(const ChannelConf& channel_conf,\n                                           const string& channel_prefix,\n                                           const string& plugin_name)\n    -> std::shared_ptr<cyber::Writer<DvPluginMsg>> {\n  if (!channel_conf.has_location()) {\n    AERROR << \"Failed to init writer for plugins for missing required file \"\n              \"location\";\n    return nullptr;\n  }\n  const string channel_location = channel_conf.location();\n  // Plugin related channel name should follow the plugin specification\n  if (channel_location.find(channel_prefix) != 0) {\n    AERROR << \"Plugin related channel should observe channel name conventions!\";\n    return nullptr;\n  }\n  if (plugins_[plugin_name].writers.find(channel_location) !=\n      plugins_[plugin_name].writers.end()) {\n    AERROR << \"Plugin has already register this channel!\";\n    return nullptr;\n  }\n  auto writer = node_->CreateWriter<DvPluginMsg>(channel_location);\n  if (!writer) {\n    AERROR << \"Failed to create writer!\";\n    return nullptr;\n  }\n  plugins_[plugin_name].writers[channel_location] = writer;\n  if (channel_conf.support_msg_name_size()) {\n    for (auto& support_msg : channel_conf.support_msg_name()) {\n      if (plugins_[plugin_name].plugin_accept_msg.find(support_msg) !=\n          plugins_[plugin_name].plugin_accept_msg.end()) {\n        AERROR << \"One-to-one message and channel, no repetition is allowed\";\n        return nullptr;\n      }\n      plugins_[plugin_name].plugin_accept_msg[support_msg] = channel_location;\n    }\n  }\n  return writer;\n};\n\nbool PluginManager::RegisterPlugin(\n    const std::shared_ptr<PluginConfig>& plugin_config) {\n  if (!plugin_config->has_name() || !plugin_config->has_launch_command() ||\n      !plugin_config->process_command_keywords_size() ||\n      !plugin_config->has_stop_command()) {\n    AERROR << \"Failed to register plugin for required fields missing!\";\n    return false;\n  }\n  string plugin_name = plugin_config->name();\n  string launch_command = plugin_config->launch_command();\n  if (plugins_.find(plugin_name) != plugins_.end()) {\n    AERROR << \"This plugin has already registered! Don't install the plugin \"\n              \"again!\";\n    return false;\n  }\n  struct PluginInfo plugin_info;\n  plugins_[plugin_name] = {};\n  plugins_[plugin_name].launch_command = launch_command;\n  plugins_[plugin_name].stop_command = plugin_config->stop_command();\n  string channel_prefix = FLAGS_plugin_channel_prefix + plugin_name + \"/\";\n  for (auto reader_channel_conf : plugin_config->reader_channel_conf()) {\n    auto plugin_reader =\n        InitPluginReader(reader_channel_conf, channel_prefix, plugin_name);\n    if (plugin_reader == nullptr) {\n      AERROR << \"Failed to register plugin reader!\";\n      plugins_.erase(plugin_name);\n      return false;\n    }\n  }\n  for (auto writer_channel_conf : plugin_config->writer_channel_conf()) {\n    auto plugin_writer = InitPluginWriterAndMsg(writer_channel_conf,\n                                                channel_prefix, plugin_name);\n    if (plugin_writer == nullptr) {\n      AERROR << \"Failed to register plugin writer!\";\n      plugins_.erase(plugin_name);\n      return false;\n    }\n  }\n  const int ret = std::system((\"nohup \" + launch_command + \" &\").data());\n  if (ret == 0) {\n    AINFO << \"SUCCESS to launch plugin: \" << plugin_name;\n  } else {\n    AERROR << \"Failed to launch plugin: \" << plugin_name << \" ret: \" << ret;\n    plugins_.erase(plugin_name);\n    return false;\n  }\n  for (auto command_keyword : plugin_config->process_command_keywords()) {\n    plugins_[plugin_name].process_command_keywords.push_back(command_keyword);\n  }\n  return true;\n}\n\nbool PluginManager::RegisterPlugins() {\n  const std::string plugin_path =\n      (cyber::common::GetEnv(\"HOME\")) + FLAGS_plugin_path;\n  DIR* directory = opendir(plugin_path.c_str());\n  if (directory == nullptr) {\n    AERROR << \"Cannot open directory \" << FLAGS_plugin_path;\n    return false;\n  }\n  struct dirent* entry;\n  bool register_res = true;\n  while ((entry = readdir(directory)) != nullptr && register_res) {\n    // skip directory_path/. and directory_path/..\n    if (!strcmp(entry->d_name, \".\") || !strcmp(entry->d_name, \"..\")) {\n      continue;\n    }\n    if (entry->d_type != DT_DIR) {\n      // skip not directory\n      continue;\n    }\n    const string plugin_config_file_name =\n        entry->d_name + FLAGS_plugin_config_file_name_suffix;\n    const string plugin_config_file_path =\n        (cyber::common::GetEnv(\"HOME\")) + FLAGS_plugin_path + \"/\" +\n        entry->d_name + \"/\" + plugin_config_file_name;\n    if (!cyber::common::PathExists(plugin_config_file_path)) {\n      AERROR << \"Cannot find plugin:\" << entry->d_name\n             << \" plugin config file, jump it!\";\n      continue;\n    }\n    auto plugin_config = std::make_shared<PluginConfig>();\n    if (!cyber::common::GetProtoFromFile(plugin_config_file_path,\n                                         plugin_config.get())) {\n      AWARN << \"Unable to read plugin config from file: \"\n            << plugin_config_file_path;\n      return false;\n    }\n    register_res = RegisterPlugin(plugin_config);\n  }\n  return register_res;\n}\n\nbool PluginManager::CheckPluginStatus(const string& plugin_name) {\n  if (plugins_.find(plugin_name) == plugins_.end()) {\n    AERROR << \"Failed to register this plugin, cann't check!\";\n    return false;\n  }\n  // todo: Extract the logic for monitoring plugin status\n  std::vector<string> running_processes;\n  for (const auto& cmd_file : cyber::common::Glob(\"/proc/*/cmdline\")) {\n    // Get process command string.\n    string cmd_string;\n    if (cyber::common::GetContent(cmd_file, &cmd_string) &&\n        !cmd_string.empty()) {\n      // In /proc/<PID>/cmdline, the parts are separated with \\0, which will be\n      // converted back to whitespaces here.\n      std::replace(cmd_string.begin(), cmd_string.end(), '\\0', ' ');\n      running_processes.push_back(cmd_string);\n    }\n  }\n  bool command_found = false;\n  for (const string& command : running_processes) {\n    bool all_keywords_matched = true;\n    for (const string& keyword :\n         plugins_[plugin_name].process_command_keywords) {\n      all_keywords_matched &= (command.find(keyword) != string::npos);\n      if (!all_keywords_matched) {\n        break;\n      }\n    }\n    command_found |= all_keywords_matched;\n  }\n  if (!command_found) {\n    AERROR << \"Failed to pass plugin status check!\";\n    return false;\n  }\n  // Process command keywords are all matched. The process is running.\n  return true;\n}\n\nbool PluginManager::SendMsgToPlugin(const string& json_str) {\n  auto plugin_msg = std::make_shared<DvPluginMsg>();\n  if (!JsonStringToMessage(json_str, plugin_msg.get()).ok()) {\n    AERROR << \"Failed to parse DvPluginMsg from json!\";\n    return false;\n  }\n  if (!plugin_msg->has_target() || !plugin_msg->has_name()) {\n    AERROR << \"Missing required field for DvPluginMsg.\";\n    return false;\n  }\n  const string plugin_name = plugin_msg->target();\n  if (!CheckPluginStatus(plugin_name)) {\n    return false;\n  }\n  const string msg_name = plugin_msg->name();\n\n  if (plugins_[plugin_name].plugin_accept_msg.find(msg_name) ==\n      plugins_[plugin_name].plugin_accept_msg.end()) {\n    AERROR << \"Plugin not accept this msg!\";\n    return false;\n  }\n  const string channel_location =\n      plugins_[plugin_name].plugin_accept_msg[msg_name];\n  if (plugins_[plugin_name].writers.find(channel_location) ==\n      plugins_[plugin_name].writers.end()) {\n    AERROR << \"The plugin does not support communication on this channel\";\n    return false;\n  }\n  FillHeader(\"PluginManager\", plugin_msg.get());\n  plugins_[plugin_name].writers[channel_location]->Write(plugin_msg);\n  return true;\n}\n\nvoid PluginManager::RegisterDvSupportApi(const string& api_name,\n                                         const DvApi& api) {\n  dv_support_apis_[api_name] = api;\n}\n\nvoid PluginManager::RegisterDvSupportApis() {\n  RegisterDvSupportApi(\"UpdateScenarioSetList\", &PluginManager::UpdateData);\n  RegisterDvSupportApi(\"UpdateDynamicModelList\", &PluginManager::UpdateData);\n  RegisterDvSupportApi(\"UpdateRecordToStatus\", &PluginManager::UpdateData);\n  RegisterDvSupportApi(\"ResetVehicleConfigSuccess\", &PluginManager::UpdateData);\n  RegisterDvSupportApi(\n    \"RefreshVehicleConfigSuccess\", &PluginManager::UpdateData);\n}\n\nbool PluginManager::ReceiveMsgFromPlugin(const DvPluginMsg& msg) {\n  if (!msg.has_name()) {\n    return false;\n  }\n  const string msg_name = msg.name();\n  if (dv_support_apis_.find(msg_name) != dv_support_apis_.end()) {\n    string json_res;\n    bool result = (this->*dv_support_apis_[msg_name])(msg, json_res);\n    if (!result) {\n      AERROR << \"Failed to handle msg!\";\n      return false;\n    }\n  }\n  Json response = JsonUtil::ProtoToTypedJson(\"PluginMsg\", msg);\n  plugin_ws_->BroadcastData(response.dump());\n  return true;\n}\n\nbool PluginManager::UpdateData(const DvPluginMsg& msg, const string& json_str) {\n  if (!msg.has_info()) {\n    AERROR << \"Failed to get data type!\";\n    return false;\n  }\n  const string info_str = msg.info();\n  Json info;\n  info = Json::parse(info_str);\n  if (!info.contains(\"data_type\")) {\n    AERROR << \"Failed to get data type!\";\n    return false;\n  }\n  const string data_type = info[\"data_type\"];\n  if (data_type_dict.find(data_type) == data_type_dict.end()) {\n    AERROR << \"Dv don't support this kind of data type!\";\n    return false;\n  }\n  const int data_type_index = data_type_dict[data_type];\n  bool update_data_res = false;\n  switch (data_type_index) {\n    case 0: {\n      update_data_res = callback_api_(\"UpdateScenarioSetToStatus\", info);\n      break;\n    }\n    case 2: {\n      // \u4e0b\u8f7d\u6210\u529f-\u65b0\u589e\u6587\u4ef6+register+\u672c\u5730hmistatus\n      // \u5220\u9664-\u5220\u9664\u6587\u4ef6+unregister+\u672c\u5730Hmistatus\n      update_data_res = callback_api_(\"UpdateDynamicModelToStatus\", info);\n      break;\n    }\n    case 3: {\n      update_data_res = callback_api_(\"UpdateRecordToStatus\", info);\n      break;\n    }\n    case 4: {\n      update_data_res = callback_api_(\"UpdateVehicleToStatus\", info);\n    }\n    default:\n      break;\n  }\n  if (!update_data_res) {\n    AERROR << \"Failed to update data!\";\n    return false;\n  }\n  return true;\n}\n\n}  // namespace dreamview\n}  // namespace apollo",
        "lookback": " * Copyright 2019 The Apollo Authors. All Rights Reserved.",
        "lookahead": "",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 0,
        "end_line": 806,
        "merge_gen_region": " Copyright Thepol Authors All Reserved/****************************************************************************** Copyright Thepol Authors All Reserved * Licensed the Apache, 20theLicense *\"); you not this except in with the. * may a of License * may a of License * *://..///LICENSE20 * Unless by applicable or to writing software distributed the is on \" IS BASIS * WARRANTIES CONDITIONS ANY, express implied * the License the for specific governing and limitations the License *****************************************************************************/includemodulesdrviewbackendpluginspluginmanagerh # <direnth # <>includelimits # <>includestring # \"/////_utilh # \"bercommonfileh # \"////__.\"includemodulescommonutiljsonutilh # \"modulescommonutilmessageutilh # \"modulesdrviewbackendcommondrviewg.\" alocommoncommonutilFill; alocommoncommonutilJson; googleprotobufutilJsonStringTo; Json nh::; scenarioset update scenario fromudio to //enos update scarios { stdmapstring int datatypedict {{scenarioset 0 }, \"enari\",, {dynamicmodel 2 }, \"\",, {vehicle\",,}; // namespace alo { namespacepol { namespaceeam { namespaceeam Plugin::ManagerPlugin(Handler pluginws :",
        "confidence": 0.9474325776100159,
        "hesitated": false,
        "resolved": false
    }
]