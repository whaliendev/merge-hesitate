[
    {
        "a_contents": "void HMIWorker::ChangeScenarioSet(const std::string &scenario_set_id) {\n  {\n    RLock rlock(status_mutex_);\n    auto &scenario_set = status_.scenario_set();\n    if ((!scenario_set_id.empty()) &&\n        (scenario_set.find(scenario_set_id) == scenario_set.end())) {\n      AERROR << \"Cannot change to unknown scenario set!\";\n      return;\n    }\n    if (status_.current_scenario_set_id() == scenario_set_id) {\n      return;\n    }\n  }\n\n  {\n    WLock wlock(status_mutex_);\n    status_.set_current_scenario_set_id(scenario_set_id);\n    status_changed_ = true;\n  }\n  return;\n}\n\nvoid HMIWorker::GetScenarioResourcePath(std::string *scenario_resource_path) {\n  CHECK_NOTNULL(scenario_resource_path);\n  const std::string home = cyber::common::GetEnv(\"HOME\");\n  *scenario_resource_path = home + FLAGS_resource_scenario_path;\n}\n\nvoid HMIWorker::GetScenarioSetPath(const std::string &scenario_set_id,\n                                   std::string *scenario_set_path) {\n  CHECK_NOTNULL(scenario_set_path);\n  GetScenarioResourcePath(scenario_set_path);\n  *scenario_set_path = *scenario_set_path + scenario_set_id;\n  return;\n}\n\nbool HMIWorker::StopModuleByCommand(const std::string &stop_command) const {\n  int ret = std::system(stop_command.data());\n  if (ret < 0 || !WIFEXITED(ret)) {\n    // 256 does not means failure\n    AERROR << \"Failed to stop sim obstacle\";\n    return false;\n  }\n  return true;\n}\n\nbool HMIWorker::ResetSimObstacle(const std::string &scenario_id) {\n  // Todo: Check sim obstacle status before closing it\n  const std::string absolute_path =\n      cyber::common::GetEnv(\"HOME\") + FLAGS_sim_obstacle_path;\n  if (!cyber::common::PathExists(absolute_path)) {\n    AERROR << \"Failed to find sim obstacle\";\n    return false;\n  }\n  StopModuleByCommand(FLAGS_sim_obstacle_stop_command);\n  std::string scenario_set_id;\n  {\n    RLock rlock(status_mutex_);\n    scenario_set_id = status_.current_scenario_set_id();\n  }\n  std::string scenario_set_path;\n  GetScenarioSetPath(scenario_set_id, &scenario_set_path);\n  const std::string scenario_path =\n      scenario_set_path + \"/scenarios/\" + scenario_id + \".json\";\n  if (!cyber::common::PathExists(scenario_path)) {\n    AERROR << \"Failed to find scenario!\";\n    return false;\n  }\n  std::string map_name = \"\";\n  double x;\n  double y;\n  bool need_to_change_map = true;\n  {\n    RLock rlock(status_mutex_);\n    auto &scenario_set = status_.scenario_set();\n    if (scenario_set.find(scenario_set_id) == scenario_set.end()) {\n      AERROR << \"Failed to find scenario set!\";\n      return false;\n    }\n    for (auto &scenario : scenario_set.at(scenario_set_id).scenarios()) {\n      if (scenario.scenario_id() == scenario_id) {\n        map_name = scenario.map_name();\n        x = scenario.start_point().x();\n        y = scenario.start_point().y();\n        break;\n      }\n    }\n    if (map_name.empty()) {\n      AERROR << \"Failed to find scenario and get map dir!\";\n      return false;\n    }\n    need_to_change_map = (status_.current_map() != map_name);\n  }\n  if (need_to_change_map) {\n    if (!ChangeMap(map_name)) {\n      AERROR << \"Failed to change map!\";\n      return false;\n    }\n    callback_api_(\"MapServiceReloadMap\", {});\n  } else {\n    // Change scenario under the same map requires reset mode\n    ResetMode();\n  }\n  // After changing the map, reset the start point from the scenario by\n  // sim_control\n  Json info;\n  info[\"x\"] = x;\n  info[\"y\"] = y;\n  callback_api_(\"SimControlRestart\", info);\n  // \u542f\u52a8sim obstacle\n  const std::string start_command = \"nohup \" + absolute_path + \" \" +\n                                    scenario_path + FLAGS_gflag_command_arg +\n                                    \" &\";\n  int ret = std::system(start_command.data());\n  if (ret != 0) {\n    AERROR << \"Failed to start sim obstacle\";\n    return false;\n  }\n  return true;\n}\n\nvoid HMIWorker::ChangeScenario(const std::string &scenario_id) {\n  {\n    RLock rlock(status_mutex_);\n    // Skip if mode doesn't actually change.\n    if (status_.current_scenario_id() == scenario_id) {\n      return;\n    }\n    if (scenario_id.empty()) {\n      // stop sim obstacle\n      // todo\uff1a add check status\n      // directly think pkill successful\n      StopModuleByCommand(FLAGS_sim_obstacle_stop_command);\n    } else {\n      auto scenario_set = status_.mutable_scenario_set();\n      auto &scenario_set_id = status_.current_scenario_set_id();\n      if (scenario_set->find(scenario_set_id) == scenario_set->end()) {\n        AERROR << \"Current scenario set is invalid!\";\n        return;\n      }\n      bool find_res = false;\n      for (auto &scenario : (*scenario_set)[scenario_set_id].scenarios()) {\n        if (scenario.scenario_id() == scenario_id) {\n          find_res = true;\n          break;\n        }\n      }\n      if (!find_res) {\n        AERROR << \"Cannot change to unknown scenario!\";\n        return;\n      }\n    }\n  }\n\n  // restart sim obstacle\n  // move sim obstacle position for rlock wlock together will result to dead\n  // lock\n  if (!scenario_id.empty()) {\n    if (!ResetSimObstacle(scenario_id)) {\n      AERROR << \"Cannot start sim obstacle by new scenario!\";\n      return;\n    }\n  }\n  {\n    WLock wlock(status_mutex_);\n    status_.set_current_scenario_id(scenario_id);\n    status_changed_ = true;\n  }\n  return;\n}\n\nvoid HMIWorker::ChangeDynamicModel(const std::string &dynamic_model_name) {\n  // To avoid toggle sim control and always choose simulation perfect control\n  // {\n  //   RLock rlock(status_mutex_);\n  //   // Skip if mode doesn't actually change.\n  //   if (status_.current_dynamic_model() == dynamic_model_name) {\n  //     return;\n  //   }\n  // }\n  if (dynamic_model_name.empty()) {\n    AERROR << \"Failed to change empty dynamic model!\";\n    return;\n  }\n  Json param_json({});\n  param_json[\"dynamic_model_name\"] = dynamic_model_name;\n  Json callback_res = callback_api_(\"ChangeDynamicModel\", param_json);\n  if (!callback_res.contains(\"result\") || !callback_res[\"result\"]) {\n    // badcase1\uff1asim control is not enabled. badcase2\uff1amiss params\n    // badcase3\uff1achange dynamic model is not registered. resolution\uff1areturn with\n    // no action,keep sim control not enabled or use original dynamic model!\n    AERROR << \"Failed to change dynamic model! Please check if the param is \"\n              \"valid!\";\n    return;\n  }\n  std::string current_dynamic_model_name = dynamic_model_name;\n  {\n    WLock wlock(status_mutex_);\n    status_.set_current_dynamic_model(dynamic_model_name);\n    status_changed_ = true;\n  }\n\n  return;\n}\n\nbool HMIWorker::UpdateScenarioSetToStatus(\n    const std::string &scenario_set_id, const std::string &scenario_set_name) {\n  ScenarioSet new_scenario_set;\n  if (!UpdateScenarioSet(scenario_set_id, scenario_set_name,\n                         &new_scenario_set)) {\n    AERROR << \"Failed to update scenario_set!\";\n    return false;\n  }\n  {\n    WLock wlock(status_mutex_);\n    auto scenario_set = status_.mutable_scenario_set();\n    scenario_set->erase(scenario_set_id);\n    (*scenario_set)[scenario_set_id] = new_scenario_set;\n    status_changed_ = true;\n  }\n  return true;\n}\n\nbool HMIWorker::UpdateDynamicModelToStatus(\n    const std::string &dynamic_model_name) {\n  Json param_json({});\n  param_json[\"dynamic_model_name\"] = dynamic_model_name;\n  Json callback_res = callback_api_(\"AddDynamicModel\", param_json);\n  if (!callback_res.contains(\"result\") || !callback_res[\"result\"]) {\n    AERROR << \"Failed to add dynamic model to local dynamic model list for \"\n              \"register failed!\";\n    return false;\n  }\n  {\n    WLock wlock(status_mutex_);\n    for (const auto &iter : status_.dynamic_models()) {\n      if (iter == dynamic_model_name) {\n        AERROR << \"Do not need to add new dynamic model for is duplicate!\";\n        return true;\n      }\n    }\n    status_.add_dynamic_models(dynamic_model_name);\n    status_changed_ = true;\n  }\n  return true;\n}\n\nbool HMIWorker::UpdateScenarioSet(const std::string &scenario_set_id,\n                                  const std::string &scenario_set_name,\n                                  ScenarioSet *new_scenario_set) {\n  std::string scenario_set_directory_path;\n  GetScenarioSetPath(scenario_set_id, &scenario_set_directory_path);\n  scenario_set_directory_path = scenario_set_directory_path + \"/scenarios/\";\n  new_scenario_set->set_scenario_set_name(scenario_set_name);\n  if (!cyber::common::PathExists(scenario_set_directory_path)) {\n    AERROR << \"Scenario set has no scenarios!\";\n    return true;\n  }\n  DIR *directory = opendir(scenario_set_directory_path.c_str());\n  if (directory == nullptr) {\n    AERROR << \"Cannot open directory \" << scenario_set_directory_path;\n    return false;\n  }\n\n  struct dirent *file;\n  while ((file = readdir(directory)) != nullptr) {\n    // skip directory_path/. and directory_path/..\n    if (!strcmp(file->d_name, \".\") || !strcmp(file->d_name, \"..\")) {\n      continue;\n    }\n    const std::string file_name = file->d_name;\n    if (!absl::EndsWith(file_name, \".json\")) {\n      continue;\n    }\n    const int index = file_name.rfind(\".json\");\n    if (index == 0) {\n      // name: \".json\" is invalid.\n      continue;\n    }\n    const std::string scenario_id = file_name.substr(0, index);\n    const std::string file_path = scenario_set_directory_path + file_name;\n    SimTicket new_sim_ticket;\n    if (!cyber::common::GetProtoFromJsonFile(file_path, &new_sim_ticket)) {\n      AERROR << \"Cannot parse this scenario:\" << file_path;\n      return false;\n    }\n    if (!new_sim_ticket.has_scenario()) {\n      AERROR << \"Cannot get scenario.\";\n      return false;\n    }\n    if (!new_sim_ticket.description_en_tokens_size()) {\n      AERROR << \"Cannot get scenario name.\";\n      return false;\n    }\n    if (!new_sim_ticket.scenario().has_map_dir()) {\n      AERROR << \"Cannot get scenario map dir.\";\n      return false;\n    }\n    if (!new_sim_ticket.scenario().has_start()) {\n      AERROR << \"Cannot get scenario start_point.\";\n      return false;\n    }\n    auto &scenario_start_point = new_sim_ticket.scenario().start();\n    if (!scenario_start_point.has_x() || !scenario_start_point.has_y()) {\n      AERROR << \"Scenario start_point is invalid!\";\n      return false;\n    }\n    std::string scenario_name = new_sim_ticket.description_en_tokens(0);\n    for (int i = 1; i < new_sim_ticket.description_en_tokens_size(); i++) {\n      scenario_name =\n          scenario_name + \"_\" + new_sim_ticket.description_en_tokens(i);\n    }\n    ScenarioInfo *scenario_info = new_scenario_set->add_scenarios();\n    scenario_info->set_scenario_id(scenario_id);\n    scenario_info->set_scenario_name(scenario_name);\n    // change scenario json map dir to map name\n    // format:modules/map/data/${map_name}\n    const std::string map_dir = new_sim_ticket.scenario().map_dir();\n    size_t idx = map_dir.find_last_of('/');\n    if (idx == map_dir.npos) {\n      AERROR << \"Cannot get scenario map name.\";\n      return false;\n    }\n    const std::string map_name = map_dir.substr(idx + 1);\n    if (map_name.empty()) {\n      AERROR << \"Cannot get scenario map name.\";\n      return false;\n    }\n    // replay engine use xx_xx like:apollo_map\n    // dv need Apollo Map\n    scenario_info->set_map_name(TitleCase(map_name));\n    auto start_point = scenario_info->mutable_start_point();\n    start_point->set_x(scenario_start_point.x());\n    start_point->set_y(scenario_start_point.y());\n  }\n  closedir(directory);\n  return true;\n}\n\nbool HMIWorker::LoadScenarios() {\n  std::string directory_path;\n  GetScenarioResourcePath(&directory_path);\n  if (!cyber::common::PathExists(directory_path)) {\n    AERROR << \"Failed to find scenario_set!\";\n    return false;\n  }\n  DIR *directory = opendir(directory_path.c_str());\n  if (directory == nullptr) {\n    AERROR << \"Cannot open directory \" << directory_path;\n    return false;\n  }\n  struct dirent *file;\n  std::map<std::string, ScenarioSet> scenario_sets;\n  while ((file = readdir(directory)) != nullptr) {\n    // skip directory_path/. and directory_path/..\n    if (!strcmp(file->d_name, \".\") || !strcmp(file->d_name, \"..\")) {\n      continue;\n    }\n    if (file->d_type != DT_DIR) {\n      continue;\n    }\n    const std::string scenario_set_id = file->d_name;\n    const std::string scenario_set_json_path =\n        directory_path + scenario_set_id + \"/scenario_set.json\";\n    // scenario_set.json use message:UserAdsGroup\n    UserAdsGroup user_ads_group_info;\n    if (!cyber::common::GetProtoFromJsonFile(scenario_set_json_path,\n                                             &user_ads_group_info)) {\n      AERROR << \"Unable to parse UserAdsGroup from file \"\n             << scenario_set_json_path;\n      return false;\n    }\n    if (!user_ads_group_info.has_name()) {\n      AERROR << \"Failed to get ads group name!\";\n      return false;\n    }\n    const std::string scenario_set_name = user_ads_group_info.name();\n    ScenarioSet new_scenario_set;\n    if (!UpdateScenarioSet(scenario_set_id, scenario_set_name,\n                           &new_scenario_set)) {\n      AERROR << \"Failed to update scenario_set!\";\n      return false;\n    }\n    scenario_sets[scenario_set_id] = new_scenario_set;\n  }\n  closedir(directory);\n  {\n    WLock wlock(status_mutex_);\n    auto scenario_set = status_.mutable_scenario_set();\n    // clear old data\n    scenario_set->clear();\n    for (auto iter = scenario_sets.begin(); iter != scenario_sets.end();\n         iter++) {\n      (*scenario_set)[iter->first] = iter->second;\n    }\n    status_changed_ = true;\n  }\n  return true;\n}\n\nbool HMIWorker::LoadDynamicModels() {\n  Json load_res = callback_api_(\"LoadDynamicModels\", {});\n  if (!load_res.contains(\"result\") || !load_res[\"result\"]) {\n    return false;\n  }\n\n  {\n    WLock wlock(status_mutex_);\n    auto dynamic_models = status_.mutable_dynamic_models();\n    // clear old data\n    for (auto iter = dynamic_models->begin(); iter != dynamic_models->end();) {\n      iter = dynamic_models->erase(iter);\n    }\n    for (const auto &dynamic_model : load_res[\"loaded_dynamic_models\"]) {\n      status_.add_dynamic_models(dynamic_model);\n    }\n    status_changed_ = true;\n  }\n  return load_res[\"result\"];\n}\n\nvoid HMIWorker::DeleteScenarioSet(const std::string &scenario_set_id) {\n  if (scenario_set_id.empty()) {\n    return;\n  }\n  std::string directory_path;\n  GetScenarioResourcePath(&directory_path);\n  directory_path = directory_path + scenario_set_id;\n  if (!cyber::common::PathExists(directory_path)) {\n    AERROR << \"Failed to find scenario_set!\";\n    return;\n  }\n  std::string command = \"rm -fr \" + directory_path;\n  // use cyber::common::removeFiles do not support sub-directory\n  // use rmdir do not support not empty directory\n  if (std::system(command.data()) != 0) {\n    AERROR << \"Failed to delete scenario set directory for: \"\n           << std::strerror(errno);\n    return;\n  }\n\n  {\n    RLock rlock(status_mutex_);\n    auto &scenario_set = status_.scenario_set();\n    if (scenario_set.find(scenario_set_id) == scenario_set.end()) {\n      AERROR << \"Cannot find unknown scenario set!\";\n      return;\n    }\n    // do not allowed remove changed current scenario set\n    if (scenario_set_id == status_.current_scenario_set_id()) {\n      AERROR << \"Cannotdelete current scenario set!\";\n      return;\n    }\n  }\n\n  {\n    WLock wlock(status_mutex_);\n    status_.mutable_scenario_set()->erase(scenario_set_id);\n    status_changed_ = true;\n  }\n  return;\n}\n\nvoid HMIWorker::DeleteDynamicModel(const std::string &dynamic_model_name) {\n  if (dynamic_model_name.empty()) {\n    AERROR << \"Invalid param:empty dynamic model name!\";\n    return;\n  }\n  {\n    RLock rlock(status_mutex_);\n    // do not allowed remove changed current dynamic model\n    if (dynamic_model_name == status_.current_dynamic_model()) {\n      AERROR << \"Cannot delete current dynamic model!\";\n      return;\n    }\n    if (dynamic_model_name == FLAGS_sim_perfect_control) {\n      AERROR << \"Cannot delete default sim control:SimPerfectControl!\";\n      return;\n    }\n  }\n  Json param_json({});\n  param_json[\"dynamic_model_name\"] = dynamic_model_name;\n  Json callback_res = callback_api_(\"DeleteDynamicModel\", param_json);\n  if (!callback_res.contains(\"result\") || !callback_res[\"result\"]) {\n    // badcase1: sim control is not enable. badcase2: miss param\n    // badcase3: Failed to delete file\n    AERROR << \"Failed to delete dynamic model!\";\n    return;\n  }\n  {\n    WLock wlock(status_mutex_);\n    auto iter = status_.dynamic_models().begin();\n    while (iter != status_.dynamic_models().end()) {\n      if (*iter == dynamic_model_name) {\n        break;\n      }\n      iter++;\n    }\n    if (iter != status_.dynamic_models().end()) {\n      status_.mutable_dynamic_models()->erase(iter);\n      status_changed_ = true;\n    } else {\n      AWARN << \"Can not find dynamic model to delete!\";\n    }\n  }\n  return;\n}\n\nvoid HMIWorker::GetRecordPath(std::string *record_path) {\n  CHECK_NOTNULL(record_path);\n  const std::string home = cyber::common::GetEnv(\"HOME\");\n  *record_path = home + FLAGS_resource_record_path;\n}\n\nbool HMIWorker::RePlayRecord(const std::string &record_id) {\n  std::string record_path;\n  GetRecordPath(&record_path);\n  record_path = record_path + record_id + \".record\";\n\n  if (!cyber::common::PathExists(record_path)) {\n    AERROR << \"Failed to find record!\";\n    return false;\n  }\n  // play the record\n  const std::string play_command =\n      absl::StrCat(\"nohup cyber_recorder play -l -f \", record_path, \" &\");\n  int ret = std::system(play_command.data());\n  if (ret != 0) {\n    AERROR << \"Failed to start cyber play command\";\n    return false;\n  }\n  return true;\n}\nvoid HMIWorker::StopRecordPlay() {\n  WLock wlock(status_mutex_);\n  { status_.set_current_record_id(\"\"); }\n  if (!StopModuleByCommand(FLAGS_cyber_recorder_stop_command)) {\n    AERROR << \"stop record failed\";\n  }\n  status_changed_ = true;\n}\nvoid HMIWorker::ChangeRecord(const std::string &record_id) {\n  StopRecordPlay();\n  {\n    RLock rlock(status_mutex_);\n    auto status_records = status_.mutable_records();\n    if (status_records->find(record_id) == status_records->end()) {\n      AERROR << \"Cannot change to unknown record!\";\n      return;\n    }\n    if (!RePlayRecord(record_id)) {\n      return;\n    }\n  }\n  WLock wlock(status_mutex_);\n  status_.set_current_record_id(record_id);\n  status_changed_ = true;\n  return;\n}\nbool HMIWorker::LoadRecords() {\n  std::string directory_path;\n  GetRecordPath(&directory_path);\n  if (!cyber::common::PathExists(directory_path)) {\n    AERROR << \"Failed to find records!\";\n    return false;\n  }\n  DIR *directory = opendir(directory_path.c_str());\n  if (directory == nullptr) {\n    AERROR << \"Cannot open record directory\" << directory_path;\n    return false;\n  }\n  struct dirent *file;\n  std::map<std::string, std::int32_t> new_records;\n  while ((file = readdir(directory)) != nullptr) {\n    if (!strcmp(file->d_name, \".\") || !strcmp(file->d_name, \"..\")) {\n      continue;\n    }\n    if (file->d_type == DT_DIR) {\n      continue;\n    }\n    const std::string record_id = file->d_name;\n    const int index = record_id.rfind(\".record\");\n    if (index != -1 && record_id[0] != '.') {\n      const std::string local_record_resource = record_id.substr(0, index);\n      new_records[local_record_resource] = 1;\n    }\n  }\n  closedir(directory);\n  {\n    WLock wlock(status_mutex_);\n    auto status_records = status_.mutable_records();\n    status_records->clear();\n    for (auto iter = new_records.begin(); iter != new_records.end(); iter++) {\n      (*status_records)[iter->first] = iter->second;\n    }\n    status_changed_ = true;\n  }\n  return true;\n}\n\nvoid HMIWorker::DeleteRecord(const std::string &record_id) {\n  StopRecordPlay();\n  if (record_id.empty()) {\n    return;\n  }\n  std::string record_path;\n  GetRecordPath(&record_path);\n  record_path = record_path + record_id + \".record\";\n  if (!cyber::common::PathExists(record_path)) {\n    return;\n  }\n  // find the delete record if exist and judge the record whether playing now\n  {\n    RLock rlock(status_mutex_);\n    auto &status_records = status_.records();\n    if (status_records.find(record_id) == status_records.end()) {\n      return;\n    }\n    if (record_id == status_.current_record_id()) {\n      return;\n    }\n  }\n  {\n    WLock wlock(status_mutex_);\n    status_.mutable_records()->erase(record_id);\n    status_changed_ = true;\n  }\n\n  // delete record from disk\n  std::string command = \"rm -rf \" + record_path;\n  if (std::system(command.data()) != 0) {\n    AERROR << \"Failed to delete record for: \" << std::strerror(errno);\n    return;\n  }\n  return;\n}\nbool HMIWorker::ReloadVehicles() {\n  AINFO << \"load config\";\n  HMIConfig config = LoadConfig();\n  std::string msg;\n  AINFO << \"serialize new config\";\n  config.SerializeToString(&msg);\n\n  WLock wlock(status_mutex_);\n  AINFO << \"parse new config\";\n  config_.ParseFromString(msg);\n  AINFO << \"init status\";\n  // status_.clear_modes();\n  // status_.clear_maps();\n  AINFO << \"clear vehicles\";\n  status_.clear_vehicles();\n  // InitStatus();\n  // Populate vehicles and current_vehicle.\n  AINFO << \"reload vehicles\";\n  for (const auto &vehicle : config_.vehicles()) {\n    status_.add_vehicles(vehicle.first);\n  }\n  status_changed_ = true;\n  return true;\n}\n\nvoid HMIWorker::UpdateCameraSensorChannelToStatus(\n    const std::string &channel_name) {\n  {\n    WLock wlock(status_mutex_);\n    if (status_.current_camera_sensor_channel() == channel_name) {\n      AINFO << \"Input channel name is current camera sensor channel\";\n      return;\n    }\n    status_.set_current_camera_sensor_channel(channel_name);\n    status_changed_ = true;\n  }\n}\n\nvoid HMIWorker::UpdatePointCloudChannelToStatus(\n    const std::string &channel_name) {\n  {\n    WLock wlock(status_mutex_);\n    if (status_.current_point_cloud_channel() == channel_name) {\n      AINFO << \"Input channel name is current camera sensor channel\";\n      return;\n    }\n    status_.set_current_point_cloud_channel(channel_name);\n    status_changed_ = true;\n  }\n}",
        "b_contents": "void HMIWorker::ChangeScenarioSet(const std::string &scenario_set_id) {\n  {\n    RLock rlock(status_mutex_);\n    auto &scenario_set = status_.scenario_set();\n    if ((!scenario_set_id.empty()) &&\n        (scenario_set.find(scenario_set_id) == scenario_set.end())) {\n      AERROR << \"Cannot change to unknown scenario set!\";\n      return;\n    }\n    if (status_.current_scenario_set_id() == scenario_set_id) {\n      return;\n    }\n  }\n\n  {\n    WLock wlock(status_mutex_);\n    status_.set_current_scenario_set_id(scenario_set_id);\n    status_changed_ = true;\n  }\n  return;\n}\n\nvoid HMIWorker::GetScenarioResourcePath(std::string &scenario_resource_path) {\n  const std::string home = cyber::common::GetEnv(\"HOME\");\n  scenario_resource_path = home + FLAGS_resource_scenario_path;\n}\n\nvoid HMIWorker::GetScenarioSetPath(const std::string &scenario_set_id,\n                                   std::string &scenario_set_path) {\n  GetScenarioResourcePath(scenario_set_path);\n  scenario_set_path = scenario_set_path + scenario_set_id;\n  return;\n}\n\nbool HMIWorker::StopModuleByCommand(const std::string &stop_command) const {\n  int ret = std::system(stop_command.data());\n  if (ret < 0 || !WIFEXITED(ret)) {\n\n    // 256 does not means failure\n    AERROR << \"Failed to stop sim obstacle\";\n    return false;\n  }\n  return true;\n}\n\nbool HMIWorker::ResetSimObstacle(const std::string &scenario_id) {\n  // Todo: Check sim obstacle status before closing it\n  const std::string absolute_path =\n      cyber::common::GetEnv(\"HOME\") + FLAGS_sim_obstacle_path;\n  if (!cyber::common::PathExists(absolute_path)) {\n    AERROR << \"Failed to find sim obstacle\";\n    return false;\n  }\n  StopModuleByCommand(FLAGS_sim_obstacle_stop_command);\n  std::string scenario_set_id;\n  {\n    RLock rlock(status_mutex_);\n    scenario_set_id = status_.current_scenario_set_id();\n  }\n  std::string scenario_set_path;\n  GetScenarioSetPath(scenario_set_id, scenario_set_path);\n  const std::string scenario_path =\n      scenario_set_path + \"/scenarios/\" + scenario_id + \".json\";\n  if (!cyber::common::PathExists(scenario_path)) {\n    AERROR << \"Failed to find scenario!\";\n    return false;\n  }\n  std::string map_name = \"\";\n  double x;\n  double y;\n  bool need_to_change_map = true;\n  {\n    RLock rlock(status_mutex_);\n    auto &scenario_set = status_.scenario_set();\n    if (scenario_set.find(scenario_set_id) == scenario_set.end()) {\n      AERROR << \"Failed to find scenario set!\";\n      return false;\n    }\n    for (auto &scenario : scenario_set.at(scenario_set_id).scenarios()) {\n      if (scenario.scenario_id() == scenario_id) {\n        map_name = scenario.map_name();\n        x = scenario.start_point().x();\n        y = scenario.start_point().y();\n        break;\n      }\n    }\n    if (map_name.empty()) {\n      AERROR << \"Failed to find scenario and get map dir!\";\n      return false;\n    }\n    need_to_change_map = (status_.current_map() != map_name);\n  }\n  if (need_to_change_map) {\n    if (!ChangeMap(map_name)) {\n      AERROR << \"Failed to change map!\";\n      return false;\n    }\n    callback_api_(\"MapServiceReloadMap\", {});\n  } else {\n    // Change scenario under the same map requires reset mode\n    ResetMode();\n  }\n  // After changing the map, reset the start point from the scenario by\n  // sim_control\n  Json info;\n  info[\"x\"] = x;\n  info[\"y\"] = y;\n  callback_api_(\"SimControlRestart\", info);\n  // \u542f\u52a8sim obstacle\n  const std::string start_command = \"nohup \" + absolute_path + \" \" +\n                                    scenario_path + FLAGS_gflag_command_arg +\n                                    \" &\";\n  int ret = std::system(start_command.data());\n  if (ret != 0) {\n    AERROR << \"Failed to start sim obstacle\";\n    return false;\n  }\n  return true;\n}\n\nvoid HMIWorker::ChangeScenario(const std::string &scenario_id) {\n  {\n    RLock rlock(status_mutex_);\n    // Skip if mode doesn't actually change.\n    if (status_.current_scenario_id() == scenario_id) {\n      return;\n    }\n    if (scenario_id.empty()) {\n      // stop sim obstacle\n      // todo\uff1a add check status\n      // directly think pkill successful\n      StopModuleByCommand(FLAGS_sim_obstacle_stop_command);\n    } else {\n      auto scenario_set = status_.mutable_scenario_set();\n      auto &scenario_set_id = status_.current_scenario_set_id();\n      if (scenario_set->find(scenario_set_id) == scenario_set->end()) {\n        AERROR << \"Current scenario set is invalid!\";\n        return;\n      }\n      bool find_res = false;\n      for (auto &scenario : (*scenario_set)[scenario_set_id].scenarios()) {\n        if (scenario.scenario_id() == scenario_id) {\n          find_res = true;\n          break;\n        }\n      }\n      if (!find_res) {\n        AERROR << \"Cannot change to unknown scenario!\";\n        return;\n      }\n    }\n  }\n\n  // restart sim obstacle\n  // move sim obstacle position for rlock wlock together will result to dead\n  // lock\n  if (!scenario_id.empty()) {\n    if (!ResetSimObstacle(scenario_id)) {\n      AERROR << \"Cannot start sim obstacle by new scenario!\";\n      return;\n    };\n  }\n  {\n    WLock wlock(status_mutex_);\n    status_.set_current_scenario_id(scenario_id);\n    status_changed_ = true;\n  }\n  return;\n}\n\nvoid HMIWorker::ChangeDynamicModel(const std::string &dynamic_model_name) {\n  {\n    RLock rlock(status_mutex_);\n    // Skip if mode doesn't actually change.\n    if (status_.current_dynamic_model() == dynamic_model_name) {\n      return;\n    }\n  }\n  if (dynamic_model_name.empty()) {\n    AERROR << \"Failed to change empty dynamic model!\";\n    return;\n  }\n  Json param_json({});\n  param_json[\"dynamic_model_name\"] = dynamic_model_name;\n  Json callback_res = callback_api_(\"ChangeDynamicModel\", param_json);\n  if (!callback_res.contains(\"result\") || !callback_res[\"result\"]) {\n    // badcase1\uff1asim control is not enabled. badcase2\uff1amiss params\n    // badcase3\uff1achange dynamic model is not registered. resolution\uff1areturn with no action,keep\n    // sim control not enabled or use original dynamic model!\n    AERROR << \"Failed to change dynamic model! Please check if the param is \"\n              \"valid!\";\n    return;\n  }\n  std::string current_dynamic_model_name = dynamic_model_name;\n  {\n    WLock wlock(status_mutex_);\n    status_.set_current_dynamic_model(dynamic_model_name);\n    status_changed_ = true;\n  }\n\n  return;\n}\n\nbool HMIWorker::UpdateScenarioSetToStatus(\n    const std::string &scenario_set_id, const std::string &scenario_set_name) {\n  ScenarioSet new_scenario_set;\n  if (!UpdateScenarioSet(scenario_set_id, scenario_set_name,\n                         new_scenario_set)) {\n    AERROR << \"Failed to update scenario_set!\";\n    return false;\n  }\n  {\n    WLock wlock(status_mutex_);\n    auto scenario_set = status_.mutable_scenario_set();\n    scenario_set->erase(scenario_set_id);\n    (*scenario_set)[scenario_set_id] = new_scenario_set;\n    status_changed_ = true;\n  }\n  return true;\n}\n\nbool HMIWorker::UpdateDynamicModelToStatus(std::string &dynamic_model_name) {\n  Json param_json({});\n  param_json[\"dynamic_model_name\"] = dynamic_model_name;\n  Json callback_res = callback_api_(\"AddDynamicModel\", param_json);\n  if (!callback_res.contains(\"result\") || !callback_res[\"result\"]) {\n    AERROR << \"Failed to add dynamic model to local dynamic model list for \"\n              \"register failed!\";\n    return false;\n  }\n  {\n    WLock wlock(status_mutex_);\n    for (const auto &iter : status_.dynamic_models()) {\n      if (iter == dynamic_model_name) {\n        AERROR << \"Do not need to add new dynamic model for is duplicate!\";\n        return true;\n      }\n    }\n    status_.mutable_dynamic_models()->Add(std::move(dynamic_model_name));\n    status_changed_ = true;\n  }\n  return true;\n}\n\nbool HMIWorker::UpdateScenarioSet(const std::string &scenario_set_id,\n                                  const std::string &scenario_set_name,\n                                  ScenarioSet &new_scenario_set) {\n  std::string scenario_set_directory_path;\n  GetScenarioSetPath(scenario_set_id, scenario_set_directory_path);\n  scenario_set_directory_path = scenario_set_directory_path + \"/scenarios/\";\n  new_scenario_set.set_scenario_set_name(scenario_set_name);\n  if (!cyber::common::PathExists(scenario_set_directory_path)) {\n    AERROR << \"Scenario set has no scenarios!\";\n    return true;\n  }\n  DIR *directory = opendir(scenario_set_directory_path.c_str());\n  if (directory == nullptr) {\n    AERROR << \"Cannot open directory \" << scenario_set_directory_path;\n    return false;\n  }\n\n  struct dirent *file;\n  while ((file = readdir(directory)) != nullptr) {\n    // skip directory_path/. and directory_path/..\n    if (!strcmp(file->d_name, \".\") || !strcmp(file->d_name, \"..\")) {\n      continue;\n    }\n    const std::string file_name = file->d_name;\n    if (!absl::EndsWith(file_name, \".json\")) {\n      continue;\n    }\n    const int index = file_name.rfind(\".json\");\n    if (index == 0) {\n      // name: \".json\" is invalid.\n      continue;\n    }\n    const std::string scenario_id = file_name.substr(0, index);\n    const std::string file_path = scenario_set_directory_path + file_name;\n    SimTicket new_sim_ticket;\n    if (!cyber::common::GetProtoFromJsonFile(file_path, &new_sim_ticket)) {\n      AERROR << \"Cannot parse this scenario:\" << file_path;\n      return false;\n    }\n    if (!new_sim_ticket.has_scenario()) {\n      AERROR << \"Cannot get scenario.\";\n      return false;\n    }\n    if (!new_sim_ticket.description_en_tokens_size()) {\n      AERROR << \"Cannot get scenario name.\";\n      return false;\n    }\n    if (!new_sim_ticket.scenario().has_map_dir()) {\n      AERROR << \"Cannot get scenario map dir.\";\n      return false;\n    }\n    if (!new_sim_ticket.scenario().has_start()) {\n      AERROR << \"Cannot get scenario start_point.\";\n      return false;\n    }\n    auto &scenario_start_point = new_sim_ticket.scenario().start();\n    if (!scenario_start_point.has_x() || !scenario_start_point.has_y()) {\n      AERROR << \"Scenario start_point is invalid!\";\n      return false;\n    }\n    std::string scenario_name = new_sim_ticket.description_en_tokens(0);\n    for (int i = 1; i < new_sim_ticket.description_en_tokens_size(); i++) {\n      scenario_name =\n          scenario_name + \"_\" + new_sim_ticket.description_en_tokens(i);\n    }\n    ScenarioInfo *scenario_info = new_scenario_set.add_scenarios();\n    scenario_info->set_scenario_id(scenario_id);\n    scenario_info->set_scenario_name(scenario_name);\n    // change scenario json map dir to map name\n    // format:modules/map/data/${map_name}\n    const std::string map_dir = new_sim_ticket.scenario().map_dir();\n    size_t idx = map_dir.find_last_of('/');\n    if (idx == map_dir.npos) {\n      AERROR << \"Cannot get scenario map name.\";\n      return false;\n    }\n    const std::string map_name = map_dir.substr(idx + 1);\n    if (map_name.empty()) {\n      AERROR << \"Cannot get scenario map name.\";\n      return false;\n    }\n    // replay engine use xx_xx like:apollo_map\n    // dv need Apollo Map\n    scenario_info->set_map_name(TitleCase(map_name));\n    auto start_point = scenario_info->mutable_start_point();\n    start_point->set_x(scenario_start_point.x());\n    start_point->set_y(scenario_start_point.y());\n  }\n  closedir(directory);\n  return true;\n}\n\nbool HMIWorker::LoadScenarios() {\n  std::string directory_path;\n  GetScenarioResourcePath(directory_path);\n  if (!cyber::common::PathExists(directory_path)) {\n    AERROR << \"Failed to find scenario_set!\";\n    return false;\n  }\n  DIR *directory = opendir(directory_path.c_str());\n  if (directory == nullptr) {\n    AERROR << \"Cannot open directory \" << directory_path;\n    return false;\n  }\n  struct dirent *file;\n  std::map<std::string, ScenarioSet> scenario_sets;\n  while ((file = readdir(directory)) != nullptr) {\n    // skip directory_path/. and directory_path/..\n    if (!strcmp(file->d_name, \".\") || !strcmp(file->d_name, \"..\")) {\n      continue;\n    }\n    if (file->d_type != DT_DIR) {\n      continue;\n    }\n    const std::string scenario_set_id = file->d_name;\n    const std::string scenario_set_json_path =\n        directory_path + scenario_set_id + \"/scenario_set.json\";\n    // scenario_set.json use message:UserAdsGroup\n    UserAdsGroup user_ads_group_info;\n    if (!cyber::common::GetProtoFromJsonFile(scenario_set_json_path,\n                                             &user_ads_group_info)) {\n      AERROR << \"Unable to parse UserAdsGroup from file \"\n             << scenario_set_json_path;\n      return false;\n    }\n    if (!user_ads_group_info.has_name()) {\n      AERROR << \"Failed to get ads group name!\";\n      return false;\n    }\n    const std::string scenario_set_name = user_ads_group_info.name();\n    ScenarioSet new_scenario_set;\n    if (!UpdateScenarioSet(scenario_set_id, scenario_set_name,\n                           new_scenario_set)) {\n      AERROR << \"Failed to update scenario_set!\";\n      return false;\n    }\n    scenario_sets[scenario_set_id] = new_scenario_set;\n  }\n  closedir(directory);\n  {\n    WLock wlock(status_mutex_);\n    auto scenario_set = status_.mutable_scenario_set();\n    // clear old data\n    scenario_set->clear();\n    for (auto iter = scenario_sets.begin(); iter != scenario_sets.end();\n         iter++) {\n      (*scenario_set)[iter->first] = iter->second;\n    }\n    status_changed_ = true;\n  }\n  return true;\n}\n\nbool HMIWorker::LoadDynamicModels() {\n  Json load_res = callback_api_(\"LoadDynamicModels\", {});\n  if (!load_res.contains(\"result\") || !load_res[\"result\"]) {\n    return false;\n  }\n\n  {\n    WLock wlock(status_mutex_);\n    auto dynamic_models = status_.mutable_dynamic_models();\n    // clear old data\n    for (auto iter = dynamic_models->begin(); iter != dynamic_models->end();) {\n      iter = dynamic_models->erase(iter);\n    }\n    for (const auto &dynamic_model : load_res[\"loaded_dynamic_models\"]) {\n      status_.add_dynamic_models(dynamic_model);\n    }\n    status_changed_ = true;\n  }\n  return load_res[\"result\"];\n}\n\nvoid HMIWorker::DeleteScenarioSet(const std::string &scenario_set_id) {\n  if (scenario_set_id.empty()) {\n    return;\n  }\n  std::string directory_path;\n  GetScenarioResourcePath(directory_path);\n  directory_path = directory_path + scenario_set_id;\n  if (!cyber::common::PathExists(directory_path)) {\n    AERROR << \"Failed to find scenario_set!\";\n    return;\n  }\n  std::string command = \"rm -fr \" + directory_path;\n  // use cyber::common::removeFiles do not support sub-directory\n  // use rmdir do not support not empty directory\n  if (std::system(command.data()) != 0) {\n    AERROR << \"Failed to delete scenario set directory for: \"\n           << std::strerror(errno);\n    return;\n  }\n\n  {\n    RLock rlock(status_mutex_);\n    auto &scenario_set = status_.scenario_set();\n    if (scenario_set.find(scenario_set_id) == scenario_set.end()) {\n      AERROR << \"Cannot find unknown scenario set!\";\n      return;\n    }\n    // do not allowed remove changed current scenario set\n    if (scenario_set_id == status_.current_scenario_set_id()) {\n      AERROR << \"Cannotdelete current scenario set!\";\n      return;\n    }\n  }\n\n  {\n    WLock wlock(status_mutex_);\n    status_.mutable_scenario_set()->erase(scenario_set_id);\n    status_changed_ = true;\n  }\n  return;\n}\n\nvoid HMIWorker::DeleteDynamicModel(const std::string &dynamic_model_name) {\n  if (dynamic_model_name.empty()) {\n    AERROR << \"Invalid param:empty dynamic model name!\";\n    return;\n  }\n  {\n    RLock rlock(status_mutex_);\n    // do not allowed remove changed current dynamic model\n    if (dynamic_model_name == status_.current_dynamic_model()) {\n      AERROR << \"Cannot delete current dynamic model!\";\n      return;\n    }\n    if (dynamic_model_name == FLAGS_sim_perfect_control) {\n      AERROR << \"Cannot delete default sim control:SimPerfectControl!\";\n      return;\n    }\n  }\n  Json param_json({});\n  param_json[\"dynamic_model_name\"] = dynamic_model_name;\n  Json callback_res = callback_api_(\"DeleteDynamicModel\", param_json);\n  if (!callback_res.contains(\"result\") || !callback_res[\"result\"]) {\n    // badcase1: sim control is not enable. badcase2: miss param\n    // badcase3: Failed to delete file\n    AERROR << \"Failed to delete dynamic model!\";\n    return;\n  }\n  {\n    WLock wlock(status_mutex_);\n    auto iter = status_.dynamic_models().begin();\n    while (iter != status_.dynamic_models().end()) {\n      if (*iter == dynamic_model_name) {\n        break;\n      }\n      iter++;\n    }\n    if (iter != status_.dynamic_models().end()) {\n      status_.mutable_dynamic_models()->erase(iter);\n      status_changed_ = true;\n    } else {\n      AWARN << \"Can not find dynamic model to delete!\";\n    }\n  }\n  return;\n}\n\nvoid HMIWorker::GetRecordPath(std::string& record_path){\n  const std::string home = cyber::common::GetEnv(\"HOME\");\n  record_path = home + FLAGS_resource_record_path;\n}\n\nbool HMIWorker::RePlayRecord(const std::string& record_id) {\n  AERROR << \"replay record--start\";\n  std::string record_path;\n  GetRecordPath(record_path);\n  record_path = record_path + record_id + \".record\";\n\n  if(!cyber::common::PathExists(record_path)){\n    AERROR << \"Failed to find record!\";\n    return false;\n  }\n  //play the record\n  const std::string play_command = absl::StrCat(\"nohup cyber_recorder play -l -f \", record_path, \" &\");\n  //std::string play_command = absl::StrCat(\"cyber_recorder play -l -f\",record_path);\n  AERROR <<\"record play command\"<< play_command;\n  int ret = std::system(play_command.data());\n  if(ret != 0){\n    AERROR << \"Failed to start cyber play command\";\n    return false;\n  }\n  AERROR << \"replay record--over\";\n  return true;\n}\nvoid HMIWorker::StopRecordPlay(){\n  AERROR << \"stop record--start\";\n  WLock wlock(status_mutex_);\n  {\n    status_.set_current_record_id(\"\");\n  }\n  if (!StopModuleByCommand(FLAGS_cyber_recorder_stop_command))\n  {\n    AERROR << \"stop record failed\";\n  }\n  AERROR << \"stop record--over\";\n  status_changed_ = true;\n}\nvoid HMIWorker::ChangeRecord(const std::string& record_id){\n  AERROR << \"change record--start\";\n  StopRecordPlay();\n  AERROR << \"change record--record stop\";\n  {\n    RLock rlock(status_mutex_);\n    AERROR << \"change record--get rlock success\";\n    auto status_records = status_.mutable_records();\n    if(status_records->find(record_id) == status_records->end()) {\n      AERROR << \"Cannot change to unknown record!\";\n      return;\n    }\n    AERROR << \"change record--start play record\";\n    if(!RePlayRecord(record_id)){\n        AERROR << \"Cannot replay a new record!\";\n        return;\n    }\n  }\n  AERROR << \"change record--start get wlock\";\n  WLock wlock(status_mutex_);\n  AERROR << \"change record--get wlock success\";\n  status_.set_current_record_id(record_id);\n  AERROR << \"change record--set current record id success\";\n  status_changed_ = true;\n  AERROR << \"change record--status_change success\";\n  return;\n}\nbool HMIWorker::UpdateRecordToStatus(const std::string& record_id,const std::string& record_status){\n\n  //\u68c0\u67e5\u5f53\u5730\u8d44\u6e90\u6709\u6ca1\u6709\u4e86record\u6587\u4ef6\n  std::string record_path;\n  GetRecordPath(record_path);\n  record_path = record_path + record_id + \".record\";\n  if (!cyber::common::PathExists(record_path)) {\n    AERROR<<\"record resources has no record!\";\n    return false;\n  }\n  //\u5199\u5165hmi status\n  WLock wlock(status_mutex_);\n  auto record_set = status_.mutable_records();\n  if(record_status==\"downloaded\"){\n    //record \u5b58\u50a8\u5f53\u524d\u72b6\u6001\u6b63\u5e38\n    (*record_set)[record_id] = 0;\n  }\n  else{\n    //record \u5b58\u50a8\u5f53\u524d\u72b6\u6001\u4e0d\u6b63\u5e38\n    (*record_set)[record_id] = 1;\n  }\n  status_changed_ = true;\n  return true;\n}\n\nbool HMIWorker::LoadRecords(){\n  AERROR << \"load record--start\";\n  StopRecordPlay();\n  AERROR << \"load record--stop record\";\n  std::string directory_path;\n  GetRecordPath(directory_path);\n  if (!cyber::common::PathExists(directory_path))\n  {\n    AERROR << \"Failed to find records!\";\n    return false;\n  }\n  AERROR << \"load record--open dir\";\n  DIR* directory = opendir(directory_path.c_str());\n  if (directory == nullptr)\n  {\n    AERROR << \"Cannot open record directory\" << directory_path;\n    return false;\n  }\n  struct dirent* file;\n  std::map<std::string,std::int32_t> new_records;\n  AERROR << \"load record--start writing to hmi status\";\n  while ((file = readdir(directory)) != nullptr) {\n    if (!strcmp(file->d_name, \".\") || !strcmp(file->d_name, \"..\"))\n    {\n      continue;\n    }\n    if (file->d_type == DT_DIR) {\n      continue;\n    }\n    const std::string record_id = file->d_name;\n    const int index = record_id.rfind(\".record\");\n    const std::string local_record_resource = record_id.substr(0, index);\n    new_records[local_record_resource] = 1;\n  }\n  closedir(directory);\n  AERROR << \"load record--close dir\";\n  {\n    AERROR << \"load record--get wlock\";\n    WLock wlock(status_mutex_);\n    AERROR << \"load record--get wlock success\";\n    auto status_records = status_.mutable_records();\n    status_records->clear();\n    for (auto iter = new_records.begin(); iter != new_records.end();iter++) {\n      (*status_records)[iter->first] = iter->second;\n    }\n    status_changed_ = true;\n  }\n   AERROR << \"load record--change records finish\";\n  return true;\n}\n\nvoid HMIWorker::DeleteRecord(const std::string& record_id){\n  AERROR << \"delete record--stop record\";\n  StopRecordPlay();\n  AERROR << \"delete record--stop record\";\n  if (record_id.empty()) {\n    return;\n  }\n  std::string record_path;\n  GetRecordPath(record_path);\n  record_path = record_path + record_id +\".record\";\n  AERROR << \"record path \" << record_path;\n  if (!cyber::common::PathExists(record_path))\n  {\n    AERROR << \"Failed to find record_path!\";\n    return;\n  }\n  //find the delete record if exist and judge the record whether playing now\n  {\n    RLock rlock(status_mutex_);\n    auto& status_records = status_.records();\n    if(status_records.find(record_id)==status_records.end()){\n      AERROR << \"Failed to find unknown record!\";\n      return;\n    }\n     AERROR << \"delete record--change record -id\";\n    if(record_id == status_.current_record_id()){\n      AERROR << \"Cannot delete the current record!\";\n      return;\n    }\n  }\n  {\n    WLock wlock(status_mutex_);\n    status_.mutable_records()->erase(record_id);\n    status_changed_ = true;\n  }\n\n  //delete record from disk\n  std::string command = \"rm -rf \" + record_path;\n  if(std::system(command.data()) != 0){\n    AERROR << \"Failed to delete record for: \" << std::strerror(errno);\n    return;\n  }\n  return;\n}\n",
        "base_contents": "",
        "res_region": "void HMIWorker::ChangeScenarioSet(const std::string &scenario_set_id) {\n  {\n    RLock rlock(status_mutex_);\n    auto &scenario_set = status_.scenario_set();\n    if ((!scenario_set_id.empty()) &&\n        (scenario_set.find(scenario_set_id) == scenario_set.end())) {\n      AERROR << \"Cannot change to unknown scenario set!\";\n      return;\n    }\n    if (status_.current_scenario_set_id() == scenario_set_id) {\n      return;\n    }\n  }\n\n  {\n    WLock wlock(status_mutex_);\n    status_.set_current_scenario_set_id(scenario_set_id);\n    status_changed_ = true;\n  }\n  return;\n}\n\nvoid HMIWorker::GetScenarioResourcePath(std::string *scenario_resource_path) {\n  CHECK_NOTNULL(scenario_resource_path);\n  const std::string home = cyber::common::GetEnv(\"HOME\");\n  *scenario_resource_path = home + FLAGS_resource_scenario_path;\n}\n\nvoid HMIWorker::GetScenarioSetPath(const std::string &scenario_set_id,\n                                   std::string *scenario_set_path) {\n  CHECK_NOTNULL(scenario_set_path);\n  GetScenarioResourcePath(scenario_set_path);\n  *scenario_set_path = *scenario_set_path + scenario_set_id;\n  return;\n}\n\nbool HMIWorker::StopModuleByCommand(const std::string &stop_command) const {\n  int ret = std::system(stop_command.data());\n  if (ret < 0 || !WIFEXITED(ret)) {\n    // 256 does not means failure\n    AERROR << \"Failed to stop sim obstacle\";\n    return false;\n  }\n  return true;\n}\n\nbool HMIWorker::ResetSimObstacle(const std::string &scenario_id) {\n  // Todo: Check sim obstacle status before closing it\n  const std::string absolute_path =\n      cyber::common::GetEnv(\"HOME\") + FLAGS_sim_obstacle_path;\n  if (!cyber::common::PathExists(absolute_path)) {\n    AERROR << \"Failed to find sim obstacle\";\n    return false;\n  }\n  StopModuleByCommand(FLAGS_sim_obstacle_stop_command);\n  std::string scenario_set_id;\n  {\n    RLock rlock(status_mutex_);\n    scenario_set_id = status_.current_scenario_set_id();\n  }\n  std::string scenario_set_path;\n  GetScenarioSetPath(scenario_set_id, &scenario_set_path);\n  const std::string scenario_path =\n      scenario_set_path + \"/scenarios/\" + scenario_id + \".json\";\n  if (!cyber::common::PathExists(scenario_path)) {\n    AERROR << \"Failed to find scenario!\";\n    return false;\n  }\n  std::string map_name = \"\";\n  double x;\n  double y;\n  bool need_to_change_map = true;\n  {\n    RLock rlock(status_mutex_);\n    auto &scenario_set = status_.scenario_set();\n    if (scenario_set.find(scenario_set_id) == scenario_set.end()) {\n      AERROR << \"Failed to find scenario set!\";\n      return false;\n    }\n    for (auto &scenario : scenario_set.at(scenario_set_id).scenarios()) {\n      if (scenario.scenario_id() == scenario_id) {\n        map_name = scenario.map_name();\n        x = scenario.start_point().x();\n        y = scenario.start_point().y();\n        break;\n      }\n    }\n    if (map_name.empty()) {\n      AERROR << \"Failed to find scenario and get map dir!\";\n      return false;\n    }\n    need_to_change_map = (status_.current_map() != map_name);\n  }\n  if (need_to_change_map) {\n    if (!ChangeMap(map_name)) {\n      AERROR << \"Failed to change map!\";\n      return false;\n    }\n    callback_api_(\"MapServiceReloadMap\", {});\n  } else {\n    // Change scenario under the same map requires reset mode\n    ResetMode();\n  }\n  // After changing the map, reset the start point from the scenario by\n  // sim_control\n  Json info;\n  info[\"x\"] = x;\n  info[\"y\"] = y;\n  callback_api_(\"SimControlRestart\", info);\n  // \u542f\u52a8sim obstacle\n  const std::string start_command = \"nohup \" + absolute_path + \" \" +\n                                    scenario_path + FLAGS_gflag_command_arg +\n                                    \" &\";\n  int ret = std::system(start_command.data());\n  if (ret != 0) {\n    AERROR << \"Failed to start sim obstacle\";\n    return false;\n  }\n  return true;\n}\n\nvoid HMIWorker::ChangeScenario(const std::string &scenario_id) {\n  {\n    RLock rlock(status_mutex_);\n    // Skip if mode doesn't actually change.\n    if (status_.current_scenario_id() == scenario_id) {\n      return;\n    }\n    if (scenario_id.empty()) {\n      // stop sim obstacle\n      // todo\uff1a add check status\n      // directly think pkill successful\n      StopModuleByCommand(FLAGS_sim_obstacle_stop_command);\n    } else {\n      auto scenario_set = status_.mutable_scenario_set();\n      auto &scenario_set_id = status_.current_scenario_set_id();\n      if (scenario_set->find(scenario_set_id) == scenario_set->end()) {\n        AERROR << \"Current scenario set is invalid!\";\n        return;\n      }\n      bool find_res = false;\n      for (auto &scenario : (*scenario_set)[scenario_set_id].scenarios()) {\n        if (scenario.scenario_id() == scenario_id) {\n          find_res = true;\n          break;\n        }\n      }\n      if (!find_res) {\n        AERROR << \"Cannot change to unknown scenario!\";\n        return;\n      }\n    }\n  }\n\n  // restart sim obstacle\n  // move sim obstacle position for rlock wlock together will result to dead\n  // lock\n  if (!scenario_id.empty()) {\n    if (!ResetSimObstacle(scenario_id)) {\n      AERROR << \"Cannot start sim obstacle by new scenario!\";\n      return;\n    }\n  }\n  {\n    WLock wlock(status_mutex_);\n    status_.set_current_scenario_id(scenario_id);\n    status_changed_ = true;\n  }\n  return;\n}\n\nvoid HMIWorker::ChangeDynamicModel(const std::string &dynamic_model_name) {\n  // To avoid toggle sim control and always choose simulation perfect control\n  // {\n  //   RLock rlock(status_mutex_);\n  //   // Skip if mode doesn't actually change.\n  //   if (status_.current_dynamic_model() == dynamic_model_name) {\n  //     return;\n  //   }\n  // }\n  if (dynamic_model_name.empty()) {\n    AERROR << \"Failed to change empty dynamic model!\";\n    return;\n  }\n  Json param_json({});\n  param_json[\"dynamic_model_name\"] = dynamic_model_name;\n  Json callback_res = callback_api_(\"ChangeDynamicModel\", param_json);\n  if (!callback_res.contains(\"result\") || !callback_res[\"result\"]) {\n    // badcase1\uff1asim control is not enabled. badcase2\uff1amiss params\n    // badcase3\uff1achange dynamic model is not registered. resolution\uff1areturn with\n    // no action,keep sim control not enabled or use original dynamic model!\n    AERROR << \"Failed to change dynamic model! Please check if the param is \"\n              \"valid!\";\n    return;\n  }\n  std::string current_dynamic_model_name = dynamic_model_name;\n  {\n    WLock wlock(status_mutex_);\n    status_.set_current_dynamic_model(dynamic_model_name);\n    status_changed_ = true;\n  }\n\n  return;\n}\n\nbool HMIWorker::UpdateScenarioSetToStatus(\n    const std::string &scenario_set_id, const std::string &scenario_set_name) {\n  ScenarioSet new_scenario_set;\n  if (!UpdateScenarioSet(scenario_set_id, scenario_set_name,\n                         &new_scenario_set)) {\n    AERROR << \"Failed to update scenario_set!\";\n    return false;\n  }\n  {\n    WLock wlock(status_mutex_);\n    auto scenario_set = status_.mutable_scenario_set();\n    scenario_set->erase(scenario_set_id);\n    (*scenario_set)[scenario_set_id] = new_scenario_set;\n    status_changed_ = true;\n  }\n  return true;\n}\n\nbool HMIWorker::UpdateDynamicModelToStatus(\n    const std::string &dynamic_model_name) {\n  Json param_json({});\n  param_json[\"dynamic_model_name\"] = dynamic_model_name;\n  Json callback_res = callback_api_(\"AddDynamicModel\", param_json);\n  if (!callback_res.contains(\"result\") || !callback_res[\"result\"]) {\n    AERROR << \"Failed to add dynamic model to local dynamic model list for \"\n              \"register failed!\";\n    return false;\n  }\n  {\n    WLock wlock(status_mutex_);\n    for (const auto &iter : status_.dynamic_models()) {\n      if (iter == dynamic_model_name) {\n        AERROR << \"Do not need to add new dynamic model for is duplicate!\";\n        return true;\n      }\n    }\n    status_.add_dynamic_models(dynamic_model_name);\n    status_changed_ = true;\n  }\n  return true;\n}\n\nbool HMIWorker::UpdateScenarioSet(const std::string &scenario_set_id,\n                                  const std::string &scenario_set_name,\n                                  ScenarioSet *new_scenario_set) {\n  std::string scenario_set_directory_path;\n  GetScenarioSetPath(scenario_set_id, &scenario_set_directory_path);\n  scenario_set_directory_path = scenario_set_directory_path + \"/scenarios/\";\n  new_scenario_set->set_scenario_set_name(scenario_set_name);\n  if (!cyber::common::PathExists(scenario_set_directory_path)) {\n    AERROR << \"Scenario set has no scenarios!\";\n    return true;\n  }\n  DIR *directory = opendir(scenario_set_directory_path.c_str());\n  if (directory == nullptr) {\n    AERROR << \"Cannot open directory \" << scenario_set_directory_path;\n    return false;\n  }\n\n  struct dirent *file;\n  while ((file = readdir(directory)) != nullptr) {\n    // skip directory_path/. and directory_path/..\n    if (!strcmp(file->d_name, \".\") || !strcmp(file->d_name, \"..\")) {\n      continue;\n    }\n    const std::string file_name = file->d_name;\n    if (!absl::EndsWith(file_name, \".json\")) {\n      continue;\n    }\n    const int index = file_name.rfind(\".json\");\n    if (index == 0) {\n      // name: \".json\" is invalid.\n      continue;\n    }\n    const std::string scenario_id = file_name.substr(0, index);\n    const std::string file_path = scenario_set_directory_path + file_name;\n    SimTicket new_sim_ticket;\n    if (!cyber::common::GetProtoFromJsonFile(file_path, &new_sim_ticket)) {\n      AERROR << \"Cannot parse this scenario:\" << file_path;\n      return false;\n    }\n    if (!new_sim_ticket.has_scenario()) {\n      AERROR << \"Cannot get scenario.\";\n      return false;\n    }\n    if (!new_sim_ticket.description_en_tokens_size()) {\n      AERROR << \"Cannot get scenario name.\";\n      return false;\n    }\n    if (!new_sim_ticket.scenario().has_map_dir()) {\n      AERROR << \"Cannot get scenario map dir.\";\n      return false;\n    }\n    if (!new_sim_ticket.scenario().has_start()) {\n      AERROR << \"Cannot get scenario start_point.\";\n      return false;\n    }\n    auto &scenario_start_point = new_sim_ticket.scenario().start();\n    if (!scenario_start_point.has_x() || !scenario_start_point.has_y()) {\n      AERROR << \"Scenario start_point is invalid!\";\n      return false;\n    }\n    std::string scenario_name = new_sim_ticket.description_en_tokens(0);\n    for (int i = 1; i < new_sim_ticket.description_en_tokens_size(); i++) {\n      scenario_name =\n          scenario_name + \"_\" + new_sim_ticket.description_en_tokens(i);\n    }\n    ScenarioInfo *scenario_info = new_scenario_set->add_scenarios();\n    scenario_info->set_scenario_id(scenario_id);\n    scenario_info->set_scenario_name(scenario_name);\n    // change scenario json map dir to map name\n    // format:modules/map/data/${map_name}\n    const std::string map_dir = new_sim_ticket.scenario().map_dir();\n    size_t idx = map_dir.find_last_of('/');\n    if (idx == map_dir.npos) {\n      AERROR << \"Cannot get scenario map name.\";\n      return false;\n    }\n    const std::string map_name = map_dir.substr(idx + 1);\n    if (map_name.empty()) {\n      AERROR << \"Cannot get scenario map name.\";\n      return false;\n    }\n    // replay engine use xx_xx like:apollo_map\n    // dv need Apollo Map\n    scenario_info->set_map_name(TitleCase(map_name));\n    auto start_point = scenario_info->mutable_start_point();\n    start_point->set_x(scenario_start_point.x());\n    start_point->set_y(scenario_start_point.y());\n  }\n  closedir(directory);\n  return true;\n}\n\nbool HMIWorker::LoadScenarios() {\n  std::string directory_path;\n  GetScenarioResourcePath(&directory_path);\n  if (!cyber::common::PathExists(directory_path)) {\n    AERROR << \"Failed to find scenario_set!\";\n    return false;\n  }\n  DIR *directory = opendir(directory_path.c_str());\n  if (directory == nullptr) {\n    AERROR << \"Cannot open directory \" << directory_path;\n    return false;\n  }\n  struct dirent *file;\n  std::map<std::string, ScenarioSet> scenario_sets;\n  while ((file = readdir(directory)) != nullptr) {\n    // skip directory_path/. and directory_path/..\n    if (!strcmp(file->d_name, \".\") || !strcmp(file->d_name, \"..\")) {\n      continue;\n    }\n    if (file->d_type != DT_DIR) {\n      continue;\n    }\n    const std::string scenario_set_id = file->d_name;\n    const std::string scenario_set_json_path =\n        directory_path + scenario_set_id + \"/scenario_set.json\";\n    // scenario_set.json use message:UserAdsGroup\n    UserAdsGroup user_ads_group_info;\n    if (!cyber::common::GetProtoFromJsonFile(scenario_set_json_path,\n                                             &user_ads_group_info)) {\n      AERROR << \"Unable to parse UserAdsGroup from file \"\n             << scenario_set_json_path;\n      return false;\n    }\n    if (!user_ads_group_info.has_name()) {\n      AERROR << \"Failed to get ads group name!\";\n      return false;\n    }\n    const std::string scenario_set_name = user_ads_group_info.name();\n    ScenarioSet new_scenario_set;\n    if (!UpdateScenarioSet(scenario_set_id, scenario_set_name,\n                           &new_scenario_set)) {\n      AERROR << \"Failed to update scenario_set!\";\n      return false;\n    }\n    scenario_sets[scenario_set_id] = new_scenario_set;\n  }\n  closedir(directory);\n  {\n    WLock wlock(status_mutex_);\n    auto scenario_set = status_.mutable_scenario_set();\n    // clear old data\n    scenario_set->clear();\n    for (auto iter = scenario_sets.begin(); iter != scenario_sets.end();\n         iter++) {\n      (*scenario_set)[iter->first] = iter->second;\n    }\n    status_changed_ = true;\n  }\n  return true;\n}\n\nbool HMIWorker::LoadDynamicModels() {\n  Json load_res = callback_api_(\"LoadDynamicModels\", {});\n  if (!load_res.contains(\"result\") || !load_res[\"result\"]) {\n    return false;\n  }\n\n  {\n    WLock wlock(status_mutex_);\n    auto dynamic_models = status_.mutable_dynamic_models();\n    // clear old data\n    for (auto iter = dynamic_models->begin(); iter != dynamic_models->end();) {\n      iter = dynamic_models->erase(iter);\n    }\n    for (const auto &dynamic_model : load_res[\"loaded_dynamic_models\"]) {\n      status_.add_dynamic_models(dynamic_model);\n    }\n    status_changed_ = true;\n  }\n  return load_res[\"result\"];\n}\n\nvoid HMIWorker::DeleteScenarioSet(const std::string &scenario_set_id) {\n  if (scenario_set_id.empty()) {\n    return;\n  }\n  std::string directory_path;\n  GetScenarioResourcePath(&directory_path);\n  directory_path = directory_path + scenario_set_id;\n  if (!cyber::common::PathExists(directory_path)) {\n    AERROR << \"Failed to find scenario_set!\";\n    return;\n  }\n  std::string command = \"rm -fr \" + directory_path;\n  // use cyber::common::removeFiles do not support sub-directory\n  // use rmdir do not support not empty directory\n  if (std::system(command.data()) != 0) {\n    AERROR << \"Failed to delete scenario set directory for: \"\n           << std::strerror(errno);\n    return;\n  }\n\n  {\n    RLock rlock(status_mutex_);\n    auto &scenario_set = status_.scenario_set();\n    if (scenario_set.find(scenario_set_id) == scenario_set.end()) {\n      AERROR << \"Cannot find unknown scenario set!\";\n      return;\n    }\n    // do not allowed remove changed current scenario set\n    if (scenario_set_id == status_.current_scenario_set_id()) {\n      AERROR << \"Cannotdelete current scenario set!\";\n      return;\n    }\n  }\n\n  {\n    WLock wlock(status_mutex_);\n    status_.mutable_scenario_set()->erase(scenario_set_id);\n    status_changed_ = true;\n  }\n  return;\n}\n\nvoid HMIWorker::DeleteDynamicModel(const std::string &dynamic_model_name) {\n  if (dynamic_model_name.empty()) {\n    AERROR << \"Invalid param:empty dynamic model name!\";\n    return;\n  }\n  {\n    RLock rlock(status_mutex_);\n    // do not allowed remove changed current dynamic model\n    if (dynamic_model_name == status_.current_dynamic_model()) {\n      AERROR << \"Cannot delete current dynamic model!\";\n      return;\n    }\n    if (dynamic_model_name == FLAGS_sim_perfect_control) {\n      AERROR << \"Cannot delete default sim control:SimPerfectControl!\";\n      return;\n    }\n  }\n  Json param_json({});\n  param_json[\"dynamic_model_name\"] = dynamic_model_name;\n  Json callback_res = callback_api_(\"DeleteDynamicModel\", param_json);\n  if (!callback_res.contains(\"result\") || !callback_res[\"result\"]) {\n    // badcase1: sim control is not enable. badcase2: miss param\n    // badcase3: Failed to delete file\n    AERROR << \"Failed to delete dynamic model!\";\n    return;\n  }\n  {\n    WLock wlock(status_mutex_);\n    auto iter = status_.dynamic_models().begin();\n    while (iter != status_.dynamic_models().end()) {\n      if (*iter == dynamic_model_name) {\n        break;\n      }\n      iter++;\n    }\n    if (iter != status_.dynamic_models().end()) {\n      status_.mutable_dynamic_models()->erase(iter);\n      status_changed_ = true;\n    } else {\n      AWARN << \"Can not find dynamic model to delete!\";\n    }\n  }\n  return;\n}\n\nvoid HMIWorker::GetRecordPath(std::string *record_path) {\n  CHECK_NOTNULL(record_path);\n  const std::string home = cyber::common::GetEnv(\"HOME\");\n  *record_path = home + FLAGS_resource_record_path;\n}\n\nbool HMIWorker::RePlayRecord(const std::string &record_id) {\n  std::string record_path;\n  GetRecordPath(&record_path);\n  record_path = record_path + record_id + \".record\";\n\n  if (!cyber::common::PathExists(record_path)) {\n    AERROR << \"Failed to find record!\";\n    return false;\n  }\n  // play the record\n  const std::string play_command =\n      absl::StrCat(\"nohup cyber_recorder play -l -f \", record_path, \" &\");\n  int ret = std::system(play_command.data());\n  if (ret != 0) {\n    AERROR << \"Failed to start cyber play command\";\n    return false;\n  }\n  return true;\n}\nvoid HMIWorker::StopRecordPlay() {\n  WLock wlock(status_mutex_);\n  { status_.set_current_record_id(\"\"); }\n  if (!StopModuleByCommand(FLAGS_cyber_recorder_stop_command)) {\n    AERROR << \"stop record failed\";\n  }\n  status_changed_ = true;\n}\nvoid HMIWorker::ChangeRecord(const std::string &record_id) {\n  StopRecordPlay();\n  {\n    RLock rlock(status_mutex_);\n    auto status_records = status_.mutable_records();\n    if (status_records->find(record_id) == status_records->end()) {\n      AERROR << \"Cannot change to unknown record!\";\n      return;\n    }\n    if (!RePlayRecord(record_id)) {\n      return;\n    }\n  }\n  WLock wlock(status_mutex_);\n  status_.set_current_record_id(record_id);\n  status_changed_ = true;\n  return;\n}\nbool HMIWorker::LoadRecords() {\n  std::string directory_path;\n  GetRecordPath(&directory_path);\n  if (!cyber::common::PathExists(directory_path)) {\n    AERROR << \"Failed to find records!\";\n    return false;\n  }\n  DIR *directory = opendir(directory_path.c_str());\n  if (directory == nullptr) {\n    AERROR << \"Cannot open record directory\" << directory_path;\n    return false;\n  }\n  struct dirent *file;\n  std::map<std::string, std::int32_t> new_records;\n  while ((file = readdir(directory)) != nullptr) {\n    if (!strcmp(file->d_name, \".\") || !strcmp(file->d_name, \"..\")) {\n      continue;\n    }\n    if (file->d_type == DT_DIR) {\n      continue;\n    }\n    const std::string record_id = file->d_name;\n    const int index = record_id.rfind(\".record\");\n    if (index != -1 && record_id[0] != '.') {\n      const std::string local_record_resource = record_id.substr(0, index);\n      new_records[local_record_resource] = 1;\n    }\n  }\n  closedir(directory);\n  {\n    WLock wlock(status_mutex_);\n    auto status_records = status_.mutable_records();\n    status_records->clear();\n    for (auto iter = new_records.begin(); iter != new_records.end(); iter++) {\n      (*status_records)[iter->first] = iter->second;\n    }\n    status_changed_ = true;\n  }\n  return true;\n}\n\nvoid HMIWorker::DeleteRecord(const std::string &record_id) {\n  StopRecordPlay();\n  if (record_id.empty()) {\n    return;\n  }\n  std::string record_path;\n  GetRecordPath(&record_path);\n  record_path = record_path + record_id + \".record\";\n  if (!cyber::common::PathExists(record_path)) {\n    return;\n  }\n  // find the delete record if exist and judge the record whether playing now\n  {\n    RLock rlock(status_mutex_);\n    auto &status_records = status_.records();\n    if (status_records.find(record_id) == status_records.end()) {\n      return;\n    }\n    if (record_id == status_.current_record_id()) {\n      return;\n    }\n  }\n  {\n    WLock wlock(status_mutex_);\n    status_.mutable_records()->erase(record_id);\n    status_changed_ = true;\n  }\n\n  // delete record from disk\n  std::string command = \"rm -rf \" + record_path;\n  if (std::system(command.data()) != 0) {\n    AERROR << \"Failed to delete record for: \" << std::strerror(errno);\n    return;\n  }\n  return;\n}\nbool HMIWorker::ReloadVehicles() {\n  AINFO << \"load config\";\n  HMIConfig config = LoadConfig();\n  std::string msg;\n  AINFO << \"serialize new config\";\n  config.SerializeToString(&msg);\n\n  WLock wlock(status_mutex_);\n  AINFO << \"parse new config\";\n  config_.ParseFromString(msg);\n  AINFO << \"init status\";\n  // status_.clear_modes();\n  // status_.clear_maps();\n  AINFO << \"clear vehicles\";\n  status_.clear_vehicles();\n  // InitStatus();\n  // Populate vehicles and current_vehicle.\n  AINFO << \"reload vehicles\";\n  for (const auto &vehicle : config_.vehicles()) {\n    status_.add_vehicles(vehicle.first);\n  }\n  status_changed_ = true;\n  return true;\n}\n\nvoid HMIWorker::UpdateCameraSensorChannelToStatus(\n    const std::string &channel_name) {\n  {\n    WLock wlock(status_mutex_);\n    if (status_.current_camera_sensor_channel() == channel_name) {\n      AINFO << \"Input channel name is current camera sensor channel\";\n      return;\n    }\n    status_.set_current_camera_sensor_channel(channel_name);\n    status_changed_ = true;\n  }\n}\n\nvoid HMIWorker::UpdatePointCloudChannelToStatus(\n    const std::string &channel_name) {\n  {\n    WLock wlock(status_mutex_);\n    if (status_.current_point_cloud_channel() == channel_name) {\n      AINFO << \"Input channel name is current camera sensor channel\";\n      return;\n    }\n    status_.set_current_point_cloud_channel(channel_name);\n    status_changed_ = true;\n  }\n}",
        "lookback": "  {",
        "lookahead": "}  // namespace dreamview",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 772,
        "end_line": 2154,
        "merge_gen_region": null,
        "confidence": 0.6730679869651794,
        "hesitated": true
    }
]