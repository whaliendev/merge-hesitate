[
    {
        "a_contents": "bool SmokeObstacleDetector::Init(const StageConfig &stage_config) {\n  if (!Initialize(stage_config)) {\n    return false;\n  }\n\n  ACHECK(stage_config.has_camera_detector_config());\n  auto smoke_obstacle_detection_config_ =\n      stage_config.camera_detector_config();\n\n  gpu_id_ = smoke_obstacle_detection_config_.gpu_id();\n  BASE_CUDA_CHECK(cudaSetDevice(gpu_id_));\n  BASE_CUDA_CHECK(cudaStreamCreate(&stream_));\n\n  std::string camera_name =\n          smoke_obstacle_detection_config_.camera_name();\n  boost::algorithm::split(camera_names_, camera_name,\n                              boost::algorithm::is_any_of(\",\"));\n  base_camera_model_ =\n      common::SensorManager::Instance()->GetUndistortCameraModel(\n          camera_names_[0]);\n  ACHECK(base_camera_model_ != nullptr) << \"base_camera_model is nullptr!\";\n\n  std::string config_path =\n      GetAbsolutePath(smoke_obstacle_detection_config_.root_dir(),\n                      smoke_obstacle_detection_config_.conf_file());\n  if (!cyber::common::GetProtoFromFile(config_path, &smoke_param_)) {\n    AERROR << \"read proto_config fail\";\n    return false;\n  }\n  const auto &model_param = smoke_param_.model_param();\n  std::string model_root = GetAbsolutePath(\n      smoke_obstacle_detection_config_.root_dir(), model_param.model_name());\n  std::string anchors_file =\n      GetAbsolutePath(model_root, model_param.anchors_file());\n  std::string types_file =\n      GetAbsolutePath(model_root, model_param.types_file());\n  std::string expand_file =\n      GetAbsolutePath(model_root, model_param.expand_file());\n  LoadInputShape(model_param);\n  LoadParam(smoke_param_);\n  min_dims_.min_2d_height /= static_cast<float>(height_);\n\n  if (!LoadAnchors(anchors_file, &anchors_)) {\n    return false;\n  }\n  if (!LoadTypes(types_file, &types_)) {\n    return false;\n  }\n  if (!LoadExpand(expand_file, &expands_)) {\n    return false;\n  }\n  ACHECK(expands_.size() == types_.size());\n  if (!InitNet(smoke_param_, model_root)) {\n    return false;\n  }\n  InitSmokeBlob(smoke_param_.net_param());\n  if (!InitFeatureExtractor(model_root)) {\n    return false;\n  }\n  return true;\n}\n",
        "b_contents": "bool SmokeObstacleDetector::Init(const StageConfig &stage_config) {\n  if (!Initialize(stage_config)) {\n    return false;\n  }\n\n  ACHECK(stage_config.has_smoke_obstacle_detection_config());\n  smoke_obstacle_detection_config_ =\n      stage_config.smoke_obstacle_detection_config();\n\n  gpu_id_ = smoke_obstacle_detection_config_.gpu_id();\n  BASE_GPU_CHECK(cudaSetDevice(gpu_id_));\n  BASE_GPU_CHECK(cudaStreamCreate(&stream_));\n\n  base_camera_model_ =\n      common::SensorManager::Instance()->GetUndistortCameraModel(\n          smoke_obstacle_detection_config_.camera_name());\n  ACHECK(base_camera_model_ != nullptr) << \"base_camera_model is nullptr!\";\n\n  std::string config_path =\n      GetAbsolutePath(smoke_obstacle_detection_config_.root_dir(),\n                      smoke_obstacle_detection_config_.conf_file());\n  if (!cyber::common::GetProtoFromFile(config_path, &smoke_param_)) {\n    AERROR << \"read proto_config fail\";\n    return false;\n  }\n  const auto &model_param = smoke_param_.model_param();\n  std::string model_root = GetAbsolutePath(\n      smoke_obstacle_detection_config_.root_dir(), model_param.model_name());\n  std::string anchors_file =\n      GetAbsolutePath(model_root, model_param.anchors_file());\n  std::string types_file =\n      GetAbsolutePath(model_root, model_param.types_file());\n  std::string expand_file =\n      GetAbsolutePath(model_root, model_param.expand_file());\n  LoadInputShape(model_param);\n  LoadParam(smoke_param_);\n  min_dims_.min_2d_height /= static_cast<float>(height_);\n\n  if (!LoadAnchors(anchors_file, &anchors_)) {\n    return false;\n  }\n  if (!LoadTypes(types_file, &types_)) {\n    return false;\n  }\n  if (!LoadExpand(expand_file, &expands_)) {\n    return false;\n  }\n  ACHECK(expands_.size() == types_.size());\n  if (!InitNet(smoke_param_, model_root)) {\n    return false;\n  }\n  InitSmokeBlob(smoke_param_.net_param());\n  if (!InitFeatureExtractor(model_root)) {\n    return false;\n  }\n  return true;\n}\n",
        "base_contents": "",
        "res_region": "bool SmokeObstacleDetector::Init(const StageConfig &stage_config) {\n  if (!Initialize(stage_config)) {\n    return false;\n  }\n\n  ACHECK(stage_config.has_camera_detector_config());\n  auto smoke_obstacle_detection_config_ =\n      stage_config.camera_detector_config();\n\n  gpu_id_ = smoke_obstacle_detection_config_.gpu_id();\n  BASE_GPU_CHECK(cudaSetDevice(gpu_id_));\n  BASE_GPU_CHECK(cudaStreamCreate(&stream_));\n\n  std::string camera_name =\n          smoke_obstacle_detection_config_.camera_name();\n  boost::algorithm::split(camera_names_, camera_name,\n                              boost::algorithm::is_any_of(\",\"));\n  base_camera_model_ =\n      common::SensorManager::Instance()->GetUndistortCameraModel(\n          camera_names_[0]);\n  ACHECK(base_camera_model_ != nullptr) << \"base_camera_model is nullptr!\";\n\n  std::string config_path =\n      GetAbsolutePath(smoke_obstacle_detection_config_.root_dir(),\n                      smoke_obstacle_detection_config_.conf_file());\n  if (!cyber::common::GetProtoFromFile(config_path, &smoke_param_)) {\n    AERROR << \"read proto_config fail\";\n    return false;\n  }\n  const auto &model_param = smoke_param_.model_param();\n  std::string model_root = GetAbsolutePath(\n      smoke_obstacle_detection_config_.root_dir(), model_param.model_name());\n  std::string anchors_file =\n      GetAbsolutePath(model_root, model_param.anchors_file());\n  std::string types_file =\n      GetAbsolutePath(model_root, model_param.types_file());\n  std::string expand_file =\n      GetAbsolutePath(model_root, model_param.expand_file());\n  LoadInputShape(model_param);\n  LoadParam(smoke_param_);\n  min_dims_.min_2d_height /= static_cast<float>(height_);\n\n  if (!LoadAnchors(anchors_file, &anchors_)) {\n    return false;\n  }\n  if (!LoadTypes(types_file, &types_)) {\n    return false;\n  }\n  if (!LoadExpand(expand_file, &expands_)) {\n    return false;\n  }\n  ACHECK(expands_.size() == types_.size());\n  if (!InitNet(smoke_param_, model_root)) {\n    return false;\n  }\n  InitSmokeBlob(smoke_param_.net_param());\n  if (!InitFeatureExtractor(model_root)) {\n    return false;\n  }\n  return true;\n}\n",
        "lookback": "  if (!Initialize(stage_config)) {",
        "lookahead": "bool SmokeObstacleDetector::InitFeatureExtractor(const std::string &root_dir) {",
        "label": [
            "interleave",
            "one_side_deletion"
        ],
        "start_line": 196,
        "end_line": 319,
        "merge_gen_region": null,
        "confidence": 0.8798320293426514,
        "hesitated": true
    },
    {
        "a_contents": "                        light_vis_conf_threshold_, light_swt_conf_threshold_,\n                        overlapped_.get(), idx_sm_.get(),\n                        &(frame->detected_objects),\n                        frame->data_provider->src_width(),\n                        frame->data_provider->src_height() - offset_y_);",
        "b_contents": "                        light_vis_conf_threshold_, light_swt_conf_threshold_,\n                        overlapped_.get(), idx_sm_.get(),\n                        &(frame->detected_objects),\n                        frame->data_provider->src_width(),\n                        frame->data_provider->src_height() - offset_y_);\n\n  AINFO << \"GetObj: \" << static_cast<double>(timer.Toc()) * 0.001 << \"ms\";\n  filter_bbox(min_dims_, &(frame->detected_objects));\n  FeatureExtractorOptions feature_options;\n  feature_options.normalized = true;\n  AINFO << \"Post1: \" << static_cast<double>(timer.Toc()) * 0.001 << \"ms\";\n  feature_extractor_->Extract(feature_options, frame);\n  AINFO << \"Extract: \" << static_cast<double>(timer.Toc()) * 0.001 << \"ms\";\n  recover_smoke_bbox(frame->data_provider->src_width(),\n                     frame->data_provider->src_height() - offset_y_, offset_y_,\n                     &frame->detected_objects);\n\n  // post processing\n  int left_boundary =\n      static_cast<int>(border_ratio_ * static_cast<float>(image_->cols()));\n  int right_boundary = static_cast<int>((1.0f - border_ratio_) *\n                                        static_cast<float>(image_->cols()));\n  for (auto &obj : frame->detected_objects) {\n    // recover alpha\n    obj->camera_supplement.alpha /= ori_cycle_;\n    // get area_id from visible_ratios\n    if (smoke_param_.model_param().num_areas() == 0) {\n      obj->camera_supplement.area_id =\n          get_area_id(obj->camera_supplement.visible_ratios);\n    }\n    // clear cut off ratios\n    auto &box = obj->camera_supplement.box;\n    if (box.xmin >= left_boundary) {\n      obj->camera_supplement.cut_off_ratios[2] = 0;\n    }\n    if (box.xmax <= right_boundary) {\n      obj->camera_supplement.cut_off_ratios[3] = 0;\n    }\n  }\n  AINFO << \"Post2: \" << static_cast<double>(timer.Toc()) * 0.001 << \"ms\";\n\n  return true;\n}\n\nbool SmokeObstacleDetector::Process(DataFrame *data_frame) {\n  if (data_frame == nullptr) {\n    return false;\n  }\n  auto frame = data_frame->camera_frame;\n\n  Timer timer;\n  if (cudaSetDevice(gpu_id_) != cudaSuccess) {\n    AERROR << \"Failed to set device to \" << gpu_id_;\n    return false;\n  }\n  const auto &camera_k_matrix = frame->camera_k_matrix.inverse();\n  auto const &net_param = smoke_param_.net_param();\n  auto input_blob = inference_->get_blob(net_param.input_data_blob());\n  auto input_K_blob = inference_->get_blob(net_param.input_ratio_blob());\n  auto input_ratio_blob = inference_->get_blob(net_param.input_instric_blob());\n\n  float *ratio_data = input_ratio_blob->mutable_cpu_data();\n  float *K_data = input_K_blob->mutable_cpu_data();\n  for (size_t i = 0; i < 3; i++) {\n    size_t i3 = i * 3;\n    for (size_t j = 0; j < 3; j++) {\n      if (frame->data_provider->sensor_name() == \"front_12mm\") {\n        K_data[i3 + j] = camera_k_matrix(i, j) * 2.f;\n      } else {\n        K_data[i3 + j] = camera_k_matrix(i, j);\n      }\n    }\n  }\n  AINFO << \"Camera k matrix input to obstacle postprocessor: \\n\"\n        << K_data[0] << \", \" << K_data[1] << \", \" << K_data[2] << \"\\n\"\n        << K_data[3] << \", \" << K_data[4] << \", \" << K_data[5] << \"\\n\"\n        << K_data[6] << \", \" << K_data[7] << \", \" << K_data[8] << \"\\n\";\n  ratio_data[0] = 4.f * static_cast<float>(frame->data_provider->src_width()) /\n                  static_cast<float>(width_);\n  ratio_data[1] = 4.f * static_cast<float>(frame->data_provider->src_height()) /\n                  static_cast<float>(height_);\n\n  AINFO << \"Start: \" << static_cast<double>(timer.Toc()) * 0.001 << \"ms\";\n  DataProvider::ImageOptions image_options;\n  image_options.target_color = base::Color::BGR;\n  image_options.crop_roi = base::RectI(\n      0, offset_y_, static_cast<int>(base_camera_model_->get_width()),\n      static_cast<int>(base_camera_model_->get_height()) - offset_y_);\n  image_options.do_crop = true;\n  frame->data_provider->GetImage(image_options, image_.get());\n  AINFO << \"GetImageBlob: \" << static_cast<double>(timer.Toc()) * 0.001 << \"ms\";\n  inference::ResizeGPU(*image_, input_blob, frame->data_provider->src_width(),\n                       0);\n  AINFO << \"Resize: \" << static_cast<double>(timer.Toc()) * 0.001 << \"ms\";",
        "base_contents": "                  light_vis_conf_threshold_, light_swt_conf_threshold_,\n                  overlapped_.get(), idx_sm_.get(), &(frame->detected_objects),\n                  frame->data_provider->src_width(),\n                  frame->data_provider->src_height() - offset_y_);",
        "res_region": "                        light_vis_conf_threshold_, light_swt_conf_threshold_,\n                        overlapped_.get(), idx_sm_.get(),\n                        &(frame->detected_objects),\n                        frame->data_provider->src_width(),\n                        frame->data_provider->src_height() - offset_y_);\n\n  AINFO << \"GetObj: \" << static_cast<double>(timer.Toc()) * 0.001 << \"ms\";\n  filter_bbox(min_dims_, &(frame->detected_objects));\n  FeatureExtractorOptions feature_options;\n  feature_options.normalized = true;\n  AINFO << \"Post1: \" << static_cast<double>(timer.Toc()) * 0.001 << \"ms\";\n  feature_extractor_->Extract(feature_options, frame);\n  AINFO << \"Extract: \" << static_cast<double>(timer.Toc()) * 0.001 << \"ms\";\n  recover_smoke_bbox(frame->data_provider->src_width(),",
        "lookback": "                        overlapped_.get(), idx_sm_.get(),",
        "lookahead": "                     frame->data_provider->src_height() - offset_y_, offset_y_,",
        "label": [
            "interleave",
            "style_related"
        ],
        "start_line": 431,
        "end_line": 537,
        "merge_gen_region": null,
        "confidence": 0.6272260546684265,
        "hesitated": true
    },
    {
        "a_contents": "                     frame->data_provider->src_height() - offset_y_, offset_y_,\n                     &frame->detected_objects);\n\n  // post processing\n  int left_boundary =\n      static_cast<int>(border_ratio_ * static_cast<float>(image_->cols()));\n  int right_boundary = static_cast<int>((1.0f - border_ratio_) *\n                                        static_cast<float>(image_->cols()));\n  for (auto &obj : frame->detected_objects) {\n    // recover alpha\n    obj->camera_supplement.alpha /= ori_cycle_;\n    // get area_id from visible_ratios\n    if (smoke_param_.model_param().num_areas() == 0) {\n      obj->camera_supplement.area_id =\n          get_area_id(obj->camera_supplement.visible_ratios);\n    }\n    // clear cut off ratios\n    auto &box = obj->camera_supplement.box;\n    if (box.xmin >= left_boundary) {\n      obj->camera_supplement.cut_off_ratios[2] = 0;\n    }\n    if (box.xmax <= right_boundary) {\n      obj->camera_supplement.cut_off_ratios[3] = 0;\n    }\n  }\n  AINFO << \"Post2: \" << static_cast<double>(timer.Toc()) * 0.001 << \"ms\";\n\n  return true;\n}\n\nbool SmokeObstacleDetector::Process(DataFrame *data_frame) {\n  if (data_frame == nullptr) {\n    return false;\n  }\n  auto frame = data_frame->camera_frame;\n\n  Timer timer;\n  if (cudaSetDevice(gpu_id_) != cudaSuccess) {\n    AERROR << \"Failed to set device to \" << gpu_id_;\n    return false;\n  }\n  const auto &camera_k_matrix = frame->camera_k_matrix.inverse();\n  auto const &net_param = smoke_param_.net_param();\n  auto input_blob = inference_->get_blob(net_param.input_data_blob());\n  auto input_K_blob = inference_->get_blob(net_param.input_instric_blob());\n  auto input_ratio_blob = inference_->get_blob(net_param.input_ratio_blob());\n\n  input_K_blob->Reshape({1, 3, 3});\n  input_ratio_blob->Reshape({1, 2});\n\n  float *ratio_data = input_ratio_blob->mutable_cpu_data();\n  float *K_data = input_K_blob->mutable_cpu_data();\n  for (size_t i = 0; i < 3; i++) {\n    size_t i3 = i * 3;\n    for (size_t j = 0; j < 3; j++) {\n      if (frame->data_provider->sensor_name() == \"front_12mm\") {\n        K_data[i3 + j] = camera_k_matrix(i, j) * 2.f;\n      } else {\n        K_data[i3 + j] = camera_k_matrix(i, j);\n      }\n    }\n  }\n  AINFO << \"Camera k matrix input to obstacle postprocessor: \\n\"\n        << K_data[0] << \", \" << K_data[1] << \", \" << K_data[2] << \"\\n\"\n        << K_data[3] << \", \" << K_data[4] << \", \" << K_data[5] << \"\\n\"\n        << K_data[6] << \", \" << K_data[7] << \", \" << K_data[8] << \"\\n\";\n  ratio_data[0] = 4.f * static_cast<float>(frame->data_provider->src_width()) /\n                  static_cast<float>(width_);\n  ratio_data[1] = 4.f * static_cast<float>(frame->data_provider->src_height()) /\n                  static_cast<float>(height_);\n\n  AINFO << \"Start: \" << static_cast<double>(timer.Toc()) * 0.001 << \"ms\";\n  DataProvider::ImageOptions image_options;\n  image_options.target_color = base::Color::RGB;\n  image_options.crop_roi = base::RectI(\n      0, offset_y_, static_cast<int>(base_camera_model_->get_width()),\n      static_cast<int>(base_camera_model_->get_height()) - offset_y_);\n  image_options.do_crop = true;\n  frame->data_provider->GetImage(image_options, image_.get());\n  AINFO << \"GetImageBlob: \" << static_cast<double>(timer.Toc()) * 0.001 << \"ms\";\n\n  // todo(zero): need to modify to cuda code\n  Preprocessor(image_.get(), input_blob);\n\n  AINFO << \"Camera type: \" << frame->data_provider->sensor_name();\n\n  inference_->Infer();\n  AINFO << \"Network Forward: \" << static_cast<double>(timer.Toc()) * 0.001\n        << \"ms\";\n  get_smoke_objects_cpu(smoke_blobs_, types_, smoke_param_.model_param(),\n                        light_vis_conf_threshold_, light_swt_conf_threshold_,\n                        overlapped_.get(), idx_sm_.get(),\n                        &(frame->detected_objects),\n                        frame->data_provider->src_width(),\n                        frame->data_provider->src_height() - offset_y_);\n  AINFO << \"GetObj: \" << static_cast<double>(timer.Toc()) * 0.001 << \"ms\";\n  filter_bbox(min_dims_, &(frame->detected_objects));\n  FeatureExtractorOptions feature_options;\n  feature_options.normalized = true;\n  AINFO << \"Post1: \" << static_cast<double>(timer.Toc()) * 0.001 << \"ms\";\n  feature_extractor_->Extract(feature_options, frame);\n  AINFO << \"Extract: \" << static_cast<double>(timer.Toc()) * 0.001 << \"ms\";\n  recover_smoke_bbox(frame->data_provider->src_width(),\n                     frame->data_provider->src_height() - offset_y_, offset_y_,\n                     &frame->detected_objects);",
        "b_contents": "                     frame->data_provider->src_height() - offset_y_, offset_y_,\n                     &frame->detected_objects);",
        "base_contents": "               frame->data_provider->src_height() - offset_y_, offset_y_,\n               &frame->detected_objects);",
        "res_region": "                     frame->data_provider->src_height() - offset_y_, offset_y_,\n                     &frame->detected_objects);\n\n  // post processing\n  int left_boundary =\n      static_cast<int>(border_ratio_ * static_cast<float>(image_->cols()));\n  int right_boundary = static_cast<int>((1.0f - border_ratio_) *\n                                        static_cast<float>(image_->cols()));\n  for (auto &obj : frame->detected_objects) {\n    // recover alpha\n    obj->camera_supplement.alpha /= ori_cycle_;\n    // get area_id from visible_ratios\n    if (smoke_param_.model_param().num_areas() == 0) {\n      obj->camera_supplement.area_id =\n          get_area_id(obj->camera_supplement.visible_ratios);\n    }\n    // clear cut off ratios\n    auto &box = obj->camera_supplement.box;\n    if (box.xmin >= left_boundary) {\n      obj->camera_supplement.cut_off_ratios[2] = 0;\n    }\n    if (box.xmax <= right_boundary) {\n      obj->camera_supplement.cut_off_ratios[3] = 0;\n    }\n  }\n  AINFO << \"Post2: \" << static_cast<double>(timer.Toc()) * 0.001 << \"ms\";\n\n  return true;\n}\n\nbool SmokeObstacleDetector::Process(DataFrame *data_frame) {\n  if (data_frame == nullptr) {\n    return false;\n  }\n  auto frame = data_frame->camera_frame;\n\n  Timer timer;\n  if (cudaSetDevice(gpu_id_) != cudaSuccess) {\n    AERROR << \"Failed to set device to \" << gpu_id_;\n    return false;\n  }\n  const auto &camera_k_matrix = frame->camera_k_matrix.inverse();\n  auto const &net_param = smoke_param_.net_param();\n  auto input_blob = inference_->get_blob(net_param.input_data_blob());\n  auto input_K_blob = inference_->get_blob(net_param.input_instric_blob());\n  auto input_ratio_blob = inference_->get_blob(net_param.input_ratio_blob());\n\n  input_K_blob->Reshape({1, 3, 3});\n  input_ratio_blob->Reshape({1, 2});\n\n  float *ratio_data = input_ratio_blob->mutable_cpu_data();\n  float *K_data = input_K_blob->mutable_cpu_data();\n  for (size_t i = 0; i < 3; i++) {\n    size_t i3 = i * 3;\n    for (size_t j = 0; j < 3; j++) {\n      if (frame->data_provider->sensor_name() == \"front_12mm\") {\n        K_data[i3 + j] = camera_k_matrix(i, j) * 2.f;\n      } else {\n        K_data[i3 + j] = camera_k_matrix(i, j);\n      }\n    }\n  }\n  AINFO << \"Camera k matrix input to obstacle postprocessor: \\n\"\n        << K_data[0] << \", \" << K_data[1] << \", \" << K_data[2] << \"\\n\"\n        << K_data[3] << \", \" << K_data[4] << \", \" << K_data[5] << \"\\n\"\n        << K_data[6] << \", \" << K_data[7] << \", \" << K_data[8] << \"\\n\";\n  ratio_data[0] = 4.f * static_cast<float>(frame->data_provider->src_width()) /\n                  static_cast<float>(width_);\n  ratio_data[1] = 4.f * static_cast<float>(frame->data_provider->src_height()) /\n                  static_cast<float>(height_);\n\n  AINFO << \"Start: \" << static_cast<double>(timer.Toc()) * 0.001 << \"ms\";\n  DataProvider::ImageOptions image_options;\n  image_options.target_color = base::Color::RGB;\n  image_options.crop_roi = base::RectI(\n      0, offset_y_, static_cast<int>(base_camera_model_->get_width()),\n      static_cast<int>(base_camera_model_->get_height()) - offset_y_);\n  image_options.do_crop = true;\n  frame->data_provider->GetImage(image_options, image_.get());\n  AINFO << \"GetImageBlob: \" << static_cast<double>(timer.Toc()) * 0.001 << \"ms\";\n\n  // todo(zero): need to modify to cuda code\n  Preprocessor(image_.get(), input_blob);\n\n  AINFO << \"Camera type: \" << frame->data_provider->sensor_name();\n\n  inference_->Infer();\n  AINFO << \"Network Forward: \" << static_cast<double>(timer.Toc()) * 0.001\n        << \"ms\";\n  get_smoke_objects_cpu(smoke_blobs_, types_, smoke_param_.model_param(),\n                        light_vis_conf_threshold_, light_swt_conf_threshold_,\n                        overlapped_.get(), idx_sm_.get(),\n                        &(frame->detected_objects),\n                        frame->data_provider->src_width(),\n                        frame->data_provider->src_height() - offset_y_);\n  AINFO << \"GetObj: \" << static_cast<double>(timer.Toc()) * 0.001 << \"ms\";\n  filter_bbox(min_dims_, &(frame->detected_objects));\n  FeatureExtractorOptions feature_options;\n  feature_options.normalized = true;\n  AINFO << \"Post1: \" << static_cast<double>(timer.Toc()) * 0.001 << \"ms\";\n  feature_extractor_->Extract(feature_options, frame);\n  AINFO << \"Extract: \" << static_cast<double>(timer.Toc()) * 0.001 << \"ms\";\n  recover_smoke_bbox(frame->data_provider->src_width(),\n                     frame->data_provider->src_height() - offset_y_, offset_y_,\n                     &frame->detected_objects);",
        "lookback": "                     &frame->detected_objects);",
        "lookahead": "",
        "label": [
            "ours",
            "base_underutilized"
        ],
        "start_line": 558,
        "end_line": 670,
        "merge_gen_region": null,
        "confidence": 0.706649661064148,
        "hesitated": true
    }
]