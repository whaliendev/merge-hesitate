[
    {
        "a_contents": "/******************************************************************************\n * Copyright 2022 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *****************************************************************************/\n\n#include \"modules/perception/pipeline/pipeline.h\"\n\n#include \"cyber/time/clock.h\"\n#include \"modules/common/util/map_util.h\"\n#include \"modules/perception/camera/lib/obstacle/camera_detection_postprocessor/camera_detection_postprocessor.h\"\n#include \"modules/perception/camera/lib/obstacle/detector/bev_detection/bev_obstacle_detector.h\"\n#include \"modules/perception/camera/lib/obstacle/detector/caddn/caddn_obstacle_detector.h\"\n#include \"modules/perception/camera/lib/obstacle/detector/smoke/smoke_obstacle_detector.h\"\n#include \"modules/perception/camera/lib/obstacle/postprocessor/location_refiner/location_refiner_obstacle_postprocessor.h\"\n#include \"modules/perception/camera/lib/obstacle/preprocessor/camera_detection_preprocessor.h\"\n#include \"modules/perception/camera/lib/obstacle/tracker/omt/omt_obstacle_tracker.h\"\n#include \"modules/perception/camera/lib/obstacle/tracker/omt2/omt_bev_tracker.h\"\n#include \"modules/perception/camera/lib/obstacle/transformer/multicue/multicue_obstacle_transformer.h\"\n#include \"modules/perception/camera/lib/traffic_light/detector/detection/detection.h\"\n#include \"modules/perception/camera/lib/traffic_light/detector/recognition/recognition.h\"\n#include \"modules/perception/camera/lib/traffic_light/tracker/semantic_decision.h\"\n#include \"modules/perception/fusion/lib/data_fusion/all_latest_fusion/all_latest_fusion.h\"\n#include \"modules/perception/fusion/lib/fusion_system/probabilistic_fusion/probabilistic_fusion.h\"\n#include \"modules/perception/fusion/lib/gatekeeper/collect_fused_object.h\"\n#include \"modules/perception/lidar/lib/classifier/fused_classifier/fused_classifier.h\"\n#include \"modules/perception/lidar/lib/detector/center_point_detection/center_point_detection.h\"\n#include \"modules/perception/lidar/lib/detector/cnn_segmentation/cnn_segmentation.h\"\n#include \"modules/perception/lidar/lib/detector/mask_pillars_detection/mask_pillars_detection.h\"\n#include \"modules/perception/lidar/lib/detector/ncut_segmentation/ncut_segmentation.h\"\n#include \"modules/perception/lidar/lib/detector/point_pillars_detection/point_pillars_detection.h\"\n#include \"modules/perception/lidar/lib/map_manager/map_manager.h\"\n#include \"modules/perception/lidar/lib/object_builder/object_builder.h\"\n#include \"modules/perception/lidar/lib/object_filter_bank/object_filter_bank.h\"\n#include \"modules/perception/lidar/lib/pointcloud_detection_postprocessor/pointcloud_detection_postprocessor.h\"\n#include \"modules/perception/lidar/lib/pointcloud_detection_preprocessor/pointcloud_detection_preprocessor.h\"\n#include \"modules/perception/lidar/lib/pointcloud_preprocessor/pointcloud_preprocessor.h\"\n#include \"modules/perception/lidar/lib/tracker/multi_lidar_fusion/mlf_engine.h\"\n#include \"modules/perception/pipeline/plugin_factory.h\"\n\nnamespace apollo {\nnamespace perception {\nnamespace pipeline {\n\nbool Pipeline::Initialize(const PipelineConfig& pipeline_config) {\n  ACHECK(!pipeline_config.stage_type().empty());\n\n  Clear();\n\n  for (const auto& stage_config : pipeline_config.stage_config()) {\n    stage_config_map_[stage_config.stage_type()] = stage_config;\n  }\n\n  // Register Plugins, Must be initialized before 'CreateStage'!!!\n  PluginFactory::Init();\n\n  for (int i = 0; i < pipeline_config.stage_config_size(); ++i) {\n    auto stage_type = pipeline_config.stage_type(i);\n    if (!apollo::common::util::ContainsKey(stage_config_map_, stage_type)) {\n      AERROR << \"Stage type : \" << StageType_Name(stage_type)\n             << \" has no config\";\n      return false;\n    }\n\n    if (!CheckRepeatedStage(StageType_Name(stage_type))) {\n      std::shared_ptr<Stage> stage_ptr = CreateStage(stage_type);\n\n      if (stage_ptr == nullptr) {\n        AERROR << \"Create stage type : \" << StageType_Name(stage_type)\n               << \" failed!\";\n        return false;\n      }\n\n      AINFO << \"Create stage type : \" << StageType_Name(stage_type)\n            << \" success!\";\n      stage_ptrs_.push_back(std::move(stage_ptr));\n    }\n  }\n\n  name_ = PipelineType_Name(pipeline_config.pipeline_type());\n  pipeline_config_.CopyFrom(pipeline_config);\n\n  return true;\n}\n\nbool Pipeline::CheckRepeatedStage(const std::string& stage_name) {\n  bool res = false;\n  for (auto created_state_ptr : stage_ptrs_) {\n    if (StageType_Name(created_state_ptr->stage_config_.stage_type()) ==\n        stage_name) {\n      AINFO << stage_name << \" already created\";\n      stage_ptrs_.push_back(std::move(created_state_ptr));\n      res = true;\n      break;\n    }\n  }\n  return res;\n}\n\nbool Pipeline::InnerProcess(DataFrame* frame) {\n  for (const auto& stage_ptr : stage_ptrs_) {\n    if (stage_ptr->IsEnabled()) {\n      double start_time = apollo::cyber::Clock::NowInSeconds();\n      bool res = stage_ptr->Process(frame);\n      AINFO << \"Stage: \" << stage_ptr->Name()\n            << \" Cost: \" << apollo::cyber::Clock::NowInSeconds() - start_time;\n      if (!res) {\n        AERROR << \"Pipeline: \" << name_ << \" Stage : \" << stage_ptr->Name()\n               << \" failed!\";\n        return false;\n      }\n    } else {\n      AINFO << \"Pipeline: \" << name_ << \" Stage : \" << stage_ptr->Name()\n            << \" disabled!\";\n    }\n  }\n  return true;\n}\n\nstd::shared_ptr<Stage> Pipeline::CreateStage(const StageType& stage_type) {\n  std::shared_ptr<Stage> stage_ptr;\n  switch (stage_type) {\n    case StageType::POINTCLOUD_PREPROCESSOR:\n      stage_ptr.reset(new lidar::PointCloudPreprocessor());\n      break;\n    case StageType::POINTCLOUD_DETECTION_PREPROCESSOR:\n      stage_ptr.reset(new lidar::PointcloudDetectionPreprocessor());\n      break;\n    case StageType::POINTCLOUD_DETECTION_POSTPROCESSOR:\n      stage_ptr.reset(new lidar::PointcloudDetectionPostprocessor());\n      break;\n    case StageType::MAP_MANAGER:\n      stage_ptr.reset(new lidar::MapManager());\n      break;\n    case StageType::POINT_PILLARS_DETECTION:\n      stage_ptr.reset(new lidar::PointPillarsDetection());\n      break;\n    case StageType::CNN_SEGMENTATION:\n      stage_ptr.reset(new lidar::CNNSegmentation());\n      break;\n    case StageType::NCUT_SEGMENTATION:\n      stage_ptr.reset(new lidar::NCutSegmentation());\n      break;\n    case StageType::MASK_PILLARS_DETECTION:\n      stage_ptr.reset(new lidar::MaskPillarsDetection());\n      break;\n    case StageType::CENTER_POINT_DETECTION:\n      stage_ptr.reset(new lidar::CenterPointDetection());\n      break;\n    case StageType::OBJECT_BUILDER:\n      stage_ptr.reset(new lidar::ObjectBuilder());\n      break;\n    case StageType::OBJECT_FILTER_BANK:\n      stage_ptr.reset(new lidar::ObjectFilterBank());\n      break;\n    case StageType::MLF_ENGINE:\n      stage_ptr.reset(new lidar::MlfEngine());\n      break;\n    case StageType::FUSED_CLASSIFIER:\n      stage_ptr.reset(new lidar::FusedClassifier());\n      break;\n    case StageType::TRAFFIC_LIGHT_DETECTION:\n      stage_ptr.reset(new camera::TrafficLightDetection());\n      break;\n    case StageType::TRAFFIC_LIGHT_RECOGNITION:\n      stage_ptr.reset(new camera::TrafficLightRecognition());\n      break;\n    case StageType::SEMANTIC_REVISER:\n      stage_ptr.reset(new camera::SemanticReviser());\n      break;\n    case StageType::CAMERA_DETECTION_POSTPROCESSOR:\n      stage_ptr.reset(new camera::CameraDetectionPostprocessor());\n      break;\n    case StageType::SMOKE_OBSTACLE_DETECTION:\n      stage_ptr.reset(new camera::SmokeObstacleDetector());\n      break;\n    case StageType::CAMERA_DETECTION_PREPROCESSOR:\n      stage_ptr.reset(new camera::CameraDetectionPreprocessor());\n      break;\n    case StageType::OMT_OBSTACLE_TRACKER:\n      stage_ptr.reset(new camera::OMTObstacleTracker());\n      break;\n    case StageType::ALL_LATEST_FUSION:\n      stage_ptr.reset(new fusion::AllLatestFusion());\n      break;\n    case StageType::PROBABILISTIC_FUSION:\n      stage_ptr.reset(new fusion::ProbabilisticFusion());\n      break;\n    case StageType::COLLECT_FUSED_OBJECT:\n      stage_ptr.reset(new fusion::CollectFusedObject());\n      break;\n    case StageType::MULTI_CUE_OBSTACLE_TRANSFORMER:\n      stage_ptr.reset(new camera::MultiCueObstacleTransformer());\n      break;\n    case StageType::LOCATION_REFINER_OBSTACLE_POSTPROCESSOR:\n      stage_ptr.reset(new camera::LocationRefinerObstaclePostprocessor());\n      break;\n    case StageType::BEV_OBSTACLE_DETECTOR:\n      stage_ptr.reset(new camera::BEVObstacleDetector());\n      break;\n    case StageType::OMT_BEV_OBSTACLE_TRACKER:\n      stage_ptr.reset(new camera::OMTBEVTracker());\n      break;\n    case StageType::CADDN_DETECTION:\n      stage_ptr.reset(new camera::CaddnObstacleDetector());\n      break;\n    default:\n      return nullptr;\n  }\n\n  if (stage_ptr != nullptr) stage_ptr->Init(stage_config_map_[stage_type]);\n  return stage_ptr;\n}\n\nvoid Pipeline::Clear() {\n  stage_ptrs_.clear();\n  stage_config_map_.clear();\n}\n\n}  // namespace pipeline\n}  // namespace perception\n}  // namespace apollo",
        "b_contents": "/******************************************************************************\n * Copyright 2022 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *****************************************************************************/\n\n#include \"modules/perception/pipeline/pipeline.h\"\n\n#include \"cyber/time/clock.h\"\n#include \"modules/common/util/map_util.h\"\n#include \"modules/perception/camera/lib/obstacle/camera_detection_postprocessor/camera_detection_postprocessor.h\"\n#include \"modules/perception/camera/lib/obstacle/detector/smoke/smoke_obstacle_detector.h\"\n#include \"modules/perception/camera/lib/obstacle/postprocessor/location_refiner/location_refiner_obstacle_postprocessor.h\"\n#include \"modules/perception/camera/lib/obstacle/preprocessor/camera_detection_preprocessor.h\"\n#include \"modules/perception/camera/lib/obstacle/tracker/omt/omt_obstacle_tracker.h\"\n#include \"modules/perception/camera/lib/obstacle/transformer/multicue/multicue_obstacle_transformer.h\"\n#include \"modules/perception/camera/lib/traffic_light/detector/detection/detection.h\"\n#include \"modules/perception/camera/lib/traffic_light/detector/recognition/recognition.h\"\n#include \"modules/perception/camera/lib/traffic_light/tracker/semantic_decision.h\"\n#include \"modules/perception/fusion/lib/data_fusion/all_latest_fusion/all_latest_fusion.h\"\n#include \"modules/perception/fusion/lib/fusion_system/probabilistic_fusion/probabilistic_fusion.h\"\n#include \"modules/perception/fusion/lib/gatekeeper/collect_fused_object.h\"\n#include \"modules/perception/lidar/lib/classifier/fused_classifier/fused_classifier.h\"\n// #include \"modules/perception/lidar/lib/detector/center_point_detection/center_point_detection.h\"\n#include \"modules/perception/lidar/lib/detector/cnn_segmentation/cnn_segmentation.h\"\n#include \"modules/perception/lidar/lib/detector/mask_pillars_detection/mask_pillars_detection.h\"\n#include \"modules/perception/lidar/lib/detector/ncut_segmentation/ncut_segmentation.h\"\n#include \"modules/perception/lidar/lib/detector/point_pillars_detection/point_pillars_detection.h\"\n#include \"modules/perception/lidar/lib/map_manager/map_manager.h\"\n#include \"modules/perception/lidar/lib/object_builder/object_builder.h\"\n#include \"modules/perception/lidar/lib/object_filter_bank/object_filter_bank.h\"\n#include \"modules/perception/lidar/lib/pointcloud_detection_postprocessor/pointcloud_detection_postprocessor.h\"\n#include \"modules/perception/lidar/lib/pointcloud_detection_preprocessor/pointcloud_detection_preprocessor.h\"\n#include \"modules/perception/lidar/lib/pointcloud_preprocessor/pointcloud_preprocessor.h\"\n#include \"modules/perception/lidar/lib/tracker/multi_lidar_fusion/mlf_engine.h\"\n#include \"modules/perception/pipeline/plugin_factory.h\"\n\nnamespace apollo {\nnamespace perception {\nnamespace pipeline {\n\nbool Pipeline::Initialize(const PipelineConfig& pipeline_config) {\n  ACHECK(!pipeline_config.stage_type().empty());\n\n  Clear();\n\n  for (const auto& stage_config : pipeline_config.stage_config()) {\n    stage_config_map_[stage_config.stage_type()] = stage_config;\n  }\n\n  // Register Plugins, Must be initialized before 'CreateStage'!!!\n  PluginFactory::Init();\n\n  for (int i = 0; i < pipeline_config.stage_config_size(); ++i) {\n    auto stage_type = pipeline_config.stage_type(i);\n    if (!apollo::common::util::ContainsKey(stage_config_map_, stage_type)) {\n      AERROR << \"Stage type : \" << StageType_Name(stage_type)\n             << \" has no config\";\n      return false;\n    }\n\n    if (!CheckRepeatedStage(StageType_Name(stage_type))) {\n      std::shared_ptr<Stage> stage_ptr = CreateStage(stage_type);\n\n      if (stage_ptr == nullptr) {\n        AERROR << \"Create stage type : \" << StageType_Name(stage_type)\n               << \" failed!\";\n        return false;\n      }\n\n      AINFO << \"Create stage type : \" << StageType_Name(stage_type)\n            << \" success!\";\n      stage_ptrs_.push_back(std::move(stage_ptr));\n    }\n  }\n\n  name_ = PipelineType_Name(pipeline_config.pipeline_type());\n  pipeline_config_.CopyFrom(pipeline_config);\n\n  return true;\n}\n\nbool Pipeline::CheckRepeatedStage(const std::string& stage_name) {\n  bool res = false;\n  for (auto created_state_ptr : stage_ptrs_) {\n    if (StageType_Name(created_state_ptr->stage_config_.stage_type()) ==\n        stage_name) {\n      AERROR << stage_name << \" already created\";\n      stage_ptrs_.push_back(std::move(created_state_ptr));\n      res = true;\n      break;\n    }\n  }\n  return res;\n}\n\nbool Pipeline::InnerProcess(DataFrame* frame) {\n  for (const auto& stage_ptr : stage_ptrs_) {\n    if (stage_ptr->IsEnabled()) {\n      double start_time = apollo::cyber::Clock::NowInSeconds();\n      bool res = stage_ptr->Process(frame);\n      AINFO << \"Stage: \" << stage_ptr->Name()\n            << \" Cost: \" << apollo::cyber::Clock::NowInSeconds() - start_time;\n      if (!res) {\n        AERROR << \"Pipeline: \" << name_ << \" Stage : \" << stage_ptr->Name()\n               << \" failed!\";\n        return false;\n      }\n    } else {\n      AINFO << \"Pipeline: \" << name_ << \" Stage : \" << stage_ptr->Name()\n            << \" disabled!\";\n    }\n  }\n  return true;\n}\n\nstd::shared_ptr<Stage> Pipeline::CreateStage(const StageType& stage_type) {\n  std::shared_ptr<Stage> stage_ptr;\n  switch (stage_type) {\n    case StageType::POINTCLOUD_PREPROCESSOR:\n      stage_ptr.reset(new lidar::PointCloudPreprocessor());\n      break;\n    case StageType::POINTCLOUD_DETECTION_PREPROCESSOR:\n      stage_ptr.reset(new lidar::PointcloudDetectionPreprocessor());\n      break;\n    case StageType::POINTCLOUD_DETECTION_POSTPROCESSOR:\n      stage_ptr.reset(new lidar::PointcloudDetectionPostprocessor());\n      break;\n    case StageType::MAP_MANAGER:\n      stage_ptr.reset(new lidar::MapManager());\n      break;\n    case StageType::POINT_PILLARS_DETECTION:\n      stage_ptr.reset(new lidar::PointPillarsDetection());\n      break;\n    case StageType::CNN_SEGMENTATION:\n      stage_ptr.reset(new lidar::CNNSegmentation());\n      break;\n    case StageType::NCUT_SEGMENTATION:\n      stage_ptr.reset(new lidar::NCutSegmentation());\n      break;\n    case StageType::MASK_PILLARS_DETECTION:\n      stage_ptr.reset(new lidar::MaskPillarsDetection());\n      break;\n    // todo(zero): Compile Error\n    // case StageType::CENTER_POINT_DETECTION:\n    //   stage_ptr.reset(new lidar::CenterPointDetection());\n    //   break;\n    case StageType::OBJECT_BUILDER:\n      stage_ptr.reset(new lidar::ObjectBuilder());\n      break;\n    case StageType::OBJECT_FILTER_BANK:\n      stage_ptr.reset(new lidar::ObjectFilterBank());\n      break;\n    case StageType::MLF_ENGINE:\n      stage_ptr.reset(new lidar::MlfEngine());\n      break;\n    case StageType::FUSED_CLASSIFIER:\n      stage_ptr.reset(new lidar::FusedClassifier());\n      break;\n    case StageType::TRAFFIC_LIGHT_DETECTION:\n      stage_ptr.reset(new camera::TrafficLightDetection());\n      break;\n    case StageType::TRAFFIC_LIGHT_RECOGNITION:\n      stage_ptr.reset(new camera::TrafficLightRecognition());\n      break;\n    case StageType::SEMANTIC_REVISER:\n      stage_ptr.reset(new camera::SemanticReviser());\n      break;\n    case StageType::CAMERA_DETECTION_POSTPROCESSOR:\n      stage_ptr.reset(new camera::CameraDetectionPostprocessor());\n      break;\n    case StageType::SMOKE_OBSTACLE_DETECTION:\n      stage_ptr.reset(new camera::SmokeObstacleDetector());\n      break;\n    case StageType::CAMERA_DETECTION_PREPROCESSOR:\n      stage_ptr.reset(new camera::CameraDetectionPreprocessor());\n      break;\n    case StageType::OMT_OBSTACLE_TRACKER:\n      stage_ptr.reset(new camera::OMTObstacleTracker());\n      break;\n    case StageType::ALL_LATEST_FUSION:\n      stage_ptr.reset(new fusion::AllLatestFusion());\n      break;\n    case StageType::PROBABILISTIC_FUSION:\n      stage_ptr.reset(new fusion::ProbabilisticFusion());\n      break;\n    case StageType::COLLECT_FUSED_OBJECT:\n      stage_ptr.reset(new fusion::CollectFusedObject());\n      break;\n    case StageType::MULTI_CUE_OBSTACLE_TRANSFORMER:\n      stage_ptr.reset(new camera::MultiCueObstacleTransformer());\n      break;\n    case StageType::LOCATION_REFINER_OBSTACLE_POSTPROCESSOR:\n      stage_ptr.reset(new camera::LocationRefinerObstaclePostprocessor());\n      break;\n    default:\n      return nullptr;\n  }\n\n  if (stage_ptr != nullptr) stage_ptr->Init(stage_config_map_[stage_type]);\n\n  return stage_ptr;\n}\n\nvoid Pipeline::Clear() {\n  stage_ptrs_.clear();\n  stage_config_map_.clear();\n}\n\n}  // namespace pipeline\n}  // namespace perception\n}  // namespace apollo",
        "base_contents": "",
        "res_region": "/******************************************************************************\n * Copyright 2022 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *****************************************************************************/\n\n#include \"modules/perception/pipeline/pipeline.h\"\n\n#include \"cyber/time/clock.h\"\n#include \"modules/common/util/map_util.h\"\n#include \"modules/perception/camera/lib/obstacle/camera_detection_postprocessor/camera_detection_postprocessor.h\"\n#include \"modules/perception/camera/lib/obstacle/detector/bev_detection/bev_obstacle_detector.h\"\n#include \"modules/perception/camera/lib/obstacle/detector/caddn/caddn_obstacle_detector.h\"\n#include \"modules/perception/camera/lib/obstacle/detector/smoke/smoke_obstacle_detector.h\"\n#include \"modules/perception/camera/lib/obstacle/postprocessor/location_refiner/location_refiner_obstacle_postprocessor.h\"\n#include \"modules/perception/camera/lib/obstacle/preprocessor/camera_detection_preprocessor.h\"\n#include \"modules/perception/camera/lib/obstacle/tracker/omt/omt_obstacle_tracker.h\"\n#include \"modules/perception/camera/lib/obstacle/tracker/omt2/omt_bev_tracker.h\"\n#include \"modules/perception/camera/lib/obstacle/transformer/multicue/multicue_obstacle_transformer.h\"\n#include \"modules/perception/camera/lib/traffic_light/detector/detection/detection.h\"\n#include \"modules/perception/camera/lib/traffic_light/detector/recognition/recognition.h\"\n#include \"modules/perception/camera/lib/traffic_light/tracker/semantic_decision.h\"\n#include \"modules/perception/fusion/lib/data_fusion/all_latest_fusion/all_latest_fusion.h\"\n#include \"modules/perception/fusion/lib/fusion_system/probabilistic_fusion/probabilistic_fusion.h\"\n#include \"modules/perception/fusion/lib/gatekeeper/collect_fused_object.h\"\n#include \"modules/perception/lidar/lib/classifier/fused_classifier/fused_classifier.h\"\n#include \"modules/perception/lidar/lib/detector/center_point_detection/center_point_detection.h\"\n#include \"modules/perception/lidar/lib/detector/cnn_segmentation/cnn_segmentation.h\"\n#include \"modules/perception/lidar/lib/detector/mask_pillars_detection/mask_pillars_detection.h\"\n#include \"modules/perception/lidar/lib/detector/ncut_segmentation/ncut_segmentation.h\"\n#include \"modules/perception/lidar/lib/detector/point_pillars_detection/point_pillars_detection.h\"\n#include \"modules/perception/lidar/lib/map_manager/map_manager.h\"\n#include \"modules/perception/lidar/lib/object_builder/object_builder.h\"\n#include \"modules/perception/lidar/lib/object_filter_bank/object_filter_bank.h\"\n#include \"modules/perception/lidar/lib/pointcloud_detection_postprocessor/pointcloud_detection_postprocessor.h\"\n#include \"modules/perception/lidar/lib/pointcloud_detection_preprocessor/pointcloud_detection_preprocessor.h\"\n#include \"modules/perception/lidar/lib/pointcloud_preprocessor/pointcloud_preprocessor.h\"\n#include \"modules/perception/lidar/lib/tracker/multi_lidar_fusion/mlf_engine.h\"\n#include \"modules/perception/pipeline/plugin_factory.h\"\n\nnamespace apollo {\nnamespace perception {\nnamespace pipeline {\n\nbool Pipeline::Initialize(const PipelineConfig& pipeline_config) {\n  ACHECK(!pipeline_config.stage_type().empty());\n\n  Clear();\n\n  for (const auto& stage_config : pipeline_config.stage_config()) {\n    stage_config_map_[stage_config.stage_type()] = stage_config;\n  }\n\n  // Register Plugins, Must be initialized before 'CreateStage'!!!\n  PluginFactory::Init();\n\n  for (int i = 0; i < pipeline_config.stage_config_size(); ++i) {\n    auto stage_type = pipeline_config.stage_type(i);\n    if (!apollo::common::util::ContainsKey(stage_config_map_, stage_type)) {\n      AERROR << \"Stage type : \" << StageType_Name(stage_type)\n             << \" has no config\";\n      return false;\n    }\n\n    if (!CheckRepeatedStage(StageType_Name(stage_type))) {\n      std::shared_ptr<Stage> stage_ptr = CreateStage(stage_type);\n\n      if (stage_ptr == nullptr) {\n        AERROR << \"Create stage type : \" << StageType_Name(stage_type)\n               << \" failed!\";\n        return false;\n      }\n\n      AINFO << \"Create stage type : \" << StageType_Name(stage_type)\n            << \" success!\";\n      stage_ptrs_.push_back(std::move(stage_ptr));\n    }\n  }\n\n  name_ = PipelineType_Name(pipeline_config.pipeline_type());\n  pipeline_config_.CopyFrom(pipeline_config);\n\n  return true;\n}\n\nbool Pipeline::CheckRepeatedStage(const std::string& stage_name) {\n  bool res = false;\n  for (auto created_state_ptr : stage_ptrs_) {\n    if (StageType_Name(created_state_ptr->stage_config_.stage_type()) ==\n        stage_name) {\n      AINFO << stage_name << \" already created\";\n      stage_ptrs_.push_back(std::move(created_state_ptr));\n      res = true;\n      break;\n    }\n  }\n  return res;\n}\n\nbool Pipeline::InnerProcess(DataFrame* frame) {\n  for (const auto& stage_ptr : stage_ptrs_) {\n    if (stage_ptr->IsEnabled()) {\n      double start_time = apollo::cyber::Clock::NowInSeconds();\n      bool res = stage_ptr->Process(frame);\n      AINFO << \"Stage: \" << stage_ptr->Name()\n            << \" Cost: \" << apollo::cyber::Clock::NowInSeconds() - start_time;\n      if (!res) {\n        AERROR << \"Pipeline: \" << name_ << \" Stage : \" << stage_ptr->Name()\n               << \" failed!\";\n        return false;\n      }\n    } else {\n      AINFO << \"Pipeline: \" << name_ << \" Stage : \" << stage_ptr->Name()\n            << \" disabled!\";\n    }\n  }\n  return true;\n}\n\nstd::shared_ptr<Stage> Pipeline::CreateStage(const StageType& stage_type) {\n  std::shared_ptr<Stage> stage_ptr;\n  switch (stage_type) {\n    case StageType::POINTCLOUD_PREPROCESSOR:\n      stage_ptr.reset(new lidar::PointCloudPreprocessor());\n      break;\n    case StageType::POINTCLOUD_DETECTION_PREPROCESSOR:\n      stage_ptr.reset(new lidar::PointcloudDetectionPreprocessor());\n      break;\n    case StageType::POINTCLOUD_DETECTION_POSTPROCESSOR:\n      stage_ptr.reset(new lidar::PointcloudDetectionPostprocessor());\n      break;\n    case StageType::MAP_MANAGER:\n      stage_ptr.reset(new lidar::MapManager());\n      break;\n    case StageType::POINT_PILLARS_DETECTION:\n      stage_ptr.reset(new lidar::PointPillarsDetection());\n      break;\n    case StageType::CNN_SEGMENTATION:\n      stage_ptr.reset(new lidar::CNNSegmentation());\n      break;\n    case StageType::NCUT_SEGMENTATION:\n      stage_ptr.reset(new lidar::NCutSegmentation());\n      break;\n    case StageType::MASK_PILLARS_DETECTION:\n      stage_ptr.reset(new lidar::MaskPillarsDetection());\n      break;\n    case StageType::CENTER_POINT_DETECTION:\n      stage_ptr.reset(new lidar::CenterPointDetection());\n      break;\n    case StageType::OBJECT_BUILDER:\n      stage_ptr.reset(new lidar::ObjectBuilder());\n      break;\n    case StageType::OBJECT_FILTER_BANK:\n      stage_ptr.reset(new lidar::ObjectFilterBank());\n      break;\n    case StageType::MLF_ENGINE:\n      stage_ptr.reset(new lidar::MlfEngine());\n      break;\n    case StageType::FUSED_CLASSIFIER:\n      stage_ptr.reset(new lidar::FusedClassifier());\n      break;\n    case StageType::TRAFFIC_LIGHT_DETECTION:\n      stage_ptr.reset(new camera::TrafficLightDetection());\n      break;\n    case StageType::TRAFFIC_LIGHT_RECOGNITION:\n      stage_ptr.reset(new camera::TrafficLightRecognition());\n      break;\n    case StageType::SEMANTIC_REVISER:\n      stage_ptr.reset(new camera::SemanticReviser());\n      break;\n    case StageType::CAMERA_DETECTION_POSTPROCESSOR:\n      stage_ptr.reset(new camera::CameraDetectionPostprocessor());\n      break;\n    case StageType::SMOKE_OBSTACLE_DETECTION:\n      stage_ptr.reset(new camera::SmokeObstacleDetector());\n      break;\n    case StageType::CAMERA_DETECTION_PREPROCESSOR:\n      stage_ptr.reset(new camera::CameraDetectionPreprocessor());\n      break;\n    case StageType::OMT_OBSTACLE_TRACKER:\n      stage_ptr.reset(new camera::OMTObstacleTracker());\n      break;\n    case StageType::ALL_LATEST_FUSION:\n      stage_ptr.reset(new fusion::AllLatestFusion());\n      break;\n    case StageType::PROBABILISTIC_FUSION:\n      stage_ptr.reset(new fusion::ProbabilisticFusion());\n      break;\n    case StageType::COLLECT_FUSED_OBJECT:\n      stage_ptr.reset(new fusion::CollectFusedObject());\n      break;\n    case StageType::MULTI_CUE_OBSTACLE_TRANSFORMER:\n      stage_ptr.reset(new camera::MultiCueObstacleTransformer());\n      break;\n    case StageType::LOCATION_REFINER_OBSTACLE_POSTPROCESSOR:\n      stage_ptr.reset(new camera::LocationRefinerObstaclePostprocessor());\n      break;\n    case StageType::BEV_OBSTACLE_DETECTOR:\n      stage_ptr.reset(new camera::BEVObstacleDetector());\n      break;\n    case StageType::OMT_BEV_OBSTACLE_TRACKER:\n      stage_ptr.reset(new camera::OMTBEVTracker());\n      break;\n    case StageType::CADDN_DETECTION:\n      stage_ptr.reset(new camera::CaddnObstacleDetector());\n      break;\n    default:\n      return nullptr;\n  }\n\n  if (stage_ptr != nullptr) stage_ptr->Init(stage_config_map_[stage_type]);\n  return stage_ptr;\n}\n\nvoid Pipeline::Clear() {\n  stage_ptrs_.clear();\n  stage_config_map_.clear();\n}\n\n}  // namespace pipeline\n}  // namespace perception\n}  // namespace apollo",
        "lookback": " * Copyright 2022 The Apollo Authors. All Rights Reserved.",
        "lookahead": "",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 0,
        "end_line": 457,
        "merge_gen_region": null,
        "confidence": 0.8623223304748535,
        "hesitated": true
    }
]