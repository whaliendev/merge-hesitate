[
    {
        "a_contents": "bool CNNSegmentation::Init(const StageConfig& stage_config) {\n  if (!Initialize(stage_config)) {\n    return false;\n  }\n\n  cnnseg_config_ = stage_config.cnnseg_config();\n  AINFO << \"CNNSegmentation: \" << cnnseg_config_.DebugString();\n\n  if (!FLAGS_lidar_model_version.empty()) {\n    sensor_name_ = FLAGS_lidar_model_version;\n  } else {\n    sensor_name_ = cnnseg_config_.sensor_name();\n  }\n\n  // get cnnseg params\n  ACHECK(GetProtoFromFile(cnnseg_config_.param_file(), &cnnseg_param_))\n      << \"Failed to parse CNNSegParam config file.\"\n      << cnnseg_config_.param_file();\n  ACHECK(GetProtoFromFile(cnnseg_config_.engine_file(), &spp_engine_config_))\n      << \"Failed to parse SppEngine config file.\"\n      << cnnseg_config_.engine_file();\n\n  // init feature parameters\n  const FeatureParam& feature_param = cnnseg_param_.feature_param();\n  range_ = feature_param.point_cloud_range();\n  width_ = feature_param.width();\n  height_ = feature_param.height();\n  min_height_ = feature_param.min_height();\n  max_height_ = feature_param.max_height();\n\n  // init inference model\n  const NetworkParam& network_param = cnnseg_param_.network_param();\n  std::vector<std::string> output_names;\n  output_names.push_back(network_param.instance_pt_blob());\n  output_names.push_back(network_param.category_pt_blob());\n  output_names.push_back(network_param.confidence_pt_blob());\n  output_names.push_back(network_param.height_pt_blob());\n  output_names.push_back(network_param.heading_pt_blob());\n  output_names.push_back(network_param.class_pt_blob());\n  std::vector<std::string> input_names;\n  input_names.push_back(network_param.feature_blob());\n  inference_.reset(\n      inference::CreateInferenceByName(cnnseg_param_.model_type(),\n                                       cnnseg_config_.proto_file(),\n                                       cnnseg_config_.weight_file(),\n                                       output_names,\n                                       input_names));\n  CHECK_NOTNULL(inference_.get());\n\n  gpu_id_ = cnnseg_param_.has_gpu_id() ? cnnseg_param_.gpu_id() : -1;\n  BASE_CUDA_CHECK(cudaSetDevice(gpu_id_));\n  inference_->set_gpu_id(gpu_id_);  // inference sets CPU mode when -1\n\n  std::map<std::string, std::vector<int>> input_shapes;\n  auto& input_shape = input_shapes[network_param.feature_blob()];\n  input_shape = {1, 8, height_, width_};\n  if (!feature_param.use_intensity_feature()) {\n    input_shape[1] -= 2;\n  }\n  if (!feature_param.use_constant_feature()) {\n    input_shape[1] -= 2;\n  }\n  ACHECK(inference_->Init(input_shapes)) << \"Failed to init inference.\";\n\n  // init blobs\n  instance_pt_blob_ = inference_->get_blob(network_param.instance_pt_blob());\n  CHECK_NOTNULL(instance_pt_blob_.get());\n  category_pt_blob_ = inference_->get_blob(network_param.category_pt_blob());\n  CHECK_NOTNULL(category_pt_blob_.get());\n  confidence_pt_blob_ =\n      inference_->get_blob(network_param.confidence_pt_blob());\n  CHECK_NOTNULL(confidence_pt_blob_.get());\n  height_pt_blob_ = inference_->get_blob(network_param.height_pt_blob());\n  CHECK_NOTNULL(height_pt_blob_.get());\n  feature_blob_ = inference_->get_blob(network_param.feature_blob());\n  CHECK_NOTNULL(feature_blob_.get());\n  if (cnnseg_param_.do_classification()) {\n    classify_pt_blob_ = inference_->get_blob(network_param.class_pt_blob());\n    CHECK_NOTNULL(classify_pt_blob_.get());\n  }\n  if (cnnseg_param_.do_heading()) {\n    heading_pt_blob_ = inference_->get_blob(network_param.heading_pt_blob());\n    CHECK_NOTNULL(heading_pt_blob_.get());\n  }\n\n  // init feature generator\n  feature_generator_.reset(new FeatureGenerator);\n  ACHECK(feature_generator_->Init(feature_param, feature_blob_.get()))\n      << \"Failed to init feature generator.\";\n\n  point2grid_.reserve(kDefaultPointCloudSize);\n\n  // init cluster and background segmentation methods\n  ACHECK(InitClusterAndBackgroundSegmentation());\n\n  return true;\n}\n\nbool CNNSegmentation::Process(DataFrame* data_frame) {\n  if (data_frame == nullptr)\n    return false;\n\n  LidarFrame* lidar_frame = data_frame->lidar_frame;\n  if (lidar_frame == nullptr)\n    return false;\n\n  LidarDetectorOptions options;\n  bool res = Detect(options, lidar_frame);\n  return res;\n}\n",
        "b_contents": "bool CNNSegmentation::Init(const StageConfig& stage_config) {\n  if (!Initialize(stage_config)) {\n    return false;\n  }\n\n  cnnseg_config_ = stage_config.cnnseg_config();\n  AINFO << \"CNNSegmentation: \" << cnnseg_config_.DebugString();\n\n  if (!FLAGS_lidar_model_version.empty()) {\n    sensor_name_ = FLAGS_lidar_model_version;\n  } else {\n    sensor_name_ = cnnseg_config_.sensor_name();\n  }\n\n  // get cnnseg params\n  ACHECK(GetProtoFromFile(cnnseg_config_.param_file(), &cnnseg_param_))\n      << \"Failed to parse CNNSegParam config file.\" << cnnseg_config_.param_file();\n  ACHECK(GetProtoFromFile(cnnseg_config_.engine_file(), &spp_engine_config_))\n      << \"Failed to parse SppEngine config file.\" << cnnseg_config_.engine_file();\n\n  // init feature parameters\n  const FeatureParam& feature_param = cnnseg_param_.feature_param();\n  range_ = feature_param.point_cloud_range();\n  width_ = feature_param.width();\n  height_ = feature_param.height();\n  min_height_ = feature_param.min_height();\n  max_height_ = feature_param.max_height();\n\n  // init inference model\n  const NetworkParam& network_param = cnnseg_param_.network_param();\n  std::vector<std::string> output_names;\n  output_names.push_back(network_param.instance_pt_blob());\n  output_names.push_back(network_param.category_pt_blob());\n  output_names.push_back(network_param.confidence_pt_blob());\n  output_names.push_back(network_param.height_pt_blob());\n  output_names.push_back(network_param.heading_pt_blob());\n  output_names.push_back(network_param.class_pt_blob());\n  std::vector<std::string> input_names;\n  input_names.push_back(network_param.feature_blob());\n  inference_.reset(\n      inference::CreateInferenceByName(cnnseg_param_.model_type(),\n                                       cnnseg_config_.proto_file(),\n                                       cnnseg_config_.weight_file(),\n                                       output_names,\n                                       input_names));\n  CHECK_NOTNULL(inference_.get());\n\n  gpu_id_ = cnnseg_param_.has_gpu_id() ? cnnseg_param_.gpu_id() : -1;\n  BASE_GPU_CHECK(cudaSetDevice(gpu_id_));\n  inference_->set_gpu_id(gpu_id_);  // inference sets CPU mode when -1\n\n  std::map<std::string, std::vector<int>> input_shapes;\n  auto& input_shape = input_shapes[network_param.feature_blob()];\n  input_shape = {1, 8, height_, width_};\n  if (!feature_param.use_intensity_feature()) {\n    input_shape[1] -= 2;\n  }\n  if (!feature_param.use_constant_feature()) {\n    input_shape[1] -= 2;\n  }\n  ACHECK(inference_->Init(input_shapes)) << \"Failed to init inference.\";\n\n  // init blobs\n  instance_pt_blob_ = inference_->get_blob(network_param.instance_pt_blob());\n  CHECK_NOTNULL(instance_pt_blob_.get());\n  category_pt_blob_ = inference_->get_blob(network_param.category_pt_blob());\n  CHECK_NOTNULL(category_pt_blob_.get());\n  confidence_pt_blob_ =\n      inference_->get_blob(network_param.confidence_pt_blob());\n  CHECK_NOTNULL(confidence_pt_blob_.get());\n  height_pt_blob_ = inference_->get_blob(network_param.height_pt_blob());\n  CHECK_NOTNULL(height_pt_blob_.get());\n  feature_blob_ = inference_->get_blob(network_param.feature_blob());\n  CHECK_NOTNULL(feature_blob_.get());\n  if (cnnseg_param_.do_classification()) {\n    classify_pt_blob_ = inference_->get_blob(network_param.class_pt_blob());\n    CHECK_NOTNULL(classify_pt_blob_.get());\n  }\n  if (cnnseg_param_.do_heading()) {\n    heading_pt_blob_ = inference_->get_blob(network_param.heading_pt_blob());\n    CHECK_NOTNULL(heading_pt_blob_.get());\n  }\n\n  // init feature generator\n  feature_generator_.reset(new FeatureGenerator);\n  ACHECK(feature_generator_->Init(feature_param, feature_blob_.get()))\n      << \"Failed to init feature generator.\";\n\n  point2grid_.reserve(kDefaultPointCloudSize);\n\n  // init cluster and background segmentation methods\n  ACHECK(InitClusterAndBackgroundSegmentation());\n\n  return true;\n}\n\nbool CNNSegmentation::Process(DataFrame* data_frame) {\n  if (data_frame == nullptr)\n    return false;\n\n  LidarFrame* lidar_frame = data_frame->lidar_frame;\n  if (lidar_frame == nullptr)\n    return false;\n\n  LidarDetectorOptions options;\n  bool res = Detect(options, lidar_frame);\n  return res;\n}\n",
        "base_contents": "",
        "res_region": "bool CNNSegmentation::Init(const StageConfig& stage_config) {\n  if (!Initialize(stage_config)) {\n    return false;\n  }\n\n  cnnseg_config_ = stage_config.cnnseg_config();\n  AINFO << \"CNNSegmentation: \" << cnnseg_config_.DebugString();\n\n  if (!FLAGS_lidar_model_version.empty()) {\n    sensor_name_ = FLAGS_lidar_model_version;\n  } else {\n    sensor_name_ = cnnseg_config_.sensor_name();\n  }\n\n  // get cnnseg params\n  ACHECK(GetProtoFromFile(cnnseg_config_.param_file(), &cnnseg_param_))\n      << \"Failed to parse CNNSegParam config file.\"\n      << cnnseg_config_.param_file();\n  ACHECK(GetProtoFromFile(cnnseg_config_.engine_file(), &spp_engine_config_))\n      << \"Failed to parse SppEngine config file.\"\n      << cnnseg_config_.engine_file();\n\n  // init feature parameters\n  const FeatureParam& feature_param = cnnseg_param_.feature_param();\n  range_ = feature_param.point_cloud_range();\n  width_ = feature_param.width();\n  height_ = feature_param.height();\n  min_height_ = feature_param.min_height();\n  max_height_ = feature_param.max_height();\n\n  // init inference model\n  const NetworkParam& network_param = cnnseg_param_.network_param();\n  std::vector<std::string> output_names;\n  output_names.push_back(network_param.instance_pt_blob());\n  output_names.push_back(network_param.category_pt_blob());\n  output_names.push_back(network_param.confidence_pt_blob());\n  output_names.push_back(network_param.height_pt_blob());\n  output_names.push_back(network_param.heading_pt_blob());\n  output_names.push_back(network_param.class_pt_blob());\n  std::vector<std::string> input_names;\n  input_names.push_back(network_param.feature_blob());\n  inference_.reset(\n      inference::CreateInferenceByName(cnnseg_param_.model_type(),\n                                       cnnseg_config_.proto_file(),\n                                       cnnseg_config_.weight_file(),\n                                       output_names,\n                                       input_names));\n  CHECK_NOTNULL(inference_.get());\n\n  gpu_id_ = cnnseg_param_.has_gpu_id() ? cnnseg_param_.gpu_id() : -1;\n  BASE_GPU_CHECK(cudaSetDevice(gpu_id_));\n  inference_->set_gpu_id(gpu_id_);  // inference sets CPU mode when -1\n\n  std::map<std::string, std::vector<int>> input_shapes;\n  auto& input_shape = input_shapes[network_param.feature_blob()];\n  input_shape = {1, 8, height_, width_};\n  if (!feature_param.use_intensity_feature()) {\n    input_shape[1] -= 2;\n  }\n  if (!feature_param.use_constant_feature()) {\n    input_shape[1] -= 2;\n  }\n  ACHECK(inference_->Init(input_shapes)) << \"Failed to init inference.\";\n\n  // init blobs\n  instance_pt_blob_ = inference_->get_blob(network_param.instance_pt_blob());\n  CHECK_NOTNULL(instance_pt_blob_.get());\n  category_pt_blob_ = inference_->get_blob(network_param.category_pt_blob());\n  CHECK_NOTNULL(category_pt_blob_.get());\n  confidence_pt_blob_ =\n      inference_->get_blob(network_param.confidence_pt_blob());\n  CHECK_NOTNULL(confidence_pt_blob_.get());\n  height_pt_blob_ = inference_->get_blob(network_param.height_pt_blob());\n  CHECK_NOTNULL(height_pt_blob_.get());\n  feature_blob_ = inference_->get_blob(network_param.feature_blob());\n  CHECK_NOTNULL(feature_blob_.get());\n  if (cnnseg_param_.do_classification()) {\n    classify_pt_blob_ = inference_->get_blob(network_param.class_pt_blob());\n    CHECK_NOTNULL(classify_pt_blob_.get());\n  }\n  if (cnnseg_param_.do_heading()) {\n    heading_pt_blob_ = inference_->get_blob(network_param.heading_pt_blob());\n    CHECK_NOTNULL(heading_pt_blob_.get());\n  }\n\n  // init feature generator\n  feature_generator_.reset(new FeatureGenerator);\n  ACHECK(feature_generator_->Init(feature_param, feature_blob_.get()))\n      << \"Failed to init feature generator.\";\n\n  point2grid_.reserve(kDefaultPointCloudSize);\n\n  // init cluster and background segmentation methods\n  ACHECK(InitClusterAndBackgroundSegmentation());\n\n  return true;\n}\n\nbool CNNSegmentation::Process(DataFrame* data_frame) {\n  if (data_frame == nullptr)\n    return false;\n\n  LidarFrame* lidar_frame = data_frame->lidar_frame;\n  if (lidar_frame == nullptr)\n    return false;\n\n  LidarDetectorOptions options;\n  bool res = Detect(options, lidar_frame);\n  return res;\n}\n",
        "lookback": "  if (!Initialize(stage_config)) {",
        "lookahead": "bool CNNSegmentation::InitClusterAndBackgroundSegmentation() {",
        "label": [
            "base",
            "one_side_deletion"
        ],
        "start_line": 146,
        "end_line": 369,
        "merge_gen_region": " CNegationInitconstConfig stageconfig { (!( Stage&_) ifInitializestageconfig)) return; csegconfig =_.nn_();INFO \"NSment: <<nn__.DebugString ifFLAGSlid___.()) sensorname =_ FLAGSlid_modelversion } {___ FLAGSlid____; else sensorname =nn__.sensorname } // cseg A(Proto(nn__.__(),csegparam <<Failed parseNSeg config.\" csegconfigparamfile Acsegparam <<Failed parseNSParam file <<nn__._();CHECKGetFromFilecsegconfigenginefile &sppengineconfig_)) \" to SEngine file <<nn__.enginefile // feature constParam feature_ =nn__.__.__(); init parameters Feature&_ =nn__.__._paramnetworkparam stdvectorstdstring outputnames outputnamespushbacknetworkparaminstancept_());_.pushbacknetworkparamcategoryptblob outputnamespushbacknetworkparamcon___());_._(_.fidenceptblob outputnamespushbacknetworkparamheightptblob output_.pushbacknetworkparamheightptbloblog_.pushbacknetworkparamhead__());_.",
        "confidence": 0.8904249668121338,
        "hesitated": false,
        "resolved": false
    }
]