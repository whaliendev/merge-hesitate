[
    {
        "a_contents": "bool CenterPointDetection::Init(const StageConfig& stage_config) {\n  if (!Initialize(stage_config)) {\n    return false;\n  }\n\n  /*\n  num_point_feature\n  */\n  paddle::AnalysisConfig config;\n  config.EnableUseGpu(1000, FLAGS_gpu_id);\n  config.SetModel(FLAGS_center_point_model_file,\n                  FLAGS_center_point_params_file);\n  config.EnableMemoryOptim();\n  if (FLAGS_use_trt) {\n    paddle::AnalysisConfig::Precision precision;\n    if (FLAGS_trt_precision == 0) {\n      precision = paddle_infer::PrecisionType::kFloat32;\n    } else if (FLAGS_trt_precision == 1) {\n      precision = paddle_infer::PrecisionType::kHalf;\n    } else {\n      AERROR << \"Tensorrt type can only support 0 or 1, but recieved is\"\n             << FLAGS_trt_precision << \"\\n\";\n      return false;\n    }\n    config.EnableTensorRtEngine(1 << 30, 1, 3, precision, FLAGS_trt_use_static,\n                                false);\n    // todo: solve EnableTunedTensorRtDynamicShape\n    config.CollectShapeRangeInfo(FLAGS_dynamic_shape_file);\n    // config.EnableTunedTensorRtDynamicShape(FLAGS_dynamic_shape_file, true);\n\n    if (FLAGS_trt_use_static) {\n      config.SetOptimCacheDir(FLAGS_trt_static_dir);\n    }\n  }\n  config.SwitchIrOptim(true);\n\n  predictor_ = paddle_infer::CreatePredictor(config);\n  return true;\n}\n\nbool CenterPointDetection::Process(DataFrame* data_frame) {\n  if (data_frame == nullptr)\n    return false;\n\n  LidarFrame* lidar_frame = data_frame->lidar_frame;\n  if (lidar_frame == nullptr)\n    return false;\n\n  LidarDetectorOptions options;\n  bool res = Detect(options, lidar_frame);\n  return res;\n}\n",
        "b_contents": "bool CenterPointDetection::Init(const StageConfig& stage_config) {\n  if (!Initialize(stage_config)) {\n    return false;\n  }\n\n  /*\n  num_point_feature\n  */\n  paddle::AnalysisConfig config;\n  config.EnableUseGpu(1000, FLAGS_gpu_id);\n  config.SetModel(FLAGS_center_point_model_file,\n                  FLAGS_center_point_params_file);\n  if (FLAGS_use_trt) {\n    paddle::AnalysisConfig::Precision precision;\n    if (FLAGS_trt_precision == 0) {\n      precision = paddle_infer::PrecisionType::kFloat32;\n    } else if (FLAGS_trt_precision == 1) {\n      precision = paddle_infer::PrecisionType::kHalf;\n    } else {\n      AERROR << \"Tensorrt type can only support 0 or 1, but recieved is\"\n             << FLAGS_trt_precision << \"\\n\";\n      return false;\n    }\n    config.EnableTensorRtEngine(1 << 30, 1, 3, precision, FLAGS_trt_use_static,\n                                false);\n    // todo: solve EnableTunedTensorRtDynamicShape\n    config.CollectShapeRangeInfo(FLAGS_dynamic_shape_file);\n    // config.EnableTunedTensorRtDynamicShape(FLAGS_dynamic_shape_file, true);\n\n    if (FLAGS_trt_use_static) {\n      config.SetOptimCacheDir(FLAGS_trt_static_dir);\n    }\n  }\n  config.SwitchIrOptim(true);\n\n  predictor_ = paddle_infer::CreatePredictor(config);\n  return true;\n}\n\nbool CenterPointDetection::Process(DataFrame* data_frame) {\n  if (data_frame == nullptr)\n    return false;\n\n  LidarFrame* lidar_frame = data_frame->lidar_frame;\n  if (lidar_frame == nullptr)\n    return false;\n\n  LidarDetectorOptions options;\n  bool res = Detect(options, lidar_frame);\n  return res;\n}\n",
        "base_contents": "",
        "res_region": "bool CenterPointDetection::Init(const StageConfig& stage_config) {\n  if (!Initialize(stage_config)) {\n    return false;\n  }\n\n  /*\n  num_point_feature\n  */\n  paddle::AnalysisConfig config;\n  config.EnableUseGpu(1000, FLAGS_gpu_id);\n  config.SetModel(FLAGS_center_point_model_file,\n                  FLAGS_center_point_params_file);\n  config.EnableMemoryOptim();\n  if (FLAGS_use_trt) {\n    paddle::AnalysisConfig::Precision precision;\n    if (FLAGS_trt_precision == 0) {\n      precision = paddle_infer::PrecisionType::kFloat32;\n    } else if (FLAGS_trt_precision == 1) {\n      precision = paddle_infer::PrecisionType::kHalf;\n    } else {\n      AERROR << \"Tensorrt type can only support 0 or 1, but recieved is\"\n             << FLAGS_trt_precision << \"\\n\";\n      return false;\n    }\n    config.EnableTensorRtEngine(1 << 30, 1, 3, precision, FLAGS_trt_use_static,\n                                false);\n    // todo: solve EnableTunedTensorRtDynamicShape\n    config.CollectShapeRangeInfo(FLAGS_dynamic_shape_file);\n    // config.EnableTunedTensorRtDynamicShape(FLAGS_dynamic_shape_file, true);\n\n    if (FLAGS_trt_use_static) {\n      config.SetOptimCacheDir(FLAGS_trt_static_dir);\n    }\n  }\n  config.SwitchIrOptim(true);\n\n  predictor_ = paddle_infer::CreatePredictor(config);\n  return true;\n}\n\nbool CenterPointDetection::Process(DataFrame* data_frame) {\n  if (data_frame == nullptr)\n    return false;\n\n  LidarFrame* lidar_frame = data_frame->lidar_frame;\n  if (lidar_frame == nullptr)\n    return false;\n\n  LidarDetectorOptions options;\n  bool res = Detect(options, lidar_frame);\n  return res;\n}\n",
        "lookback": "  if (!Initialize(stage_config)) {",
        "lookahead": "bool CenterPointDetection::Detect(const LidarDetectorOptions &options,",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 94,
        "end_line": 202,
        "merge_gen_region": null,
        "confidence": 0.8219273686408997,
        "hesitated": true
    }
]