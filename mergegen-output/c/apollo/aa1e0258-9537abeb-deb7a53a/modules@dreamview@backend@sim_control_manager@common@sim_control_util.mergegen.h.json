[
    {
        "a_contents": "/******************************************************************************\n * Copyright 2018 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *****************************************************************************/\n#pragma once\n\n#include <math.h>\n#include <stdio.h>\n\n#include <iostream>\n#include <string>\n#include <vector>\n\n#include <google/protobuf/text_format.h>\n\n#include \"cyber/common/log.h\"\n#include \"cyber/cyber.h\"\n\nnamespace apollo {\nnamespace dreamview {\n\nclass SimControlUtil {\n public:\n  double interpolate_1d(const double& p1, const double& p2,\n                        const double& frac1);\n  double interpolated_find(const std::vector<double>& range_table,\n                           const std::vector<double>& val_table,\n                           double to_find);\n\n  static double sigmoid(const double value);\n  static double relu(const double value);\n  double normalize(const double value, const double mean, const double std);\n\n  template <class P>\n  bool load_binary_file(const std::string& filename, P* pb_out) {\n    std::fstream input(filename, std::ios::in | std::ios::binary);\n    return pb_out->ParseFromIstream(&input);\n  }\n\n  template <class P>\n  bool load_text_file(const std::string& filename, P* pb_out) {\n    std::fstream input(filename, std::ios::in);\n    std::string input_data((std::istreambuf_iterator<char>(input)),\n                           std::istreambuf_iterator<char>());\n\n    if (input_data.empty()) {\n      return false;\n    }\n\n    return google::protobuf::TextFormat::ParseFromString(input_data, pb_out);\n  }\n\n  template <class P>\n  bool load_file_to_proto(const std::string& filename, P* pb_out) {\n    if (ends_with(filename, \".bin\")) {\n      if (!load_binary_file(filename, pb_out) &&\n          !load_text_file(filename, pb_out)) {\n        return false;\n      }\n    } else {\n      if (!load_text_file(filename, pb_out) &&\n          !load_binary_file(filename, pb_out)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  bool ends_with(const std::string& original, const std::string& pattern) {\n    return original.length() >= pattern.length() &&\n           original.substr(original.length() - pattern.length()) == pattern;\n  }\n\n  // delta function\n  int delta_function(double value, double threshold) {\n    return static_cast<int>(value > threshold);\n  }\n\n  // calculate \\eta from rise time and peak time\n  double get_eta(double rise_time, double peak_time) {\n    if (peak_time <= 0.0) {\n      AFATAL << \"peak_time should be positive\";\n    }\n    return cos(M_PI - rise_time / (peak_time / M_PI));\n  }\n\n  // calculate \\tau_s (1/omega); only suitable for under-damped system (eta < 1)\n  double get_tau_s(double peak_time, double eta) {\n    if (eta > 1.0) {\n      AFATAL << \"not an underdamped system\";\n    }\n    return peak_time / sqrt(1 - eta * eta);\n  }\n};\n\n}  // namespace dreamview\n}  // namespace apollo",
        "b_contents": "/******************************************************************************\n * Copyright 2018 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *****************************************************************************/\n#pragma once\n\n#include <google/protobuf/text_format.h>\n#include <math.h>\n#include <stdio.h>\n#include <iostream>\n#include <string>\n#include <vector>\n\n#include \"cyber/common/log.h\"\n#include \"cyber/cyber.h\"\n\nnamespace apollo {\nnamespace dreamview {\n\nclass SimControlUtil {\n public:\n  double interpolate_1d(const double& p1, const double& p2,\n                        const double& frac1);\n  double interpolated_find(const std::vector<double>& range_table,\n                           const std::vector<double>& val_table,\n                           double to_find);\n\n  static double sigmoid(const double value);\n  static double relu(const double value);\n  double normalize(const double value, const double mean, const double std);\n\n  template <class P>\n  bool load_binary_file(const std::string& filename, P* pb_out) {\n    std::fstream input(filename, std::ios::in | std::ios::binary);\n    return pb_out->ParseFromIstream(&input);\n  }\n\n  template <class P>\n  bool load_text_file(const std::string& filename, P* pb_out) {\n    std::fstream input(filename, std::ios::in);\n    std::string input_data((std::istreambuf_iterator<char>(input)),\n                           std::istreambuf_iterator<char>());\n\n    if (input_data.empty()) {\n      return false;\n    }\n\n    return google::protobuf::TextFormat::ParseFromString(input_data, pb_out);\n  }\n\n  template <class P>\n  bool load_file_to_proto(const std::string& filename, P* pb_out) {\n    if (ends_with(filename, \".bin\")) {\n      if (!load_binary_file(filename, pb_out) &&\n          !load_text_file(filename, pb_out)) {\n        return false;\n      }\n    } else {\n      if (!load_text_file(filename, pb_out) &&\n          !load_binary_file(filename, pb_out)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  bool ends_with(const std::string& original, const std::string& pattern) {\n    return original.length() >= pattern.length() &&\n           original.substr(original.length() - pattern.length()) == pattern;\n  }\n\n  // delta function\n  int delta_function(double value, double threshold) {\n    return int(value > threshold);\n  }\n\n  // calculate \\eta from rise time and peak time\n  double get_eta(double rise_time, double peak_time) {\n    if (peak_time <= 0.0) {\n      AFATAL << \"peak_time should be positive\";\n    }\n    return cos(M_PI - rise_time / (peak_time / M_PI));\n  }\n\n  // calculate \\tau_s (1/omega); only suitable for under-damped system (eta < 1)\n  double get_tau_s(double peak_time, double eta) {\n    if (eta > 1.0) {\n      AFATAL << \"not an underdamped system\";\n    }\n    return peak_time / sqrt(1 - eta * eta);\n  }\n};\n\n}  // namespace dreamview\n}  // namespace apollo",
        "base_contents": "",
        "res_region": "/******************************************************************************\n * Copyright 2018 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *****************************************************************************/\n#pragma once\n\n#include <math.h>\n#include <stdio.h>\n\n#include <iostream>\n#include <string>\n#include <vector>\n\n#include <google/protobuf/text_format.h>\n\n#include \"cyber/common/log.h\"\n#include \"cyber/cyber.h\"\n\nnamespace apollo {\nnamespace dreamview {\n\nclass SimControlUtil {\n public:\n  double interpolate_1d(const double& p1, const double& p2,\n                        const double& frac1);\n  double interpolated_find(const std::vector<double>& range_table,\n                           const std::vector<double>& val_table,\n                           double to_find);\n\n  static double sigmoid(const double value);\n  static double relu(const double value);\n  double normalize(const double value, const double mean, const double std);\n\n  template <class P>\n  bool load_binary_file(const std::string& filename, P* pb_out) {\n    std::fstream input(filename, std::ios::in | std::ios::binary);\n    return pb_out->ParseFromIstream(&input);\n  }\n\n  template <class P>\n  bool load_text_file(const std::string& filename, P* pb_out) {\n    std::fstream input(filename, std::ios::in);\n    std::string input_data((std::istreambuf_iterator<char>(input)),\n                           std::istreambuf_iterator<char>());\n\n    if (input_data.empty()) {\n      return false;\n    }\n\n    return google::protobuf::TextFormat::ParseFromString(input_data, pb_out);\n  }\n\n  template <class P>\n  bool load_file_to_proto(const std::string& filename, P* pb_out) {\n    if (ends_with(filename, \".bin\")) {\n      if (!load_binary_file(filename, pb_out) &&\n          !load_text_file(filename, pb_out)) {\n        return false;\n      }\n    } else {\n      if (!load_text_file(filename, pb_out) &&\n          !load_binary_file(filename, pb_out)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  bool ends_with(const std::string& original, const std::string& pattern) {\n    return original.length() >= pattern.length() &&\n           original.substr(original.length() - pattern.length()) == pattern;\n  }\n\n  // delta function\n  int delta_function(double value, double threshold) {\n    return static_cast<int>(value > threshold);\n  }\n\n  // calculate \\eta from rise time and peak time\n  double get_eta(double rise_time, double peak_time) {\n    if (peak_time <= 0.0) {\n      AFATAL << \"peak_time should be positive\";\n    }\n    return cos(M_PI - rise_time / (peak_time / M_PI));\n  }\n\n  // calculate \\tau_s (1/omega); only suitable for under-damped system (eta < 1)\n  double get_tau_s(double peak_time, double eta) {\n    if (eta > 1.0) {\n      AFATAL << \"not an underdamped system\";\n    }\n    return peak_time / sqrt(1 - eta * eta);\n  }\n};\n\n}  // namespace dreamview\n}  // namespace apollo",
        "lookback": " * Copyright 2018 The Apollo Authors. All Rights Reserved.",
        "lookahead": "",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 0,
        "end_line": 219,
        "merge_gen_region": " Copyright Thepol Authors All Reserved/****************************************************************************** Copyright Thepol Authors All Reserved * Licensed the Apache, 20theLicense *\"); you not this except in with the. * may a of License * may a of License * *://../licensesLICENSE20 * Unless by law agreed in, * under License distributed anAS\" BASIS * WARRANTIES CONDITIONS ANY, either or. See License the for specific governing and limitations the License *****************************************************************************/pragma # onceincludemathh # <.>includestdioh>includeiostream # <>includestring # <>includevector # </protobuftextformath # \"cy///logh # \"bercycy.\" alo namespaceeam { SimUtil public doublepolate1( double p, double p, double frac); interatedfindconst::<<>& rangetable const::<>& valtable double_find static sigoidconst double); doubleu( double); normalizeconst double, double, double, double, double, double, double, double, double, double,);); < P loadbinaryfileconst::&,*_) stdfstream(,:::: |::::); pboutParseI(&input } <class> loadtextfileconst::&,* pbout {:: inputfilename",
        "confidence": 0.9433387517929077,
        "hesitated": false,
        "resolved": false
    }
]