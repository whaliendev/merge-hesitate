[
    {
        "a_contents": "/******************************************************************************\n * Copyright 2018 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *****************************************************************************/\n#include \"modules/dreamview/backend/sim_control_manager/core/dynamic_model_factory.h\"\n\n#include \"modules/dreamview/backend/sim_control_manager/proto/dynamic_model_conf.pb.h\"\n\n#include \"cyber/class_loader/shared_library/exceptions.h\"\n#include \"cyber/class_loader/shared_library/shared_library.h\"\n#include \"modules/common/util/util.h\"\n#include \"modules/dreamview/backend/common/dreamview_gflags.h\"\n#include \"modules/dreamview/backend/map/map_service.h\"\n#include \"modules/dreamview/backend/sim_control_manager/dynamic_model/perfect_control/sim_perfect_control.h\"\n\nnamespace apollo {\nnamespace dreamview {\n\nusing apollo::cyber::class_loader::LibraryAlreadyLoadedException;\nusing apollo::cyber::class_loader::LibraryLoadException;\nusing apollo::cyber::class_loader::SharedLibrary;\nusing apollo::cyber::class_loader::SymbolNotFoundException;\nusing ::std::string;\nusing ::std::unordered_map;\nusing SharedLibraryPtr = std::shared_ptr<SharedLibrary>;\n\nstruct DynamicModelInfo {\n  std::string dynamic_model_name;\n  std::string library_name;\n  SimControlBase *dynamic_model_ptr;\n};\nunordered_map<string, DynamicModelInfo> s_dynamic_model_map_;\nunordered_map<string, int> s_dm_lib_count_;\n\nDynamicModelFactory::DynamicModelFactory() : dynamic_model_local_path_(\"\") {\n  home_path_ = cyber::common::GetEnv(\"HOME\");\n  dynamic_model_local_path_ = home_path_ + FLAGS_resource_dynamic_model_path;\n  // init should register default sim control:SimPerfectControl\n  RegisterSimPerfectControl();\n}\n\nDynamicModelFactory::~DynamicModelFactory() {\n  for (auto iter = s_dynamic_model_map_.begin();\n       iter != s_dynamic_model_map_.end(); iter++) {\n    delete iter->second.dynamic_model_ptr;\n    iter->second.dynamic_model_ptr = nullptr;\n  }\n}\n\nvoid DynamicModelFactory::RegisterSimPerfectControl() {\n  // map_service\u5f53\u53c2\u6570\n  if (s_dynamic_model_map_.find(FLAGS_sim_perfect_control) ==\n      s_dynamic_model_map_.end()) {\n    // Avoid dumplicate register dynamic model which is already registered\n    s_dynamic_model_map_[FLAGS_sim_perfect_control] = {};\n    s_dynamic_model_map_[FLAGS_sim_perfect_control].dynamic_model_name =\n        FLAGS_sim_perfect_control;\n    s_dynamic_model_map_[FLAGS_sim_perfect_control].dynamic_model_ptr =\n        new SimPerfectControl(new MapService());\n  }\n}\n\nbool DynamicModelFactory::RegisterDynamicModel(const std::string &dm_dir_name) {\n  std::string dynamic_model_conf_json_path;\n  GetDynamicModelPath(dm_dir_name, &dynamic_model_conf_json_path, true);\n  if (!cyber::common::PathExists(dynamic_model_conf_json_path)) {\n    AERROR << \"Failed to load Dynamic Model: \" << dm_dir_name\n           << \". conf file is not exists!\";\n    return false;\n  }\n  DynamicModelConf dynamic_model_conf;\n  if (!cyber::common::GetProtoFromJsonFile(dynamic_model_conf_json_path,\n                                           &dynamic_model_conf)) {\n    AERROR << \"Unable to parse Dynamic model conf from file \"\n           << dynamic_model_conf_json_path;\n    return false;\n  }\n  std::string dynamic_model_name = dynamic_model_conf.dynamic_model_name();\n  // get library name to load dm class\n  if (!dynamic_model_conf.has_library_name() ||\n      !dynamic_model_conf.has_dynamic_model_name()) {\n    AERROR << \"Missing required field!\";\n    return false;\n  }\n  // if is already registered\n  auto iter = s_dynamic_model_map_.find(dynamic_model_name);\n  if (iter != s_dynamic_model_map_.end()) {\n    AERROR << \"This dynamic model:  \" << dynamic_model_name\n           << \" is already registered!\";\n    return false;\n  }\n  std::string dm_library_name = dynamic_model_conf.library_name();\n  std::string dynamic_model_library_path =\n      home_path_ + FLAGS_dynamic_model_library_path + dm_library_name;\n  SharedLibraryPtr shared_library = nullptr;\n  try {\n    // todo(@lijin):when to unload\n    shared_library =\n        SharedLibraryPtr(new SharedLibrary(dynamic_model_library_path));\n    create_t *create_dynamic_model =\n        reinterpret_cast<create_t *>(shared_library->GetSymbol(\"create\"));\n    SimControlBase *dynamic_model_ptr =\n        create_dynamic_model(dm_dir_name, home_path_);\n    if (!dynamic_model_ptr) {\n      return false;\n    }\n    s_dynamic_model_map_[dynamic_model_name] = {};\n    s_dynamic_model_map_[dynamic_model_name].dynamic_model_name =\n        dynamic_model_name;\n    s_dynamic_model_map_[dynamic_model_name].dynamic_model_ptr =\n        dynamic_model_ptr;\n    s_dynamic_model_map_[dynamic_model_name].library_name = dm_library_name;\n    auto iter = s_dm_lib_count_.find(dm_library_name);\n    if (iter == s_dm_lib_count_.end()) {\n      s_dm_lib_count_[dm_library_name] = 1;\n    } else {\n      s_dm_lib_count_[dm_library_name]++;\n    }\n  } catch (const LibraryLoadException &e) {\n    AERROR << \"LibraryLoadException: \" << e.what();\n    return false;\n  } catch (const LibraryAlreadyLoadedException &e) {\n    AERROR << \"LibraryAlreadyLoadedException: \" << e.what();\n    return false;\n  } catch (const SymbolNotFoundException &e) {\n    AERROR << \"SymbolNotFoundException: \" << e.what();\n    return false;\n  }\n  return true;\n}\n\nvoid DynamicModelFactory::GetDynamicModelPath(\n    const std::string &dynamic_model_name, std::string *path,\n    bool get_conf_json) {\n  CHECK_NOTNULL(path);\n  *path = dynamic_model_local_path_ + dynamic_model_name;\n  if (get_conf_json) {\n    *path = *path + \"/dynamic_model.json\";\n  }\n  return;\n}\n\nnlohmann::json DynamicModelFactory::RegisterDynamicModels() {\n  nlohmann::json result = {};\n  result[\"result\"] = true;\n  result[\"loaded_dynamic_models\"] = {};\n  if (!cyber::common::PathExists(dynamic_model_local_path_)) {\n    AERROR << \"Failed to find DynamicModel!No dynamic model locally,Or do not \"\n              \"place it in correct location.\";\n  } else {\n    DIR *directory = opendir(dynamic_model_local_path_.c_str());\n    if (directory == nullptr) {\n      AERROR << \"Cannot open directory \" << dynamic_model_local_path_;\n    } else {\n      struct dirent *file;\n      std::string dynamic_model_dir_name;\n      std::string dynamic_model_library_path;\n      while ((file = readdir(directory)) != nullptr) {\n        // skip directory_path/. and directory_path/..\n        if (!strcmp(file->d_name, \".\") || !strcmp(file->d_name, \"..\")) {\n          continue;\n        }\n        if (file->d_type != DT_DIR) {\n          continue;\n        }\n        dynamic_model_dir_name = file->d_name;\n        // avpid dumplicate register dynamic model\n        RegisterDynamicModel(dynamic_model_dir_name);\n      }\n      closedir(directory);\n    }\n  }\n\n  // c++ map's traversal order is different from the insertion order.\n  // To ensure that the default sim control is in the front,put it before other\n  // dynamic models.\n  result[\"loaded_dynamic_models\"] = {FLAGS_sim_perfect_control};\n  for (auto iter = s_dynamic_model_map_.begin();\n       iter != s_dynamic_model_map_.end(); iter++) {\n    if (iter->first != FLAGS_sim_perfect_control) {\n      result[\"loaded_dynamic_models\"].push_back(iter->first);\n    }\n  }\n  return result;\n}\n\nSimControlBase *DynamicModelFactory::GetModelType(\n    std::string dynamic_model_name) {\n  auto iter = s_dynamic_model_map_.find(dynamic_model_name);\n  if (iter == s_dynamic_model_map_.end()) {\n    AERROR << \"Failed to get \" << dynamic_model_name << \" related pointer.\";\n    return nullptr;\n  }\n  return iter->second.dynamic_model_ptr;\n}\n\nbool DynamicModelFactory::UnregisterDynamicModel(\n    const std::string &dynamic_model_name) {\n  auto iter = s_dynamic_model_map_.find(dynamic_model_name);\n  if (iter == s_dynamic_model_map_.end()) {\n    AERROR << \"Failed to get \" << dynamic_model_name << \" related pointer.\";\n    return true;\n  }\n  std::string library_name = iter->second.library_name;\n  s_dynamic_model_map_.erase(dynamic_model_name);\n  std::string dynamic_model_dir;\n  GetDynamicModelPath(dynamic_model_name, &dynamic_model_dir, false);\n  std::string command = \"rm -fr \" + dynamic_model_dir;\n  // use cyber::common::removeFiles do not support sub-directory\n  // use rmdir do not support not empty directory\n  if (std::system(command.data()) != 0) {\n    AERROR << \"Failed to delete dynamic model directory for: \"\n           << std::strerror(errno);\n    return false;\n  }\n  // delete related library if library is only used by this dynamic model\n  auto count_iter = s_dm_lib_count_.find(library_name);\n  if (count_iter->second == 1) {\n    std::string lib_path =\n        home_path_ + FLAGS_dynamic_model_library_path + library_name;\n    cyber::common::DeleteFile(lib_path);\n    s_dm_lib_count_.erase(library_name);\n  } else {\n    s_dm_lib_count_[library_name]--;\n  }\n  return true;\n}\n\n}  // namespace dreamview\n}  // namespace apollo",
        "b_contents": "/******************************************************************************\n * Copyright 2018 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *****************************************************************************/\n#include \"modules/dreamview/backend/sim_control_manager/core/dynamic_model_factory.h\"\n\n#include \"modules/dreamview/backend/sim_control_manager/proto/dynamic_model_conf.pb.h\"\n\n#include \"cyber/class_loader/shared_library/exceptions.h\"\n#include \"cyber/class_loader/shared_library/shared_library.h\"\n#include \"modules/common/util/util.h\"\n#include \"modules/dreamview/backend/common/dreamview_gflags.h\"\n#include \"modules/dreamview/backend/map/map_service.h\"\n#include \"modules/dreamview/backend/sim_control_manager/dynamic_model/perfect_control/sim_perfect_control.h\"\n\nnamespace apollo {\nnamespace dreamview {\n\nusing apollo::cyber::class_loader::LibraryAlreadyLoadedException;\nusing apollo::cyber::class_loader::LibraryLoadException;\nusing apollo::cyber::class_loader::SharedLibrary;\nusing apollo::cyber::class_loader::SymbolNotFoundException;\nusing ::std::string;\nusing ::std::unordered_map;\nusing SharedLibraryPtr = std::shared_ptr<SharedLibrary>;\n\nstruct DynamicModelInfo {\n  std::string dynamic_model_name;\n  std::string library_name;\n  SimControlBase *dynamic_model_ptr;\n};\nunordered_map<string, DynamicModelInfo> s_dynamic_model_map_;\nunordered_map<string, int> s_dm_lib_count_;\n\nDynamicModelFactory::DynamicModelFactory() : dynamic_model_local_path_(\"\") {\n  home_path_ = cyber::common::GetEnv(\"HOME\");\n  dynamic_model_local_path_ = home_path_ + FLAGS_resource_dynamic_model_path;\n  // init should register default sim control:SimPerfectControl\n  RegisterSimPerfectControl();\n}\n\nDynamicModelFactory::~DynamicModelFactory() {\n  for (auto iter = s_dynamic_model_map_.begin();\n       iter != s_dynamic_model_map_.end(); iter++) {\n    delete iter->second.dynamic_model_ptr;\n    iter->second.dynamic_model_ptr = nullptr;\n  }\n}\n\nvoid DynamicModelFactory::RegisterSimPerfectControl() {\n  // map_service\u5f53\u53c2\u6570\n  if (s_dynamic_model_map_.find(FLAGS_sim_perfect_control) ==\n      s_dynamic_model_map_.end()) {\n    // Avoid dumplicate register dynamic model which is already registered\n    s_dynamic_model_map_[FLAGS_sim_perfect_control] = {};\n    s_dynamic_model_map_[FLAGS_sim_perfect_control].dynamic_model_name =\n        FLAGS_sim_perfect_control;\n    s_dynamic_model_map_[FLAGS_sim_perfect_control].dynamic_model_ptr =\n        new SimPerfectControl(new MapService());\n  }\n}\n\nbool DynamicModelFactory::RegisterDynamicModel(std::string &dm_dir_name) {\n  std::string dynamic_model_conf_json_path;\n  GetDynamicModelPath(dm_dir_name, dynamic_model_conf_json_path, true);\n  if (!cyber::common::PathExists(dynamic_model_conf_json_path)) {\n    AERROR << \"Failed to load Dynamic Model: \" << dm_dir_name\n           << \". conf file is not exists!\";\n    return false;\n  }\n  DynamicModelConf dynamic_model_conf;\n  if (!cyber::common::GetProtoFromJsonFile(dynamic_model_conf_json_path,\n                                           &dynamic_model_conf)) {\n    AERROR << \"Unable to parse Dynamic model conf from file \"\n           << dynamic_model_conf_json_path;\n    return false;\n  }\n  std::string dynamic_model_name = dynamic_model_conf.dynamic_model_name();\n  // get library name to load dm class\n  if (!dynamic_model_conf.has_library_name() ||\n      !dynamic_model_conf.has_dynamic_model_name()) {\n    AERROR << \"Missing required field!\";\n    return false;\n  }\n  // if is already registered\n  auto iter = s_dynamic_model_map_.find(dynamic_model_name);\n  if (iter != s_dynamic_model_map_.end()) {\n    AINFO<<\"This dynamic model:  \"<< dynamic_model_name<<\" is already registered!\";\n    return false;\n  }\n  std::string dm_library_name = dynamic_model_conf.library_name();\n  std::string dynamic_model_library_path =\n      home_path_ + FLAGS_dynamic_model_library_path + dm_library_name;\n  SharedLibraryPtr shared_library = nullptr;\n  try {\n    // todo(@lijin):when to unload\n    shared_library =\n        SharedLibraryPtr(new SharedLibrary(dynamic_model_library_path));\n    create_t *create_dynamic_model =\n        (create_t *)shared_library->GetSymbol(\"create\");\n    SimControlBase *dynamic_model_ptr =\n        create_dynamic_model(dm_dir_name, home_path_);\n    if (!dynamic_model_ptr) {\n      return false;\n    }\n    s_dynamic_model_map_[dynamic_model_name] = {};\n    s_dynamic_model_map_[dynamic_model_name].dynamic_model_name = dynamic_model_name;\n    s_dynamic_model_map_[dynamic_model_name].dynamic_model_ptr = dynamic_model_ptr;\n    s_dynamic_model_map_[dynamic_model_name].library_name = dm_library_name;\n    auto iter = s_dm_lib_count_.find(dm_library_name);\n    if (iter == s_dm_lib_count_.end()) {\n      s_dm_lib_count_[dm_library_name] = 1;\n    } else {\n      s_dm_lib_count_[dm_library_name]++;\n    }\n  } catch (const LibraryLoadException &e) {\n    AERROR << \"LibraryLoadException: \" << e.what();\n    return false;\n  } catch (const LibraryAlreadyLoadedException &e) {\n    AERROR << \"LibraryAlreadyLoadedException: \" << e.what();\n    return false;\n  } catch (const SymbolNotFoundException &e) {\n    AERROR << \"SymbolNotFoundException: \" << e.what();\n    return false;\n  }\n  return true;\n}\n\nvoid DynamicModelFactory::GetDynamicModelPath(std::string &dynamic_model_name,\n                                              std::string &path,\n                                              bool get_conf_json) {\n  path = dynamic_model_local_path_ + dynamic_model_name;\n  if (get_conf_json) {\n    path = path + \"/dynamic_model.json\";\n  }\n  return;\n}\n\nnlohmann::json DynamicModelFactory::RegisterDynamicModels() {\n  nlohmann::json result = {};\n  result[\"result\"] = true;\n  result[\"loaded_dynamic_models\"] = {};\n  if (!cyber::common::PathExists(dynamic_model_local_path_)) {\n    AERROR << \"Failed to find DynamicModel!No dynamic model locally,Or do not \"\n              \"place it in correct location.\";\n  } else {\n    DIR *directory = opendir(dynamic_model_local_path_.c_str());\n    if (directory == nullptr) {\n      AERROR << \"Cannot open directory \" << dynamic_model_local_path_;\n    } else {\n      struct dirent *file;\n      std::string dynamic_model_dir_name;\n      std::string dynamic_model_library_path;\n      while ((file = readdir(directory)) != nullptr) {\n        // skip directory_path/. and directory_path/..\n        if (!strcmp(file->d_name, \".\") || !strcmp(file->d_name, \"..\")) {\n          continue;\n        }\n        if (file->d_type != DT_DIR) {\n          continue;\n        }\n        dynamic_model_dir_name = file->d_name;\n        // avpid dumplicate register dynamic model\n        RegisterDynamicModel(dynamic_model_dir_name);\n      }\n      closedir(directory);\n    }\n  }\n\n// c++ map's traversal order is different from the insertion order.\n// To ensure that the default sim control is in the front,put it before other\n// dynamic models.\n  result[\"loaded_dynamic_models\"] = {FLAGS_sim_perfect_control};\n  for (auto iter = s_dynamic_model_map_.begin();\n       iter != s_dynamic_model_map_.end(); iter++) {\n    if (iter->first != FLAGS_sim_perfect_control)\n    {\n      result[\"loaded_dynamic_models\"].push_back(iter->first);\n    }\n  }\n  return result;\n}\n\nSimControlBase *DynamicModelFactory::GetModelType(\n    std::string dynamic_model_name) {\n  auto iter = s_dynamic_model_map_.find(dynamic_model_name);\n  if (iter == s_dynamic_model_map_.end()) {\n    AERROR << \"Failed to get \" << dynamic_model_name << \" related pointer.\";\n    return nullptr;\n  }\n  return iter->second.dynamic_model_ptr;\n}\n\nbool DynamicModelFactory::UnregisterDynamicModel(\n    std::string &dynamic_model_name) {\n  auto iter = s_dynamic_model_map_.find(dynamic_model_name);\n  if (iter == s_dynamic_model_map_.end()) {\n    AERROR << \"Failed to get \" << dynamic_model_name << \" related pointer.\";\n    return true;\n  }\n  std::string library_name = iter->second.library_name;\n  s_dynamic_model_map_.erase(dynamic_model_name);\n  std::string dynamic_model_dir;\n  GetDynamicModelPath(dynamic_model_name, dynamic_model_dir, false);\n  std::string command = \"rm -fr \" + dynamic_model_dir;\n  // use cyber::common::removeFiles do not support sub-directory\n  // use rmdir do not support not empty directory\n  if (std::system(command.data()) != 0) {\n    AERROR << \"Failed to delete dynamic model directory for: \"\n           << std::strerror(errno);\n    return false;\n  }\n  // delete related library if library is only used by this dynamic model\n  auto count_iter = s_dm_lib_count_.find(library_name);\n  if (count_iter->second == 1) {\n    std::string lib_path =\n        home_path_ + FLAGS_dynamic_model_library_path + library_name;\n    cyber::common::DeleteFile(lib_path);\n    s_dm_lib_count_.erase(library_name);\n  } else {\n    s_dm_lib_count_[library_name]--;\n  }\n  return true;\n}\n\n}  // namespace dreamview\n}  // namespace apollo",
        "base_contents": "",
        "res_region": "/******************************************************************************\n * Copyright 2018 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *****************************************************************************/\n#include \"modules/dreamview/backend/sim_control_manager/core/dynamic_model_factory.h\"\n\n#include \"modules/dreamview/backend/sim_control_manager/proto/dynamic_model_conf.pb.h\"\n\n#include \"cyber/class_loader/shared_library/exceptions.h\"\n#include \"cyber/class_loader/shared_library/shared_library.h\"\n#include \"modules/common/util/util.h\"\n#include \"modules/dreamview/backend/common/dreamview_gflags.h\"\n#include \"modules/dreamview/backend/map/map_service.h\"\n#include \"modules/dreamview/backend/sim_control_manager/dynamic_model/perfect_control/sim_perfect_control.h\"\n\nnamespace apollo {\nnamespace dreamview {\n\nusing apollo::cyber::class_loader::LibraryAlreadyLoadedException;\nusing apollo::cyber::class_loader::LibraryLoadException;\nusing apollo::cyber::class_loader::SharedLibrary;\nusing apollo::cyber::class_loader::SymbolNotFoundException;\nusing ::std::string;\nusing ::std::unordered_map;\nusing SharedLibraryPtr = std::shared_ptr<SharedLibrary>;\n\nstruct DynamicModelInfo {\n  std::string dynamic_model_name;\n  std::string library_name;\n  SimControlBase *dynamic_model_ptr;\n};\nunordered_map<string, DynamicModelInfo> s_dynamic_model_map_;\nunordered_map<string, int> s_dm_lib_count_;\n\nDynamicModelFactory::DynamicModelFactory() : dynamic_model_local_path_(\"\") {\n  home_path_ = cyber::common::GetEnv(\"HOME\");\n  dynamic_model_local_path_ = home_path_ + FLAGS_resource_dynamic_model_path;\n  // init should register default sim control:SimPerfectControl\n  RegisterSimPerfectControl();\n}\n\nDynamicModelFactory::~DynamicModelFactory() {\n  for (auto iter = s_dynamic_model_map_.begin();\n       iter != s_dynamic_model_map_.end(); iter++) {\n    delete iter->second.dynamic_model_ptr;\n    iter->second.dynamic_model_ptr = nullptr;\n  }\n}\n\nvoid DynamicModelFactory::RegisterSimPerfectControl() {\n  // map_service\u5f53\u53c2\u6570\n  if (s_dynamic_model_map_.find(FLAGS_sim_perfect_control) ==\n      s_dynamic_model_map_.end()) {\n    // Avoid dumplicate register dynamic model which is already registered\n    s_dynamic_model_map_[FLAGS_sim_perfect_control] = {};\n    s_dynamic_model_map_[FLAGS_sim_perfect_control].dynamic_model_name =\n        FLAGS_sim_perfect_control;\n    s_dynamic_model_map_[FLAGS_sim_perfect_control].dynamic_model_ptr =\n        new SimPerfectControl(new MapService());\n  }\n}\n\nbool DynamicModelFactory::RegisterDynamicModel(const std::string &dm_dir_name) {\n  std::string dynamic_model_conf_json_path;\n  GetDynamicModelPath(dm_dir_name, &dynamic_model_conf_json_path, true);\n  if (!cyber::common::PathExists(dynamic_model_conf_json_path)) {\n    AERROR << \"Failed to load Dynamic Model: \" << dm_dir_name\n           << \". conf file is not exists!\";\n    return false;\n  }\n  DynamicModelConf dynamic_model_conf;\n  if (!cyber::common::GetProtoFromJsonFile(dynamic_model_conf_json_path,\n                                           &dynamic_model_conf)) {\n    AERROR << \"Unable to parse Dynamic model conf from file \"\n           << dynamic_model_conf_json_path;\n    return false;\n  }\n  std::string dynamic_model_name = dynamic_model_conf.dynamic_model_name();\n  // get library name to load dm class\n  if (!dynamic_model_conf.has_library_name() ||\n      !dynamic_model_conf.has_dynamic_model_name()) {\n    AERROR << \"Missing required field!\";\n    return false;\n  }\n  // if is already registered\n  auto iter = s_dynamic_model_map_.find(dynamic_model_name);\n  if (iter != s_dynamic_model_map_.end()) {\n    AERROR << \"This dynamic model:  \" << dynamic_model_name\n           << \" is already registered!\";\n    return false;\n  }\n  std::string dm_library_name = dynamic_model_conf.library_name();\n  std::string dynamic_model_library_path =\n      home_path_ + FLAGS_dynamic_model_library_path + dm_library_name;\n  SharedLibraryPtr shared_library = nullptr;\n  try {\n    // todo(@lijin):when to unload\n    shared_library =\n        SharedLibraryPtr(new SharedLibrary(dynamic_model_library_path));\n    create_t *create_dynamic_model =\n        reinterpret_cast<create_t *>(shared_library->GetSymbol(\"create\"));\n    SimControlBase *dynamic_model_ptr =\n        create_dynamic_model(dm_dir_name, home_path_);\n    if (!dynamic_model_ptr) {\n      return false;\n    }\n    s_dynamic_model_map_[dynamic_model_name] = {};\n    s_dynamic_model_map_[dynamic_model_name].dynamic_model_name =\n        dynamic_model_name;\n    s_dynamic_model_map_[dynamic_model_name].dynamic_model_ptr =\n        dynamic_model_ptr;\n    s_dynamic_model_map_[dynamic_model_name].library_name = dm_library_name;\n    auto iter = s_dm_lib_count_.find(dm_library_name);\n    if (iter == s_dm_lib_count_.end()) {\n      s_dm_lib_count_[dm_library_name] = 1;\n    } else {\n      s_dm_lib_count_[dm_library_name]++;\n    }\n  } catch (const LibraryLoadException &e) {\n    AERROR << \"LibraryLoadException: \" << e.what();\n    return false;\n  } catch (const LibraryAlreadyLoadedException &e) {\n    AERROR << \"LibraryAlreadyLoadedException: \" << e.what();\n    return false;\n  } catch (const SymbolNotFoundException &e) {\n    AERROR << \"SymbolNotFoundException: \" << e.what();\n    return false;\n  }\n  return true;\n}\n\nvoid DynamicModelFactory::GetDynamicModelPath(\n    const std::string &dynamic_model_name, std::string *path,\n    bool get_conf_json) {\n  CHECK_NOTNULL(path);\n  *path = dynamic_model_local_path_ + dynamic_model_name;\n  if (get_conf_json) {\n    *path = *path + \"/dynamic_model.json\";\n  }\n  return;\n}\n\nnlohmann::json DynamicModelFactory::RegisterDynamicModels() {\n  nlohmann::json result = {};\n  result[\"result\"] = true;\n  result[\"loaded_dynamic_models\"] = {};\n  if (!cyber::common::PathExists(dynamic_model_local_path_)) {\n    AERROR << \"Failed to find DynamicModel!No dynamic model locally,Or do not \"\n              \"place it in correct location.\";\n  } else {\n    DIR *directory = opendir(dynamic_model_local_path_.c_str());\n    if (directory == nullptr) {\n      AERROR << \"Cannot open directory \" << dynamic_model_local_path_;\n    } else {\n      struct dirent *file;\n      std::string dynamic_model_dir_name;\n      std::string dynamic_model_library_path;\n      while ((file = readdir(directory)) != nullptr) {\n        // skip directory_path/. and directory_path/..\n        if (!strcmp(file->d_name, \".\") || !strcmp(file->d_name, \"..\")) {\n          continue;\n        }\n        if (file->d_type != DT_DIR) {\n          continue;\n        }\n        dynamic_model_dir_name = file->d_name;\n        // avpid dumplicate register dynamic model\n        RegisterDynamicModel(dynamic_model_dir_name);\n      }\n      closedir(directory);\n    }\n  }\n\n  // c++ map's traversal order is different from the insertion order.\n  // To ensure that the default sim control is in the front,put it before other\n  // dynamic models.\n  result[\"loaded_dynamic_models\"] = {FLAGS_sim_perfect_control};\n  for (auto iter = s_dynamic_model_map_.begin();\n       iter != s_dynamic_model_map_.end(); iter++) {\n    if (iter->first != FLAGS_sim_perfect_control) {\n      result[\"loaded_dynamic_models\"].push_back(iter->first);\n    }\n  }\n  return result;\n}\n\nSimControlBase *DynamicModelFactory::GetModelType(\n    std::string dynamic_model_name) {\n  auto iter = s_dynamic_model_map_.find(dynamic_model_name);\n  if (iter == s_dynamic_model_map_.end()) {\n    AERROR << \"Failed to get \" << dynamic_model_name << \" related pointer.\";\n    return nullptr;\n  }\n  return iter->second.dynamic_model_ptr;\n}\n\nbool DynamicModelFactory::UnregisterDynamicModel(\n    const std::string &dynamic_model_name) {\n  auto iter = s_dynamic_model_map_.find(dynamic_model_name);\n  if (iter == s_dynamic_model_map_.end()) {\n    AERROR << \"Failed to get \" << dynamic_model_name << \" related pointer.\";\n    return true;\n  }\n  std::string library_name = iter->second.library_name;\n  s_dynamic_model_map_.erase(dynamic_model_name);\n  std::string dynamic_model_dir;\n  GetDynamicModelPath(dynamic_model_name, &dynamic_model_dir, false);\n  std::string command = \"rm -fr \" + dynamic_model_dir;\n  // use cyber::common::removeFiles do not support sub-directory\n  // use rmdir do not support not empty directory\n  if (std::system(command.data()) != 0) {\n    AERROR << \"Failed to delete dynamic model directory for: \"\n           << std::strerror(errno);\n    return false;\n  }\n  // delete related library if library is only used by this dynamic model\n  auto count_iter = s_dm_lib_count_.find(library_name);\n  if (count_iter->second == 1) {\n    std::string lib_path =\n        home_path_ + FLAGS_dynamic_model_library_path + library_name;\n    cyber::common::DeleteFile(lib_path);\n    s_dm_lib_count_.erase(library_name);\n  } else {\n    s_dm_lib_count_[library_name]--;\n  }\n  return true;\n}\n\n}  // namespace dreamview\n}  // namespace apollo",
        "lookback": " * Copyright 2018 The Apollo Authors. All Rights Reserved.",
        "lookahead": "",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 0,
        "end_line": 482,
        "merge_gen_region": " Copyright Thepol Authors All Reserved/****************************************************************************** Copyright Thepol Authors All Reserved * Licensed the Apache, 20theLicense *\"); you not this except in with the. You obtain copy the License * may a of License * *://.///LICENSE20 * Unless by law agreed in,, * under License distributed anAS\" BASIS * WARRANTIES CONDITIONS ANY, either or. See License the for specific governing and limitations the License *****************************************************************************/includemodulesdrviewbackendsimcontrolmanagercoredynamicmodelfactoryh # \"/drviewbackendsimcontrolmanagerprotodynamicmodelconfpbh # \"berclassloadersharedlibraryexceptionsh # \"berclassloadersharedlibrarysharedlibraryh # \"modulescommonutilutilutilh # \"modulesdrviewbackendcommondrviewg.\"includemodulesdrviewbackendcommonmapmapserviceh # \"/eam/eam/eam/eam/eam///viewbackendsimcontrolmanagerdynamicmodelperf_/simperf_.h namespacepol { drview usingpol::berclassloaderLibraryAlreadyException usingpol::::berclassloaderLibraryException usingpol::::berclassloaderLibraryLibrary usingpol::berclassloaderSymbolException usingstdstring usingstdunorderedmap usingLibrary =::__<Library>; DynamicInfo {:: dynamic",
        "confidence": 0.9354922771453857,
        "hesitated": false,
        "resolved": false
    }
]