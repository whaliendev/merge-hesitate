[
    {
        "a_contents": "/******************************************************************************\n * Copyright 2022 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *****************************************************************************/\n\n#include \"modules/perception/camera/lib/obstacle/camera_detection_postprocessor/camera_get_object/camera_get_object.h\"\n\n#include \"cyber/common/file.h\"\n#include \"cyber/common/log.h\"\n\nnamespace apollo {\nnamespace perception {\nnamespace camera {\n\nCameraGetObject::CameraGetObject(const PluginConfig &plugin_config) {\n  Init(plugin_config);\n}\n\nbool CameraGetObject::Init(const PluginConfig &plugin_config) {\n  // ACHECK(plugin_config.CameraGetObject());\n  // confidence_threshold_ = plugin_config.confidence_threshold();\n  return true;\n}\n\n// input  : DataFrame *data_frame\n// output : DataFrame * data_frame\nbool CameraGetObject::Process(const std::vector<float> &detect_result,\n                              DataFrame *data_frame) {\n  if (nullptr == data_frame) {\n    AERROR << \"Input null dataframe ptr.\";\n    return false;\n  }\n\n  auto frame = data_frame->camera_frame;\n  get_smoke_objects_cpu(\n      detect_result, confidence_threshold_, frame->data_provider->src_width(),\n      frame->data_provider->src_height(), &(frame->detected_objects));\n  return true;\n}\n\nvoid CameraGetObject::get_smoke_objects_cpu(\n    const std::vector<float> &detect_result, float confidence_threshold,\n    int width, int height, std::vector<base::ObjectPtr> *objects) {\n  objects->clear();\n\n  // todo(zero): need fix model_param\n  // int len_pred = 14;\n  // for (int i = 0; i < 50; i++) {\n  //   const float *bbox = detect_result.data() + i * len_pred;\n  //   float score = bbox[13];\n  //   if (score < model_param.confidence_threshold()) {\n  //     continue;\n  //   }\n\n  //   float label = bbox[0];\n  //   base::ObjectPtr obj = nullptr;\n  //   obj.reset(new base::Object);\n  //   obj->sub_type = get_smoke_object_subtype(label);\n  //   obj->type = base::kSubType2TypeMap.at(obj->sub_type);\n  //   obj->type_probs.assign(static_cast<int>(base::ObjectType::MAX_OBJECT_TYPE),\n  //                          0);\n  //   obj->sub_type_probs.assign(\n  //       static_cast<int>(base::ObjectSubType::MAX_OBJECT_TYPE), 0);\n  //   obj->type_probs[static_cast<int>(obj->type)] = score;\n  //   obj->sub_type_probs[static_cast<int>(obj->sub_type)] = score;\n  //   obj->confidence = score;\n\n  //   fill_smoke_base(obj, bbox + 2, width, height);\n  //   fill_smoke_bbox3d(model_param.with_box3d(), obj, bbox);\n\n  //   objects->push_back(obj);\n  // }\n}\n\nvoid CameraGetObject::fill_smoke_base(base::ObjectPtr obj, const float *bbox,\n                                      int width, int height) {\n  obj->camera_supplement.box.xmin = bbox[0] / width;\n  obj->camera_supplement.box.ymin = bbox[1] / height;\n  obj->camera_supplement.box.xmax = bbox[2] / width;\n  obj->camera_supplement.box.ymax = bbox[3] / height;\n}\n\nvoid CameraGetObject::fill_smoke_bbox3d(bool with_box3d, base::ObjectPtr obj,\n                                        const float *bbox) {\n  if (with_box3d) {\n    obj->camera_supplement.alpha = bbox[1];\n    obj->size[2] = bbox[6];\n    obj->size[1] = bbox[7];\n    obj->size[0] = bbox[8];\n\n    obj->camera_supplement.local_center[0] = bbox[9];\n    obj->camera_supplement.local_center[1] = bbox[10];\n    obj->camera_supplement.local_center[2] = bbox[11];\n  }\n}\n\n}  // namespace camera\n}  // namespace perception\n}  // namespace apollo",
        "b_contents": "/******************************************************************************\n * Copyright 2022 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *****************************************************************************/\n\n#include \"modules/perception/camera/lib/obstacle/camera_detection_postprocessor/camera_get_object/camera_get_object.h\"\n\n#include \"cyber/common/file.h\"\n#include \"cyber/common/log.h\"\n\nnamespace apollo {\nnamespace perception {\nnamespace camera {\n\nCameraGetObject::CameraGetObject(const PluginConfig& plugin_config) {\n  Init(plugin_config);\n}\n\nbool CameraGetObject::Init(const PluginConfig& plugin_config) {\n  // ACHECK(plugin_config.CameraGetObject());\n  // confidence_threshold_ = plugin_config.confidence_threshold();\n  return true;\n}\n\n\n// input  : DataFrame *data_frame\n// output : DataFrame * data_frame\nbool CameraGetObject::Process(const std::vector<float> &detect_result,\n                        DataFrame *data_frame) {\n  if (nullptr == data_frame) {\n    AERROR << \"Input null dataframe ptr.\";\n    return false;\n  }\n\n  auto frame = data_frame->camera_frame;\n  get_smoke_objects_cpu(\n      detect_result, confidence_threshold_, frame->data_provider->src_width(),\n      frame->data_provider->src_height(), &(frame->detected_objects));\n  return true;\n}\n\nvoid CameraGetObject::get_smoke_objects_cpu(const std::vector<float> &detect_result,\n                                      float confidence_threshold, int width,\n                                      int height,\n                                      std::vector<base::ObjectPtr> *objects) {\n  objects->clear();\n\n  // todo(zero): need fix model_param\n  // int len_pred = 14;\n  // for (int i = 0; i < 50; i++) {\n  //   const float *bbox = detect_result.data() + i * len_pred;\n  //   float score = bbox[13];\n  //   if (score < model_param.confidence_threshold()) {\n  //     continue;\n  //   }\n\n  //   float label = bbox[0];\n  //   base::ObjectPtr obj = nullptr;\n  //   obj.reset(new base::Object);\n  //   obj->sub_type = get_smoke_object_subtype(label);\n  //   obj->type = base::kSubType2TypeMap.at(obj->sub_type);\n  //   obj->type_probs.assign(static_cast<int>(base::ObjectType::MAX_OBJECT_TYPE),\n  //                          0);\n  //   obj->sub_type_probs.assign(\n  //       static_cast<int>(base::ObjectSubType::MAX_OBJECT_TYPE), 0);\n  //   obj->type_probs[static_cast<int>(obj->type)] = score;\n  //   obj->sub_type_probs[static_cast<int>(obj->sub_type)] = score;\n  //   obj->confidence = score;\n\n  //   fill_smoke_base(obj, bbox + 2, width, height);\n  //   fill_smoke_bbox3d(model_param.with_box3d(), obj, bbox);\n\n  //   objects->push_back(obj);\n  // }\n}\n\nvoid CameraGetObject::fill_smoke_base(base::ObjectPtr obj, const float *bbox,\n                                int width, int height) {\n  obj->camera_supplement.box.xmin = bbox[0] / width;\n  obj->camera_supplement.box.ymin = bbox[1] / height;\n  obj->camera_supplement.box.xmax = bbox[2] / width;\n  obj->camera_supplement.box.ymax = bbox[3] / height;\n}\n\nvoid CameraGetObject::fill_smoke_bbox3d(bool with_box3d, base::ObjectPtr obj,\n                                  const float *bbox) {\n  if (with_box3d) {\n    obj->camera_supplement.alpha = bbox[1];\n    obj->size[2] = bbox[6];\n    obj->size[1] = bbox[7];\n    obj->size[0] = bbox[8];\n\n    obj->camera_supplement.local_center[0] = bbox[9];\n    obj->camera_supplement.local_center[1] = bbox[10];\n    obj->camera_supplement.local_center[2] = bbox[11];\n  }\n}\n\n}  // namespace camera\n}  // namespace perception\n}  // namespace apollo",
        "base_contents": "",
        "res_region": "/******************************************************************************\n * Copyright 2022 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *****************************************************************************/\n\n#include \"modules/perception/camera/lib/obstacle/camera_detection_postprocessor/camera_get_object/camera_get_object.h\"\n\n#include \"cyber/common/file.h\"\n#include \"cyber/common/log.h\"\n\nnamespace apollo {\nnamespace perception {\nnamespace camera {\n\nCameraGetObject::CameraGetObject(const PluginConfig &plugin_config) {\n  Init(plugin_config);\n}\n\nbool CameraGetObject::Init(const PluginConfig &plugin_config) {\n  // ACHECK(plugin_config.CameraGetObject());\n  // confidence_threshold_ = plugin_config.confidence_threshold();\n  return true;\n}\n\n// input  : DataFrame *data_frame\n// output : DataFrame * data_frame\nbool CameraGetObject::Process(const std::vector<float> &detect_result,\n                              DataFrame *data_frame) {\n  if (nullptr == data_frame) {\n    AERROR << \"Input null dataframe ptr.\";\n    return false;\n  }\n\n  auto frame = data_frame->camera_frame;\n  get_smoke_objects_cpu(\n      detect_result, confidence_threshold_, frame->data_provider->src_width(),\n      frame->data_provider->src_height(), &(frame->detected_objects));\n  return true;\n}\n\nvoid CameraGetObject::get_smoke_objects_cpu(\n    const std::vector<float> &detect_result, float confidence_threshold,\n    int width, int height, std::vector<base::ObjectPtr> *objects) {\n  objects->clear();\n\n  // todo(zero): need fix model_param\n  // int len_pred = 14;\n  // for (int i = 0; i < 50; i++) {\n  //   const float *bbox = detect_result.data() + i * len_pred;\n  //   float score = bbox[13];\n  //   if (score < model_param.confidence_threshold()) {\n  //     continue;\n  //   }\n\n  //   float label = bbox[0];\n  //   base::ObjectPtr obj = nullptr;\n  //   obj.reset(new base::Object);\n  //   obj->sub_type = get_smoke_object_subtype(label);\n  //   obj->type = base::kSubType2TypeMap.at(obj->sub_type);\n  //   obj->type_probs.assign(static_cast<int>(base::ObjectType::MAX_OBJECT_TYPE),\n  //                          0);\n  //   obj->sub_type_probs.assign(\n  //       static_cast<int>(base::ObjectSubType::MAX_OBJECT_TYPE), 0);\n  //   obj->type_probs[static_cast<int>(obj->type)] = score;\n  //   obj->sub_type_probs[static_cast<int>(obj->sub_type)] = score;\n  //   obj->confidence = score;\n\n  //   fill_smoke_base(obj, bbox + 2, width, height);\n  //   fill_smoke_bbox3d(model_param.with_box3d(), obj, bbox);\n\n  //   objects->push_back(obj);\n  // }\n}\n\nvoid CameraGetObject::fill_smoke_base(base::ObjectPtr obj, const float *bbox,\n                                      int width, int height) {\n  obj->camera_supplement.box.xmin = bbox[0] / width;\n  obj->camera_supplement.box.ymin = bbox[1] / height;\n  obj->camera_supplement.box.xmax = bbox[2] / width;\n  obj->camera_supplement.box.ymax = bbox[3] / height;\n}\n\nvoid CameraGetObject::fill_smoke_bbox3d(bool with_box3d, base::ObjectPtr obj,\n                                        const float *bbox) {\n  if (with_box3d) {\n    obj->camera_supplement.alpha = bbox[1];\n    obj->size[2] = bbox[6];\n    obj->size[1] = bbox[7];\n    obj->size[0] = bbox[8];\n\n    obj->camera_supplement.local_center[0] = bbox[9];\n    obj->camera_supplement.local_center[1] = bbox[10];\n    obj->camera_supplement.local_center[2] = bbox[11];\n  }\n}\n\n}  // namespace camera\n}  // namespace perception\n}  // namespace apollo",
        "lookback": " * Copyright 2022 The Apollo Authors. All Rights Reserved.",
        "lookahead": "",
        "label": [
            "ours",
            "base_underutilized"
        ],
        "start_line": 0,
        "end_line": 225,
        "merge_gen_region": " Copyright022 Alo. Rights. Rights. * Licensed the License, 20theLicense * may use file in with License * may obtain copy the License * *://.///LICENSE20 * Unless by law agreed in, * under License distributed anAS\" BASIS * WARRANTIES CONDITIONS ANY, express implied * the See License the for specific governing and limitations the License *****************************************************************************/includemodulesper///staclecameralibob/_staclecameradetectionpost/___/__/__/_/_/_/_/_.\"includecy///.\"includecy/commonlogh namespacepol { per { camera Camera::GetObjectCamera( Plugin &_) Initpluginconfig } Camera::InitconstConfigpluginconfig { A(_.GetObject //CHECKpluginconfigCamera()); con__ pluginconfigcon_(); true; // : Data *_ // :Frame dataframe Camera::(( stdvectorfloat &_,Framedataframe { ifnullptr data_) A <<Input data ptr return; auto =_->_->_; auto =_->_->_;_okeobjectscpu detectresult con__, framedataprovidersrcwidth framedataprovidersrcheight &(->_)); true } Camera::get",
        "confidence": 0.9258530139923096,
        "hesitated": false,
        "resolved": false
    }
]