[
    {
        "a_contents": "bool ObstacleDetectionCamera::Init(const PipelineConfig &pipeline_config) {\n  if (!Initialize(pipeline_config)) {\n    return false;\n  }\n\n  camera_detection_config_ = pipeline_config.camera_detection_config();\n  ACHECK(inference::CudaUtil::set_device_id(camera_detection_config_.gpu_id()));\n  std::string work_root = GetCyberWorkRoot();\n  // Init detector\n\n  for (const auto stage_ptr : stage_ptrs_) {\n    if (stage_ptr->stage_config_.type() == \"camera_detector\") {\n      base::BaseCameraModelPtr model;\n      auto stage_config = stage_ptr->stage_config_;\n      std::string camera_name =\n          stage_config.camera_detector_config().camera_name();\n      boost::algorithm::split(camera_names_, camera_name,\n                              boost::algorithm::is_any_of(\",\"));\n\n      for (size_t i = 0; i < camera_names_.size(); ++i) {\n        model = common::SensorManager::Instance()->GetUndistortCameraModel(\n            camera_names_[i]);\n        auto pinhole = static_cast<base::PinholeCameraModel *>(model.get());\n        name_intrinsic_map_.insert(std::pair<std::string, Eigen::Matrix3f>(\n            camera_names_[i], pinhole->get_intrinsic_params()));\n      }\n    } else {\n      continue;\n    }",
        "b_contents": "bool ObstacleDetectionCamera::Init(const PipelineConfig &pipeline_config) {\n  if (!Initialize(pipeline_config)) {\n    return false;",
        "base_contents": "void ObstacleDetectionCamera::SetCameraHeightAndPitch(\n    const std::map<std::string, float> &name_camera_ground_height_map,\n    const std::map<std::string, float> &name_camera_pitch_angle_diff_map,\n    const float &pitch_angle_calibrator_working_sensor) {\n  if (calibration_service_ == nullptr) {\n    AERROR << \"Calibraion service is not available\";\n    return;",
        "res_region": "bool ObstacleDetectionCamera::Init(const PipelineConfig &pipeline_config) {\n  if (!Initialize(pipeline_config)) {\n    return false;\n  }\n\n  camera_detection_config_ = pipeline_config.camera_detection_config();\n  ACHECK(inference::CudaUtil::set_device_id(camera_detection_config_.gpu_id()));\n  std::string work_root = GetCyberWorkRoot();\n  // Init detector\n\n  for (const auto stage_ptr : stage_ptrs_) {\n    if (stage_ptr->stage_config_.type() == \"camera_detector\") {\n      base::BaseCameraModelPtr model;\n      auto stage_config = stage_ptr->stage_config_;\n      std::string camera_name =\n          stage_config.camera_detector_config().camera_name();\n      boost::algorithm::split(camera_names_, camera_name,\n                              boost::algorithm::is_any_of(\",\"));\n\n      for (size_t i = 0; i < camera_names_.size(); ++i) {\n        model = common::SensorManager::Instance()->GetUndistortCameraModel(\n            camera_names_[i]);\n        auto pinhole = static_cast<base::PinholeCameraModel *>(model.get());\n        name_intrinsic_map_.insert(std::pair<std::string, Eigen::Matrix3f>(\n            camera_names_[i], pinhole->get_intrinsic_params()));\n      }\n    } else {\n      continue;\n    }",
        "lookback": "  if (!Initialize(pipeline_config)) {",
        "lookahead": "  }",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 161,
        "end_line": 203,
        "merge_gen_region": null,
        "confidence": 0.8545952439308167,
        "hesitated": true
    },
    {
        "a_contents": "  // Init tracker\n  // Init transformer\n  // Init obstacle postprocessor\n  // Init debug_param\n  if (camera_detection_config_.has_debug_param()) {\n    // Init debug info\n    if (camera_detection_config_.debug_param().has_track_out_file()) {\n      out_track_.open(camera_detection_config_.debug_param().track_out_file(),\n                      std::ofstream::out);\n    }\n    if (camera_detection_config_.debug_param().has_camera2world_out_file()) {\n      out_pose_.open(\n          camera_detection_config_.debug_param().camera2world_out_file(),\n          std::ofstream::out);\n    }\n  }\n\n  // Init object template\n  if (camera_detection_config_.has_object_template_param()) {\n    ObjectTemplateManagerInitOptions init_options;\n    auto plugin_param =\n        camera_detection_config_.object_template_param().plugin_param();\n    // todo(zero): need fix work_root\n    init_options.root_dir = GetAbsolutePath(work_root, plugin_param.root_dir());\n    init_options.conf_file = plugin_param.config_file();\n    ACHECK(ObjectTemplateManager::Instance()->Init(init_options));",
        "b_contents": "  camera_detection_config_ = pipeline_config.camera_detection_config();\n  ACHECK(inference::CudaUtil::set_device_id(camera_detection_config_.gpu_id()));\n  std::string work_root = GetCyberWorkRoot();\n  // Init detector\n\n  // wxt todo: remove this init to smoke stage\n  SmokeObstacleDetectionConfig smoke_obstacle_det_config =\n      (stage_config_map_.at(StageType::SMOKE_OBSTACLE_DETECTION))\n          .smoke_obstacle_detection_config();\n  std::string config_file =\n      GetAbsolutePath(smoke_obstacle_det_config.root_dir(),\n                      smoke_obstacle_det_config.conf_file());\n  config_file = GetAbsolutePath(work_root, config_file);\n  ACHECK(cyber::common::GetProtoFromFile(config_file, &smoke_param_))\n      << \"Read config failed: \" << config_file;\n  // ACHECK(inference::CudaUtil::set_device_id(perception_param_.gpu_id()));\n\n  // Init detector\n  base::BaseCameraModelPtr model;\n\n  model = common::SensorManager::Instance()->GetUndistortCameraModel(\n      smoke_obstacle_det_config.camera_name());\n\n  auto pinhole = static_cast<base::PinholeCameraModel *>(model.get());\n  name_intrinsic_map_.insert(std::pair<std::string, Eigen::Matrix3f>(\n      smoke_obstacle_det_config.camera_name(),\n      pinhole->get_intrinsic_params()));\n\n  // Init tracker\n  // Init transformer\n  // Init obstacle postprocessor\n  // Init debug_param\n  if (camera_detection_config_.has_debug_param()) {\n    // Init debug info\n    if (camera_detection_config_.debug_param().has_track_out_file()) {\n      out_track_.open(camera_detection_config_.debug_param().track_out_file(),\n                      std::ofstream::out);\n    }\n    if (camera_detection_config_.debug_param().has_camera2world_out_file()) {\n      out_pose_.open(\n          camera_detection_config_.debug_param().camera2world_out_file(),\n          std::ofstream::out);\n    }\n  }\n\n  // Init object template\n  if (camera_detection_config_.has_object_template_param()) {\n    ObjectTemplateManagerInitOptions init_options;\n    auto plugin_param =\n        camera_detection_config_.object_template_param().plugin_param();\n    // todo(zero): need fix work_root\n    init_options.root_dir = GetAbsolutePath(work_root, plugin_param.root_dir());\n    init_options.conf_file = plugin_param.config_file();\n    ACHECK(ObjectTemplateManager::Instance()->Init(init_options));",
        "base_contents": "void ObstacleDetectionCamera::SetIm2CarHomography(\n    Eigen::Matrix3d homography_im2car) {\n  if (calibration_service_ == nullptr) {\n    AERROR << \"Calibraion service is not available\";\n    return;",
        "res_region": "\n  // Init tracker\n  // Init transformer\n  // Init obstacle postprocessor\n  // Init debug_param\n  if (camera_detection_config_.has_debug_param()) {\n    // Init debug info\n    if (camera_detection_config_.debug_param().has_track_out_file()) {\n      out_track_.open(camera_detection_config_.debug_param().track_out_file(),\n                      std::ofstream::out);\n    }\n    if (camera_detection_config_.debug_param().has_camera2world_out_file()) {\n      out_pose_.open(\n          camera_detection_config_.debug_param().camera2world_out_file(),\n          std::ofstream::out);\n    }\n  }\n\n  // Init object template\n  if (camera_detection_config_.has_object_template_param()) {\n    ObjectTemplateManagerInitOptions init_options;\n    auto plugin_param =\n        camera_detection_config_.object_template_param().plugin_param();\n    // todo(zero): need fix work_root\n    init_options.root_dir = GetAbsolutePath(work_root, plugin_param.root_dir());\n    init_options.conf_file = plugin_param.config_file();\n    ACHECK(ObjectTemplateManager::Instance()->Init(init_options));",
        "lookback": "  // Init tracker",
        "lookahead": "  }",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 206,
        "end_line": 294,
        "merge_gen_region": " Init // tracker Init // Init // Init // Initer Initstacleprocessor Init_ ifcameradetectionconfighasdebugparam { Init info (____.debugparamhastrackoutfile {__.opencameradetectionconfig stdstring_<::,::); ifcameradetectionconfig_.___().____(),::::(); ifcameradetectionconfig_.__()._____(),::::::);",
        "confidence": 0.8965180516242981,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "bool ObstacleDetectionCamera::Process(DataFrame *data_frame) {\n  CameraFrame *frame = data_frame->camera_frame;\n  frame->camera_k_matrix =\n      name_intrinsic_map_.at(frame->data_provider->sensor_name());\n  for (size_t i = 1; i < camera_names_.size(); ++i) {\n    if (camera_names_.size() == 2) {\n      continue;\n    } else {\n      CameraFrame *frame = (data_frame + i)->camera_frame;\n      frame->camera_k_matrix =\n      name_intrinsic_map_.at(frame->data_provider->sensor_name());\n    }\n  }\n  InnerProcess(data_frame);\n\n  if (camera_detection_config_.has_debug_param()) {\n    if (camera_detection_config_.debug_param().has_camera2world_out_file()) {\n      WriteCamera2World(out_pose_, frame->frame_id, frame->camera2world_pose);\n    }\n    if (camera_detection_config_.debug_param().has_track_out_file()) {\n      WriteTracking(out_track_, frame->frame_id, frame->tracked_objects);\n    }\n  }\n\n  // Save tracked detections results as kitti format\n  WriteDetections(\n      camera_detection_config_.debug_param().has_tracked_detection_out_dir(),\n      absl::StrCat(\n          camera_detection_config_.debug_param().tracked_detection_out_dir(),\n          \"/\", frame->frame_id, \".txt\"),\n      frame->tracked_objects);\n\n  // Fill polygon and set anchor point\n  for (auto &obj : frame->tracked_objects) {\n    FillObjectPolygonFromBBox3D(obj.get());\n    obj->anchor_point = obj->center;\n  }",
        "b_contents": "bool ObstacleDetectionCamera::Process(DataFrame *data_frame) {\n  CameraFrame *frame = data_frame->camera_frame;\n  frame->camera_k_matrix =\n      name_intrinsic_map_.at(frame->data_provider->sensor_name());\n  InnerProcess(data_frame);\n\n  if (camera_detection_config_.has_debug_param()) {\n    if (camera_detection_config_.debug_param().has_camera2world_out_file()) {\n      WriteCamera2World(out_pose_, frame->frame_id, frame->camera2world_pose);\n    }\n    if (camera_detection_config_.debug_param().has_track_out_file()) {\n      WriteTracking(out_track_, frame->frame_id, frame->tracked_objects);\n    }\n  }\n\n  // Save tracked detections results as kitti format\n  WriteDetections(\n      camera_detection_config_.debug_param().has_tracked_detection_out_dir(),\n      absl::StrCat(\n          camera_detection_config_.debug_param().tracked_detection_out_dir(),\n          \"/\", frame->frame_id, \".txt\"),\n      frame->tracked_objects);\n\n  // Fill polygon and set anchor point\n  for (auto &obj : frame->tracked_objects) {\n    FillObjectPolygonFromBBox3D(obj.get());\n    obj->anchor_point = obj->center;\n  }\n",
        "base_contents": "bool ObstacleDetectionCamera::GetCalibrationService(\n    BaseCalibrationService **calibration_service) {\n  *calibration_service = calibration_service_.get();",
        "res_region": "bool ObstacleDetectionCamera::Process(DataFrame *data_frame) {\n  CameraFrame *frame = data_frame->camera_frame;\n  frame->camera_k_matrix =\n      name_intrinsic_map_.at(frame->data_provider->sensor_name());\n  for (size_t i = 1; i < camera_names_.size(); ++i) {\n    if (camera_names_.size() == 2) {\n      continue;\n    } else {\n      CameraFrame *frame = (data_frame + i)->camera_frame;\n      frame->camera_k_matrix =\n      name_intrinsic_map_.at(frame->data_provider->sensor_name());\n    }\n  }\n  InnerProcess(data_frame);\n\n  if (camera_detection_config_.has_debug_param()) {\n    if (camera_detection_config_.debug_param().has_camera2world_out_file()) {\n      WriteCamera2World(out_pose_, frame->frame_id, frame->camera2world_pose);\n    }\n    if (camera_detection_config_.debug_param().has_track_out_file()) {\n      WriteTracking(out_track_, frame->frame_id, frame->tracked_objects);\n    }\n  }\n\n  // Save tracked detections results as kitti format\n  WriteDetections(\n      camera_detection_config_.debug_param().has_tracked_detection_out_dir(),\n      absl::StrCat(\n          camera_detection_config_.debug_param().tracked_detection_out_dir(),\n          \"/\", frame->frame_id, \".txt\"),\n      frame->tracked_objects);\n\n  // Fill polygon and set anchor point\n  for (auto &obj : frame->tracked_objects) {\n    FillObjectPolygonFromBBox3D(obj.get());\n    obj->anchor_point = obj->center;\n  }",
        "lookback": "  CameraFrame *frame = data_frame->camera_frame;",
        "lookahead": "  return true;",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 300,
        "end_line": 372,
        "merge_gen_region": null,
        "confidence": 0.7683148980140686,
        "hesitated": true
    }
]