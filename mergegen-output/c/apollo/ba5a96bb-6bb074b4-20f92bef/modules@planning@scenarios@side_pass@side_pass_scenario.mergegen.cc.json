[
    {
        "a_contents": "  if (current_scenario.scenario_type() == ScenarioConfig::SIDE_PASS) {\n    // Check side-pass exiting conditions.\n    ADEBUG << \"Checking if it's needed to exit SIDE_PASS:\";\n    ADEBUG << \"Able to use self-lane counter = \"\n           << PlanningContext::able_to_use_self_lane_counter();\n    return PlanningContext::able_to_use_self_lane_counter() < 3;\n  } else if (current_scenario.scenario_type() != ScenarioConfig::LANE_FOLLOW) {\n    // If in some other scenario, then don't try to switch to SIDE_PASS.\n    ADEBUG << \"Currently in some other scenario.\";\n    return false;\n  } else {\n    // If originally in LANE_FOLLOW, then decide whether we should\n    // switch to SIDE_PASS scenario.\n    ADEBUG << \"Checking if it's needed to switch from LANE_FOLLOW to \"\n              \"SIDE_PASS: \";\n    bool is_side_pass = IsSidePassScenario(frame);\n    if (is_side_pass) {\n      ADEBUG << \"   YES!\";\n    } else {\n      ADEBUG << \"   NO!\";\n    }\n    return is_side_pass &&\n           PlanningContext::front_static_obstacle_cycle_counter() >= 1;\n  }\n\n  // TODO(all): the following is the old legacy code. Retire them when the new\n  //            code gets steady.\n  /*\n  std::string front_blocking_obstacle_id =\n      PlanningContext::Planningstatus().side_pass()\n          .front_blocking_obstacle_id();",
        "b_contents": "  std::string front_blocking_obstacle_id = PlanningContext::Planningstatus()\n                                               .side_pass()\n                                               .front_blocking_obstacle_id();",
        "base_contents": "  std::string front_blocking_obstacle_id =\n      PlanningContext::Planningstatus().side_pass()\n          .front_blocking_obstacle_id();",
        "res_region": "  if (current_scenario.scenario_type() == ScenarioConfig::SIDE_PASS) {\n    // Check side-pass exiting conditions.\n    ADEBUG << \"Checking if it's needed to exit SIDE_PASS:\";\n    ADEBUG << \"Able to use self-lane counter = \"\n           << PlanningContext::able_to_use_self_lane_counter();\n    return PlanningContext::able_to_use_self_lane_counter() < 3;\n  } else if (current_scenario.scenario_type() != ScenarioConfig::LANE_FOLLOW) {\n    // If in some other scenario, then don't try to switch to SIDE_PASS.\n    ADEBUG << \"Currently in some other scenario.\";\n    return false;\n  } else {\n    // If originally in LANE_FOLLOW, then decide whether we should\n    // switch to SIDE_PASS scenario.\n    ADEBUG << \"Checking if it's needed to switch from LANE_FOLLOW to \"\n              \"SIDE_PASS: \";\n    bool is_side_pass = IsSidePassScenario(frame);\n    if (is_side_pass) {\n      ADEBUG << \"   YES!\";\n    } else {\n      ADEBUG << \"   NO!\";\n    }\n    return is_side_pass &&\n           PlanningContext::front_static_obstacle_cycle_counter() >= 1;\n  }\n\n  // TODO(all): the following is the old legacy code. Retire them when the new\n  //            code gets steady.\n  /*\n  std::string front_blocking_obstacle_id =\n      PlanningContext::Planningstatus().side_pass()\n          .front_blocking_obstacle_id();",
        "lookback": "    // Check side-pass exiting conditions.",
        "lookahead": "",
        "label": [
            "ours",
            "base_underutilized"
        ],
        "start_line": 93,
        "end_line": 133,
        "merge_gen_region": " Check- exiting. (_. { Check- exiting.DEBUG \" ifcurrentscenarioscenariotype ==enario::__) // Check- exiting.DEBUG \" if's needed exitDEPASS\";DEBUG \"ble use- counter \" PlanContextabletouseselflanecounter returnning::abletouseselflanecounter <; else (_.. { { (__selflanecounter <; else (_./ { { (__selflanecounter { (__selflanecounter <; (___1 {TypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypesTypes",
        "confidence": 0.9542657732963562,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "bool SidePassScenario::IsSidePassScenario(const Frame& frame) {\n  // return HasSingleReferenceLine(frame) &&\n  //        IsFarFromDestination(frame) &&\n  //        IsFarFromIntersection(frame) &&\n  //        HasBlockingObstacle(frame);\n\n  return HasSingleReferenceLine(frame) && IsFarFromDestination(frame) &&\n         IsFarFromIntersection(frame) && IsWithinSidePassingSpeedADC(frame) &&\n         IsSidePassableObstacle(frame, frame.reference_line_info().front(),\n                                frame.reference_line_info().front()\n                                     .path_data().blocking_obstacle_id());",
        "b_contents": "bool SidePassScenario::IsSidePassScenario(const Frame& frame,\n                                          const ScenarioConfig& config) {\n  return (IsFarFromDestination(frame) && IsFarFromIntersection(frame) &&\n          HasBlockingObstacle(frame, config));",
        "base_contents": "bool SidePassScenario::IsSidePassScenario(\n    const Frame& frame,\n    const ScenarioConfig& config) {\n  return (IsFarFromDestination(frame) && IsFarFromIntersection(frame) &&\n          HasBlockingObstacle(frame, config));",
        "res_region": "bool SidePassScenario::IsSidePassScenario(const Frame& frame) {\n  // return HasSingleReferenceLine(frame) &&\n  //        IsFarFromDestination(frame) &&\n  //        IsFarFromIntersection(frame) &&\n  //        HasBlockingObstacle(frame);\n\n  return HasSingleReferenceLine(frame) && IsFarFromDestination(frame) &&\n         IsFarFromIntersection(frame) && IsWithinSidePassingSpeedADC(frame) &&\n         IsSidePassableObstacle(frame, frame.reference_line_info().front(),\n                                frame.reference_line_info().front()\n                                     .path_data().blocking_obstacle_id());",
        "lookback": "  // return HasSingleReferenceLine(frame) &&",
        "lookahead": "}",
        "label": [
            "ours",
            "base_underutilized"
        ],
        "start_line": 189,
        "end_line": 212,
        "merge_gen_region": " returnSingleLineframe &&outputReplaceoutputoutputdexdex7979ReplaceReplaceoutputoutputdex7979ReplaceboolReplaceoutputoutputoutputdexReplaceReplaceoutputoutputdexReplaceReplaceoutputoutputReplaceReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputoutputReplaceoutputoutputReplaceoutputoutputReplaceoutputoutputReplaceoutputoutputReplaceoutputoutputReplaceoutputoutputReplaceoutputoutputReplaceoutputoutputReplaceoutputReplaceoutputReplaceoutputoutputReplaceoutputoutputReplaceoutputReplaceoutputoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplaceoutputReplace",
        "confidence": 0.8972673416137695,
        "hesitated": false,
        "resolved": false
    }
]