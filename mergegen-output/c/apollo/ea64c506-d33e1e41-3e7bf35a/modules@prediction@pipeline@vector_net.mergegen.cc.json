[
    {
        "a_contents": "/******************************************************************************\n * Copyright 2021 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *****************************************************************************/\n#include \"modules/prediction/pipeline/vector_net.h\"\n\n#include <cmath>\n#include <limits>\n#include <unordered_set>\n#include <utility>\n\n#include \"cyber/common/file.h\"\n\nnamespace apollo {\nnamespace prediction {\ntemplate <typename Points>\nvoid VectorNet::GetOnePolyline(\n    const Points& points, double* start_length,\n    const common::PointENU& center_point, const double obstacle_phi,\n    ATTRIBUTE_TYPE attr_type, BOUNDARY_TYPE bound_type, const int count,\n    std::vector<std::vector<double>>* const one_polyline,\n    std::vector<double>* const one_p_id) {\n  size_t size = points.size();\n  std::vector<double> s(size, 0);\n\n  for (size_t i = 1; i < size; ++i) {\n    s[i] = std::hypot(points.at(i).x() - points.at(i - 1).x(),\n                      points.at(i).y() - points.at(i - 1).y()) +\n           s[i - 1];\n  }\n\n  std::vector<double> x;\n  std::vector<double> y;\n  double cur_length = *start_length;\n\n  auto it_lower = std::lower_bound(s.begin(), s.end(), cur_length);\n  while (it_lower != s.end()) {\n    if (it_lower == s.begin()) {\n      x.push_back(points.at(0).x());\n      y.push_back(points.at(0).y());\n    } else {\n      const auto distance = std::distance(s.begin(), it_lower);\n      x.push_back(common::math::lerp(points.at(distance - 1).x(),\n                                     s[distance - 1], points.at(distance).x(),\n                                     s[distance], cur_length));\n      y.push_back(common::math::lerp(points.at(distance - 1).y(),\n                                     s[distance - 1], points.at(distance).y(),\n                                     s[distance], cur_length));\n    }\n    cur_length += FLAGS_point_distance;\n    it_lower = std::lower_bound(s.begin(), s.end(), cur_length);\n  }\n  size_t point_size = x.size();\n\n  *start_length = cur_length - s[size - 1];\n  if (point_size == 0) return;\n  const double attr = attribute_map.at(attr_type);\n  const double bound = boundary_map.at(bound_type);\n  auto last_point_after_rotate = common::math::RotateVector2d(\n      {x[0] - center_point.x(), y[0] - center_point.y()},\n      M_PI_2 - obstacle_phi);\n\n  for (size_t i = 1; i < point_size; ++i) {\n    if (one_p_id->at(0) > last_point_after_rotate.x()) {\n      one_p_id->at(0) = last_point_after_rotate.x();\n    }\n    if (one_p_id->at(1) > last_point_after_rotate.y()) {\n      one_p_id->at(1) = last_point_after_rotate.y();\n    }\n\n    std::vector<double> one_vector;\n\n    // d_s, d_e\n    one_vector.push_back(last_point_after_rotate.x());\n    one_vector.push_back(last_point_after_rotate.y());\n\n    Eigen::Vector2d point_after_rotate = common::math::RotateVector2d(\n        {x[i] - center_point.x(), y[i] - center_point.y()},\n        M_PI_2 - obstacle_phi);\n\n    one_vector.push_back(point_after_rotate.x());\n    one_vector.push_back(point_after_rotate.y());\n    last_point_after_rotate = std::move(point_after_rotate);\n\n    // attribute\n    one_vector.insert(one_vector.end(), {0.0, 0.0, attr, bound});\n\n    one_vector.push_back(count);\n    one_polyline->push_back(std::move(one_vector));\n  }\n}\n\nbool VectorNet::query(const common::PointENU& center_point,\n                      const double obstacle_phi,\n                      FeatureVector* const feature_ptr,\n                      PidVector* const p_id_ptr) {\n  CHECK_NOTNULL(feature_ptr);\n  count_ = 0;\n  GetRoads(center_point, obstacle_phi, feature_ptr, p_id_ptr);\n  GetLanes(center_point, obstacle_phi, feature_ptr, p_id_ptr);\n  GetJunctions(center_point, obstacle_phi, feature_ptr, p_id_ptr);\n  GetCrosswalks(center_point, obstacle_phi, feature_ptr, p_id_ptr);\n  return true;\n}\n\nbool VectorNet::offline_query(const double obstacle_x, const double obstacle_y,\n                              const double obstacle_phi) {\n  FeatureVector offline_feature;\n  PidVector p_id;\n  common::PointENU center_point =\n      common::util::PointFactory::ToPointENU(obstacle_x, obstacle_y);\n  query(center_point, obstacle_phi, &offline_feature, &p_id);\n\n  apollo::prediction::VectorNetFeature vector_net_pb_;\n  vector_net_pb_.mutable_car_position()->set_x(obstacle_x);\n  vector_net_pb_.mutable_car_position()->set_y(obstacle_y);\n  vector_net_pb_.mutable_car_position()->set_phi(obstacle_phi);\n\n  size_t i = 0;\n  for (const auto& polyline : offline_feature) {\n    auto* polyline_pb = vector_net_pb_.add_polyline();\n    polyline_pb->set_p_id_x(p_id[i][0]);\n    polyline_pb->set_p_id_y(p_id[i][1]);\n    i++;\n    for (const auto& vector : polyline) {\n      auto* vector_pb = polyline_pb->add_vector();\n      for (const auto& element : vector) {\n        vector_pb->add_element(element);\n      }\n    }\n  }\n  cyber::common::SetProtoToASCIIFile(vector_net_pb_,\n                                     FLAGS_prediction_target_file);\n\n  return true;\n}\n\nvoid VectorNet::GetRoads(const common::PointENU& center_point,\n                         const double obstacle_phi,\n                         FeatureVector* const feature_ptr,\n                         PidVector* const p_id_ptr) {\n  std::vector<apollo::hdmap::RoadInfoConstPtr> roads;\n  apollo::hdmap::HDMapUtil::BaseMap().GetRoads(center_point,\n                                               FLAGS_road_distance, &roads);\n\n  for (const auto& road : roads) {\n    for (const auto& section : road->road().section()) {\n      for (const auto& edge : section.boundary().outer_polygon().edge()) {\n        std::vector<std::vector<double>> one_polyline;\n        std::vector<double> one_p_id{std::numeric_limits<float>::max(),\n                                     std::numeric_limits<float>::max()};\n        double start_length = 0;\n        BOUNDARY_TYPE bound_type = UNKNOW;\n        if (edge.type() == hdmap::BoundaryEdge::LEFT_BOUNDARY) {\n          bound_type = LEFT_BOUNDARY;\n        } else if (edge.type() == hdmap::BoundaryEdge::RIGHT_BOUNDARY) {\n          bound_type = RIGHT_BOUNDARY;\n        } else if (edge.type() == hdmap::BoundaryEdge::NORMAL) {\n          bound_type = NORMAL;\n        } else {\n          bound_type = UNKNOW;\n        }\n\n        for (const auto& segment : edge.curve().segment()) {\n          GetOnePolyline(segment.line_segment().point(), &start_length,\n                         center_point, obstacle_phi, ROAD, bound_type, count_,\n                         &one_polyline, &one_p_id);\n        }\n        if (one_polyline.size() == 0) continue;\n\n        feature_ptr->push_back(std::move(one_polyline));\n        p_id_ptr->push_back(std::move(one_p_id));\n        ++count_;\n      }\n    }\n  }\n}\n\nvoid VectorNet::GetLaneQueue(\n    const std::vector<hdmap::LaneInfoConstPtr>& lanes,\n    std::vector<std::deque<hdmap::LaneInfoConstPtr>>* const lane_deque_ptr) {\n  std::unordered_set<hdmap::LaneInfoConstPtr> lane_set(lanes.begin(),\n                                                       lanes.end());\n\n  while (!lane_set.empty()) {\n    std::deque<apollo::hdmap::LaneInfoConstPtr> one_lane_deque;\n    auto cur_lane = *lane_set.begin();\n    lane_set.erase(lane_set.begin());\n    one_lane_deque.push_back(cur_lane);\n    while (cur_lane->lane().successor_id_size() > 0) {\n      auto id = cur_lane->lane().successor_id(0);\n      cur_lane = apollo::hdmap::HDMapUtil::BaseMap().GetLaneById(id);\n      if (lane_set.find(cur_lane) != lane_set.end()) {\n        lane_set.erase(cur_lane);\n        one_lane_deque.push_back(cur_lane);\n      } else {\n        break;\n      }\n    }\n\n    cur_lane = one_lane_deque.front();\n    while (cur_lane->lane().predecessor_id_size() > 0) {\n      auto id = cur_lane->lane().predecessor_id(0);\n      cur_lane = apollo::hdmap::HDMapUtil::BaseMap().GetLaneById(id);\n      if (lane_set.find(cur_lane) != lane_set.end()) {\n        lane_set.erase(cur_lane);\n        one_lane_deque.push_front(cur_lane);\n      } else {\n        break;\n      }\n    }\n\n    lane_deque_ptr->push_back(one_lane_deque);\n  }\n}\n\nvoid VectorNet::GetLanes(const common::PointENU& center_point,\n                         const double obstacle_phi,\n                         FeatureVector* const feature_ptr,\n                         PidVector* const p_id_ptr) {\n  std::vector<apollo::hdmap::LaneInfoConstPtr> lanes;\n  apollo::hdmap::HDMapUtil::BaseMap().GetLanes(center_point,\n                                               FLAGS_road_distance, &lanes);\n\n  std::vector<std::deque<apollo::hdmap::LaneInfoConstPtr>> lane_deque_vector;\n  GetLaneQueue(lanes, &lane_deque_vector);\n\n  for (const auto& lane_deque : lane_deque_vector) {\n    // Draw lane's left_boundary\n    std::vector<std::vector<double>> left_polyline;\n    std::vector<double> left_p_id{std::numeric_limits<float>::max(),\n                                  std::numeric_limits<float>::max()};\n    double start_length = 0;\n    for (const auto& lane : lane_deque) {\n      std::cout << lane->lane().id().id() << \" \";\n      // if (lane->lane().left_boundary().virtual_()) continue;\n      for (const auto& segment :\n           lane->lane().left_boundary().curve().segment()) {\n        auto bound_type =\n            lane->lane().left_boundary().boundary_type(0).types(0);\n        GetOnePolyline(segment.line_segment().point(), &start_length,\n                       center_point, obstacle_phi, lane_attr_map.at(bound_type),\n                       LEFT_BOUNDARY, count_, &left_polyline, &left_p_id);\n      }\n    }\n\n    if (left_polyline.size() < 2) continue;\n    feature_ptr->push_back(std::move(left_polyline));\n    p_id_ptr->push_back(std::move(left_p_id));\n    ++count_;\n\n    std::vector<std::vector<double>> right_polyline;\n    std::vector<double> right_p_id{std::numeric_limits<float>::max(),\n                                   std::numeric_limits<float>::max()};\n    start_length = 0;\n    // Draw lane's right_boundary\n    for (const auto& lane : lane_deque) {\n      // if (lane->lane().right_boundary().virtual_()) continue;\n      for (const auto& segment :\n           lane->lane().right_boundary().curve().segment()) {\n        auto bound_type =\n            lane->lane().left_boundary().boundary_type(0).types(0);\n        GetOnePolyline(segment.line_segment().point(), &start_length,\n                       center_point, obstacle_phi, lane_attr_map.at(bound_type),\n                       RIGHT_BOUNDARY, count_, &right_polyline, &right_p_id);\n      }\n    }\n\n    if (right_polyline.size() < 2) continue;\n    feature_ptr->push_back(std::move(right_polyline));\n    p_id_ptr->push_back(std::move(right_p_id));\n    ++count_;\n  }\n}\n\nvoid VectorNet::GetJunctions(const common::PointENU& center_point,\n                             const double obstacle_phi,\n                             FeatureVector* const feature_ptr,\n                             PidVector* const p_id_ptr) {\n  std::vector<apollo::hdmap::JunctionInfoConstPtr> junctions;\n  apollo::hdmap::HDMapUtil::BaseMap().GetJunctions(\n      center_point, FLAGS_road_distance, &junctions);\n  for (const auto& junction : junctions) {\n    std::vector<std::vector<double>> one_polyline;\n    std::vector<double> one_p_id{std::numeric_limits<float>::max(),\n                                 std::numeric_limits<float>::max()};\n    double start_length = 0;\n    GetOnePolyline(junction->junction().polygon().point(), &start_length,\n                   center_point, obstacle_phi, JUNCTION, UNKNOW, count_,\n                   &one_polyline, &one_p_id);\n\n    feature_ptr->push_back(std::move(one_polyline));\n    p_id_ptr->push_back(std::move(one_p_id));\n    ++count_;\n  }\n}\n\nvoid VectorNet::GetCrosswalks(const common::PointENU& center_point,\n                              const double obstacle_phi,\n                              FeatureVector* const feature_ptr,\n                              PidVector* const p_id_ptr) {\n  std::vector<apollo::hdmap::CrosswalkInfoConstPtr> crosswalks;\n  apollo::hdmap::HDMapUtil::BaseMap().GetCrosswalks(\n      center_point, FLAGS_road_distance, &crosswalks);\n  for (const auto& crosswalk : crosswalks) {\n    std::vector<std::vector<double>> one_polyline;\n    std::vector<double> one_p_id{std::numeric_limits<float>::max(),\n                                 std::numeric_limits<float>::max()};\n    double start_length = 0;\n    GetOnePolyline(crosswalk->crosswalk().polygon().point(), &start_length,\n                   center_point, obstacle_phi, CROSSWALK, UNKNOW, count_,\n                   &one_polyline, &one_p_id);\n\n    feature_ptr->push_back(std::move(one_polyline));\n    p_id_ptr->push_back(std::move(one_p_id));\n    ++count_;\n  }\n}\n}  // namespace prediction\n}  // namespace apollo",
        "b_contents": "/******************************************************************************\n * Copyright 2021 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *****************************************************************************/\n#include \"modules/prediction/pipeline/vector_net.h\"\n\n#include <cmath>\n#include <limits>\n#include <unordered_set>\n#include <utility>\n\n#include \"cyber/common/file.h\"\n\nnamespace apollo {\nnamespace prediction {\ntemplate <typename Points>\nvoid VectorNet::GetOnePolyline(\n    const Points& points, double* start_length,\n    const common::PointENU& center_point, const double obstacle_phi,\n    ATTRIBUTE_TYPE attr_type, BOUNDARY_TYPE bound_type, const int count,\n    std::vector<std::vector<double>>* const one_polyline,\n    std::vector<double>* const one_p_id) {\n  size_t size = points.size();\n  std::vector<double> s(size, 0);\n\n  for (size_t i = 1; i < size; ++i) {\n    s[i] = std::hypot(points.at(i).x() - points.at(i - 1).x(),\n                      points.at(i).y() - points.at(i - 1).y()) +\n           s[i - 1];\n  }\n\n  std::vector<double> x;\n  std::vector<double> y;\n  double cur_length = *start_length;\n\n  auto it_lower = std::lower_bound(s.begin(), s.end(), cur_length);\n  while (it_lower != s.end()) {\n    if (it_lower == s.begin()) {\n      x.push_back(points.at(0).x());\n      y.push_back(points.at(0).y());\n    } else {\n      const auto distance = std::distance(s.begin(), it_lower);\n      x.push_back(common::math::lerp(points.at(distance - 1).x(),\n                                     s[distance - 1], points.at(distance).x(),\n                                     s[distance], cur_length));\n      y.push_back(common::math::lerp(points.at(distance - 1).y(),\n                                     s[distance - 1], points.at(distance).y(),\n                                     s[distance], cur_length));\n    }\n    cur_length += FLAGS_point_distance;\n    it_lower = std::lower_bound(s.begin(), s.end(), cur_length);\n  }\n  size_t point_size = x.size();\n\n  *start_length = cur_length - s[size - 1];\n  if (point_size == 0) return;\n  const double attr = attribute_map.at(attr_type);\n  const double bound = boundary_map.at(bound_type);\n  auto last_point_after_rotate = common::math::RotateVector2d(\n      {x[0] - center_point.x(), y[0] - center_point.y()},\n      M_PI_2 - obstacle_phi);\n\n  for (size_t i = 1; i < point_size; ++i) {\n    if (one_p_id->at(0) > last_point_after_rotate.x()) {\n      one_p_id->at(0) = last_point_after_rotate.x();\n    }\n    if (one_p_id->at(1) > last_point_after_rotate.y()) {\n      one_p_id->at(1) = last_point_after_rotate.y();\n    }\n\n    std::vector<double> one_vector;\n\n    // d_s, d_e\n    one_vector.push_back(last_point_after_rotate.x());\n    one_vector.push_back(last_point_after_rotate.y());\n\n    Eigen::Vector2d point_after_rotate = common::math::RotateVector2d(\n        {x[i] - center_point.x(), y[i] - center_point.y()},\n        M_PI_2 - obstacle_phi);\n\n    one_vector.push_back(point_after_rotate.x());\n    one_vector.push_back(point_after_rotate.y());\n    last_point_after_rotate = std::move(point_after_rotate);\n\n    // attribute\n    one_vector.insert(one_vector.end(), {0.0, 0.0, attr, bound});\n\n    one_vector.push_back(count);\n    one_polyline->push_back(std::move(one_vector));\n  }\n}\n\nbool VectorNet::query(const common::PointENU& center_point,\n                      const double obstacle_phi,\n                      FeatureVector* const feature_ptr,\n                      PidVector* const p_id_ptr) {\n  CHECK_NOTNULL(feature_ptr);\n  count_ = 0;\n  GetRoads(center_point, obstacle_phi, feature_ptr, p_id_ptr);\n  GetLanes(center_point, obstacle_phi, feature_ptr, p_id_ptr);\n  GetJunctions(center_point, obstacle_phi, feature_ptr, p_id_ptr);\n  GetCrosswalks(center_point, obstacle_phi, feature_ptr, p_id_ptr);\n  return true;\n}\n\nbool VectorNet::offline_query(const double obstacle_x, const double obstacle_y,\n                              const double obstacle_phi) {\n  return offline_query(obstacle_x,\n                       obstacle_y,\n                       obstacle_phi,\n                       FLAGS_prediction_target_file);\n}\n\nbool VectorNet::offline_query(const double obstacle_x,\n                              const double obstacle_y,\n                              const double obstacle_phi,\n                              const std::string file_name) {\n  FeatureVector offline_feature;\n  PidVector p_id;\n  common::PointENU center_point =\n      common::util::PointFactory::ToPointENU(obstacle_x, obstacle_y);\n  query(center_point, obstacle_phi, &offline_feature, &p_id);\n\n  apollo::prediction::VectorNetFeature vector_net_pb_;\n  vector_net_pb_.mutable_car_position()->set_x(obstacle_x);\n  vector_net_pb_.mutable_car_position()->set_y(obstacle_y);\n  vector_net_pb_.mutable_car_position()->set_phi(obstacle_phi);\n\n  size_t i = 0;\n  for (const auto& polyline : offline_feature) {\n    auto* polyline_pb = vector_net_pb_.add_polyline();\n    polyline_pb->set_p_id_x(p_id[i][0]);\n    polyline_pb->set_p_id_y(p_id[i][1]);\n    i++;\n    for (const auto& vector : polyline) {\n      auto* vector_pb = polyline_pb->add_vector();\n      for (const auto& element : vector) {\n        vector_pb->add_element(element);\n      }\n    }\n  }\n  cyber::common::SetProtoToASCIIFile(vector_net_pb_,\n                                     file_name);\n\n  return true;\n}\n\nvoid VectorNet::GetRoads(const common::PointENU& center_point,\n                         const double obstacle_phi,\n                         FeatureVector* const feature_ptr,\n                         PidVector* const p_id_ptr) {\n  std::vector<apollo::hdmap::RoadInfoConstPtr> roads;\n  apollo::hdmap::HDMapUtil::BaseMap().GetRoads(center_point,\n                                               FLAGS_road_distance, &roads);\n\n  for (const auto& road : roads) {\n    for (const auto& section : road->road().section()) {\n      for (const auto& edge : section.boundary().outer_polygon().edge()) {\n        std::vector<std::vector<double>> one_polyline;\n        std::vector<double> one_p_id{std::numeric_limits<float>::max(),\n                                     std::numeric_limits<float>::max()};\n        double start_length = 0;\n        BOUNDARY_TYPE bound_type = UNKNOW;\n        if (edge.type() == hdmap::BoundaryEdge::LEFT_BOUNDARY) {\n          bound_type = LEFT_BOUNDARY;\n        } else if (edge.type() == hdmap::BoundaryEdge::RIGHT_BOUNDARY) {\n          bound_type = RIGHT_BOUNDARY;\n        } else if (edge.type() == hdmap::BoundaryEdge::NORMAL) {\n          bound_type = NORMAL;\n        } else {\n          bound_type = UNKNOW;\n        }\n\n        for (const auto& segment : edge.curve().segment()) {\n          GetOnePolyline(segment.line_segment().point(), &start_length,\n                         center_point, obstacle_phi, ROAD, bound_type, count_,\n                         &one_polyline, &one_p_id);\n        }\n        if (one_polyline.size() == 0) continue;\n\n        feature_ptr->push_back(std::move(one_polyline));\n        p_id_ptr->push_back(std::move(one_p_id));\n        ++count_;\n      }\n    }\n  }\n}\n\nvoid VectorNet::GetLaneQueue(\n    const std::vector<hdmap::LaneInfoConstPtr>& lanes,\n    std::vector<std::deque<hdmap::LaneInfoConstPtr>>* const lane_deque_ptr) {\n  std::unordered_set<hdmap::LaneInfoConstPtr> lane_set(lanes.begin(),\n                                                       lanes.end());\n\n  while (!lane_set.empty()) {\n    std::deque<apollo::hdmap::LaneInfoConstPtr> one_lane_deque;\n    auto cur_lane = *lane_set.begin();\n    lane_set.erase(lane_set.begin());\n    one_lane_deque.push_back(cur_lane);\n    while (cur_lane->lane().successor_id_size() > 0) {\n      auto id = cur_lane->lane().successor_id(0);\n      cur_lane = apollo::hdmap::HDMapUtil::BaseMap().GetLaneById(id);\n      if (lane_set.find(cur_lane) != lane_set.end()) {\n        lane_set.erase(cur_lane);\n        one_lane_deque.push_back(cur_lane);\n      } else {\n        break;\n      }\n    }\n\n    cur_lane = one_lane_deque.front();\n    while (cur_lane->lane().predecessor_id_size() > 0) {\n      auto id = cur_lane->lane().predecessor_id(0);\n      cur_lane = apollo::hdmap::HDMapUtil::BaseMap().GetLaneById(id);\n      if (lane_set.find(cur_lane) != lane_set.end()) {\n        lane_set.erase(cur_lane);\n        one_lane_deque.push_front(cur_lane);\n      } else {\n        break;\n      }\n    }\n\n    lane_deque_ptr->push_back(one_lane_deque);\n  }\n}\n\nvoid VectorNet::GetLanes(const common::PointENU& center_point,\n                         const double obstacle_phi,\n                         FeatureVector* const feature_ptr,\n                         PidVector* const p_id_ptr) {\n  std::vector<apollo::hdmap::LaneInfoConstPtr> lanes;\n  apollo::hdmap::HDMapUtil::BaseMap().GetLanes(center_point,\n                                               FLAGS_road_distance, &lanes);\n\n  std::vector<std::deque<apollo::hdmap::LaneInfoConstPtr>> lane_deque_vector;\n  GetLaneQueue(lanes, &lane_deque_vector);\n\n  for (const auto& lane_deque : lane_deque_vector) {\n    // Draw lane's left_boundary\n    std::vector<std::vector<double>> left_polyline;\n    std::vector<double> left_p_id{std::numeric_limits<float>::max(),\n                                  std::numeric_limits<float>::max()};\n    double start_length = 0;\n    for (const auto& lane : lane_deque) {\n      std::cout << lane->lane().id().id() << \" \";\n      // if (lane->lane().left_boundary().virtual_()) continue;\n      for (const auto& segment :\n           lane->lane().left_boundary().curve().segment()) {\n        auto bound_type =\n            lane->lane().left_boundary().boundary_type(0).types(0);\n        GetOnePolyline(segment.line_segment().point(), &start_length,\n                       center_point, obstacle_phi, lane_attr_map.at(bound_type),\n                       LEFT_BOUNDARY, count_, &left_polyline, &left_p_id);\n      }\n    }\n\n    if (left_polyline.size() < 2) continue;\n    feature_ptr->push_back(std::move(left_polyline));\n    p_id_ptr->push_back(std::move(left_p_id));\n    ++count_;\n\n    std::vector<std::vector<double>> right_polyline;\n    std::vector<double> right_p_id{std::numeric_limits<float>::max(),\n                                   std::numeric_limits<float>::max()};\n    start_length = 0;\n    // Draw lane's right_boundary\n    for (const auto& lane : lane_deque) {\n      // if (lane->lane().right_boundary().virtual_()) continue;\n      for (const auto& segment :\n           lane->lane().right_boundary().curve().segment()) {\n        auto bound_type =\n            lane->lane().left_boundary().boundary_type(0).types(0);\n        GetOnePolyline(segment.line_segment().point(), &start_length,\n                       center_point, obstacle_phi, lane_attr_map.at(bound_type),\n                       RIGHT_BOUNDARY, count_, &right_polyline, &right_p_id);\n      }\n    }\n\n    if (right_polyline.size() < 2) continue;\n    feature_ptr->push_back(std::move(right_polyline));\n    p_id_ptr->push_back(std::move(right_p_id));\n    ++count_;\n  }\n}\n\nvoid VectorNet::GetJunctions(const common::PointENU& center_point,\n                             const double obstacle_phi,\n                             FeatureVector* const feature_ptr,\n                             PidVector* const p_id_ptr) {\n  std::vector<apollo::hdmap::JunctionInfoConstPtr> junctions;\n  apollo::hdmap::HDMapUtil::BaseMap().GetJunctions(\n      center_point, FLAGS_road_distance, &junctions);\n  for (const auto& junction : junctions) {\n    std::vector<std::vector<double>> one_polyline;\n    std::vector<double> one_p_id{std::numeric_limits<float>::max(),\n                                 std::numeric_limits<float>::max()};\n    double start_length = 0;\n    GetOnePolyline(junction->junction().polygon().point(), &start_length,\n                   center_point, obstacle_phi, JUNCTION, UNKNOW, count_,\n                   &one_polyline, &one_p_id);\n\n    feature_ptr->push_back(std::move(one_polyline));\n    p_id_ptr->push_back(std::move(one_p_id));\n    ++count_;\n  }\n}\n\nvoid VectorNet::GetCrosswalks(const common::PointENU& center_point,\n                              const double obstacle_phi,\n                              FeatureVector* const feature_ptr,\n                              PidVector* const p_id_ptr) {\n  std::vector<apollo::hdmap::CrosswalkInfoConstPtr> crosswalks;\n  apollo::hdmap::HDMapUtil::BaseMap().GetCrosswalks(\n      center_point, FLAGS_road_distance, &crosswalks);\n  for (const auto& crosswalk : crosswalks) {\n    std::vector<std::vector<double>> one_polyline;\n    std::vector<double> one_p_id{std::numeric_limits<float>::max(),\n                                 std::numeric_limits<float>::max()};\n    double start_length = 0;\n    GetOnePolyline(crosswalk->crosswalk().polygon().point(), &start_length,\n                   center_point, obstacle_phi, CROSSWALK, UNKNOW, count_,\n                   &one_polyline, &one_p_id);\n\n    feature_ptr->push_back(std::move(one_polyline));\n    p_id_ptr->push_back(std::move(one_p_id));\n    ++count_;\n  }\n}\n}  // namespace prediction\n}  // namespace apollo",
        "base_contents": "",
        "res_region": "/******************************************************************************\n * Copyright 2021 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *****************************************************************************/\n#include \"modules/prediction/pipeline/vector_net.h\"\n\n#include <cmath>\n#include <limits>\n#include <unordered_set>\n#include <utility>\n\n#include \"cyber/common/file.h\"\n\nnamespace apollo {\nnamespace prediction {\ntemplate <typename Points>\nvoid VectorNet::GetOnePolyline(\n    const Points& points, double* start_length,\n    const common::PointENU& center_point, const double obstacle_phi,\n    ATTRIBUTE_TYPE attr_type, BOUNDARY_TYPE bound_type, const int count,\n    std::vector<std::vector<double>>* const one_polyline,\n    std::vector<double>* const one_p_id) {\n  size_t size = points.size();\n  std::vector<double> s(size, 0);\n\n  for (size_t i = 1; i < size; ++i) {\n    s[i] = std::hypot(points.at(i).x() - points.at(i - 1).x(),\n                      points.at(i).y() - points.at(i - 1).y()) +\n           s[i - 1];\n  }\n\n  std::vector<double> x;\n  std::vector<double> y;\n  double cur_length = *start_length;\n\n  auto it_lower = std::lower_bound(s.begin(), s.end(), cur_length);\n  while (it_lower != s.end()) {\n    if (it_lower == s.begin()) {\n      x.push_back(points.at(0).x());\n      y.push_back(points.at(0).y());\n    } else {\n      const auto distance = std::distance(s.begin(), it_lower);\n      x.push_back(common::math::lerp(points.at(distance - 1).x(),\n                                     s[distance - 1], points.at(distance).x(),\n                                     s[distance], cur_length));\n      y.push_back(common::math::lerp(points.at(distance - 1).y(),\n                                     s[distance - 1], points.at(distance).y(),\n                                     s[distance], cur_length));\n    }\n    cur_length += FLAGS_point_distance;\n    it_lower = std::lower_bound(s.begin(), s.end(), cur_length);\n  }\n  size_t point_size = x.size();\n\n  *start_length = cur_length - s[size - 1];\n  if (point_size == 0) return;\n  const double attr = attribute_map.at(attr_type);\n  const double bound = boundary_map.at(bound_type);\n  auto last_point_after_rotate = common::math::RotateVector2d(\n      {x[0] - center_point.x(), y[0] - center_point.y()},\n      M_PI_2 - obstacle_phi);\n\n  for (size_t i = 1; i < point_size; ++i) {\n    if (one_p_id->at(0) > last_point_after_rotate.x()) {\n      one_p_id->at(0) = last_point_after_rotate.x();\n    }\n    if (one_p_id->at(1) > last_point_after_rotate.y()) {\n      one_p_id->at(1) = last_point_after_rotate.y();\n    }\n\n    std::vector<double> one_vector;\n\n    // d_s, d_e\n    one_vector.push_back(last_point_after_rotate.x());\n    one_vector.push_back(last_point_after_rotate.y());\n\n    Eigen::Vector2d point_after_rotate = common::math::RotateVector2d(\n        {x[i] - center_point.x(), y[i] - center_point.y()},\n        M_PI_2 - obstacle_phi);\n\n    one_vector.push_back(point_after_rotate.x());\n    one_vector.push_back(point_after_rotate.y());\n    last_point_after_rotate = std::move(point_after_rotate);\n\n    // attribute\n    one_vector.insert(one_vector.end(), {0.0, 0.0, attr, bound});\n\n    one_vector.push_back(count);\n    one_polyline->push_back(std::move(one_vector));\n  }\n}\n\nbool VectorNet::query(const common::PointENU& center_point,\n                      const double obstacle_phi,\n                      FeatureVector* const feature_ptr,\n                      PidVector* const p_id_ptr) {\n  CHECK_NOTNULL(feature_ptr);\n  count_ = 0;\n  GetRoads(center_point, obstacle_phi, feature_ptr, p_id_ptr);\n  GetLanes(center_point, obstacle_phi, feature_ptr, p_id_ptr);\n  GetJunctions(center_point, obstacle_phi, feature_ptr, p_id_ptr);\n  GetCrosswalks(center_point, obstacle_phi, feature_ptr, p_id_ptr);\n  return true;\n}\n\nbool VectorNet::offline_query(const double obstacle_x, const double obstacle_y,\n                              const double obstacle_phi) {\n  return offline_query(obstacle_x,\n                       obstacle_y,\n                       obstacle_phi,\n                       FLAGS_prediction_target_file);\n}\n\nbool VectorNet::offline_query(const double obstacle_x,\n                              const double obstacle_y,\n                              const double obstacle_phi,\n                              const std::string file_name) {\n  FeatureVector offline_feature;\n  PidVector p_id;\n  common::PointENU center_point =\n      common::util::PointFactory::ToPointENU(obstacle_x, obstacle_y);\n  query(center_point, obstacle_phi, &offline_feature, &p_id);\n\n  apollo::prediction::VectorNetFeature vector_net_pb_;\n  vector_net_pb_.mutable_car_position()->set_x(obstacle_x);\n  vector_net_pb_.mutable_car_position()->set_y(obstacle_y);\n  vector_net_pb_.mutable_car_position()->set_phi(obstacle_phi);\n\n  size_t i = 0;\n  for (const auto& polyline : offline_feature) {\n    auto* polyline_pb = vector_net_pb_.add_polyline();\n    polyline_pb->set_p_id_x(p_id[i][0]);\n    polyline_pb->set_p_id_y(p_id[i][1]);\n    i++;\n    for (const auto& vector : polyline) {\n      auto* vector_pb = polyline_pb->add_vector();\n      for (const auto& element : vector) {\n        vector_pb->add_element(element);\n      }\n    }\n  }\n  cyber::common::SetProtoToASCIIFile(vector_net_pb_,\n                                     file_name);\n\n  return true;\n}\n\nvoid VectorNet::GetRoads(const common::PointENU& center_point,\n                         const double obstacle_phi,\n                         FeatureVector* const feature_ptr,\n                         PidVector* const p_id_ptr) {\n  std::vector<apollo::hdmap::RoadInfoConstPtr> roads;\n  apollo::hdmap::HDMapUtil::BaseMap().GetRoads(center_point,\n                                               FLAGS_road_distance, &roads);\n\n  for (const auto& road : roads) {\n    for (const auto& section : road->road().section()) {\n      for (const auto& edge : section.boundary().outer_polygon().edge()) {\n        std::vector<std::vector<double>> one_polyline;\n        std::vector<double> one_p_id{std::numeric_limits<float>::max(),\n                                     std::numeric_limits<float>::max()};\n        double start_length = 0;\n        BOUNDARY_TYPE bound_type = UNKNOW;\n        if (edge.type() == hdmap::BoundaryEdge::LEFT_BOUNDARY) {\n          bound_type = LEFT_BOUNDARY;\n        } else if (edge.type() == hdmap::BoundaryEdge::RIGHT_BOUNDARY) {\n          bound_type = RIGHT_BOUNDARY;\n        } else if (edge.type() == hdmap::BoundaryEdge::NORMAL) {\n          bound_type = NORMAL;\n        } else {\n          bound_type = UNKNOW;\n        }\n\n        for (const auto& segment : edge.curve().segment()) {\n          GetOnePolyline(segment.line_segment().point(), &start_length,\n                         center_point, obstacle_phi, ROAD, bound_type, count_,\n                         &one_polyline, &one_p_id);\n        }\n        if (one_polyline.size() == 0) continue;\n\n        feature_ptr->push_back(std::move(one_polyline));\n        p_id_ptr->push_back(std::move(one_p_id));\n        ++count_;\n      }\n    }\n  }\n}\n\nvoid VectorNet::GetLaneQueue(\n    const std::vector<hdmap::LaneInfoConstPtr>& lanes,\n    std::vector<std::deque<hdmap::LaneInfoConstPtr>>* const lane_deque_ptr) {\n  std::unordered_set<hdmap::LaneInfoConstPtr> lane_set(lanes.begin(),\n                                                       lanes.end());\n\n  while (!lane_set.empty()) {\n    std::deque<apollo::hdmap::LaneInfoConstPtr> one_lane_deque;\n    auto cur_lane = *lane_set.begin();\n    lane_set.erase(lane_set.begin());\n    one_lane_deque.push_back(cur_lane);\n    while (cur_lane->lane().successor_id_size() > 0) {\n      auto id = cur_lane->lane().successor_id(0);\n      cur_lane = apollo::hdmap::HDMapUtil::BaseMap().GetLaneById(id);\n      if (lane_set.find(cur_lane) != lane_set.end()) {\n        lane_set.erase(cur_lane);\n        one_lane_deque.push_back(cur_lane);\n      } else {\n        break;\n      }\n    }\n\n    cur_lane = one_lane_deque.front();\n    while (cur_lane->lane().predecessor_id_size() > 0) {\n      auto id = cur_lane->lane().predecessor_id(0);\n      cur_lane = apollo::hdmap::HDMapUtil::BaseMap().GetLaneById(id);\n      if (lane_set.find(cur_lane) != lane_set.end()) {\n        lane_set.erase(cur_lane);\n        one_lane_deque.push_front(cur_lane);\n      } else {\n        break;\n      }\n    }\n\n    lane_deque_ptr->push_back(one_lane_deque);\n  }\n}\n\nvoid VectorNet::GetLanes(const common::PointENU& center_point,\n                         const double obstacle_phi,\n                         FeatureVector* const feature_ptr,\n                         PidVector* const p_id_ptr) {\n  std::vector<apollo::hdmap::LaneInfoConstPtr> lanes;\n  apollo::hdmap::HDMapUtil::BaseMap().GetLanes(center_point,\n                                               FLAGS_road_distance, &lanes);\n\n  std::vector<std::deque<apollo::hdmap::LaneInfoConstPtr>> lane_deque_vector;\n  GetLaneQueue(lanes, &lane_deque_vector);\n\n  for (const auto& lane_deque : lane_deque_vector) {\n    // Draw lane's left_boundary\n    std::vector<std::vector<double>> left_polyline;\n    std::vector<double> left_p_id{std::numeric_limits<float>::max(),\n                                  std::numeric_limits<float>::max()};\n    double start_length = 0;\n    for (const auto& lane : lane_deque) {\n      std::cout << lane->lane().id().id() << \" \";\n      // if (lane->lane().left_boundary().virtual_()) continue;\n      for (const auto& segment :\n           lane->lane().left_boundary().curve().segment()) {\n        auto bound_type =\n            lane->lane().left_boundary().boundary_type(0).types(0);\n        GetOnePolyline(segment.line_segment().point(), &start_length,\n                       center_point, obstacle_phi, lane_attr_map.at(bound_type),\n                       LEFT_BOUNDARY, count_, &left_polyline, &left_p_id);\n      }\n    }\n\n    if (left_polyline.size() < 2) continue;\n    feature_ptr->push_back(std::move(left_polyline));\n    p_id_ptr->push_back(std::move(left_p_id));\n    ++count_;\n\n    std::vector<std::vector<double>> right_polyline;\n    std::vector<double> right_p_id{std::numeric_limits<float>::max(),\n                                   std::numeric_limits<float>::max()};\n    start_length = 0;\n    // Draw lane's right_boundary\n    for (const auto& lane : lane_deque) {\n      // if (lane->lane().right_boundary().virtual_()) continue;\n      for (const auto& segment :\n           lane->lane().right_boundary().curve().segment()) {\n        auto bound_type =\n            lane->lane().left_boundary().boundary_type(0).types(0);\n        GetOnePolyline(segment.line_segment().point(), &start_length,\n                       center_point, obstacle_phi, lane_attr_map.at(bound_type),\n                       RIGHT_BOUNDARY, count_, &right_polyline, &right_p_id);\n      }\n    }\n\n    if (right_polyline.size() < 2) continue;\n    feature_ptr->push_back(std::move(right_polyline));\n    p_id_ptr->push_back(std::move(right_p_id));\n    ++count_;\n  }\n}\n\nvoid VectorNet::GetJunctions(const common::PointENU& center_point,\n                             const double obstacle_phi,\n                             FeatureVector* const feature_ptr,\n                             PidVector* const p_id_ptr) {\n  std::vector<apollo::hdmap::JunctionInfoConstPtr> junctions;\n  apollo::hdmap::HDMapUtil::BaseMap().GetJunctions(\n      center_point, FLAGS_road_distance, &junctions);\n  for (const auto& junction : junctions) {\n    std::vector<std::vector<double>> one_polyline;\n    std::vector<double> one_p_id{std::numeric_limits<float>::max(),\n                                 std::numeric_limits<float>::max()};\n    double start_length = 0;\n    GetOnePolyline(junction->junction().polygon().point(), &start_length,\n                   center_point, obstacle_phi, JUNCTION, UNKNOW, count_,\n                   &one_polyline, &one_p_id);\n\n    feature_ptr->push_back(std::move(one_polyline));\n    p_id_ptr->push_back(std::move(one_p_id));\n    ++count_;\n  }\n}\n\nvoid VectorNet::GetCrosswalks(const common::PointENU& center_point,\n                              const double obstacle_phi,\n                              FeatureVector* const feature_ptr,\n                              PidVector* const p_id_ptr) {\n  std::vector<apollo::hdmap::CrosswalkInfoConstPtr> crosswalks;\n  apollo::hdmap::HDMapUtil::BaseMap().GetCrosswalks(\n      center_point, FLAGS_road_distance, &crosswalks);\n  for (const auto& crosswalk : crosswalks) {\n    std::vector<std::vector<double>> one_polyline;\n    std::vector<double> one_p_id{std::numeric_limits<float>::max(),\n                                 std::numeric_limits<float>::max()};\n    double start_length = 0;\n    GetOnePolyline(crosswalk->crosswalk().polygon().point(), &start_length,\n                   center_point, obstacle_phi, CROSSWALK, UNKNOW, count_,\n                   &one_polyline, &one_p_id);\n\n    feature_ptr->push_back(std::move(one_polyline));\n    p_id_ptr->push_back(std::move(one_p_id));\n    ++count_;\n  }\n}\n}  // namespace prediction\n}  // namespace apollo",
        "lookback": " * Copyright 2021 The Apollo Authors. All Rights Reserved.",
        "lookahead": "",
        "label": [
            "base",
            "one_side_deletion"
        ],
        "start_line": 0,
        "end_line": 675,
        "merge_gen_region": " Copyright021 Alo Copyright021 Alo. Rights. Rights. * Licensed the Apache, 20theLicense *\"); you not this except in with the. * may a of License * may a of License * * httpwwwapacheorglicensesLICENSE20 * Unless by law agreed in, * under License distributed anAS\" BASIS * WARRANTIES CONDITIONS ANY, either or. See License the specific governing and limitations the License *****************************************************************************/includemodulespredictionpipelinevectorneth # <cmath # <>includelimits # <_>includeunorderedset # <> # \"utility # \"bercommonfileh namespacepol { namespace { templatetypename> Vector::::Oneline const&,******,* startlength const::ENU centerpoint const::::<::<::<>>* onepoly,::<>* onepid { sizet =.();::<> ssize 0 forsizet =; <;ii =::potpointsatix -.( -).x pointsat( - 1x(),.().y -.( -).()) s[ -]; }::<> x stdvectordouble y double_ =startlength auto_ =::_(..).()); else const distance stdvectordouble x",
        "confidence": 0.9315161108970642,
        "hesitated": false,
        "resolved": false
    }
]