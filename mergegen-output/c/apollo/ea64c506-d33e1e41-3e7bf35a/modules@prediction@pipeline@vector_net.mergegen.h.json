[
    {
        "a_contents": "/******************************************************************************\n * Copyright 2021 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n *implied. See the License for the specific language governing\n *permissions and limitations under the License.\n *****************************************************************************/\n\n#pragma once\n\n#include <deque>\n#include <map>\n#include <vector>\n\n#include \"modules/prediction/proto/vector_net.pb.h\"\n#include \"modules/common/math/linear_interpolation.h\"\n#include \"modules/common/util/point_factory.h\"\n#include \"modules/map/hdmap/hdmap_util.h\"\n#include \"modules/prediction/common/prediction_system_gflags.h\"\n\nnamespace apollo {\nnamespace prediction {\n\nusing FeatureVector = std::vector<std::vector<std::vector<double>>>;\nusing PidVector = std::vector<std::vector<double>>;\n\nenum ATTRIBUTE_TYPE {\n  ROAD,\n  LANE_UNKOWN,\n  LANE_DOTTED_YELLOW,\n  LANE_DOTTED_WHITE,\n  LANE_SOLID_YELLOW,\n  LANE_SOLID_WHITE,\n  LANE_DOUBLE_YELLOW,\n  LANE_CURB,\n  JUNCTION,\n  CROSSWALK,\n};\n\nenum BOUNDARY_TYPE {\n  UNKNOW,\n  NORMAL,\n  LEFT_BOUNDARY,\n  RIGHT_BOUNDARY,\n};\n\nclass VectorNet {\n public:\n  VectorNet() { apollo::hdmap::HDMapUtil::ReloadMaps(); }\n\n  ~VectorNet() = default;\n\n  bool query(const common::PointENU& center_point, const double obstacle_phi,\n             FeatureVector* const feature_ptr, PidVector* const p_id_ptr);\n\n  bool offline_query(const double obstacle_x, const double obstacle_y,\n                     const double obstacle_phi);\n\n private:\n  // TODO(Yiqun): 1.Left/Right boundary 2.Ordinal Encoding\n  const std::map<ATTRIBUTE_TYPE, double> attribute_map{\n      {ROAD, 0.0},\n      {LANE_UNKOWN, 1.0},\n      {LANE_DOTTED_YELLOW, 2.0},\n      {LANE_DOTTED_WHITE, 3.0},\n      {LANE_SOLID_YELLOW, 4.0},\n      {LANE_SOLID_WHITE, 5.0},\n      {LANE_DOUBLE_YELLOW, 6.0},\n      {LANE_CURB, 7.0},\n      {JUNCTION, 8.0},\n      {CROSSWALK, 9.0},\n  };\n\n  const std::map<BOUNDARY_TYPE, double> boundary_map{\n      {UNKNOW, 0.0}, {NORMAL, 1.0}, {LEFT_BOUNDARY, 2.0}, {RIGHT_BOUNDARY, 3.0},\n  };\n\n  const std::map<hdmap::LaneBoundaryType::Type, ATTRIBUTE_TYPE> lane_attr_map{\n      {hdmap::LaneBoundaryType::UNKNOWN, LANE_UNKOWN},\n      {hdmap::LaneBoundaryType::DOTTED_YELLOW, LANE_DOTTED_YELLOW},\n      {hdmap::LaneBoundaryType::DOTTED_WHITE, LANE_DOTTED_WHITE},\n      {hdmap::LaneBoundaryType::SOLID_YELLOW, LANE_SOLID_YELLOW},\n      {hdmap::LaneBoundaryType::SOLID_WHITE, LANE_SOLID_WHITE},\n      {hdmap::LaneBoundaryType::DOUBLE_YELLOW, LANE_DOUBLE_YELLOW},\n      {hdmap::LaneBoundaryType::CURB, LANE_CURB},\n  };\n\n  template <typename Points>\n  void GetOnePolyline(const Points& points, double* start_length,\n                      const common::PointENU& center_point,\n                      const double obstacle_phi, ATTRIBUTE_TYPE attr_type,\n                      BOUNDARY_TYPE bound_type, const int count,\n                      std::vector<std::vector<double>>* const one_polyline,\n                      std::vector<double>* const one_p_id);\n\n  void GetRoads(const common::PointENU& center_point, const double obstacle_phi,\n                FeatureVector* const feature_ptr, PidVector* const p_id_ptr);\n\n  void GetLaneQueue(\n      const std::vector<hdmap::LaneInfoConstPtr>& lanes,\n      std::vector<std::deque<hdmap::LaneInfoConstPtr>>* const lane_deque_ptr);\n\n  void GetLanes(const common::PointENU& center_point, const double obstacle_phi,\n                FeatureVector* const feature_ptr, PidVector* const p_id_ptr);\n  void GetJunctions(const common::PointENU& center_point,\n                    const double obstacle_phi, FeatureVector* const feature_ptr,\n                    PidVector* const p_id_ptr);\n  void GetCrosswalks(const common::PointENU& center_point,\n                     const double obstacle_phi,\n                     FeatureVector* const feature_ptr,\n                     PidVector* const p_id_ptr);\n  int count_ = 0;\n};\n\n}  // namespace prediction\n}  // namespace apollo",
        "b_contents": "/******************************************************************************\n * Copyright 2021 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n *implied. See the License for the specific language governing\n *permissions and limitations under the License.\n *****************************************************************************/\n\n#pragma once\n\n#include <deque>\n#include <map>\n#include <vector>\n#include <string>\n\n#include \"modules/prediction/proto/vector_net.pb.h\"\n#include \"modules/common/math/linear_interpolation.h\"\n#include \"modules/common/util/point_factory.h\"\n#include \"modules/map/hdmap/hdmap_util.h\"\n#include \"modules/prediction/common/prediction_system_gflags.h\"\n\nnamespace apollo {\nnamespace prediction {\n\nusing FeatureVector = std::vector<std::vector<std::vector<double>>>;\nusing PidVector = std::vector<std::vector<double>>;\n\nenum ATTRIBUTE_TYPE {\n  ROAD,\n  LANE_UNKOWN,\n  LANE_DOTTED_YELLOW,\n  LANE_DOTTED_WHITE,\n  LANE_SOLID_YELLOW,\n  LANE_SOLID_WHITE,\n  LANE_DOUBLE_YELLOW,\n  LANE_CURB,\n  JUNCTION,\n  CROSSWALK,\n};\n\nenum BOUNDARY_TYPE {\n  UNKNOW,\n  NORMAL,\n  LEFT_BOUNDARY,\n  RIGHT_BOUNDARY,\n};\n\nclass VectorNet {\n public:\n  VectorNet() { apollo::hdmap::HDMapUtil::ReloadMaps(); }\n\n  ~VectorNet() = default;\n\n  bool query(const common::PointENU& center_point, const double obstacle_phi,\n             FeatureVector* const feature_ptr, PidVector* const p_id_ptr);\n\n  bool offline_query(const double obstacle_x, const double obstacle_y,\n                     const double obstacle_phi);\n\n  bool offline_query(const double obstacle_x, const double obstacle_y,\n                     const double obstacle_phi, const std::string file_name);\n\n private:\n  // TODO(Yiqun): 1.Left/Right boundary 2.Ordinal Encoding\n  const std::map<ATTRIBUTE_TYPE, double> attribute_map{\n      {ROAD, 0.0},\n      {LANE_UNKOWN, 1.0},\n      {LANE_DOTTED_YELLOW, 2.0},\n      {LANE_DOTTED_WHITE, 3.0},\n      {LANE_SOLID_YELLOW, 4.0},\n      {LANE_SOLID_WHITE, 5.0},\n      {LANE_DOUBLE_YELLOW, 6.0},\n      {LANE_CURB, 7.0},\n      {JUNCTION, 8.0},\n      {CROSSWALK, 9.0},\n  };\n\n  const std::map<BOUNDARY_TYPE, double> boundary_map{\n      {UNKNOW, 0.0}, {NORMAL, 1.0}, {LEFT_BOUNDARY, 2.0}, {RIGHT_BOUNDARY, 3.0},\n  };\n\n  const std::map<hdmap::LaneBoundaryType::Type, ATTRIBUTE_TYPE> lane_attr_map{\n      {hdmap::LaneBoundaryType::UNKNOWN, LANE_UNKOWN},\n      {hdmap::LaneBoundaryType::DOTTED_YELLOW, LANE_DOTTED_YELLOW},\n      {hdmap::LaneBoundaryType::DOTTED_WHITE, LANE_DOTTED_WHITE},\n      {hdmap::LaneBoundaryType::SOLID_YELLOW, LANE_SOLID_YELLOW},\n      {hdmap::LaneBoundaryType::SOLID_WHITE, LANE_SOLID_WHITE},\n      {hdmap::LaneBoundaryType::DOUBLE_YELLOW, LANE_DOUBLE_YELLOW},\n      {hdmap::LaneBoundaryType::CURB, LANE_CURB},\n  };\n\n  template <typename Points>\n  void GetOnePolyline(const Points& points, double* start_length,\n                      const common::PointENU& center_point,\n                      const double obstacle_phi, ATTRIBUTE_TYPE attr_type,\n                      BOUNDARY_TYPE bound_type, const int count,\n                      std::vector<std::vector<double>>* const one_polyline,\n                      std::vector<double>* const one_p_id);\n\n  void GetRoads(const common::PointENU& center_point, const double obstacle_phi,\n                FeatureVector* const feature_ptr, PidVector* const p_id_ptr);\n\n  void GetLaneQueue(\n      const std::vector<hdmap::LaneInfoConstPtr>& lanes,\n      std::vector<std::deque<hdmap::LaneInfoConstPtr>>* const lane_deque_ptr);\n\n  void GetLanes(const common::PointENU& center_point, const double obstacle_phi,\n                FeatureVector* const feature_ptr, PidVector* const p_id_ptr);\n  void GetJunctions(const common::PointENU& center_point,\n                    const double obstacle_phi, FeatureVector* const feature_ptr,\n                    PidVector* const p_id_ptr);\n  void GetCrosswalks(const common::PointENU& center_point,\n                     const double obstacle_phi,\n                     FeatureVector* const feature_ptr,\n                     PidVector* const p_id_ptr);\n  int count_ = 0;\n};\n\n}  // namespace prediction\n}  // namespace apollo",
        "base_contents": "",
        "res_region": "/******************************************************************************\n * Copyright 2021 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n *implied. See the License for the specific language governing\n *permissions and limitations under the License.\n *****************************************************************************/\n\n#pragma once\n\n#include <deque>\n#include <map>\n#include <vector>\n#include <string>\n\n#include \"modules/prediction/proto/vector_net.pb.h\"\n#include \"modules/common/math/linear_interpolation.h\"\n#include \"modules/common/util/point_factory.h\"\n#include \"modules/map/hdmap/hdmap_util.h\"\n#include \"modules/prediction/common/prediction_system_gflags.h\"\n\nnamespace apollo {\nnamespace prediction {\n\nusing FeatureVector = std::vector<std::vector<std::vector<double>>>;\nusing PidVector = std::vector<std::vector<double>>;\n\nenum ATTRIBUTE_TYPE {\n  ROAD,\n  LANE_UNKOWN,\n  LANE_DOTTED_YELLOW,\n  LANE_DOTTED_WHITE,\n  LANE_SOLID_YELLOW,\n  LANE_SOLID_WHITE,\n  LANE_DOUBLE_YELLOW,\n  LANE_CURB,\n  JUNCTION,\n  CROSSWALK,\n};\n\nenum BOUNDARY_TYPE {\n  UNKNOW,\n  NORMAL,\n  LEFT_BOUNDARY,\n  RIGHT_BOUNDARY,\n};\n\nclass VectorNet {\n public:\n  VectorNet() { apollo::hdmap::HDMapUtil::ReloadMaps(); }\n\n  ~VectorNet() = default;\n\n  bool query(const common::PointENU& center_point, const double obstacle_phi,\n             FeatureVector* const feature_ptr, PidVector* const p_id_ptr);\n\n  bool offline_query(const double obstacle_x, const double obstacle_y,\n                     const double obstacle_phi);\n\n  bool offline_query(const double obstacle_x, const double obstacle_y,\n                     const double obstacle_phi, const std::string file_name);\n\n private:\n  // TODO(Yiqun): 1.Left/Right boundary 2.Ordinal Encoding\n  const std::map<ATTRIBUTE_TYPE, double> attribute_map{\n      {ROAD, 0.0},\n      {LANE_UNKOWN, 1.0},\n      {LANE_DOTTED_YELLOW, 2.0},\n      {LANE_DOTTED_WHITE, 3.0},\n      {LANE_SOLID_YELLOW, 4.0},\n      {LANE_SOLID_WHITE, 5.0},\n      {LANE_DOUBLE_YELLOW, 6.0},\n      {LANE_CURB, 7.0},\n      {JUNCTION, 8.0},\n      {CROSSWALK, 9.0},\n  };\n\n  const std::map<BOUNDARY_TYPE, double> boundary_map{\n      {UNKNOW, 0.0}, {NORMAL, 1.0}, {LEFT_BOUNDARY, 2.0}, {RIGHT_BOUNDARY, 3.0},\n  };\n\n  const std::map<hdmap::LaneBoundaryType::Type, ATTRIBUTE_TYPE> lane_attr_map{\n      {hdmap::LaneBoundaryType::UNKNOWN, LANE_UNKOWN},\n      {hdmap::LaneBoundaryType::DOTTED_YELLOW, LANE_DOTTED_YELLOW},\n      {hdmap::LaneBoundaryType::DOTTED_WHITE, LANE_DOTTED_WHITE},\n      {hdmap::LaneBoundaryType::SOLID_YELLOW, LANE_SOLID_YELLOW},\n      {hdmap::LaneBoundaryType::SOLID_WHITE, LANE_SOLID_WHITE},\n      {hdmap::LaneBoundaryType::DOUBLE_YELLOW, LANE_DOUBLE_YELLOW},\n      {hdmap::LaneBoundaryType::CURB, LANE_CURB},\n  };\n\n  template <typename Points>\n  void GetOnePolyline(const Points& points, double* start_length,\n                      const common::PointENU& center_point,\n                      const double obstacle_phi, ATTRIBUTE_TYPE attr_type,\n                      BOUNDARY_TYPE bound_type, const int count,\n                      std::vector<std::vector<double>>* const one_polyline,\n                      std::vector<double>* const one_p_id);\n\n  void GetRoads(const common::PointENU& center_point, const double obstacle_phi,\n                FeatureVector* const feature_ptr, PidVector* const p_id_ptr);\n\n  void GetLaneQueue(\n      const std::vector<hdmap::LaneInfoConstPtr>& lanes,\n      std::vector<std::deque<hdmap::LaneInfoConstPtr>>* const lane_deque_ptr);\n\n  void GetLanes(const common::PointENU& center_point, const double obstacle_phi,\n                FeatureVector* const feature_ptr, PidVector* const p_id_ptr);\n  void GetJunctions(const common::PointENU& center_point,\n                    const double obstacle_phi, FeatureVector* const feature_ptr,\n                    PidVector* const p_id_ptr);\n  void GetCrosswalks(const common::PointENU& center_point,\n                     const double obstacle_phi,\n                     FeatureVector* const feature_ptr,\n                     PidVector* const p_id_ptr);\n  int count_ = 0;\n};\n\n}  // namespace prediction\n}  // namespace apollo",
        "lookback": " * Copyright 2021 The Apollo Authors. All Rights Reserved.",
        "lookahead": "",
        "label": [
            "base",
            "one_side_deletion"
        ],
        "start_line": 0,
        "end_line": 255,
        "merge_gen_region": " Copyright021 Alo Authors All Reserved/****************************************************************************** Copyright021 Apol Authors All Reserved * Licensed the Apache, 20theLicense * may use file in with License * may a of License * may a of License * * httpwwwapacheorglicensesLICENSE20 * Unless by law agreed in, * to writing software distributed the is on \" IS BASIS * WARRANTIES CONDITIONS ANY, express * and limitations the License *****************************************************************************/pragma # <>includedeque # <>includemap # <vector # <modulespredictionprotovectornetpbh # \"modulescommonmathlinearinter.\"includemodulescommonutilpointfactoryh # \"modulesmaphd/maphd_..\"includemodulespredictioncommonpredictionsystemg.h namespacepol { namespace { Feature =::<::<::<::<::<>> usingid = stdvectorstdvectorstdvectordouble; ATTRIBUTETYPE RO,ANEUNK,ANEDOEDYELLOW L_TT_, L_TT_, L___,ANEDOUBLEYELLOW L_B JCTION CSS, enumUND_ { UNNOW NORMAL LEFTBOUNDARY RIGHTBOUNDARY }; Vector { public Vector() apol::mapHDUtilReload(); ~Net = default bool( commonPoint&_, doublestaclephi Feature* featureptr PVector const__",
        "confidence": 0.9297038316726685,
        "hesitated": false,
        "resolved": false
    }
]