[
    {
        "a_contents": "// only one lane one lane has one segment\nvoid OpenSpaceRoiDecider::GetInLaneEndPoint(LaneInfoConstPtr lane_info,\n                                           PointENU* left_boundary_point,\n                                           PointENU* right_boundary_point) {\n  const auto& left_boundary_segment =\n    lane_info->lane().left_boundary().curve().segment();\n  const auto& right_boundary_segment =\n    lane_info->lane().right_boundary().curve().segment();\n  size_t lane_points_num = left_boundary_segment[0].line_segment().point_size();\n  *left_boundary_point =\n    left_boundary_segment[0].line_segment().point(lane_points_num - 1);\n  *right_boundary_point =\n    right_boundary_segment[0].line_segment().point(lane_points_num - 1);\n}\n\nvoid OpenSpaceRoiDecider::GetOutLaneStartPoint(\n  LaneInfoConstPtr lane_info,\n  PointENU* left_boundary_point,\n  PointENU* right_boundary_point) {\n  const auto& left_boundary_segment =\n    lane_info->lane().left_boundary().curve().segment();\n  const auto& right_boundary_segment =\n    lane_info->lane().right_boundary().curve().segment();\n  *left_boundary_point =\n    left_boundary_segment[0].line_segment().point(0);\n  *right_boundary_point =\n    right_boundary_segment[0].line_segment().point(0);\n}\n\nvoid OpenSpaceRoiDecider::GetInLaneBoundaryPoints(LaneInfoConstPtr lane_info,\n                        const hdmap::Path &nearby_path,\n                        std::vector<PointENU>* In_left_boundary_points,\n                        std::vector<PointENU>* In_right_boundary_points) {\n  const auto& left_boundary_segment =\n    lane_info->lane().left_boundary().curve().segment();\n  const auto& right_boundary_segment =\n    lane_info->lane().right_boundary().curve().segment();\n  size_t lane_points_num = left_boundary_segment[0].line_segment().point_size();\n  int temp_record_left = 0;\n  int temp_record_right = 0;\n  std::vector<PointENU> left_points, right_points;\n  for (size_t i = 0; i < lane_points_num; ++i) {\n    left_points.push_back(left_boundary_segment[0].\n                          line_segment().point().at(i));\n    right_points.push_back(right_boundary_segment[0].\n                           line_segment().point().at(i));\n  }\n  // (to do): by s\n  for (size_t i = 0; i < lane_points_num; ++i) {\n    if (left_points[i].x() < temp_state_.x()) {\n      In_left_boundary_points->push_back(left_points[i]);\n      temp_record_left = i;\n    }\n    if (right_points[i].x() < temp_state_.x()) {\n      In_right_boundary_points->push_back(right_points[i]);\n      temp_record_right = i;\n    }\n  }\n  // add one point, bigger than vehicle x\n  if (left_points[temp_record_left - 1].x() > temp_state_.x()) {\n    In_left_boundary_points->push_back(left_points[temp_record_left - 1]);\n  }\n  if (right_points[temp_record_right - 1].x() > temp_state_.x()) {\n    In_right_boundary_points->push_back(right_points[temp_record_right - 1]);\n  }\n  std::reverse(In_right_boundary_points->begin(),\n               In_right_boundary_points->end());\n}\n\nvoid OpenSpaceRoiDecider::GetOutLaneBoundaryPoints(\n  LaneInfoConstPtr lane_info,\n  const hdmap::Path &nearby_path,\n  std::vector<PointENU>* Out_left_boundary_points,\n  std::vector<PointENU>* Out_right_boundary_points) {\n  const auto& left_boundary_segment =\n    lane_info->lane().left_boundary().curve().segment();\n  const auto& right_boundary_segment =\n    lane_info->lane().right_boundary().curve().segment();\n  size_t lane_points_num =\n    left_boundary_segment[0].line_segment().point_size();\n  int temp_record_left = 0;\n  int temp_record_right = 0;\n  std::vector<PointENU> left_points, right_points;\n  for (size_t i = 0; i < lane_points_num; ++i) {\n    left_points.push_back(left_boundary_segment[0].\n                          line_segment().point().at(i));\n    right_points.push_back(right_boundary_segment[0].\n                          line_segment().point().at(i));\n  }\n  // (to do): by s\n  for (size_t i = 0; i < lane_points_num; ++i) {\n    if (left_points[i].x() < routing_target_point_.x()) {\n      Out_left_boundary_points->push_back(left_points[i]);\n      temp_record_left = i;\n    }\n    if (right_points[i].x() < routing_target_point_.x()) {\n      Out_right_boundary_points->push_back(right_points[i]);\n      temp_record_right = i;\n    }\n  }\n  // add one point, bigger than vehicle x\n  if (left_points[temp_record_left + 1].x() > routing_target_point_.x()) {\n    Out_left_boundary_points->push_back(left_points[temp_record_left + 1]);\n  }\n  if (right_points[temp_record_right + 1].x() > routing_target_point_.x()) {\n    Out_right_boundary_points->push_back(right_points[temp_record_right + 1]);\n  }\n  std::reverse(Out_left_boundary_points->begin(),\n               Out_left_boundary_points->end());\n}\n\nbool OpenSpaceRoiDecider::GetDeadEndBoundary(\n  Frame* const frame, const std::vector<Vec2d> &dead_end_vertices,\n  const hdmap::Path &nearby_path,\n  std::vector<std::vector<common::math::Vec2d>> *const roi_deadend_boundary) {\n  size_t waypoint_num =\n    frame->local_view().routing->routing_request().waypoint().size();\n  routing_target_point_ = frame->local_view().routing->\n    routing_request().dead_end_info().target_point();\n  if (routing_in_flag_) {\n    routing_end_point_ = frame->local_view().routing->routing_request().\n                         waypoint().at(waypoint_num - 1).pose();\n    routing_in_flag_ = false;\n  }\n  double nearest_s = 0.0;\n  double nearest_l = 0.0;\n  LaneInfoConstPtr start_nearest_lane;\n  PointENU left_end_point, right_end_point;\n  hdmap_->GetNearestLane(routing_end_point_,\n    &start_nearest_lane, &nearest_s, &nearest_l);\n  GetInLaneEndPoint(start_nearest_lane, &left_end_point, &right_end_point);\n\n  LaneInfoConstPtr end_nearest_lane;\n  PointENU left_start_point, right_start_point;\n  hdmap_->GetNearestLane(routing_target_point_,\n    &end_nearest_lane, &nearest_s, &nearest_l);\n  GetOutLaneStartPoint(end_nearest_lane,\n                       &left_start_point,\n                       &right_start_point);\n\n  LaneInfoConstPtr car_lane;\n  PointENU car_pose;\n  car_pose.set_x(temp_state_.x());\n  car_pose.set_y(temp_state_.y());\n  hdmap_->GetNearestLane(car_pose, &car_lane, &nearest_s, &nearest_l);\n  std::vector<PointENU> In_left_boundary_points;\n  std::vector<PointENU> In_right_boundary_points;\n  GetInLaneBoundaryPoints(car_lane, nearby_path,\n                          &In_left_boundary_points,\n                          &In_right_boundary_points);\n\n  LaneInfoConstPtr target_lane;\n  double out_routing_x = routing_target_point_.x() + FLAGS_buffer_out_routing;\n  routing_target_point_.set_x(out_routing_x);\n  hdmap_->GetNearestLane(routing_target_point_,\n                         &target_lane,\n                         &nearest_s,\n                         &nearest_l);\n  std::vector<PointENU> Out_left_boundary_points;\n  std::vector<PointENU> Out_right_boundary_points;\n  GetOutLaneBoundaryPoints(target_lane,\n                           nearby_path,\n                           &Out_left_boundary_points,\n                           &Out_right_boundary_points);\n\n  std::vector<Vec2d> point_boundary;\n  for (size_t i = 0; i < In_right_boundary_points.size(); ++i) {\n    point_boundary.push_back({In_right_boundary_points[i].x(),\n                              In_right_boundary_points[i].y()});\n  }\n  point_boundary.push_back({right_end_point.x(), right_end_point.y()});\n  for (size_t i = 0; i < dead_end_vertices.size(); ++i) {\n    point_boundary.push_back(dead_end_vertices[i]);\n  }\n  point_boundary.push_back({right_start_point.x(), right_start_point.y()});\n  for (size_t i = 0; i < Out_right_boundary_points.size(); ++i) {\n    point_boundary.push_back({Out_right_boundary_points[i].x(),\n                              Out_right_boundary_points[i].y()});\n  }\n  for (size_t i = 0; i < Out_left_boundary_points.size(); ++i) {\n    point_boundary.push_back({Out_left_boundary_points[i].x(),\n                              Out_left_boundary_points[i].y()});\n  }\n  point_boundary.push_back({left_start_point.x(), left_start_point.y()});\n  point_boundary.push_back({left_end_point.x(), left_end_point.y()});\n  for (size_t i = 0; i < In_left_boundary_points.size(); ++i) {\n    point_boundary.push_back({In_left_boundary_points[i].x(),\n                              In_left_boundary_points[i].y()});\n  }\n  point_boundary.push_back({In_right_boundary_points[0].x(),\n                            In_right_boundary_points[0].y()});\n  const auto &origin_point = frame->open_space_info().origin_point();\n  const auto &origin_heading = frame->open_space_info().origin_heading();\n\n  for (size_t i = 0; i < point_boundary.size(); ++i) {\n    point_boundary[i] -= origin_point;\n    point_boundary[i].SelfRotate(-origin_heading);\n  }\n  // construct LineSegment\n  for (size_t i = 0; i < point_boundary.size(); ++i) {\n    std::vector<Vec2d> segment{point_boundary[i],\n                               point_boundary[i + 1]};\n    roi_deadend_boundary->push_back(segment);\n  }\n  // Fuse line segments into convex contraints\n  if (!FuseLineSegments(roi_deadend_boundary)) {\n    AERROR << \"FuseLineSegments failed in parking ROI\";\n    return false;\n  }\n  // Get xy boundary\n  auto xminmax = std::minmax_element(\n      point_boundary.begin(), point_boundary.end(),\n      [](const Vec2d &a, const Vec2d &b) { return a.x() < b.x(); });\n  auto yminmax = std::minmax_element(\n      point_boundary.begin(), point_boundary.end(),\n      [](const Vec2d &a, const Vec2d &b) { return a.y() < b.y(); });\n  std::vector<double> ROI_xy_boundary{xminmax.first->x(), xminmax.second->x(),\n                                      yminmax.first->y(), yminmax.second->y()};\n  auto *xy_boundary =\n      frame->mutable_open_space_info()->mutable_ROI_xy_boundary();\n  xy_boundary->assign(ROI_xy_boundary.begin(), ROI_xy_boundary.end());\n\n  Vec2d vehicle_xy = Vec2d(vehicle_state_.x(), vehicle_state_.y());\n  vehicle_xy -= origin_point;\n  vehicle_xy.SelfRotate(-origin_heading);\n\n  if (vehicle_xy.x() < ROI_xy_boundary[0] ||\n      vehicle_xy.x() > ROI_xy_boundary[1] ||\n      vehicle_xy.y() < ROI_xy_boundary[2] ||\n      vehicle_xy.y() > ROI_xy_boundary[3]) {\n    ADEBUG << \"vehicle outside of xy boundary of parking ROI\";\n    return false;\n  }\n  return true;\n}\n",
        "b_contents": "// only one lane one lane has one segment\nvoid OpenSpaceRoiDecider::GetInLaneEndPoint(LaneInfoConstPtr lane_info,\n                                           PointENU* left_boundary_point,\n                                           PointENU* right_boundary_point) {\n  const auto& left_boundary_segment =\n    lane_info->lane().left_boundary().curve().segment();\n  const auto& right_boundary_segment =\n    lane_info->lane().right_boundary().curve().segment();\n  size_t lane_points_num = left_boundary_segment[0].line_segment().point_size();\n  *left_boundary_point =\n    left_boundary_segment[0].line_segment().point(lane_points_num - 1);\n  *right_boundary_point =\n    right_boundary_segment[0].line_segment().point(lane_points_num - 1);\n}\n\nvoid OpenSpaceRoiDecider::GetOutLaneStartPoint(\n  LaneInfoConstPtr lane_info,\n  PointENU* left_boundary_point,\n  PointENU* right_boundary_point) {\n  const auto& left_boundary_segment =\n    lane_info->lane().left_boundary().curve().segment();\n  const auto& right_boundary_segment =\n    lane_info->lane().right_boundary().curve().segment();\n  *left_boundary_point =\n    left_boundary_segment[0].line_segment().point(0);\n  *right_boundary_point =\n    right_boundary_segment[0].line_segment().point(0);\n}\n\nvoid OpenSpaceRoiDecider::GetInLaneBoundaryPoints(LaneInfoConstPtr lane_info,\n                        const hdmap::Path &nearby_path,\n                        std::vector<PointENU>* In_left_boundary_points,\n                        std::vector<PointENU>* In_right_boundary_points) {\n  const auto& left_boundary_segment =\n    lane_info->lane().left_boundary().curve().segment();\n  const auto& right_boundary_segment =\n    lane_info->lane().right_boundary().curve().segment();\n  size_t lane_points_num =\n    left_boundary_segment[0].line_segment().point_size();\n  int temp_record_left = 0;\n  int temp_record_right = 0;\n  double left_point_s = 0.0;\n  double left_point_l = 0.0;\n  double right_point_s = 0.0;\n  double right_point_l = 0.0;\n  std::vector<double> left_s, right_s, left_l, right_l;\n  std::vector<PointENU> left_points, right_points;\n  double car_s, car_l;\n  Vec2d car_position = {temp_state_.x(), temp_state_.y()};\n  lane_info->GetProjection(car_position, &car_s, &car_l);\n  for (size_t i = 0; i < lane_points_num; ++i) {\n    PointENU left_point = left_boundary_segment[0].\n                          line_segment().point().at(i);\n    PointENU right_point = right_boundary_segment[0].\n                           line_segment().point().at(i);\n    left_points.push_back(left_point);\n    right_points.push_back(right_point);\n    Vec2d left_point_v = {left_boundary_segment[0].\n                        line_segment().point().at(i).x(),\n                        left_boundary_segment[0].\n                        line_segment().point().at(i).y()};\n    Vec2d right_point_v = {right_boundary_segment[0].\n                         line_segment().point().at(i).x(),\n                         right_boundary_segment[0].\n                         line_segment().point().at(i).y()};\n    lane_info->GetProjection(left_point_v, &left_point_s, &left_point_l);\n    lane_info->GetProjection(right_point_v, &right_point_s, &right_point_l);\n    if (left_point_s > car_s) {\n      In_left_boundary_points->push_back(left_point);\n      temp_record_left = i;\n    }\n    if (right_point_s > car_s) {\n      In_right_boundary_points->push_back(right_point);\n      temp_record_right = i;\n    }\n    left_s.push_back(left_point_s);\n    left_l.push_back(left_point_l);\n    right_s.push_back(right_point_s);\n    right_l.push_back(right_point_l);\n  }\n  if (left_s[temp_record_left - 1] < car_s) {\n    In_left_boundary_points->push_back(left_points[temp_record_left - 1]);\n  }\n  if (right_s[temp_record_right - 1] < car_s) {\n    In_right_boundary_points->push_back(right_points[temp_record_right - 1]);\n  }\n  std::reverse(In_right_boundary_points->begin(),\n               In_right_boundary_points->end());\n}\n\nvoid OpenSpaceRoiDecider::GetOutLaneBoundaryPoints(\n  LaneInfoConstPtr lane_info,\n  const hdmap::Path &nearby_path,\n  std::vector<PointENU>* Out_left_boundary_points,\n  std::vector<PointENU>* Out_right_boundary_points) {\n  const auto& left_boundary_segment =\n    lane_info->lane().left_boundary().curve().segment();\n  const auto& right_boundary_segment =\n    lane_info->lane().right_boundary().curve().segment();\n  size_t lane_points_num =\n    left_boundary_segment[0].line_segment().point_size();\n  int temp_record_left = 0;\n  int temp_record_right = 0;\n  double left_point_s = 0.0;\n  double left_point_l = 0.0;\n  double right_point_s = 0.0;\n  double right_point_l = 0.0;\n  std::vector<double> left_s, right_s, left_l, right_l;\n  std::vector<PointENU> left_points, right_points;\n  double target_point_s, target_point_l;\n  Vec2d target_position = {routing_target_point_.x(),\n                           routing_target_point_.y()};\n  lane_info->GetProjection(target_position, &target_point_s, &target_point_l);\n  for (size_t i = 0; i < lane_points_num; ++i) {\n    PointENU left_point = left_boundary_segment[0].\n                          line_segment().point().at(i);\n    PointENU right_point = right_boundary_segment[0].\n                           line_segment().point().at(i);\n    left_points.push_back(left_point);\n    right_points.push_back(right_point);\n    Vec2d left_point_v = {left_boundary_segment[0].\n                          line_segment().point().at(i).x(),\n                          left_boundary_segment[0].\n                          line_segment().point().at(i).y()};\n    Vec2d right_point_v = {right_boundary_segment[0].\n                           line_segment().point().at(i).x(),\n                           right_boundary_segment[0].\n                           line_segment().point().at(i).y()};\n    lane_info->GetProjection(left_point_v, &left_point_s, &left_point_l);\n    lane_info->GetProjection(right_point_v, &right_point_s, &right_point_l);\n    if (left_point_s < target_point_s) {\n      Out_left_boundary_points->push_back(left_point);\n      temp_record_left = i;\n    }\n    if (right_point_s < target_point_s) {\n      Out_right_boundary_points->push_back(right_point);\n      temp_record_right = i;\n    }\n    left_s.push_back(left_point_s);\n    left_l.push_back(left_point_l);\n    right_s.push_back(right_point_s);\n    right_l.push_back(right_point_l);\n  }\n  if (left_s[temp_record_left + 1] > target_point_s) {\n    Out_left_boundary_points->push_back(left_points[temp_record_left + 1]);\n  }\n  if (right_s[temp_record_right + 1] > target_point_s) {\n    Out_right_boundary_points->push_back(right_points[temp_record_right + 1]);\n  }\n  std::reverse(Out_left_boundary_points->begin(),\n               Out_left_boundary_points->end());\n}\n\nbool OpenSpaceRoiDecider::GetDeadEndBoundary(\n  Frame* const frame, const std::vector<Vec2d> &dead_end_vertices,\n  const hdmap::Path &nearby_path,\n  std::vector<std::vector<common::math::Vec2d>> *const roi_deadend_boundary) {\n  size_t waypoint_num =\n    frame->local_view().routing->routing_request().waypoint().size();\n  routing_target_point_ = frame->local_view().routing->\n    routing_request().dead_end_info().target_point();\n  if (routing_in_flag_) {\n    routing_end_point_ = frame->local_view().routing->routing_request().\n                         waypoint().at(waypoint_num - 1).pose();\n    routing_in_flag_ = false;\n  }\n  double nearest_s = 0.0;\n  double nearest_l = 0.0;\n  LaneInfoConstPtr start_nearest_lane;\n  PointENU left_end_point, right_end_point;\n  hdmap_->GetNearestLane(routing_end_point_,\n    &start_nearest_lane, &nearest_s, &nearest_l);\n  GetInLaneEndPoint(start_nearest_lane, &left_end_point, &right_end_point);\n\n  LaneInfoConstPtr end_nearest_lane;\n  PointENU left_start_point, right_start_point;\n  hdmap_->GetNearestLane(routing_target_point_,\n    &end_nearest_lane, &nearest_s, &nearest_l);\n  GetOutLaneStartPoint(end_nearest_lane,\n                       &left_start_point,\n                       &right_start_point);\n\n  LaneInfoConstPtr car_lane;\n  PointENU car_pose;\n  car_pose.set_x(temp_state_.x());\n  car_pose.set_y(temp_state_.y());\n  hdmap_->GetNearestLane(car_pose, &car_lane, &nearest_s, &nearest_l);\n  std::vector<PointENU> In_left_boundary_points;\n  std::vector<PointENU> In_right_boundary_points;\n  GetInLaneBoundaryPoints(car_lane, nearby_path,\n                          &In_left_boundary_points,\n                          &In_right_boundary_points);\n\n  LaneInfoConstPtr target_lane;\n  double out_routing_x = routing_target_point_.x() + FLAGS_buffer_out_routing;\n  routing_target_point_.set_x(out_routing_x);\n  hdmap_->GetNearestLane(routing_target_point_,\n                         &target_lane,\n                         &nearest_s,\n                         &nearest_l);\n  std::vector<PointENU> Out_left_boundary_points;\n  std::vector<PointENU> Out_right_boundary_points;\n  GetOutLaneBoundaryPoints(target_lane,\n                           nearby_path,\n                           &Out_left_boundary_points,\n                           &Out_right_boundary_points);\n\n  std::vector<Vec2d> point_boundary;\n  for (size_t i = 0; i < In_right_boundary_points.size(); ++i) {\n    point_boundary.push_back({In_right_boundary_points[i].x(),\n                              In_right_boundary_points[i].y()});\n  }\n  point_boundary.push_back({right_end_point.x(), right_end_point.y()});\n  for (size_t i = 0; i < dead_end_vertices.size(); ++i) {\n    point_boundary.push_back(dead_end_vertices[i]);\n  }\n  point_boundary.push_back({right_start_point.x(), right_start_point.y()});\n  for (size_t i = 0; i < Out_right_boundary_points.size(); ++i) {\n    point_boundary.push_back({Out_right_boundary_points[i].x(),\n                              Out_right_boundary_points[i].y()});\n  }\n  for (size_t i = 0; i < Out_left_boundary_points.size(); ++i) {\n    point_boundary.push_back({Out_left_boundary_points[i].x(),\n                              Out_left_boundary_points[i].y()});\n  }\n  point_boundary.push_back({left_start_point.x(), left_start_point.y()});\n  point_boundary.push_back({left_end_point.x(), left_end_point.y()});\n  for (size_t i = 0; i < In_left_boundary_points.size(); ++i) {\n    point_boundary.push_back({In_left_boundary_points[i].x(),\n                              In_left_boundary_points[i].y()});\n  }\n  point_boundary.push_back({In_right_boundary_points[0].x(),\n                            In_right_boundary_points[0].y()});\n  const auto &origin_point = frame->open_space_info().origin_point();\n  const auto &origin_heading = frame->open_space_info().origin_heading();\n  for (size_t i = 0; i < point_boundary.size(); ++i) {\n    point_boundary[i] -= origin_point;\n    point_boundary[i].SelfRotate(-origin_heading);\n  }\n  // construct LineSegment\n  for (size_t i = 0; i < point_boundary.size(); ++i) {\n    std::vector<Vec2d> segment{point_boundary[i],\n                               point_boundary[i + 1]};\n    roi_deadend_boundary->push_back(segment);\n  }\n  // Fuse line segments into convex contraints\n  if (!FuseLineSegments(roi_deadend_boundary)) {\n    AERROR << \"FuseLineSegments failed in parking ROI\";\n    return false;\n  }\n  // Get xy boundary\n  auto xminmax = std::minmax_element(\n      point_boundary.begin(), point_boundary.end(),\n      [](const Vec2d &a, const Vec2d &b) { return a.x() < b.x(); });\n  auto yminmax = std::minmax_element(\n      point_boundary.begin(), point_boundary.end(),\n      [](const Vec2d &a, const Vec2d &b) { return a.y() < b.y(); });\n  std::vector<double> ROI_xy_boundary{xminmax.first->x(), xminmax.second->x(),\n                                      yminmax.first->y(), yminmax.second->y()};\n  auto *xy_boundary =\n      frame->mutable_open_space_info()->mutable_ROI_xy_boundary();\n  xy_boundary->assign(ROI_xy_boundary.begin(), ROI_xy_boundary.end());\n\n  Vec2d vehicle_xy = Vec2d(vehicle_state_.x(), vehicle_state_.y());\n  vehicle_xy -= origin_point;\n  vehicle_xy.SelfRotate(-origin_heading);\n\n  if (vehicle_xy.x() < ROI_xy_boundary[0] ||\n      vehicle_xy.x() > ROI_xy_boundary[1] ||\n      vehicle_xy.y() < ROI_xy_boundary[2] ||\n      vehicle_xy.y() > ROI_xy_boundary[3]) {\n    ADEBUG << \"vehicle outside of xy boundary of parking ROI\";\n    return false;\n  }\n  return true;\n}\n",
        "base_contents": "",
        "res_region": "// only one lane one lane has one segment\nvoid OpenSpaceRoiDecider::GetInLaneEndPoint(LaneInfoConstPtr lane_info,\n                                           PointENU* left_boundary_point,\n                                           PointENU* right_boundary_point) {\n  const auto& left_boundary_segment =\n    lane_info->lane().left_boundary().curve().segment();\n  const auto& right_boundary_segment =\n    lane_info->lane().right_boundary().curve().segment();\n  size_t lane_points_num = left_boundary_segment[0].line_segment().point_size();\n  *left_boundary_point =\n    left_boundary_segment[0].line_segment().point(lane_points_num - 1);\n  *right_boundary_point =\n    right_boundary_segment[0].line_segment().point(lane_points_num - 1);\n}\n\nvoid OpenSpaceRoiDecider::GetOutLaneStartPoint(\n  LaneInfoConstPtr lane_info,\n  PointENU* left_boundary_point,\n  PointENU* right_boundary_point) {\n  const auto& left_boundary_segment =\n    lane_info->lane().left_boundary().curve().segment();\n  const auto& right_boundary_segment =\n    lane_info->lane().right_boundary().curve().segment();\n  *left_boundary_point =\n    left_boundary_segment[0].line_segment().point(0);\n  *right_boundary_point =\n    right_boundary_segment[0].line_segment().point(0);\n}\n\nvoid OpenSpaceRoiDecider::GetInLaneBoundaryPoints(LaneInfoConstPtr lane_info,\n                        const hdmap::Path &nearby_path,\n                        std::vector<PointENU>* In_left_boundary_points,\n                        std::vector<PointENU>* In_right_boundary_points) {\n  const auto& left_boundary_segment =\n    lane_info->lane().left_boundary().curve().segment();\n  const auto& right_boundary_segment =\n    lane_info->lane().right_boundary().curve().segment();\n  size_t lane_points_num =\n    left_boundary_segment[0].line_segment().point_size();\n  int temp_record_left = 0;\n  int temp_record_right = 0;\n  double left_point_s = 0.0;\n  double left_point_l = 0.0;\n  double right_point_s = 0.0;\n  double right_point_l = 0.0;\n  std::vector<double> left_s, right_s, left_l, right_l;\n  std::vector<PointENU> left_points, right_points;\n  double car_s, car_l;\n  Vec2d car_position = {temp_state_.x(), temp_state_.y()};\n  lane_info->GetProjection(car_position, &car_s, &car_l);\n  for (size_t i = 0; i < lane_points_num; ++i) {\n    PointENU left_point = left_boundary_segment[0].\n                          line_segment().point().at(i);\n    PointENU right_point = right_boundary_segment[0].\n                           line_segment().point().at(i);\n    left_points.push_back(left_point);\n    right_points.push_back(right_point);\n    Vec2d left_point_v = {left_boundary_segment[0].\n                        line_segment().point().at(i).x(),\n                        left_boundary_segment[0].\n                        line_segment().point().at(i).y()};\n    Vec2d right_point_v = {right_boundary_segment[0].\n                         line_segment().point().at(i).x(),\n                         right_boundary_segment[0].\n                         line_segment().point().at(i).y()};\n    lane_info->GetProjection(left_point_v, &left_point_s, &left_point_l);\n    lane_info->GetProjection(right_point_v, &right_point_s, &right_point_l);\n    if (left_point_s > car_s) {\n      In_left_boundary_points->push_back(left_point);\n      temp_record_left = i;\n    }\n    if (right_point_s > car_s) {\n      In_right_boundary_points->push_back(right_point);\n      temp_record_right = i;\n    }\n    left_s.push_back(left_point_s);\n    left_l.push_back(left_point_l);\n    right_s.push_back(right_point_s);\n    right_l.push_back(right_point_l);\n  }\n  if (left_s[temp_record_left - 1] < car_s) {\n    In_left_boundary_points->push_back(left_points[temp_record_left - 1]);\n  }\n  if (right_s[temp_record_right - 1] < car_s) {\n    In_right_boundary_points->push_back(right_points[temp_record_right - 1]);\n  }\n  std::reverse(In_right_boundary_points->begin(),\n               In_right_boundary_points->end());\n}\n\nvoid OpenSpaceRoiDecider::GetOutLaneBoundaryPoints(\n  LaneInfoConstPtr lane_info,\n  const hdmap::Path &nearby_path,\n  std::vector<PointENU>* Out_left_boundary_points,\n  std::vector<PointENU>* Out_right_boundary_points) {\n  const auto& left_boundary_segment =\n    lane_info->lane().left_boundary().curve().segment();\n  const auto& right_boundary_segment =\n    lane_info->lane().right_boundary().curve().segment();\n  size_t lane_points_num =\n    left_boundary_segment[0].line_segment().point_size();\n  int temp_record_left = 0;\n  int temp_record_right = 0;\n  double left_point_s = 0.0;\n  double left_point_l = 0.0;\n  double right_point_s = 0.0;\n  double right_point_l = 0.0;\n  std::vector<double> left_s, right_s, left_l, right_l;\n  std::vector<PointENU> left_points, right_points;\n  double target_point_s, target_point_l;\n  Vec2d target_position = {routing_target_point_.x(),\n                           routing_target_point_.y()};\n  lane_info->GetProjection(target_position, &target_point_s, &target_point_l);\n  for (size_t i = 0; i < lane_points_num; ++i) {\n    PointENU left_point = left_boundary_segment[0].\n                          line_segment().point().at(i);\n    PointENU right_point = right_boundary_segment[0].\n                           line_segment().point().at(i);\n    left_points.push_back(left_point);\n    right_points.push_back(right_point);\n    Vec2d left_point_v = {left_boundary_segment[0].\n                          line_segment().point().at(i).x(),\n                          left_boundary_segment[0].\n                          line_segment().point().at(i).y()};\n    Vec2d right_point_v = {right_boundary_segment[0].\n                           line_segment().point().at(i).x(),\n                           right_boundary_segment[0].\n                           line_segment().point().at(i).y()};\n    lane_info->GetProjection(left_point_v, &left_point_s, &left_point_l);\n    lane_info->GetProjection(right_point_v, &right_point_s, &right_point_l);\n    if (left_point_s < target_point_s) {\n      Out_left_boundary_points->push_back(left_point);\n      temp_record_left = i;\n    }\n    if (right_point_s < target_point_s) {\n      Out_right_boundary_points->push_back(right_point);\n      temp_record_right = i;\n    }\n    left_s.push_back(left_point_s);\n    left_l.push_back(left_point_l);\n    right_s.push_back(right_point_s);\n    right_l.push_back(right_point_l);\n  }\n  if (left_s[temp_record_left + 1] > target_point_s) {\n    Out_left_boundary_points->push_back(left_points[temp_record_left + 1]);\n  }\n  if (right_s[temp_record_right + 1] > target_point_s) {\n    Out_right_boundary_points->push_back(right_points[temp_record_right + 1]);\n  }\n  std::reverse(Out_left_boundary_points->begin(),\n               Out_left_boundary_points->end());\n}\n\nbool OpenSpaceRoiDecider::GetDeadEndBoundary(\n  Frame* const frame, const std::vector<Vec2d> &dead_end_vertices,\n  const hdmap::Path &nearby_path,\n  std::vector<std::vector<common::math::Vec2d>> *const roi_deadend_boundary) {\n  size_t waypoint_num =\n    frame->local_view().routing->routing_request().waypoint().size();\n  routing_target_point_ = frame->local_view().routing->\n    routing_request().dead_end_info().target_point();\n  if (routing_in_flag_) {\n    routing_end_point_ = frame->local_view().routing->routing_request().\n                         waypoint().at(waypoint_num - 1).pose();\n    routing_in_flag_ = false;\n  }\n  double nearest_s = 0.0;\n  double nearest_l = 0.0;\n  LaneInfoConstPtr start_nearest_lane;\n  PointENU left_end_point, right_end_point;\n  hdmap_->GetNearestLane(routing_end_point_,\n    &start_nearest_lane, &nearest_s, &nearest_l);\n  GetInLaneEndPoint(start_nearest_lane, &left_end_point, &right_end_point);\n\n  LaneInfoConstPtr end_nearest_lane;\n  PointENU left_start_point, right_start_point;\n  hdmap_->GetNearestLane(routing_target_point_,\n    &end_nearest_lane, &nearest_s, &nearest_l);\n  GetOutLaneStartPoint(end_nearest_lane,\n                       &left_start_point,\n                       &right_start_point);\n\n  LaneInfoConstPtr car_lane;\n  PointENU car_pose;\n  car_pose.set_x(temp_state_.x());\n  car_pose.set_y(temp_state_.y());\n  hdmap_->GetNearestLane(car_pose, &car_lane, &nearest_s, &nearest_l);\n  std::vector<PointENU> In_left_boundary_points;\n  std::vector<PointENU> In_right_boundary_points;\n  GetInLaneBoundaryPoints(car_lane, nearby_path,\n                          &In_left_boundary_points,\n                          &In_right_boundary_points);\n\n  LaneInfoConstPtr target_lane;\n  double out_routing_x = routing_target_point_.x() + FLAGS_buffer_out_routing;\n  routing_target_point_.set_x(out_routing_x);\n  hdmap_->GetNearestLane(routing_target_point_,\n                         &target_lane,\n                         &nearest_s,\n                         &nearest_l);\n  std::vector<PointENU> Out_left_boundary_points;\n  std::vector<PointENU> Out_right_boundary_points;\n  GetOutLaneBoundaryPoints(target_lane,\n                           nearby_path,\n                           &Out_left_boundary_points,\n                           &Out_right_boundary_points);\n\n  std::vector<Vec2d> point_boundary;\n  for (size_t i = 0; i < In_right_boundary_points.size(); ++i) {\n    point_boundary.push_back({In_right_boundary_points[i].x(),\n                              In_right_boundary_points[i].y()});\n  }\n  point_boundary.push_back({right_end_point.x(), right_end_point.y()});\n  for (size_t i = 0; i < dead_end_vertices.size(); ++i) {\n    point_boundary.push_back(dead_end_vertices[i]);\n  }\n  point_boundary.push_back({right_start_point.x(), right_start_point.y()});\n  for (size_t i = 0; i < Out_right_boundary_points.size(); ++i) {\n    point_boundary.push_back({Out_right_boundary_points[i].x(),\n                              Out_right_boundary_points[i].y()});\n  }\n  for (size_t i = 0; i < Out_left_boundary_points.size(); ++i) {\n    point_boundary.push_back({Out_left_boundary_points[i].x(),\n                              Out_left_boundary_points[i].y()});\n  }\n  point_boundary.push_back({left_start_point.x(), left_start_point.y()});\n  point_boundary.push_back({left_end_point.x(), left_end_point.y()});\n  for (size_t i = 0; i < In_left_boundary_points.size(); ++i) {\n    point_boundary.push_back({In_left_boundary_points[i].x(),\n                              In_left_boundary_points[i].y()});\n  }\n  point_boundary.push_back({In_right_boundary_points[0].x(),\n                            In_right_boundary_points[0].y()});\n  const auto &origin_point = frame->open_space_info().origin_point();\n  const auto &origin_heading = frame->open_space_info().origin_heading();\n  for (size_t i = 0; i < point_boundary.size(); ++i) {\n    point_boundary[i] -= origin_point;\n    point_boundary[i].SelfRotate(-origin_heading);\n  }\n  // construct LineSegment\n  for (size_t i = 0; i < point_boundary.size(); ++i) {\n    std::vector<Vec2d> segment{point_boundary[i],\n                               point_boundary[i + 1]};\n    roi_deadend_boundary->push_back(segment);\n  }\n  // Fuse line segments into convex contraints\n  if (!FuseLineSegments(roi_deadend_boundary)) {\n    AERROR << \"FuseLineSegments failed in parking ROI\";\n    return false;\n  }\n  // Get xy boundary\n  auto xminmax = std::minmax_element(\n      point_boundary.begin(), point_boundary.end(),\n      [](const Vec2d &a, const Vec2d &b) { return a.x() < b.x(); });\n  auto yminmax = std::minmax_element(\n      point_boundary.begin(), point_boundary.end(),\n      [](const Vec2d &a, const Vec2d &b) { return a.y() < b.y(); });\n  std::vector<double> ROI_xy_boundary{xminmax.first->x(), xminmax.second->x(),\n                                      yminmax.first->y(), yminmax.second->y()};\n  auto *xy_boundary =\n      frame->mutable_open_space_info()->mutable_ROI_xy_boundary();\n  xy_boundary->assign(ROI_xy_boundary.begin(), ROI_xy_boundary.end());\n\n  Vec2d vehicle_xy = Vec2d(vehicle_state_.x(), vehicle_state_.y());\n  vehicle_xy -= origin_point;\n  vehicle_xy.SelfRotate(-origin_heading);\n\n  if (vehicle_xy.x() < ROI_xy_boundary[0] ||\n      vehicle_xy.x() > ROI_xy_boundary[1] ||\n      vehicle_xy.y() < ROI_xy_boundary[2] ||\n      vehicle_xy.y() > ROI_xy_boundary[3]) {\n    ADEBUG << \"vehicle outside of xy boundary of parking ROI\";\n    return false;\n  }\n  return true;\n}\n",
        "lookback": "void OpenSpaceRoiDecider::GetInLaneEndPoint(LaneInfoConstPtr lane_info,",
        "lookahead": "bool OpenSpaceRoiDecider::GetParkingBoundary(",
        "label": [
            "base",
            "one_side_deletion"
        ],
        "start_line": 814,
        "end_line": 1330,
        "merge_gen_region": null,
        "confidence": 0.7521801590919495,
        "hesitated": true
    }
]