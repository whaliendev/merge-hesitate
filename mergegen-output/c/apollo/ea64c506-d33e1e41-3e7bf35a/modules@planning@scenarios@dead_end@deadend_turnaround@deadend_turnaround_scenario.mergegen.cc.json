[
    {
        "a_contents": "/******************************************************************************\n * Copyright 2021 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *****************************************************************************/\n\n/**\n * @file\n **/\n#include \"modules/planning/scenarios/dead_end/deadend_turnaround/deadend_turnaround_scenario.h\"\n#include \"modules/planning/scenarios/dead_end/deadend_turnaround/stage_approaching_turning_point.h\"\n#include \"modules/planning/scenarios/dead_end/deadend_turnaround/stage_turning.h\"\n\nnamespace apollo {\nnamespace planning {\nnamespace scenario {\nnamespace deadend_turnaround {\n\nusing apollo::common::VehicleState;\nusing apollo::common::math::Vec2d;\nusing apollo::hdmap::ParkingSpaceInfoConstPtr;\nusing apollo::hdmap::Path;\nusing apollo::hdmap::PathOverlap;\nusing apollo::common::PointENU;\nusing apollo::hdmap::HDMapUtil;\nusing apollo::hdmap::JunctionInfoConstPtr;\nusing apollo::routing::RoutingRequest;\nusing apollo::common::math::Polygon2d;\nusing apollo::common::math::LineSegment2d;\n\napollo::common::util::Factory<\n    ScenarioConfig::StageType, Stage,\n    Stage* (*)(const ScenarioConfig::StageConfig& stage_config,\n               const std::shared_ptr<DependencyInjector>& injector)>\n    DeadEndTurnAroundScenario::s_stage_factory_;\n\nvoid DeadEndTurnAroundScenario::Init() {\n  if (init_) {\n    return;\n  }\n  Scenario::Init();\n  if (!GetScenarioConfig()) {\n    return;\n  }\n\n  hdmap_ = hdmap::HDMapUtil::BaseMapPtr();\n  CHECK_NOTNULL(hdmap_);\n}\n\nvoid DeadEndTurnAroundScenario::RegisterStages() {\n  if (s_stage_factory_.Empty()) {\n    s_stage_factory_.Clear();\n  }\n  s_stage_factory_.Register(\n      ScenarioConfig::DEADEND_TURNAROUND_APPROACHING_TURNING_POINT,\n      [](const ScenarioConfig::StageConfig& config,\n         const std::shared_ptr<DependencyInjector>& injector) -> Stage* {\n        return new StageApproachingTurningPoint(config, injector);\n      });\n  s_stage_factory_.Register(\n      ScenarioConfig::DEADEND_TURNAROUND_TURNING,\n      [](const ScenarioConfig::StageConfig& config,\n         const std::shared_ptr<DependencyInjector>& injector) -> Stage* {\n        return new StageTurning(config, injector);\n      });\n}\n\nstd::unique_ptr<Stage> DeadEndTurnAroundScenario::CreateStage(\n    const ScenarioConfig::StageConfig& stage_config,\n    const std::shared_ptr<DependencyInjector>& injector) {\n  if (s_stage_factory_.Empty()) {\n    RegisterStages();\n  }\n  auto ptr = s_stage_factory_.CreateObjectOrNull(stage_config.stage_type(),\n                                                 stage_config, injector);\n  if (ptr) {\n    ptr->SetContext(&context_);\n  }\n  return ptr;\n}\n\nbool DeadEndTurnAroundScenario::GetScenarioConfig() {\n  if (!config_.has_deadend_turnaround_config()) {\n    return false;\n  }\n  context_.scenario_config.CopyFrom(config_.deadend_turnaround_config());\n  return true;\n}\n\nbool DeadEndTurnAroundScenario::IsTransferable(\n  const Frame& frame,\n  const PointENU& dead_end_point,\n  const double dead_end_start_range) {\n  std::string target_dead_end_id;\n  // vaild check\n  const hdmap::HDMap* base_map_ptr = hdmap::HDMapUtil::BaseMapPtr();\n  std::vector<JunctionInfoConstPtr> junctions;\n  JunctionInfoConstPtr junction;\n  if (base_map_ptr->GetJunctions(dead_end_point, 1.0, &junctions) != 0) {\n    ADEBUG << \"Fail to get junctions from base_map.\";\n    return false;\n  }\n  if (junctions.size() <= 0) {\n    ADEBUG << \"No junction from map\";\n    return false;\n  }\n  if (!SelectTargetDeadEndJunction(&junctions, dead_end_point, &junction)) {\n    ADEBUG << \"Target Dead End not found\";\n    return false;\n  }\n  target_dead_end_id = junction->id().id();\n  const auto& vehicle_state = frame.vehicle_state();\n  const auto& nearby_path =\n      frame.reference_line_info().front().reference_line().map_path();\n  if (!CheckDistanceToDeadEnd(vehicle_state,\n                              nearby_path,\n                              dead_end_start_range,\n                              &junction)) {\n    ADEBUG << \"Dead end found, but too far, distance larger than \"\n              \"pre-defined distance \"\n           << target_dead_end_id;\n    return false;\n  }\n  return true;\n}\n\nbool DeadEndTurnAroundScenario::SelectTargetDeadEndJunction(\n    std::vector<JunctionInfoConstPtr>* junctions,\n    const apollo::common::PointENU& dead_end_point,\n    JunctionInfoConstPtr* target_junction) {\n  Vec2d start_point;\n  start_point.set_x(dead_end_point.x());\n  start_point.set_y(dead_end_point.y());\n  // warning: the car only be the one junction\n  size_t junction_num = junctions->size();\n  if (junction_num <= 0) {\n    ADEBUG << \"No junctions frim map\";\n    return false;\n  }\n  for (size_t i = 0; i < junction_num; ++i) {\n    if (junctions->at(i)->junction().type() == 5) {\n      Polygon2d polygon = junctions->at(i)->polygon();\n      // judge dead end point in the select junction\n      if (polygon.IsPointIn(start_point)) {\n        *target_junction = junctions->at(i);\n        return true;\n      } else {\n        return false;\n      }\n    } else {\n      ADEBUG << \"No dead end junction\";\n      return false;\n    }\n  }\n  return true;\n}\n\nbool DeadEndTurnAroundScenario::CheckDistanceToDeadEnd(\n    const VehicleState& vehicle_state,\n    const Path& nearby_path,\n    const double dead_end_start_range,\n    JunctionInfoConstPtr* junction) {\n  const Vec2d& car_position = {vehicle_state.x(), vehicle_state.y()};\n  auto junction_polygon = (*junction)->polygon();\n  return std::abs(junction_polygon.DistanceTo(car_position)) <\n         dead_end_start_range;\n}\n\n}  // namespace deadend_turnaround\n}  // namespace scenario\n}  // namespace planning\n}  // namespace apollo",
        "b_contents": "/******************************************************************************\n * Copyright 2021 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *****************************************************************************/\n\n/**\n * @file\n **/\n#include \"modules/planning/scenarios/dead_end/deadend_turnaround/deadend_turnaround_scenario.h\"\n#include \"modules/planning/scenarios/dead_end/deadend_turnaround/stage_approaching_turning_point.h\"\n#include \"modules/planning/scenarios/dead_end/deadend_turnaround/stage_turning.h\"\n\nnamespace apollo {\nnamespace planning {\nnamespace scenario {\nnamespace deadend_turnaround {\n\nusing apollo::common::VehicleState;\nusing apollo::common::math::Vec2d;\nusing apollo::hdmap::ParkingSpaceInfoConstPtr;\nusing apollo::hdmap::Path;\nusing apollo::hdmap::PathOverlap;\nusing apollo::common::PointENU;\nusing apollo::hdmap::HDMapUtil;\nusing apollo::hdmap::JunctionInfoConstPtr;\nusing apollo::routing::RoutingRequest;\nusing apollo::common::math::Polygon2d;\nusing apollo::common::math::LineSegment2d;\n\napollo::common::util::Factory<\n    ScenarioConfig::StageType, Stage,\n    Stage* (*)(const ScenarioConfig::StageConfig& stage_config,\n               const std::shared_ptr<DependencyInjector>& injector)>\n    DeadEndTurnAroundScenario::s_stage_factory_;\n\nvoid DeadEndTurnAroundScenario::Init() {\n  if (init_) {\n    return;\n  }\n  Scenario::Init();\n  if (!GetScenarioConfig()) {\n    return;\n  }\n\n  hdmap_ = hdmap::HDMapUtil::BaseMapPtr();\n  CHECK_NOTNULL(hdmap_);\n}\n\nvoid DeadEndTurnAroundScenario::RegisterStages() {\n  if (s_stage_factory_.Empty()) {\n    s_stage_factory_.Clear();\n  }\n  s_stage_factory_.Register(\n      ScenarioConfig::DEADEND_TURNAROUND_APPROACHING_TURNING_POINT,\n      [](const ScenarioConfig::StageConfig& config,\n         const std::shared_ptr<DependencyInjector>& injector) -> Stage* {\n        return new StageApproachingTurningPoint(config, injector);\n      });\n  s_stage_factory_.Register(\n      ScenarioConfig::DEADEND_TURNAROUND_TURNING,\n      [](const ScenarioConfig::StageConfig& config,\n         const std::shared_ptr<DependencyInjector>& injector) -> Stage* {\n        return new StageTurning(config, injector);\n      });\n}\n\nstd::unique_ptr<Stage> DeadEndTurnAroundScenario::CreateStage(\n    const ScenarioConfig::StageConfig& stage_config,\n    const std::shared_ptr<DependencyInjector>& injector) {\n  if (s_stage_factory_.Empty()) {\n    RegisterStages();\n  }\n  auto ptr = s_stage_factory_.CreateObjectOrNull(stage_config.stage_type(),\n                                                 stage_config, injector);\n  if (ptr) {\n    ptr->SetContext(&context_);\n  }\n  return ptr;\n}\n\nbool DeadEndTurnAroundScenario::GetScenarioConfig() {\n  if (!config_.has_deadend_turnaround_config()) {\n    return false;\n  }\n  context_.scenario_config.CopyFrom(config_.deadend_turnaround_config());\n  return true;\n}\n\nbool DeadEndTurnAroundScenario::IsTransferable(\n  const Frame& frame,\n  const PointENU& dead_end_point,\n  const double dead_end_start_range) {\n  std::string target_dead_end_id;\n  const auto& routing_type =\n      frame.local_view().routing->routing_request().dead_end_info().\n      dead_end_routing_type();\n  if (routing_type != routing::ROUTING_IN &&\n      routing_type != routing::ROUTING_OUT) {\n    ADEBUG << \"falied to get dead end routing task\";\n    return false;\n  }\n  // vaild check\n  const hdmap::HDMap* base_map_ptr = hdmap::HDMapUtil::BaseMapPtr();\n  std::vector<JunctionInfoConstPtr> junctions;\n  JunctionInfoConstPtr junction;\n  if (base_map_ptr->GetJunctions(dead_end_point, 1.0, &junctions) != 0) {\n    ADEBUG << \"Fail to get junctions from base_map.\";\n    return false;\n  }\n  if (junctions.size() <= 0) {\n    ADEBUG << \"No junction from map\";\n    return false;\n  }\n  if (!SelectTargetDeadEndJunction(&junctions, dead_end_point, &junction)) {\n    ADEBUG << \"Target Dead End not found\";\n    return false;\n  }\n  target_dead_end_id = junction->id().id();\n  const auto& vehicle_state = frame.vehicle_state();\n  const auto& nearby_path =\n      frame.reference_line_info().front().reference_line().map_path();\n  if (!CheckDistanceToDeadEnd(vehicle_state,\n                              nearby_path,\n                              dead_end_start_range,\n                              &junction)) {\n    ADEBUG << \"Dead end found, but too far, distance larger than \"\n              \"pre-defined distance \"\n           << target_dead_end_id;\n    return false;\n  }\n  return true;\n}\n\nbool DeadEndTurnAroundScenario::SelectTargetDeadEndJunction(\n    std::vector<JunctionInfoConstPtr>* junctions,\n    const apollo::common::PointENU& dead_end_point,\n    JunctionInfoConstPtr* target_junction) {\n  Vec2d start_point;\n  start_point.set_x(dead_end_point.x());\n  start_point.set_y(dead_end_point.y());\n  // warning: the car only be the one junction\n  size_t junction_num = junctions->size();\n  if (junction_num <= 0) {\n    ADEBUG << \"No junctions frim map\";\n    return false;\n  }\n  for (size_t i = 0; i < junction_num; ++i) {\n    if (junctions->at(i)->junction().type() == 5) {\n      Polygon2d polygon = junctions->at(i)->polygon();\n      // judge dead end point in the select junction\n      if (polygon.IsPointIn(start_point)) {\n        *target_junction = junctions->at(i);\n        return true;\n      } else {\n        return false;\n      }\n    } else {\n      ADEBUG << \"No dead end junction\";\n      return false;\n    }\n  }\n  return true;\n}\n\nbool DeadEndTurnAroundScenario::CheckDistanceToDeadEnd(\n    const VehicleState& vehicle_state,\n    const Path& nearby_path,\n    const double dead_end_start_range,\n    JunctionInfoConstPtr* junction) {\n  const Vec2d& car_position = {vehicle_state.x(), vehicle_state.y()};\n  auto junction_polygon = (*junction)->polygon();\n  return std::abs(junction_polygon.DistanceTo(car_position)) <\n         dead_end_start_range;\n}\n\n}  // namespace deadend_turnaround\n}  // namespace scenario\n}  // namespace planning\n}  // namespace apollo",
        "base_contents": "",
        "res_region": "/******************************************************************************\n * Copyright 2021 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *****************************************************************************/\n\n/**\n * @file\n **/\n#include \"modules/planning/scenarios/dead_end/deadend_turnaround/deadend_turnaround_scenario.h\"\n#include \"modules/planning/scenarios/dead_end/deadend_turnaround/stage_approaching_turning_point.h\"\n#include \"modules/planning/scenarios/dead_end/deadend_turnaround/stage_turning.h\"\n\nnamespace apollo {\nnamespace planning {\nnamespace scenario {\nnamespace deadend_turnaround {\n\nusing apollo::common::VehicleState;\nusing apollo::common::math::Vec2d;\nusing apollo::hdmap::ParkingSpaceInfoConstPtr;\nusing apollo::hdmap::Path;\nusing apollo::hdmap::PathOverlap;\nusing apollo::common::PointENU;\nusing apollo::hdmap::HDMapUtil;\nusing apollo::hdmap::JunctionInfoConstPtr;\nusing apollo::routing::RoutingRequest;\nusing apollo::common::math::Polygon2d;\nusing apollo::common::math::LineSegment2d;\n\napollo::common::util::Factory<\n    ScenarioConfig::StageType, Stage,\n    Stage* (*)(const ScenarioConfig::StageConfig& stage_config,\n               const std::shared_ptr<DependencyInjector>& injector)>\n    DeadEndTurnAroundScenario::s_stage_factory_;\n\nvoid DeadEndTurnAroundScenario::Init() {\n  if (init_) {\n    return;\n  }\n  Scenario::Init();\n  if (!GetScenarioConfig()) {\n    return;\n  }\n\n  hdmap_ = hdmap::HDMapUtil::BaseMapPtr();\n  CHECK_NOTNULL(hdmap_);\n}\n\nvoid DeadEndTurnAroundScenario::RegisterStages() {\n  if (s_stage_factory_.Empty()) {\n    s_stage_factory_.Clear();\n  }\n  s_stage_factory_.Register(\n      ScenarioConfig::DEADEND_TURNAROUND_APPROACHING_TURNING_POINT,\n      [](const ScenarioConfig::StageConfig& config,\n         const std::shared_ptr<DependencyInjector>& injector) -> Stage* {\n        return new StageApproachingTurningPoint(config, injector);\n      });\n  s_stage_factory_.Register(\n      ScenarioConfig::DEADEND_TURNAROUND_TURNING,\n      [](const ScenarioConfig::StageConfig& config,\n         const std::shared_ptr<DependencyInjector>& injector) -> Stage* {\n        return new StageTurning(config, injector);\n      });\n}\n\nstd::unique_ptr<Stage> DeadEndTurnAroundScenario::CreateStage(\n    const ScenarioConfig::StageConfig& stage_config,\n    const std::shared_ptr<DependencyInjector>& injector) {\n  if (s_stage_factory_.Empty()) {\n    RegisterStages();\n  }\n  auto ptr = s_stage_factory_.CreateObjectOrNull(stage_config.stage_type(),\n                                                 stage_config, injector);\n  if (ptr) {\n    ptr->SetContext(&context_);\n  }\n  return ptr;\n}\n\nbool DeadEndTurnAroundScenario::GetScenarioConfig() {\n  if (!config_.has_deadend_turnaround_config()) {\n    return false;\n  }\n  context_.scenario_config.CopyFrom(config_.deadend_turnaround_config());\n  return true;\n}\n\nbool DeadEndTurnAroundScenario::IsTransferable(\n  const Frame& frame,\n  const PointENU& dead_end_point,\n  const double dead_end_start_range) {\n  std::string target_dead_end_id;\n  const auto& routing_type =\n      frame.local_view().routing->routing_request().dead_end_info().\n      dead_end_routing_type();\n  if (routing_type != routing::ROUTING_IN &&\n      routing_type != routing::ROUTING_OUT) {\n    ADEBUG << \"falied to get dead end routing task\";\n    return false;\n  }\n  // vaild check\n  const hdmap::HDMap* base_map_ptr = hdmap::HDMapUtil::BaseMapPtr();\n  std::vector<JunctionInfoConstPtr> junctions;\n  JunctionInfoConstPtr junction;\n  if (base_map_ptr->GetJunctions(dead_end_point, 1.0, &junctions) != 0) {\n    ADEBUG << \"Fail to get junctions from base_map.\";\n    return false;\n  }\n  if (junctions.size() <= 0) {\n    ADEBUG << \"No junction from map\";\n    return false;\n  }\n  if (!SelectTargetDeadEndJunction(&junctions, dead_end_point, &junction)) {\n    ADEBUG << \"Target Dead End not found\";\n    return false;\n  }\n  target_dead_end_id = junction->id().id();\n  const auto& vehicle_state = frame.vehicle_state();\n  const auto& nearby_path =\n      frame.reference_line_info().front().reference_line().map_path();\n  if (!CheckDistanceToDeadEnd(vehicle_state,\n                              nearby_path,\n                              dead_end_start_range,\n                              &junction)) {\n    ADEBUG << \"Dead end found, but too far, distance larger than \"\n              \"pre-defined distance \"\n           << target_dead_end_id;\n    return false;\n  }\n  return true;\n}\n\nbool DeadEndTurnAroundScenario::SelectTargetDeadEndJunction(\n    std::vector<JunctionInfoConstPtr>* junctions,\n    const apollo::common::PointENU& dead_end_point,\n    JunctionInfoConstPtr* target_junction) {\n  Vec2d start_point;\n  start_point.set_x(dead_end_point.x());\n  start_point.set_y(dead_end_point.y());\n  // warning: the car only be the one junction\n  size_t junction_num = junctions->size();\n  if (junction_num <= 0) {\n    ADEBUG << \"No junctions frim map\";\n    return false;\n  }\n  for (size_t i = 0; i < junction_num; ++i) {\n    if (junctions->at(i)->junction().type() == 5) {\n      Polygon2d polygon = junctions->at(i)->polygon();\n      // judge dead end point in the select junction\n      if (polygon.IsPointIn(start_point)) {\n        *target_junction = junctions->at(i);\n        return true;\n      } else {\n        return false;\n      }\n    } else {\n      ADEBUG << \"No dead end junction\";\n      return false;\n    }\n  }\n  return true;\n}\n\nbool DeadEndTurnAroundScenario::CheckDistanceToDeadEnd(\n    const VehicleState& vehicle_state,\n    const Path& nearby_path,\n    const double dead_end_start_range,\n    JunctionInfoConstPtr* junction) {\n  const Vec2d& car_position = {vehicle_state.x(), vehicle_state.y()};\n  auto junction_polygon = (*junction)->polygon();\n  return std::abs(junction_polygon.DistanceTo(car_position)) <\n         dead_end_start_range;\n}\n\n}  // namespace deadend_turnaround\n}  // namespace scenario\n}  // namespace planning\n}  // namespace apollo",
        "lookback": " * Copyright 2021 The Apollo Authors. All Rights Reserved.",
        "lookahead": "",
        "label": [
            "base",
            "one_side_deletion"
        ],
        "start_line": 0,
        "end_line": 375,
        "merge_gen_region": " Copyright021 Alo Authors All Reserved/****************************************************************************** Copyright021 Apol Authors All Reserved * Licensed the Apache, 20theLicense *\"); you not this except in with the. You obtain copy the License * may a of License * * httpwwwapacheorglicensesLICENSE20 * Unless by law agreed in, * to writing software distributed the is on \" IS BASIS * WARRANTIES CONDITIONS ANY, express implied * the License the for specific governing and limitations the License *****************************************************************************/ *file # \"modulesplan/enari/__/dendturn/dendturn_scenarioh # \"//ningscariosdeadenddend_aroundstageapachingturn_.\"includemodulesplan/enari/_____.\"includemodulesplan/enari/__aroundstageturn.\" alo { plan { namespace { dendturn { alocommonVehicle; alocommonmathVecd usingpol::mapPingInfoPtr usingpol::mapPath usingpol::mapPath; alohd::Overlap usingpol::::ENU usingpol::mapHDUtil usingpol::mapJInfoConst; alocommonroutingRouting; alocommonmathPolygond usingpol::::::::Segmentd alocommonutilFactory ScConfig",
        "confidence": 0.956489622592926,
        "hesitated": false,
        "resolved": false
    }
]