[
    {
        "a_contents": "/******************************************************************************\n * Copyright 2022 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *****************************************************************************/\n#pragma once\n\n#include <deque>\n#include <map>\n#include <memory>\n#include <string>\n#include <vector>\n\n#include \"paddle/include/paddle_inference_api.h\"\n#include \"pcl/point_cloud.h\"\n#include \"pcl/point_types.h\"\n\n#include \"modules/perception/base/object.h\"\n#include \"modules/perception/base/point_cloud.h\"\n#include \"modules/perception/lidar/common/lidar_frame.h\"\n#include \"modules/perception/lidar/lib/interface/base_lidar_detector.h\"\n#include \"modules/perception/pipeline/stage.h\"\n\nnamespace apollo {\nnamespace perception {\nnamespace lidar {\n\nclass CenterPointDetection : public BaseLidarDetector {\n public:\n  CenterPointDetection();\n  virtual ~CenterPointDetection() = default;\n\n  bool Init(const LidarDetectorInitOptions &options =\n                LidarDetectorInitOptions()) override;\n\n  bool Detect(const LidarDetectorOptions &options, LidarFrame *frame) override;\n\n  bool Init(const StageConfig& stage_config) override;\n\n  bool Process(DataFrame* data_frame) override;\n\n  bool IsEnabled() const override { return enable_; }\n\n  std::string Name() const override { return name_; }\n\n private:\n  void CloudToArray(const base::PointFCloudPtr &pc_ptr, float *out_points_array,\n                    float normalizing_factor);\n\n  void FuseCloud(const base::PointFCloudPtr &out_cloud_ptr,\n                 const std::deque<base::PointDCloudPtr> &fuse_clouds);\n\n  bool Preprocess(const float *in_points_array, const int in_num_points,\n                  std::vector<int> *voxels_shape,\n                  std::vector<float> *voxels_data,\n                  std::vector<int> *num_points_shape,\n                  std::vector<int> *num_points_data,\n                  std::vector<int> *coords_shape,\n                  std::vector<int> *coords_data);\n\n  std::vector<int> GenerateIndices(int start_index, int size, bool shuffle);\n\n  void DoInference(const std::vector<float> &points_data,\n                   const int in_num_points, std::vector<float> *out_detections,\n                   std::vector<int64_t> *out_labels,\n                   std::vector<float> *out_scores);\n\n  void Run(paddle_infer::Predictor *predictor,\n           const std::vector<int> &points_shape,\n           const std::vector<float> &points_data,\n           std::vector<float> *box3d_lidar, std::vector<int64_t> *label_preds,\n           std::vector<float> *scores);\n\n  void GetObjects(std::vector<std::shared_ptr<base::Object>> *objects,\n                  const Eigen::Affine3d &pose, std::vector<float> *detections,\n                  std::vector<int64_t> *labels);\n\n  void FilterScore(const std::vector<float> *box3d_lidar,\n                    const std::vector<int64_t> *label_preds,\n                    const std::vector<float> *scores,\n                    const float score_threshold,\n                    std::vector<float> *box3d_lidar_final,\n                    std::vector<int64_t> *label_preds_final);\n\n  base::ObjectSubType GetObjectSubType(int label);\n\n  // reference pointer of lidar frame\n  LidarFrame *lidar_frame_ref_ = nullptr;\n  std::shared_ptr<base::AttributePointCloud<base::PointF>> original_cloud_;\n  std::shared_ptr<base::AttributePointCloud<base::PointD>>\n      original_world_cloud_;\n\n  std::deque<base::PointDCloudPtr> prev_world_clouds_;\n\n  base::PointFCloudPtr cur_cloud_ptr_;\n\n  // point cloud range\n  float x_min_range_;\n  float x_max_range_;\n  float y_min_range_;\n  float y_max_range_;\n  float z_min_range_;\n  float z_max_range_;\n\n  // time statistics\n  double downsample_time_ = 0.0;\n  double fuse_time_ = 0.0;\n\n  double shuffle_time_ = 0.0;\n  double cloud_to_array_time_ = 0.0;\n  double inference_time_ = 0.0;\n  double collect_time_ = 0.0;\n\n  // bounding_box\n  const int num_output_box_feature_ = 7;\n\n  std::shared_ptr<paddle_infer::Predictor> predictor_;\n};  // class CenterPointDetection\n\n}  // namespace lidar\n}  // namespace perception\n}  // namespace apollo",
        "b_contents": "/******************************************************************************\n * Copyright 2022 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *****************************************************************************/\n#pragma once\n\n#include <deque>\n#include <map>\n#include <memory>\n#include <string>\n#include <vector>\n\n#include \"paddle/include/paddle_inference_api.h\"\n#include \"pcl/point_cloud.h\"\n#include \"pcl/point_types.h\"\n\n#include \"modules/perception/base/object.h\"\n#include \"modules/perception/base/point_cloud.h\"\n#include \"modules/perception/lidar/common/lidar_frame.h\"\n#include \"modules/perception/lidar/lib/interface/base_lidar_detector.h\"\n\nnamespace apollo {\nnamespace perception {\nnamespace lidar {\n\nclass CenterPointDetection : public BaseLidarDetector {\n public:\n  CenterPointDetection();\n  virtual ~CenterPointDetection() = default;\n\n  bool Init(const LidarDetectorInitOptions &options =\n                LidarDetectorInitOptions()) override;\n\n  bool Detect(const LidarDetectorOptions &options, LidarFrame *frame) override;\n\n  std::string Name() const override { return \"CenterPointDetection\"; }\n\n private:\n  void CloudToArray(const base::PointFCloudPtr &pc_ptr, float *out_points_array,\n                    float normalizing_factor);\n\n  void FuseCloud(const base::PointFCloudPtr &out_cloud_ptr,\n                 const std::deque<base::PointDCloudPtr> &fuse_clouds);\n\n  bool Preprocess(const float *in_points_array, const int in_num_points,\n                  std::vector<int> *voxels_shape,\n                  std::vector<float> *voxels_data,\n                  std::vector<int> *num_points_shape,\n                  std::vector<int> *num_points_data,\n                  std::vector<int> *coords_shape,\n                  std::vector<int> *coords_data);\n\n  std::vector<int> GenerateIndices(int start_index, int size, bool shuffle);\n\n  void DoInference(const std::vector<float> &points_data,\n                   const int in_num_points, std::vector<float> *out_detections,\n                   std::vector<int64_t> *out_labels,\n                   std::vector<float> *out_scores);\n\n  void Run(paddle_infer::Predictor *predictor,\n           const std::vector<int> &points_shape,\n           const std::vector<float> &points_data,\n           std::vector<float> *box3d_lidar, std::vector<int64_t> *label_preds,\n           std::vector<float> *scores);\n\n  void GetObjects(std::vector<std::shared_ptr<base::Object>> *objects,\n                  const Eigen::Affine3d &pose, std::vector<float> *detections,\n                  std::vector<int64_t> *labels);\n\n  void FilterScore(const std::vector<float> *box3d_lidar,\n                    const std::vector<int64_t> *label_preds,\n                    const std::vector<float> *scores,\n                    const float score_threshold,\n                    std::vector<float> *box3d_lidar_final,\n                    std::vector<int64_t> *label_preds_final);\n\n  base::ObjectSubType GetObjectSubType(int label);\n\n  // reference pointer of lidar frame\n  LidarFrame *lidar_frame_ref_ = nullptr;\n  std::shared_ptr<base::AttributePointCloud<base::PointF>> original_cloud_;\n  std::shared_ptr<base::AttributePointCloud<base::PointD>>\n      original_world_cloud_;\n\n  std::deque<base::PointDCloudPtr> prev_world_clouds_;\n\n  base::PointFCloudPtr cur_cloud_ptr_;\n\n  // point cloud range\n  float x_min_range_;\n  float x_max_range_;\n  float y_min_range_;\n  float y_max_range_;\n  float z_min_range_;\n  float z_max_range_;\n\n  // time statistics\n  double downsample_time_ = 0.0;\n  double fuse_time_ = 0.0;\n\n  double shuffle_time_ = 0.0;\n  double cloud_to_array_time_ = 0.0;\n  double inference_time_ = 0.0;\n  double collect_time_ = 0.0;\n\n  // bounding_box\n  const int num_output_box_feature_ = 7;\n\n  std::shared_ptr<paddle_infer::Predictor> predictor_;\n};  // class CenterPointDetection\n\n}  // namespace lidar\n}  // namespace perception\n}  // namespace apollo",
        "base_contents": "",
        "res_region": "/******************************************************************************\n * Copyright 2022 The Apollo Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *****************************************************************************/\n#pragma once\n\n#include <deque>\n#include <map>\n#include <memory>\n#include <string>\n#include <vector>\n\n#include \"paddle/include/paddle_inference_api.h\"\n#include \"pcl/point_cloud.h\"\n#include \"pcl/point_types.h\"\n\n#include \"modules/perception/base/object.h\"\n#include \"modules/perception/base/point_cloud.h\"\n#include \"modules/perception/lidar/common/lidar_frame.h\"\n#include \"modules/perception/lidar/lib/interface/base_lidar_detector.h\"\n#include \"modules/perception/pipeline/stage.h\"\n\nnamespace apollo {\nnamespace perception {\nnamespace lidar {\n\nclass CenterPointDetection : public BaseLidarDetector {\n public:\n  CenterPointDetection();\n  virtual ~CenterPointDetection() = default;\n\n  bool Init(const LidarDetectorInitOptions &options =\n                LidarDetectorInitOptions()) override;\n\n  bool Detect(const LidarDetectorOptions &options, LidarFrame *frame) override;\n\n  bool Init(const StageConfig& stage_config) override;\n\n  bool Process(DataFrame* data_frame) override;\n\n  bool IsEnabled() const override { return enable_; }\n\n  std::string Name() const override { return name_; }\n\n private:\n  void CloudToArray(const base::PointFCloudPtr &pc_ptr, float *out_points_array,\n                    float normalizing_factor);\n\n  void FuseCloud(const base::PointFCloudPtr &out_cloud_ptr,\n                 const std::deque<base::PointDCloudPtr> &fuse_clouds);\n\n  bool Preprocess(const float *in_points_array, const int in_num_points,\n                  std::vector<int> *voxels_shape,\n                  std::vector<float> *voxels_data,\n                  std::vector<int> *num_points_shape,\n                  std::vector<int> *num_points_data,\n                  std::vector<int> *coords_shape,\n                  std::vector<int> *coords_data);\n\n  std::vector<int> GenerateIndices(int start_index, int size, bool shuffle);\n\n  void DoInference(const std::vector<float> &points_data,\n                   const int in_num_points, std::vector<float> *out_detections,\n                   std::vector<int64_t> *out_labels,\n                   std::vector<float> *out_scores);\n\n  void Run(paddle_infer::Predictor *predictor,\n           const std::vector<int> &points_shape,\n           const std::vector<float> &points_data,\n           std::vector<float> *box3d_lidar, std::vector<int64_t> *label_preds,\n           std::vector<float> *scores);\n\n  void GetObjects(std::vector<std::shared_ptr<base::Object>> *objects,\n                  const Eigen::Affine3d &pose, std::vector<float> *detections,\n                  std::vector<int64_t> *labels);\n\n  void FilterScore(const std::vector<float> *box3d_lidar,\n                    const std::vector<int64_t> *label_preds,\n                    const std::vector<float> *scores,\n                    const float score_threshold,\n                    std::vector<float> *box3d_lidar_final,\n                    std::vector<int64_t> *label_preds_final);\n\n  base::ObjectSubType GetObjectSubType(int label);\n\n  // reference pointer of lidar frame\n  LidarFrame *lidar_frame_ref_ = nullptr;\n  std::shared_ptr<base::AttributePointCloud<base::PointF>> original_cloud_;\n  std::shared_ptr<base::AttributePointCloud<base::PointD>>\n      original_world_cloud_;\n\n  std::deque<base::PointDCloudPtr> prev_world_clouds_;\n\n  base::PointFCloudPtr cur_cloud_ptr_;\n\n  // point cloud range\n  float x_min_range_;\n  float x_max_range_;\n  float y_min_range_;\n  float y_max_range_;\n  float z_min_range_;\n  float z_max_range_;\n\n  // time statistics\n  double downsample_time_ = 0.0;\n  double fuse_time_ = 0.0;\n\n  double shuffle_time_ = 0.0;\n  double cloud_to_array_time_ = 0.0;\n  double inference_time_ = 0.0;\n  double collect_time_ = 0.0;\n\n  // bounding_box\n  const int num_output_box_feature_ = 7;\n\n  std::shared_ptr<paddle_infer::Predictor> predictor_;\n};  // class CenterPointDetection\n\n}  // namespace lidar\n}  // namespace perception\n}  // namespace apollo",
        "lookback": " * Copyright 2022 The Apollo Authors. All Rights Reserved.",
        "lookahead": "",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 0,
        "end_line": 260,
        "merge_gen_region": " Copyright022 Alo. Rights. Rights. * Licensed the Apache, 20theLicense * may use file in with License * may a of License * * httpwwwapacheorglicensesLICENSE20 * Unless by applicable or to writing software distributed the is on \" IS BASIS * WARRANTIES CONDITIONS ANY, either or. See License for specific governing and limitations the License *****************************************************************************/pragma # onceincludedeque # <>includemap # <>includememory # <string # <vector # \"padd/includepadd_nferenceapih # \"pclpointcloudh # \"pclpointtypesh # \"//ceptionbaseobjecth # \"/per///.\"includemodulesper///_.\"includemodulesper//.\"includemodulesper/arcommonlid_frameh # \"/ceptionlid/////////////////////////////////////_detectorh # \"/per////////////////////////////..\" alo namespaceception namespaceid { CenterDetection public BaseidDetector public Center",
        "confidence": 0.9356112480163574,
        "hesitated": false,
        "resolved": false
    }
]