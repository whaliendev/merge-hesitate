[
    {
        "a_contents": "        boost::shared_ptr<semilattice_readwrite_view_t<servers_semilattice_metadata_t> >\n            _servers_sl_view,\n        server_name_client_t *_name_client,\n        watchable_map_t<peer_id_t, cluster_directory_metadata_t> *_directory_view) :\n    common_server_artificial_table_backend_t(_servers_sl_view, _name_client),\n    directory_view(_directory_view),\n    last_seen_tracker(_servers_sl_view, _directory_view),\n    directory_subs(directory_view,\n        [this](const peer_id_t &, const cluster_directory_metadata_t *md) {\n            if (md == nullptr) {\n                notify_all();\n            } else {\n                /* This is one of the rare cases where we can tell exactly which row\n                needs to be recomputed */\n                notify_row(convert_uuid_to_datum(md->server_id));\n            }\n        }, false)\n    { }\n\nserver_status_artificial_table_backend_t::~server_status_artificial_table_backend_t() {\n    begin_changefeed_destruction();",
        "b_contents": "    boost::shared_ptr<semilattice_readwrite_view_t<servers_semilattice_metadata_t> >\n        _servers_sl_view,\n    server_config_client_t *_server_config_client,\n    clone_ptr_t<watchable_t<change_tracking_map_t<peer_id_t,\n        cluster_directory_metadata_t> > > _directory_view,\n    boost::shared_ptr<semilattice_readwrite_view_t<cow_ptr_t<\n        namespaces_semilattice_metadata_t> > > _table_sl_view,\n    boost::shared_ptr<semilattice_readwrite_view_t<databases_semilattice_metadata_t> >\n        _database_sl_view) :\n    common_server_artificial_table_backend_t(_servers_sl_view, _server_config_client),\n    directory_view(_directory_view), table_sl_view(_table_sl_view),\n    database_sl_view(_database_sl_view),\n    last_seen_tracker(\n        _servers_sl_view,\n        _directory_view->incremental_subview(\n            incremental_field_getter_t<server_id_t, cluster_directory_metadata_t>(\n                                    &cluster_directory_metadata_t::server_id)))\n{\n    table_sl_view->assert_thread();\n    database_sl_view->assert_thread();",
        "base_contents": "    boost::shared_ptr<semilattice_readwrite_view_t<servers_semilattice_metadata_t> >\n        _servers_sl_view,\n    server_name_client_t *_name_client,\n    clone_ptr_t<watchable_t<change_tracking_map_t<peer_id_t,\n        cluster_directory_metadata_t> > > _directory_view,\n    boost::shared_ptr<semilattice_readwrite_view_t<cow_ptr_t<\n        namespaces_semilattice_metadata_t> > > _table_sl_view,\n    boost::shared_ptr<semilattice_readwrite_view_t<databases_semilattice_metadata_t> >\n        _database_sl_view) :\n    common_server_artificial_table_backend_t(_servers_sl_view, _name_client),\n    directory_view(_directory_view), table_sl_view(_table_sl_view),\n    database_sl_view(_database_sl_view),\n    last_seen_tracker(\n        _servers_sl_view,\n        _directory_view->incremental_subview(\n            incremental_field_getter_t<server_id_t, cluster_directory_metadata_t>(\n                                    &cluster_directory_metadata_t::server_id)))\n{\n    table_sl_view->assert_thread();\n    database_sl_view->assert_thread();",
        "res_region": "        boost::shared_ptr<semilattice_readwrite_view_t<servers_semilattice_metadata_t> >\n            _servers_sl_view,\n        server_config_client_t *_server_config_client,\n        watchable_map_t<peer_id_t, cluster_directory_metadata_t> *_directory_view) :\n    common_server_artificial_table_backend_t(_servers_sl_view, _server_config_client),\n    directory_view(_directory_view),\n    last_seen_tracker(_servers_sl_view, _directory_view),\n    directory_subs(directory_view,\n        [this](const peer_id_t &, const cluster_directory_metadata_t *md) {\n            if (md == nullptr) {\n                notify_all();\n            } else {\n                /* This is one of the rare cases where we can tell exactly which row\n                needs to be recomputed */\n                notify_row(convert_uuid_to_datum(md->server_id));\n            }\n        }, false)\n    { }\n\nserver_status_artificial_table_backend_t::~server_status_artificial_table_backend_t() {\n    begin_changefeed_destruction();",
        "lookback": "            _servers_sl_view,",
        "lookahead": "}",
        "label": [
            "newcode",
            "complex_conflict"
        ],
        "start_line": 19,
        "end_line": 83,
        "merge_gen_region": null,
        "confidence": 0.7152857780456543,
        "hesitated": true
    }
]