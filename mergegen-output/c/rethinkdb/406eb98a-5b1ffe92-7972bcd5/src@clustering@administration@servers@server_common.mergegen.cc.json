[
    {
        "a_contents": "    /* Note that we don't have a subscription watching `get_server_id_to_name_map()`,\n    even though we use it in this calculation. This is OK because any time\n    `get_server_id_to_name_map()` changes, we'll also get a notification through\n    `servers_sl_view`, and since the `cfeed_artificial_table_backend_t` does its\n    recalculations asynchronously, it shouldn't matter that there is a slight delay\n    between when we get a notification through `servers_sl_view` and when\n    `get_server_id_to_name_map()` actually changes. But it's still a bit fragile, and\n    maybe we shouldn't do it. */\n    std::map<server_id_t, name_string_t> server_map =\n        name_client->get_server_id_to_name_map()->get();\n    for (auto it = server_map.begin(); it != server_map.end(); ++it) {\n        ql::datum_t row;\n        std::map<server_id_t, deletable_t<server_semilattice_metadata_t> >\n            ::iterator sl_it;\n        if (!search_metadata_by_uuid(&servers_sl.servers, it->first, &sl_it)) {\n            continue;\n        }\n        if (!format_row(it->second, it->first, sl_it->second.get_ref(),\n                        interruptor, &row, error_out)) {\n            return false;\n        }\n        rows_out->push_back(row);\n    }\n    return true;",
        "b_contents": "    bool result = true;\n    server_config_client->get_server_id_to_name_map()->apply_read(\n        [&](const std::map<server_id_t, name_string_t> *map) {\n            for (auto it = map->begin(); it != map->end(); ++it) {\n                ql::datum_t row;\n                std::map<\n                        server_id_t, deletable_t<server_semilattice_metadata_t>\n                    >::iterator sl_it;\n                if (!search_metadata_by_uuid(&servers_sl.servers, it->first, &sl_it)) {\n                    continue;\n                }\n                if (!format_row(it->second, it->first, sl_it->second.get_ref(),\n                                &row, error_out)) {\n                    result = false;\n                    return;\n                }\n                rows_out->push_back(row);\n            }\n        });\n    return result;",
        "base_contents": "    bool result = true;\n    name_client->get_server_id_to_name_map()->apply_read(\n        [&](const std::map<server_id_t, name_string_t> *map) {\n            for (auto it = map->begin(); it != map->end(); ++it) {\n                ql::datum_t row;\n                std::map<\n                        server_id_t, deletable_t<server_semilattice_metadata_t>\n                    >::iterator sl_it;\n                if (!search_metadata_by_uuid(&servers_sl.servers, it->first, &sl_it)) {\n                    continue;\n                }\n                if (!format_row(it->second, it->first, sl_it->second.get_ref(),\n                                &row, error_out)) {\n                    result = false;\n                    return;\n                }\n                rows_out->push_back(row);\n            }\n        });\n    return result;",
        "res_region": "    /* Note that we don't have a subscription watching `get_server_id_to_name_map()`,\n    even though we use it in this calculation. This is OK because any time\n    `get_server_id_to_name_map()` changes, we'll also get a notification through\n    `servers_sl_view`, and since the `cfeed_artificial_table_backend_t` does its\n    recalculations asynchronously, it shouldn't matter that there is a slight delay\n    between when we get a notification through `servers_sl_view` and when\n    `get_server_id_to_name_map()` actually changes. But it's still a bit fragile, and\n    maybe we shouldn't do it. */\n    std::map<server_id_t, name_string_t> server_map =\n        server_config_client->get_server_id_to_name_map()->get();\n    for (auto it = server_map.begin(); it != server_map.end(); ++it) {\n        ql::datum_t row;\n        std::map<server_id_t, deletable_t<server_semilattice_metadata_t> >\n            ::iterator sl_it;\n        if (!search_metadata_by_uuid(&servers_sl.servers, it->first, &sl_it)) {\n            continue;\n        }\n        if (!format_row(it->second, it->first, sl_it->second.get_ref(),\n                        interruptor, &row, error_out)) {\n            return false;\n        }\n        rows_out->push_back(row);\n    }\n    return true;",
        "lookback": "    even though we use it in this calculation. This is OK because any time",
        "lookahead": "}",
        "label": [
            "newcode",
            "complex_conflict"
        ],
        "start_line": 29,
        "end_line": 96,
        "merge_gen_region": " Note we don have subscriptioninggetserveridtonamemap`,substr use in calculation This OK any `______() changes we also a throughserversslview and since `eedart_ificialtablebackendt does recations, shouldn't that is slight between we a throughserversslview and `____getserveridtonamemapgetgetserveridtonamemapgetgetserveridtonamemapgetgetgetserveridtonamemapgetget forauto it servermapbegin it servermapbegin it servermapbegin it servermapbegin it servermapend ++) qldatumt;::<::<::<::<::<::<::<::<::<::<::<::>Extiterator_; ifsearchmetadatabyuuidserversslservers,->first &_)) continue } (!___*_",
        "confidence": 0.881853461265564,
        "hesitated": false,
        "resolved": false
    }
]