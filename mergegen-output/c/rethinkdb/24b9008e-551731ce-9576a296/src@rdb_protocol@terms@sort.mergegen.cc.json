[
    {
        "a_contents": "    static bool lt_cmp(env_t *,\n                       counted_t<const datum_t> l,\n                       counted_t<const datum_t> r) {\n        return *l < *r;\n    }\n    virtual counted_t<val_t> eval_impl(scope_env_t *env, args_t *args, eval_flags_t) const {\n        counted_t<datum_stream_t> s = args->arg(env, 0)->as_seq(env->env);\n        std::vector<counted_t<const datum_t> > arr;\n        counted_t<const datum_t> last;\n        batchspec_t batchspec = batchspec_t::user(batch_type_t::TERMINAL, env->env);\n        {\n            profile::sampler_t sampler(\"Evaluating elements in distinct.\",\n                                       env->env->trace);\n            while (counted_t<const datum_t> d = s->next(env->env, batchspec)) {\n                arr.push_back(std::move(d));\n                rcheck_array_size(arr, base_exc_t::GENERIC);\n                sampler.new_sample();",
        "b_contents": "    virtual counted_t<val_t> eval_impl(scope_env_t *env, eval_flags_t) {\n        counted_t<val_t> v = arg(env, 0);\n        counted_t<val_t> idx = optarg(env, \"index\");\n        if (v->get_type().is_convertible(val_t::type_t::TABLE)) {\n            counted_t<table_t> tbl = v->as_table();\n            std::string idx_str = idx.has() ? idx->as_str().to_std() : tbl->get_pkey();\n            if (idx.has() && idx_str == tbl->get_pkey()) {\n                auto row = pb::dummy_var_t::DISTINCT_ROW;\n                std::vector<sym_t> args{dummy_var_to_sym(row)};\n                protob_t<Term> body(make_counted_term());\n                {\n                    r::reql_t f = r::var(row)[idx_str];\n                    body->Swap(&f.get());\n                }\n                propagate(body.get());\n                counted_t<datum_stream_t> s =\n                    tbl->as_datum_stream(env->env, backtrace());\n                map_wire_func_t mwf(body, std::move(args), backtrace());\n                s->add_transformation(std::move(mwf), backtrace());\n                return new_val(env->env, s);\n            } else {\n                tbl->add_sorting(idx_str, sorting_t::ASCENDING, this);\n                counted_t<datum_stream_t> s =\n                    tbl->as_datum_stream(env->env, backtrace());\n                s->add_transformation(distinct_wire_func_t(idx.has()), backtrace());\n                return new_val(env->env, s->ordered_distinct());",
        "base_contents": "    static bool lt_cmp(env_t *,\n                       counted_t<const datum_t> l,\n                       counted_t<const datum_t> r) {\n        return *l < *r;\n    }\n    virtual counted_t<val_t> eval_impl(scope_env_t *env, UNUSED eval_flags_t flags) {\n        counted_t<datum_stream_t> s = arg(env, 0)->as_seq(env->env);\n        std::vector<counted_t<const datum_t> > arr;\n        counted_t<const datum_t> last;\n        batchspec_t batchspec = batchspec_t::user(batch_type_t::TERMINAL, env->env);\n        {\n            profile::sampler_t sampler(\"Evaluating elements in distinct.\",\n                                       env->env->trace);\n            while (counted_t<const datum_t> d = s->next(env->env, batchspec)) {\n                arr.push_back(std::move(d));\n                rcheck_array_size(arr, base_exc_t::GENERIC);\n                sampler.new_sample();",
        "res_region": "    virtual counted_t<val_t> eval_impl(\n        scope_env_t *env, args_t *args, eval_flags_t) const {\n        counted_t<val_t> v = args->arg(env, 0);\n        counted_t<val_t> idx = args->optarg(env, \"index\");\n        if (v->get_type().is_convertible(val_t::type_t::TABLE)) {\n            counted_t<table_t> tbl = v->as_table();\n            std::string idx_str = idx.has() ? idx->as_str().to_std() : tbl->get_pkey();\n            if (idx.has() && idx_str == tbl->get_pkey()) {\n                auto row = pb::dummy_var_t::DISTINCT_ROW;\n                std::vector<sym_t> distinct_args{dummy_var_to_sym(row)};\n                protob_t<Term> body(make_counted_term());\n                {\n                    r::reql_t f = r::var(row)[idx_str];\n                    body->Swap(&f.get());\n                }\n                propagate(body.get());\n                counted_t<datum_stream_t> s =\n                    tbl->as_datum_stream(env->env, backtrace());\n                map_wire_func_t mwf(body, std::move(distinct_args), backtrace());\n                s->add_transformation(std::move(mwf), backtrace());\n                return new_val(env->env, s);\n            } else {\n                tbl->add_sorting(idx_str, sorting_t::ASCENDING, this);\n                counted_t<datum_stream_t> s =\n                    tbl->as_datum_stream(env->env, backtrace());\n                s->add_transformation(distinct_wire_func_t(idx.has()), backtrace());\n                return new_val(env->env, s->ordered_distinct());",
        "lookback": "        scope_env_t *env, args_t *args, eval_flags_t) const {",
        "lookahead": "            }",
        "label": [
            "newcode",
            "complex_conflict"
        ],
        "start_line": 211,
        "end_line": 274,
        "merge_gen_region": null,
        "confidence": 0.7788659930229187,
        "hesitated": true
    }
]