[
    {
        "a_contents": "",
        "b_contents": "/* The query-routing logic provides the following ordering guarantees:\n\n1.  All the replicas of each individual key will see writes in the same order.\n\n    Example: Suppose K = \"x\". You send (append \"a\" to K) and (append \"b\" to K)\n    concurrently from different nodes. Either every copy of K will become \"xab\",\n    or every copy of K will become \"xba\", but the different copies of K will\n    never disagree.\n\n2.  Queries from the same origin will be performed in same order they are sent.\n\n    Example: Suppose K = \"a\". You send (set K to \"b\") and (read K) from the same\n    thread on the same node, in that order. The read will return \"b\".\n\n3.  Arbitrary atomic single-key operations can be performed, as long as they can\n    be expressed as `write_t` objects.\n\n4.  There are no other atomicity or ordering guarantees.\n\n    Example: Suppose K1 = \"x\" and K2 = \"x\". You send (append \"a\" to every key)\n    and (append \"b\" to every key) concurrently. Every copy of K1 will agree with\n    every other copy of K1, and every copy of K2 will agree with every other\n    copy of K2, but K1 and K2 may disagree.\n\n    Example: Suppose K = \"a\". You send (set K to \"b\"). As soon as it's sent, you\n    send (set K to \"c\") from a different node. K may end up being either \"b\" or\n    \"c\".\n\n    Example: Suppose K1 = \"a\" and K2 = \"a\". You send (set K1 to \"b\") and (set K2\n    to \"b\") from the same node, in that order. Then you send (read K1 and K2)\n    from a different node. The read may return (K1 = \"a\", K2 = \"b\").\n\n5.  There is no simple way to perform an atomic multikey transaction. You might\n    be able to fake it by using a key as a \"lock\".\n*/\n\nclass store_subview_t final : public store_view_t {\npublic:\n    store_subview_t(store_view_t *_store_view, region_t region)\n        : store_view_t(region), store_view(_store_view) {\n        rassert(region_is_superset(_store_view->get_region(), region));\n    }\n\n    ~store_subview_t() {\n        store_view->note_reshard();\n    }\n    void note_reshard() {\n        store_view->note_reshard();\n    }\n\n    using store_view_t::get_region;\n\n    void new_read_token(read_token_t *token_out) {\n        home_thread_mixin_t::assert_thread();\n        store_view->new_read_token(token_out);\n    }\n\n    void new_write_token(write_token_t *token_out) {\n        home_thread_mixin_t::assert_thread();\n        store_view->new_write_token(token_out);\n    }\n\n    void do_get_metainfo(order_token_t order_token,\n                         read_token_t *token,\n                         signal_t *interruptor,\n                         region_map_t<binary_blob_t> *out)\n            THROWS_ONLY(interrupted_exc_t) {\n        home_thread_mixin_t::assert_thread();\n        region_map_t<binary_blob_t> tmp;\n        store_view->do_get_metainfo(order_token, token, interruptor, &tmp);\n        *out = tmp.mask(get_region());\n    }\n\n    void set_metainfo(const region_map_t<binary_blob_t> &new_metainfo,\n                      order_token_t order_token,\n                      write_token_t *token,\n                      signal_t *interruptor) THROWS_ONLY(interrupted_exc_t) {\n        home_thread_mixin_t::assert_thread();\n        rassert(region_is_superset(get_region(), new_metainfo.get_domain()));\n        store_view->set_metainfo(new_metainfo, order_token, token, interruptor);\n    }\n\n    void read(\n            DEBUG_ONLY(const metainfo_checker_t& metainfo_checker, )\n            const read_t &read,\n            read_response_t *response,\n            order_token_t order_token,\n            read_token_t *token,\n            signal_t *interruptor)\n            THROWS_ONLY(interrupted_exc_t) {\n        home_thread_mixin_t::assert_thread();\n        rassert(region_is_superset(get_region(), metainfo_checker.get_domain()));\n\n        store_view->read(DEBUG_ONLY(metainfo_checker, ) read, response, order_token, token, interruptor);\n    }\n\n    void write(\n            DEBUG_ONLY(const metainfo_checker_t& metainfo_checker, )\n            const region_map_t<binary_blob_t>& new_metainfo,\n            const write_t &write,\n            write_response_t *response,\n            write_durability_t durability,\n            state_timestamp_t timestamp,\n            order_token_t order_token,\n            write_token_t *token,\n            signal_t *interruptor)\n            THROWS_ONLY(interrupted_exc_t) {\n        home_thread_mixin_t::assert_thread();\n        rassert(region_is_superset(get_region(), metainfo_checker.get_domain()));\n        rassert(region_is_superset(get_region(), new_metainfo.get_domain()));\n\n        store_view->write(DEBUG_ONLY(metainfo_checker, ) new_metainfo, write, response, durability, timestamp, order_token, token, interruptor);\n    }\n\n    bool send_backfill(\n            const region_map_t<state_timestamp_t> &start_point,\n            send_backfill_callback_t *send_backfill_cb,\n            traversal_progress_combiner_t *p,\n            read_token_t *token,\n            signal_t *interruptor)\n            THROWS_ONLY(interrupted_exc_t) {\n        home_thread_mixin_t::assert_thread();\n        rassert(region_is_superset(get_region(), start_point.get_domain()));\n\n        return store_view->send_backfill(start_point, send_backfill_cb, p, token, interruptor);\n    }\n\n    void receive_backfill(\n            const backfill_chunk_t &chunk,\n            write_token_t *token,\n            signal_t *interruptor)\n            THROWS_ONLY(interrupted_exc_t) {\n        home_thread_mixin_t::assert_thread();\n        store_view->receive_backfill(chunk, token, interruptor);\n    }\n\n    void throttle_backfill_chunk(signal_t *interruptor)\n            THROWS_ONLY(interrupted_exc_t) {\n        home_thread_mixin_t::assert_thread();\n        store_view->throttle_backfill_chunk(interruptor);\n    }\n\n    void reset_data(\n            const binary_blob_t &zero_version,\n            const region_t &subregion,\n            write_durability_t durability,\n            signal_t *interruptor)\n            THROWS_ONLY(interrupted_exc_t) {\n        home_thread_mixin_t::assert_thread();\n        rassert(region_is_superset(get_region(), subregion));\n\n        store_view->reset_data(zero_version, subregion, durability, interruptor);\n    }\n\nprivate:\n    store_view_t *store_view;\n\n    DISABLE_COPYING(store_subview_t);\n};\n",
        "base_contents": "/* The query-routing logic provides the following ordering guarantees:\n\n1.  All the replicas of each individual key will see writes in the same order.\n\n    Example: Suppose K = \"x\". You send (append \"a\" to K) and (append \"b\" to K)\n    concurrently from different nodes. Either every copy of K will become \"xab\",\n    or every copy of K will become \"xba\", but the different copies of K will\n    never disagree.\n\n2.  Queries from the same origin will be performed in same order they are sent.\n\n    Example: Suppose K = \"a\". You send (set K to \"b\") and (read K) from the same\n    thread on the same node, in that order. The read will return \"b\".\n\n3.  Arbitrary atomic single-key operations can be performed, as long as they can\n    be expressed as `write_t` objects.\n\n4.  There are no other atomicity or ordering guarantees.\n\n    Example: Suppose K1 = \"x\" and K2 = \"x\". You send (append \"a\" to every key)\n    and (append \"b\" to every key) concurrently. Every copy of K1 will agree with\n    every other copy of K1, and every copy of K2 will agree with every other\n    copy of K2, but K1 and K2 may disagree.\n\n    Example: Suppose K = \"a\". You send (set K to \"b\"). As soon as it's sent, you\n    send (set K to \"c\") from a different node. K may end up being either \"b\" or\n    \"c\".\n\n    Example: Suppose K1 = \"a\" and K2 = \"a\". You send (set K1 to \"b\") and (set K2\n    to \"b\") from the same node, in that order. Then you send (read K1 and K2)\n    from a different node. The read may return (K1 = \"a\", K2 = \"b\").\n\n5.  There is no simple way to perform an atomic multikey transaction. You might\n    be able to fake it by using a key as a \"lock\".\n*/\n\nclass store_subview_t final : public store_view_t {\npublic:\n    store_subview_t(store_view_t *_store_view, region_t region)\n        : store_view_t(region), store_view(_store_view) {\n        rassert(region_is_superset(_store_view->get_region(), region));\n    }\n\n    ~store_subview_t() {\n        store_view->note_reshard();\n    }\n    void note_reshard() {\n        store_view->note_reshard();\n    }\n\n    using store_view_t::get_region;\n\n    void new_read_token(read_token_t *token_out) {\n        home_thread_mixin_t::assert_thread();\n        store_view->new_read_token(token_out);\n    }\n\n    void new_write_token(write_token_t *token_out) {\n        home_thread_mixin_t::assert_thread();\n        store_view->new_write_token(token_out);\n    }\n\n    void do_get_metainfo(order_token_t order_token,\n                         read_token_t *token,\n                         signal_t *interruptor,\n                         region_map_t<binary_blob_t> *out)\n            THROWS_ONLY(interrupted_exc_t) {\n        home_thread_mixin_t::assert_thread();\n        region_map_t<binary_blob_t> tmp;\n        store_view->do_get_metainfo(order_token, token, interruptor, &tmp);\n        *out = tmp.mask(get_region());\n    }\n\n    void set_metainfo(const region_map_t<binary_blob_t> &new_metainfo,\n                      order_token_t order_token,\n                      write_token_t *token,\n                      signal_t *interruptor) THROWS_ONLY(interrupted_exc_t) {\n        home_thread_mixin_t::assert_thread();\n        rassert(region_is_superset(get_region(), new_metainfo.get_domain()));\n        store_view->set_metainfo(new_metainfo, order_token, token, interruptor);\n    }\n\n    void read(\n            DEBUG_ONLY(const metainfo_checker_t& metainfo_checker, )\n            const read_t &read,\n            read_response_t *response,\n            order_token_t order_token,\n            read_token_t *token,\n            signal_t *interruptor)\n            THROWS_ONLY(interrupted_exc_t) {\n        home_thread_mixin_t::assert_thread();\n        rassert(region_is_superset(get_region(), metainfo_checker.get_domain()));\n\n        store_view->read(DEBUG_ONLY(metainfo_checker, ) read, response, order_token, token, interruptor);\n    }\n\n    void write(\n            DEBUG_ONLY(const metainfo_checker_t& metainfo_checker, )\n            const region_map_t<binary_blob_t>& new_metainfo,\n            const write_t &write,\n            write_response_t *response,\n            write_durability_t durability,\n            transition_timestamp_t timestamp,\n            order_token_t order_token,\n            write_token_t *token,\n            signal_t *interruptor)\n            THROWS_ONLY(interrupted_exc_t) {\n        home_thread_mixin_t::assert_thread();\n        rassert(region_is_superset(get_region(), metainfo_checker.get_domain()));\n        rassert(region_is_superset(get_region(), new_metainfo.get_domain()));\n\n        store_view->write(DEBUG_ONLY(metainfo_checker, ) new_metainfo, write, response, durability, timestamp, order_token, token, interruptor);\n    }\n\n    bool send_backfill(\n            const region_map_t<state_timestamp_t> &start_point,\n            send_backfill_callback_t *send_backfill_cb,\n            traversal_progress_combiner_t *p,\n            read_token_t *token,\n            signal_t *interruptor)\n            THROWS_ONLY(interrupted_exc_t) {\n        home_thread_mixin_t::assert_thread();\n        rassert(region_is_superset(get_region(), start_point.get_domain()));\n\n        return store_view->send_backfill(start_point, send_backfill_cb, p, token, interruptor);\n    }\n\n    void receive_backfill(\n            const backfill_chunk_t &chunk,\n            write_token_t *token,\n            signal_t *interruptor)\n            THROWS_ONLY(interrupted_exc_t) {\n        home_thread_mixin_t::assert_thread();\n        store_view->receive_backfill(chunk, token, interruptor);\n    }\n\n    void throttle_backfill_chunk(signal_t *interruptor)\n            THROWS_ONLY(interrupted_exc_t) {\n        home_thread_mixin_t::assert_thread();\n        store_view->throttle_backfill_chunk(interruptor);\n    }\n\n    void reset_data(\n            const binary_blob_t &zero_version,\n            const region_t &subregion,\n            write_durability_t durability,\n            signal_t *interruptor)\n            THROWS_ONLY(interrupted_exc_t) {\n        home_thread_mixin_t::assert_thread();\n        rassert(region_is_superset(get_region(), subregion));\n\n        store_view->reset_data(zero_version, subregion, durability, interruptor);\n    }\n\nprivate:\n    store_view_t *store_view;\n\n    DISABLE_COPYING(store_subview_t);\n};\n",
        "res_region": "",
        "lookback": "",
        "lookahead": "#endif  // STORE_VIEW_HPP_",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 130,
        "end_line": 453,
        "merge_gen_region": " storesub__ finalt public storeviewt public storeviewtstoreviewtstoreview regiont)",
        "confidence": 0.9314753413200378,
        "hesitated": false,
        "resolved": false
    }
]