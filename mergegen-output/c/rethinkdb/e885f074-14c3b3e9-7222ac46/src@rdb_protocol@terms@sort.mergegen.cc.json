[
    {
        "a_contents": "                tbl_slice = tbl_slice->with_sorting(idx_str, sorting_t::ASCENDING);\n                counted_t<datum_stream_t> s = tbl_slice->as_seq(env->env, backtrace());\n                s->add_transformation(distinct_wire_func_t(idx.has()), backtrace());\n                return new_val(env->env, s->ordered_distinct());\n            }\n        } else {\n            rcheck(!idx, base_exc_t::GENERIC,\n                   \"Can only perform an indexed distinct on a TABLE.\");\n            counted_t<datum_stream_t> s = v->as_seq(env->env);\n            // The reql_version matters here, because we copy `results` into `toret`\n            // in ascending order.\n            std::set<datum_t, optional_datum_less_t>\n                results(optional_datum_less_t(env->env->reql_version()));\n            batchspec_t batchspec = batchspec_t::user(batch_type_t::TERMINAL, env->env);\n            {\n                profile::sampler_t sampler(\"Evaluating elements in distinct.\",\n                                           env->env->trace);\n                datum_t d;\n                while (d = s->next(env->env, batchspec), d.has()) {\n                    results.insert(std::move(d));\n                    rcheck_array_size(results, env->env->limits(), base_exc_t::GENERIC);\n                    sampler.new_sample();",
        "b_contents": "                if (!tbl->sindex_id || *tbl->sindex_id == idx_str) {\n                    if (tbl->sorting == sorting_t::UNORDERED) {\n                        tbl->add_sorting(idx_str, sorting_t::ASCENDING, this);\n                    }\n                    counted_t<datum_stream_t> s =\n                        tbl->as_datum_stream(env->env, backtrace());\n                    s->add_transformation(distinct_wire_func_t(idx.has()), backtrace());\n                    return new_val(env->env, s->ordered_distinct());",
        "base_contents": "                tbl->add_sorting(idx_str, sorting_t::ASCENDING, this);\n                counted_t<datum_stream_t> s =\n                    tbl->as_datum_stream(env->env, backtrace());\n                s->add_transformation(distinct_wire_func_t(idx.has()), backtrace());\n                return new_val(env->env, s->ordered_distinct());\n            }\n        } else {\n            rcheck(!idx, base_exc_t::GENERIC,\n                   \"Can only perform an indexed distinct on a TABLE.\");\n            counted_t<datum_stream_t> s = v->as_seq(env->env);\n            // The reql_version matters here, because we copy `results` into `toret`\n            // in ascending order.\n            std::set<datum_t, optional_datum_less_t>\n                results(optional_datum_less_t(env->env->reql_version()));\n            batchspec_t batchspec = batchspec_t::user(batch_type_t::TERMINAL, env->env);\n            {\n                profile::sampler_t sampler(\"Evaluating elements in distinct.\",\n                                           env->env->trace);\n                datum_t d;\n                while (d = s->next(env->env, batchspec), d.has()) {\n                    results.insert(std::move(d));\n                    rcheck_array_size(results, env->env->limits(), base_exc_t::GENERIC);\n                    sampler.new_sample();",
        "res_region": "            } else if (!tbl_slice->get_idx() || *tbl_slice->get_idx() == idx_str) {\n                if (tbl_slice->sorting == sorting_t::UNORDERED) {\n                    tbl_slice = tbl_slice->with_sorting(idx_str, sorting_t::ASCENDING);\n                }\n                counted_t<datum_stream_t> s = tbl_slice->as_seq(env->env, backtrace());\n                s->add_transformation(distinct_wire_func_t(idx.has()), backtrace());\n                return new_val(env->env, s->ordered_distinct());",
        "lookback": "                if (tbl_slice->sorting == sorting_t::UNORDERED) {",
        "lookahead": "            }",
        "label": [
            "newcode",
            "complex_conflict"
        ],
        "start_line": 235,
        "end_line": 291,
        "merge_gen_region": " (__iftbliftbliftbliftbliftbliftbl",
        "confidence": 0.8912287950515747,
        "hesitated": false,
        "resolved": false
    }
]