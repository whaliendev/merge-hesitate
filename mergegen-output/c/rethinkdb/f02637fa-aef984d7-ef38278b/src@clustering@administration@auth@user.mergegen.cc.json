[
    {
        "a_contents": "// Copyright 2010-2015 RethinkDB, all rights reserved.\n#include \"clustering/administration/auth/user.hpp\"\n\n#include <set>\n#include <string>\n\n#include \"errors.hpp\"\n#include <boost/algorithm/string/join.hpp>\n\n#include \"arch/runtime/runtime_utils.hpp\"\n#include \"clustering/administration/metadata.hpp\"\n#include \"clustering/administration/tables/table_metadata.hpp\"\n#include \"clustering/table_manager/table_meta_client.hpp\"\n#include \"containers/archive/boost_types.hpp\"\n#include \"containers/archive/stl_types.hpp\"\n#include \"containers/archive/versioned.hpp\"\n\nnamespace auth {\n\n// Note that `m_global_permissions` has a different constructor from the other\n// permissions since it has the `\"connect\"` permission, be sure to construct it\n\nuser_t::user_t()\n    : m_password(boost::none),\n      m_global_permissions(\n        boost::indeterminate,\n        boost::indeterminate,\n        boost::indeterminate,\n        boost::indeterminate) {\n}\n\nuser_t::user_t(admin_t)\n    : m_password(boost::none),\n      m_global_permissions(true, true, true, true) {\n}\n\nuser_t::user_t(password_t password, permissions_t global_permissions)\n    : m_password(std::move(password)),\n      m_global_permissions(std::move(global_permissions)) {\n}\n\nuser_t::user_t(ql::datum_t const &datum)\n    : m_password(boost::none),\n      m_global_permissions(\n        boost::indeterminate,\n        boost::indeterminate,\n        boost::indeterminate,\n        boost::indeterminate) {\n    merge(datum);\n}\n\nvoid user_t::merge(ql::datum_t const &datum) {\n    if (!datum.has() || datum.get_type() != ql::datum_t::R_OBJECT) {\n        throw admin_op_exc_t(\n            \"Expected an object, got \" + datum.print() + \".\", query_state_t::FAILED);\n    }\n\n    ql::datum_t id = datum.get_field(\"id\", ql::NOTHROW);\n    if (!id.has()) {\n        throw admin_op_exc_t(\"Expected a field named `id`.\", query_state_t::FAILED);\n    }\n\n    ql::datum_t password = datum.get_field(\"password\", ql::NOTHROW);\n    if (!password.has()) {\n        throw admin_op_exc_t(\"Expected a field named `password`.\", query_state_t::FAILED);\n    }\n\n    if (datum.obj_size() != 2) {\n        std::set<std::string> keys;\n        for (size_t i = 0; i < datum.obj_size(); ++i) {\n            keys.insert(datum.get_pair(i).first.to_std());\n        }\n        keys.erase(\"id\");\n        keys.erase(\"password\");\n\n        throw admin_op_exc_t(\n            \"Unexpected key(s) `\" + boost::algorithm::join(keys, \"`, `\") + \"`.\",\n            query_state_t::FAILED);\n    }\n\n    if (password.get_type() == ql::datum_t::R_STR) {\n        set_password(password.as_str().to_std());\n    } else if (password.get_type() == ql::datum_t::R_BOOL) {\n        if (password.as_bool()) {\n            if (!static_cast<bool>(m_password)) {\n                throw admin_op_exc_t(\n                    \"Expected a string to set the password or `false` to keep it \"\n                    \"unset, got \" + password.print() + \".\",\n                    query_state_t::FAILED);\n            }\n        } else {\n            set_password(boost::none);\n        }\n    } else {\n        throw admin_op_exc_t(\n            \"Expected a string or boolean for `password`, got \" + password.print() + \".\",\n            query_state_t::FAILED);\n    }\n}\n\nbool user_t::has_password() const {\n    return static_cast<bool>(m_password);\n}\n\nboost::optional<password_t> const & user_t::get_password() const {\n    return m_password;\n}\n\nvoid user_t::set_password(boost::optional<std::string> password) {\n    if (static_cast<bool>(password)) {\n        m_password = std::move(password.get());\n    } else {\n        m_password = boost::none;\n    }\n}\n\npermissions_t const &user_t::get_global_permissions() const {\n    return m_global_permissions;\n}\n\npermissions_t &user_t::get_global_permissions() {\n    return m_global_permissions;\n}\n\nvoid user_t::set_global_permissions(permissions_t permissions) {\n    m_global_permissions = std::move(permissions);\n}\n\nstd::map<database_id_t, permissions_t> const &user_t::get_database_permissions() const {\n    return m_database_permissions;\n}\n\npermissions_t user_t::get_database_permissions(database_id_t const &database_id) const {\n    auto iter = m_database_permissions.find(database_id);\n    if (iter != m_database_permissions.end()) {\n        return iter->second;\n    } else {\n        return permissions_t(\n            boost::indeterminate, boost::indeterminate, boost::indeterminate);\n    }\n}\n\npermissions_t &user_t::get_database_permissions(database_id_t const &database_id) {\n    return m_database_permissions.insert(\n        std::make_pair(\n            database_id,\n            permissions_t(\n                boost::indeterminate,\n                boost::indeterminate,\n                boost::indeterminate))).first->second;\n}\n\nvoid user_t::set_database_permissions(\n        database_id_t const &database_id,\n        permissions_t permissions) {\n    if (permissions.is_indeterminate()) {\n        m_database_permissions.erase(database_id);\n    } else {\n        m_database_permissions[database_id] = std::move(permissions);\n    }\n}\n\nstd::map<namespace_id_t, permissions_t> const &user_t::get_table_permissions() const {\n    return m_table_permissions;\n}\n\npermissions_t user_t::get_table_permissions(namespace_id_t const &table_id) const {\n    auto iter = m_table_permissions.find(table_id);\n    if (iter != m_table_permissions.end()) {\n        return iter->second;\n    } else {\n        return permissions_t(\n            boost::indeterminate, boost::indeterminate, boost::indeterminate);\n    }\n}\n\npermissions_t &user_t::get_table_permissions(namespace_id_t const &table_id) {\n    return m_table_permissions.insert(\n        std::make_pair(\n            table_id,\n            permissions_t(\n                boost::indeterminate,\n                boost::indeterminate,\n                boost::indeterminate))).first->second;\n}\n\nvoid user_t::set_table_permissions(\n        namespace_id_t const &table_id,\n        permissions_t permissions) {\n    if (permissions.is_indeterminate()) {\n        m_table_permissions.erase(table_id);\n    } else {\n        m_table_permissions[table_id] = std::move(permissions);\n    }\n}\n\nbool user_t::has_read_permission(\n        database_id_t const &database_id,\n        namespace_id_t const &table_id) const {\n    auto table = m_table_permissions.find(table_id);\n    if (table != m_table_permissions.end()) {\n        boost::tribool table_permission = table->second.get_read();\n        if (!indeterminate(table_permission)) {\n            return table_permission;\n        }\n    }\n\n    auto database = m_database_permissions.find(database_id);\n    if (database != m_database_permissions.end()) {\n        boost::tribool database_permission = database->second.get_read();\n        if (!indeterminate(database_permission)) {\n            return database_permission;\n        }\n    }\n\n    return m_global_permissions.get_read() || false;\n}\n\nbool user_t::has_write_permission(\n        database_id_t const &database_id,\n        namespace_id_t const &table_id) const {\n    auto table = m_table_permissions.find(table_id);\n    if (table != m_table_permissions.end()) {\n        boost::tribool table_permission = table->second.get_write();\n        if (!indeterminate(table_permission)) {\n            return table_permission;\n        }\n    }\n\n    auto database = m_database_permissions.find(database_id);\n    if (database != m_database_permissions.end()) {\n        boost::tribool database_permission = database->second.get_write();\n        if (!indeterminate(database_permission)) {\n            return database_permission;\n        }\n    }\n\n    return m_global_permissions.get_write() || false;\n}\n\nbool user_t::has_config_permission() const {\n    return m_global_permissions.get_config() || false;\n}\n\nbool user_t::has_config_permission(\n        database_id_t const &database_id) const {\n    auto database = m_database_permissions.find(database_id);\n    if (database != m_database_permissions.end()) {\n        boost::tribool database_permission = database->second.get_config();\n        if (!indeterminate(database_permission)) {\n            return database_permission;\n        }\n    }\n\n    return has_config_permission();\n}\n\nbool user_t::has_config_permission(\n        database_id_t const &database_id,\n        namespace_id_t const &table_id) const {\n    auto table = m_table_permissions.find(table_id);\n    if (table != m_table_permissions.end()) {\n        boost::tribool table_permission = table->second.get_config();\n        if (!indeterminate(table_permission)) {\n            return table_permission;\n        }\n    }\n\n    return has_config_permission(database_id);\n}\n\nbool user_t::has_connect_permission() const {\n    return m_global_permissions.get_connect() || false;\n}\n\nbool user_t::operator==(user_t const &rhs) const {\n    return\n        m_password == rhs.m_password &&\n        m_global_permissions == rhs.m_global_permissions &&\n        m_database_permissions == rhs.m_database_permissions &&\n        m_table_permissions == rhs.m_table_permissions;\n}\n\nRDB_IMPL_SERIALIZABLE_4(\n    user_t,\n    m_password,\n    m_global_permissions,\n    m_database_permissions,\n    m_table_permissions);\nINSTANTIATE_SERIALIZABLE_SINCE_v2_3(user_t);\n\n}  // namespace auth",
        "b_contents": "// Copyright 2010-2015 RethinkDB, all rights reserved.\n#include \"clustering/administration/auth/user.hpp\"\n\n#include <set>\n#include <string>\n\n#include \"errors.hpp\"\n#include <boost/algorithm/string/join.hpp>\n\n#include \"arch/runtime/runtime_utils.hpp\"\n#include \"clustering/administration/metadata.hpp\"\n#include \"clustering/administration/tables/table_metadata.hpp\"\n#include \"clustering/table_manager/table_meta_client.hpp\"\n#include \"containers/archive/boost_types.hpp\"\n#include \"containers/archive/stl_types.hpp\"\n#include \"containers/archive/versioned.hpp\"\n\nnamespace auth {\n\n// Note that `m_global_permissions` has a different constructor from the other\n// permissions since it has the `\"connect\"` permission, be sure to construct it\n\nuser_t::user_t()\n    : m_password(boost::none),\n      m_global_permissions(\n        boost::indeterminate,\n        boost::indeterminate,\n        boost::indeterminate,\n        boost::indeterminate) {\n}\n\nuser_t::user_t(admin_t)\n    : m_password(boost::none),\n      m_global_permissions(true, true, true, true) {\n}\n\nuser_t::user_t(ql::datum_t const &datum)\n    : m_password(boost::none),\n      m_global_permissions(\n        boost::indeterminate,\n        boost::indeterminate,\n        boost::indeterminate,\n        boost::indeterminate) {\n    merge(datum);\n}\n\nvoid user_t::merge(ql::datum_t const &datum) {\n    if (!datum.has() || datum.get_type() != ql::datum_t::R_OBJECT) {\n        throw admin_op_exc_t(\n            \"Expected an object, got \" + datum.print() + \".\", query_state_t::FAILED);\n    }\n\n    ql::datum_t id = datum.get_field(\"id\", ql::NOTHROW);\n    if (!id.has()) {\n        throw admin_op_exc_t(\"Expected a field named `id`.\", query_state_t::FAILED);\n    }\n\n    ql::datum_t password = datum.get_field(\"password\", ql::NOTHROW);\n    if (!password.has()) {\n        throw admin_op_exc_t(\"Expected a field named `password`.\", query_state_t::FAILED);\n    }\n\n    if (datum.obj_size() != 2) {\n        std::set<std::string> keys;\n        for (size_t i = 0; i < datum.obj_size(); ++i) {\n            keys.insert(datum.get_pair(i).first.to_std());\n        }\n        keys.erase(\"id\");\n        keys.erase(\"password\");\n\n        throw admin_op_exc_t(\n            \"Unexpected key(s) `\" + boost::algorithm::join(keys, \"`, `\") + \"`.\",\n            query_state_t::FAILED);\n    }\n\n    if (password.get_type() == ql::datum_t::R_STR) {\n        set_password(password.as_str().to_std());\n    } else if (password.get_type() == ql::datum_t::R_BOOL) {\n        if (password.as_bool()) {\n            if (!static_cast<bool>(m_password)) {\n                throw admin_op_exc_t(\n                    \"Expected a string to set the password or `false` to keep it \"\n                    \"unset, got \" + password.print() + \".\",\n                    query_state_t::FAILED);\n            }\n        } else {\n            set_password(boost::none);\n        }\n    } else {\n        throw admin_op_exc_t(\n            \"Expected a string or boolean for `password`, got \" + password.print() + \".\",\n            query_state_t::FAILED);\n    }\n}\n\nbool user_t::has_password() const {\n    return static_cast<bool>(m_password);\n}\n\nboost::optional<password_t> const & user_t::get_password() const {\n    return m_password;\n}\n\nvoid user_t::set_password(boost::optional<std::string> password) {\n    if (static_cast<bool>(password)) {\n        m_password = std::move(password.get());\n    } else {\n        m_password = boost::none;\n    }\n}\n\npermissions_t const &user_t::get_global_permissions() const {\n    return m_global_permissions;\n}\n\npermissions_t &user_t::get_global_permissions() {\n    return m_global_permissions;\n}\n\nvoid user_t::set_global_permissions(permissions_t permissions) {\n    m_global_permissions = std::move(permissions);\n}\n\nstd::map<database_id_t, permissions_t> const &user_t::get_database_permissions() const {\n    return m_database_permissions;\n}\n\npermissions_t user_t::get_database_permissions(database_id_t const &database_id) const {\n    auto iter = m_database_permissions.find(database_id);\n    if (iter != m_database_permissions.end()) {\n        return iter->second;\n    } else {\n        return permissions_t(\n            boost::indeterminate, boost::indeterminate, boost::indeterminate);\n    }\n}\n\npermissions_t &user_t::get_database_permissions(database_id_t const &database_id) {\n    return m_database_permissions.insert(\n        std::make_pair(\n            database_id,\n            permissions_t(\n                boost::indeterminate,\n                boost::indeterminate,\n                boost::indeterminate))).first->second;\n}\n\nvoid user_t::set_database_permissions(\n        database_id_t const &database_id,\n        permissions_t permissions) {\n    if (permissions.is_indeterminate()) {\n        m_database_permissions.erase(database_id);\n    } else {\n        m_database_permissions[database_id] = std::move(permissions);\n    }\n}\n\nstd::map<namespace_id_t, permissions_t> const &user_t::get_table_permissions() const {\n    return m_table_permissions;\n}\n\npermissions_t user_t::get_table_permissions(namespace_id_t const &table_id) const {\n    auto iter = m_table_permissions.find(table_id);\n    if (iter != m_table_permissions.end()) {\n        return iter->second;\n    } else {\n        return permissions_t(\n            boost::indeterminate, boost::indeterminate, boost::indeterminate);\n    }\n}\n\npermissions_t &user_t::get_table_permissions(namespace_id_t const &table_id) {\n    return m_table_permissions.insert(\n        std::make_pair(\n            table_id,\n            permissions_t(\n                boost::indeterminate,\n                boost::indeterminate,\n                boost::indeterminate))).first->second;\n}\n\nvoid user_t::set_table_permissions(\n        namespace_id_t const &table_id,\n        permissions_t permissions) {\n    if (permissions.is_indeterminate()) {\n        m_table_permissions.erase(table_id);\n    } else {\n        m_table_permissions[table_id] = std::move(permissions);\n    }\n}\n\nbool user_t::has_read_permission(\n        database_id_t const &database_id,\n        namespace_id_t const &table_id) const {\n    auto table = m_table_permissions.find(table_id);\n    if (table != m_table_permissions.end()) {\n        boost::tribool table_permission = table->second.get_read();\n        if (!indeterminate(table_permission)) {\n            return table_permission;\n        }\n    }\n\n    auto database = m_database_permissions.find(database_id);\n    if (database != m_database_permissions.end()) {\n        boost::tribool database_permission = database->second.get_read();\n        if (!indeterminate(database_permission)) {\n            return database_permission;\n        }\n    }\n\n    return m_global_permissions.get_read() || false;\n}\n\nbool user_t::has_write_permission(\n        database_id_t const &database_id,\n        namespace_id_t const &table_id) const {\n    auto table = m_table_permissions.find(table_id);\n    if (table != m_table_permissions.end()) {\n        boost::tribool table_permission = table->second.get_write();\n        if (!indeterminate(table_permission)) {\n            return table_permission;\n        }\n    }\n\n    auto database = m_database_permissions.find(database_id);\n    if (database != m_database_permissions.end()) {\n        boost::tribool database_permission = database->second.get_write();\n        if (!indeterminate(database_permission)) {\n            return database_permission;\n        }\n    }\n\n    return m_global_permissions.get_write() || false;\n}\n\nbool user_t::has_config_permission() const {\n    return m_global_permissions.get_config() || false;\n}\n\nbool user_t::has_config_permission(\n        database_id_t const &database_id) const {\n    auto database = m_database_permissions.find(database_id);\n    if (database != m_database_permissions.end()) {\n        boost::tribool database_permission = database->second.get_config();\n        if (!indeterminate(database_permission)) {\n            return database_permission;\n        }\n    }\n\n    return has_config_permission();\n}\n\nbool user_t::has_config_permission(\n        database_id_t const &database_id,\n        namespace_id_t const &table_id) const {\n    auto table = m_table_permissions.find(table_id);\n    if (table != m_table_permissions.end()) {\n        boost::tribool table_permission = table->second.get_config();\n        if (!indeterminate(table_permission)) {\n            return table_permission;\n        }\n    }\n\n    return has_config_permission(database_id);\n}\n\nbool user_t::has_connect_permission() const {\n    return m_global_permissions.get_connect() || false;\n}\n\nbool user_t::operator==(user_t const &rhs) const {\n    return\n        m_password == rhs.m_password &&\n        m_global_permissions == rhs.m_global_permissions &&\n        m_database_permissions == rhs.m_database_permissions &&\n        m_table_permissions == rhs.m_table_permissions;\n}\n\nRDB_IMPL_SERIALIZABLE_4(\n    user_t,\n    m_password,\n    m_global_permissions,\n    m_database_permissions,\n    m_table_permissions);\nINSTANTIATE_SERIALIZABLE_SINCE_v2_3(user_t);\n\n}  // namespace auth",
        "base_contents": "",
        "res_region": "// Copyright 2010-2015 RethinkDB, all rights reserved.\n#include \"clustering/administration/auth/user.hpp\"\n\n#include <set>\n#include <string>\n\n#include \"errors.hpp\"\n#include <boost/algorithm/string/join.hpp>\n\n#include \"arch/runtime/runtime_utils.hpp\"\n#include \"clustering/administration/metadata.hpp\"\n#include \"clustering/administration/tables/table_metadata.hpp\"\n#include \"clustering/table_manager/table_meta_client.hpp\"\n#include \"containers/archive/boost_types.hpp\"\n#include \"containers/archive/stl_types.hpp\"\n#include \"containers/archive/versioned.hpp\"\n\nnamespace auth {\n\n// Note that `m_global_permissions` has a different constructor from the other\n// permissions since it has the `\"connect\"` permission, be sure to construct it\n\nuser_t::user_t()\n    : m_password(boost::none),\n      m_global_permissions(\n        boost::indeterminate,\n        boost::indeterminate,\n        boost::indeterminate,\n        boost::indeterminate) {\n}\n\nuser_t::user_t(admin_t)\n    : m_password(boost::none),\n      m_global_permissions(true, true, true, true) {\n}\n\nuser_t::user_t(password_t password, permissions_t global_permissions)\n    : m_password(std::move(password)),\n      m_global_permissions(std::move(global_permissions)) {\n}\n\nuser_t::user_t(ql::datum_t const &datum)\n    : m_password(boost::none),\n      m_global_permissions(\n        boost::indeterminate,\n        boost::indeterminate,\n        boost::indeterminate,\n        boost::indeterminate) {\n    merge(datum);\n}\n\nvoid user_t::merge(ql::datum_t const &datum) {\n    if (!datum.has() || datum.get_type() != ql::datum_t::R_OBJECT) {\n        throw admin_op_exc_t(\n            \"Expected an object, got \" + datum.print() + \".\", query_state_t::FAILED);\n    }\n\n    ql::datum_t id = datum.get_field(\"id\", ql::NOTHROW);\n    if (!id.has()) {\n        throw admin_op_exc_t(\"Expected a field named `id`.\", query_state_t::FAILED);\n    }\n\n    ql::datum_t password = datum.get_field(\"password\", ql::NOTHROW);\n    if (!password.has()) {\n        throw admin_op_exc_t(\"Expected a field named `password`.\", query_state_t::FAILED);\n    }\n\n    if (datum.obj_size() != 2) {\n        std::set<std::string> keys;\n        for (size_t i = 0; i < datum.obj_size(); ++i) {\n            keys.insert(datum.get_pair(i).first.to_std());\n        }\n        keys.erase(\"id\");\n        keys.erase(\"password\");\n\n        throw admin_op_exc_t(\n            \"Unexpected key(s) `\" + boost::algorithm::join(keys, \"`, `\") + \"`.\",\n            query_state_t::FAILED);\n    }\n\n    if (password.get_type() == ql::datum_t::R_STR) {\n        set_password(password.as_str().to_std());\n    } else if (password.get_type() == ql::datum_t::R_BOOL) {\n        if (password.as_bool()) {\n            if (!static_cast<bool>(m_password)) {\n                throw admin_op_exc_t(\n                    \"Expected a string to set the password or `false` to keep it \"\n                    \"unset, got \" + password.print() + \".\",\n                    query_state_t::FAILED);\n            }\n        } else {\n            set_password(boost::none);\n        }\n    } else {\n        throw admin_op_exc_t(\n            \"Expected a string or boolean for `password`, got \" + password.print() + \".\",\n            query_state_t::FAILED);\n    }\n}\n\nbool user_t::has_password() const {\n    return static_cast<bool>(m_password);\n}\n\nboost::optional<password_t> const & user_t::get_password() const {\n    return m_password;\n}\n\nvoid user_t::set_password(boost::optional<std::string> password) {\n    if (static_cast<bool>(password)) {\n        m_password = std::move(password.get());\n    } else {\n        m_password = boost::none;\n    }\n}\n\npermissions_t const &user_t::get_global_permissions() const {\n    return m_global_permissions;\n}\n\npermissions_t &user_t::get_global_permissions() {\n    return m_global_permissions;\n}\n\nvoid user_t::set_global_permissions(permissions_t permissions) {\n    m_global_permissions = std::move(permissions);\n}\n\nstd::map<database_id_t, permissions_t> const &user_t::get_database_permissions() const {\n    return m_database_permissions;\n}\n\npermissions_t user_t::get_database_permissions(database_id_t const &database_id) const {\n    auto iter = m_database_permissions.find(database_id);\n    if (iter != m_database_permissions.end()) {\n        return iter->second;\n    } else {\n        return permissions_t(\n            boost::indeterminate, boost::indeterminate, boost::indeterminate);\n    }\n}\n\npermissions_t &user_t::get_database_permissions(database_id_t const &database_id) {\n    return m_database_permissions.insert(\n        std::make_pair(\n            database_id,\n            permissions_t(\n                boost::indeterminate,\n                boost::indeterminate,\n                boost::indeterminate))).first->second;\n}\n\nvoid user_t::set_database_permissions(\n        database_id_t const &database_id,\n        permissions_t permissions) {\n    if (permissions.is_indeterminate()) {\n        m_database_permissions.erase(database_id);\n    } else {\n        m_database_permissions[database_id] = std::move(permissions);\n    }\n}\n\nstd::map<namespace_id_t, permissions_t> const &user_t::get_table_permissions() const {\n    return m_table_permissions;\n}\n\npermissions_t user_t::get_table_permissions(namespace_id_t const &table_id) const {\n    auto iter = m_table_permissions.find(table_id);\n    if (iter != m_table_permissions.end()) {\n        return iter->second;\n    } else {\n        return permissions_t(\n            boost::indeterminate, boost::indeterminate, boost::indeterminate);\n    }\n}\n\npermissions_t &user_t::get_table_permissions(namespace_id_t const &table_id) {\n    return m_table_permissions.insert(\n        std::make_pair(\n            table_id,\n            permissions_t(\n                boost::indeterminate,\n                boost::indeterminate,\n                boost::indeterminate))).first->second;\n}\n\nvoid user_t::set_table_permissions(\n        namespace_id_t const &table_id,\n        permissions_t permissions) {\n    if (permissions.is_indeterminate()) {\n        m_table_permissions.erase(table_id);\n    } else {\n        m_table_permissions[table_id] = std::move(permissions);\n    }\n}\n\nbool user_t::has_read_permission(\n        database_id_t const &database_id,\n        namespace_id_t const &table_id) const {\n    auto table = m_table_permissions.find(table_id);\n    if (table != m_table_permissions.end()) {\n        boost::tribool table_permission = table->second.get_read();\n        if (!indeterminate(table_permission)) {\n            return table_permission;\n        }\n    }\n\n    auto database = m_database_permissions.find(database_id);\n    if (database != m_database_permissions.end()) {\n        boost::tribool database_permission = database->second.get_read();\n        if (!indeterminate(database_permission)) {\n            return database_permission;\n        }\n    }\n\n    return m_global_permissions.get_read() || false;\n}\n\nbool user_t::has_write_permission(\n        database_id_t const &database_id,\n        namespace_id_t const &table_id) const {\n    auto table = m_table_permissions.find(table_id);\n    if (table != m_table_permissions.end()) {\n        boost::tribool table_permission = table->second.get_write();\n        if (!indeterminate(table_permission)) {\n            return table_permission;\n        }\n    }\n\n    auto database = m_database_permissions.find(database_id);\n    if (database != m_database_permissions.end()) {\n        boost::tribool database_permission = database->second.get_write();\n        if (!indeterminate(database_permission)) {\n            return database_permission;\n        }\n    }\n\n    return m_global_permissions.get_write() || false;\n}\n\nbool user_t::has_config_permission() const {\n    return m_global_permissions.get_config() || false;\n}\n\nbool user_t::has_config_permission(\n        database_id_t const &database_id) const {\n    auto database = m_database_permissions.find(database_id);\n    if (database != m_database_permissions.end()) {\n        boost::tribool database_permission = database->second.get_config();\n        if (!indeterminate(database_permission)) {\n            return database_permission;\n        }\n    }\n\n    return has_config_permission();\n}\n\nbool user_t::has_config_permission(\n        database_id_t const &database_id,\n        namespace_id_t const &table_id) const {\n    auto table = m_table_permissions.find(table_id);\n    if (table != m_table_permissions.end()) {\n        boost::tribool table_permission = table->second.get_config();\n        if (!indeterminate(table_permission)) {\n            return table_permission;\n        }\n    }\n\n    return has_config_permission(database_id);\n}\n\nbool user_t::has_connect_permission() const {\n    return m_global_permissions.get_connect() || false;\n}\n\nbool user_t::operator==(user_t const &rhs) const {\n    return\n        m_password == rhs.m_password &&\n        m_global_permissions == rhs.m_global_permissions &&\n        m_database_permissions == rhs.m_database_permissions &&\n        m_table_permissions == rhs.m_table_permissions;\n}\n\nRDB_IMPL_SERIALIZABLE_4(\n    user_t,\n    m_password,\n    m_global_permissions,\n    m_database_permissions,\n    m_table_permissions);\nINSTANTIATE_SERIALIZABLE_SINCE_v2_3(user_t);\n\n}  // namespace auth",
        "lookback": "#include \"clustering/administration/auth/user.hpp\"",
        "lookahead": "",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 0,
        "end_line": 582,
        "merge_gen_region": null,
        "confidence": 0.7963937520980835,
        "hesitated": true
    }
]