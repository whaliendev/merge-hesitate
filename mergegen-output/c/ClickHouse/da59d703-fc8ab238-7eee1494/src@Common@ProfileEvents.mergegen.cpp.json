[
    {
        "a_contents": "    M(Query, \"Number of queries to be interpreted and potentially executed. Does not include queries that failed to parse or were rejected due to AST size limits, quota limits or limits on the number of simultaneously running queries. May include internal queries initiated by ClickHouse itself. Does not count subqueries.\") \\\n    M(SelectQuery, \"Same as Query, but only for SELECT queries.\") \\\n    M(InsertQuery, \"Same as Query, but only for INSERT queries.\") \\\n    M(InitialQuery, \"Same as Query, but only counts initial queries (see is_initial_query).\")\\\n    M(QueriesWithSubqueries, \"Count queries with all subqueries\") \\\n    M(SelectQueriesWithSubqueries, \"Count SELECT queries with all subqueries\") \\\n    M(InsertQueriesWithSubqueries, \"Count INSERT queries with all subqueries\") \\\n    M(SelectQueriesWithPrimaryKeyUsage, \"Count SELECT queries which use the primary key to evaluate the WHERE condition\") \\\n    M(AsyncInsertQuery, \"Same as InsertQuery, but only for asynchronous INSERT queries.\") \\\n    M(AsyncInsertBytes, \"Data size in bytes of asynchronous INSERT queries.\") \\\n    M(AsyncInsertRows, \"Number of rows inserted by asynchronous INSERT queries.\") \\\n    M(AsyncInsertCacheHits, \"Number of times a duplicate hash id has been found in asynchronous INSERT hash id cache.\") \\\n    M(FailedQuery, \"Number of failed queries.\") \\\n    M(FailedSelectQuery, \"Same as FailedQuery, but only for SELECT queries.\") \\\n    M(FailedInsertQuery, \"Same as FailedQuery, but only for INSERT queries.\") \\\n    M(FailedAsyncInsertQuery, \"Number of failed ASYNC INSERT queries.\") \\\n    M(QueryTimeMicroseconds, \"Total time of all queries.\") \\\n    M(SelectQueryTimeMicroseconds, \"Total time of SELECT queries.\") \\\n    M(InsertQueryTimeMicroseconds, \"Total time of INSERT queries.\") \\\n    M(OtherQueryTimeMicroseconds, \"Total time of queries that are not SELECT or INSERT.\") \\\n    M(FileOpen, \"Number of files opened.\") \\\n    M(Seek, \"Number of times the 'lseek' function was called.\") \\\n    M(ReadBufferFromFileDescriptorRead, \"Number of reads (read/pread) from a file descriptor. Does not include sockets.\") \\\n    M(ReadBufferFromFileDescriptorReadFailed, \"Number of times the read (read/pread) from a file descriptor have failed.\") \\\n    M(ReadBufferFromFileDescriptorReadBytes, \"Number of bytes read from file descriptors. If the file is compressed, this will show the compressed data size.\") \\\n    M(WriteBufferFromFileDescriptorWrite, \"Number of writes (write/pwrite) to a file descriptor. Does not include sockets.\") \\\n    M(WriteBufferFromFileDescriptorWriteFailed, \"Number of times the write (write/pwrite) to a file descriptor have failed.\") \\\n    M(WriteBufferFromFileDescriptorWriteBytes, \"Number of bytes written to file descriptors. If the file is compressed, this will show compressed data size.\") \\\n    M(FileSync, \"Number of times the F_FULLFSYNC/fsync/fdatasync function was called for files.\") \\\n    M(DirectorySync, \"Number of times the F_FULLFSYNC/fsync/fdatasync function was called for directories.\") \\\n    M(FileSyncElapsedMicroseconds, \"Total time spent waiting for F_FULLFSYNC/fsync/fdatasync syscall for files.\") \\\n    M(DirectorySyncElapsedMicroseconds, \"Total time spent waiting for F_FULLFSYNC/fsync/fdatasync syscall for directories.\") \\\n    M(ReadCompressedBytes, \"Number of bytes (the number of bytes before decompression) read from compressed sources (files, network).\") \\\n    M(CompressedReadBufferBlocks, \"Number of compressed blocks (the blocks of data that are compressed independent of each other) read from compressed sources (files, network).\") \\\n    M(CompressedReadBufferBytes, \"Number of uncompressed bytes (the number of bytes after decompression) read from compressed sources (files, network).\") \\\n    M(UncompressedCacheHits, \"Number of times a block of data has been found in the uncompressed cache (and decompression was avoided).\") \\\n    M(UncompressedCacheMisses, \"Number of times a block of data has not been found in the uncompressed cache (and required decompression).\") \\\n    M(UncompressedCacheWeightLost, \"Number of bytes evicted from the uncompressed cache.\") \\\n    M(MMappedFileCacheHits, \"Number of times a file has been found in the MMap cache (for the 'mmap' read_method), so we didn't have to mmap it again.\") \\\n    M(MMappedFileCacheMisses, \"Number of times a file has not been found in the MMap cache (for the 'mmap' read_method), so we had to mmap it again.\") \\\n    M(OpenedFileCacheHits, \"Number of times a file has been found in the opened file cache, so we didn't have to open it again.\") \\\n    M(OpenedFileCacheMisses, \"Number of times a file has been found in the opened file cache, so we had to open it again.\") \\\n    M(OpenedFileCacheMicroseconds, \"Amount of time spent executing OpenedFileCache methods.\") \\\n    M(AIOWrite, \"Number of writes with Linux or FreeBSD AIO interface\") \\\n    M(AIOWriteBytes, \"Number of bytes written with Linux or FreeBSD AIO interface\") \\\n    M(AIORead, \"Number of reads with Linux or FreeBSD AIO interface\") \\\n    M(AIOReadBytes, \"Number of bytes read with Linux or FreeBSD AIO interface\") \\\n    M(IOBufferAllocs, \"Number of allocations of IO buffers (for ReadBuffer/WriteBuffer).\") \\\n    M(IOBufferAllocBytes, \"Number of bytes allocated for IO buffers (for ReadBuffer/WriteBuffer).\") \\\n    M(ArenaAllocChunks, \"Number of chunks allocated for memory Arena (used for GROUP BY and similar operations)\") \\\n    M(ArenaAllocBytes, \"Number of bytes allocated for memory Arena (used for GROUP BY and similar operations)\") \\\n    M(FunctionExecute, \"Number of SQL ordinary function calls (SQL functions are called on per-block basis, so this number represents the number of blocks).\") \\\n    M(TableFunctionExecute, \"Number of table function calls.\") \\\n    M(MarkCacheHits, \"Number of times an entry has been found in the mark cache, so we didn't have to load a mark file.\") \\\n    M(MarkCacheMisses, \"Number of times an entry has not been found in the mark cache, so we had to load a mark file in memory, which is a costly operation, adding to query latency.\") \\\n    M(QueryCacheHits, \"Number of times a query result has been found in the query cache (and query computation was avoided). Only updated for SELECT queries with SETTING use_query_cache = 1.\") \\\n    M(QueryCacheMisses, \"Number of times a query result has not been found in the query cache (and required query computation). Only updated for SELECT queries with SETTING use_query_cache = 1.\") \\\n    M(QueryConditionCacheHits, \"Number of times an entry has been found in the query condition cache (and reading of invalid marks can be skipped). Only updated for SELECT queries with SETTING use_query_condition_cache = 1.\") \\\n    M(QueryConditionCacheMisses, \"Number of times an entry has not been found in the query condition cache (and reading of mark cannot be skipped). Only updated for SELECT queries with SETTING use_query_condition_cache = 1.\") \\",
        "b_contents": "    M(Query, \"Number of queries to be interpreted and potentially executed. Does not include queries that failed to parse or were rejected due to AST size limits, quota limits or limits on the number of simultaneously running queries. May include internal queries initiated by ClickHouse itself. Does not count subqueries.\", ValueType::Number) \\\n    M(SelectQuery, \"Same as Query, but only for SELECT queries.\", ValueType::Number) \\\n    M(InsertQuery, \"Same as Query, but only for INSERT queries.\", ValueType::Number) \\\n    M(InitialQuery, \"Same as Query, but only counts initial queries (see is_initial_query).\", ValueType::Number)\\\n    M(QueriesWithSubqueries, \"Count queries with all subqueries\", ValueType::Number) \\\n    M(SelectQueriesWithSubqueries, \"Count SELECT queries with all subqueries\", ValueType::Number) \\\n    M(InsertQueriesWithSubqueries, \"Count INSERT queries with all subqueries\", ValueType::Number) \\\n    M(SelectQueriesWithPrimaryKeyUsage, \"Count SELECT queries which use the primary key to evaluate the WHERE condition\", ValueType::Number) \\\n    M(AsyncInsertQuery, \"Same as InsertQuery, but only for asynchronous INSERT queries.\", ValueType::Number) \\\n    M(AsyncInsertBytes, \"Data size in bytes of asynchronous INSERT queries.\", ValueType::Bytes) \\\n    M(AsyncInsertRows, \"Number of rows inserted by asynchronous INSERT queries.\", ValueType::Number) \\\n    M(AsyncInsertCacheHits, \"Number of times a duplicate hash id has been found in asynchronous INSERT hash id cache.\", ValueType::Number) \\\n    M(FailedQuery, \"Number of failed queries.\", ValueType::Number) \\\n    M(FailedSelectQuery, \"Same as FailedQuery, but only for SELECT queries.\", ValueType::Number) \\\n    M(FailedInsertQuery, \"Same as FailedQuery, but only for INSERT queries.\", ValueType::Number) \\\n    M(FailedAsyncInsertQuery, \"Number of failed ASYNC INSERT queries.\", ValueType::Number) \\\n    M(QueryTimeMicroseconds, \"Total time of all queries.\", ValueType::Microseconds) \\\n    M(SelectQueryTimeMicroseconds, \"Total time of SELECT queries.\", ValueType::Microseconds) \\\n    M(InsertQueryTimeMicroseconds, \"Total time of INSERT queries.\", ValueType::Microseconds) \\\n    M(OtherQueryTimeMicroseconds, \"Total time of queries that are not SELECT or INSERT.\", ValueType::Microseconds) \\\n    M(FileOpen, \"Number of files opened.\", ValueType::Number) \\\n    M(Seek, \"Number of times the 'lseek' function was called.\", ValueType::Number) \\\n    M(ReadBufferFromFileDescriptorRead, \"Number of reads (read/pread) from a file descriptor. Does not include sockets.\", ValueType::Number) \\\n    M(ReadBufferFromFileDescriptorReadFailed, \"Number of times the read (read/pread) from a file descriptor have failed.\", ValueType::Number) \\\n    M(ReadBufferFromFileDescriptorReadBytes, \"Number of bytes read from file descriptors. If the file is compressed, this will show the compressed data size.\", ValueType::Bytes) \\\n    M(WriteBufferFromFileDescriptorWrite, \"Number of writes (write/pwrite) to a file descriptor. Does not include sockets.\", ValueType::Number) \\\n    M(WriteBufferFromFileDescriptorWriteFailed, \"Number of times the write (write/pwrite) to a file descriptor have failed.\", ValueType::Number) \\\n    M(WriteBufferFromFileDescriptorWriteBytes, \"Number of bytes written to file descriptors. If the file is compressed, this will show compressed data size.\", ValueType::Bytes) \\\n    M(FileSync, \"Number of times the F_FULLFSYNC/fsync/fdatasync function was called for files.\", ValueType::Number) \\\n    M(DirectorySync, \"Number of times the F_FULLFSYNC/fsync/fdatasync function was called for directories.\", ValueType::Number) \\\n    M(FileSyncElapsedMicroseconds, \"Total time spent waiting for F_FULLFSYNC/fsync/fdatasync syscall for files.\", ValueType::Microseconds) \\\n    M(DirectorySyncElapsedMicroseconds, \"Total time spent waiting for F_FULLFSYNC/fsync/fdatasync syscall for directories.\", ValueType::Microseconds) \\\n    M(ReadCompressedBytes, \"Number of bytes (the number of bytes before decompression) read from compressed sources (files, network).\", ValueType::Bytes) \\\n    M(CompressedReadBufferBlocks, \"Number of compressed blocks (the blocks of data that are compressed independent of each other) read from compressed sources (files, network).\", ValueType::Number) \\\n    M(CompressedReadBufferBytes, \"Number of uncompressed bytes (the number of bytes after decompression) read from compressed sources (files, network).\", ValueType::Bytes) \\\n    M(UncompressedCacheHits, \"Number of times a block of data has been found in the uncompressed cache (and decompression was avoided).\", ValueType::Number) \\\n    M(UncompressedCacheMisses, \"Number of times a block of data has not been found in the uncompressed cache (and required decompression).\", ValueType::Number) \\\n    M(UncompressedCacheWeightLost, \"Number of bytes evicted from the uncompressed cache.\", ValueType::Bytes) \\\n    M(MMappedFileCacheHits, \"Number of times a file has been found in the MMap cache (for the 'mmap' read_method), so we didn't have to mmap it again.\", ValueType::Number) \\\n    M(MMappedFileCacheMisses, \"Number of times a file has not been found in the MMap cache (for the 'mmap' read_method), so we had to mmap it again.\", ValueType::Number) \\\n    M(OpenedFileCacheHits, \"Number of times a file has been found in the opened file cache, so we didn't have to open it again.\", ValueType::Number) \\\n    M(OpenedFileCacheMisses, \"Number of times a file has been found in the opened file cache, so we had to open it again.\", ValueType::Number) \\\n    M(OpenedFileCacheMicroseconds, \"Amount of time spent executing OpenedFileCache methods.\", ValueType::Microseconds) \\\n    M(AIOWrite, \"Number of writes with Linux or FreeBSD AIO interface\", ValueType::Number) \\\n    M(AIOWriteBytes, \"Number of bytes written with Linux or FreeBSD AIO interface\", ValueType::Bytes) \\\n    M(AIORead, \"Number of reads with Linux or FreeBSD AIO interface\", ValueType::Number) \\\n    M(AIOReadBytes, \"Number of bytes read with Linux or FreeBSD AIO interface\", ValueType::Bytes) \\\n    M(IOBufferAllocs, \"Number of allocations of IO buffers (for ReadBuffer/WriteBuffer).\", ValueType::Number) \\\n    M(IOBufferAllocBytes, \"Number of bytes allocated for IO buffers (for ReadBuffer/WriteBuffer).\", ValueType::Bytes) \\\n    M(ArenaAllocChunks, \"Number of chunks allocated for memory Arena (used for GROUP BY and similar operations)\", ValueType::Number) \\\n    M(ArenaAllocBytes, \"Number of bytes allocated for memory Arena (used for GROUP BY and similar operations)\", ValueType::Bytes) \\\n    M(FunctionExecute, \"Number of SQL ordinary function calls (SQL functions are called on per-block basis, so this number represents the number of blocks).\", ValueType::Number) \\\n    M(TableFunctionExecute, \"Number of table function calls.\", ValueType::Number) \\\n    M(DefaultImplementationForNullsRows, \"Number of rows processed by default implementation for nulls in function execution\", ValueType::Number) \\\n    M(DefaultImplementationForNullsRowsWithNulls, \"Number of rows which contain null values processed by default implementation for nulls in function execution\", ValueType::Number) \\\n    M(MarkCacheHits, \"Number of times an entry has been found in the mark cache, so we didn't have to load a mark file.\", ValueType::Number) \\\n    M(MarkCacheMisses, \"Number of times an entry has not been found in the mark cache, so we had to load a mark file in memory, which is a costly operation, adding to query latency.\", ValueType::Number) \\\n    M(QueryCacheHits, \"Number of times a query result has been found in the query cache (and query computation was avoided). Only updated for SELECT queries with SETTING use_query_cache = 1.\", ValueType::Number) \\\n    M(QueryCacheMisses, \"Number of times a query result has not been found in the query cache (and required query computation). Only updated for SELECT queries with SETTING use_query_cache = 1.\", ValueType::Number) \\",
        "base_contents": "    M(Query, \"Number of queries to be interpreted and potentially executed. Does not include queries that failed to parse or were rejected due to AST size limits, quota limits or limits on the number of simultaneously running queries. May include internal queries initiated by ClickHouse itself. Does not count subqueries.\") \\\n    M(SelectQuery, \"Same as Query, but only for SELECT queries.\") \\\n    M(InsertQuery, \"Same as Query, but only for INSERT queries.\") \\\n    M(InitialQuery, \"Same as Query, but only counts initial queries (see is_initial_query).\")\\\n    M(QueriesWithSubqueries, \"Count queries with all subqueries\") \\\n    M(SelectQueriesWithSubqueries, \"Count SELECT queries with all subqueries\") \\\n    M(InsertQueriesWithSubqueries, \"Count INSERT queries with all subqueries\") \\\n    M(SelectQueriesWithPrimaryKeyUsage, \"Count SELECT queries which use the primary key to evaluate the WHERE condition\") \\\n    M(AsyncInsertQuery, \"Same as InsertQuery, but only for asynchronous INSERT queries.\") \\\n    M(AsyncInsertBytes, \"Data size in bytes of asynchronous INSERT queries.\") \\\n    M(AsyncInsertRows, \"Number of rows inserted by asynchronous INSERT queries.\") \\\n    M(AsyncInsertCacheHits, \"Number of times a duplicate hash id has been found in asynchronous INSERT hash id cache.\") \\\n    M(FailedQuery, \"Number of failed queries.\") \\\n    M(FailedSelectQuery, \"Same as FailedQuery, but only for SELECT queries.\") \\\n    M(FailedInsertQuery, \"Same as FailedQuery, but only for INSERT queries.\") \\\n    M(FailedAsyncInsertQuery, \"Number of failed ASYNC INSERT queries.\") \\\n    M(QueryTimeMicroseconds, \"Total time of all queries.\") \\\n    M(SelectQueryTimeMicroseconds, \"Total time of SELECT queries.\") \\\n    M(InsertQueryTimeMicroseconds, \"Total time of INSERT queries.\") \\\n    M(OtherQueryTimeMicroseconds, \"Total time of queries that are not SELECT or INSERT.\") \\\n    M(FileOpen, \"Number of files opened.\") \\\n    M(Seek, \"Number of times the 'lseek' function was called.\") \\\n    M(ReadBufferFromFileDescriptorRead, \"Number of reads (read/pread) from a file descriptor. Does not include sockets.\") \\\n    M(ReadBufferFromFileDescriptorReadFailed, \"Number of times the read (read/pread) from a file descriptor have failed.\") \\\n    M(ReadBufferFromFileDescriptorReadBytes, \"Number of bytes read from file descriptors. If the file is compressed, this will show the compressed data size.\") \\\n    M(WriteBufferFromFileDescriptorWrite, \"Number of writes (write/pwrite) to a file descriptor. Does not include sockets.\") \\\n    M(WriteBufferFromFileDescriptorWriteFailed, \"Number of times the write (write/pwrite) to a file descriptor have failed.\") \\\n    M(WriteBufferFromFileDescriptorWriteBytes, \"Number of bytes written to file descriptors. If the file is compressed, this will show compressed data size.\") \\\n    M(FileSync, \"Number of times the F_FULLFSYNC/fsync/fdatasync function was called for files.\") \\\n    M(DirectorySync, \"Number of times the F_FULLFSYNC/fsync/fdatasync function was called for directories.\") \\\n    M(FileSyncElapsedMicroseconds, \"Total time spent waiting for F_FULLFSYNC/fsync/fdatasync syscall for files.\") \\\n    M(DirectorySyncElapsedMicroseconds, \"Total time spent waiting for F_FULLFSYNC/fsync/fdatasync syscall for directories.\") \\\n    M(ReadCompressedBytes, \"Number of bytes (the number of bytes before decompression) read from compressed sources (files, network).\") \\\n    M(CompressedReadBufferBlocks, \"Number of compressed blocks (the blocks of data that are compressed independent of each other) read from compressed sources (files, network).\") \\\n    M(CompressedReadBufferBytes, \"Number of uncompressed bytes (the number of bytes after decompression) read from compressed sources (files, network).\") \\\n    M(UncompressedCacheHits, \"Number of times a block of data has been found in the uncompressed cache (and decompression was avoided).\") \\\n    M(UncompressedCacheMisses, \"Number of times a block of data has not been found in the uncompressed cache (and required decompression).\") \\\n    M(UncompressedCacheWeightLost, \"Number of bytes evicted from the uncompressed cache.\") \\\n    M(MMappedFileCacheHits, \"Number of times a file has been found in the MMap cache (for the 'mmap' read_method), so we didn't have to mmap it again.\") \\\n    M(MMappedFileCacheMisses, \"Number of times a file has not been found in the MMap cache (for the 'mmap' read_method), so we had to mmap it again.\") \\\n    M(OpenedFileCacheHits, \"Number of times a file has been found in the opened file cache, so we didn't have to open it again.\") \\\n    M(OpenedFileCacheMisses, \"Number of times a file has been found in the opened file cache, so we had to open it again.\") \\\n    M(OpenedFileCacheMicroseconds, \"Amount of time spent executing OpenedFileCache methods.\") \\\n    M(AIOWrite, \"Number of writes with Linux or FreeBSD AIO interface\") \\\n    M(AIOWriteBytes, \"Number of bytes written with Linux or FreeBSD AIO interface\") \\\n    M(AIORead, \"Number of reads with Linux or FreeBSD AIO interface\") \\\n    M(AIOReadBytes, \"Number of bytes read with Linux or FreeBSD AIO interface\") \\\n    M(IOBufferAllocs, \"Number of allocations of IO buffers (for ReadBuffer/WriteBuffer).\") \\\n    M(IOBufferAllocBytes, \"Number of bytes allocated for IO buffers (for ReadBuffer/WriteBuffer).\") \\\n    M(ArenaAllocChunks, \"Number of chunks allocated for memory Arena (used for GROUP BY and similar operations)\") \\\n    M(ArenaAllocBytes, \"Number of bytes allocated for memory Arena (used for GROUP BY and similar operations)\") \\\n    M(FunctionExecute, \"Number of SQL ordinary function calls (SQL functions are called on per-block basis, so this number represents the number of blocks).\") \\\n    M(TableFunctionExecute, \"Number of table function calls.\") \\\n    M(MarkCacheHits, \"Number of times an entry has been found in the mark cache, so we didn't have to load a mark file.\") \\\n    M(MarkCacheMisses, \"Number of times an entry has not been found in the mark cache, so we had to load a mark file in memory, which is a costly operation, adding to query latency.\") \\\n    M(QueryCacheHits, \"Number of times a query result has been found in the query cache (and query computation was avoided). Only updated for SELECT queries with SETTING use_query_cache = 1.\") \\\n    M(QueryCacheMisses, \"Number of times a query result has not been found in the query cache (and required query computation). Only updated for SELECT queries with SETTING use_query_cache = 1.\") \\",
        "res_region": "    M(Query, \"Number of queries to be interpreted and potentially executed. Does not include queries that failed to parse or were rejected due to AST size limits, quota limits or limits on the number of simultaneously running queries. May include internal queries initiated by ClickHouse itself. Does not count subqueries.\", ValueType::Number) \\\n    M(SelectQuery, \"Same as Query, but only for SELECT queries.\", ValueType::Number) \\\n    M(InsertQuery, \"Same as Query, but only for INSERT queries.\", ValueType::Number) \\\n    M(InitialQuery, \"Same as Query, but only counts initial queries (see is_initial_query).\", ValueType::Number)\\\n    M(QueriesWithSubqueries, \"Count queries with all subqueries\", ValueType::Number) \\\n    M(SelectQueriesWithSubqueries, \"Count SELECT queries with all subqueries\", ValueType::Number) \\\n    M(InsertQueriesWithSubqueries, \"Count INSERT queries with all subqueries\", ValueType::Number) \\\n    M(SelectQueriesWithPrimaryKeyUsage, \"Count SELECT queries which use the primary key to evaluate the WHERE condition\", ValueType::Number) \\\n    M(AsyncInsertQuery, \"Same as InsertQuery, but only for asynchronous INSERT queries.\", ValueType::Number) \\\n    M(AsyncInsertBytes, \"Data size in bytes of asynchronous INSERT queries.\", ValueType::Bytes) \\\n    M(AsyncInsertRows, \"Number of rows inserted by asynchronous INSERT queries.\", ValueType::Number) \\\n    M(AsyncInsertCacheHits, \"Number of times a duplicate hash id has been found in asynchronous INSERT hash id cache.\", ValueType::Number) \\\n    M(FailedQuery, \"Number of failed queries.\", ValueType::Number) \\\n    M(FailedSelectQuery, \"Same as FailedQuery, but only for SELECT queries.\", ValueType::Number) \\\n    M(FailedInsertQuery, \"Same as FailedQuery, but only for INSERT queries.\", ValueType::Number) \\\n    M(FailedAsyncInsertQuery, \"Number of failed ASYNC INSERT queries.\", ValueType::Number) \\\n    M(QueryTimeMicroseconds, \"Total time of all queries.\", ValueType::Microseconds) \\\n    M(SelectQueryTimeMicroseconds, \"Total time of SELECT queries.\", ValueType::Microseconds) \\\n    M(InsertQueryTimeMicroseconds, \"Total time of INSERT queries.\", ValueType::Microseconds) \\\n    M(OtherQueryTimeMicroseconds, \"Total time of queries that are not SELECT or INSERT.\", ValueType::Microseconds) \\\n    M(FileOpen, \"Number of files opened.\", ValueType::Number) \\\n    M(Seek, \"Number of times the 'lseek' function was called.\", ValueType::Number) \\\n    M(ReadBufferFromFileDescriptorRead, \"Number of reads (read/pread) from a file descriptor. Does not include sockets.\", ValueType::Number) \\\n    M(ReadBufferFromFileDescriptorReadFailed, \"Number of times the read (read/pread) from a file descriptor have failed.\", ValueType::Number) \\\n    M(ReadBufferFromFileDescriptorReadBytes, \"Number of bytes read from file descriptors. If the file is compressed, this will show the compressed data size.\", ValueType::Bytes) \\\n    M(WriteBufferFromFileDescriptorWrite, \"Number of writes (write/pwrite) to a file descriptor. Does not include sockets.\", ValueType::Number) \\\n    M(WriteBufferFromFileDescriptorWriteFailed, \"Number of times the write (write/pwrite) to a file descriptor have failed.\", ValueType::Number) \\\n    M(WriteBufferFromFileDescriptorWriteBytes, \"Number of bytes written to file descriptors. If the file is compressed, this will show compressed data size.\", ValueType::Bytes) \\\n    M(FileSync, \"Number of times the F_FULLFSYNC/fsync/fdatasync function was called for files.\", ValueType::Number) \\\n    M(DirectorySync, \"Number of times the F_FULLFSYNC/fsync/fdatasync function was called for directories.\", ValueType::Number) \\\n    M(FileSyncElapsedMicroseconds, \"Total time spent waiting for F_FULLFSYNC/fsync/fdatasync syscall for files.\", ValueType::Microseconds) \\\n    M(DirectorySyncElapsedMicroseconds, \"Total time spent waiting for F_FULLFSYNC/fsync/fdatasync syscall for directories.\", ValueType::Microseconds) \\\n    M(ReadCompressedBytes, \"Number of bytes (the number of bytes before decompression) read from compressed sources (files, network).\", ValueType::Bytes) \\\n    M(CompressedReadBufferBlocks, \"Number of compressed blocks (the blocks of data that are compressed independent of each other) read from compressed sources (files, network).\", ValueType::Number) \\\n    M(CompressedReadBufferBytes, \"Number of uncompressed bytes (the number of bytes after decompression) read from compressed sources (files, network).\", ValueType::Bytes) \\\n    M(UncompressedCacheHits, \"Number of times a block of data has been found in the uncompressed cache (and decompression was avoided).\", ValueType::Number) \\\n    M(UncompressedCacheMisses, \"Number of times a block of data has not been found in the uncompressed cache (and required decompression).\", ValueType::Number) \\\n    M(UncompressedCacheWeightLost, \"Number of bytes evicted from the uncompressed cache.\", ValueType::Bytes) \\\n    M(MMappedFileCacheHits, \"Number of times a file has been found in the MMap cache (for the 'mmap' read_method), so we didn't have to mmap it again.\", ValueType::Number) \\\n    M(MMappedFileCacheMisses, \"Number of times a file has not been found in the MMap cache (for the 'mmap' read_method), so we had to mmap it again.\", ValueType::Number) \\\n    M(OpenedFileCacheHits, \"Number of times a file has been found in the opened file cache, so we didn't have to open it again.\", ValueType::Number) \\\n    M(OpenedFileCacheMisses, \"Number of times a file has been found in the opened file cache, so we had to open it again.\", ValueType::Number) \\\n    M(OpenedFileCacheMicroseconds, \"Amount of time spent executing OpenedFileCache methods.\", ValueType::Microseconds) \\\n    M(AIOWrite, \"Number of writes with Linux or FreeBSD AIO interface\", ValueType::Number) \\\n    M(AIOWriteBytes, \"Number of bytes written with Linux or FreeBSD AIO interface\", ValueType::Bytes) \\\n    M(AIORead, \"Number of reads with Linux or FreeBSD AIO interface\", ValueType::Number) \\\n    M(AIOReadBytes, \"Number of bytes read with Linux or FreeBSD AIO interface\", ValueType::Bytes) \\\n    M(IOBufferAllocs, \"Number of allocations of IO buffers (for ReadBuffer/WriteBuffer).\", ValueType::Number) \\\n    M(IOBufferAllocBytes, \"Number of bytes allocated for IO buffers (for ReadBuffer/WriteBuffer).\", ValueType::Bytes) \\\n    M(ArenaAllocChunks, \"Number of chunks allocated for memory Arena (used for GROUP BY and similar operations)\", ValueType::Number) \\\n    M(ArenaAllocBytes, \"Number of bytes allocated for memory Arena (used for GROUP BY and similar operations)\", ValueType::Bytes) \\\n    M(FunctionExecute, \"Number of SQL ordinary function calls (SQL functions are called on per-block basis, so this number represents the number of blocks).\", ValueType::Number) \\\n    M(TableFunctionExecute, \"Number of table function calls.\", ValueType::Number) \\\n    M(DefaultImplementationForNullsRows, \"Number of rows processed by default implementation for nulls in function execution\", ValueType::Number) \\\n    M(DefaultImplementationForNullsRowsWithNulls, \"Number of rows which contain null values processed by default implementation for nulls in function execution\", ValueType::Number) \\\n    M(MarkCacheHits, \"Number of times an entry has been found in the mark cache, so we didn't have to load a mark file.\", ValueType::Number) \\\n    M(MarkCacheMisses, \"Number of times an entry has not been found in the mark cache, so we had to load a mark file in memory, which is a costly operation, adding to query latency.\", ValueType::Number) \\\n    M(QueryCacheHits, \"Number of times a query result has been found in the query cache (and query computation was avoided). Only updated for SELECT queries with SETTING use_query_cache = 1.\", ValueType::Number) \\\n    M(QueryCacheMisses, \"Number of times a query result has not been found in the query cache (and required query computation). Only updated for SELECT queries with SETTING use_query_cache = 1.\", ValueType::Number) \\\n    M(QueryConditionCacheHits, \"Number of times an entry has been found in the query condition cache (and reading of invalid marks can be skipped). Only updated for SELECT queries with SETTING use_query_condition_cache = 1.\", ValueType::Number) \\\n    M(QueryConditionCacheMisses, \"Number of times an entry has not been found in the query condition cache (and reading of mark cannot be skipped). Only updated for SELECT queries with SETTING use_query_condition_cache = 1.\", ValueType::Number) \\",
        "lookback": "    M(SelectQuery, \"Same as Query, but only for SELECT queries.\", ValueType::Number) \\",
        "lookahead": "    /* Each page cache chunk access increments exactly one of the following 5 PageCacheChunk* counters. */ \\",
        "label": [
            "newcode",
            "complex_conflict"
        ],
        "start_line": 10,
        "end_line": 188,
        "merge_gen_region": null,
        "confidence": 0.8618096709251404,
        "hesitated": true
    }
]