[
    {
        "a_contents": "    else /*if constexpr (is_integral_v<typename DataType::FieldType>)*/\n        return tryReadIntText(x, rb);\n}\n\ntemplate <>\ninline bool tryParseImpl<DataTypeDate>(DataTypeDate::FieldType & x, ReadBuffer & rb, const DateLUTImpl * time_zone, bool)\n{\n    DayNum tmp(0);\n    if (!tryReadDateText(tmp, rb, *time_zone))\n        return false;\n    x = tmp;\n    return true;\n}\n\ntemplate <>\ninline bool tryParseImpl<DataTypeDate32>(DataTypeDate32::FieldType & x, ReadBuffer & rb, const DateLUTImpl * time_zone, bool)\n{\n    ExtendedDayNum tmp(0);\n    if (!tryReadDateText(tmp, rb, *time_zone))\n        return false;\n    x = tmp;\n    return true;\n}\n\ntemplate <>\ninline bool tryParseImpl<DataTypeDateTime>(DataTypeDateTime::FieldType & x, ReadBuffer & rb, const DateLUTImpl * time_zone, bool)\n{\n    time_t time = 0;\n    if (!tryReadDateTimeText(time, rb, *time_zone))\n        return false;\n    convertFromTime<DataTypeDateTime>(x, time);\n    return true;\n}\n\ntemplate <>\ninline bool tryParseImpl<DataTypeUUID>(DataTypeUUID::FieldType & x, ReadBuffer & rb, const DateLUTImpl *, bool)\n{\n    UUID tmp;\n    if (!tryReadUUIDText(tmp, rb))\n        return false;\n\n    x = tmp.toUnderType();\n    return true;\n}\n\ntemplate <>\ninline bool tryParseImpl<DataTypeIPv4>(DataTypeIPv4::FieldType & x, ReadBuffer & rb, const DateLUTImpl *, bool)\n{\n    IPv4 tmp;\n    if (!tryReadIPv4Text(tmp, rb))\n        return false;\n\n    x = tmp.toUnderType();\n    return true;\n}\n\ntemplate <>\ninline bool tryParseImpl<DataTypeIPv6>(DataTypeIPv6::FieldType & x, ReadBuffer & rb, const DateLUTImpl *, bool)\n{\n    IPv6 tmp;\n    if (!tryReadIPv6Text(tmp, rb))\n        return false;\n\n    x = tmp;\n    return true;\n}\n\n\n/** Throw exception with verbose message when string value is not parsed completely.\n  */\n[[noreturn]] inline void throwExceptionForIncompletelyParsedValue(ReadBuffer & read_buffer, const IDataType & result_type)\n{\n    WriteBufferFromOwnString message_buf;\n    message_buf << \"Cannot parse string \" << quote << String(read_buffer.buffer().begin(), read_buffer.buffer().size())\n                << \" as \" << result_type.getName()\n                << \": syntax error\";\n\n    if (read_buffer.offset())\n        message_buf << \" at position \" << read_buffer.offset()\n                    << \" (parsed just \" << quote << String(read_buffer.buffer().begin(), read_buffer.offset()) << \")\";\n    else\n        message_buf << \" at begin of string\";\n\n    // Currently there are no functions toIPv{4,6}Or{Null,Zero}\n    if (isNativeNumber(result_type) && !(result_type.getName() == \"IPv4\" || result_type.getName() == \"IPv6\"))\n        message_buf << \". Note: there are to\" << result_type.getName() << \"OrZero and to\" << result_type.getName() << \"OrNull functions, which returns zero/NULL instead of throwing exception.\";\n\n    throw Exception(PreformattedMessage{message_buf.str(), \"Cannot parse string {} as {}: syntax error {}\", {String(read_buffer.buffer().begin(), read_buffer.buffer().size()), result_type.getName()}}, ErrorCodes::CANNOT_PARSE_TEXT);\n}\n\n\nenum class ConvertFromStringExceptionMode : uint8_t\n{\n    Throw,  /// Throw exception if value cannot be parsed.\n    Zero,   /// Fill with zero or default if value cannot be parsed.\n    Null    /// Return ColumnNullable with NULLs when value cannot be parsed.\n};\n\nenum class ConvertFromStringParsingMode : uint8_t\n{\n    Normal,\n    BestEffort,  /// Only applicable for DateTime. Will use sophisticated method, that is slower.\n    BestEffortUS\n};\n\nstruct AccurateConvertStrategyAdditions\n{\n    UInt32 scale { 0 };\n};\n\nstruct AccurateOrNullConvertStrategyAdditions\n{\n    UInt32 scale { 0 };\n};\n\ntemplate <typename FromDataType, typename ToDataType, typename Name,\n    ConvertFromStringExceptionMode exception_mode, ConvertFromStringParsingMode parsing_mode>\nstruct ConvertThroughParsing\n{\n    static_assert(std::is_same_v<FromDataType, DataTypeString> || std::is_same_v<FromDataType, DataTypeFixedString>,\n        \"ConvertThroughParsing is only applicable for String or FixedString data types\");\n\n    static constexpr bool to_datetime64 = std::is_same_v<ToDataType, DataTypeDateTime64>;\n\n    static bool isAllRead(ReadBuffer & in)\n    {\n        /// In case of FixedString, skip zero bytes at end.\n        if constexpr (std::is_same_v<FromDataType, DataTypeFixedString>)\n            while (!in.eof() && *in.position() == 0)\n                ++in.position();\n\n        if (in.eof())\n            return true;\n\n        /// Special case, that allows to parse string with DateTime or DateTime64 as Date or Date32.\n        if constexpr (std::is_same_v<ToDataType, DataTypeDate> || std::is_same_v<ToDataType, DataTypeDate32>)\n        {\n            if (!in.eof() && (*in.position() == ' ' || *in.position() == 'T'))\n            {\n                if (in.buffer().size() == strlen(\"YYYY-MM-DD hh:mm:ss\"))\n                    return true;\n\n                if (in.buffer().size() >= strlen(\"YYYY-MM-DD hh:mm:ss.x\")\n                    && in.buffer().begin()[19] == '.')\n                {\n                    in.position() = in.buffer().begin() + 20;\n\n                    while (!in.eof() && isNumericASCII(*in.position()))\n                        ++in.position();\n\n                    if (in.eof())\n                        return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    template <typename Additions = void *>\n    static ColumnPtr execute(const ColumnsWithTypeAndName & arguments, const DataTypePtr & res_type, size_t input_rows_count,\n                        Additions additions [[maybe_unused]] = Additions())\n    {\n        using ColVecTo = typename ToDataType::ColumnType;\n\n        const DateLUTImpl * local_time_zone [[maybe_unused]] = nullptr;\n        const DateLUTImpl * utc_time_zone [[maybe_unused]] = nullptr;\n\n        /// For conversion to Date or DateTime type, second argument with time zone could be specified.\n        if constexpr (std::is_same_v<ToDataType, DataTypeDateTime> || to_datetime64)\n        {\n            const auto result_type = removeNullable(res_type);\n            // Time zone is already figured out during result type resolution, no need to do it here.\n            if (const auto dt_col = checkAndGetDataType<ToDataType>(result_type.get()))\n                local_time_zone = &dt_col->getTimeZone();\n            else\n                local_time_zone = &extractTimeZoneFromFunctionArguments(arguments, 1, 0);\n\n            if constexpr (parsing_mode == ConvertFromStringParsingMode::BestEffort || parsing_mode == ConvertFromStringParsingMode::BestEffortUS)\n                utc_time_zone = &DateLUT::instance(\"UTC\");\n        }\n        else if constexpr (std::is_same_v<ToDataType, DataTypeDate> || std::is_same_v<ToDataType, DataTypeDate32>)\n        {\n            // Timezone is more or less dummy when parsing Date/Date32 from string.\n            local_time_zone = &DateLUT::instance();\n            utc_time_zone = &DateLUT::instance(\"UTC\");\n        }\n\n        const IColumn * col_from = arguments[0].column.get();\n        const ColumnString * col_from_string = checkAndGetColumn<ColumnString>(col_from);\n        const ColumnFixedString * col_from_fixed_string = checkAndGetColumn<ColumnFixedString>(col_from);\n\n        if (std::is_same_v<FromDataType, DataTypeString> && !col_from_string)\n            throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of first argument of function {}\",\n                col_from->getName(), Name::name);\n\n        if (std::is_same_v<FromDataType, DataTypeFixedString> && !col_from_fixed_string)\n            throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of first argument of function {}\",\n                col_from->getName(), Name::name);\n\n        size_t size = input_rows_count;\n        typename ColVecTo::MutablePtr col_to = nullptr;\n\n        if constexpr (IsDataTypeDecimal<ToDataType>)\n        {\n            UInt32 scale = additions;\n            if constexpr (to_datetime64)\n            {\n                ToDataType check_bounds_in_ctor(scale, local_time_zone ? local_time_zone->getTimeZone() : String{});\n            }\n            else\n            {\n                ToDataType check_bounds_in_ctor(ToDataType::maxPrecision(), scale);\n            }\n            col_to = ColVecTo::create(size, scale);\n        }\n        else\n            col_to = ColVecTo::create(size);\n\n        typename ColVecTo::Container & vec_to = col_to->getData();\n\n        ColumnUInt8::MutablePtr col_null_map_to;\n        ColumnUInt8::Container * vec_null_map_to [[maybe_unused]] = nullptr;\n        if constexpr (exception_mode == ConvertFromStringExceptionMode::Null)\n        {\n            col_null_map_to = ColumnUInt8::create(size);\n            vec_null_map_to = &col_null_map_to->getData();\n        }\n\n        const ColumnString::Chars * chars = nullptr;\n        const IColumn::Offsets * offsets = nullptr;\n        size_t fixed_string_size = 0;\n\n        if constexpr (std::is_same_v<FromDataType, DataTypeString>)\n        {\n            chars = &col_from_string->getChars();\n            offsets = &col_from_string->getOffsets();\n        }\n        else\n        {\n            chars = &col_from_fixed_string->getChars();\n            fixed_string_size = col_from_fixed_string->getN();\n        }\n\n        size_t current_offset = 0;\n\n        bool precise_float_parsing = false;\n\n        if (DB::CurrentThread::isInitialized())\n        {\n            const DB::ContextPtr query_context = DB::CurrentThread::get().getQueryContext();\n\n            if (query_context)\n                precise_float_parsing = query_context->getSettingsRef()[Setting::precise_float_parsing];\n        }\n\n        for (size_t i = 0; i < size; ++i)\n        {\n            size_t next_offset = std::is_same_v<FromDataType, DataTypeString> ? (*offsets)[i] : (current_offset + fixed_string_size);\n            size_t string_size = std::is_same_v<FromDataType, DataTypeString> ? next_offset - current_offset - 1 : fixed_string_size;\n\n            ReadBufferFromMemory read_buffer(chars->data() + current_offset, string_size);\n\n            if constexpr (exception_mode == ConvertFromStringExceptionMode::Throw)\n            {\n                if constexpr (parsing_mode == ConvertFromStringParsingMode::BestEffort)\n                {\n                    if constexpr (to_datetime64)\n                    {\n                        DateTime64 res = 0;\n                        parseDateTime64BestEffort(res, col_to->getScale(), read_buffer, *local_time_zone, *utc_time_zone);\n                        vec_to[i] = res;\n                    }\n                    else\n                    {\n                        time_t res;\n                        parseDateTimeBestEffort(res, read_buffer, *local_time_zone, *utc_time_zone);\n                        convertFromTime<ToDataType>(vec_to[i], res);\n                    }\n                }\n                else if constexpr (parsing_mode == ConvertFromStringParsingMode::BestEffortUS)\n                {\n                    if constexpr (to_datetime64)\n                    {\n                        DateTime64 res = 0;\n                        parseDateTime64BestEffortUS(res, col_to->getScale(), read_buffer, *local_time_zone, *utc_time_zone);\n                        vec_to[i] = res;\n                    }\n                    else\n                    {\n                        time_t res;\n                        parseDateTimeBestEffortUS(res, read_buffer, *local_time_zone, *utc_time_zone);\n                        convertFromTime<ToDataType>(vec_to[i], res);\n                    }\n                }\n                else\n                {\n                    if constexpr (to_datetime64)\n                    {\n                        DateTime64 value = 0;\n                        readDateTime64Text(value, col_to->getScale(), read_buffer, *local_time_zone);\n                        vec_to[i] = value;\n                    }\n                    else if constexpr (IsDataTypeDecimal<ToDataType>)\n                    {\n                        SerializationDecimal<typename ToDataType::FieldType>::readText(\n                            vec_to[i], read_buffer, ToDataType::maxPrecision(), col_to->getScale());\n                    }\n                    else\n                    {\n                        /// we want to utilize constexpr condition here, which is not mixable with value comparison\n                        do\n                        {\n                            if constexpr (std::is_same_v<FromDataType, DataTypeFixedString> && std::is_same_v<ToDataType, DataTypeIPv6>)\n                            {\n                                if (fixed_string_size == IPV6_BINARY_LENGTH)\n                                {\n                                    readBinary(vec_to[i], read_buffer);\n                                    break;\n                                }\n                            }\n                            if constexpr (std::is_same_v<Additions, AccurateConvertStrategyAdditions>)\n                            {\n                                if (!tryParseImpl<ToDataType>(vec_to[i], read_buffer, local_time_zone, precise_float_parsing))\n                                    throw Exception(ErrorCodes::CANNOT_PARSE_TEXT, \"Cannot parse string to type {}\", TypeName<typename ToDataType::FieldType>);\n                            }\n                            else\n                                parseImpl<ToDataType>(vec_to[i], read_buffer, local_time_zone, precise_float_parsing);\n                        } while (false);\n                    }\n                }\n\n                if (!isAllRead(read_buffer))\n                    throwExceptionForIncompletelyParsedValue(read_buffer, *res_type);\n            }\n            else\n            {\n                bool parsed;\n\n                if constexpr (parsing_mode == ConvertFromStringParsingMode::BestEffort)\n                {\n                    if constexpr (to_datetime64)\n                    {\n                        DateTime64 res = 0;\n                        parsed = tryParseDateTime64BestEffort(res, col_to->getScale(), read_buffer, *local_time_zone, *utc_time_zone);\n                        vec_to[i] = res;\n                    }\n                    else\n                    {\n                        time_t res;\n                        parsed = tryParseDateTimeBestEffort(res, read_buffer, *local_time_zone, *utc_time_zone);\n                        convertFromTime<ToDataType>(vec_to[i],res);\n                    }\n                }\n                else if constexpr (parsing_mode == ConvertFromStringParsingMode::BestEffortUS)\n                {\n                    if constexpr (to_datetime64)\n                    {\n                        DateTime64 res = 0;\n                        parsed = tryParseDateTime64BestEffortUS(res, col_to->getScale(), read_buffer, *local_time_zone, *utc_time_zone);\n                        vec_to[i] = res;\n                    }\n                    else\n                    {\n                        time_t res;\n                        parsed = tryParseDateTimeBestEffortUS(res, read_buffer, *local_time_zone, *utc_time_zone);\n                        convertFromTime<ToDataType>(vec_to[i],res);\n                    }\n                }\n                else\n                {\n                    if constexpr (to_datetime64)\n                    {\n                        DateTime64 value = 0;\n                        parsed = tryReadDateTime64Text(value, col_to->getScale(), read_buffer, *local_time_zone);\n                        vec_to[i] = value;\n                    }\n                    else if constexpr (IsDataTypeDecimal<ToDataType>)\n                    {\n                        parsed = SerializationDecimal<typename ToDataType::FieldType>::tryReadText(\n                            vec_to[i], read_buffer, ToDataType::maxPrecision(), col_to->getScale());\n                    }\n                    else if (std::is_same_v<FromDataType, DataTypeFixedString> && std::is_same_v<ToDataType, DataTypeIPv6>\n                            && fixed_string_size == IPV6_BINARY_LENGTH)\n                    {\n                        readBinary(vec_to[i], read_buffer);\n                        parsed = true;\n                    }\n                    else\n                    {\n                        parsed = tryParseImpl<ToDataType>(vec_to[i], read_buffer, local_time_zone, precise_float_parsing);\n                    }\n                }\n\n                if (!isAllRead(read_buffer))\n                    parsed = false;\n\n                if (!parsed)\n                {\n                    if constexpr (std::is_same_v<ToDataType, DataTypeDate32>)\n                    {\n                        vec_to[i] = -static_cast<Int32>(DateLUT::instance().getDayNumOffsetEpoch()); /// NOLINT(readability-static-accessed-through-instance)\n                    }\n                    else\n                    {\n                        vec_to[i] = static_cast<typename ToDataType::FieldType>(0);\n                    }\n                }\n\n                if constexpr (exception_mode == ConvertFromStringExceptionMode::Null)\n                    (*vec_null_map_to)[i] = !parsed;\n            }\n\n            current_offset = next_offset;\n        }\n\n        if constexpr (exception_mode == ConvertFromStringExceptionMode::Null)\n            return ColumnNullable::create(std::move(col_to), std::move(col_null_map_to));\n        else\n            return col_to;\n    }\n};\n\n\n/// Function toUnixTimestamp has exactly the same implementation as toDateTime of String type.\nstruct NameToUnixTimestamp { static constexpr auto name = \"toUnixTimestamp\"; };\n\n/// Function toUnixTimestampEx has exactly the same implementation as toDateTime of String type.\nstruct NameToUnixTimestampEx { static constexpr auto name = \"toUnixTimestampEx\"; };\n\nenum class BehaviourOnErrorFromString : uint8_t\n{\n    ConvertDefaultBehaviorTag,\n    ConvertReturnNullOnErrorTag,\n    ConvertReturnZeroOnErrorTag\n};\n\n/** Conversion of number types to each other, enums to numbers, dates and datetimes to numbers and back: done by straight assignment.\n  *  (Date is represented internally as number of days from some day; DateTime - as unix timestamp)\n  */\ntemplate <typename FromDataType, typename ToDataType, typename Name,\n    FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior = default_date_time_overflow_behavior>\nstruct ConvertImpl\n{\n    template <typename Additions = void *>\n    static ColumnPtr NO_SANITIZE_UNDEFINED execute(\n        const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type [[maybe_unused]], size_t input_rows_count,\n        BehaviourOnErrorFromString from_string_tag [[maybe_unused]], Additions additions = Additions())\n    {\n        const ColumnWithTypeAndName & named_from = arguments[0];\n\n        if constexpr ((std::is_same_v<FromDataType, ToDataType> && !FromDataType::is_parametric)\n            || (std::is_same_v<FromDataType, DataTypeEnum8> && std::is_same_v<ToDataType, DataTypeInt8>)\n            || (std::is_same_v<FromDataType, DataTypeEnum16> && std::is_same_v<ToDataType, DataTypeInt16>))\n        {\n            /// If types are the same, reuse the columns.\n            /// Conversions between Enum and the underlying type are also free.\n            return named_from.column;\n        }\n        else if constexpr ((std::is_same_v<FromDataType, DataTypeDateTime> || std::is_same_v<FromDataType, DataTypeDate32>)\n            && std::is_same_v<ToDataType, DataTypeDate>)\n        {\n            /// Conversion of DateTime to Date: throw off time component.\n            /// Conversion of Date32 to Date.\n            return DateTimeTransformImpl<FromDataType, ToDataType, ToDateImpl<date_time_overflow_behavior>, false>::template execute<Additions>(\n                arguments, result_type, input_rows_count);\n        }\n        else if constexpr (std::is_same_v<FromDataType, DataTypeDateTime> && std::is_same_v<ToDataType, DataTypeDate32>)\n        {\n            /// Conversion of DateTime to Date: throw off time component.\n            return DateTimeTransformImpl<FromDataType, ToDataType, ToDate32Impl, false>::template execute<Additions>(\n                arguments, result_type, input_rows_count);\n        }\n        else if constexpr ((std::is_same_v<FromDataType, DataTypeDate> || std::is_same_v<FromDataType, DataTypeDate32>)\n            && std::is_same_v<ToDataType, DataTypeDateTime>)\n        {\n            /// Conversion from Date/Date32 to DateTime.\n            return DateTimeTransformImpl<FromDataType, ToDataType, ToDateTimeImpl<date_time_overflow_behavior>, false>::template execute<Additions>(\n                arguments, result_type, input_rows_count);\n        }\n        else if constexpr (std::is_same_v<FromDataType, DataTypeDateTime64> && std::is_same_v<ToDataType, DataTypeDate32>)\n        {\n            return DateTimeTransformImpl<DataTypeDateTime64, DataTypeDate32, TransformDateTime64<ToDate32Impl>, false>::template execute<Additions>(\n                arguments, result_type, input_rows_count, additions);\n        }\n        /** Special case of converting Int8, Int16, (U)Int32 or (U)Int64 (and also, for convenience,\n          * Float32, Float64) to Date. If the\n          * number is less than 65536, then it is treated as DayNum, and if it's greater or equals to 65536,\n          * then treated as unix timestamp. If the number exceeds UInt32, saturate to MAX_UINT32 then as DayNum.\n          * It's a bit illogical, as we actually have two functions in one.\n          * But allows to support frequent case,\n          *  when user write toDate(UInt32), expecting conversion of unix timestamp to Date.\n          *  (otherwise such usage would be frequent mistake).\n          */\n        else if constexpr ((\n                std::is_same_v<FromDataType, DataTypeUInt32>\n                || std::is_same_v<FromDataType, DataTypeUInt64>)\n            && std::is_same_v<ToDataType, DataTypeDate>)\n        {\n            return DateTimeTransformImpl<FromDataType, ToDataType, ToDateTransform32Or64<typename FromDataType::FieldType, default_date_time_overflow_behavior>, false>::template execute<Additions>(\n                arguments, result_type, input_rows_count);\n        }\n        else if constexpr ((\n                std::is_same_v<FromDataType, DataTypeInt8>\n                || std::is_same_v<FromDataType, DataTypeInt16>)\n            && std::is_same_v<ToDataType, DataTypeDate>)\n        {\n            return DateTimeTransformImpl<FromDataType, ToDataType, ToDateTransform8Or16Signed<typename FromDataType::FieldType, default_date_time_overflow_behavior>, false>::template execute<Additions>(\n                arguments, result_type, input_rows_count);\n        }\n        else if constexpr ((\n                std::is_same_v<FromDataType, DataTypeInt32>\n                || std::is_same_v<FromDataType, DataTypeInt64>\n                || std::is_same_v<FromDataType, DataTypeFloat32>\n                || std::is_same_v<FromDataType, DataTypeFloat64>)\n            && std::is_same_v<ToDataType, DataTypeDate>)\n        {\n            return DateTimeTransformImpl<FromDataType, ToDataType, ToDateTransform32Or64Signed<typename FromDataType::FieldType, default_date_time_overflow_behavior>, false>::template execute<Additions>(\n                arguments, result_type, input_rows_count);\n        }\n        else if constexpr ((\n                std::is_same_v<FromDataType, DataTypeUInt32>\n                || std::is_same_v<FromDataType, DataTypeUInt64>)\n            && std::is_same_v<ToDataType, DataTypeDate32>)\n        {\n            return DateTimeTransformImpl<FromDataType, ToDataType, ToDate32Transform32Or64<typename FromDataType::FieldType, default_date_time_overflow_behavior>, false>::template execute<Additions>(\n                arguments, result_type, input_rows_count);\n        }\n        else if constexpr ((\n                std::is_same_v<FromDataType, DataTypeInt8>\n                || std::is_same_v<FromDataType, DataTypeInt16>)\n            && std::is_same_v<ToDataType, DataTypeDate32>)\n        {\n            return DateTimeTransformImpl<FromDataType, ToDataType, ToDate32Transform8Or16Signed<typename FromDataType::FieldType>, false>::template execute<Additions>(\n                arguments, result_type, input_rows_count);\n        }\n        else if constexpr ((\n                std::is_same_v<FromDataType, DataTypeInt32>\n                || std::is_same_v<FromDataType, DataTypeInt64>\n                || std::is_same_v<FromDataType, DataTypeFloat32>\n                || std::is_same_v<FromDataType, DataTypeFloat64>)\n            && std::is_same_v<ToDataType, DataTypeDate32>)\n        {\n            return DateTimeTransformImpl<FromDataType, ToDataType, ToDate32Transform32Or64Signed<typename FromDataType::FieldType, default_date_time_overflow_behavior>, false>::template execute<Additions>(\n                arguments, result_type, input_rows_count);\n        }\n        /// Special case of converting Int8, Int16, Int32 or (U)Int64 (and also, for convenience, Float32, Float64) to DateTime.\n        else if constexpr ((\n                std::is_same_v<FromDataType, DataTypeInt8>\n                || std::is_same_v<FromDataType, DataTypeInt16>\n                || std::is_same_v<FromDataType, DataTypeInt32>)\n            && std::is_same_v<ToDataType, DataTypeDateTime>)\n        {\n            return DateTimeTransformImpl<FromDataType, ToDataType, ToDateTimeTransformSigned<typename FromDataType::FieldType, UInt32, default_date_time_overflow_behavior>, false>::template execute<Additions>(\n                arguments, result_type, input_rows_count);\n        }\n        else if constexpr (std::is_same_v<FromDataType, DataTypeUInt64>\n            && std::is_same_v<ToDataType, DataTypeDateTime>)\n        {\n            return DateTimeTransformImpl<FromDataType, ToDataType, ToDateTimeTransform64<typename FromDataType::FieldType, UInt32, default_date_time_overflow_behavior>, false>::template execute<Additions>(\n                arguments, result_type, input_rows_count);\n        }\n        else if constexpr ((\n                std::is_same_v<FromDataType, DataTypeInt64>\n                || std::is_same_v<FromDataType, DataTypeFloat32>\n                || std::is_same_v<FromDataType, DataTypeFloat64>)\n            && std::is_same_v<ToDataType, DataTypeDateTime>)\n        {\n            return DateTimeTransformImpl<FromDataType, ToDataType, ToDateTimeTransform64Signed<typename FromDataType::FieldType, UInt32, default_date_time_overflow_behavior>, false>::template execute<Additions>(\n                arguments, result_type, input_rows_count);\n        }\n        else if constexpr ((\n                std::is_same_v<FromDataType, DataTypeInt8>\n                || std::is_same_v<FromDataType, DataTypeInt16>\n                || std::is_same_v<FromDataType, DataTypeInt32>\n                || std::is_same_v<FromDataType, DataTypeInt64>)\n            && std::is_same_v<ToDataType, DataTypeDateTime64>)\n        {\n            return DateTimeTransformImpl<FromDataType, ToDataType, ToDateTime64TransformSigned<typename FromDataType::FieldType, default_date_time_overflow_behavior>, false>::template execute<Additions>(\n                arguments, result_type, input_rows_count, additions);\n        }\n        else if constexpr (std::is_same_v<FromDataType, DataTypeUInt64>\n            && std::is_same_v<ToDataType, DataTypeDateTime64>)\n        {\n            return DateTimeTransformImpl<FromDataType, ToDataType, ToDateTime64TransformUnsigned<UInt64, default_date_time_overflow_behavior>, false>::template execute<Additions>(\n                arguments, result_type, input_rows_count, additions);\n        }\n        else if constexpr ((\n                std::is_same_v<FromDataType, DataTypeFloat32>\n                || std::is_same_v<FromDataType, DataTypeFloat64>)\n            && std::is_same_v<ToDataType, DataTypeDateTime64>)\n        {\n            return DateTimeTransformImpl<FromDataType, ToDataType, ToDateTime64TransformFloat<FromDataType, typename FromDataType::FieldType, default_date_time_overflow_behavior>, false>::template execute<Additions>(\n                arguments, result_type, input_rows_count, additions);\n        }\n        /// Conversion of DateTime64 to Date or DateTime: discards fractional part.\n        else if constexpr (std::is_same_v<FromDataType, DataTypeDateTime64>\n            && std::is_same_v<ToDataType, DataTypeDate>)\n        {\n            return DateTimeTransformImpl<FromDataType, ToDataType, TransformDateTime64<ToDateImpl<date_time_overflow_behavior>>, false>::template execute<Additions>(\n                arguments, result_type, input_rows_count, additions);\n        }\n        else if constexpr (std::is_same_v<FromDataType, DataTypeDateTime64>\n            && std::is_same_v<ToDataType, DataTypeDateTime>)\n        {\n            return DateTimeTransformImpl<FromDataType, ToDataType, TransformDateTime64<ToDateTimeImpl<date_time_overflow_behavior>>, false>::template execute<Additions>(\n                arguments, result_type, input_rows_count, additions);\n        }\n        /// Conversion of Date or DateTime to DateTime64: add zero sub-second part.\n        else if constexpr ((\n                std::is_same_v<FromDataType, DataTypeDate>\n                || std::is_same_v<FromDataType, DataTypeDate32>\n                || std::is_same_v<FromDataType, DataTypeDateTime>)\n            && std::is_same_v<ToDataType, DataTypeDateTime64>)\n        {\n            return DateTimeTransformImpl<FromDataType, ToDataType, ToDateTime64Transform, false>::template execute<Additions>(\n                arguments, result_type, input_rows_count, additions);\n        }\n        else if constexpr (IsDataTypeDateOrDateTime<FromDataType>\n            && std::is_same_v<ToDataType, DataTypeString>)\n        {\n            /// Date or DateTime to String\n\n            using FromFieldType = typename FromDataType::FieldType;\n            using ColVecType = ColumnVectorOrDecimal<FromFieldType>;\n\n            auto datetime_arg = arguments[0];\n\n            const DateLUTImpl * time_zone = nullptr;\n            const ColumnConst * time_zone_column = nullptr;\n\n            if (arguments.size() == 1)\n            {\n                auto non_null_args = createBlockWithNestedColumns(arguments);\n                time_zone = &extractTimeZoneFromFunctionArguments(non_null_args, 1, 0);\n            }\n            else /// When we have a column for timezone\n            {\n                datetime_arg.column = datetime_arg.column->convertToFullColumnIfConst();\n\n                if constexpr (std::is_same_v<FromDataType, DataTypeDate> || std::is_same_v<FromDataType, DataTypeDate32>)\n                    time_zone = &DateLUT::instance();\n                /// For argument of Date or DateTime type, second argument with time zone could be specified.\n                if constexpr (std::is_same_v<FromDataType, DataTypeDateTime> || std::is_same_v<FromDataType, DataTypeDateTime64>)\n                {\n                    if ((time_zone_column = checkAndGetColumnConst<ColumnString>(arguments[1].column.get())))\n                    {\n                        auto non_null_args = createBlockWithNestedColumns(arguments);\n                        time_zone = &extractTimeZoneFromFunctionArguments(non_null_args, 1, 0);\n                    }\n                }\n            }\n            const auto & col_with_type_and_name = columnGetNested(datetime_arg);\n\n            if (const auto col_from = checkAndGetColumn<ColVecType>(col_with_type_and_name.column.get()))\n            {\n                auto col_to = ColumnString::create();\n\n                const typename ColVecType::Container & vec_from = col_from->getData();\n                ColumnString::Chars & data_to = col_to->getChars();\n                ColumnString::Offsets & offsets_to = col_to->getOffsets();\n                size_t size = vec_from.size();\n\n                if constexpr (std::is_same_v<FromDataType, DataTypeDate>)\n                    data_to.resize(size * (strlen(\"YYYY-MM-DD\") + 1));\n                else if constexpr (std::is_same_v<FromDataType, DataTypeDate32>)\n                    data_to.resize(size * (strlen(\"YYYY-MM-DD\") + 1));\n                else if constexpr (std::is_same_v<FromDataType, DataTypeDateTime>)\n                    data_to.resize(size * (strlen(\"YYYY-MM-DD hh:mm:ss\") + 1));\n                else if constexpr (std::is_same_v<FromDataType, DataTypeDateTime64>)\n                    data_to.resize(size * (strlen(\"YYYY-MM-DD hh:mm:ss.\") + col_from->getScale() + 1));\n                else\n                    data_to.resize(size * 3);   /// Arbitrary\n\n                offsets_to.resize(size);\n\n                WriteBufferFromVector<ColumnString::Chars> write_buffer(data_to);\n                const FromDataType & type = static_cast<const FromDataType &>(*col_with_type_and_name.type);\n\n                ColumnUInt8::MutablePtr null_map = copyNullMap(datetime_arg.column);\n\n                bool cut_trailing_zeros_align_to_groups_of_thousands = false;\n                if (DB::CurrentThread::isInitialized())\n                {\n                    const DB::ContextPtr query_context = DB::CurrentThread::get().getQueryContext();\n\n                    if (query_context)\n                        cut_trailing_zeros_align_to_groups_of_thousands = query_context->getSettingsRef()[Setting::date_time_64_output_format_cut_trailing_zeros_align_to_groups_of_thousands];\n                }\n\n                if (!null_map && arguments.size() > 1)\n                    null_map = copyNullMap(arguments[1].column->convertToFullColumnIfConst());\n\n                if (null_map)\n                {\n                    for (size_t i = 0; i < size; ++i)\n                    {\n                        if (!time_zone_column && arguments.size() > 1)\n                        {\n                            if (!arguments[1].column.get()->getDataAt(i).toString().empty())\n                                time_zone = &DateLUT::instance(arguments[1].column.get()->getDataAt(i).toString());\n                            else\n                                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Provided time zone must be non-empty\");\n                        }\n                        bool is_ok = true;\n                        if constexpr (std::is_same_v<FromDataType, DataTypeDateTime64>)\n                        {\n                            if (cut_trailing_zeros_align_to_groups_of_thousands)\n                                writeDateTimeTextCutTrailingZerosAlignToGroupOfThousands(DateTime64(vec_from[i]), type.getScale(), write_buffer, *time_zone);\n                            else\n                                is_ok = FormatImpl<FromDataType>::template execute<bool>(vec_from[i], write_buffer, &type, time_zone);\n                        }\n                        else\n                        {\n                            is_ok = FormatImpl<FromDataType>::template execute<bool>(vec_from[i], write_buffer, &type, time_zone);\n                        }\n                        null_map->getData()[i] |= !is_ok;\n                        writeChar(0, write_buffer);\n                        offsets_to[i] = write_buffer.count();\n                    }\n                }\n                else\n                {\n                    for (size_t i = 0; i < size; ++i)\n                    {\n                        if (!time_zone_column && arguments.size() > 1)\n                        {\n                            if (!arguments[1].column.get()->getDataAt(i).toString().empty())\n                                time_zone = &DateLUT::instance(arguments[1].column.get()->getDataAt(i).toString());\n                            else\n                                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Provided time zone must be non-empty\");\n                        }\n                        if constexpr (std::is_same_v<FromDataType, DataTypeDateTime64>)\n                        {\n                            if (cut_trailing_zeros_align_to_groups_of_thousands)\n                                writeDateTimeTextCutTrailingZerosAlignToGroupOfThousands(DateTime64(vec_from[i]), type.getScale(), write_buffer, *time_zone);\n                            else\n                                FormatImpl<FromDataType>::template execute<bool>(vec_from[i], write_buffer, &type, time_zone);\n                        }\n                        else\n                        {\n                            FormatImpl<FromDataType>::template execute<bool>(vec_from[i], write_buffer, &type, time_zone);\n                        }\n                        writeChar(0, write_buffer);\n                        offsets_to[i] = write_buffer.count();\n                    }\n                }\n\n                write_buffer.finalize();\n\n                if (null_map)\n                    return ColumnNullable::create(std::move(col_to), std::move(null_map));\n                return col_to;\n            }\n            else\n                throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of first argument of function {}\",\n                        arguments[0].column->getName(), Name::name);\n        }\n        /// Conversion from FixedString to String.\n        /// Cutting sequences of zero bytes from end of strings.\n        else if constexpr (std::is_same_v<ToDataType, DataTypeString>\n            && std::is_same_v<FromDataType, DataTypeFixedString>)\n        {\n            ColumnUInt8::MutablePtr null_map = copyNullMap(arguments[0].column);\n            const auto & nested =  columnGetNested(arguments[0]);\n            if (const ColumnFixedString * col_from = checkAndGetColumn<ColumnFixedString>(nested.column.get()))\n            {\n                auto col_to = ColumnString::create();\n\n                const ColumnFixedString::Chars & data_from = col_from->getChars();\n                ColumnString::Chars & data_to = col_to->getChars();\n                ColumnString::Offsets & offsets_to = col_to->getOffsets();\n                size_t size = col_from->size();\n                size_t n = col_from->getN();\n                data_to.resize(size * (n + 1)); /// + 1 - zero terminator\n                offsets_to.resize(size);\n\n                size_t offset_from = 0;\n                size_t offset_to = 0;\n                for (size_t i = 0; i < size; ++i)\n                {\n                    if (!null_map || !null_map->getData()[i])\n                    {\n                        size_t bytes_to_copy = n;\n                        while (bytes_to_copy > 0 && data_from[offset_from + bytes_to_copy - 1] == 0)\n                            --bytes_to_copy;\n\n                        memcpy(&data_to[offset_to], &data_from[offset_from], bytes_to_copy);\n                        offset_to += bytes_to_copy;\n                    }\n                    data_to[offset_to] = 0;\n                    ++offset_to;\n                    offsets_to[i] = offset_to;\n                    offset_from += n;\n                }\n\n                data_to.resize(offset_to);\n                if (result_type->isNullable() && null_map)\n                    return ColumnNullable::create(std::move(col_to), std::move(null_map));\n                return col_to;\n            }\n            else\n                throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of first argument of function {}\",\n                        arguments[0].column->getName(), Name::name);\n        }\n        else if constexpr (std::is_same_v<ToDataType, DataTypeString>)\n        {\n            /// Anything else to String.\n\n            using FromFieldType = typename FromDataType::FieldType;\n            using ColVecType = ColumnVectorOrDecimal<FromFieldType>;\n\n            ColumnUInt8::MutablePtr null_map = copyNullMap(arguments[0].column);\n\n            const auto & col_with_type_and_name = columnGetNested(arguments[0]);\n            const auto & type = static_cast<const FromDataType &>(*col_with_type_and_name.type);\n\n            if (const auto col_from = checkAndGetColumn<ColVecType>(col_with_type_and_name.column.get()))\n            {\n                auto col_to = ColumnString::create();\n\n                const typename ColVecType::Container & vec_from = col_from->getData();\n                ColumnString::Chars & data_to = col_to->getChars();\n                ColumnString::Offsets & offsets_to = col_to->getOffsets();\n                size_t size = vec_from.size();\n\n                data_to.resize(size * 3);\n                offsets_to.resize(size);\n\n                WriteBufferFromVector<ColumnString::Chars> write_buffer(data_to);\n\n                if (null_map)\n                {\n                    for (size_t i = 0; i < size; ++i)\n                    {\n                        bool is_ok = FormatImpl<FromDataType>::template execute<bool>(vec_from[i], write_buffer, &type, nullptr);\n                        /// We don't use timezones in this branch\n                        null_map->getData()[i] |= !is_ok;\n                        writeChar(0, write_buffer);\n                        offsets_to[i] = write_buffer.count();\n                    }\n                }\n                else\n                {\n                    for (size_t i = 0; i < size; ++i)\n                    {\n                        FormatImpl<FromDataType>::template execute<void>(vec_from[i], write_buffer, &type, nullptr);\n                        writeChar(0, write_buffer);\n                        offsets_to[i] = write_buffer.count();\n                    }\n                }\n\n                write_buffer.finalize();\n\n                if (null_map)\n                    return ColumnNullable::create(std::move(col_to), std::move(null_map));\n                return col_to;\n            }\n            else\n                throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of first argument of function {}\",\n                        arguments[0].column->getName(), Name::name);\n        }\n        else if constexpr (std::is_same_v<Name, NameToUnixTimestamp>\n            && std::is_same_v<FromDataType, DataTypeString>\n            && std::is_same_v<ToDataType, DataTypeUInt32>)\n        {\n            return ConvertImpl<FromDataType, DataTypeDateTime, Name, date_time_overflow_behavior>::template execute<Additions>(\n                arguments, result_type, input_rows_count, from_string_tag);\n        }\n        else if constexpr (std::is_same_v<Name, NameToUnixTimestampEx>\n            && std::is_same_v<FromDataType, DataTypeString>\n            && std::is_same_v<ToDataType, DataTypeInt64>)\n        {\n            /// Convert String to DateTime64\n            ColumnPtr res = ConvertImpl<FromDataType, DataTypeDateTime64, Name, date_time_overflow_behavior>::template execute<UInt32>(\n                arguments, result_type, input_rows_count, from_string_tag, 0);\n            /// Convert DateTime64 to Int64\n            return ConvertImpl<DataTypeDateTime64, ToDataType, Name, date_time_overflow_behavior>::template execute<Additions>(\n                ColumnsWithTypeAndName{{res, result_type, arguments[0].name}}, result_type, input_rows_count, from_string_tag);\n        }\n        else if constexpr ((std::is_same_v<FromDataType, DataTypeString> || std::is_same_v<FromDataType, DataTypeFixedString>))\n        {\n            switch (from_string_tag)\n            {\n            case BehaviourOnErrorFromString::ConvertDefaultBehaviorTag:\n                return ConvertThroughParsing<FromDataType,\n                                             ToDataType,\n                                             Name,\n                                             ConvertFromStringExceptionMode::Throw,\n                                             ConvertFromStringParsingMode::Normal>::execute(\n                        arguments, result_type, input_rows_count, additions);\n            case BehaviourOnErrorFromString::ConvertReturnNullOnErrorTag:\n                return ConvertThroughParsing<FromDataType,\n                                             ToDataType,\n                                             Name,\n                                             ConvertFromStringExceptionMode::Null,\n                                             ConvertFromStringParsingMode::Normal>::execute(\n                        arguments, result_type, input_rows_count, additions);\n            case BehaviourOnErrorFromString::ConvertReturnZeroOnErrorTag:\n                return ConvertThroughParsing<FromDataType,\n                                             ToDataType,\n                                             Name,\n                                             ConvertFromStringExceptionMode::Zero,\n                                             ConvertFromStringParsingMode::Normal>::execute(\n                        arguments, result_type, input_rows_count, additions);\n            }\n        }\n        else if constexpr (std::is_same_v<FromDataType, DataTypeInterval> && std::is_same_v<ToDataType, DataTypeInterval>)\n        {\n            IntervalKind to = typeid_cast<const DataTypeInterval *>(result_type.get())->getKind();\n            IntervalKind from = typeid_cast<const DataTypeInterval *>(arguments[0].type.get())->getKind();\n\n            if (from == to || arguments[0].column->empty())\n                return arguments[0].column;\n\n            Int64 conversion_factor = 1;\n            Int64 result_value;\n\n            int from_position = static_cast<int>(from.kind);\n            int to_position = static_cast<int>(to.kind); /// Positions of each interval according to granularity map\n\n            if (from_position < to_position)\n            {\n                for (int i = from_position; i < to_position; ++i)\n                    conversion_factor *= interval_conversions[i];\n                result_value = arguments[0].column->getInt(0) / conversion_factor;\n            }\n            else\n            {\n                for (int i = from_position; i > to_position; --i)\n                    conversion_factor *= interval_conversions[i];\n                result_value = arguments[0].column->getInt(0) * conversion_factor;\n            }\n\n            return ColumnConst::create(ColumnInt64::create(1, result_value), input_rows_count);\n        }\n        else\n        {\n            using FromFieldType = typename FromDataType::FieldType;\n            using ToFieldType = typename ToDataType::FieldType;\n            using ColVecFrom = typename FromDataType::ColumnType;\n            using ColVecTo = typename ToDataType::ColumnType;\n\n            if constexpr ((IsDataTypeDecimal<FromDataType> || IsDataTypeDecimal<ToDataType>)\n                && !(std::is_same_v<DataTypeDateTime64, FromDataType> || std::is_same_v<DataTypeDateTime64, ToDataType>)\n                && (!IsDataTypeDecimalOrNumber<FromDataType> || !IsDataTypeDecimalOrNumber<ToDataType>))\n            {\n                throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of first argument of function {}\",\n                    named_from.column->getName(), Name::name);\n            }\n\n            const ColVecFrom * col_from = checkAndGetColumn<ColVecFrom>(named_from.column.get());\n            if (!col_from)\n                throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of first argument of function {}\",\n                    named_from.column->getName(), Name::name);\n\n            typename ColVecTo::MutablePtr col_to = nullptr;\n\n            if constexpr (IsDataTypeDecimal<ToDataType>)\n            {\n                UInt32 scale;\n\n                if constexpr (std::is_same_v<Additions, AccurateConvertStrategyAdditions>\n                    || std::is_same_v<Additions, AccurateOrNullConvertStrategyAdditions>)\n                {\n                    scale = additions.scale;\n                }\n                else\n                {\n                    scale = additions;\n                }\n\n                col_to = ColVecTo::create(0, scale);\n            }\n            else\n                col_to = ColVecTo::create();\n\n            const auto & vec_from = col_from->getData();\n            auto & vec_to = col_to->getData();\n            vec_to.resize(input_rows_count);\n\n            ColumnUInt8::MutablePtr col_null_map_to;\n            ColumnUInt8::Container * vec_null_map_to [[maybe_unused]] = nullptr;\n            if constexpr (std::is_same_v<Additions, AccurateOrNullConvertStrategyAdditions>)\n            {\n                col_null_map_to = ColumnUInt8::create(input_rows_count, false);\n                vec_null_map_to = &col_null_map_to->getData();\n            }\n\n            bool result_is_bool = isBool(result_type);\n            for (size_t i = 0; i < input_rows_count; ++i)\n            {\n                if constexpr (std::is_same_v<ToDataType, DataTypeUInt8>)\n                {\n                    if (result_is_bool)\n                    {\n                        vec_to[i] = vec_from[i] != FromFieldType(0);\n                        continue;\n                    }\n                }\n\n                if constexpr (std::is_same_v<FromDataType, DataTypeUUID> && std::is_same_v<ToDataType, DataTypeUInt128>)\n                {\n                    static_assert(\n                        std::is_same_v<DataTypeUInt128::FieldType, DataTypeUUID::FieldType::UnderlyingType>,\n                        \"UInt128 and UUID types must be same\");\n\n                    vec_to[i].items[1] = vec_from[i].toUnderType().items[0];\n                    vec_to[i].items[0] = vec_from[i].toUnderType().items[1];\n                }\n                else if constexpr (std::is_same_v<FromDataType, DataTypeIPv6> && std::is_same_v<ToDataType, DataTypeUInt128>)\n                {\n                    static_assert(\n                        std::is_same_v<DataTypeUInt128::FieldType, DataTypeUUID::FieldType::UnderlyingType>,\n                        \"UInt128 and IPv6 types must be same\");\n\n                    vec_to[i].items[1] = std::byteswap(vec_from[i].toUnderType().items[0]);\n                    vec_to[i].items[0] = std::byteswap(vec_from[i].toUnderType().items[1]);\n                }\n                else if constexpr (std::is_same_v<FromDataType, DataTypeUUID> != std::is_same_v<ToDataType, DataTypeUUID>)\n                {\n                    throw Exception(ErrorCodes::NOT_IMPLEMENTED,\n                                    \"Conversion between numeric types and UUID is not supported. \"\n                                    \"Probably the passed UUID is unquoted\");\n                }\n                else if constexpr (\n                    (std::is_same_v<FromDataType, DataTypeIPv4> != std::is_same_v<ToDataType, DataTypeIPv4>)\n                    && !(is_any_of<FromDataType, DataTypeUInt8, DataTypeUInt16, DataTypeUInt32, DataTypeUInt64, DataTypeIPv6>\n                        || is_any_of<ToDataType, DataTypeUInt32, DataTypeUInt64, DataTypeUInt128, DataTypeUInt256, DataTypeIPv6>))\n                {\n                    throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Conversion from {} to {} is not supported\",\n                                    TypeName<typename FromDataType::FieldType>, TypeName<typename ToDataType::FieldType>);\n                }\n                else if constexpr (std::is_same_v<FromDataType, DataTypeIPv6> != std::is_same_v<ToDataType, DataTypeIPv6>\n                    && !(std::is_same_v<ToDataType, DataTypeIPv4> || std::is_same_v<FromDataType, DataTypeIPv4>))\n                {\n                    throw Exception(ErrorCodes::NOT_IMPLEMENTED,\n                                    \"Conversion between numeric types and IPv6 is not supported. \"\n                                    \"Probably the passed IPv6 is unquoted\");\n                }\n                else if constexpr (IsDataTypeDecimal<FromDataType> || IsDataTypeDecimal<ToDataType>)\n                {\n                    if constexpr (std::is_same_v<Additions, AccurateOrNullConvertStrategyAdditions>)\n                    {\n                        ToFieldType result;\n                        bool convert_result = false;\n\n                        if constexpr (IsDataTypeDecimal<FromDataType> && IsDataTypeDecimal<ToDataType>)\n                            convert_result = tryConvertDecimals<FromDataType, ToDataType>(vec_from[i], col_from->getScale(), col_to->getScale(), result);\n                        else if constexpr (IsDataTypeDecimal<FromDataType> && IsDataTypeNumber<ToDataType>)\n                            convert_result = tryConvertFromDecimal<FromDataType, ToDataType>(vec_from[i], col_from->getScale(), result);\n                        else if constexpr (IsDataTypeNumber<FromDataType> && IsDataTypeDecimal<ToDataType>)\n                            convert_result = tryConvertToDecimal<FromDataType, ToDataType>(vec_from[i], col_to->getScale(), result);\n\n                        if (convert_result)\n                            vec_to[i] = result;\n                        else\n                        {\n                            vec_to[i] = static_cast<ToFieldType>(0);\n                            (*vec_null_map_to)[i] = true;\n                        }\n                    }\n                    else\n                    {\n                        if constexpr (IsDataTypeDecimal<FromDataType> && IsDataTypeDecimal<ToDataType>)\n                            vec_to[i] = convertDecimals<FromDataType, ToDataType>(vec_from[i], col_from->getScale(), col_to->getScale());\n                        else if constexpr (IsDataTypeDecimal<FromDataType> && IsDataTypeNumber<ToDataType>)\n                            vec_to[i] = convertFromDecimal<FromDataType, ToDataType>(vec_from[i], col_from->getScale());\n                        else if constexpr (IsDataTypeNumber<FromDataType> && IsDataTypeDecimal<ToDataType>)\n                            vec_to[i] = convertToDecimal<FromDataType, ToDataType>(vec_from[i], col_to->getScale());\n                        else\n                            throw Exception(ErrorCodes::CANNOT_CONVERT_TYPE, \"Unsupported data type in conversion function\");\n                    }\n                }\n                else if constexpr (std::is_same_v<ToDataType, DataTypeIPv4> && std::is_same_v<FromDataType, DataTypeIPv6>)\n                {\n                    const uint8_t ip4_cidr[] {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00};\n                    const uint8_t * src = reinterpret_cast<const uint8_t *>(&vec_from[i].toUnderType());\n                    if (!matchIPv6Subnet(src, ip4_cidr, 96))\n                    {\n                        char addr[IPV6_MAX_TEXT_LENGTH + 1] {};\n                        char * paddr = addr;\n                        formatIPv6(src, paddr);\n\n                        throw Exception(ErrorCodes::CANNOT_CONVERT_TYPE, \"IPv6 {} in column {} is not in IPv4 mapping block\", addr, named_from.column->getName());\n                    }\n\n                    uint8_t * dst = reinterpret_cast<uint8_t *>(&vec_to[i].toUnderType());\n                    if constexpr (std::endian::native == std::endian::little)\n                    {\n                        dst[0] = src[15];\n                        dst[1] = src[14];\n                        dst[2] = src[13];\n                        dst[3] = src[12];\n                    }\n                    else\n                    {\n                        dst[0] = src[12];\n                        dst[1] = src[13];\n                        dst[2] = src[14];\n                        dst[3] = src[15];\n                    }\n                }\n                else if constexpr (std::is_same_v<ToDataType, DataTypeIPv6> && std::is_same_v<FromDataType, DataTypeIPv4>)\n                {\n                    const uint8_t * src = reinterpret_cast<const uint8_t *>(&vec_from[i].toUnderType());\n                    uint8_t * dst = reinterpret_cast<uint8_t *>(&vec_to[i].toUnderType());\n                    std::memset(dst, '\\0', IPV6_BINARY_LENGTH);\n                    dst[10] = dst[11] = 0xff;\n\n                    if constexpr (std::endian::native == std::endian::little)\n                    {\n                        dst[12] = src[3];\n                        dst[13] = src[2];\n                        dst[14] = src[1];\n                        dst[15] = src[0];\n                    }\n                    else\n                    {\n                        dst[12] = src[0];\n                        dst[13] = src[1];\n                        dst[14] = src[2];\n                        dst[15] = src[3];\n                    }\n                }\n                else if constexpr (std::is_same_v<ToDataType, DataTypeIPv4> && std::is_same_v<FromDataType, DataTypeUInt64>)\n                {\n                    vec_to[i] = static_cast<ToFieldType>(static_cast<IPv4::UnderlyingType>(vec_from[i]));\n                }\n                else if constexpr (std::is_same_v<Name, NameToUnixTimestamp>\n                    && (std::is_same_v<FromDataType, DataTypeDate> || std::is_same_v<FromDataType, DataTypeDate32>))\n                {\n                    vec_to[i] = static_cast<ToFieldType>(vec_from[i] * DATE_SECONDS_PER_DAY);\n                }\n                else if constexpr (std::is_same_v<Name, NameToUnixTimestampEx>\n                    && (std::is_same_v<FromDataType, DataTypeDate> || std::is_same_v<FromDataType, DataTypeDate32>))\n                {\n                    vec_to[i] = vec_from[i] * DATE_SECONDS_PER_DAY;\n                }\n                else\n                {\n                    /// If From Data is Nan or Inf and we convert to integer type, throw exception\n                    if constexpr (std::is_floating_point_v<FromFieldType> && !std::is_floating_point_v<ToFieldType>)\n                    {\n                        if (!isFinite(vec_from[i]))\n                        {\n                            if constexpr (std::is_same_v<Additions, AccurateOrNullConvertStrategyAdditions>)\n                            {\n                                vec_to[i] = 0;\n                                (*vec_null_map_to)[i] = true;\n                                continue;\n                            }\n                            else\n                                throw Exception(ErrorCodes::CANNOT_CONVERT_TYPE, \"Unexpected inf or nan to integer conversion\");\n                        }\n                    }\n\n                    if constexpr (std::is_same_v<Additions, AccurateOrNullConvertStrategyAdditions>\n                            || std::is_same_v<Additions, AccurateConvertStrategyAdditions>)\n                    {\n                        bool convert_result = accurate::convertNumeric(vec_from[i], vec_to[i]);\n\n                        if (!convert_result)\n                        {\n                            if (std::is_same_v<Additions, AccurateOrNullConvertStrategyAdditions>)\n                            {\n                                vec_to[i] = 0;\n                                (*vec_null_map_to)[i] = true;\n                            }\n                            else\n                            {\n                                throw Exception(ErrorCodes::CANNOT_CONVERT_TYPE, \"Value in column {} cannot be safely converted into type {}\",\n                                    named_from.column->getName(), result_type->getName());\n                            }\n                        }\n                    }\n                    else\n                    {\n                        vec_to[i] = static_cast<ToFieldType>(vec_from[i]);\n                    }\n                }\n            }\n\n            if constexpr (std::is_same_v<Additions, AccurateOrNullConvertStrategyAdditions>)\n                return ColumnNullable::create(std::move(col_to), std::move(col_null_map_to));\n            else\n                return col_to;\n        }\n    }\n};\n\n\n/// Generic conversion of any type from String. Used for complex types: Array and Tuple or types with custom serialization.\ntemplate <bool throw_on_error>\nstruct ConvertImplGenericFromString\n{\n    static ColumnPtr execute(ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable * column_nullable, size_t input_rows_count, const ContextPtr & context)\n    {\n        const IColumn & column_from = *arguments[0].column;\n        const IDataType & data_type_to = *result_type;\n        auto res = data_type_to.createColumn();\n        auto serialization = data_type_to.getDefaultSerialization();\n        const auto * null_map = column_nullable ? &column_nullable->getNullMapData() : nullptr;\n\n        executeImpl(column_from, *res, *serialization, input_rows_count, null_map, result_type.get(), context);\n        return res;\n    }\n\n    static void executeImpl(\n        const IColumn & column_from,\n        IColumn & column_to,\n        const ISerialization & serialization_from,\n        size_t input_rows_count,\n        const PaddedPODArray<UInt8> * null_map,\n        const IDataType * result_type,\n        const ContextPtr & context)\n    {\n        column_to.reserve(input_rows_count);\n\n        FormatSettings format_settings = context ? getFormatSettings(context) : FormatSettings{};\n        for (size_t i = 0; i < input_rows_count; ++i)\n        {\n            if (null_map && (*null_map)[i])\n            {\n                column_to.insertDefault();\n                continue;\n            }\n\n            const auto & val = column_from.getDataAt(i);\n            ReadBufferFromMemory read_buffer(val.data, val.size);\n            try\n            {\n                serialization_from.deserializeWholeText(column_to, read_buffer, format_settings);\n            }\n            catch (const Exception &)\n            {\n                if constexpr (throw_on_error)\n                    throw;\n                /// Check if exception happened after we inserted the value\n                /// (deserializeWholeText should not do it, but let's check anyway).\n                if (column_to.size() > i)\n                    column_to.popBack(column_to.size() - i);\n                column_to.insertDefault();\n            }\n\n            /// Usually deserializeWholeText checks for eof after parsing, but let's check one more time just in case.\n            if (!read_buffer.eof())\n            {\n                if constexpr (throw_on_error)\n                {\n                    if (result_type)\n                        throwExceptionForIncompletelyParsedValue(read_buffer, *result_type);\n                    else\n                        throw Exception(\n                            ErrorCodes::CANNOT_PARSE_TEXT, \"Cannot parse string to column {}. Expected eof\", column_to.getName());\n                }\n                else\n                {\n                    if (column_to.size() > i)\n                        column_to.popBack(column_to.size() - i);\n                    column_to.insertDefault();\n                }\n            }\n        }\n    }\n};\n\n\n/// Declared early because used below.\nstruct NameToDate { static constexpr auto name = \"toDate\"; };\nstruct NameToDate32 { static constexpr auto name = \"toDate32\"; };\nstruct NameToDateTime { static constexpr auto name = \"toDateTime\"; };\nstruct NameToDateTime32 { static constexpr auto name = \"toDateTime32\"; };\nstruct NameToDateTime64 { static constexpr auto name = \"toDateTime64\"; };\nstruct NameToString { static constexpr auto name = \"toString\"; };\nstruct NameToDecimal32 { static constexpr auto name = \"toDecimal32\"; };\nstruct NameToDecimal64 { static constexpr auto name = \"toDecimal64\"; };\nstruct NameToDecimal128 { static constexpr auto name = \"toDecimal128\"; };\nstruct NameToDecimal256 { static constexpr auto name = \"toDecimal256\"; };\n\n\n#define DEFINE_NAME_TO_INTERVAL(INTERVAL_KIND) \\\n    struct NameToInterval ## INTERVAL_KIND \\\n    { \\\n        static constexpr auto name = \"toInterval\" #INTERVAL_KIND; \\\n        static constexpr auto kind = IntervalKind::Kind::INTERVAL_KIND; \\\n    };\n\nDEFINE_NAME_TO_INTERVAL(Nanosecond)\nDEFINE_NAME_TO_INTERVAL(Microsecond)\nDEFINE_NAME_TO_INTERVAL(Millisecond)\nDEFINE_NAME_TO_INTERVAL(Second)\nDEFINE_NAME_TO_INTERVAL(Minute)\nDEFINE_NAME_TO_INTERVAL(Hour)\nDEFINE_NAME_TO_INTERVAL(Day)\nDEFINE_NAME_TO_INTERVAL(Week)\nDEFINE_NAME_TO_INTERVAL(Month)\nDEFINE_NAME_TO_INTERVAL(Quarter)\nDEFINE_NAME_TO_INTERVAL(Year)\n\n#undef DEFINE_NAME_TO_INTERVAL\n\nstruct NameParseDateTimeBestEffort;\nstruct NameParseDateTimeBestEffortOrZero;\nstruct NameParseDateTimeBestEffortOrNull;\n\ntemplate <typename Name, typename ToDataType>\nconstexpr bool mightBeDateTime()\n{\n    if constexpr (std::is_same_v<ToDataType, DataTypeDateTime64>)\n        return true;\n    else if constexpr (\n        std::is_same_v<Name, NameToDateTime> || std::is_same_v<Name, NameParseDateTimeBestEffort>\n        || std::is_same_v<Name, NameParseDateTimeBestEffortOrZero> || std::is_same_v<Name, NameParseDateTimeBestEffortOrNull>)\n        return true;\n\n    return false;\n}\n\ntemplate<typename Name, typename ToDataType>\ninline bool isDateTime64(const ColumnsWithTypeAndName & arguments)\n{\n    if constexpr (std::is_same_v<ToDataType, DataTypeDateTime64>)\n        return true;\n    else if constexpr (std::is_same_v<Name, NameToDateTime> || std::is_same_v<Name, NameParseDateTimeBestEffort>\n        || std::is_same_v<Name, NameParseDateTimeBestEffortOrZero> || std::is_same_v<Name, NameParseDateTimeBestEffortOrNull>)\n    {\n        return (arguments.size() == 2 && isUInt(arguments[1].type)) || arguments.size() == 3;\n    }\n\n    return false;\n}\n\ntemplate <typename ToDataType, typename Name, typename MonotonicityImpl>\nclass FunctionConvert : public IFunction\n{\npublic:\n    using Monotonic = MonotonicityImpl;\n\n    static constexpr auto name = Name::name;\n    static constexpr bool to_datetime64 = std::is_same_v<ToDataType, DataTypeDateTime64>;\n    static constexpr bool to_decimal = IsDataTypeDecimal<ToDataType> && !to_datetime64;\n\n    static FunctionPtr create(ContextPtr context) { return std::make_shared<FunctionConvert>(context); }\n    explicit FunctionConvert(ContextPtr context_) : context(context_) {}\n\n    String getName() const override\n    {\n        return name;\n    }\n\n    bool isVariadic() const override { return true; }\n    size_t getNumberOfArguments() const override { return 0; }\n    bool isInjective(const ColumnsWithTypeAndName &) const override { return std::is_same_v<Name, NameToString>; }\n    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & arguments) const override\n    {\n        return !(IsDataTypeDateOrDateTime<ToDataType> && isNumber(*arguments[0].type));\n    }\n\n    using DefaultReturnTypeGetter = std::function<DataTypePtr(const ColumnsWithTypeAndName &)>;\n    static DataTypePtr getReturnTypeDefaultImplementationForNulls(const ColumnsWithTypeAndName & arguments, const DefaultReturnTypeGetter & getter)\n    {\n        NullPresence null_presence = getNullPresense(arguments);\n\n        if (null_presence.has_null_constant)\n        {\n            return makeNullable(std::make_shared<DataTypeNothing>());\n        }\n        if (null_presence.has_nullable)\n        {\n            auto nested_columns = Block(createBlockWithNestedColumns(arguments));\n            auto return_type = getter(ColumnsWithTypeAndName(nested_columns.begin(), nested_columns.end()));\n            return makeNullable(return_type);\n        }\n\n        return getter(arguments);\n    }\n\n    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n    {\n        auto getter = [&] (const auto & args) { return getReturnTypeImplRemovedNullable(args); };\n        auto res = getReturnTypeDefaultImplementationForNulls(arguments, getter);\n        to_nullable = res->isNullable();\n        checked_return_type = true;\n        return res;\n    }\n\n    DataTypePtr getReturnTypeImplRemovedNullable(const ColumnsWithTypeAndName & arguments) const\n    {\n        FunctionArgumentDescriptors mandatory_args = {{\"Value\", nullptr, nullptr, \"any type\"}};\n        FunctionArgumentDescriptors optional_args;\n\n        if constexpr (to_decimal)\n        {\n            mandatory_args.push_back({\"scale\", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isNativeInteger), &isColumnConst, \"const Integer\"});\n        }\n\n        if (!to_decimal && isDateTime64<Name, ToDataType>(arguments))\n        {\n            mandatory_args.push_back({\"scale\", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isNativeInteger), &isColumnConst, \"const Integer\"});\n        }\n\n        // toString(DateTime or DateTime64, [timezone: String])\n        if ((std::is_same_v<Name, NameToString> && !arguments.empty() && (isDateTime64(arguments[0].type) || isDateTime(arguments[0].type)))\n            // toUnixTimestamp(value[, timezone : String])\n            || std::is_same_v<Name, NameToUnixTimestamp>\n            // toUnixTimestampEx(value[, timezone : String])\n            || std::is_same_v<Name, NameToUnixTimestampEx>\n            // toDate(value[, timezone : String])\n            || std::is_same_v<ToDataType, DataTypeDate> // TODO: shall we allow timestamp argument for toDate? DateTime knows nothing about timezones and this argument is ignored below.\n            // toDate32(value[, timezone : String])\n            || std::is_same_v<ToDataType, DataTypeDate32>\n            // toDateTime(value[, timezone: String])\n            || std::is_same_v<ToDataType, DataTypeDateTime>\n            // toDateTime64(value, scale : Integer[, timezone: String])\n            || std::is_same_v<ToDataType, DataTypeDateTime64>)\n        {\n            optional_args.push_back({\"timezone\", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isString), nullptr, \"String\"});\n        }\n\n            validateFunctionArguments(*this, arguments, mandatory_args, optional_args);\n\n        if constexpr (std::is_same_v<ToDataType, DataTypeInterval>)\n        {\n            return std::make_shared<DataTypeInterval>(Name::kind);\n        }\n        else if constexpr (to_decimal)\n        {\n            UInt64 scale = extractToDecimalScale(arguments[1]);\n\n            if constexpr (std::is_same_v<Name, NameToDecimal32>)\n                return createDecimalMaxPrecision<Decimal32>(scale);\n            else if constexpr (std::is_same_v<Name, NameToDecimal64>)\n                return createDecimalMaxPrecision<Decimal64>(scale);\n            else if constexpr (std::is_same_v<Name, NameToDecimal128>)\n                return createDecimalMaxPrecision<Decimal128>(scale);\n            else if constexpr (std::is_same_v<Name, NameToDecimal256>)\n                return createDecimalMaxPrecision<Decimal256>(scale);\n\n            throw Exception(ErrorCodes::LOGICAL_ERROR, \"Unexpected branch in code of conversion function: it is a bug.\");\n        }\n        else\n        {\n            // Optional second argument with time zone for DateTime.\n            UInt8 timezone_arg_position = 1;\n            UInt32 scale [[maybe_unused]] = DataTypeDateTime64::default_scale;\n\n            // DateTime64 requires more arguments: scale and timezone. Since timezone is optional, scale should be first.\n            if (isDateTime64<Name, ToDataType>(arguments))\n            {\n                timezone_arg_position += 1;\n                scale = static_cast<UInt32>(arguments[1].column->get64(0));\n\n                if (to_datetime64 || scale != 0) /// toDateTime('xxxx-xx-xx xx:xx:xx', 0) return DateTime\n                    return std::make_shared<DataTypeDateTime64>(scale,\n                        extractTimeZoneNameFromFunctionArguments(arguments, timezone_arg_position, 0, false));\n\n                return std::make_shared<DataTypeDateTime>(extractTimeZoneNameFromFunctionArguments(arguments, timezone_arg_position, 0, false));\n            }\n\n            if constexpr (std::is_same_v<ToDataType, DataTypeDateTime>)\n                return std::make_shared<DataTypeDateTime>(extractTimeZoneNameFromFunctionArguments(arguments, timezone_arg_position, 0, false));\n            else if constexpr (std::is_same_v<ToDataType, DataTypeDateTime64>)\n                throw Exception(ErrorCodes::LOGICAL_ERROR, \"Unexpected branch in code of conversion function: it is a bug.\");\n            else\n                return std::make_shared<ToDataType>();\n        }\n    }\n\n    /// Function actually uses default implementation for nulls,\n    /// but we need to know if return type is Nullable or not,\n    /// so we use checked_return_type only to intercept the first call to getReturnTypeImpl(...).\n    bool useDefaultImplementationForNulls() const override\n    {\n        bool to_nullable_string = to_nullable && std::is_same_v<ToDataType, DataTypeString>;\n        return checked_return_type && !to_nullable_string;\n    }\n\n    bool useDefaultImplementationForConstants() const override { return true; }\n    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override\n    {\n        if constexpr (std::is_same_v<ToDataType, DataTypeString>)\n            return {};\n        else if constexpr (std::is_same_v<ToDataType, DataTypeDateTime64>)\n            return {2};\n        return {1};\n    }\n    bool canBeExecutedOnDefaultArguments() const override { return false; }\n\n    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override\n    {\n        try\n        {\n            return executeInternal(arguments, result_type, input_rows_count);\n        }\n        catch (Exception & e)\n        {\n            /// More convenient error message.\n            if (e.code() == ErrorCodes::ATTEMPT_TO_READ_AFTER_EOF)\n            {\n                e.addMessage(\"Cannot parse \"\n                    + result_type->getName() + \" from \"\n                    + arguments[0].type->getName()\n                    + \", because value is too short\");\n            }\n            else if (e.code() == ErrorCodes::CANNOT_PARSE_NUMBER\n                || e.code() == ErrorCodes::CANNOT_READ_ARRAY_FROM_TEXT\n                || e.code() == ErrorCodes::CANNOT_PARSE_INPUT_ASSERTION_FAILED\n                || e.code() == ErrorCodes::CANNOT_PARSE_QUOTED_STRING\n                || e.code() == ErrorCodes::CANNOT_PARSE_ESCAPE_SEQUENCE\n                || e.code() == ErrorCodes::CANNOT_PARSE_DATE\n                || e.code() == ErrorCodes::CANNOT_PARSE_DATETIME\n                || e.code() == ErrorCodes::CANNOT_PARSE_UUID\n                || e.code() == ErrorCodes::CANNOT_PARSE_IPV4\n                || e.code() == ErrorCodes::CANNOT_PARSE_IPV6)\n            {\n                e.addMessage(\"Cannot parse \"\n                    + result_type->getName() + \" from \"\n                    + arguments[0].type->getName());\n            }\n\n            throw;\n        }\n    }\n\n    bool hasInformationAboutMonotonicity() const override\n    {\n        return Monotonic::has();\n    }\n\n    Monotonicity getMonotonicityForRange(const IDataType & type, const Field & left, const Field & right) const override\n    {\n        return Monotonic::get(type, left, right);\n    }\n\nprivate:\n    ContextPtr context;\n    mutable bool checked_return_type = false;\n    mutable bool to_nullable = false;\n\n    ColumnPtr executeInternal(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const\n    {\n        if (arguments.empty())\n            throw Exception(ErrorCodes::TOO_FEW_ARGUMENTS_FOR_FUNCTION, \"Function {} expects at least 1 argument\", getName());\n\n        if (result_type->onlyNull())\n            return result_type->createColumnConstWithDefaultValue(input_rows_count);\n\n        const DataTypePtr from_type = removeNullable(arguments[0].type);\n        ColumnPtr result_column;\n\n        FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior = default_date_time_overflow_behavior;\n\n        if (context)\n            date_time_overflow_behavior = context->getSettingsRef()[Setting::date_time_overflow_behavior].value;\n\n        auto call = [&](const auto & types, BehaviourOnErrorFromString from_string_tag) -> bool\n        {\n            using Types = std::decay_t<decltype(types)>;\n            using LeftDataType = typename Types::LeftType;\n            using RightDataType = typename Types::RightType;\n\n            if constexpr (IsDataTypeDecimal<RightDataType>)\n            {\n\n                if constexpr (std::is_same_v<RightDataType, DataTypeDateTime64>)\n                {\n                    /// Account for optional timezone argument.\n                    if (arguments.size() != 2 && arguments.size() != 3)\n                        throw Exception(ErrorCodes::TOO_FEW_ARGUMENTS_FOR_FUNCTION, \"Function {} expects 2 or 3 arguments for DataTypeDateTime64.\", getName());\n                }\n                else if (arguments.size() != 2)\n                {\n                    throw Exception(ErrorCodes::TOO_FEW_ARGUMENTS_FOR_FUNCTION, \"Function {} expects 2 arguments for Decimal.\", getName());\n                }\n\n                const ColumnWithTypeAndName & scale_column = arguments[1];\n                UInt32 scale = extractToDecimalScale(scale_column);\n\n                switch (date_time_overflow_behavior)\n                {\n                    case FormatSettings::DateTimeOverflowBehavior::Throw:\n                        result_column = ConvertImpl<LeftDataType, RightDataType, Name, FormatSettings::DateTimeOverflowBehavior::Throw>::execute(arguments, result_type, input_rows_count, from_string_tag, scale);\n                        break;\n                    case FormatSettings::DateTimeOverflowBehavior::Ignore:\n                        result_column = ConvertImpl<LeftDataType, RightDataType, Name, FormatSettings::DateTimeOverflowBehavior::Ignore>::execute(arguments, result_type, input_rows_count, from_string_tag, scale);\n                        break;\n                    case FormatSettings::DateTimeOverflowBehavior::Saturate:\n                        result_column = ConvertImpl<LeftDataType, RightDataType, Name, FormatSettings::DateTimeOverflowBehavior::Saturate>::execute(arguments, result_type, input_rows_count, from_string_tag, scale);\n                        break;\n                }\n            }\n            else if constexpr (IsDataTypeDateOrDateTime<RightDataType> && std::is_same_v<LeftDataType, DataTypeDateTime64>)\n            {\n                const auto * dt64 = assert_cast<const DataTypeDateTime64 *>(arguments[0].type.get());\n                switch (date_time_overflow_behavior)\n                {\n                    case FormatSettings::DateTimeOverflowBehavior::Throw:\n                        result_column = ConvertImpl<LeftDataType, RightDataType, Name, FormatSettings::DateTimeOverflowBehavior::Throw>::execute(arguments, result_type, input_rows_count, from_string_tag, dt64->getScale());\n                        break;\n                    case FormatSettings::DateTimeOverflowBehavior::Ignore:\n                        result_column = ConvertImpl<LeftDataType, RightDataType, Name, FormatSettings::DateTimeOverflowBehavior::Ignore>::execute(arguments, result_type, input_rows_count, from_string_tag, dt64->getScale());\n                        break;\n                    case FormatSettings::DateTimeOverflowBehavior::Saturate:\n                        result_column = ConvertImpl<LeftDataType, RightDataType, Name, FormatSettings::DateTimeOverflowBehavior::Saturate>::execute(arguments, result_type, input_rows_count, from_string_tag, dt64->getScale());\n                        break;\n                }\n            }\n            else if constexpr ((IsDataTypeNumber<LeftDataType>\n                                || IsDataTypeDateOrDateTime<LeftDataType>)&&IsDataTypeDateOrDateTime<RightDataType>)\n            {\n#define GENERATE_OVERFLOW_MODE_CASE(OVERFLOW_MODE) \\\n    case FormatSettings::DateTimeOverflowBehavior::OVERFLOW_MODE: \\\n        result_column = ConvertImpl<LeftDataType, RightDataType, Name, FormatSettings::DateTimeOverflowBehavior::OVERFLOW_MODE>::execute( \\\n            arguments, result_type, input_rows_count, from_string_tag); \\\n        break;\n                switch (date_time_overflow_behavior)\n                {\n                    GENERATE_OVERFLOW_MODE_CASE(Throw)\n                    GENERATE_OVERFLOW_MODE_CASE(Ignore)\n                    GENERATE_OVERFLOW_MODE_CASE(Saturate)\n                }\n\n#undef GENERATE_OVERFLOW_MODE_CASE\n            }\n            else if constexpr (IsDataTypeDecimalOrNumber<LeftDataType> && IsDataTypeDecimalOrNumber<RightDataType>)\n            {\n                using LeftT = typename LeftDataType::FieldType;\n                using RightT = typename RightDataType::FieldType;\n\n                static constexpr bool bad_left =\n                    is_decimal<LeftT> || std::is_floating_point_v<LeftT> || is_big_int_v<LeftT> || is_signed_v<LeftT>;\n                static constexpr bool bad_right =\n                    is_decimal<RightT> || std::is_floating_point_v<RightT> || is_big_int_v<RightT> || is_signed_v<RightT>;\n\n                /// Disallow int vs UUID conversion (but support int vs UInt128 conversion)\n                if constexpr ((bad_left && std::is_same_v<RightDataType, DataTypeUUID>) ||\n                              (bad_right && std::is_same_v<LeftDataType, DataTypeUUID>))\n                {\n                    throw Exception(ErrorCodes::CANNOT_CONVERT_TYPE, \"Wrong UUID conversion\");\n                }\n                else\n                {\n                    result_column = ConvertImpl<LeftDataType, RightDataType, Name>::execute(\n                        arguments, result_type, input_rows_count, from_string_tag);\n                }\n            }\n            else\n                result_column = ConvertImpl<LeftDataType, RightDataType, Name>::execute(arguments, result_type, input_rows_count, from_string_tag);\n\n            return true;\n        };\n\n        if constexpr (mightBeDateTime<Name, ToDataType>())\n        {\n            if (isDateTime64<Name, ToDataType>(arguments))\n            {\n                /// For toDateTime('xxxx-xx-xx xx:xx:xx.00', 2[, 'timezone']) we need to it convert to DateTime64\n                const ColumnWithTypeAndName & scale_column = arguments[1];\n                UInt32 scale = extractToDecimalScale(scale_column);\n\n                if (to_datetime64 || scale != 0) /// When scale = 0, the data type is DateTime otherwise the data type is DateTime64\n                {\n                    if (!callOnIndexAndDataType<DataTypeDateTime64>(\n                            from_type->getTypeId(), call, BehaviourOnErrorFromString::ConvertDefaultBehaviorTag))\n                        throw Exception(\n                            ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n                            \"Illegal type {} of argument of function {}\",\n                            arguments[0].type->getName(),\n                            getName());\n\n                    return result_column;\n                }\n            }\n        }\n\n        if constexpr (std::is_same_v<ToDataType, DataTypeString>)\n        {\n            if (from_type->getCustomSerialization())\n                return ConvertImplGenericToString<ColumnString>::execute(arguments, result_type, input_rows_count, context);\n        }\n\n        bool done = false;\n        if constexpr (is_any_of<ToDataType, DataTypeString, DataTypeFixedString>)\n        {\n            done = callOnIndexAndDataType<ToDataType>(from_type->getTypeId(), call, BehaviourOnErrorFromString::ConvertDefaultBehaviorTag);\n        }\n        else\n        {\n            bool cast_ipv4_ipv6_default_on_conversion_error = false;\n            if constexpr (is_any_of<ToDataType, DataTypeIPv4, DataTypeIPv6>)\n            {\n                if (context && (cast_ipv4_ipv6_default_on_conversion_error = context->getSettingsRef()[Setting::cast_ipv4_ipv6_default_on_conversion_error]))\n                    done = callOnIndexAndDataType<ToDataType>(from_type->getTypeId(), call, BehaviourOnErrorFromString::ConvertReturnZeroOnErrorTag);\n            }\n\n            if (!cast_ipv4_ipv6_default_on_conversion_error)\n            {\n                /// We should use ConvertFromStringExceptionMode::Null mode when converting from String (or FixedString)\n                /// to Nullable type, to avoid 'value is too short' error on attempt to parse empty string from NULL values.\n                if (to_nullable && WhichDataType(from_type).isStringOrFixedString())\n                    done = callOnIndexAndDataType<ToDataType>(from_type->getTypeId(), call, BehaviourOnErrorFromString::ConvertReturnNullOnErrorTag);\n                else\n                    done = callOnIndexAndDataType<ToDataType>(from_type->getTypeId(), call, BehaviourOnErrorFromString::ConvertDefaultBehaviorTag);\n            }\n\n            if constexpr (std::is_same_v<ToDataType, DataTypeInterval>)\n                if (WhichDataType(from_type).isInterval())\n                    done = callOnIndexAndDataType<ToDataType>(from_type->getTypeId(), call, BehaviourOnErrorFromString::ConvertDefaultBehaviorTag);\n        }\n\n        if (!done)\n        {\n            /// Generic conversion of any type to String.\n            if (std::is_same_v<ToDataType, DataTypeString>)\n            {\n                return ConvertImplGenericToString<ColumnString>::execute(arguments, result_type, input_rows_count, context);\n            }\n            else\n                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal type {} of argument of function {}\",\n                    arguments[0].type->getName(), getName());\n        }\n\n        return result_column;\n    }\n};\n\n\n/** Function toTOrZero (where T is number of date or datetime type):\n  *  try to convert from String to type T through parsing,\n  *  if cannot parse, return default value instead of throwing exception.\n  * Function toTOrNull will return Nullable type with NULL when cannot parse.\n  * NOTE Also need to implement tryToUnixTimestamp with timezone.\n  */\ntemplate <typename ToDataType, typename Name,\n    ConvertFromStringExceptionMode exception_mode,\n    ConvertFromStringParsingMode parsing_mode = ConvertFromStringParsingMode::Normal>\nclass FunctionConvertFromString : public IFunction\n{\npublic:\n    static constexpr auto name = Name::name;\n    static constexpr bool to_datetime64 = std::is_same_v<ToDataType, DataTypeDateTime64>;\n    static constexpr bool to_decimal = IsDataTypeDecimal<ToDataType> && !to_datetime64;\n\n    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionConvertFromString>(); }\n\n    String getName() const override\n    {\n        return name;\n    }\n\n    bool isVariadic() const override { return true; }\n    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n    size_t getNumberOfArguments() const override { return 0; }\n\n    bool useDefaultImplementationForConstants() const override { return true; }\n    bool canBeExecutedOnDefaultArguments() const override { return false; }\n\n    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1}; }\n\n    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n    {\n        DataTypePtr res;\n\n        if (isDateTime64<Name, ToDataType>(arguments))\n        {\n            validateFunctionArguments(*this, arguments,\n                FunctionArgumentDescriptors{{\"string\", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isStringOrFixedString), nullptr, \"String or FixedString\"}},\n                // optional\n                FunctionArgumentDescriptors{\n                    {\"precision\", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isUInt8), isColumnConst, \"const UInt8\"},\n                    {\"timezone\", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isStringOrFixedString), isColumnConst, \"const String or FixedString\"},\n                });\n\n            UInt64 scale = to_datetime64 ? DataTypeDateTime64::default_scale : 0;\n            if (arguments.size() > 1)\n                scale = extractToDecimalScale(arguments[1]);\n            const auto timezone = extractTimeZoneNameFromFunctionArguments(arguments, 2, 0, false);\n\n            res = scale == 0 ? res = std::make_shared<DataTypeDateTime>(timezone) : std::make_shared<DataTypeDateTime64>(scale, timezone);\n        }\n        else\n        {\n            if ((arguments.size() != 1 && arguments.size() != 2) || (to_decimal && arguments.size() != 2))\n                throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n                    \"Number of arguments for function {} doesn't match: passed {}, should be 1 or 2. \"\n                    \"Second argument only make sense for DateTime (time zone, optional) and Decimal (scale).\",\n                    getName(), arguments.size());\n\n            if (!isStringOrFixedString(arguments[0].type))\n            {\n                if (this->getName().find(\"OrZero\") != std::string::npos ||\n                    this->getName().find(\"OrNull\") != std::string::npos)\n                    throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal type {} of first argument of function {}. \"\n                            \"Conversion functions with postfix 'OrZero' or 'OrNull' should take String argument\",\n                            arguments[0].type->getName(), getName());\n                else\n                    throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal type {} of first argument of function {}\",\n                            arguments[0].type->getName(), getName());\n            }\n\n            if (arguments.size() == 2)\n            {\n                if constexpr (std::is_same_v<ToDataType, DataTypeDateTime>)\n                {\n                    if (!isString(arguments[1].type))\n                        throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal type {} of 2nd argument of function {}\",\n                            arguments[1].type->getName(), getName());\n                }\n                else if constexpr (to_decimal)\n                {\n                    if (!isInteger(arguments[1].type))\n                        throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal type {} of 2nd argument of function {}\",\n                            arguments[1].type->getName(), getName());\n                    if (!arguments[1].column)\n                        throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Second argument for function {} must be constant\", getName());\n                }\n                else\n                {\n                    throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n                        \"Number of arguments for function {} doesn't match: passed {}, should be 1. \"\n                        \"Second argument makes sense only for DateTime and Decimal.\",\n                        getName(), arguments.size());\n                }\n            }\n\n            if constexpr (std::is_same_v<ToDataType, DataTypeDateTime>)\n                res = std::make_shared<DataTypeDateTime>(extractTimeZoneNameFromFunctionArguments(arguments, 1, 0, false));\n            else if constexpr (std::is_same_v<ToDataType, DataTypeDateTime64>)\n                throw Exception(ErrorCodes::LOGICAL_ERROR, \"MaterializedMySQL is a bug.\");\n            else if constexpr (to_decimal)\n            {\n                UInt64 scale = extractToDecimalScale(arguments[1]);\n                res = createDecimalMaxPrecision<typename ToDataType::FieldType>(scale);\n                if (!res)\n                    throw Exception(ErrorCodes::LOGICAL_ERROR, \"Something wrong with toDecimalNNOrZero() or toDecimalNNOrNull()\");\n            }\n            else\n                res = std::make_shared<ToDataType>();\n        }\n\n        if constexpr (exception_mode == ConvertFromStringExceptionMode::Null)\n            res = std::make_shared<DataTypeNullable>(res);\n\n        return res;\n    }\n\n    template <typename ConvertToDataType>\n    ColumnPtr executeInternal(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count, UInt32 scale) const\n    {\n        const IDataType * from_type = arguments[0].type.get();\n\n        if (checkAndGetDataType<DataTypeString>(from_type))\n        {\n            return ConvertThroughParsing<DataTypeString, ConvertToDataType, Name, exception_mode, parsing_mode>::execute(\n                arguments, result_type, input_rows_count, scale);\n        }\n        else if (checkAndGetDataType<DataTypeFixedString>(from_type))\n        {\n            return ConvertThroughParsing<DataTypeFixedString, ConvertToDataType, Name, exception_mode, parsing_mode>::execute(\n                arguments, result_type, input_rows_count, scale);\n        }\n\n        return nullptr;\n    }\n\n    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override\n    {\n        ColumnPtr result_column;\n\n        if constexpr (to_decimal)\n        {\n            result_column = executeInternal<ToDataType>(arguments, result_type, input_rows_count,\n                assert_cast<const ToDataType &>(*removeNullable(result_type)).getScale());\n        }\n        else if constexpr (mightBeDateTime<Name, ToDataType>())\n        {\n            if (isDateTime64<Name, ToDataType>(arguments))\n            {\n                UInt64 scale = to_datetime64 ? DataTypeDateTime64::default_scale : 0;\n                if (arguments.size() > 1)\n                    scale = extractToDecimalScale(arguments[1]);\n\n                if (scale == 0)\n                {\n                    result_column = executeInternal<DataTypeDateTime>(arguments, result_type, input_rows_count, 0);\n                }\n                else\n                {\n                    result_column\n                        = executeInternal<DataTypeDateTime64>(arguments, result_type, input_rows_count, static_cast<UInt32>(scale));\n                }\n            }\n            else\n            {\n                result_column = executeInternal<ToDataType>(arguments, result_type, input_rows_count, 0);\n            }\n        }\n        else\n        {\n            result_column = executeInternal<ToDataType>(arguments, result_type, input_rows_count, 0);\n        }\n\n        if (!result_column)\n            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal type {} of argument of function {}. \"\n                \"Only String or FixedString argument is accepted for try-conversion function. For other arguments, \"\n                \"use function without 'orZero' or 'orNull'.\", arguments[0].type->getName(), getName());\n\n        return result_column;\n    }\n};\n\n\n/// Monotonicity.\n\nstruct PositiveMonotonicity\n{\n    static bool has() { return true; }\n    static IFunction::Monotonicity get(const IDataType &, const Field &, const Field &)\n    {\n        return { .is_monotonic = true };\n    }\n};\n\nstruct UnknownMonotonicity\n{\n    static bool has() { return false; }\n    static IFunction::Monotonicity get(const IDataType &, const Field &, const Field &)\n    {\n        return { };\n    }\n};\n\ntemplate <typename T>\nstruct ToNumberMonotonicity\n{\n    static bool has() { return true; }\n\n    static UInt64 divideByRangeOfType(UInt64 x)\n    {\n        if constexpr (sizeof(T) < sizeof(UInt64))\n            return x >> (sizeof(T) * 8);\n        else\n            return 0;\n    }\n\n    static IFunction::Monotonicity get(const IDataType & type, const Field & left, const Field & right)\n    {\n        if (!type.isValueRepresentedByNumber())\n            return {};\n\n        /// If type is same, the conversion is always monotonic.\n        /// (Enum has separate case, because it is different data type)\n        if (checkAndGetDataType<DataTypeNumber<T>>(&type) ||\n            checkAndGetDataType<DataTypeEnum<T>>(&type))\n            return { .is_monotonic = true, .is_always_monotonic = true };\n\n        /// Float cases.\n\n        /// When converting to Float, the conversion is always monotonic.\n        if constexpr (std::is_floating_point_v<T>)\n            return { .is_monotonic = true, .is_always_monotonic = true };\n\n        const auto * low_cardinality = typeid_cast<const DataTypeLowCardinality *>(&type);\n        const IDataType * low_cardinality_dictionary_type = nullptr;\n        if (low_cardinality)\n            low_cardinality_dictionary_type = low_cardinality->getDictionaryType().get();\n\n        WhichDataType which_type(type);\n        WhichDataType which_inner_type = low_cardinality\n            ? WhichDataType(low_cardinality_dictionary_type)\n            : WhichDataType(type);\n\n        /// If converting from Float, for monotonicity, arguments must fit in range of result type.\n        if (which_inner_type.isFloat())\n        {\n            if (left.isNull() || right.isNull())\n                return {};\n\n            Float64 left_float = left.safeGet<Float64>();\n            Float64 right_float = right.safeGet<Float64>();\n\n            if (left_float >= static_cast<Float64>(std::numeric_limits<T>::min())\n                && left_float <= static_cast<Float64>(std::numeric_limits<T>::max())\n                && right_float >= static_cast<Float64>(std::numeric_limits<T>::min())\n                && right_float <= static_cast<Float64>(std::numeric_limits<T>::max()))\n                return { .is_monotonic = true };\n\n            return {};\n        }\n\n        /// Integer cases.\n\n        /// Only support types represented by native integers.\n        /// It can be extended to big integers, decimals and DateTime64 later.\n        /// By the way, NULLs are representing unbounded ranges.\n        if (!((left.isNull() || left.getType() == Field::Types::UInt64 || left.getType() == Field::Types::Int64)\n            && (right.isNull() || right.getType() == Field::Types::UInt64 || right.getType() == Field::Types::Int64)))\n            return {};\n\n        const bool from_is_unsigned = type.isValueRepresentedByUnsignedInteger();\n        const bool to_is_unsigned = is_unsigned_v<T>;\n\n        const size_t size_of_from = type.getSizeOfValueInMemory();\n        const size_t size_of_to = sizeof(T);\n\n        const bool left_in_first_half = left.isNull()\n            ? from_is_unsigned\n            : (left.safeGet<Int64>() >= 0);\n\n        const bool right_in_first_half = right.isNull()\n            ? !from_is_unsigned\n            : (right.safeGet<Int64>() >= 0);\n\n        /// Size of type is the same.\n        if (size_of_from == size_of_to)\n        {\n            if (from_is_unsigned == to_is_unsigned)\n                return { .is_monotonic = true, .is_always_monotonic = true };\n\n            if (left_in_first_half == right_in_first_half)\n                return { .is_monotonic = true };\n\n            return {};\n        }\n\n        /// Size of type is expanded.\n        if (size_of_from < size_of_to)\n        {\n            if (from_is_unsigned == to_is_unsigned)\n                return { .is_monotonic = true, .is_always_monotonic = true };\n\n            if (!to_is_unsigned)\n                return { .is_monotonic = true, .is_always_monotonic = true };\n\n            /// signed -> unsigned. If arguments from the same half, then function is monotonic.\n            if (left_in_first_half == right_in_first_half)\n                return { .is_monotonic = true };\n\n            return {};\n        }\n\n        /// Size of type is shrunk.\n        if (size_of_from > size_of_to)\n        {\n            /// Function cannot be monotonic on unbounded ranges.\n            if (left.isNull() || right.isNull())\n                return {};\n\n            /// Function cannot be monotonic when left and right are not on the same ranges.\n            if (divideByRangeOfType(left.safeGet<UInt64>()) != divideByRangeOfType(right.safeGet<UInt64>()))\n                return {};\n\n            if (to_is_unsigned)\n                return { .is_monotonic = true };\n            else\n            {\n                // If To is signed, it's possible that the signedness is different after conversion. So we check it explicitly.\n                const bool is_monotonic = (T(left.safeGet<UInt64>()) >= 0) == (T(right.safeGet<UInt64>()) >= 0);\n\n                return { .is_monotonic = is_monotonic };\n            }\n        }\n\n        UNREACHABLE();\n    }\n};\n\nstruct ToDateMonotonicity\n{\n    static bool has() { return true; }\n\n    static IFunction::Monotonicity get(const IDataType & type, const Field & left, const Field & right)\n    {\n        auto which = WhichDataType(type);\n        if (which.isDateOrDate32() || which.isDateTime() || which.isDateTime64() || which.isInt8() || which.isInt16() || which.isUInt8()\n            || which.isUInt16())\n        {\n            return {.is_monotonic = true, .is_always_monotonic = true};\n        }\n        else if (\n            ((left.getType() == Field::Types::UInt64 || left.isNull()) && (right.getType() == Field::Types::UInt64 || right.isNull())\n             && ((left.isNull() || left.safeGet<UInt64>() < 0xFFFF) && (right.isNull() || right.safeGet<UInt64>() >= 0xFFFF)))\n            || ((left.getType() == Field::Types::Int64 || left.isNull()) && (right.getType() == Field::Types::Int64 || right.isNull())\n                && ((left.isNull() || left.safeGet<Int64>() < 0xFFFF) && (right.isNull() || right.safeGet<Int64>() >= 0xFFFF)))\n            || ((\n                (left.getType() == Field::Types::Float64 || left.isNull())\n                && (right.getType() == Field::Types::Float64 || right.isNull())\n                && ((left.isNull() || left.safeGet<Float64>() < 0xFFFF) && (right.isNull() || right.safeGet<Float64>() >= 0xFFFF))))\n            || !isNativeNumber(type))\n        {\n            return {};\n        }\n        else\n        {\n            return {.is_monotonic = true, .is_always_monotonic = true};\n        }\n    }\n};\n\nstruct ToDateTimeMonotonicity\n{\n    static bool has() { return true; }\n\n    static IFunction::Monotonicity get(const IDataType & type, const Field &, const Field &)\n    {\n        if (type.isValueRepresentedByNumber())\n            return {.is_monotonic = true, .is_always_monotonic = true};\n        else\n            return {};\n    }\n};\n\n/** The monotonicity for the `toString` function is mainly determined for test purposes.\n  * It is doubtful that anyone is looking to optimize queries with conditions `toString(CounterID) = 34`.\n  */\nstruct ToStringMonotonicity\n{\n    static bool has() { return true; }\n\n    static IFunction::Monotonicity get(const IDataType & type, const Field & left, const Field & right)\n    {\n        IFunction::Monotonicity positive{ .is_monotonic = true };\n        IFunction::Monotonicity not_monotonic;\n\n        const auto * type_ptr = &type;\n        if (const auto * low_cardinality_type = checkAndGetDataType<DataTypeLowCardinality>(type_ptr))\n            type_ptr = low_cardinality_type->getDictionaryType().get();\n\n        /// Order on enum values (which is the order on integers) is completely arbitrary in respect to the order on strings.\n        if (WhichDataType(type).isEnum())\n            return not_monotonic;\n\n        /// `toString` function is monotonous if the argument is Date or Date32 or DateTime or String, or non-negative numbers with the same number of symbols.\n        if (checkDataTypes<DataTypeDate, DataTypeDate32, DataTypeDateTime, DataTypeString>(type_ptr))\n            return positive;\n\n        if (left.isNull() || right.isNull())\n            return {};\n\n        if (left.getType() == Field::Types::UInt64\n            && right.getType() == Field::Types::UInt64)\n        {\n            return (left.safeGet<Int64>() == 0 && right.safeGet<Int64>() == 0)\n                || (floor(log10(left.safeGet<UInt64>())) == floor(log10(right.safeGet<UInt64>())))\n                ? positive : not_monotonic;\n        }\n\n        if (left.getType() == Field::Types::Int64\n            && right.getType() == Field::Types::Int64)\n        {\n            return (left.safeGet<Int64>() == 0 && right.safeGet<Int64>() == 0)\n                || (left.safeGet<Int64>() > 0 && right.safeGet<Int64>() > 0 && floor(log10(left.safeGet<Int64>())) == floor(log10(right.safeGet<Int64>())))\n                ? positive : not_monotonic;\n        }\n\n        return not_monotonic;\n    }\n};\n\n\nstruct NameToUInt8 { static constexpr auto name = \"toUInt8\"; };\nstruct NameToUInt16 { static constexpr auto name = \"toUInt16\"; };\nstruct NameToUInt32 { static constexpr auto name = \"toUInt32\"; };\nstruct NameToUInt64 { static constexpr auto name = \"toUInt64\"; };\nstruct NameToUInt128 { static constexpr auto name = \"toUInt128\"; };\nstruct NameToUInt256 { static constexpr auto name = \"toUInt256\"; };\nstruct NameToInt8 { static constexpr auto name = \"toInt8\"; };\nstruct NameToInt16 { static constexpr auto name = \"toInt16\"; };\nstruct NameToInt32 { static constexpr auto name = \"toInt32\"; };\nstruct NameToInt64 { static constexpr auto name = \"toInt64\"; };\nstruct NameToInt128 { static constexpr auto name = \"toInt128\"; };\nstruct NameToInt256 { static constexpr auto name = \"toInt256\"; };\nstruct NameToFloat32 { static constexpr auto name = \"toFloat32\"; };\nstruct NameToFloat64 { static constexpr auto name = \"toFloat64\"; };\nstruct NameToUUID { static constexpr auto name = \"toUUID\"; };\nstruct NameToIPv4 { static constexpr auto name = \"toIPv4\"; };\nstruct NameToIPv6 { static constexpr auto name = \"toIPv6\"; };\n\nusing FunctionToUInt8 = FunctionConvert<DataTypeUInt8, NameToUInt8, ToNumberMonotonicity<UInt8>>;\nusing FunctionToUInt16 = FunctionConvert<DataTypeUInt16, NameToUInt16, ToNumberMonotonicity<UInt16>>;\nusing FunctionToUInt32 = FunctionConvert<DataTypeUInt32, NameToUInt32, ToNumberMonotonicity<UInt32>>;\nusing FunctionToUInt64 = FunctionConvert<DataTypeUInt64, NameToUInt64, ToNumberMonotonicity<UInt64>>;\nusing FunctionToUInt128 = FunctionConvert<DataTypeUInt128, NameToUInt128, ToNumberMonotonicity<UInt128>>;\nusing FunctionToUInt256 = FunctionConvert<DataTypeUInt256, NameToUInt256, ToNumberMonotonicity<UInt256>>;\nusing FunctionToInt8 = FunctionConvert<DataTypeInt8, NameToInt8, ToNumberMonotonicity<Int8>>;\nusing FunctionToInt16 = FunctionConvert<DataTypeInt16, NameToInt16, ToNumberMonotonicity<Int16>>;\nusing FunctionToInt32 = FunctionConvert<DataTypeInt32, NameToInt32, ToNumberMonotonicity<Int32>>;\nusing FunctionToInt64 = FunctionConvert<DataTypeInt64, NameToInt64, ToNumberMonotonicity<Int64>>;\nusing FunctionToInt128 = FunctionConvert<DataTypeInt128, NameToInt128, ToNumberMonotonicity<Int128>>;\nusing FunctionToInt256 = FunctionConvert<DataTypeInt256, NameToInt256, ToNumberMonotonicity<Int256>>;\nusing FunctionToFloat32 = FunctionConvert<DataTypeFloat32, NameToFloat32, ToNumberMonotonicity<Float32>>;\nusing FunctionToFloat64 = FunctionConvert<DataTypeFloat64, NameToFloat64, ToNumberMonotonicity<Float64>>;\n\nusing FunctionToDate = FunctionConvert<DataTypeDate, NameToDate, ToDateMonotonicity>;\n\nusing FunctionToDate32 = FunctionConvert<DataTypeDate32, NameToDate32, ToDateMonotonicity>;\n\nusing FunctionToDateTime = FunctionConvert<DataTypeDateTime, NameToDateTime, ToDateTimeMonotonicity>;\n\nusing FunctionToDateTime32 = FunctionConvert<DataTypeDateTime, NameToDateTime32, ToDateTimeMonotonicity>;\n\nusing FunctionToDateTime64 = FunctionConvert<DataTypeDateTime64, NameToDateTime64, ToDateTimeMonotonicity>;\n\nusing FunctionToUUID = FunctionConvert<DataTypeUUID, NameToUUID, ToNumberMonotonicity<UInt128>>;\nusing FunctionToIPv4 = FunctionConvert<DataTypeIPv4, NameToIPv4, ToNumberMonotonicity<UInt32>>;\nusing FunctionToIPv6 = FunctionConvert<DataTypeIPv6, NameToIPv6, ToNumberMonotonicity<UInt128>>;\nusing FunctionToString = FunctionConvert<DataTypeString, NameToString, ToStringMonotonicity>;\nusing FunctionToUnixTimestamp = FunctionConvert<DataTypeUInt32, NameToUnixTimestamp, ToNumberMonotonicity<UInt32>>;\nusing FunctionToUnixTimestampEx = FunctionConvert<DataTypeInt64, NameToUnixTimestampEx, ToNumberMonotonicity<Int64>>;\nusing FunctionToDecimal32 = FunctionConvert<DataTypeDecimal<Decimal32>, NameToDecimal32, UnknownMonotonicity>;\nusing FunctionToDecimal64 = FunctionConvert<DataTypeDecimal<Decimal64>, NameToDecimal64, UnknownMonotonicity>;\nusing FunctionToDecimal128 = FunctionConvert<DataTypeDecimal<Decimal128>, NameToDecimal128, UnknownMonotonicity>;\nusing FunctionToDecimal256 = FunctionConvert<DataTypeDecimal<Decimal256>, NameToDecimal256, UnknownMonotonicity>;\n\ntemplate <typename DataType, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior = default_date_time_overflow_behavior> struct FunctionTo;\n\ntemplate <> struct FunctionTo<DataTypeUInt8> { using Type = FunctionToUInt8; };\ntemplate <> struct FunctionTo<DataTypeUInt16> { using Type = FunctionToUInt16; };\ntemplate <> struct FunctionTo<DataTypeUInt32> { using Type = FunctionToUInt32; };\ntemplate <> struct FunctionTo<DataTypeUInt64> { using Type = FunctionToUInt64; };\ntemplate <> struct FunctionTo<DataTypeUInt128> { using Type = FunctionToUInt128; };\ntemplate <> struct FunctionTo<DataTypeUInt256> { using Type = FunctionToUInt256; };\ntemplate <> struct FunctionTo<DataTypeInt8> { using Type = FunctionToInt8; };\ntemplate <> struct FunctionTo<DataTypeInt16> { using Type = FunctionToInt16; };\ntemplate <> struct FunctionTo<DataTypeInt32> { using Type = FunctionToInt32; };\ntemplate <> struct FunctionTo<DataTypeInt64> { using Type = FunctionToInt64; };\ntemplate <> struct FunctionTo<DataTypeInt128> { using Type = FunctionToInt128; };\ntemplate <> struct FunctionTo<DataTypeInt256> { using Type = FunctionToInt256; };\ntemplate <> struct FunctionTo<DataTypeFloat32> { using Type = FunctionToFloat32; };\ntemplate <> struct FunctionTo<DataTypeFloat64> { using Type = FunctionToFloat64; };\n\ntemplate <FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\nstruct FunctionTo<DataTypeDate, date_time_overflow_behavior> { using Type = FunctionToDate; };\n\ntemplate <FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\nstruct FunctionTo<DataTypeDate32, date_time_overflow_behavior> { using Type = FunctionToDate32; };\n\ntemplate <FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\nstruct FunctionTo<DataTypeDateTime, date_time_overflow_behavior> { using Type = FunctionToDateTime; };\n\ntemplate <FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\nstruct FunctionTo<DataTypeDateTime64, date_time_overflow_behavior> { using Type = FunctionToDateTime64; };\n\ntemplate <> struct FunctionTo<DataTypeUUID> { using Type = FunctionToUUID; };\ntemplate <> struct FunctionTo<DataTypeIPv4> { using Type = FunctionToIPv4; };\ntemplate <> struct FunctionTo<DataTypeIPv6> { using Type = FunctionToIPv6; };\ntemplate <> struct FunctionTo<DataTypeString> { using Type = FunctionToString; };\ntemplate <> struct FunctionTo<DataTypeFixedString> { using Type = FunctionToFixedString; };\ntemplate <> struct FunctionTo<DataTypeDecimal<Decimal32>> { using Type = FunctionToDecimal32; };\ntemplate <> struct FunctionTo<DataTypeDecimal<Decimal64>> { using Type = FunctionToDecimal64; };\ntemplate <> struct FunctionTo<DataTypeDecimal<Decimal128>> { using Type = FunctionToDecimal128; };\ntemplate <> struct FunctionTo<DataTypeDecimal<Decimal256>> { using Type = FunctionToDecimal256; };\n\ntemplate <typename FieldType> struct FunctionTo<DataTypeEnum<FieldType>>\n    : FunctionTo<DataTypeNumber<FieldType>>\n{\n};\n\nstruct NameToUInt8OrZero { static constexpr auto name = \"toUInt8OrZero\"; };\nstruct NameToUInt16OrZero { static constexpr auto name = \"toUInt16OrZero\"; };\nstruct NameToUInt32OrZero { static constexpr auto name = \"toUInt32OrZero\"; };\nstruct NameToUInt64OrZero { static constexpr auto name = \"toUInt64OrZero\"; };\nstruct NameToUInt128OrZero { static constexpr auto name = \"toUInt128OrZero\"; };\nstruct NameToUInt256OrZero { static constexpr auto name = \"toUInt256OrZero\"; };\nstruct NameToInt8OrZero { static constexpr auto name = \"toInt8OrZero\"; };\nstruct NameToInt16OrZero { static constexpr auto name = \"toInt16OrZero\"; };\nstruct NameToInt32OrZero { static constexpr auto name = \"toInt32OrZero\"; };\nstruct NameToInt64OrZero { static constexpr auto name = \"toInt64OrZero\"; };\nstruct NameToInt128OrZero { static constexpr auto name = \"toInt128OrZero\"; };\nstruct NameToInt256OrZero { static constexpr auto name = \"toInt256OrZero\"; };\nstruct NameToFloat32OrZero { static constexpr auto name = \"toFloat32OrZero\"; };\nstruct NameToFloat64OrZero { static constexpr auto name = \"toFloat64OrZero\"; };\nstruct NameToDateOrZero { static constexpr auto name = \"toDateOrZero\"; };\nstruct NameToDate32OrZero { static constexpr auto name = \"toDate32OrZero\"; };\nstruct NameToDateTimeOrZero { static constexpr auto name = \"toDateTimeOrZero\"; };\nstruct NameToDateTime64OrZero { static constexpr auto name = \"toDateTime64OrZero\"; };\nstruct NameToDecimal32OrZero { static constexpr auto name = \"toDecimal32OrZero\"; };\nstruct NameToDecimal64OrZero { static constexpr auto name = \"toDecimal64OrZero\"; };\nstruct NameToDecimal128OrZero { static constexpr auto name = \"toDecimal128OrZero\"; };\nstruct NameToDecimal256OrZero { static constexpr auto name = \"toDecimal256OrZero\"; };\nstruct NameToUUIDOrZero { static constexpr auto name = \"toUUIDOrZero\"; };\nstruct NameToIPv4OrZero { static constexpr auto name = \"toIPv4OrZero\"; };\nstruct NameToIPv6OrZero { static constexpr auto name = \"toIPv6OrZero\"; };\n\nusing FunctionToUInt8OrZero = FunctionConvertFromString<DataTypeUInt8, NameToUInt8OrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToUInt16OrZero = FunctionConvertFromString<DataTypeUInt16, NameToUInt16OrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToUInt32OrZero = FunctionConvertFromString<DataTypeUInt32, NameToUInt32OrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToUInt64OrZero = FunctionConvertFromString<DataTypeUInt64, NameToUInt64OrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToUInt128OrZero = FunctionConvertFromString<DataTypeUInt128, NameToUInt128OrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToUInt256OrZero = FunctionConvertFromString<DataTypeUInt256, NameToUInt256OrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToInt8OrZero = FunctionConvertFromString<DataTypeInt8, NameToInt8OrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToInt16OrZero = FunctionConvertFromString<DataTypeInt16, NameToInt16OrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToInt32OrZero = FunctionConvertFromString<DataTypeInt32, NameToInt32OrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToInt64OrZero = FunctionConvertFromString<DataTypeInt64, NameToInt64OrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToInt128OrZero = FunctionConvertFromString<DataTypeInt128, NameToInt128OrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToInt256OrZero = FunctionConvertFromString<DataTypeInt256, NameToInt256OrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToFloat32OrZero = FunctionConvertFromString<DataTypeFloat32, NameToFloat32OrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToFloat64OrZero = FunctionConvertFromString<DataTypeFloat64, NameToFloat64OrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToDateOrZero = FunctionConvertFromString<DataTypeDate, NameToDateOrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToDate32OrZero = FunctionConvertFromString<DataTypeDate32, NameToDate32OrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToDateTimeOrZero = FunctionConvertFromString<DataTypeDateTime, NameToDateTimeOrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToDateTime64OrZero = FunctionConvertFromString<DataTypeDateTime64, NameToDateTime64OrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToDecimal32OrZero = FunctionConvertFromString<DataTypeDecimal<Decimal32>, NameToDecimal32OrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToDecimal64OrZero = FunctionConvertFromString<DataTypeDecimal<Decimal64>, NameToDecimal64OrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToDecimal128OrZero = FunctionConvertFromString<DataTypeDecimal<Decimal128>, NameToDecimal128OrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToDecimal256OrZero = FunctionConvertFromString<DataTypeDecimal<Decimal256>, NameToDecimal256OrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToUUIDOrZero = FunctionConvertFromString<DataTypeUUID, NameToUUIDOrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToIPv4OrZero = FunctionConvertFromString<DataTypeIPv4, NameToIPv4OrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToIPv6OrZero = FunctionConvertFromString<DataTypeIPv6, NameToIPv6OrZero, ConvertFromStringExceptionMode::Zero>;\n\nstruct NameToUInt8OrNull { static constexpr auto name = \"toUInt8OrNull\"; };\nstruct NameToUInt16OrNull { static constexpr auto name = \"toUInt16OrNull\"; };\nstruct NameToUInt32OrNull { static constexpr auto name = \"toUInt32OrNull\"; };\nstruct NameToUInt64OrNull { static constexpr auto name = \"toUInt64OrNull\"; };\nstruct NameToUInt128OrNull { static constexpr auto name = \"toUInt128OrNull\"; };\nstruct NameToUInt256OrNull { static constexpr auto name = \"toUInt256OrNull\"; };\nstruct NameToInt8OrNull { static constexpr auto name = \"toInt8OrNull\"; };\nstruct NameToInt16OrNull { static constexpr auto name = \"toInt16OrNull\"; };\nstruct NameToInt32OrNull { static constexpr auto name = \"toInt32OrNull\"; };\nstruct NameToInt64OrNull { static constexpr auto name = \"toInt64OrNull\"; };\nstruct NameToInt128OrNull { static constexpr auto name = \"toInt128OrNull\"; };\nstruct NameToInt256OrNull { static constexpr auto name = \"toInt256OrNull\"; };\nstruct NameToFloat32OrNull { static constexpr auto name = \"toFloat32OrNull\"; };\nstruct NameToFloat64OrNull { static constexpr auto name = \"toFloat64OrNull\"; };\nstruct NameToDateOrNull { static constexpr auto name = \"toDateOrNull\"; };\nstruct NameToDate32OrNull { static constexpr auto name = \"toDate32OrNull\"; };\nstruct NameToDateTimeOrNull { static constexpr auto name = \"toDateTimeOrNull\"; };\nstruct NameToDateTime64OrNull { static constexpr auto name = \"toDateTime64OrNull\"; };\nstruct NameToDecimal32OrNull { static constexpr auto name = \"toDecimal32OrNull\"; };\nstruct NameToDecimal64OrNull { static constexpr auto name = \"toDecimal64OrNull\"; };\nstruct NameToDecimal128OrNull { static constexpr auto name = \"toDecimal128OrNull\"; };\nstruct NameToDecimal256OrNull { static constexpr auto name = \"toDecimal256OrNull\"; };\nstruct NameToUUIDOrNull { static constexpr auto name = \"toUUIDOrNull\"; };\nstruct NameToIPv4OrNull { static constexpr auto name = \"toIPv4OrNull\"; };\nstruct NameToIPv6OrNull { static constexpr auto name = \"toIPv6OrNull\"; };\n\nusing FunctionToUInt8OrNull = FunctionConvertFromString<DataTypeUInt8, NameToUInt8OrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToUInt16OrNull = FunctionConvertFromString<DataTypeUInt16, NameToUInt16OrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToUInt32OrNull = FunctionConvertFromString<DataTypeUInt32, NameToUInt32OrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToUInt64OrNull = FunctionConvertFromString<DataTypeUInt64, NameToUInt64OrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToUInt128OrNull = FunctionConvertFromString<DataTypeUInt128, NameToUInt128OrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToUInt256OrNull = FunctionConvertFromString<DataTypeUInt256, NameToUInt256OrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToInt8OrNull = FunctionConvertFromString<DataTypeInt8, NameToInt8OrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToInt16OrNull = FunctionConvertFromString<DataTypeInt16, NameToInt16OrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToInt32OrNull = FunctionConvertFromString<DataTypeInt32, NameToInt32OrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToInt64OrNull = FunctionConvertFromString<DataTypeInt64, NameToInt64OrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToInt128OrNull = FunctionConvertFromString<DataTypeInt128, NameToInt128OrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToInt256OrNull = FunctionConvertFromString<DataTypeInt256, NameToInt256OrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToFloat32OrNull = FunctionConvertFromString<DataTypeFloat32, NameToFloat32OrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToFloat64OrNull = FunctionConvertFromString<DataTypeFloat64, NameToFloat64OrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToDateOrNull = FunctionConvertFromString<DataTypeDate, NameToDateOrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToDate32OrNull = FunctionConvertFromString<DataTypeDate32, NameToDate32OrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToDateTimeOrNull = FunctionConvertFromString<DataTypeDateTime, NameToDateTimeOrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToDateTime64OrNull = FunctionConvertFromString<DataTypeDateTime64, NameToDateTime64OrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToDecimal32OrNull = FunctionConvertFromString<DataTypeDecimal<Decimal32>, NameToDecimal32OrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToDecimal64OrNull = FunctionConvertFromString<DataTypeDecimal<Decimal64>, NameToDecimal64OrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToDecimal128OrNull = FunctionConvertFromString<DataTypeDecimal<Decimal128>, NameToDecimal128OrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToDecimal256OrNull = FunctionConvertFromString<DataTypeDecimal<Decimal256>, NameToDecimal256OrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToUUIDOrNull = FunctionConvertFromString<DataTypeUUID, NameToUUIDOrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToIPv4OrNull = FunctionConvertFromString<DataTypeIPv4, NameToIPv4OrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToIPv6OrNull = FunctionConvertFromString<DataTypeIPv6, NameToIPv6OrNull, ConvertFromStringExceptionMode::Null>;\n\nstruct NameParseDateTimeBestEffort { static constexpr auto name = \"parseDateTimeBestEffort\"; };\nstruct NameParseDateTimeBestEffortOrZero { static constexpr auto name = \"parseDateTimeBestEffortOrZero\"; };\nstruct NameParseDateTimeBestEffortOrNull { static constexpr auto name = \"parseDateTimeBestEffortOrNull\"; };\nstruct NameParseDateTimeBestEffortUS { static constexpr auto name = \"parseDateTimeBestEffortUS\"; };\nstruct NameParseDateTimeBestEffortUSOrZero { static constexpr auto name = \"parseDateTimeBestEffortUSOrZero\"; };\nstruct NameParseDateTimeBestEffortUSOrNull { static constexpr auto name = \"parseDateTimeBestEffortUSOrNull\"; };\nstruct NameParseDateTime32BestEffort { static constexpr auto name = \"parseDateTime32BestEffort\"; };\nstruct NameParseDateTime32BestEffortOrZero { static constexpr auto name = \"parseDateTime32BestEffortOrZero\"; };\nstruct NameParseDateTime32BestEffortOrNull { static constexpr auto name = \"parseDateTime32BestEffortOrNull\"; };\nstruct NameParseDateTime64BestEffort { static constexpr auto name = \"parseDateTime64BestEffort\"; };\nstruct NameParseDateTime64BestEffortOrZero { static constexpr auto name = \"parseDateTime64BestEffortOrZero\"; };\nstruct NameParseDateTime64BestEffortOrNull { static constexpr auto name = \"parseDateTime64BestEffortOrNull\"; };\nstruct NameParseDateTime64BestEffortUS { static constexpr auto name = \"parseDateTime64BestEffortUS\"; };\nstruct NameParseDateTime64BestEffortUSOrZero { static constexpr auto name = \"parseDateTime64BestEffortUSOrZero\"; };\nstruct NameParseDateTime64BestEffortUSOrNull { static constexpr auto name = \"parseDateTime64BestEffortUSOrNull\"; };\n\n\nusing FunctionParseDateTimeBestEffort = FunctionConvertFromString<\n    DataTypeDateTime, NameParseDateTimeBestEffort, ConvertFromStringExceptionMode::Throw, ConvertFromStringParsingMode::BestEffort>;\nusing FunctionParseDateTimeBestEffortOrZero = FunctionConvertFromString<\n    DataTypeDateTime, NameParseDateTimeBestEffortOrZero, ConvertFromStringExceptionMode::Zero, ConvertFromStringParsingMode::BestEffort>;\nusing FunctionParseDateTimeBestEffortOrNull = FunctionConvertFromString<\n    DataTypeDateTime, NameParseDateTimeBestEffortOrNull, ConvertFromStringExceptionMode::Null, ConvertFromStringParsingMode::BestEffort>;\n\nusing FunctionParseDateTimeBestEffortUS = FunctionConvertFromString<\n    DataTypeDateTime, NameParseDateTimeBestEffortUS, ConvertFromStringExceptionMode::Throw, ConvertFromStringParsingMode::BestEffortUS>;\nusing FunctionParseDateTimeBestEffortUSOrZero = FunctionConvertFromString<\n    DataTypeDateTime, NameParseDateTimeBestEffortUSOrZero, ConvertFromStringExceptionMode::Zero, ConvertFromStringParsingMode::BestEffortUS>;\nusing FunctionParseDateTimeBestEffortUSOrNull = FunctionConvertFromString<\n    DataTypeDateTime, NameParseDateTimeBestEffortUSOrNull, ConvertFromStringExceptionMode::Null, ConvertFromStringParsingMode::BestEffortUS>;\n\nusing FunctionParseDateTime32BestEffort = FunctionConvertFromString<\n    DataTypeDateTime, NameParseDateTime32BestEffort, ConvertFromStringExceptionMode::Throw, ConvertFromStringParsingMode::BestEffort>;\nusing FunctionParseDateTime32BestEffortOrZero = FunctionConvertFromString<\n    DataTypeDateTime, NameParseDateTime32BestEffortOrZero, ConvertFromStringExceptionMode::Zero, ConvertFromStringParsingMode::BestEffort>;\nusing FunctionParseDateTime32BestEffortOrNull = FunctionConvertFromString<\n    DataTypeDateTime, NameParseDateTime32BestEffortOrNull, ConvertFromStringExceptionMode::Null, ConvertFromStringParsingMode::BestEffort>;\n\nusing FunctionParseDateTime64BestEffort = FunctionConvertFromString<\n    DataTypeDateTime64, NameParseDateTime64BestEffort, ConvertFromStringExceptionMode::Throw, ConvertFromStringParsingMode::BestEffort>;\nusing FunctionParseDateTime64BestEffortOrZero = FunctionConvertFromString<\n    DataTypeDateTime64, NameParseDateTime64BestEffortOrZero, ConvertFromStringExceptionMode::Zero, ConvertFromStringParsingMode::BestEffort>;\nusing FunctionParseDateTime64BestEffortOrNull = FunctionConvertFromString<\n    DataTypeDateTime64, NameParseDateTime64BestEffortOrNull, ConvertFromStringExceptionMode::Null, ConvertFromStringParsingMode::BestEffort>;\n\nusing FunctionParseDateTime64BestEffortUS = FunctionConvertFromString<\n    DataTypeDateTime64, NameParseDateTime64BestEffortUS, ConvertFromStringExceptionMode::Throw, ConvertFromStringParsingMode::BestEffortUS>;\nusing FunctionParseDateTime64BestEffortUSOrZero = FunctionConvertFromString<\n    DataTypeDateTime64, NameParseDateTime64BestEffortUSOrZero, ConvertFromStringExceptionMode::Zero, ConvertFromStringParsingMode::BestEffortUS>;\nusing FunctionParseDateTime64BestEffortUSOrNull = FunctionConvertFromString<\n    DataTypeDateTime64, NameParseDateTime64BestEffortUSOrNull, ConvertFromStringExceptionMode::Null, ConvertFromStringParsingMode::BestEffortUS>;\n\n\nclass ExecutableFunctionCast : public IExecutableFunction\n{\npublic:\n    using WrapperType = std::function<ColumnPtr(ColumnsWithTypeAndName &, const DataTypePtr &, const ColumnNullable *, size_t)>;\n\n    explicit ExecutableFunctionCast(\n            WrapperType && wrapper_function_, const char * name_, std::optional<CastDiagnostic> diagnostic_)\n            : wrapper_function(std::move(wrapper_function_)), name(name_), diagnostic(std::move(diagnostic_)) {}\n\n    String getName() const override { return name; }\n\nprotected:\n    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override\n    {\n        /// drop second argument, pass others\n        ColumnsWithTypeAndName new_arguments{arguments.front()};\n        if (arguments.size() > 2)\n            new_arguments.insert(std::end(new_arguments), std::next(std::begin(arguments), 2), std::end(arguments));\n\n        try\n        {\n            return wrapper_function(new_arguments, result_type, nullptr, input_rows_count);\n        }\n        catch (Exception & e)\n        {\n            if (diagnostic)\n                e.addMessage(\"while converting source column \" + backQuoteIfNeed(diagnostic->column_from) +\n                             \" to destination column \" + backQuoteIfNeed(diagnostic->column_to));\n            throw;\n        }\n    }\n\n    bool useDefaultImplementationForNulls() const override { return false; }\n    /// CAST(Nothing, T) -> T\n    bool useDefaultImplementationForNothing() const override { return false; }\n    bool useDefaultImplementationForConstants() const override { return true; }\n    bool useDefaultImplementationForLowCardinalityColumns() const override { return false; }\n    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1}; }\n\nprivate:\n    WrapperType wrapper_function;\n    const char * name;\n    std::optional<CastDiagnostic> diagnostic;\n};\n\n\nstruct FunctionCastName\n{\n    static constexpr auto name = \"CAST\";\n};\n\nclass FunctionCast final : public IFunctionBase\n{\npublic:\n    using MonotonicityForRange = std::function<Monotonicity(const IDataType &, const Field &, const Field &)>;\n    using WrapperType = std::function<ColumnPtr(ColumnsWithTypeAndName &, const DataTypePtr &, const ColumnNullable *, size_t)>;\n\n    FunctionCast(ContextPtr context_\n            , const char * cast_name_\n            , MonotonicityForRange && monotonicity_for_range_\n            , const DataTypes & argument_types_\n            , const DataTypePtr & return_type_\n            , std::optional<CastDiagnostic> diagnostic_\n            , CastType cast_type_)\n        : cast_name(cast_name_), monotonicity_for_range(std::move(monotonicity_for_range_))\n        , argument_types(argument_types_), return_type(return_type_), diagnostic(std::move(diagnostic_))\n        , cast_type(cast_type_)\n        , context(context_)\n    {\n    }\n\n    const DataTypes & getArgumentTypes() const override { return argument_types; }\n    const DataTypePtr & getResultType() const override { return return_type; }\n\n    ExecutableFunctionPtr prepare(const ColumnsWithTypeAndName & /*sample_columns*/) const override\n    {\n        try\n        {\n            return std::make_unique<ExecutableFunctionCast>(\n                prepareUnpackDictionaries(getArgumentTypes()[0], getResultType()), cast_name, diagnostic);\n        }\n        catch (Exception & e)\n        {\n            if (diagnostic)\n                e.addMessage(\"while converting source column \" + backQuoteIfNeed(diagnostic->column_from) +\n                             \" to destination column \" + backQuoteIfNeed(diagnostic->column_to));\n            throw;\n        }\n    }\n\n    String getName() const override { return cast_name; }\n\n    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n\n    bool hasInformationAboutMonotonicity() const override\n    {\n        return static_cast<bool>(monotonicity_for_range);\n    }\n\n    Monotonicity getMonotonicityForRange(const IDataType & type, const Field & left, const Field & right) const override\n    {\n        return monotonicity_for_range(type, left, right);\n    }\n\nprivate:\n    const char * cast_name;\n    MonotonicityForRange monotonicity_for_range;\n\n    DataTypes argument_types;\n    DataTypePtr return_type;\n\n    std::optional<CastDiagnostic> diagnostic;\n    CastType cast_type;\n    ContextPtr context;\n\n    static WrapperType createFunctionAdaptor(FunctionPtr function, const DataTypePtr & from_type)\n    {\n        auto function_adaptor = std::make_unique<FunctionToOverloadResolverAdaptor>(function)->build({ColumnWithTypeAndName{nullptr, from_type, \"\"}});\n\n        return [function_adaptor]\n            (ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable *, size_t input_rows_count)\n        {\n            return function_adaptor->execute(arguments, result_type, input_rows_count);\n        };\n    }\n\n    static WrapperType createToNullableColumnWrapper()\n    {\n        return [] (ColumnsWithTypeAndName &, const DataTypePtr & result_type, const ColumnNullable *, size_t input_rows_count)\n        {\n            ColumnPtr res = result_type->createColumn();\n            ColumnUInt8::Ptr col_null_map_to = ColumnUInt8::create(input_rows_count, true);\n            return ColumnNullable::create(res->cloneResized(input_rows_count), std::move(col_null_map_to));\n        };\n    }\n\n    template <typename ToDataType>\n    WrapperType createWrapper(const DataTypePtr & from_type, const ToDataType * const to_type, bool requested_result_is_nullable) const\n    {\n        TypeIndex from_type_index = from_type->getTypeId();\n        WhichDataType which(from_type_index);\n        TypeIndex to_type_index = to_type->getTypeId();\n        WhichDataType to(to_type_index);\n        bool can_apply_accurate_cast = (cast_type == CastType::accurate || cast_type == CastType::accurateOrNull)\n            && (which.isInt() || which.isUInt() || which.isFloat());\n        can_apply_accurate_cast |= cast_type == CastType::accurate && which.isStringOrFixedString() && to.isNativeInteger();\n\n        FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior = default_date_time_overflow_behavior;\n        if (context)\n            date_time_overflow_behavior = context->getSettingsRef()[Setting::date_time_overflow_behavior];\n\n        if (requested_result_is_nullable && checkAndGetDataType<DataTypeString>(from_type.get()))\n        {\n            /// In case when converting to Nullable type, we apply different parsing rule,\n            /// that will not throw an exception but return NULL in case of malformed input.\n            FunctionPtr function = FunctionConvertFromString<ToDataType, FunctionCastName, ConvertFromStringExceptionMode::Null>::create(context);\n            return createFunctionAdaptor(function, from_type);\n        }\n        else if (!can_apply_accurate_cast)\n        {\n            FunctionPtr function = FunctionTo<ToDataType>::Type::create(context);\n            return createFunctionAdaptor(function, from_type);\n        }\n\n        return [wrapper_cast_type = cast_type, from_type_index, to_type, date_time_overflow_behavior]\n            (ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable * column_nullable, size_t input_rows_count)\n        {\n            ColumnPtr result_column;\n            auto res = callOnIndexAndDataType<ToDataType>(from_type_index, [&](const auto & types) -> bool\n            {\n                using Types = std::decay_t<decltype(types)>;\n                using LeftDataType = typename Types::LeftType;\n                using RightDataType = typename Types::RightType;\n\n                if constexpr (IsDataTypeNumber<LeftDataType>)\n                {\n                    if constexpr (IsDataTypeDateOrDateTime<RightDataType>)\n                    {\n#define GENERATE_OVERFLOW_MODE_CASE(OVERFLOW_MODE, ADDITIONS) \\\n    case FormatSettings::DateTimeOverflowBehavior::OVERFLOW_MODE: \\\n        result_column \\\n            = ConvertImpl<LeftDataType, RightDataType, FunctionCastName, FormatSettings::DateTimeOverflowBehavior::OVERFLOW_MODE>:: \\\n                execute(arguments, result_type, input_rows_count, BehaviourOnErrorFromString::ConvertDefaultBehaviorTag, ADDITIONS()); \\\n        break;\n                        if (wrapper_cast_type == CastType::accurate)\n                        {\n                            switch (date_time_overflow_behavior)\n                            {\n                                GENERATE_OVERFLOW_MODE_CASE(Throw, DateTimeAccurateConvertStrategyAdditions)\n                                GENERATE_OVERFLOW_MODE_CASE(Ignore, DateTimeAccurateConvertStrategyAdditions)\n                                GENERATE_OVERFLOW_MODE_CASE(Saturate, DateTimeAccurateConvertStrategyAdditions)\n                            }\n                        }\n                        else\n                        {\n                            switch (date_time_overflow_behavior)\n                            {\n                                GENERATE_OVERFLOW_MODE_CASE(Throw, DateTimeAccurateOrNullConvertStrategyAdditions)\n                                GENERATE_OVERFLOW_MODE_CASE(Ignore, DateTimeAccurateOrNullConvertStrategyAdditions)\n                                GENERATE_OVERFLOW_MODE_CASE(Saturate, DateTimeAccurateOrNullConvertStrategyAdditions)\n                            }\n                        }\n#undef GENERATE_OVERFLOW_MODE_CASE\n\n                        return true;\n                    }\n                    else if constexpr (IsDataTypeNumber<RightDataType>)\n                    {\n                        if (wrapper_cast_type == CastType::accurate)\n                        {\n                            result_column = ConvertImpl<LeftDataType, RightDataType, FunctionCastName>::execute(\n                                arguments,\n                                result_type,\n                                input_rows_count,\n                                BehaviourOnErrorFromString::ConvertDefaultBehaviorTag,\n                                AccurateConvertStrategyAdditions());\n                        }\n                        else\n                        {\n                            result_column = ConvertImpl<LeftDataType, RightDataType, FunctionCastName>::execute(\n                                arguments,\n                                result_type,\n                                input_rows_count,\n                                BehaviourOnErrorFromString::ConvertDefaultBehaviorTag,\n                                AccurateOrNullConvertStrategyAdditions());\n                        }\n\n                        return true;\n                    }\n                }\n                else if constexpr (IsDataTypeStringOrFixedString<LeftDataType>)\n                {\n                    if constexpr (IsDataTypeNumber<RightDataType>)\n                    {\n                        chassert(wrapper_cast_type == CastType::accurate);\n                        result_column = ConvertImpl<LeftDataType, RightDataType, FunctionCastName>::execute(\n                            arguments,\n                            result_type,\n                            input_rows_count,\n                            BehaviourOnErrorFromString::ConvertDefaultBehaviorTag,\n                            AccurateConvertStrategyAdditions());\n                    }\n                    return true;\n                }\n\n                return false;\n            });\n\n            /// Additionally check if callOnIndexAndDataType wasn't called at all.\n            if (!res)\n            {\n                if (wrapper_cast_type == CastType::accurateOrNull)\n                {\n                    auto nullable_column_wrapper = FunctionCast::createToNullableColumnWrapper();\n                    return nullable_column_wrapper(arguments, result_type, column_nullable, input_rows_count);\n                }\n                else\n                {\n                    throw Exception(ErrorCodes::CANNOT_CONVERT_TYPE,\n                        \"Conversion from {} to {} is not supported\",\n                        from_type_index, to_type->getName());\n                }\n            }\n\n            return result_column;\n        };\n    }\n\n    template <typename ToDataType>\n    WrapperType createBoolWrapper(const DataTypePtr & from_type, const ToDataType * const to_type, bool requested_result_is_nullable) const\n    {\n        if (checkAndGetDataType<DataTypeString>(from_type.get()))\n        {\n            if (cast_type == CastType::accurateOrNull)\n            {\n                return [this](ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable * column_nullable, size_t input_rows_count) -> ColumnPtr\n                {\n                    return ConvertImplGenericFromString<false>::execute(arguments, result_type, column_nullable, input_rows_count, context);\n                };\n            }\n\n            return [this](ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable * column_nullable, size_t input_rows_count) -> ColumnPtr\n            {\n                return ConvertImplGenericFromString<true>::execute(arguments, result_type, column_nullable, input_rows_count, context);\n            };\n        }\n\n        return createWrapper<ToDataType>(from_type, to_type, requested_result_is_nullable);\n    }\n\n    WrapperType createUInt8ToBoolWrapper(const DataTypePtr from_type, const DataTypePtr to_type) const\n    {\n        return [from_type, to_type] (ColumnsWithTypeAndName & arguments, const DataTypePtr &, const ColumnNullable *, size_t /*input_rows_count*/) -> ColumnPtr\n        {\n            /// Special case when we convert UInt8 column to Bool column.\n            /// both columns have type UInt8, but we shouldn't use identity wrapper,\n            /// because Bool column can contain only 0 and 1.\n            auto res_column = to_type->createColumn();\n            const auto & data_from = checkAndGetColumn<ColumnUInt8>(*arguments[0].column).getData();\n            auto & data_to = assert_cast<ColumnUInt8 *>(res_column.get())->getData();\n            data_to.resize(data_from.size());\n            for (size_t i = 0; i != data_from.size(); ++i)\n                data_to[i] = static_cast<bool>(data_from[i]);\n            return res_column;\n        };\n    }\n\n    WrapperType createStringWrapper(const DataTypePtr & from_type) const\n    {\n        FunctionPtr function = FunctionToString::create(context);\n        return createFunctionAdaptor(function, from_type);\n    }\n\n    WrapperType createFixedStringWrapper(const DataTypePtr & from_type, const size_t N) const\n    {\n        if (!isStringOrFixedString(from_type))\n            throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"CAST AS FixedString is only implemented for types String and FixedString\");\n\n        bool exception_mode_null = cast_type == CastType::accurateOrNull;\n        return [exception_mode_null, N] (ColumnsWithTypeAndName & arguments, const DataTypePtr &, const ColumnNullable *, size_t /*input_rows_count*/)\n        {\n            if (exception_mode_null)\n                return FunctionToFixedString::executeForN<ConvertToFixedStringExceptionMode::Null>(arguments, N);\n            else\n                return FunctionToFixedString::executeForN<ConvertToFixedStringExceptionMode::Throw>(arguments, N);\n        };\n    }\n\n#define GENERATE_INTERVAL_CASE(INTERVAL_KIND) \\\n            case IntervalKind::Kind::INTERVAL_KIND: \\\n                return createFunctionAdaptor(FunctionConvert<DataTypeInterval, NameToInterval##INTERVAL_KIND, PositiveMonotonicity>::create(context), from_type);\n\n    WrapperType createIntervalWrapper(const DataTypePtr & from_type, IntervalKind kind) const\n    {\n        switch (kind.kind)\n        {\n            GENERATE_INTERVAL_CASE(Nanosecond)\n            GENERATE_INTERVAL_CASE(Microsecond)\n            GENERATE_INTERVAL_CASE(Millisecond)\n            GENERATE_INTERVAL_CASE(Second)\n            GENERATE_INTERVAL_CASE(Minute)\n            GENERATE_INTERVAL_CASE(Hour)\n            GENERATE_INTERVAL_CASE(Day)\n            GENERATE_INTERVAL_CASE(Week)\n            GENERATE_INTERVAL_CASE(Month)\n            GENERATE_INTERVAL_CASE(Quarter)\n            GENERATE_INTERVAL_CASE(Year)\n        }\n        throw Exception{ErrorCodes::CANNOT_CONVERT_TYPE, \"Conversion to unexpected IntervalKind: {}\", kind.toString()};\n    }\n\n#undef GENERATE_INTERVAL_CASE\n\n    template <typename ToDataType>\n    requires IsDataTypeDecimal<ToDataType>\n    WrapperType createDecimalWrapper(const DataTypePtr & from_type, const ToDataType * to_type, bool requested_result_is_nullable) const\n    {\n        TypeIndex type_index = from_type->getTypeId();\n        UInt32 scale = to_type->getScale();\n\n        WhichDataType which(type_index);\n        bool ok = which.isNativeInt() || which.isNativeUInt() || which.isDecimal() || which.isFloat() || which.isDateOrDate32() || which.isDateTime() || which.isDateTime64()\n            || which.isStringOrFixedString();\n        if (!ok)\n        {\n            if (cast_type == CastType::accurateOrNull)\n                return createToNullableColumnWrapper();\n            else\n                throw Exception(ErrorCodes::CANNOT_CONVERT_TYPE, \"Conversion from {} to {} is not supported\",\n                    from_type->getName(), to_type->getName());\n        }\n\n        auto wrapper_cast_type = cast_type;\n\n        return [wrapper_cast_type, type_index, scale, to_type, requested_result_is_nullable]\n            (ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable *column_nullable, size_t input_rows_count)\n        {\n            ColumnPtr result_column;\n            auto res = callOnIndexAndDataType<ToDataType>(type_index, [&](const auto & types) -> bool\n            {\n                using Types = std::decay_t<decltype(types)>;\n                using LeftDataType = typename Types::LeftType;\n                using RightDataType = typename Types::RightType;\n\n                if constexpr (IsDataTypeDecimalOrNumber<LeftDataType> && IsDataTypeDecimalOrNumber<RightDataType> && !std::is_same_v<DataTypeDateTime64, RightDataType>)\n                {\n                    if (wrapper_cast_type == CastType::accurate)\n                    {\n                        AccurateConvertStrategyAdditions additions;\n                        additions.scale = scale;\n                        result_column = ConvertImpl<LeftDataType, RightDataType, FunctionCastName>::execute(\n                            arguments, result_type, input_rows_count, BehaviourOnErrorFromString::ConvertDefaultBehaviorTag, additions);\n\n                        return true;\n                    }\n                    else if (wrapper_cast_type == CastType::accurateOrNull)\n                    {\n                        AccurateOrNullConvertStrategyAdditions additions;\n                        additions.scale = scale;\n                        result_column = ConvertImpl<LeftDataType, RightDataType, FunctionCastName>::execute(\n                            arguments, result_type, input_rows_count, BehaviourOnErrorFromString::ConvertDefaultBehaviorTag, additions);\n\n                        return true;\n                    }\n                }\n                else if constexpr (std::is_same_v<LeftDataType, DataTypeString>)\n                {\n                    if (requested_result_is_nullable)\n                    {\n                        /// Consistent with CAST(Nullable(String) AS Nullable(Numbers))\n                        /// In case when converting to Nullable type, we apply different parsing rule,\n                        /// that will not throw an exception but return NULL in case of malformed input.\n                        result_column = ConvertImpl<LeftDataType, RightDataType, FunctionCastName>::execute(\n                            arguments, result_type, input_rows_count, BehaviourOnErrorFromString::ConvertReturnNullOnErrorTag, scale);\n\n                        return true;\n                    }\n                }\n\n                result_column = ConvertImpl<LeftDataType, RightDataType, FunctionCastName>::execute(arguments, result_type, input_rows_count, BehaviourOnErrorFromString::ConvertDefaultBehaviorTag, scale);\n\n                return true;\n            });\n\n            /// Additionally check if callOnIndexAndDataType wasn't called at all.\n            if (!res)\n            {\n                if (wrapper_cast_type == CastType::accurateOrNull)\n                {\n                    auto nullable_column_wrapper = FunctionCast::createToNullableColumnWrapper();\n                    return nullable_column_wrapper(arguments, result_type, column_nullable, input_rows_count);\n                }\n                else\n                    throw Exception(ErrorCodes::CANNOT_CONVERT_TYPE,\n                        \"Conversion from {} to {} is not supported\",\n                        type_index, to_type->getName());\n            }\n\n            return result_column;\n        };\n    }\n\n    WrapperType createAggregateFunctionWrapper(const DataTypePtr & from_type_untyped, const DataTypeAggregateFunction * to_type) const\n    {\n        /// Conversion from String through parsing.\n        if (checkAndGetDataType<DataTypeString>(from_type_untyped.get()))\n        {\n            return [this](ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable * column_nullable, size_t input_rows_count) -> ColumnPtr\n            {\n                return ConvertImplGenericFromString<true>::execute(arguments, result_type, column_nullable, input_rows_count, context);\n            };\n        }\n        else if (const auto * agg_type = checkAndGetDataType<DataTypeAggregateFunction>(from_type_untyped.get()))\n        {\n            if (agg_type->getFunction()->haveSameStateRepresentation(*to_type->getFunction()))\n            {\n                return [function = to_type->getFunction()](\n                           ColumnsWithTypeAndName & arguments,\n                           const DataTypePtr & /* result_type */,\n                           const ColumnNullable * /* nullable_source */,\n                           size_t /*input_rows_count*/) -> ColumnPtr\n                {\n                    const auto & argument_column = arguments.front();\n                    const auto * col_agg = checkAndGetColumn<ColumnAggregateFunction>(argument_column.column.get());\n                    if (col_agg)\n                    {\n                        auto new_col_agg = ColumnAggregateFunction::create(*col_agg);\n                        new_col_agg->set(function);\n                        return new_col_agg;\n                    }\n                    else\n                    {\n                        throw Exception(\n                            ErrorCodes::LOGICAL_ERROR,\n                            \"Illegal column {} for function CAST AS AggregateFunction\",\n                            argument_column.column->getName());\n                    }\n                };\n            }\n        }\n\n        if (cast_type == CastType::accurateOrNull)\n            return createToNullableColumnWrapper();\n        else\n            throw Exception(ErrorCodes::CANNOT_CONVERT_TYPE, \"Conversion from {} to {} is not supported\",\n                from_type_untyped->getName(), to_type->getName());\n    }\n\n    WrapperType createArrayWrapper(const DataTypePtr & from_type_untyped, const DataTypeArray & to_type) const\n    {\n        /// Conversion from String through parsing.\n        if (checkAndGetDataType<DataTypeString>(from_type_untyped.get()))\n        {\n            return [this](ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable * column_nullable, size_t input_rows_count) -> ColumnPtr\n            {\n                return ConvertImplGenericFromString<true>::execute(arguments, result_type, column_nullable, input_rows_count, context);\n            };\n        }\n\n        DataTypePtr from_type_holder;\n        const auto * from_type = checkAndGetDataType<DataTypeArray>(from_type_untyped.get());\n        const auto * from_type_map = checkAndGetDataType<DataTypeMap>(from_type_untyped.get());\n\n        /// Convert from Map\n        if (from_type_map)\n        {\n            /// Recreate array of unnamed tuples because otherwise it may work\n            /// unexpectedly while converting to array of named tuples.\n            from_type_holder = from_type_map->getNestedTypeWithUnnamedTuple();\n            from_type = assert_cast<const DataTypeArray *>(from_type_holder.get());\n        }\n\n        if (!from_type)\n        {\n            throw Exception(ErrorCodes::TYPE_MISMATCH,\n                \"CAST AS Array can only be performed between same-dimensional Array, Map or String types\");\n        }\n\n        DataTypePtr from_nested_type = from_type->getNestedType();\n\n        /// In query SELECT CAST([] AS Array(Array(String))) from type is Array(Nothing)\n        bool from_empty_array = isNothing(from_nested_type);\n\n        if (from_type->getNumberOfDimensions() != to_type.getNumberOfDimensions() && !from_empty_array)\n            throw Exception(ErrorCodes::TYPE_MISMATCH,\n                \"CAST AS Array can only be performed between same-dimensional array types\");\n\n        const DataTypePtr & to_nested_type = to_type.getNestedType();\n\n        /// Prepare nested type conversion\n        const auto nested_function = prepareUnpackDictionaries(from_nested_type, to_nested_type);\n\n        return [nested_function, from_nested_type, to_nested_type](\n                ColumnsWithTypeAndName & arguments, const DataTypePtr &, const ColumnNullable * nullable_source, size_t /*input_rows_count*/) -> ColumnPtr\n        {\n            const auto & argument_column = arguments.front();\n\n            const ColumnArray * col_array = nullptr;\n\n            if (const ColumnMap * col_map = checkAndGetColumn<ColumnMap>(argument_column.column.get()))\n                col_array = &col_map->getNestedColumn();\n            else\n                col_array = checkAndGetColumn<ColumnArray>(argument_column.column.get());\n\n            if (col_array)\n            {\n                /// create columns for converting nested column containing original and result columns\n                ColumnsWithTypeAndName nested_columns{{ col_array->getDataPtr(), from_nested_type, \"\" }};\n\n                /// convert nested column\n                auto result_column = nested_function(nested_columns, to_nested_type, nullable_source, nested_columns.front().column->size());\n\n                /// set converted nested column to result\n                return ColumnArray::create(result_column, col_array->getOffsetsPtr());\n            }\n            else\n            {\n                throw Exception(ErrorCodes::LOGICAL_ERROR,\n                    \"Illegal column {} for function CAST AS Array\",\n                    argument_column.column->getName());\n            }\n        };\n    }\n\n    using ElementWrappers = std::vector<WrapperType>;\n\n    ElementWrappers getElementWrappers(const DataTypes & from_element_types, const DataTypes & to_element_types) const\n    {\n        ElementWrappers element_wrappers;\n        element_wrappers.reserve(from_element_types.size());\n\n        /// Create conversion wrapper for each element in tuple\n        for (size_t i = 0; i < from_element_types.size(); ++i)\n        {\n            const DataTypePtr & from_element_type = from_element_types[i];\n            const DataTypePtr & to_element_type = to_element_types[i];\n            element_wrappers.push_back(prepareUnpackDictionaries(from_element_type, to_element_type));\n        }\n\n        return element_wrappers;\n    }\n\n    WrapperType createTupleWrapper(const DataTypePtr & from_type_untyped, const DataTypeTuple * to_type) const\n    {\n        /// Conversion from String through parsing.\n        if (checkAndGetDataType<DataTypeString>(from_type_untyped.get()))\n        {\n            return [this](ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable * column_nullable, size_t input_rows_count) -> ColumnPtr\n            {\n                return ConvertImplGenericFromString<true>::execute(arguments, result_type, column_nullable, input_rows_count, context);\n            };\n        }\n\n        const auto * from_type = checkAndGetDataType<DataTypeTuple>(from_type_untyped.get());\n        if (!from_type)\n            throw Exception(ErrorCodes::TYPE_MISMATCH, \"CAST AS Tuple can only be performed between tuple types or from String.\\n\"\n                            \"Left type: {}, right type: {}\", from_type_untyped->getName(), to_type->getName());\n\n        const auto & from_element_types = from_type->getElements();\n        const auto & to_element_types = to_type->getElements();\n\n        std::vector<WrapperType> element_wrappers;\n        std::vector<std::optional<size_t>> to_reverse_index;\n\n        /// For named tuples allow conversions for tuples with\n        /// different sets of elements. If element exists in @to_type\n        /// and doesn't exist in @to_type it will be filled by default values.\n        if (from_type->haveExplicitNames() && to_type->haveExplicitNames())\n        {\n            const auto & from_names = from_type->getElementNames();\n            std::unordered_map<String, size_t> from_positions;\n            from_positions.reserve(from_names.size());\n            for (size_t i = 0; i < from_names.size(); ++i)\n                from_positions[from_names[i]] = i;\n\n            const auto & to_names = to_type->getElementNames();\n            element_wrappers.reserve(to_names.size());\n            to_reverse_index.reserve(from_names.size());\n\n            for (size_t i = 0; i < to_names.size(); ++i)\n            {\n                auto it = from_positions.find(to_names[i]);\n                if (it != from_positions.end())\n                {\n                    element_wrappers.emplace_back(prepareUnpackDictionaries(from_element_types[it->second], to_element_types[i]));\n                    to_reverse_index.emplace_back(it->second);\n                }\n                else\n                {\n                    element_wrappers.emplace_back();\n                    to_reverse_index.emplace_back();\n                }\n            }\n        }\n        else\n        {\n            if (from_element_types.size() != to_element_types.size())\n                throw Exception(ErrorCodes::TYPE_MISMATCH, \"CAST AS Tuple can only be performed between tuple types \"\n                                \"with the same number of elements or from String.\\nLeft type: {}, right type: {}\",\n                                from_type->getName(), to_type->getName());\n\n            element_wrappers = getElementWrappers(from_element_types, to_element_types);\n            to_reverse_index.reserve(to_element_types.size());\n            for (size_t i = 0; i < to_element_types.size(); ++i)\n                to_reverse_index.emplace_back(i);\n        }\n\n        return [element_wrappers, from_element_types, to_element_types, to_reverse_index]\n            (ColumnsWithTypeAndName & arguments, const DataTypePtr &, const ColumnNullable * nullable_source, size_t input_rows_count) -> ColumnPtr\n        {\n            const auto * col = arguments.front().column.get();\n\n            size_t tuple_size = to_element_types.size();\n            const ColumnTuple & column_tuple = typeid_cast<const ColumnTuple &>(*col);\n\n            Columns converted_columns(tuple_size);\n\n            /// invoke conversion for each element\n            for (size_t i = 0; i < tuple_size; ++i)\n            {\n                if (to_reverse_index[i])\n                {\n                    size_t from_idx = *to_reverse_index[i];\n                    ColumnsWithTypeAndName element = {{column_tuple.getColumns()[from_idx], from_element_types[from_idx], \"\" }};\n                    converted_columns[i] = element_wrappers[i](element, to_element_types[i], nullable_source, input_rows_count);\n                }\n                else\n                {\n                    converted_columns[i] = to_element_types[i]->createColumn()->cloneResized(input_rows_count);\n                }\n            }\n\n            return ColumnTuple::create(converted_columns);\n        };\n    }\n\n    /// The case of: tuple([key1, key2, ..., key_n], [value1, value2, ..., value_n])\n    WrapperType createTupleToMapWrapper(const DataTypes & from_kv_types, const DataTypes & to_kv_types) const\n    {\n        return [element_wrappers = getElementWrappers(from_kv_types, to_kv_types), from_kv_types, to_kv_types]\n            (ColumnsWithTypeAndName & arguments, const DataTypePtr &, const ColumnNullable * nullable_source, size_t /*input_rows_count*/) -> ColumnPtr\n        {\n            const auto * col = arguments.front().column.get();\n            const auto & column_tuple = assert_cast<const ColumnTuple &>(*col);\n\n            Columns offsets(2);\n            Columns converted_columns(2);\n            for (size_t i = 0; i < 2; ++i)\n            {\n                const auto & column_array = assert_cast<const ColumnArray &>(column_tuple.getColumn(i));\n                ColumnsWithTypeAndName element = {{column_array.getDataPtr(), from_kv_types[i], \"\"}};\n                converted_columns[i] = element_wrappers[i](element, to_kv_types[i], nullable_source, (element[0].column)->size());\n                offsets[i] = column_array.getOffsetsPtr();\n            }\n\n            const auto & keys_offsets = assert_cast<const ColumnArray::ColumnOffsets &>(*offsets[0]).getData();\n            const auto & values_offsets = assert_cast<const ColumnArray::ColumnOffsets &>(*offsets[1]).getData();\n            if (keys_offsets != values_offsets)\n                throw Exception(ErrorCodes::TYPE_MISMATCH,\n                    \"CAST AS Map can only be performed from tuple of arrays with equal sizes.\");\n\n            return ColumnMap::create(converted_columns[0], converted_columns[1], offsets[0]);\n        };\n    }\n\n    WrapperType createMapToMapWrapper(const DataTypes & from_kv_types, const DataTypes & to_kv_types) const\n    {\n        return [element_wrappers = getElementWrappers(from_kv_types, to_kv_types), from_kv_types, to_kv_types]\n            (ColumnsWithTypeAndName & arguments, const DataTypePtr &, const ColumnNullable * nullable_source, size_t /*input_rows_count*/) -> ColumnPtr\n        {\n            const auto * col = arguments.front().column.get();\n            const auto & column_map = typeid_cast<const ColumnMap &>(*col);\n            const auto & nested_data = column_map.getNestedData();\n\n            Columns converted_columns(2);\n            for (size_t i = 0; i < 2; ++i)\n            {\n                ColumnsWithTypeAndName element = {{nested_data.getColumnPtr(i), from_kv_types[i], \"\"}};\n                converted_columns[i] = element_wrappers[i](element, to_kv_types[i], nullable_source, (element[0].column)->size());\n            }\n\n            return ColumnMap::create(converted_columns[0], converted_columns[1], column_map.getNestedColumn().getOffsetsPtr());\n        };\n    }\n\n    /// The case of: [(key1, value1), (key2, value2), ...]\n    WrapperType createArrayToMapWrapper(const DataTypes & from_kv_types, const DataTypes & to_kv_types) const\n    {\n        return [element_wrappers = getElementWrappers(from_kv_types, to_kv_types), from_kv_types, to_kv_types]\n            (ColumnsWithTypeAndName & arguments, const DataTypePtr &, const ColumnNullable * nullable_source, size_t /*input_rows_count*/) -> ColumnPtr\n        {\n            const auto * col = arguments.front().column.get();\n            const auto & column_array = typeid_cast<const ColumnArray &>(*col);\n            const auto & nested_data = typeid_cast<const ColumnTuple &>(column_array.getData());\n\n            Columns converted_columns(2);\n            for (size_t i = 0; i < 2; ++i)\n            {\n                ColumnsWithTypeAndName element = {{nested_data.getColumnPtr(i), from_kv_types[i], \"\"}};\n                converted_columns[i] = element_wrappers[i](element, to_kv_types[i], nullable_source, (element[0].column)->size());\n            }\n\n            return ColumnMap::create(converted_columns[0], converted_columns[1], column_array.getOffsetsPtr());\n        };\n    }\n\n\n    WrapperType createMapWrapper(const DataTypePtr & from_type_untyped, const DataTypeMap * to_type) const\n    {\n        if (const auto * from_tuple = checkAndGetDataType<DataTypeTuple>(from_type_untyped.get()))\n        {\n            if (from_tuple->getElements().size() != 2)\n                throw Exception(\n                    ErrorCodes::TYPE_MISMATCH,\n                    \"CAST AS Map from tuple requires 2 elements. \"\n                    \"Left type: {}, right type: {}\",\n                    from_tuple->getName(),\n                    to_type->getName());\n\n            DataTypes from_kv_types;\n            const auto & to_kv_types = to_type->getKeyValueTypes();\n\n            for (const auto & elem : from_tuple->getElements())\n            {\n                const auto * type_array = checkAndGetDataType<DataTypeArray>(elem.get());\n                if (!type_array)\n                    throw Exception(ErrorCodes::TYPE_MISMATCH,\n                        \"CAST AS Map can only be performed from tuples of array. Got: {}\", from_tuple->getName());\n\n                from_kv_types.push_back(type_array->getNestedType());\n            }\n\n            return createTupleToMapWrapper(from_kv_types, to_kv_types);\n        }\n        else if (const auto * from_array = typeid_cast<const DataTypeArray *>(from_type_untyped.get()))\n        {\n            if (typeid_cast<const DataTypeNothing *>(from_array->getNestedType().get()))\n                return [nested = to_type->getNestedType()](ColumnsWithTypeAndName &, const DataTypePtr &, const ColumnNullable *, size_t size)\n                {\n                    return ColumnMap::create(nested->createColumnConstWithDefaultValue(size)->convertToFullColumnIfConst());\n                };\n\n            const auto * nested_tuple = typeid_cast<const DataTypeTuple *>(from_array->getNestedType().get());\n            if (!nested_tuple || nested_tuple->getElements().size() != 2)\n                throw Exception(\n                    ErrorCodes::TYPE_MISMATCH,\n                    \"CAST AS Map from array requires nested tuple of 2 elements. \"\n                    \"Left type: {}, right type: {}\",\n                    from_array->getName(),\n                    to_type->getName());\n\n            return createArrayToMapWrapper(nested_tuple->getElements(), to_type->getKeyValueTypes());\n        }\n        else if (const auto * from_type = checkAndGetDataType<DataTypeMap>(from_type_untyped.get()))\n        {\n            return createMapToMapWrapper(from_type->getKeyValueTypes(), to_type->getKeyValueTypes());\n        }\n        else\n        {\n            throw Exception(ErrorCodes::TYPE_MISMATCH, \"Unsupported types to CAST AS Map. \"\n                \"Left type: {}, right type: {}\", from_type_untyped->getName(), to_type->getName());\n        }\n    }\n\n    WrapperType createTupleToObjectWrapper(const DataTypeTuple & from_tuple, bool has_nullable_subcolumns) const\n    {\n        if (!from_tuple.haveExplicitNames())\n            throw Exception(ErrorCodes::TYPE_MISMATCH,\n            \"Cast to Object can be performed only from flatten Named Tuple. Got: {}\", from_tuple.getName());\n\n        PathsInData paths;\n        DataTypes from_types;\n\n        std::tie(paths, from_types) = flattenTuple(from_tuple.getPtr());\n        auto to_types = from_types;\n\n        for (auto & type : to_types)\n        {\n            if (isTuple(type) || isNested(type))\n                throw Exception(ErrorCodes::TYPE_MISMATCH,\n                    \"Cast to Object can be performed only from flatten Named Tuple. Got: {}\",\n                    from_tuple.getName());\n\n            type = recursiveRemoveLowCardinality(type);\n        }\n\n        return [element_wrappers = getElementWrappers(from_types, to_types),\n            has_nullable_subcolumns, from_types, to_types, paths]\n            (ColumnsWithTypeAndName & arguments, const DataTypePtr &, const ColumnNullable * nullable_source, size_t input_rows_count)\n        {\n            size_t tuple_size = to_types.size();\n            auto flattened_column = flattenTuple(arguments.front().column);\n            const auto & column_tuple = assert_cast<const ColumnTuple &>(*flattened_column);\n\n            if (tuple_size != column_tuple.getColumns().size())\n                throw Exception(ErrorCodes::TYPE_MISMATCH,\n                    \"Expected tuple with {} subcolumn, but got {} subcolumns\",\n                    tuple_size, column_tuple.getColumns().size());\n\n            auto res = ColumnObjectDeprecated::create(has_nullable_subcolumns);\n            for (size_t i = 0; i < tuple_size; ++i)\n            {\n                ColumnsWithTypeAndName element = {{column_tuple.getColumns()[i], from_types[i], \"\" }};\n                auto converted_column = element_wrappers[i](element, to_types[i], nullable_source, input_rows_count);\n                res->addSubcolumn(paths[i], converted_column->assumeMutable());\n            }\n\n            return res;\n        };\n    }\n\n    WrapperType createMapToObjectWrapper(const DataTypeMap & from_map, bool has_nullable_subcolumns) const\n    {\n        auto key_value_types = from_map.getKeyValueTypes();\n\n        if (!isStringOrFixedString(key_value_types[0]))\n            throw Exception(ErrorCodes::TYPE_MISMATCH,\n                \"Cast to Object from Map can be performed only from Map \"\n                \"with String or FixedString key. Got: {}\", from_map.getName());\n\n        const auto & value_type = key_value_types[1];\n        auto to_value_type = value_type;\n\n        if (!has_nullable_subcolumns && value_type->isNullable())\n            to_value_type = removeNullable(value_type);\n\n        if (has_nullable_subcolumns && !value_type->isNullable())\n            to_value_type = makeNullable(value_type);\n\n        DataTypes to_key_value_types{std::make_shared<DataTypeString>(), std::move(to_value_type)};\n        auto element_wrappers = getElementWrappers(key_value_types, to_key_value_types);\n\n        return [has_nullable_subcolumns, element_wrappers, key_value_types, to_key_value_types]\n            (ColumnsWithTypeAndName & arguments, const DataTypePtr &, const ColumnNullable * nullable_source, size_t) -> ColumnPtr\n        {\n            const auto & column_map = assert_cast<const ColumnMap &>(*arguments.front().column);\n            const auto & offsets = column_map.getNestedColumn().getOffsets();\n            auto key_value_columns = column_map.getNestedData().getColumnsCopy();\n\n            for (size_t i = 0; i < 2; ++i)\n            {\n                ColumnsWithTypeAndName element{{key_value_columns[i], key_value_types[i], \"\"}};\n                key_value_columns[i] = element_wrappers[i](element, to_key_value_types[i], nullable_source, key_value_columns[i]->size());\n            }\n\n            const auto & key_column_str = assert_cast<const ColumnString &>(*key_value_columns[0]);\n            const auto & value_column = *key_value_columns[1];\n\n            using SubcolumnsMap = HashMap<StringRef, MutableColumnPtr, StringRefHash>;\n            SubcolumnsMap subcolumns;\n\n            for (size_t row = 0; row < offsets.size(); ++row)\n            {\n                for (size_t i = offsets[static_cast<ssize_t>(row) - 1]; i < offsets[row]; ++i)\n                {\n                    auto ref = key_column_str.getDataAt(i);\n\n                    bool inserted;\n                    SubcolumnsMap::LookupResult it;\n                    subcolumns.emplace(ref, it, inserted);\n                    auto & subcolumn = it->getMapped();\n\n                    if (inserted)\n                        subcolumn = value_column.cloneEmpty()->cloneResized(row);\n\n                    /// Map can have duplicated keys. We insert only first one.\n                    if (subcolumn->size() == row)\n                        subcolumn->insertFrom(value_column, i);\n                }\n\n                /// Insert default values for keys missed in current row.\n                for (const auto & [_, subcolumn] : subcolumns)\n                    if (subcolumn->size() == row)\n                        subcolumn->insertDefault();\n            }\n\n            auto column_object = ColumnObjectDeprecated::create(has_nullable_subcolumns);\n            for (auto && [key, subcolumn] : subcolumns)\n            {\n                PathInData path(key.toView());\n                column_object->addSubcolumn(path, std::move(subcolumn));\n            }\n\n            return column_object;\n        };\n    }\n\n    WrapperType createObjectDeprecatedWrapper(const DataTypePtr & from_type, const DataTypeObjectDeprecated * to_type) const\n    {\n        if (const auto * from_tuple = checkAndGetDataType<DataTypeTuple>(from_type.get()))\n        {\n            return createTupleToObjectWrapper(*from_tuple, to_type->hasNullableSubcolumns());\n        }\n        else if (const auto * from_map = checkAndGetDataType<DataTypeMap>(from_type.get()))\n        {\n            return createMapToObjectWrapper(*from_map, to_type->hasNullableSubcolumns());\n        }\n        else if (checkAndGetDataType<DataTypeString>(from_type.get()))\n        {\n            return [this](ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable * nullable_source, size_t input_rows_count)\n            {\n                auto res = ConvertImplGenericFromString<true>::execute(arguments, result_type, nullable_source, input_rows_count, context)->assumeMutable();\n                res->finalize();\n                return res;\n            };\n        }\n        else if (checkAndGetDataType<DataTypeObjectDeprecated>(from_type.get()))\n        {\n            return [is_nullable = to_type->hasNullableSubcolumns()] (ColumnsWithTypeAndName & arguments, const DataTypePtr & , const ColumnNullable * , size_t) -> ColumnPtr\n            {\n                const auto & column_object = assert_cast<const ColumnObjectDeprecated &>(*arguments.front().column);\n                auto res = ColumnObjectDeprecated::create(is_nullable);\n                for (size_t i = 0; i < column_object.size(); i++)\n                    res->insert(column_object[i]);\n\n                res->finalize();\n                return res;\n            };\n        }\n\n        throw Exception(ErrorCodes::TYPE_MISMATCH,\n            \"Cast to Object can be performed only from flatten named Tuple, Map or String. Got: {}\", from_type->getName());\n    }\n\n    WrapperType createObjectWrapper(const DataTypePtr & from_type, const DataTypeObject * to_object) const\n    {\n        if (checkAndGetDataType<DataTypeString>(from_type.get()))\n        {\n            return [this](ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable * nullable_source, size_t input_rows_count)\n            {\n                auto res = ConvertImplGenericFromString<true>::execute(arguments, result_type, nullable_source, input_rows_count, context)->assumeMutable();\n                res->finalize();\n                return res;\n            };\n        }\n\n        /// TODO: support CAST between JSON types with different parameters\n        ///       support CAST from Map to JSON\n        ///       support CAST from Tuple to JSON\n        ///       support CAST from Object('json') to JSON\n        throw Exception(ErrorCodes::TYPE_MISMATCH, \"Cast to {} can be performed only from String. Got: {}\", magic_enum::enum_name(to_object->getSchemaFormat()), from_type->getName());\n    }\n\n    WrapperType createVariantToVariantWrapper(const DataTypeVariant & from_variant, const DataTypeVariant & to_variant) const\n    {\n        /// We support only extension of variant type, so, only new types can be added.\n        /// For example: Variant(T1, T2) -> Variant(T1, T2, T3) is supported, but Variant(T1, T2) -> Variant(T1, T3) is not supported.\n        /// We want to extend Variant type for free without rewriting the data, but we sort data types inside Variant during type creation\n        /// (we do it because we want Variant(T1, T2) to be the same as Variant(T2, T1)), but after extension the order of variant types\n        /// (and so their discriminators) can be different. For example: Variant(T1, T3) -> Variant(T1, T2, T3).\n        /// To avoid full rewrite of discriminators column, ColumnVariant supports it's local order of variant columns (and so local\n        /// discriminators) and stores mapping global order -> local order.\n        /// So, to extend Variant with new types for free, we should keep old local order for old variants, append new variants and change\n        /// mapping global order -> local order according to the new global order.\n\n        /// Create map (new variant type) -> (it's global discriminator in new order).\n        const auto & new_variants = to_variant.getVariants();\n        std::unordered_map<String, ColumnVariant::Discriminator> new_variant_types_to_new_global_discriminator;\n        new_variant_types_to_new_global_discriminator.reserve(new_variants.size());\n        for (size_t i = 0; i != new_variants.size(); ++i)\n            new_variant_types_to_new_global_discriminator[new_variants[i]->getName()] = i;\n\n        /// Create set of old variant types.\n        const auto & old_variants = from_variant.getVariants();\n        std::unordered_map<String, ColumnVariant::Discriminator> old_variant_types_to_old_global_discriminator;\n        old_variant_types_to_old_global_discriminator.reserve(old_variants.size());\n        for (size_t i = 0; i != old_variants.size(); ++i)\n            old_variant_types_to_old_global_discriminator[old_variants[i]->getName()] = i;\n\n        /// Check that the set of old variants types is a subset of new variant types and collect new global discriminator for each old global discriminator.\n        std::unordered_map<ColumnVariant::Discriminator, ColumnVariant::Discriminator> old_global_discriminator_to_new;\n        old_global_discriminator_to_new.reserve(old_variants.size());\n        for (const auto & [old_variant_type, old_discriminator] : old_variant_types_to_old_global_discriminator)\n        {\n            auto it = new_variant_types_to_new_global_discriminator.find(old_variant_type);\n            if (it == new_variant_types_to_new_global_discriminator.end())\n                throw Exception(\n                    ErrorCodes::CANNOT_CONVERT_TYPE,\n                    \"Cannot convert type {} to {}. Conversion between Variant types is allowed only when new Variant type is an extension \"\n                    \"of an initial one\", from_variant.getName(), to_variant.getName());\n            old_global_discriminator_to_new[old_discriminator] = it->second;\n        }\n\n        /// Collect variant types and their global discriminators that should be added to the old Variant to get the new Variant.\n        std::vector<std::pair<DataTypePtr, ColumnVariant::Discriminator>> variant_types_and_discriminators_to_add;\n        variant_types_and_discriminators_to_add.reserve(new_variants.size() - old_variants.size());\n        for (size_t i = 0; i != new_variants.size(); ++i)\n        {\n            if (!old_variant_types_to_old_global_discriminator.contains(new_variants[i]->getName()))\n                variant_types_and_discriminators_to_add.emplace_back(new_variants[i], i);\n        }\n\n        return [old_global_discriminator_to_new, variant_types_and_discriminators_to_add]\n               (ColumnsWithTypeAndName & arguments, const DataTypePtr &, const ColumnNullable *, size_t) -> ColumnPtr\n        {\n            const auto & column_variant = assert_cast<const ColumnVariant &>(*arguments.front().column.get());\n            size_t num_old_variants = column_variant.getNumVariants();\n            Columns new_variant_columns;\n            new_variant_columns.reserve(num_old_variants + variant_types_and_discriminators_to_add.size());\n            std::vector<ColumnVariant::Discriminator> new_local_to_global_discriminators;\n            new_local_to_global_discriminators.reserve(num_old_variants + variant_types_and_discriminators_to_add.size());\n            for (size_t i = 0; i != num_old_variants; ++i)\n            {\n                new_variant_columns.push_back(column_variant.getVariantPtrByLocalDiscriminator(i));\n                new_local_to_global_discriminators.push_back(old_global_discriminator_to_new.at(column_variant.globalDiscriminatorByLocal(i)));\n            }\n\n            for (const auto & [new_variant_type, new_global_discriminator] : variant_types_and_discriminators_to_add)\n            {\n                new_variant_columns.push_back(new_variant_type->createColumn());\n                new_local_to_global_discriminators.push_back(new_global_discriminator);\n            }\n\n            return ColumnVariant::create(column_variant.getLocalDiscriminatorsPtr(), column_variant.getOffsetsPtr(), new_variant_columns, new_local_to_global_discriminators);\n        };\n    }\n\n    /// Create wrapper only if we support this conversion.\n    WrapperType createWrapperIfCanConvert(const DataTypePtr & from, const DataTypePtr & to) const\n    {\n        try\n        {\n            /// We can avoid try/catch here if we will implement check that 2 types can be casted, but it\n            /// requires quite a lot of work. By now let's simply use try/catch.\n            /// First, check that we can create a wrapper.\n            WrapperType wrapper = prepareUnpackDictionaries(from, to);\n            /// Second, check if we can perform a conversion on column with default value.\n            /// (we cannot just check empty column as we do some checks only during iteration over rows).\n            auto test_col = from->createColumn();\n            test_col->insertDefault();\n            ColumnsWithTypeAndName column_from = {{test_col->getPtr(), from, \"\" }};\n            wrapper(column_from, to, nullptr, 1);\n            return wrapper;\n        }\n        catch (const Exception &)\n        {\n            return {};\n        }\n    }\n\n    WrapperType createVariantToColumnWrapper(const DataTypeVariant & from_variant, const DataTypePtr & to_type) const\n    {\n        const auto & variant_types = from_variant.getVariants();\n        std::vector<WrapperType> variant_wrappers;\n        variant_wrappers.reserve(variant_types.size());\n\n        /// Create conversion wrapper for each variant.\n        for (const auto & variant_type : variant_types)\n        {\n            WrapperType wrapper;\n            if (cast_type == CastType::accurateOrNull)\n            {\n                /// Create wrapper only if we support conversion from variant to the resulting type.\n                wrapper = createWrapperIfCanConvert(variant_type, to_type);\n            }\n            else\n            {\n                wrapper = prepareUnpackDictionaries(variant_type, to_type);\n            }\n            variant_wrappers.push_back(wrapper);\n        }\n\n        return [variant_wrappers, variant_types, to_type]\n               (ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable *, size_t input_rows_count) -> ColumnPtr\n        {\n            const auto & column_variant = assert_cast<const ColumnVariant &>(*arguments.front().column.get());\n\n            /// First, cast each variant to the result type.\n            std::vector<ColumnPtr> casted_variant_columns;\n            casted_variant_columns.reserve(variant_types.size());\n            for (size_t i = 0; i != variant_types.size(); ++i)\n            {\n                auto variant_col = column_variant.getVariantPtrByGlobalDiscriminator(i);\n                ColumnsWithTypeAndName variant = {{variant_col, variant_types[i], \"\" }};\n                const auto & variant_wrapper = variant_wrappers[i];\n                ColumnPtr casted_variant;\n                /// Check if we have wrapper for this variant.\n                if (variant_wrapper)\n                    casted_variant = variant_wrapper(variant, result_type, nullptr, variant_col->size());\n                casted_variant_columns.push_back(std::move(casted_variant));\n            }\n\n            /// Second, construct resulting column from casted variant columns according to discriminators.\n            const auto & local_discriminators = column_variant.getLocalDiscriminators();\n            auto res = result_type->createColumn();\n            res->reserve(input_rows_count);\n            for (size_t i = 0; i != input_rows_count; ++i)\n            {\n                auto global_discr = column_variant.globalDiscriminatorByLocal(local_discriminators[i]);\n                if (global_discr == ColumnVariant::NULL_DISCRIMINATOR || !casted_variant_columns[global_discr])\n                    res->insertDefault();\n                else\n                    res->insertFrom(*casted_variant_columns[global_discr], column_variant.offsetAt(i));\n            }\n\n            return res;\n        };\n    }\n\n    static ColumnPtr createVariantFromDescriptorsAndOneNonEmptyVariant(const DataTypes & variant_types, const ColumnPtr & discriminators, const ColumnPtr & variant, ColumnVariant::Discriminator variant_discr)\n    {\n        Columns variants;\n        variants.reserve(variant_types.size());\n        for (size_t i = 0; i != variant_types.size(); ++i)\n        {\n            if (i == variant_discr)\n                variants.emplace_back(variant);\n            else\n                variants.push_back(variant_types[i]->createColumn());\n        }\n\n        return ColumnVariant::create(discriminators, variants);\n    }\n\n    WrapperType createStringToVariantWrapper() const\n    {\n        return [&](ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable *, size_t input_rows_count) -> ColumnPtr\n        {\n            auto column = arguments[0].column->convertToFullColumnIfLowCardinality();\n            auto args = arguments;\n            args[0].column = column;\n\n            const ColumnNullable * column_nullable = nullptr;\n            if (isColumnNullable(*args[0].column))\n            {\n                column_nullable = assert_cast<const ColumnNullable *>(args[0].column.get());\n                args[0].column = column_nullable->getNestedColumnPtr();\n            }\n\n            args[0].type = removeNullable(removeLowCardinality(args[0].type));\n\n            if (cast_type == CastType::accurateOrNull)\n                return ConvertImplGenericFromString<false>::execute(args, result_type, column_nullable, input_rows_count, context);\n            return ConvertImplGenericFromString<true>::execute(args, result_type, column_nullable, input_rows_count, context);\n        };\n    }\n\n    WrapperType createColumnToVariantWrapper(const DataTypePtr & from_type, const DataTypeVariant & to_variant) const\n    {\n        /// We allow converting NULL to Variant(...) as Variant can store NULLs.\n        if (from_type->onlyNull())\n        {\n            return [](ColumnsWithTypeAndName &, const DataTypePtr & result_type, const ColumnNullable *, size_t input_rows_count) -> ColumnPtr\n            {\n                auto result_column = result_type->createColumn();\n                result_column->insertManyDefaults(input_rows_count);\n                return result_column;\n            };\n        }\n\n        auto variant_discr_opt = to_variant.tryGetVariantDiscriminator(removeNullableOrLowCardinalityNullable(from_type)->getName());\n        /// Cast String to Variant through parsing if it's not Variant(String).\n        if (isStringOrFixedString(removeNullable(removeLowCardinality(from_type))) && (!variant_discr_opt || to_variant.getVariants().size() > 1))\n            return createStringToVariantWrapper();\n\n        if (!variant_discr_opt)\n            throw Exception(ErrorCodes::CANNOT_CONVERT_TYPE, \"Cannot convert type {} to {}. Conversion to Variant allowed only for types from this Variant\", from_type->getName(), to_variant.getName());\n\n        return [variant_discr = *variant_discr_opt]\n               (ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable *, size_t) -> ColumnPtr\n        {\n            const auto & result_variant_type = assert_cast<const DataTypeVariant &>(*result_type);\n            const auto & variant_types = result_variant_type.getVariants();\n            if (const ColumnNullable * col_nullable = typeid_cast<const ColumnNullable *>(arguments.front().column.get()))\n            {\n                const auto & column = col_nullable->getNestedColumnPtr();\n                const auto & null_map = col_nullable->getNullMapData();\n                IColumn::Filter filter;\n                filter.reserve(column->size());\n                auto discriminators = ColumnVariant::ColumnDiscriminators::create();\n                auto & discriminators_data = discriminators->getData();\n                discriminators_data.reserve(column->size());\n                size_t variant_size_hint = 0;\n                for (size_t i = 0; i != column->size(); ++i)\n                {\n                    if (null_map[i])\n                    {\n                        discriminators_data.push_back(ColumnVariant::NULL_DISCRIMINATOR);\n                        filter.push_back(0);\n                    }\n                    else\n                    {\n                        discriminators_data.push_back(variant_discr);\n                        filter.push_back(1);\n                        ++variant_size_hint;\n                    }\n                }\n\n                ColumnPtr variant_column;\n                /// If there were no NULLs, just use the column.\n                if (variant_size_hint == column->size())\n                    variant_column = column;\n                /// Otherwise we should use filtered column.\n                else\n                    variant_column = column->filter(filter, variant_size_hint);\n                return createVariantFromDescriptorsAndOneNonEmptyVariant(variant_types, std::move(discriminators), variant_column, variant_discr);\n            }\n            else if (isColumnLowCardinalityNullable(*arguments.front().column))\n            {\n                const auto & column = arguments.front().column;\n\n                /// Variant column cannot have LowCardinality(Nullable(...)) variant, as Variant column stores NULLs itself.\n                /// We should create a null-map, insert NULL_DISCRIMINATOR on NULL values and filter initial column.\n                const auto & col_lc = assert_cast<const ColumnLowCardinality &>(*column);\n                const auto & indexes = col_lc.getIndexes();\n                auto null_index = col_lc.getDictionary().getNullValueIndex();\n                IColumn::Filter filter;\n                filter.reserve(col_lc.size());\n                auto discriminators = ColumnVariant::ColumnDiscriminators::create();\n                auto & discriminators_data = discriminators->getData();\n                discriminators_data.reserve(col_lc.size());\n                size_t variant_size_hint = 0;\n                for (size_t i = 0; i != col_lc.size(); ++i)\n                {\n                    if (indexes.getUInt(i) == null_index)\n                    {\n                        discriminators_data.push_back(ColumnVariant::NULL_DISCRIMINATOR);\n                        filter.push_back(0);\n                    }\n                    else\n                    {\n                        discriminators_data.push_back(variant_discr);\n                        filter.push_back(1);\n                        ++variant_size_hint;\n                    }\n                }\n\n                MutableColumnPtr variant_column;\n                /// If there were no NULLs, we can just clone the column.\n                if (variant_size_hint == col_lc.size())\n                    variant_column = IColumn::mutate(column);\n                /// Otherwise we should filter column.\n                else\n                    variant_column = column->filter(filter, variant_size_hint)->assumeMutable();\n\n                assert_cast<ColumnLowCardinality &>(*variant_column).nestedRemoveNullable();\n                return createVariantFromDescriptorsAndOneNonEmptyVariant(variant_types, std::move(discriminators), std::move(variant_column), variant_discr);\n            }\n            else\n            {\n                const auto & column = arguments.front().column;\n                auto discriminators = ColumnVariant::ColumnDiscriminators::create();\n                discriminators->getData().resize_fill(column->size(), variant_discr);\n                return createVariantFromDescriptorsAndOneNonEmptyVariant(variant_types, std::move(discriminators), column, variant_discr);\n            }\n        };\n    }\n\n    /// Wrapper for conversion to/from Variant type\n    WrapperType createVariantWrapper(const DataTypePtr & from_type, const DataTypePtr & to_type) const\n    {\n        if (const auto * from_variant = checkAndGetDataType<DataTypeVariant>(from_type.get()))\n        {\n            if (const auto * to_variant = checkAndGetDataType<DataTypeVariant>(to_type.get()))\n                return createVariantToVariantWrapper(*from_variant, *to_variant);\n\n            return createVariantToColumnWrapper(*from_variant, to_type);\n        }\n\n        return createColumnToVariantWrapper(from_type, assert_cast<const DataTypeVariant &>(*to_type));\n    }\n\n    WrapperType createDynamicToColumnWrapper(const DataTypePtr &) const\n    {\n        return [this]\n               (ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable *, size_t input_rows_count) -> ColumnPtr\n        {\n            /// When casting Dynamic to regular column we should cast all variants from current Dynamic column\n            /// and construct the result based on discriminators.\n            const auto & column_dynamic = assert_cast<const ColumnDynamic &>(*arguments.front().column.get());\n            const auto & variant_column = column_dynamic.getVariantColumn();\n            const auto & variant_info = column_dynamic.getVariantInfo();\n\n            /// First, cast usual variants to result type.\n            const auto & variant_types = assert_cast<const DataTypeVariant &>(*variant_info.variant_type).getVariants();\n            std::vector<ColumnPtr> casted_variant_columns;\n            casted_variant_columns.reserve(variant_types.size());\n            for (size_t i = 0; i != variant_types.size(); ++i)\n            {\n                /// Skip shared variant, it will be processed later.\n                if (i == column_dynamic.getSharedVariantDiscriminator())\n                {\n                    casted_variant_columns.push_back(nullptr);\n                    continue;\n                }\n\n                const auto & variant_col = variant_column.getVariantPtrByGlobalDiscriminator(i);\n                ColumnsWithTypeAndName variant = {{variant_col, variant_types[i], \"\"}};\n                WrapperType variant_wrapper;\n                if (cast_type == CastType::accurateOrNull)\n                    /// Create wrapper only if we support conversion from variant to the resulting type.\n                    variant_wrapper = createWrapperIfCanConvert(variant_types[i], result_type);\n                else\n                    variant_wrapper = prepareUnpackDictionaries(variant_types[i], result_type);\n\n                ColumnPtr casted_variant;\n                /// Check if we have wrapper for this variant.\n                if (variant_wrapper)\n                    casted_variant = variant_wrapper(variant, result_type, nullptr, variant_col->size());\n                casted_variant_columns.push_back(casted_variant);\n            }\n\n            /// Second, collect all variants stored in shared variant and cast them to result type.\n            std::vector<MutableColumnPtr> variant_columns_from_shared_variant;\n            DataTypes variant_types_from_shared_variant;\n            /// We will need to know what variant to use when we see discriminator of a shared variant.\n            /// To do it, we remember what variant was extracted from each row and what was it's offset.\n            PaddedPODArray<UInt64> shared_variant_indexes;\n            PaddedPODArray<UInt64> shared_variant_offsets;\n            std::unordered_map<String, UInt64> shared_variant_to_index;\n            const auto & shared_variant = column_dynamic.getSharedVariant();\n            const auto shared_variant_discr = column_dynamic.getSharedVariantDiscriminator();\n            const auto & local_discriminators = variant_column.getLocalDiscriminators();\n            const auto & offsets = variant_column.getOffsets();\n            if (!shared_variant.empty())\n            {\n                shared_variant_indexes.reserve(input_rows_count);\n                shared_variant_offsets.reserve(input_rows_count);\n                FormatSettings format_settings;\n                const auto shared_variant_local_discr = variant_column.localDiscriminatorByGlobal(shared_variant_discr);\n                for (size_t i = 0; i != input_rows_count; ++i)\n                {\n                    if (local_discriminators[i] == shared_variant_local_discr)\n                    {\n                        auto value = shared_variant.getDataAt(offsets[i]);\n                        ReadBufferFromMemory buf(value.data, value.size);\n                        auto type = decodeDataType(buf);\n                        auto type_name = type->getName();\n                        auto it = shared_variant_to_index.find(type_name);\n                        /// Check if we didn't create column for this variant yet.\n                        if (it == shared_variant_to_index.end())\n                        {\n                            it = shared_variant_to_index.emplace(type_name, variant_columns_from_shared_variant.size()).first;\n                            variant_columns_from_shared_variant.push_back(type->createColumn());\n                            variant_types_from_shared_variant.push_back(type);\n                        }\n\n                        shared_variant_indexes.push_back(it->second);\n                        shared_variant_offsets.push_back(variant_columns_from_shared_variant[it->second]->size());\n                        type->getDefaultSerialization()->deserializeBinary(*variant_columns_from_shared_variant[it->second], buf, format_settings);\n                    }\n                    else\n                    {\n                        shared_variant_indexes.emplace_back();\n                        shared_variant_offsets.emplace_back();\n                    }\n                }\n            }\n\n            /// Cast all extracted variants into result type.\n            std::vector<ColumnPtr> casted_shared_variant_columns;\n            casted_shared_variant_columns.reserve(variant_types_from_shared_variant.size());\n            for (size_t i = 0; i != variant_types_from_shared_variant.size(); ++i)\n            {\n                ColumnsWithTypeAndName variant = {{variant_columns_from_shared_variant[i]->getPtr(), variant_types_from_shared_variant[i], \"\"}};\n                WrapperType variant_wrapper;\n                if (cast_type == CastType::accurateOrNull)\n                    /// Create wrapper only if we support conversion from variant to the resulting type.\n                    variant_wrapper = createWrapperIfCanConvert(variant_types_from_shared_variant[i], result_type);\n                else\n                    variant_wrapper = prepareUnpackDictionaries(variant_types_from_shared_variant[i], result_type);\n\n                ColumnPtr casted_variant;\n                /// Check if we have wrapper for this variant.\n                if (variant_wrapper)\n                    casted_variant = variant_wrapper(variant, result_type, nullptr, variant_columns_from_shared_variant[i]->size());\n                casted_shared_variant_columns.push_back(casted_variant);\n            }\n\n            /// Construct result column from all casted variants.\n            auto res = result_type->createColumn();\n            res->reserve(input_rows_count);\n            for (size_t i = 0; i != input_rows_count; ++i)\n            {\n                auto global_discr = variant_column.globalDiscriminatorByLocal(local_discriminators[i]);\n                if (global_discr == ColumnVariant::NULL_DISCRIMINATOR)\n                {\n                    res->insertDefault();\n                }\n                else if (global_discr == shared_variant_discr)\n                {\n                    if (casted_shared_variant_columns[shared_variant_indexes[i]])\n                        res->insertFrom(*casted_shared_variant_columns[shared_variant_indexes[i]], shared_variant_offsets[i]);\n                    else\n                        res->insertDefault();\n                }\n                else\n                {\n                    if (casted_variant_columns[global_discr])\n                        res->insertFrom(*casted_variant_columns[global_discr], offsets[i]);\n                    else\n                        res->insertDefault();\n                }\n            }\n\n            return res;\n        };\n    }\n\n    WrapperType createStringToDynamicThroughParsingWrapper() const\n    {\n        return [&](ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable *, size_t input_rows_count) -> ColumnPtr\n        {\n            auto column = arguments[0].column->convertToFullColumnIfLowCardinality();\n            auto args = arguments;\n            args[0].column = column;\n\n            const ColumnNullable * column_nullable = nullptr;\n            if (isColumnNullable(*args[0].column))\n            {\n                column_nullable = assert_cast<const ColumnNullable *>(args[0].column.get());\n                args[0].column = column_nullable->getNestedColumnPtr();\n            }\n\n            args[0].type = removeNullable(removeLowCardinality(args[0].type));\n\n            if (cast_type == CastType::accurateOrNull)\n                return ConvertImplGenericFromString<false>::execute(args, result_type, column_nullable, input_rows_count, context);\n            return ConvertImplGenericFromString<true>::execute(args, result_type, column_nullable, input_rows_count, context);\n        };\n    }\n\n    WrapperType createVariantToDynamicWrapper(const DataTypeVariant & from_variant_type, const DataTypeDynamic & dynamic_type) const\n    {\n        /// First create extended Variant with shared variant type and cast this Variant to it.\n        auto variants_for_dynamic = from_variant_type.getVariants();\n        size_t number_of_variants = variants_for_dynamic.size();\n        variants_for_dynamic.push_back(ColumnDynamic::getSharedVariantDataType());\n        const auto & variant_type_for_dynamic = std::make_shared<DataTypeVariant>(variants_for_dynamic);\n        auto old_to_new_variant_wrapper = createVariantToVariantWrapper(from_variant_type, *variant_type_for_dynamic);\n        auto max_dynamic_types = dynamic_type.getMaxDynamicTypes();\n        return [old_to_new_variant_wrapper, variant_type_for_dynamic, number_of_variants, max_dynamic_types]\n               (ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable * col_nullable, size_t input_rows_count) -> ColumnPtr\n        {\n            auto variant_column_for_dynamic = old_to_new_variant_wrapper(arguments, result_type, col_nullable, input_rows_count);\n            /// If resulting Dynamic column can contain all variants from this Variant column, just create Dynamic column from it.\n            if (max_dynamic_types >= number_of_variants)\n                return ColumnDynamic::create(variant_column_for_dynamic, variant_type_for_dynamic, max_dynamic_types, max_dynamic_types);\n\n            /// Otherwise some variants should go to the shared variant. Create temporary Dynamic column from this Variant and insert\n            /// all data to the resulting Dynamic column, this insertion will do all the logic with shared variant.\n            auto tmp_dynamic_column = ColumnDynamic::create(variant_column_for_dynamic, variant_type_for_dynamic, number_of_variants, number_of_variants);\n            auto result_dynamic_column = ColumnDynamic::create(max_dynamic_types);\n            result_dynamic_column->insertRangeFrom(*tmp_dynamic_column, 0, tmp_dynamic_column->size());\n            return result_dynamic_column;\n        };\n    }\n\n    WrapperType createColumnToDynamicWrapper(const DataTypePtr & from_type, const DataTypeDynamic & dynamic_type) const\n    {\n        if (const auto * variant_type = typeid_cast<const DataTypeVariant *>(from_type.get()))\n            return createVariantToDynamicWrapper(*variant_type, dynamic_type);\n\n        if (context && context->getSettingsRef()[Setting::cast_string_to_dynamic_use_inference] && isStringOrFixedString(removeNullable(removeLowCardinality(from_type))))\n            return createStringToDynamicThroughParsingWrapper();\n\n        /// First, cast column to Variant with 2 variants - the type of the column we cast and shared variant type.\n        auto variant_type = std::make_shared<DataTypeVariant>(DataTypes{removeNullableOrLowCardinalityNullable(from_type)});\n        auto column_to_variant_wrapper = createColumnToVariantWrapper(from_type, *variant_type);\n        /// Second, cast this Variant to Dynamic.\n        auto variant_to_dynamic_wrapper = createVariantToDynamicWrapper(*variant_type, dynamic_type);\n        return [column_to_variant_wrapper, variant_to_dynamic_wrapper, variant_type]\n               (ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable * col_nullable, size_t input_rows_count) -> ColumnPtr\n        {\n            auto variant_res = column_to_variant_wrapper(arguments, variant_type, col_nullable, input_rows_count);\n            ColumnsWithTypeAndName args = {{variant_res, variant_type, \"\"}};\n            return variant_to_dynamic_wrapper(args, result_type, nullptr, input_rows_count);\n        };\n    }\n\n    WrapperType createDynamicToDynamicWrapper(const DataTypeDynamic & from_dynamic, const DataTypeDynamic & to_dynamic) const\n    {\n        size_t from_max_types = from_dynamic.getMaxDynamicTypes();\n        size_t to_max_types = to_dynamic.getMaxDynamicTypes();\n        if (from_max_types == to_max_types)\n            return createIdentityWrapper(from_dynamic.getPtr());\n\n        if (to_max_types > from_max_types)\n        {\n            return [to_max_types]\n                   (ColumnsWithTypeAndName & arguments, const DataTypePtr &, const ColumnNullable *, size_t) -> ColumnPtr\n            {\n                const auto & dynamic_column = assert_cast<const ColumnDynamic &>(*arguments[0].column);\n                /// We should use the same limit as already used in column and change only global limit.\n                /// It's needed because shared variant should contain values only when limit is exceeded,\n                /// so if there are already some data, we cannot increase the limit.\n                return ColumnDynamic::create(dynamic_column.getVariantColumnPtr(), dynamic_column.getVariantInfo(), dynamic_column.getMaxDynamicTypes(), to_max_types);\n            };\n        }\n\n        return [to_max_types]\n               (ColumnsWithTypeAndName & arguments, const DataTypePtr &, const ColumnNullable *, size_t) -> ColumnPtr\n        {\n            const auto & dynamic_column = assert_cast<const ColumnDynamic &>(*arguments[0].column);\n            /// If real limit in the column is not greater than desired, just use the same variant column.\n            if (dynamic_column.getMaxDynamicTypes() <= to_max_types)\n                return ColumnDynamic::create(dynamic_column.getVariantColumnPtr(), dynamic_column.getVariantInfo(), dynamic_column.getMaxDynamicTypes(), to_max_types);\n\n            /// Otherwise some variants should go to the shared variant. We try to keep the most frequent variants.\n            const auto & variant_info = dynamic_column.getVariantInfo();\n            const auto & variants = assert_cast<const DataTypeVariant &>(*variant_info.variant_type).getVariants();\n            const auto & statistics = dynamic_column.getStatistics();\n            const auto & variant_column = dynamic_column.getVariantColumn();\n            auto shared_variant_discr = dynamic_column.getSharedVariantDiscriminator();\n            std::vector<std::tuple<size_t, String, DataTypePtr>> variants_with_sizes;\n            variants_with_sizes.reserve(variant_info.variant_names.size());\n            for (const auto & [name, discr] : variant_info.variant_name_to_discriminator)\n            {\n                /// Don't include shared variant.\n                if (discr == shared_variant_discr)\n                    continue;\n\n                size_t size = variant_column.getVariantByGlobalDiscriminator(discr).size();\n                /// If column has statistics from the data part, use size from it for consistency.\n                /// It's important to keep the same dynamic structure of the result column during ALTER.\n                if (statistics)\n                {\n                    auto statistics_it = statistics->variants_statistics.find(name);\n                    if (statistics_it != statistics->variants_statistics.end())\n                        size = statistics_it->second;\n                }\n                variants_with_sizes.emplace_back(size, name, variants[discr]);\n            }\n\n            std::sort(variants_with_sizes.begin(), variants_with_sizes.end(), std::greater());\n            DataTypes result_variants;\n            result_variants.reserve(to_max_types + 1); /// +1 for shared variant.\n            /// Add new variants from sorted list until we reach to_max_types.\n            for (const auto & [size, name, type] : variants_with_sizes)\n            {\n                if (result_variants.size() < to_max_types)\n                    result_variants.push_back(type);\n                else\n                    break;\n            }\n\n            /// Add shared variant.\n            result_variants.push_back(ColumnDynamic::getSharedVariantDataType());\n            /// Create resulting Variant type and Dynamic column.\n            auto result_variant_type = std::make_shared<DataTypeVariant>(result_variants);\n            auto result_dynamic_column = ColumnDynamic::create(result_variant_type->createColumn(), result_variant_type, to_max_types, to_max_types);\n            const auto & result_variant_info = result_dynamic_column->getVariantInfo();\n            auto & result_variant_column = result_dynamic_column->getVariantColumn();\n            auto result_shared_variant_discr = result_dynamic_column->getSharedVariantDiscriminator();\n            /// Create mapping from old discriminators to the new ones.\n            std::vector<ColumnVariant::Discriminator> old_to_new_discriminators;\n            old_to_new_discriminators.resize(variant_info.variant_name_to_discriminator.size(), result_shared_variant_discr);\n            for (const auto & [name, discr] : result_variant_info.variant_name_to_discriminator)\n            {\n                auto old_discr = variant_info.variant_name_to_discriminator.at(name);\n                old_to_new_discriminators[old_discr] = discr;\n                /// Reuse old variant column if it's not shared variant.\n                if (discr != result_shared_variant_discr)\n                    result_variant_column.getVariantPtrByGlobalDiscriminator(discr) = variant_column.getVariantPtrByGlobalDiscriminator(old_discr);\n            }\n\n            const auto & local_discriminators = variant_column.getLocalDiscriminators();\n            const auto & offsets = variant_column.getOffsets();\n            const auto & shared_variant = dynamic_column.getSharedVariant();\n            auto & result_local_discriminators = result_variant_column.getLocalDiscriminators();\n            result_local_discriminators.reserve(local_discriminators.size());\n            auto & result_offsets = result_variant_column.getOffsets();\n            result_offsets.reserve(offsets.size());\n            auto & result_shared_variant = result_dynamic_column->getSharedVariant();\n            for (size_t i = 0; i != local_discriminators.size(); ++i)\n            {\n                auto global_discr = variant_column.globalDiscriminatorByLocal(local_discriminators[i]);\n                if (global_discr == ColumnVariant::NULL_DISCRIMINATOR)\n                {\n                    result_local_discriminators.push_back(ColumnVariant::NULL_DISCRIMINATOR);\n                    result_offsets.emplace_back();\n                }\n                else if (global_discr == shared_variant_discr)\n                {\n                    result_local_discriminators.push_back(result_variant_column.localDiscriminatorByGlobal(result_shared_variant_discr));\n                    result_offsets.push_back(result_shared_variant.size());\n                    result_shared_variant.insertFrom(shared_variant, offsets[i]);\n                }\n                else\n                {\n                    auto result_global_discr = old_to_new_discriminators[global_discr];\n                    if (result_global_discr == result_shared_variant_discr)\n                    {\n                        result_local_discriminators.push_back(result_variant_column.localDiscriminatorByGlobal(result_shared_variant_discr));\n                        result_offsets.push_back(result_shared_variant.size());\n                        ColumnDynamic::serializeValueIntoSharedVariant(\n                            result_shared_variant,\n                            variant_column.getVariantByGlobalDiscriminator(global_discr),\n                            variants[global_discr],\n                            variants[global_discr]->getDefaultSerialization(),\n                            offsets[i]);\n                    }\n                    else\n                    {\n                        result_local_discriminators.push_back(result_variant_column.localDiscriminatorByGlobal(result_global_discr));\n                        result_offsets.push_back(offsets[i]);\n                    }\n                }\n            }\n\n            return result_dynamic_column;\n        };\n    }\n\n    /// Wrapper for conversion to/from Dynamic type\n    WrapperType createDynamicWrapper(const DataTypePtr & from_type, const DataTypePtr & to_type) const\n    {\n        if (const auto * from_dynamic = checkAndGetDataType<DataTypeDynamic>(from_type.get()))\n        {\n            if (const auto * to_dynamic = checkAndGetDataType<DataTypeDynamic>(to_type.get()))\n                return createDynamicToDynamicWrapper(*from_dynamic, *to_dynamic);\n\n            return createDynamicToColumnWrapper(to_type);\n        }\n\n        return createColumnToDynamicWrapper(from_type, *checkAndGetDataType<DataTypeDynamic>(to_type.get()));\n    }\n\n    template <typename FieldType>\n    WrapperType createEnumWrapper(const DataTypePtr & from_type, const DataTypeEnum<FieldType> * to_type) const\n    {\n        using EnumType = DataTypeEnum<FieldType>;\n        using Function = typename FunctionTo<EnumType>::Type;\n\n        if (const auto * from_enum8 = checkAndGetDataType<DataTypeEnum8>(from_type.get()))\n            checkEnumToEnumConversion(from_enum8, to_type);\n        else if (const auto * from_enum16 = checkAndGetDataType<DataTypeEnum16>(from_type.get()))\n            checkEnumToEnumConversion(from_enum16, to_type);\n\n        if (checkAndGetDataType<DataTypeString>(from_type.get()))\n            return createStringToEnumWrapper<ColumnString, EnumType>();\n        else if (checkAndGetDataType<DataTypeFixedString>(from_type.get()))\n            return createStringToEnumWrapper<ColumnFixedString, EnumType>();\n        else if (isNativeNumber(from_type) || isEnum(from_type))\n        {\n            auto function = Function::create(context);\n            return createFunctionAdaptor(function, from_type);\n        }\n        else\n        {\n            if (cast_type == CastType::accurateOrNull)\n                return createToNullableColumnWrapper();\n            else\n                throw Exception(ErrorCodes::CANNOT_CONVERT_TYPE, \"Conversion from {} to {} is not supported\",\n                    from_type->getName(), to_type->getName());\n        }\n    }\n\n    template <typename EnumTypeFrom, typename EnumTypeTo>\n    void checkEnumToEnumConversion(const EnumTypeFrom * from_type, const EnumTypeTo * to_type) const\n    {\n        const auto & from_values = from_type->getValues();\n        const auto & to_values = to_type->getValues();\n\n        using ValueType = std::common_type_t<typename EnumTypeFrom::FieldType, typename EnumTypeTo::FieldType>;\n        using NameValuePair = std::pair<std::string, ValueType>;\n        using EnumValues = std::vector<NameValuePair>;\n\n        EnumValues name_intersection;\n        std::set_intersection(std::begin(from_values), std::end(from_values),\n            std::begin(to_values), std::end(to_values), std::back_inserter(name_intersection),\n            [] (auto && from, auto && to) { return from.first < to.first; });\n\n        for (const auto & name_value : name_intersection)\n        {\n            const auto & old_value = name_value.second;\n            const auto & new_value = to_type->getValue(name_value.first);\n            if (old_value != new_value)\n                throw Exception(ErrorCodes::CANNOT_CONVERT_TYPE, \"Enum conversion changes value for element '{}' from {} to {}\",\n                    name_value.first, toString(old_value), toString(new_value));\n        }\n    }\n\n    template <typename ColumnStringType, typename EnumType>\n    WrapperType createStringToEnumWrapper() const\n    {\n        const char * function_name = cast_name;\n        return [function_name] (\n            ColumnsWithTypeAndName & arguments, const DataTypePtr & res_type, const ColumnNullable * nullable_col, size_t /*input_rows_count*/)\n        {\n            const auto & first_col = arguments.front().column.get();\n            const auto & result_type = typeid_cast<const EnumType &>(*res_type);\n\n            const ColumnStringType * col = typeid_cast<const ColumnStringType *>(first_col);\n\n            if (col && nullable_col && nullable_col->size() != col->size())\n                throw Exception(ErrorCodes::LOGICAL_ERROR, \"ColumnNullable is not compatible with original\");\n\n            if (col)\n            {\n                const auto size = col->size();\n\n                auto res = result_type.createColumn();\n                auto & out_data = static_cast<typename EnumType::ColumnType &>(*res).getData();\n                out_data.resize(size);\n\n                auto default_enum_value = result_type.getValues().front().second;\n\n                if (nullable_col)\n                {\n                    for (size_t i = 0; i < size; ++i)\n                    {\n                        if (!nullable_col->isNullAt(i))\n                            out_data[i] = result_type.getValue(col->getDataAt(i));\n                        else\n                            out_data[i] = default_enum_value;\n                    }\n                }\n                else\n                {\n                    for (size_t i = 0; i < size; ++i)\n                        out_data[i] = result_type.getValue(col->getDataAt(i));\n                }\n\n                return res;\n            }\n            else\n                throw Exception(ErrorCodes::LOGICAL_ERROR, \"Unexpected column {} as first argument of function {}\",\n                    first_col->getName(), function_name);\n        };\n    }\n\n    template <typename EnumType>\n    WrapperType createEnumToStringWrapper() const\n    {\n        const char * function_name = cast_name;\n        return [function_name] (\n            ColumnsWithTypeAndName & arguments, const DataTypePtr & res_type, const ColumnNullable * nullable_col, size_t /*input_rows_count*/)\n        {\n            using ColumnEnumType = typename EnumType::ColumnType;\n\n            const auto & first_col = arguments.front().column.get();\n            const auto & first_type = arguments.front().type.get();\n\n            const ColumnEnumType * enum_col = typeid_cast<const ColumnEnumType *>(first_col);\n            const EnumType * enum_type = typeid_cast<const EnumType *>(first_type);\n\n            if (enum_col && nullable_col && nullable_col->size() != enum_col->size())\n                throw Exception(ErrorCodes::LOGICAL_ERROR, \"ColumnNullable is not compatible with original\");\n\n            if (enum_col && enum_type)\n            {\n                const auto size = enum_col->size();\n                const auto & enum_data = enum_col->getData();\n\n                auto res = res_type->createColumn();\n\n                if (nullable_col)\n                {\n                    for (size_t i = 0; i < size; ++i)\n                    {\n                        if (!nullable_col->isNullAt(i))\n                        {\n                            const auto & value = enum_type->getNameForValue(enum_data[i]);\n                            res->insertData(value.data, value.size);\n                        }\n                        else\n                            res->insertDefault();\n                    }\n                }\n                else\n                {\n                    for (size_t i = 0; i < size; ++i)\n                    {\n                        const auto & value = enum_type->getNameForValue(enum_data[i]);\n                        res->insertData(value.data, value.size);\n                    }\n                }\n\n                return res;\n            }\n            else\n                throw Exception(ErrorCodes::LOGICAL_ERROR, \"Unexpected column {} as first argument of function {}\",\n                    first_col->getName(), function_name);\n        };\n    }\n\n    static WrapperType createIdentityWrapper(const DataTypePtr &)\n    {\n        return [] (ColumnsWithTypeAndName & arguments, const DataTypePtr &, const ColumnNullable *, size_t /*input_rows_count*/)\n        {\n            return arguments.front().column;\n        };\n    }\n\n    static WrapperType createNothingWrapper(const IDataType * to_type)\n    {\n        ColumnPtr res = to_type->createColumnConstWithDefaultValue(1);\n        return [res] (ColumnsWithTypeAndName &, const DataTypePtr &, const ColumnNullable *, size_t input_rows_count)\n        {\n            /// Column of Nothing type is trivially convertible to any other column\n            return res->cloneResized(input_rows_count)->convertToFullColumnIfConst();\n        };\n    }\n\n    WrapperType prepareUnpackDictionaries(const DataTypePtr & from_type, const DataTypePtr & to_type) const\n    {\n        /// Conversion from/to Variant/Dynamic data type is processed in a special way.\n        /// We don't need to remove LowCardinality/Nullable.\n        if (isDynamic(to_type) || isDynamic(from_type))\n            return createDynamicWrapper(from_type, to_type);\n\n        if (isVariant(to_type) || isVariant(from_type))\n            return createVariantWrapper(from_type, to_type);\n\n        const auto * from_low_cardinality = typeid_cast<const DataTypeLowCardinality *>(from_type.get());\n        const auto * to_low_cardinality = typeid_cast<const DataTypeLowCardinality *>(to_type.get());\n        const auto & from_nested = from_low_cardinality ? from_low_cardinality->getDictionaryType() : from_type;\n        const auto & to_nested = to_low_cardinality ? to_low_cardinality->getDictionaryType() : to_type;\n\n        if (from_type->onlyNull())\n        {\n            if (!to_nested->isNullable() && !isVariant(to_type))\n            {\n                if (cast_type == CastType::accurateOrNull)\n                {\n                    return createToNullableColumnWrapper();\n                }\n                else\n                {\n                    throw Exception(ErrorCodes::CANNOT_CONVERT_TYPE, \"Cannot convert NULL to a non-nullable type\");\n                }\n            }\n\n            return [](ColumnsWithTypeAndName &, const DataTypePtr & result_type, const ColumnNullable *, size_t input_rows_count)\n            {\n                return result_type->createColumnConstWithDefaultValue(input_rows_count)->convertToFullColumnIfConst();\n            };\n        }\n\n        bool skip_not_null_check = false;\n\n        if (from_low_cardinality && from_nested->isNullable() && !to_nested->isNullable())\n            /// Disable check for dictionary. Will check that column doesn't contain NULL in wrapper below.\n            skip_not_null_check = true;\n\n        auto wrapper = prepareRemoveNullable(from_nested, to_nested, skip_not_null_check);\n        if (!from_low_cardinality && !to_low_cardinality)\n            return wrapper;\n\n        return [wrapper, from_low_cardinality, to_low_cardinality, skip_not_null_check]\n                (ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable * nullable_source, size_t input_rows_count) -> ColumnPtr\n        {\n            ColumnsWithTypeAndName args = {arguments[0]};\n            auto & arg = args.front();\n            auto res_type = result_type;\n\n            ColumnPtr converted_column;\n\n            ColumnPtr res_indexes;\n            /// For some types default can't be casted (for example, String to Int). In that case convert column to full.\n            bool src_converted_to_full_column = false;\n\n            {\n                auto tmp_rows_count = input_rows_count;\n\n                if (to_low_cardinality)\n                    res_type = to_low_cardinality->getDictionaryType();\n\n                if (from_low_cardinality)\n                {\n                    const auto & col_low_cardinality = typeid_cast<const ColumnLowCardinality &>(*arguments[0].column);\n\n                    if (skip_not_null_check && col_low_cardinality.containsNull())\n                        throw Exception(ErrorCodes::CANNOT_INSERT_NULL_IN_ORDINARY_COLUMN, \"Cannot convert NULL value to non-Nullable type\");\n\n                    arg.column = col_low_cardinality.getDictionary().getNestedColumn();\n                    arg.type = from_low_cardinality->getDictionaryType();\n\n                    /// TODO: Make map with defaults conversion.\n                    src_converted_to_full_column = !removeNullable(arg.type)->equals(*removeNullable(res_type));\n                    if (src_converted_to_full_column)\n                        arg.column = arg.column->index(col_low_cardinality.getIndexes(), 0);\n                    else\n                        res_indexes = col_low_cardinality.getIndexesPtr();\n\n                    tmp_rows_count = arg.column->size();\n                }\n\n                /// Perform the requested conversion.\n                converted_column = wrapper(args, res_type, nullable_source, tmp_rows_count);\n            }\n\n            if (to_low_cardinality)\n            {\n                auto res_column = to_low_cardinality->createColumn();\n                auto & col_low_cardinality = typeid_cast<ColumnLowCardinality &>(*res_column);\n\n                if (from_low_cardinality && !src_converted_to_full_column)\n                    col_low_cardinality.insertRangeFromDictionaryEncodedColumn(*converted_column, *res_indexes);\n                else\n                    col_low_cardinality.insertRangeFromFullColumn(*converted_column, 0, converted_column->size());\n\n                return res_column;\n            }\n            else if (!src_converted_to_full_column)\n                return converted_column->index(*res_indexes, 0);\n            else\n                return converted_column;\n        };\n    }\n\n    WrapperType prepareRemoveNullable(const DataTypePtr & from_type, const DataTypePtr & to_type, bool skip_not_null_check) const\n    {\n        /// Determine whether pre-processing and/or post-processing must take place during conversion.\n\n        bool source_is_nullable = from_type->isNullable();\n        bool result_is_nullable = to_type->isNullable();\n\n        auto wrapper = prepareImpl(removeNullable(from_type), removeNullable(to_type), result_is_nullable);\n\n        if (result_is_nullable)\n        {\n            return [wrapper, source_is_nullable]\n                (ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable *, size_t input_rows_count) -> ColumnPtr\n            {\n                /// Create a temporary columns on which to perform the operation.\n                const auto & nullable_type = static_cast<const DataTypeNullable &>(*result_type);\n                const auto & nested_type = nullable_type.getNestedType();\n\n                ColumnsWithTypeAndName tmp_args;\n                if (source_is_nullable)\n                    tmp_args = createBlockWithNestedColumns(arguments);\n                else\n                    tmp_args = arguments;\n\n                const ColumnNullable * nullable_source = nullptr;\n\n                /// Add original ColumnNullable for createStringToEnumWrapper()\n                if (source_is_nullable)\n                {\n                    if (arguments.size() != 1)\n                        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Invalid number of arguments\");\n                    nullable_source = typeid_cast<const ColumnNullable *>(arguments.front().column.get());\n                }\n\n                /// Perform the requested conversion.\n                auto tmp_res = wrapper(tmp_args, nested_type, nullable_source, input_rows_count);\n\n                /// May happen in fuzzy tests. For debug purpose.\n                if (!tmp_res)\n                    throw Exception(ErrorCodes::LOGICAL_ERROR, \"Couldn't convert {} to {} in prepareRemoveNullable wrapper.\",\n                                    arguments[0].type->getName(), nested_type->getName());\n\n                return wrapInNullable(tmp_res, arguments, nested_type, input_rows_count);\n            };\n        }\n        else if (source_is_nullable)\n        {\n            /// Conversion from Nullable to non-Nullable.\n\n            return [wrapper, skip_not_null_check]\n                (ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable *, size_t input_rows_count) -> ColumnPtr\n            {\n                auto tmp_args = createBlockWithNestedColumns(arguments);\n                auto nested_type = removeNullable(result_type);\n\n                /// Check that all values are not-NULL.\n                /// Check can be skipped in case if LowCardinality dictionary is transformed.\n                /// In that case, correctness will be checked beforehand.\n                if (!skip_not_null_check)\n                {\n                    const auto & col = arguments[0].column;\n                    const auto & nullable_col = assert_cast<const ColumnNullable &>(*col);\n                    const auto & null_map = nullable_col.getNullMapData();\n\n                    if (!memoryIsZero(null_map.data(), 0, null_map.size()))\n                        throw Exception(ErrorCodes::CANNOT_INSERT_NULL_IN_ORDINARY_COLUMN, \"Cannot convert NULL value to non-Nullable type\");\n                }\n                const ColumnNullable * nullable_source = typeid_cast<const ColumnNullable *>(arguments.front().column.get());\n                return wrapper(tmp_args, nested_type, nullable_source, input_rows_count);\n            };\n        }\n        else\n            return wrapper;\n    }\n\n    /// 'from_type' and 'to_type' are nested types in case of Nullable.\n    /// 'requested_result_is_nullable' is true if CAST to Nullable type is requested.\n    WrapperType prepareImpl(const DataTypePtr & from_type, const DataTypePtr & to_type, bool requested_result_is_nullable) const\n    {\n        if (isUInt8(from_type) && isBool(to_type))\n            return createUInt8ToBoolWrapper(from_type, to_type);\n\n        /// We can cast IPv6 into IPv6, IPv4 into IPv4, but we should not allow to cast FixedString(16) into IPv6 as part of identity cast\n        bool safe_convert_custom_types = true;\n\n        if (const auto * to_type_custom_name = to_type->getCustomName())\n            safe_convert_custom_types = from_type->getCustomName() && from_type->getCustomName()->getName() == to_type_custom_name->getName();\n        else if (const auto * from_type_custom_name = from_type->getCustomName())\n            safe_convert_custom_types = to_type->getCustomName() && from_type_custom_name->getName() == to_type->getCustomName()->getName();\n\n        if (from_type->equals(*to_type) && safe_convert_custom_types)\n        {\n            /// We can only use identity conversion for DataTypeAggregateFunction when they are strictly equivalent.\n            if (typeid_cast<const DataTypeAggregateFunction *>(from_type.get()))\n            {\n                if (DataTypeAggregateFunction::strictEquals(from_type, to_type))\n                    return createIdentityWrapper(from_type);\n            }\n            else\n                return createIdentityWrapper(from_type);\n        }\n        else if (WhichDataType(from_type).isNothing())\n            return createNothingWrapper(to_type.get());\n\n        WrapperType ret;\n\n        auto make_default_wrapper = [&](const auto & types) -> bool\n        {\n            using Types = std::decay_t<decltype(types)>;\n            using ToDataType = typename Types::LeftType;\n\n            if constexpr (is_any_of<ToDataType,\n                DataTypeUInt16, DataTypeUInt32, DataTypeUInt64, DataTypeUInt128, DataTypeUInt256,\n                DataTypeInt8, DataTypeInt16, DataTypeInt32, DataTypeInt64, DataTypeInt128, DataTypeInt256,\n                DataTypeFloat32, DataTypeFloat64,\n                DataTypeDate, DataTypeDate32, DataTypeDateTime,\n                DataTypeUUID, DataTypeIPv4, DataTypeIPv6>)\n            {\n                ret = createWrapper(from_type, checkAndGetDataType<ToDataType>(to_type.get()), requested_result_is_nullable);\n                return true;\n            }\n            if constexpr (std::is_same_v<ToDataType, DataTypeUInt8>)\n            {\n                if (isBool(to_type))\n                    ret = createBoolWrapper<ToDataType>(from_type, checkAndGetDataType<ToDataType>(to_type.get()), requested_result_is_nullable);\n                else\n                    ret = createWrapper(from_type, checkAndGetDataType<ToDataType>(to_type.get()), requested_result_is_nullable);\n                return true;\n            }\n            if constexpr (\n                std::is_same_v<ToDataType, DataTypeEnum8> ||\n                std::is_same_v<ToDataType, DataTypeEnum16>)\n            {\n                ret = createEnumWrapper(from_type, checkAndGetDataType<ToDataType>(to_type.get()));\n                return true;\n            }\n            if constexpr (is_any_of<ToDataType,\n                DataTypeDecimal<Decimal32>, DataTypeDecimal<Decimal64>,\n                DataTypeDecimal<Decimal128>, DataTypeDecimal<Decimal256>,\n                DataTypeDateTime64>)\n            {\n                ret = createDecimalWrapper(from_type, checkAndGetDataType<ToDataType>(to_type.get()), requested_result_is_nullable);\n                return true;\n            }\n\n            return false;\n        };\n\n        bool cast_ipv4_ipv6_default_on_conversion_error_value = context && context->getSettingsRef()[Setting::cast_ipv4_ipv6_default_on_conversion_error];\n        bool input_format_ipv4_default_on_conversion_error_value = context && context->getSettingsRef()[Setting::input_format_ipv4_default_on_conversion_error];\n        bool input_format_ipv6_default_on_conversion_error_value = context && context->getSettingsRef()[Setting::input_format_ipv6_default_on_conversion_error];\n\n        auto make_custom_serialization_wrapper = [&, cast_ipv4_ipv6_default_on_conversion_error_value, input_format_ipv4_default_on_conversion_error_value, input_format_ipv6_default_on_conversion_error_value](const auto & types) -> bool\n        {\n            using Types = std::decay_t<decltype(types)>;\n            using ToDataType = typename Types::RightType;\n            using FromDataType = typename Types::LeftType;\n\n            if constexpr (WhichDataType(FromDataType::type_id).isStringOrFixedString())\n            {\n                if constexpr (std::is_same_v<ToDataType, DataTypeIPv4>)\n                {\n                    ret = [cast_ipv4_ipv6_default_on_conversion_error_value,\n                           input_format_ipv4_default_on_conversion_error_value,\n                           requested_result_is_nullable](\n                              ColumnsWithTypeAndName & arguments,\n                              const DataTypePtr & result_type,\n                              const ColumnNullable * column_nullable,\n                              size_t) -> ColumnPtr\n                    {\n                        if (!WhichDataType(result_type).isIPv4())\n                            throw Exception(ErrorCodes::TYPE_MISMATCH, \"Wrong result type {}. Expected IPv4\", result_type->getName());\n\n                        const auto * null_map = column_nullable ? &column_nullable->getNullMapData() : nullptr;\n                        if (requested_result_is_nullable)\n                            return convertToIPv4<IPStringToNumExceptionMode::Null>(arguments[0].column, null_map);\n                        else if (cast_ipv4_ipv6_default_on_conversion_error_value || input_format_ipv4_default_on_conversion_error_value)\n                            return convertToIPv4<IPStringToNumExceptionMode::Default>(arguments[0].column, null_map);\n                        else\n                            return convertToIPv4<IPStringToNumExceptionMode::Throw>(arguments[0].column, null_map);\n                    };\n\n                    return true;\n                }\n\n                if constexpr (std::is_same_v<ToDataType, DataTypeIPv6>)\n                {\n                    ret = [cast_ipv4_ipv6_default_on_conversion_error_value,\n                           input_format_ipv6_default_on_conversion_error_value,\n                           requested_result_is_nullable](\n                              ColumnsWithTypeAndName & arguments,\n                              const DataTypePtr & result_type,\n                              const ColumnNullable * column_nullable,\n                              size_t) -> ColumnPtr\n                    {\n                        if (!WhichDataType(result_type).isIPv6())\n                            throw Exception(\n                                ErrorCodes::TYPE_MISMATCH, \"Wrong result type {}. Expected IPv6\", result_type->getName());\n\n                        const auto * null_map = column_nullable ? &column_nullable->getNullMapData() : nullptr;\n                        if (requested_result_is_nullable)\n                            return convertToIPv6<IPStringToNumExceptionMode::Null>(arguments[0].column, null_map);\n                        else if (cast_ipv4_ipv6_default_on_conversion_error_value || input_format_ipv6_default_on_conversion_error_value)\n                            return convertToIPv6<IPStringToNumExceptionMode::Default>(arguments[0].column, null_map);\n                        else\n                            return convertToIPv6<IPStringToNumExceptionMode::Throw>(arguments[0].column, null_map);\n                    };\n\n                    return true;\n                }\n\n                if (to_type->getCustomSerialization() && to_type->getCustomName())\n                {\n                    ret = [requested_result_is_nullable, this](\n                              ColumnsWithTypeAndName & arguments,\n                              const DataTypePtr & result_type,\n                              const ColumnNullable * column_nullable,\n                              size_t input_rows_count) -> ColumnPtr\n                    {\n                        auto wrapped_result_type = result_type;\n                        if (requested_result_is_nullable)\n                            wrapped_result_type = makeNullable(result_type);\n                        if (this->cast_type == CastType::accurateOrNull)\n                            return ConvertImplGenericFromString<false>::execute(\n                                arguments, wrapped_result_type, column_nullable, input_rows_count, context);\n                        return ConvertImplGenericFromString<true>::execute(\n                            arguments, wrapped_result_type, column_nullable, input_rows_count, context);\n                    };\n                    return true;\n                }\n            }\n            else if constexpr (WhichDataType(FromDataType::type_id).isIPv6() && WhichDataType(ToDataType::type_id).isIPv4())\n            {\n                ret = [cast_ipv4_ipv6_default_on_conversion_error_value, requested_result_is_nullable](\n                                ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable * column_nullable, size_t)\n                        -> ColumnPtr\n                {\n                    if (!WhichDataType(result_type).isIPv4())\n                        throw Exception(\n                            ErrorCodes::TYPE_MISMATCH, \"Wrong result type {}. Expected IPv4\", result_type->getName());\n\n                    const auto * null_map = column_nullable ? &column_nullable->getNullMapData() : nullptr;\n                    if (requested_result_is_nullable)\n                        return convertIPv6ToIPv4<IPStringToNumExceptionMode::Null>(arguments[0].column, null_map);\n                    else if (cast_ipv4_ipv6_default_on_conversion_error_value)\n                        return convertIPv6ToIPv4<IPStringToNumExceptionMode::Default>(arguments[0].column, null_map);\n                    else\n                        return convertIPv6ToIPv4<IPStringToNumExceptionMode::Throw>(arguments[0].column, null_map);\n                };\n\n                return true;\n            }\n\n            if constexpr (WhichDataType(ToDataType::type_id).isStringOrFixedString())\n            {\n                if constexpr (WhichDataType(FromDataType::type_id).isEnum())\n                {\n                    ret = createEnumToStringWrapper<FromDataType>();\n                    return true;\n                }\n                else if (from_type->getCustomSerialization())\n                {\n                    ret = [this](ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable *, size_t input_rows_count) -> ColumnPtr\n                    {\n                        return ConvertImplGenericToString<typename ToDataType::ColumnType>::execute(arguments, result_type, input_rows_count, context);\n                    };\n                    return true;\n                }\n            }\n\n            return false;\n        };\n\n        if (callOnTwoTypeIndexes(from_type->getTypeId(), to_type->getTypeId(), make_custom_serialization_wrapper))\n            return ret;\n\n        if (callOnIndexAndDataType<void>(to_type->getTypeId(), make_default_wrapper))\n            return ret;\n\n        switch (to_type->getTypeId())\n        {\n            case TypeIndex::String:\n                return createStringWrapper(from_type);\n            case TypeIndex::FixedString:\n                return createFixedStringWrapper(from_type, checkAndGetDataType<DataTypeFixedString>(to_type.get())->getN());\n            case TypeIndex::Array:\n                return createArrayWrapper(from_type, static_cast<const DataTypeArray &>(*to_type));\n            case TypeIndex::Tuple:\n                return createTupleWrapper(from_type, checkAndGetDataType<DataTypeTuple>(to_type.get()));\n            case TypeIndex::Map:\n                return createMapWrapper(from_type, checkAndGetDataType<DataTypeMap>(to_type.get()));\n            case TypeIndex::ObjectDeprecated:\n                return createObjectDeprecatedWrapper(from_type, checkAndGetDataType<DataTypeObjectDeprecated>(to_type.get()));\n            case TypeIndex::Object:\n                return createObjectWrapper(from_type, checkAndGetDataType<DataTypeObject>(to_type.get()));\n            case TypeIndex::AggregateFunction:\n                return createAggregateFunctionWrapper(from_type, checkAndGetDataType<DataTypeAggregateFunction>(to_type.get()));\n            case TypeIndex::Interval:\n                return createIntervalWrapper(from_type, checkAndGetDataType<DataTypeInterval>(to_type.get())->getKind());\n            default:\n                break;\n        }\n\n        if (cast_type == CastType::accurateOrNull)\n            return createToNullableColumnWrapper();\n        else\n            throw Exception(ErrorCodes::CANNOT_CONVERT_TYPE, \"Conversion from {} to {} is not supported\",\n                from_type->getName(), to_type->getName());\n    }\n};\n\n}\n\n\nFunctionBasePtr createFunctionBaseCast(\n    ContextPtr context,\n    const char * name,\n    const ColumnsWithTypeAndName & arguments,\n    const DataTypePtr & return_type,\n    std::optional<CastDiagnostic> diagnostic,\n    CastType cast_type)\n{\n    DataTypes data_types(arguments.size());\n\n    for (size_t i = 0; i < arguments.size(); ++i)\n        data_types[i] = arguments[i].type;\n\n    FunctionCast::MonotonicityForRange monotonicity;\n\n    if (isEnum(arguments.front().type)\n        && castTypeToEither<DataTypeEnum8, DataTypeEnum16>(return_type.get(), [&](auto & type)\n        {\n            monotonicity = FunctionTo<std::decay_t<decltype(type)>>::Type::Monotonic::get;\n            return true;\n        }))\n    {\n    }\n    else if (castTypeToEither<\n        DataTypeUInt8, DataTypeUInt16, DataTypeUInt32, DataTypeUInt64, DataTypeUInt128, DataTypeUInt256,\n        DataTypeInt8, DataTypeInt16, DataTypeInt32, DataTypeInt64, DataTypeInt128, DataTypeInt256,\n        DataTypeFloat32, DataTypeFloat64,\n        DataTypeDate, DataTypeDate32, DataTypeDateTime, DataTypeDateTime64,\n        DataTypeString>(return_type.get(), [&](auto & type)\n        {\n            monotonicity = FunctionTo<std::decay_t<decltype(type)>>::Type::Monotonic::get;\n            return true;\n        }))\n    {\n    }\n\n    return std::make_unique<FunctionCast>(context, name, std::move(monotonicity), data_types, return_type, diagnostic, cast_type);\n}\n\nREGISTER_FUNCTION(Conversion)\n{\n    factory.registerFunction<FunctionToUInt8>();\n    factory.registerFunction<FunctionToUInt16>();\n    factory.registerFunction<FunctionToUInt32>();\n    factory.registerFunction<FunctionToUInt64>();\n    factory.registerFunction<FunctionToUInt128>();\n    factory.registerFunction<FunctionToUInt256>();\n    factory.registerFunction<FunctionToInt8>();\n    factory.registerFunction<FunctionToInt16>();\n    factory.registerFunction<FunctionToInt32>();\n    factory.registerFunction<FunctionToInt64>();\n    factory.registerFunction<FunctionToInt128>();\n    factory.registerFunction<FunctionToInt256>();\n    factory.registerFunction<FunctionToFloat32>();\n    factory.registerFunction<FunctionToFloat64>();\n\n    factory.registerFunction<FunctionToDecimal32>();\n    factory.registerFunction<FunctionToDecimal64>();\n    factory.registerFunction<FunctionToDecimal128>();\n    factory.registerFunction<FunctionToDecimal256>();\n\n    factory.registerFunction<FunctionToDate>();\n\n    /// MySQL compatibility alias. Cannot be registered as alias,\n    /// because we don't want it to be normalized to toDate in queries,\n    /// otherwise CREATE DICTIONARY query breaks.\n    factory.registerFunction(\"DATE\", &FunctionToDate::create, {}, FunctionFactory::Case::Insensitive);\n\n    factory.registerFunction<FunctionToDate32>();\n    factory.registerFunction<FunctionToDateTime>();\n    factory.registerFunction<FunctionToDateTime32>();\n    factory.registerFunction<FunctionToDateTime64>();\n    factory.registerFunction<FunctionToUUID>();\n    factory.registerFunction<FunctionToIPv4>();\n    factory.registerFunction<FunctionToIPv6>();\n    factory.registerFunction<FunctionToString>();\n\n    factory.registerFunction<FunctionToUnixTimestamp>();\n    factory.registerFunction<FunctionToUnixTimestampEx>();\n\n    factory.registerFunction<FunctionToUInt8OrZero>();\n    factory.registerFunction<FunctionToUInt16OrZero>();\n    factory.registerFunction<FunctionToUInt32OrZero>();\n    factory.registerFunction<FunctionToUInt64OrZero>();\n    factory.registerFunction<FunctionToUInt128OrZero>();\n    factory.registerFunction<FunctionToUInt256OrZero>();\n    factory.registerFunction<FunctionToInt8OrZero>();\n    factory.registerFunction<FunctionToInt16OrZero>();\n    factory.registerFunction<FunctionToInt32OrZero>();\n    factory.registerFunction<FunctionToInt64OrZero>();\n    factory.registerFunction<FunctionToInt128OrZero>();\n    factory.registerFunction<FunctionToInt256OrZero>();\n    factory.registerFunction<FunctionToFloat32OrZero>();\n    factory.registerFunction<FunctionToFloat64OrZero>();\n    factory.registerFunction<FunctionToDateOrZero>();\n    factory.registerFunction<FunctionToDate32OrZero>();\n    factory.registerFunction<FunctionToDateTimeOrZero>();\n    factory.registerFunction<FunctionToDateTime64OrZero>();\n\n    factory.registerFunction<FunctionToDecimal32OrZero>();\n    factory.registerFunction<FunctionToDecimal64OrZero>();\n    factory.registerFunction<FunctionToDecimal128OrZero>();\n    factory.registerFunction<FunctionToDecimal256OrZero>();\n\n    factory.registerFunction<FunctionToUUIDOrZero>();\n    factory.registerFunction<FunctionToIPv4OrZero>();\n    factory.registerFunction<FunctionToIPv6OrZero>();\n\n    factory.registerFunction<FunctionToUInt8OrNull>();\n    factory.registerFunction<FunctionToUInt16OrNull>();\n    factory.registerFunction<FunctionToUInt32OrNull>();\n    factory.registerFunction<FunctionToUInt64OrNull>();\n    factory.registerFunction<FunctionToUInt128OrNull>();\n    factory.registerFunction<FunctionToUInt256OrNull>();\n    factory.registerFunction<FunctionToInt8OrNull>();\n    factory.registerFunction<FunctionToInt16OrNull>();\n    factory.registerFunction<FunctionToInt32OrNull>();\n    factory.registerFunction<FunctionToInt64OrNull>();\n    factory.registerFunction<FunctionToInt128OrNull>();\n    factory.registerFunction<FunctionToInt256OrNull>();\n    factory.registerFunction<FunctionToFloat32OrNull>();\n    factory.registerFunction<FunctionToFloat64OrNull>();\n    factory.registerFunction<FunctionToDateOrNull>();\n    factory.registerFunction<FunctionToDate32OrNull>();\n    factory.registerFunction<FunctionToDateTimeOrNull>();\n    factory.registerFunction<FunctionToDateTime64OrNull>();\n\n    factory.registerFunction<FunctionToDecimal32OrNull>();\n    factory.registerFunction<FunctionToDecimal64OrNull>();\n    factory.registerFunction<FunctionToDecimal128OrNull>();\n    factory.registerFunction<FunctionToDecimal256OrNull>();\n\n    factory.registerFunction<FunctionToUUIDOrNull>();\n    factory.registerFunction<FunctionToIPv4OrNull>();\n    factory.registerFunction<FunctionToIPv6OrNull>();\n\n    factory.registerFunction<FunctionParseDateTimeBestEffort>();\n    factory.registerFunction<FunctionParseDateTimeBestEffortOrZero>();\n    factory.registerFunction<FunctionParseDateTimeBestEffortOrNull>();\n    factory.registerFunction<FunctionParseDateTimeBestEffortUS>();\n    factory.registerFunction<FunctionParseDateTimeBestEffortUSOrZero>();\n    factory.registerFunction<FunctionParseDateTimeBestEffortUSOrNull>();\n    factory.registerFunction<FunctionParseDateTime32BestEffort>();\n    factory.registerFunction<FunctionParseDateTime32BestEffortOrZero>();\n    factory.registerFunction<FunctionParseDateTime32BestEffortOrNull>();\n    factory.registerFunction<FunctionParseDateTime64BestEffort>();\n    factory.registerFunction<FunctionParseDateTime64BestEffortOrZero>();\n    factory.registerFunction<FunctionParseDateTime64BestEffortOrNull>();\n    factory.registerFunction<FunctionParseDateTime64BestEffortUS>();\n    factory.registerFunction<FunctionParseDateTime64BestEffortUSOrZero>();\n    factory.registerFunction<FunctionParseDateTime64BestEffortUSOrNull>();",
        "b_contents": "",
        "base_contents": "    else /*if constexpr (is_integral_v<typename DataType::FieldType>)*/\n        return tryReadIntText(x, rb);\n}\n\ntemplate <>\ninline bool tryParseImpl<DataTypeDate>(DataTypeDate::FieldType & x, ReadBuffer & rb, const DateLUTImpl * time_zone, bool)\n{\n    DayNum tmp(0);\n    if (!tryReadDateText(tmp, rb, *time_zone))\n        return false;\n    x = tmp;\n    return true;\n}\n\ntemplate <>\ninline bool tryParseImpl<DataTypeDate32>(DataTypeDate32::FieldType & x, ReadBuffer & rb, const DateLUTImpl * time_zone, bool)\n{\n    ExtendedDayNum tmp(0);\n    if (!tryReadDateText(tmp, rb, *time_zone))\n        return false;\n    x = tmp;\n    return true;\n}\n\ntemplate <>\ninline bool tryParseImpl<DataTypeDateTime>(DataTypeDateTime::FieldType & x, ReadBuffer & rb, const DateLUTImpl * time_zone, bool)\n{\n    time_t time = 0;\n    if (!tryReadDateTimeText(time, rb, *time_zone))\n        return false;\n    convertFromTime<DataTypeDateTime>(x, time);\n    return true;\n}\n\ntemplate <>\ninline bool tryParseImpl<DataTypeUUID>(DataTypeUUID::FieldType & x, ReadBuffer & rb, const DateLUTImpl *, bool)\n{\n    UUID tmp;\n    if (!tryReadUUIDText(tmp, rb))\n        return false;\n\n    x = tmp.toUnderType();\n    return true;\n}\n\ntemplate <>\ninline bool tryParseImpl<DataTypeIPv4>(DataTypeIPv4::FieldType & x, ReadBuffer & rb, const DateLUTImpl *, bool)\n{\n    IPv4 tmp;\n    if (!tryReadIPv4Text(tmp, rb))\n        return false;\n\n    x = tmp.toUnderType();\n    return true;\n}\n\ntemplate <>\ninline bool tryParseImpl<DataTypeIPv6>(DataTypeIPv6::FieldType & x, ReadBuffer & rb, const DateLUTImpl *, bool)\n{\n    IPv6 tmp;\n    if (!tryReadIPv6Text(tmp, rb))\n        return false;\n\n    x = tmp;\n    return true;\n}\n\n\n/** Throw exception with verbose message when string value is not parsed completely.\n  */\n[[noreturn]] inline void throwExceptionForIncompletelyParsedValue(ReadBuffer & read_buffer, const IDataType & result_type)\n{\n    WriteBufferFromOwnString message_buf;\n    message_buf << \"Cannot parse string \" << quote << String(read_buffer.buffer().begin(), read_buffer.buffer().size())\n                << \" as \" << result_type.getName()\n                << \": syntax error\";\n\n    if (read_buffer.offset())\n        message_buf << \" at position \" << read_buffer.offset()\n                    << \" (parsed just \" << quote << String(read_buffer.buffer().begin(), read_buffer.offset()) << \")\";\n    else\n        message_buf << \" at begin of string\";\n\n    // Currently there are no functions toIPv{4,6}Or{Null,Zero}\n    if (isNativeNumber(result_type) && !(result_type.getName() == \"IPv4\" || result_type.getName() == \"IPv6\"))\n        message_buf << \". Note: there are to\" << result_type.getName() << \"OrZero and to\" << result_type.getName() << \"OrNull functions, which returns zero/NULL instead of throwing exception.\";\n\n    throw Exception(PreformattedMessage{message_buf.str(), \"Cannot parse string {} as {}: syntax error {}\", {String(read_buffer.buffer().begin(), read_buffer.buffer().size()), result_type.getName()}}, ErrorCodes::CANNOT_PARSE_TEXT);\n}\n\n\nenum class ConvertFromStringExceptionMode : uint8_t\n{\n    Throw,  /// Throw exception if value cannot be parsed.\n    Zero,   /// Fill with zero or default if value cannot be parsed.\n    Null    /// Return ColumnNullable with NULLs when value cannot be parsed.\n};\n\nenum class ConvertFromStringParsingMode : uint8_t\n{\n    Normal,\n    BestEffort,  /// Only applicable for DateTime. Will use sophisticated method, that is slower.\n    BestEffortUS\n};\n\nstruct AccurateConvertStrategyAdditions\n{\n    UInt32 scale { 0 };\n};\n\nstruct AccurateOrNullConvertStrategyAdditions\n{\n    UInt32 scale { 0 };\n};\n\ntemplate <typename FromDataType, typename ToDataType, typename Name,\n    ConvertFromStringExceptionMode exception_mode, ConvertFromStringParsingMode parsing_mode>\nstruct ConvertThroughParsing\n{\n    static_assert(std::is_same_v<FromDataType, DataTypeString> || std::is_same_v<FromDataType, DataTypeFixedString>,\n        \"ConvertThroughParsing is only applicable for String or FixedString data types\");\n\n    static constexpr bool to_datetime64 = std::is_same_v<ToDataType, DataTypeDateTime64>;\n\n    static bool isAllRead(ReadBuffer & in)\n    {\n        /// In case of FixedString, skip zero bytes at end.\n        if constexpr (std::is_same_v<FromDataType, DataTypeFixedString>)\n            while (!in.eof() && *in.position() == 0)\n                ++in.position();\n\n        if (in.eof())\n            return true;\n\n        /// Special case, that allows to parse string with DateTime or DateTime64 as Date or Date32.\n        if constexpr (std::is_same_v<ToDataType, DataTypeDate> || std::is_same_v<ToDataType, DataTypeDate32>)\n        {\n            if (!in.eof() && (*in.position() == ' ' || *in.position() == 'T'))\n            {\n                if (in.buffer().size() == strlen(\"YYYY-MM-DD hh:mm:ss\"))\n                    return true;\n\n                if (in.buffer().size() >= strlen(\"YYYY-MM-DD hh:mm:ss.x\")\n                    && in.buffer().begin()[19] == '.')\n                {\n                    in.position() = in.buffer().begin() + 20;\n\n                    while (!in.eof() && isNumericASCII(*in.position()))\n                        ++in.position();\n\n                    if (in.eof())\n                        return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    template <typename Additions = void *>\n    static ColumnPtr execute(const ColumnsWithTypeAndName & arguments, const DataTypePtr & res_type, size_t input_rows_count,\n                        Additions additions [[maybe_unused]] = Additions())\n    {\n        using ColVecTo = typename ToDataType::ColumnType;\n\n        const DateLUTImpl * local_time_zone [[maybe_unused]] = nullptr;\n        const DateLUTImpl * utc_time_zone [[maybe_unused]] = nullptr;\n\n        /// For conversion to Date or DateTime type, second argument with time zone could be specified.\n        if constexpr (std::is_same_v<ToDataType, DataTypeDateTime> || to_datetime64)\n        {\n            const auto result_type = removeNullable(res_type);\n            // Time zone is already figured out during result type resolution, no need to do it here.\n            if (const auto dt_col = checkAndGetDataType<ToDataType>(result_type.get()))\n                local_time_zone = &dt_col->getTimeZone();\n            else\n                local_time_zone = &extractTimeZoneFromFunctionArguments(arguments, 1, 0);\n\n            if constexpr (parsing_mode == ConvertFromStringParsingMode::BestEffort || parsing_mode == ConvertFromStringParsingMode::BestEffortUS)\n                utc_time_zone = &DateLUT::instance(\"UTC\");\n        }\n        else if constexpr (std::is_same_v<ToDataType, DataTypeDate> || std::is_same_v<ToDataType, DataTypeDate32>)\n        {\n            // Timezone is more or less dummy when parsing Date/Date32 from string.\n            local_time_zone = &DateLUT::instance();\n            utc_time_zone = &DateLUT::instance(\"UTC\");\n        }\n\n        const IColumn * col_from = arguments[0].column.get();\n        const ColumnString * col_from_string = checkAndGetColumn<ColumnString>(col_from);\n        const ColumnFixedString * col_from_fixed_string = checkAndGetColumn<ColumnFixedString>(col_from);\n\n        if (std::is_same_v<FromDataType, DataTypeString> && !col_from_string)\n            throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of first argument of function {}\",\n                col_from->getName(), Name::name);\n\n        if (std::is_same_v<FromDataType, DataTypeFixedString> && !col_from_fixed_string)\n            throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of first argument of function {}\",\n                col_from->getName(), Name::name);\n\n        size_t size = input_rows_count;\n        typename ColVecTo::MutablePtr col_to = nullptr;\n\n        if constexpr (IsDataTypeDecimal<ToDataType>)\n        {\n            UInt32 scale = additions;\n            if constexpr (to_datetime64)\n            {\n                ToDataType check_bounds_in_ctor(scale, local_time_zone ? local_time_zone->getTimeZone() : String{});\n            }\n            else\n            {\n                ToDataType check_bounds_in_ctor(ToDataType::maxPrecision(), scale);\n            }\n            col_to = ColVecTo::create(size, scale);\n        }\n        else\n            col_to = ColVecTo::create(size);\n\n        typename ColVecTo::Container & vec_to = col_to->getData();\n\n        ColumnUInt8::MutablePtr col_null_map_to;\n        ColumnUInt8::Container * vec_null_map_to [[maybe_unused]] = nullptr;\n        if constexpr (exception_mode == ConvertFromStringExceptionMode::Null)\n        {\n            col_null_map_to = ColumnUInt8::create(size);\n            vec_null_map_to = &col_null_map_to->getData();\n        }\n\n        const ColumnString::Chars * chars = nullptr;\n        const IColumn::Offsets * offsets = nullptr;\n        size_t fixed_string_size = 0;\n\n        if constexpr (std::is_same_v<FromDataType, DataTypeString>)\n        {\n            chars = &col_from_string->getChars();\n            offsets = &col_from_string->getOffsets();\n        }\n        else\n        {\n            chars = &col_from_fixed_string->getChars();\n            fixed_string_size = col_from_fixed_string->getN();\n        }\n\n        size_t current_offset = 0;\n\n        bool precise_float_parsing = false;\n\n        if (DB::CurrentThread::isInitialized())\n        {\n            const DB::ContextPtr query_context = DB::CurrentThread::get().getQueryContext();\n\n            if (query_context)\n                precise_float_parsing = query_context->getSettingsRef()[Setting::precise_float_parsing];\n        }\n\n        for (size_t i = 0; i < size; ++i)\n        {\n            size_t next_offset = std::is_same_v<FromDataType, DataTypeString> ? (*offsets)[i] : (current_offset + fixed_string_size);\n            size_t string_size = std::is_same_v<FromDataType, DataTypeString> ? next_offset - current_offset - 1 : fixed_string_size;\n\n            ReadBufferFromMemory read_buffer(chars->data() + current_offset, string_size);\n\n            if constexpr (exception_mode == ConvertFromStringExceptionMode::Throw)\n            {\n                if constexpr (parsing_mode == ConvertFromStringParsingMode::BestEffort)\n                {\n                    if constexpr (to_datetime64)\n                    {\n                        DateTime64 res = 0;\n                        parseDateTime64BestEffort(res, col_to->getScale(), read_buffer, *local_time_zone, *utc_time_zone);\n                        vec_to[i] = res;\n                    }\n                    else\n                    {\n                        time_t res;\n                        parseDateTimeBestEffort(res, read_buffer, *local_time_zone, *utc_time_zone);\n                        convertFromTime<ToDataType>(vec_to[i], res);\n                    }\n                }\n                else if constexpr (parsing_mode == ConvertFromStringParsingMode::BestEffortUS)\n                {\n                    if constexpr (to_datetime64)\n                    {\n                        DateTime64 res = 0;\n                        parseDateTime64BestEffortUS(res, col_to->getScale(), read_buffer, *local_time_zone, *utc_time_zone);\n                        vec_to[i] = res;\n                    }\n                    else\n                    {\n                        time_t res;\n                        parseDateTimeBestEffortUS(res, read_buffer, *local_time_zone, *utc_time_zone);\n                        convertFromTime<ToDataType>(vec_to[i], res);\n                    }\n                }\n                else\n                {\n                    if constexpr (to_datetime64)\n                    {\n                        DateTime64 value = 0;\n                        readDateTime64Text(value, col_to->getScale(), read_buffer, *local_time_zone);\n                        vec_to[i] = value;\n                    }\n                    else if constexpr (IsDataTypeDecimal<ToDataType>)\n                    {\n                        SerializationDecimal<typename ToDataType::FieldType>::readText(\n                            vec_to[i], read_buffer, ToDataType::maxPrecision(), col_to->getScale());\n                    }\n                    else\n                    {\n                        /// we want to utilize constexpr condition here, which is not mixable with value comparison\n                        do\n                        {\n                            if constexpr (std::is_same_v<FromDataType, DataTypeFixedString> && std::is_same_v<ToDataType, DataTypeIPv6>)\n                            {\n                                if (fixed_string_size == IPV6_BINARY_LENGTH)\n                                {\n                                    readBinary(vec_to[i], read_buffer);\n                                    break;\n                                }\n                            }\n                            if constexpr (std::is_same_v<Additions, AccurateConvertStrategyAdditions>)\n                            {\n                                if (!tryParseImpl<ToDataType>(vec_to[i], read_buffer, local_time_zone, precise_float_parsing))\n                                    throw Exception(ErrorCodes::CANNOT_PARSE_TEXT, \"Cannot parse string to type {}\", TypeName<typename ToDataType::FieldType>);\n                            }\n                            else\n                                parseImpl<ToDataType>(vec_to[i], read_buffer, local_time_zone, precise_float_parsing);\n                        } while (false);\n                    }\n                }\n\n                if (!isAllRead(read_buffer))\n                    throwExceptionForIncompletelyParsedValue(read_buffer, *res_type);\n            }\n            else\n            {\n                bool parsed;\n\n                if constexpr (parsing_mode == ConvertFromStringParsingMode::BestEffort)\n                {\n                    if constexpr (to_datetime64)\n                    {\n                        DateTime64 res = 0;\n                        parsed = tryParseDateTime64BestEffort(res, col_to->getScale(), read_buffer, *local_time_zone, *utc_time_zone);\n                        vec_to[i] = res;\n                    }\n                    else\n                    {\n                        time_t res;\n                        parsed = tryParseDateTimeBestEffort(res, read_buffer, *local_time_zone, *utc_time_zone);\n                        convertFromTime<ToDataType>(vec_to[i],res);\n                    }\n                }\n                else if constexpr (parsing_mode == ConvertFromStringParsingMode::BestEffortUS)\n                {\n                    if constexpr (to_datetime64)\n                    {\n                        DateTime64 res = 0;\n                        parsed = tryParseDateTime64BestEffortUS(res, col_to->getScale(), read_buffer, *local_time_zone, *utc_time_zone);\n                        vec_to[i] = res;\n                    }\n                    else\n                    {\n                        time_t res;\n                        parsed = tryParseDateTimeBestEffortUS(res, read_buffer, *local_time_zone, *utc_time_zone);\n                        convertFromTime<ToDataType>(vec_to[i],res);\n                    }\n                }\n                else\n                {\n                    if constexpr (to_datetime64)\n                    {\n                        DateTime64 value = 0;\n                        parsed = tryReadDateTime64Text(value, col_to->getScale(), read_buffer, *local_time_zone);\n                        vec_to[i] = value;\n                    }\n                    else if constexpr (IsDataTypeDecimal<ToDataType>)\n                    {\n                        parsed = SerializationDecimal<typename ToDataType::FieldType>::tryReadText(\n                            vec_to[i], read_buffer, ToDataType::maxPrecision(), col_to->getScale());\n                    }\n                    else if (std::is_same_v<FromDataType, DataTypeFixedString> && std::is_same_v<ToDataType, DataTypeIPv6>\n                            && fixed_string_size == IPV6_BINARY_LENGTH)\n                    {\n                        readBinary(vec_to[i], read_buffer);\n                        parsed = true;\n                    }\n                    else\n                    {\n                        parsed = tryParseImpl<ToDataType>(vec_to[i], read_buffer, local_time_zone, precise_float_parsing);\n                    }\n                }\n\n                if (!isAllRead(read_buffer))\n                    parsed = false;\n\n                if (!parsed)\n                {\n                    if constexpr (std::is_same_v<ToDataType, DataTypeDate32>)\n                    {\n                        vec_to[i] = -static_cast<Int32>(DateLUT::instance().getDayNumOffsetEpoch()); /// NOLINT(readability-static-accessed-through-instance)\n                    }\n                    else\n                    {\n                        vec_to[i] = static_cast<typename ToDataType::FieldType>(0);\n                    }\n                }\n\n                if constexpr (exception_mode == ConvertFromStringExceptionMode::Null)\n                    (*vec_null_map_to)[i] = !parsed;\n            }\n\n            current_offset = next_offset;\n        }\n\n        if constexpr (exception_mode == ConvertFromStringExceptionMode::Null)\n            return ColumnNullable::create(std::move(col_to), std::move(col_null_map_to));\n        else\n            return col_to;\n    }\n};\n\n\n/// Function toUnixTimestamp has exactly the same implementation as toDateTime of String type.\nstruct NameToUnixTimestamp { static constexpr auto name = \"toUnixTimestamp\"; };\n\nenum class BehaviourOnErrorFromString : uint8_t\n{\n    ConvertDefaultBehaviorTag,\n    ConvertReturnNullOnErrorTag,\n    ConvertReturnZeroOnErrorTag\n};\n\n/** Conversion of number types to each other, enums to numbers, dates and datetimes to numbers and back: done by straight assignment.\n  *  (Date is represented internally as number of days from some day; DateTime - as unix timestamp)\n  */\ntemplate <typename FromDataType, typename ToDataType, typename Name,\n    FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior = default_date_time_overflow_behavior>\nstruct ConvertImpl\n{\n    template <typename Additions = void *>\n    static ColumnPtr NO_SANITIZE_UNDEFINED execute(\n        const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type [[maybe_unused]], size_t input_rows_count,\n        BehaviourOnErrorFromString from_string_tag [[maybe_unused]], Additions additions = Additions())\n    {\n        const ColumnWithTypeAndName & named_from = arguments[0];\n\n        if constexpr ((std::is_same_v<FromDataType, ToDataType> && !FromDataType::is_parametric)\n            || (std::is_same_v<FromDataType, DataTypeEnum8> && std::is_same_v<ToDataType, DataTypeInt8>)\n            || (std::is_same_v<FromDataType, DataTypeEnum16> && std::is_same_v<ToDataType, DataTypeInt16>))\n        {\n            /// If types are the same, reuse the columns.\n            /// Conversions between Enum and the underlying type are also free.\n            return named_from.column;\n        }\n        else if constexpr ((std::is_same_v<FromDataType, DataTypeDateTime> || std::is_same_v<FromDataType, DataTypeDate32>)\n            && std::is_same_v<ToDataType, DataTypeDate>)\n        {\n            /// Conversion of DateTime to Date: throw off time component.\n            /// Conversion of Date32 to Date.\n            return DateTimeTransformImpl<FromDataType, ToDataType, ToDateImpl<date_time_overflow_behavior>, false>::template execute<Additions>(\n                arguments, result_type, input_rows_count);\n        }\n        else if constexpr (std::is_same_v<FromDataType, DataTypeDateTime> && std::is_same_v<ToDataType, DataTypeDate32>)\n        {\n            /// Conversion of DateTime to Date: throw off time component.\n            return DateTimeTransformImpl<FromDataType, ToDataType, ToDate32Impl, false>::template execute<Additions>(\n                arguments, result_type, input_rows_count);\n        }\n        else if constexpr ((std::is_same_v<FromDataType, DataTypeDate> || std::is_same_v<FromDataType, DataTypeDate32>)\n            && std::is_same_v<ToDataType, DataTypeDateTime>)\n        {\n            /// Conversion from Date/Date32 to DateTime.\n            return DateTimeTransformImpl<FromDataType, ToDataType, ToDateTimeImpl<date_time_overflow_behavior>, false>::template execute<Additions>(\n                arguments, result_type, input_rows_count);\n        }\n        else if constexpr (std::is_same_v<FromDataType, DataTypeDateTime64> && std::is_same_v<ToDataType, DataTypeDate32>)\n        {\n            return DateTimeTransformImpl<DataTypeDateTime64, DataTypeDate32, TransformDateTime64<ToDate32Impl>, false>::template execute<Additions>(\n                arguments, result_type, input_rows_count, additions);\n        }\n        /** Special case of converting Int8, Int16, (U)Int32 or (U)Int64 (and also, for convenience,\n          * Float32, Float64) to Date. If the\n          * number is less than 65536, then it is treated as DayNum, and if it's greater or equals to 65536,\n          * then treated as unix timestamp. If the number exceeds UInt32, saturate to MAX_UINT32 then as DayNum.\n          * It's a bit illogical, as we actually have two functions in one.\n          * But allows to support frequent case,\n          *  when user write toDate(UInt32), expecting conversion of unix timestamp to Date.\n          *  (otherwise such usage would be frequent mistake).\n          */\n        else if constexpr ((\n                std::is_same_v<FromDataType, DataTypeUInt32>\n                || std::is_same_v<FromDataType, DataTypeUInt64>)\n            && std::is_same_v<ToDataType, DataTypeDate>)\n        {\n            return DateTimeTransformImpl<FromDataType, ToDataType, ToDateTransform32Or64<typename FromDataType::FieldType, default_date_time_overflow_behavior>, false>::template execute<Additions>(\n                arguments, result_type, input_rows_count);\n        }\n        else if constexpr ((\n                std::is_same_v<FromDataType, DataTypeInt8>\n                || std::is_same_v<FromDataType, DataTypeInt16>)\n            && std::is_same_v<ToDataType, DataTypeDate>)\n        {\n            return DateTimeTransformImpl<FromDataType, ToDataType, ToDateTransform8Or16Signed<typename FromDataType::FieldType, default_date_time_overflow_behavior>, false>::template execute<Additions>(\n                arguments, result_type, input_rows_count);\n        }\n        else if constexpr ((\n                std::is_same_v<FromDataType, DataTypeInt32>\n                || std::is_same_v<FromDataType, DataTypeInt64>\n                || std::is_same_v<FromDataType, DataTypeFloat32>\n                || std::is_same_v<FromDataType, DataTypeFloat64>)\n            && std::is_same_v<ToDataType, DataTypeDate>)\n        {\n            return DateTimeTransformImpl<FromDataType, ToDataType, ToDateTransform32Or64Signed<typename FromDataType::FieldType, default_date_time_overflow_behavior>, false>::template execute<Additions>(\n                arguments, result_type, input_rows_count);\n        }\n        else if constexpr ((\n                std::is_same_v<FromDataType, DataTypeUInt32>\n                || std::is_same_v<FromDataType, DataTypeUInt64>)\n            && std::is_same_v<ToDataType, DataTypeDate32>)\n        {\n            return DateTimeTransformImpl<FromDataType, ToDataType, ToDate32Transform32Or64<typename FromDataType::FieldType, default_date_time_overflow_behavior>, false>::template execute<Additions>(\n                arguments, result_type, input_rows_count);\n        }\n        else if constexpr ((\n                std::is_same_v<FromDataType, DataTypeInt8>\n                || std::is_same_v<FromDataType, DataTypeInt16>)\n            && std::is_same_v<ToDataType, DataTypeDate32>)\n        {\n            return DateTimeTransformImpl<FromDataType, ToDataType, ToDate32Transform8Or16Signed<typename FromDataType::FieldType>, false>::template execute<Additions>(\n                arguments, result_type, input_rows_count);\n        }\n        else if constexpr ((\n                std::is_same_v<FromDataType, DataTypeInt32>\n                || std::is_same_v<FromDataType, DataTypeInt64>\n                || std::is_same_v<FromDataType, DataTypeFloat32>\n                || std::is_same_v<FromDataType, DataTypeFloat64>)\n            && std::is_same_v<ToDataType, DataTypeDate32>)\n        {\n            return DateTimeTransformImpl<FromDataType, ToDataType, ToDate32Transform32Or64Signed<typename FromDataType::FieldType, default_date_time_overflow_behavior>, false>::template execute<Additions>(\n                arguments, result_type, input_rows_count);\n        }\n        /// Special case of converting Int8, Int16, Int32 or (U)Int64 (and also, for convenience, Float32, Float64) to DateTime.\n        else if constexpr ((\n                std::is_same_v<FromDataType, DataTypeInt8>\n                || std::is_same_v<FromDataType, DataTypeInt16>\n                || std::is_same_v<FromDataType, DataTypeInt32>)\n            && std::is_same_v<ToDataType, DataTypeDateTime>)\n        {\n            return DateTimeTransformImpl<FromDataType, ToDataType, ToDateTimeTransformSigned<typename FromDataType::FieldType, UInt32, default_date_time_overflow_behavior>, false>::template execute<Additions>(\n                arguments, result_type, input_rows_count);\n        }\n        else if constexpr (std::is_same_v<FromDataType, DataTypeUInt64>\n            && std::is_same_v<ToDataType, DataTypeDateTime>)\n        {\n            return DateTimeTransformImpl<FromDataType, ToDataType, ToDateTimeTransform64<typename FromDataType::FieldType, UInt32, default_date_time_overflow_behavior>, false>::template execute<Additions>(\n                arguments, result_type, input_rows_count);\n        }\n        else if constexpr ((\n                std::is_same_v<FromDataType, DataTypeInt64>\n                || std::is_same_v<FromDataType, DataTypeFloat32>\n                || std::is_same_v<FromDataType, DataTypeFloat64>)\n            && std::is_same_v<ToDataType, DataTypeDateTime>)\n        {\n            return DateTimeTransformImpl<FromDataType, ToDataType, ToDateTimeTransform64Signed<typename FromDataType::FieldType, UInt32, default_date_time_overflow_behavior>, false>::template execute<Additions>(\n                arguments, result_type, input_rows_count);\n        }\n        else if constexpr ((\n                std::is_same_v<FromDataType, DataTypeInt8>\n                || std::is_same_v<FromDataType, DataTypeInt16>\n                || std::is_same_v<FromDataType, DataTypeInt32>\n                || std::is_same_v<FromDataType, DataTypeInt64>)\n            && std::is_same_v<ToDataType, DataTypeDateTime64>)\n        {\n            return DateTimeTransformImpl<FromDataType, ToDataType, ToDateTime64TransformSigned<typename FromDataType::FieldType, default_date_time_overflow_behavior>, false>::template execute<Additions>(\n                arguments, result_type, input_rows_count, additions);\n        }\n        else if constexpr (std::is_same_v<FromDataType, DataTypeUInt64>\n            && std::is_same_v<ToDataType, DataTypeDateTime64>)\n        {\n            return DateTimeTransformImpl<FromDataType, ToDataType, ToDateTime64TransformUnsigned<UInt64, default_date_time_overflow_behavior>, false>::template execute<Additions>(\n                arguments, result_type, input_rows_count, additions);\n        }\n        else if constexpr ((\n                std::is_same_v<FromDataType, DataTypeFloat32>\n                || std::is_same_v<FromDataType, DataTypeFloat64>)\n            && std::is_same_v<ToDataType, DataTypeDateTime64>)\n        {\n            return DateTimeTransformImpl<FromDataType, ToDataType, ToDateTime64TransformFloat<FromDataType, typename FromDataType::FieldType, default_date_time_overflow_behavior>, false>::template execute<Additions>(\n                arguments, result_type, input_rows_count, additions);\n        }\n        /// Conversion of DateTime64 to Date or DateTime: discards fractional part.\n        else if constexpr (std::is_same_v<FromDataType, DataTypeDateTime64>\n            && std::is_same_v<ToDataType, DataTypeDate>)\n        {\n            return DateTimeTransformImpl<FromDataType, ToDataType, TransformDateTime64<ToDateImpl<date_time_overflow_behavior>>, false>::template execute<Additions>(\n                arguments, result_type, input_rows_count, additions);\n        }\n        else if constexpr (std::is_same_v<FromDataType, DataTypeDateTime64>\n            && std::is_same_v<ToDataType, DataTypeDateTime>)\n        {\n            return DateTimeTransformImpl<FromDataType, ToDataType, TransformDateTime64<ToDateTimeImpl<date_time_overflow_behavior>>, false>::template execute<Additions>(\n                arguments, result_type, input_rows_count, additions);\n        }\n        /// Conversion of Date or DateTime to DateTime64: add zero sub-second part.\n        else if constexpr ((\n                std::is_same_v<FromDataType, DataTypeDate>\n                || std::is_same_v<FromDataType, DataTypeDate32>\n                || std::is_same_v<FromDataType, DataTypeDateTime>)\n            && std::is_same_v<ToDataType, DataTypeDateTime64>)\n        {\n            return DateTimeTransformImpl<FromDataType, ToDataType, ToDateTime64Transform, false>::template execute<Additions>(\n                arguments, result_type, input_rows_count, additions);\n        }\n        else if constexpr (IsDataTypeDateOrDateTime<FromDataType>\n            && std::is_same_v<ToDataType, DataTypeString>)\n        {\n            /// Date or DateTime to String\n\n            using FromFieldType = typename FromDataType::FieldType;\n            using ColVecType = ColumnVectorOrDecimal<FromFieldType>;\n\n            auto datetime_arg = arguments[0];\n\n            const DateLUTImpl * time_zone = nullptr;\n            const ColumnConst * time_zone_column = nullptr;\n\n            if (arguments.size() == 1)\n            {\n                auto non_null_args = createBlockWithNestedColumns(arguments);\n                time_zone = &extractTimeZoneFromFunctionArguments(non_null_args, 1, 0);\n            }\n            else /// When we have a column for timezone\n            {\n                datetime_arg.column = datetime_arg.column->convertToFullColumnIfConst();\n\n                if constexpr (std::is_same_v<FromDataType, DataTypeDate> || std::is_same_v<FromDataType, DataTypeDate32>)\n                    time_zone = &DateLUT::instance();\n                /// For argument of Date or DateTime type, second argument with time zone could be specified.\n                if constexpr (std::is_same_v<FromDataType, DataTypeDateTime> || std::is_same_v<FromDataType, DataTypeDateTime64>)\n                {\n                    if ((time_zone_column = checkAndGetColumnConst<ColumnString>(arguments[1].column.get())))\n                    {\n                        auto non_null_args = createBlockWithNestedColumns(arguments);\n                        time_zone = &extractTimeZoneFromFunctionArguments(non_null_args, 1, 0);\n                    }\n                }\n            }\n            const auto & col_with_type_and_name = columnGetNested(datetime_arg);\n\n            if (const auto col_from = checkAndGetColumn<ColVecType>(col_with_type_and_name.column.get()))\n            {\n                auto col_to = ColumnString::create();\n\n                const typename ColVecType::Container & vec_from = col_from->getData();\n                ColumnString::Chars & data_to = col_to->getChars();\n                ColumnString::Offsets & offsets_to = col_to->getOffsets();\n                size_t size = vec_from.size();\n\n                if constexpr (std::is_same_v<FromDataType, DataTypeDate>)\n                    data_to.resize(size * (strlen(\"YYYY-MM-DD\") + 1));\n                else if constexpr (std::is_same_v<FromDataType, DataTypeDate32>)\n                    data_to.resize(size * (strlen(\"YYYY-MM-DD\") + 1));\n                else if constexpr (std::is_same_v<FromDataType, DataTypeDateTime>)\n                    data_to.resize(size * (strlen(\"YYYY-MM-DD hh:mm:ss\") + 1));\n                else if constexpr (std::is_same_v<FromDataType, DataTypeDateTime64>)\n                    data_to.resize(size * (strlen(\"YYYY-MM-DD hh:mm:ss.\") + col_from->getScale() + 1));\n                else\n                    data_to.resize(size * 3);   /// Arbitrary\n\n                offsets_to.resize(size);\n\n                WriteBufferFromVector<ColumnString::Chars> write_buffer(data_to);\n                const FromDataType & type = static_cast<const FromDataType &>(*col_with_type_and_name.type);\n\n                ColumnUInt8::MutablePtr null_map = copyNullMap(datetime_arg.column);\n\n                bool cut_trailing_zeros_align_to_groups_of_thousands = false;\n                if (DB::CurrentThread::isInitialized())\n                {\n                    const DB::ContextPtr query_context = DB::CurrentThread::get().getQueryContext();\n\n                    if (query_context)\n                        cut_trailing_zeros_align_to_groups_of_thousands = query_context->getSettingsRef()[Setting::date_time_64_output_format_cut_trailing_zeros_align_to_groups_of_thousands];\n                }\n\n                if (!null_map && arguments.size() > 1)\n                    null_map = copyNullMap(arguments[1].column->convertToFullColumnIfConst());\n\n                if (null_map)\n                {\n                    for (size_t i = 0; i < size; ++i)\n                    {\n                        if (!time_zone_column && arguments.size() > 1)\n                        {\n                            if (!arguments[1].column.get()->getDataAt(i).toString().empty())\n                                time_zone = &DateLUT::instance(arguments[1].column.get()->getDataAt(i).toString());\n                            else\n                                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Provided time zone must be non-empty\");\n                        }\n                        bool is_ok = true;\n                        if constexpr (std::is_same_v<FromDataType, DataTypeDateTime64>)\n                        {\n                            if (cut_trailing_zeros_align_to_groups_of_thousands)\n                                writeDateTimeTextCutTrailingZerosAlignToGroupOfThousands(DateTime64(vec_from[i]), type.getScale(), write_buffer, *time_zone);\n                            else\n                                is_ok = FormatImpl<FromDataType>::template execute<bool>(vec_from[i], write_buffer, &type, time_zone);\n                        }\n                        else\n                        {\n                            is_ok = FormatImpl<FromDataType>::template execute<bool>(vec_from[i], write_buffer, &type, time_zone);\n                        }\n                        null_map->getData()[i] |= !is_ok;\n                        writeChar(0, write_buffer);\n                        offsets_to[i] = write_buffer.count();\n                    }\n                }\n                else\n                {\n                    for (size_t i = 0; i < size; ++i)\n                    {\n                        if (!time_zone_column && arguments.size() > 1)\n                        {\n                            if (!arguments[1].column.get()->getDataAt(i).toString().empty())\n                                time_zone = &DateLUT::instance(arguments[1].column.get()->getDataAt(i).toString());\n                            else\n                                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Provided time zone must be non-empty\");\n                        }\n                        if constexpr (std::is_same_v<FromDataType, DataTypeDateTime64>)\n                        {\n                            if (cut_trailing_zeros_align_to_groups_of_thousands)\n                                writeDateTimeTextCutTrailingZerosAlignToGroupOfThousands(DateTime64(vec_from[i]), type.getScale(), write_buffer, *time_zone);\n                            else\n                                FormatImpl<FromDataType>::template execute<bool>(vec_from[i], write_buffer, &type, time_zone);\n                        }\n                        else\n                        {\n                            FormatImpl<FromDataType>::template execute<bool>(vec_from[i], write_buffer, &type, time_zone);\n                        }\n                        writeChar(0, write_buffer);\n                        offsets_to[i] = write_buffer.count();\n                    }\n                }\n\n                write_buffer.finalize();\n\n                if (null_map)\n                    return ColumnNullable::create(std::move(col_to), std::move(null_map));\n                return col_to;\n            }\n            else\n                throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of first argument of function {}\",\n                        arguments[0].column->getName(), Name::name);\n        }\n        /// Conversion from FixedString to String.\n        /// Cutting sequences of zero bytes from end of strings.\n        else if constexpr (std::is_same_v<ToDataType, DataTypeString>\n            && std::is_same_v<FromDataType, DataTypeFixedString>)\n        {\n            ColumnUInt8::MutablePtr null_map = copyNullMap(arguments[0].column);\n            const auto & nested =  columnGetNested(arguments[0]);\n            if (const ColumnFixedString * col_from = checkAndGetColumn<ColumnFixedString>(nested.column.get()))\n            {\n                auto col_to = ColumnString::create();\n\n                const ColumnFixedString::Chars & data_from = col_from->getChars();\n                ColumnString::Chars & data_to = col_to->getChars();\n                ColumnString::Offsets & offsets_to = col_to->getOffsets();\n                size_t size = col_from->size();\n                size_t n = col_from->getN();\n                data_to.resize(size * (n + 1)); /// + 1 - zero terminator\n                offsets_to.resize(size);\n\n                size_t offset_from = 0;\n                size_t offset_to = 0;\n                for (size_t i = 0; i < size; ++i)\n                {\n                    if (!null_map || !null_map->getData()[i])\n                    {\n                        size_t bytes_to_copy = n;\n                        while (bytes_to_copy > 0 && data_from[offset_from + bytes_to_copy - 1] == 0)\n                            --bytes_to_copy;\n\n                        memcpy(&data_to[offset_to], &data_from[offset_from], bytes_to_copy);\n                        offset_to += bytes_to_copy;\n                    }\n                    data_to[offset_to] = 0;\n                    ++offset_to;\n                    offsets_to[i] = offset_to;\n                    offset_from += n;\n                }\n\n                data_to.resize(offset_to);\n                if (result_type->isNullable() && null_map)\n                    return ColumnNullable::create(std::move(col_to), std::move(null_map));\n                return col_to;\n            }\n            else\n                throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of first argument of function {}\",\n                        arguments[0].column->getName(), Name::name);\n        }\n        else if constexpr (std::is_same_v<ToDataType, DataTypeString>)\n        {\n            /// Anything else to String.\n\n            using FromFieldType = typename FromDataType::FieldType;\n            using ColVecType = ColumnVectorOrDecimal<FromFieldType>;\n\n            ColumnUInt8::MutablePtr null_map = copyNullMap(arguments[0].column);\n\n            const auto & col_with_type_and_name = columnGetNested(arguments[0]);\n            const auto & type = static_cast<const FromDataType &>(*col_with_type_and_name.type);\n\n            if (const auto col_from = checkAndGetColumn<ColVecType>(col_with_type_and_name.column.get()))\n            {\n                auto col_to = ColumnString::create();\n\n                const typename ColVecType::Container & vec_from = col_from->getData();\n                ColumnString::Chars & data_to = col_to->getChars();\n                ColumnString::Offsets & offsets_to = col_to->getOffsets();\n                size_t size = vec_from.size();\n\n                data_to.resize(size * 3);\n                offsets_to.resize(size);\n\n                WriteBufferFromVector<ColumnString::Chars> write_buffer(data_to);\n\n                if (null_map)\n                {\n                    for (size_t i = 0; i < size; ++i)\n                    {\n                        bool is_ok = FormatImpl<FromDataType>::template execute<bool>(vec_from[i], write_buffer, &type, nullptr);\n                        /// We don't use timezones in this branch\n                        null_map->getData()[i] |= !is_ok;\n                        writeChar(0, write_buffer);\n                        offsets_to[i] = write_buffer.count();\n                    }\n                }\n                else\n                {\n                    for (size_t i = 0; i < size; ++i)\n                    {\n                        FormatImpl<FromDataType>::template execute<void>(vec_from[i], write_buffer, &type, nullptr);\n                        writeChar(0, write_buffer);\n                        offsets_to[i] = write_buffer.count();\n                    }\n                }\n\n                write_buffer.finalize();\n\n                if (null_map)\n                    return ColumnNullable::create(std::move(col_to), std::move(null_map));\n                return col_to;\n            }\n            else\n                throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of first argument of function {}\",\n                        arguments[0].column->getName(), Name::name);\n        }\n        else if constexpr (std::is_same_v<Name, NameToUnixTimestamp>\n            && std::is_same_v<FromDataType, DataTypeString>\n            && std::is_same_v<ToDataType, DataTypeUInt32>)\n        {\n            return ConvertImpl<FromDataType, DataTypeDateTime, Name, date_time_overflow_behavior>::template execute<Additions>(\n                arguments, result_type, input_rows_count, from_string_tag);\n        }\n        else if constexpr ((std::is_same_v<FromDataType, DataTypeString> || std::is_same_v<FromDataType, DataTypeFixedString>))\n        {\n            switch (from_string_tag)\n            {\n            case BehaviourOnErrorFromString::ConvertDefaultBehaviorTag:\n                return ConvertThroughParsing<FromDataType,\n                                             ToDataType,\n                                             Name,\n                                             ConvertFromStringExceptionMode::Throw,\n                                             ConvertFromStringParsingMode::Normal>::execute(\n                        arguments, result_type, input_rows_count, additions);\n            case BehaviourOnErrorFromString::ConvertReturnNullOnErrorTag:\n                return ConvertThroughParsing<FromDataType,\n                                             ToDataType,\n                                             Name,\n                                             ConvertFromStringExceptionMode::Null,\n                                             ConvertFromStringParsingMode::Normal>::execute(\n                        arguments, result_type, input_rows_count, additions);\n            case BehaviourOnErrorFromString::ConvertReturnZeroOnErrorTag:\n                return ConvertThroughParsing<FromDataType,\n                                             ToDataType,\n                                             Name,\n                                             ConvertFromStringExceptionMode::Zero,\n                                             ConvertFromStringParsingMode::Normal>::execute(\n                        arguments, result_type, input_rows_count, additions);\n            }\n        }\n        else if constexpr (std::is_same_v<FromDataType, DataTypeInterval> && std::is_same_v<ToDataType, DataTypeInterval>)\n        {\n            IntervalKind to = typeid_cast<const DataTypeInterval *>(result_type.get())->getKind();\n            IntervalKind from = typeid_cast<const DataTypeInterval *>(arguments[0].type.get())->getKind();\n\n            if (from == to || arguments[0].column->empty())\n                return arguments[0].column;\n\n            Int64 conversion_factor = 1;\n            Int64 result_value;\n\n            int from_position = static_cast<int>(from.kind);\n            int to_position = static_cast<int>(to.kind); /// Positions of each interval according to granularity map\n\n            if (from_position < to_position)\n            {\n                for (int i = from_position; i < to_position; ++i)\n                    conversion_factor *= interval_conversions[i];\n                result_value = arguments[0].column->getInt(0) / conversion_factor;\n            }\n            else\n            {\n                for (int i = from_position; i > to_position; --i)\n                    conversion_factor *= interval_conversions[i];\n                result_value = arguments[0].column->getInt(0) * conversion_factor;\n            }\n\n            return ColumnConst::create(ColumnInt64::create(1, result_value), input_rows_count);\n        }\n        else\n        {\n            using FromFieldType = typename FromDataType::FieldType;\n            using ToFieldType = typename ToDataType::FieldType;\n            using ColVecFrom = typename FromDataType::ColumnType;\n            using ColVecTo = typename ToDataType::ColumnType;\n\n            if constexpr ((IsDataTypeDecimal<FromDataType> || IsDataTypeDecimal<ToDataType>)\n                && !(std::is_same_v<DataTypeDateTime64, FromDataType> || std::is_same_v<DataTypeDateTime64, ToDataType>)\n                && (!IsDataTypeDecimalOrNumber<FromDataType> || !IsDataTypeDecimalOrNumber<ToDataType>))\n            {\n                throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of first argument of function {}\",\n                    named_from.column->getName(), Name::name);\n            }\n\n            const ColVecFrom * col_from = checkAndGetColumn<ColVecFrom>(named_from.column.get());\n            if (!col_from)\n                throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of first argument of function {}\",\n                    named_from.column->getName(), Name::name);\n\n            typename ColVecTo::MutablePtr col_to = nullptr;\n\n            if constexpr (IsDataTypeDecimal<ToDataType>)\n            {\n                UInt32 scale;\n\n                if constexpr (std::is_same_v<Additions, AccurateConvertStrategyAdditions>\n                    || std::is_same_v<Additions, AccurateOrNullConvertStrategyAdditions>)\n                {\n                    scale = additions.scale;\n                }\n                else\n                {\n                    scale = additions;\n                }\n\n                col_to = ColVecTo::create(0, scale);\n            }\n            else\n                col_to = ColVecTo::create();\n\n            const auto & vec_from = col_from->getData();\n            auto & vec_to = col_to->getData();\n            vec_to.resize(input_rows_count);\n\n            ColumnUInt8::MutablePtr col_null_map_to;\n            ColumnUInt8::Container * vec_null_map_to [[maybe_unused]] = nullptr;\n            if constexpr (std::is_same_v<Additions, AccurateOrNullConvertStrategyAdditions>)\n            {\n                col_null_map_to = ColumnUInt8::create(input_rows_count, false);\n                vec_null_map_to = &col_null_map_to->getData();\n            }\n\n            bool result_is_bool = isBool(result_type);\n            for (size_t i = 0; i < input_rows_count; ++i)\n            {\n                if constexpr (std::is_same_v<ToDataType, DataTypeUInt8>)\n                {\n                    if (result_is_bool)\n                    {\n                        vec_to[i] = vec_from[i] != FromFieldType(0);\n                        continue;\n                    }\n                }\n\n                if constexpr (std::is_same_v<FromDataType, DataTypeUUID> && std::is_same_v<ToDataType, DataTypeUInt128>)\n                {\n                    static_assert(\n                        std::is_same_v<DataTypeUInt128::FieldType, DataTypeUUID::FieldType::UnderlyingType>,\n                        \"UInt128 and UUID types must be same\");\n\n                    vec_to[i].items[1] = vec_from[i].toUnderType().items[0];\n                    vec_to[i].items[0] = vec_from[i].toUnderType().items[1];\n                }\n                else if constexpr (std::is_same_v<FromDataType, DataTypeIPv6> && std::is_same_v<ToDataType, DataTypeUInt128>)\n                {\n                    static_assert(\n                        std::is_same_v<DataTypeUInt128::FieldType, DataTypeUUID::FieldType::UnderlyingType>,\n                        \"UInt128 and IPv6 types must be same\");\n\n                    vec_to[i].items[1] = std::byteswap(vec_from[i].toUnderType().items[0]);\n                    vec_to[i].items[0] = std::byteswap(vec_from[i].toUnderType().items[1]);\n                }\n                else if constexpr (std::is_same_v<FromDataType, DataTypeUUID> != std::is_same_v<ToDataType, DataTypeUUID>)\n                {\n                    throw Exception(ErrorCodes::NOT_IMPLEMENTED,\n                                    \"Conversion between numeric types and UUID is not supported. \"\n                                    \"Probably the passed UUID is unquoted\");\n                }\n                else if constexpr (\n                    (std::is_same_v<FromDataType, DataTypeIPv4> != std::is_same_v<ToDataType, DataTypeIPv4>)\n                    && !(is_any_of<FromDataType, DataTypeUInt8, DataTypeUInt16, DataTypeUInt32, DataTypeUInt64, DataTypeIPv6>\n                        || is_any_of<ToDataType, DataTypeUInt32, DataTypeUInt64, DataTypeUInt128, DataTypeUInt256, DataTypeIPv6>))\n                {\n                    throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Conversion from {} to {} is not supported\",\n                                    TypeName<typename FromDataType::FieldType>, TypeName<typename ToDataType::FieldType>);\n                }\n                else if constexpr (std::is_same_v<FromDataType, DataTypeIPv6> != std::is_same_v<ToDataType, DataTypeIPv6>\n                    && !(std::is_same_v<ToDataType, DataTypeIPv4> || std::is_same_v<FromDataType, DataTypeIPv4>))\n                {\n                    throw Exception(ErrorCodes::NOT_IMPLEMENTED,\n                                    \"Conversion between numeric types and IPv6 is not supported. \"\n                                    \"Probably the passed IPv6 is unquoted\");\n                }\n                else if constexpr (IsDataTypeDecimal<FromDataType> || IsDataTypeDecimal<ToDataType>)\n                {\n                    if constexpr (std::is_same_v<Additions, AccurateOrNullConvertStrategyAdditions>)\n                    {\n                        ToFieldType result;\n                        bool convert_result = false;\n\n                        if constexpr (IsDataTypeDecimal<FromDataType> && IsDataTypeDecimal<ToDataType>)\n                            convert_result = tryConvertDecimals<FromDataType, ToDataType>(vec_from[i], col_from->getScale(), col_to->getScale(), result);\n                        else if constexpr (IsDataTypeDecimal<FromDataType> && IsDataTypeNumber<ToDataType>)\n                            convert_result = tryConvertFromDecimal<FromDataType, ToDataType>(vec_from[i], col_from->getScale(), result);\n                        else if constexpr (IsDataTypeNumber<FromDataType> && IsDataTypeDecimal<ToDataType>)\n                            convert_result = tryConvertToDecimal<FromDataType, ToDataType>(vec_from[i], col_to->getScale(), result);\n\n                        if (convert_result)\n                            vec_to[i] = result;\n                        else\n                        {\n                            vec_to[i] = static_cast<ToFieldType>(0);\n                            (*vec_null_map_to)[i] = true;\n                        }\n                    }\n                    else\n                    {\n                        if constexpr (IsDataTypeDecimal<FromDataType> && IsDataTypeDecimal<ToDataType>)\n                            vec_to[i] = convertDecimals<FromDataType, ToDataType>(vec_from[i], col_from->getScale(), col_to->getScale());\n                        else if constexpr (IsDataTypeDecimal<FromDataType> && IsDataTypeNumber<ToDataType>)\n                            vec_to[i] = convertFromDecimal<FromDataType, ToDataType>(vec_from[i], col_from->getScale());\n                        else if constexpr (IsDataTypeNumber<FromDataType> && IsDataTypeDecimal<ToDataType>)\n                            vec_to[i] = convertToDecimal<FromDataType, ToDataType>(vec_from[i], col_to->getScale());\n                        else\n                            throw Exception(ErrorCodes::CANNOT_CONVERT_TYPE, \"Unsupported data type in conversion function\");\n                    }\n                }\n                else if constexpr (std::is_same_v<ToDataType, DataTypeIPv4> && std::is_same_v<FromDataType, DataTypeIPv6>)\n                {\n                    const uint8_t ip4_cidr[] {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00};\n                    const uint8_t * src = reinterpret_cast<const uint8_t *>(&vec_from[i].toUnderType());\n                    if (!matchIPv6Subnet(src, ip4_cidr, 96))\n                    {\n                        char addr[IPV6_MAX_TEXT_LENGTH + 1] {};\n                        char * paddr = addr;\n                        formatIPv6(src, paddr);\n\n                        throw Exception(ErrorCodes::CANNOT_CONVERT_TYPE, \"IPv6 {} in column {} is not in IPv4 mapping block\", addr, named_from.column->getName());\n                    }\n\n                    uint8_t * dst = reinterpret_cast<uint8_t *>(&vec_to[i].toUnderType());\n                    if constexpr (std::endian::native == std::endian::little)\n                    {\n                        dst[0] = src[15];\n                        dst[1] = src[14];\n                        dst[2] = src[13];\n                        dst[3] = src[12];\n                    }\n                    else\n                    {\n                        dst[0] = src[12];\n                        dst[1] = src[13];\n                        dst[2] = src[14];\n                        dst[3] = src[15];\n                    }\n                }\n                else if constexpr (std::is_same_v<ToDataType, DataTypeIPv6> && std::is_same_v<FromDataType, DataTypeIPv4>)\n                {\n                    const uint8_t * src = reinterpret_cast<const uint8_t *>(&vec_from[i].toUnderType());\n                    uint8_t * dst = reinterpret_cast<uint8_t *>(&vec_to[i].toUnderType());\n                    std::memset(dst, '\\0', IPV6_BINARY_LENGTH);\n                    dst[10] = dst[11] = 0xff;\n\n                    if constexpr (std::endian::native == std::endian::little)\n                    {\n                        dst[12] = src[3];\n                        dst[13] = src[2];\n                        dst[14] = src[1];\n                        dst[15] = src[0];\n                    }\n                    else\n                    {\n                        dst[12] = src[0];\n                        dst[13] = src[1];\n                        dst[14] = src[2];\n                        dst[15] = src[3];\n                    }\n                }\n                else if constexpr (std::is_same_v<ToDataType, DataTypeIPv4> && std::is_same_v<FromDataType, DataTypeUInt64>)\n                {\n                    vec_to[i] = static_cast<ToFieldType>(static_cast<IPv4::UnderlyingType>(vec_from[i]));\n                }\n                else if constexpr (std::is_same_v<Name, NameToUnixTimestamp>\n                    && (std::is_same_v<FromDataType, DataTypeDate> || std::is_same_v<FromDataType, DataTypeDate32>))\n                {\n                    vec_to[i] = static_cast<ToFieldType>(vec_from[i] * DATE_SECONDS_PER_DAY);\n                }\n                else\n                {\n                    /// If From Data is Nan or Inf and we convert to integer type, throw exception\n                    if constexpr (std::is_floating_point_v<FromFieldType> && !std::is_floating_point_v<ToFieldType>)\n                    {\n                        if (!isFinite(vec_from[i]))\n                        {\n                            if constexpr (std::is_same_v<Additions, AccurateOrNullConvertStrategyAdditions>)\n                            {\n                                vec_to[i] = 0;\n                                (*vec_null_map_to)[i] = true;\n                                continue;\n                            }\n                            else\n                                throw Exception(ErrorCodes::CANNOT_CONVERT_TYPE, \"Unexpected inf or nan to integer conversion\");\n                        }\n                    }\n\n                    if constexpr (std::is_same_v<Additions, AccurateOrNullConvertStrategyAdditions>\n                            || std::is_same_v<Additions, AccurateConvertStrategyAdditions>)\n                    {\n                        bool convert_result = accurate::convertNumeric(vec_from[i], vec_to[i]);\n\n                        if (!convert_result)\n                        {\n                            if (std::is_same_v<Additions, AccurateOrNullConvertStrategyAdditions>)\n                            {\n                                vec_to[i] = 0;\n                                (*vec_null_map_to)[i] = true;\n                            }\n                            else\n                            {\n                                throw Exception(ErrorCodes::CANNOT_CONVERT_TYPE, \"Value in column {} cannot be safely converted into type {}\",\n                                    named_from.column->getName(), result_type->getName());\n                            }\n                        }\n                    }\n                    else\n                    {\n                        vec_to[i] = static_cast<ToFieldType>(vec_from[i]);\n                    }\n                }\n            }\n\n            if constexpr (std::is_same_v<Additions, AccurateOrNullConvertStrategyAdditions>)\n                return ColumnNullable::create(std::move(col_to), std::move(col_null_map_to));\n            else\n                return col_to;\n        }\n    }\n};\n\n\n/// Generic conversion of any type from String. Used for complex types: Array and Tuple or types with custom serialization.\ntemplate <bool throw_on_error>\nstruct ConvertImplGenericFromString\n{\n    static ColumnPtr execute(ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable * column_nullable, size_t input_rows_count, const ContextPtr & context)\n    {\n        const IColumn & column_from = *arguments[0].column;\n        const IDataType & data_type_to = *result_type;\n        auto res = data_type_to.createColumn();\n        auto serialization = data_type_to.getDefaultSerialization();\n        const auto * null_map = column_nullable ? &column_nullable->getNullMapData() : nullptr;\n\n        executeImpl(column_from, *res, *serialization, input_rows_count, null_map, result_type.get(), context);\n        return res;\n    }\n\n    static void executeImpl(\n        const IColumn & column_from,\n        IColumn & column_to,\n        const ISerialization & serialization_from,\n        size_t input_rows_count,\n        const PaddedPODArray<UInt8> * null_map,\n        const IDataType * result_type,\n        const ContextPtr & context)\n    {\n        column_to.reserve(input_rows_count);\n\n        FormatSettings format_settings = context ? getFormatSettings(context) : FormatSettings{};\n        for (size_t i = 0; i < input_rows_count; ++i)\n        {\n            if (null_map && (*null_map)[i])\n            {\n                column_to.insertDefault();\n                continue;\n            }\n\n            const auto & val = column_from.getDataAt(i);\n            ReadBufferFromMemory read_buffer(val.data, val.size);\n            try\n            {\n                serialization_from.deserializeWholeText(column_to, read_buffer, format_settings);\n            }\n            catch (const Exception &)\n            {\n                if constexpr (throw_on_error)\n                    throw;\n                /// Check if exception happened after we inserted the value\n                /// (deserializeWholeText should not do it, but let's check anyway).\n                if (column_to.size() > i)\n                    column_to.popBack(column_to.size() - i);\n                column_to.insertDefault();\n            }\n\n            /// Usually deserializeWholeText checks for eof after parsing, but let's check one more time just in case.\n            if (!read_buffer.eof())\n            {\n                if constexpr (throw_on_error)\n                {\n                    if (result_type)\n                        throwExceptionForIncompletelyParsedValue(read_buffer, *result_type);\n                    else\n                        throw Exception(\n                            ErrorCodes::CANNOT_PARSE_TEXT, \"Cannot parse string to column {}. Expected eof\", column_to.getName());\n                }\n                else\n                {\n                    if (column_to.size() > i)\n                        column_to.popBack(column_to.size() - i);\n                    column_to.insertDefault();\n                }\n            }\n        }\n    }\n};\n\n\n/// Declared early because used below.\nstruct NameToDate { static constexpr auto name = \"toDate\"; };\nstruct NameToDate32 { static constexpr auto name = \"toDate32\"; };\nstruct NameToDateTime { static constexpr auto name = \"toDateTime\"; };\nstruct NameToDateTime32 { static constexpr auto name = \"toDateTime32\"; };\nstruct NameToDateTime64 { static constexpr auto name = \"toDateTime64\"; };\nstruct NameToString { static constexpr auto name = \"toString\"; };\nstruct NameToDecimal32 { static constexpr auto name = \"toDecimal32\"; };\nstruct NameToDecimal64 { static constexpr auto name = \"toDecimal64\"; };\nstruct NameToDecimal128 { static constexpr auto name = \"toDecimal128\"; };\nstruct NameToDecimal256 { static constexpr auto name = \"toDecimal256\"; };\n\n\n#define DEFINE_NAME_TO_INTERVAL(INTERVAL_KIND) \\\n    struct NameToInterval ## INTERVAL_KIND \\\n    { \\\n        static constexpr auto name = \"toInterval\" #INTERVAL_KIND; \\\n        static constexpr auto kind = IntervalKind::Kind::INTERVAL_KIND; \\\n    };\n\nDEFINE_NAME_TO_INTERVAL(Nanosecond)\nDEFINE_NAME_TO_INTERVAL(Microsecond)\nDEFINE_NAME_TO_INTERVAL(Millisecond)\nDEFINE_NAME_TO_INTERVAL(Second)\nDEFINE_NAME_TO_INTERVAL(Minute)\nDEFINE_NAME_TO_INTERVAL(Hour)\nDEFINE_NAME_TO_INTERVAL(Day)\nDEFINE_NAME_TO_INTERVAL(Week)\nDEFINE_NAME_TO_INTERVAL(Month)\nDEFINE_NAME_TO_INTERVAL(Quarter)\nDEFINE_NAME_TO_INTERVAL(Year)\n\n#undef DEFINE_NAME_TO_INTERVAL\n\nstruct NameParseDateTimeBestEffort;\nstruct NameParseDateTimeBestEffortOrZero;\nstruct NameParseDateTimeBestEffortOrNull;\n\ntemplate <typename Name, typename ToDataType>\nconstexpr bool mightBeDateTime()\n{\n    if constexpr (std::is_same_v<ToDataType, DataTypeDateTime64>)\n        return true;\n    else if constexpr (\n        std::is_same_v<Name, NameToDateTime> || std::is_same_v<Name, NameParseDateTimeBestEffort>\n        || std::is_same_v<Name, NameParseDateTimeBestEffortOrZero> || std::is_same_v<Name, NameParseDateTimeBestEffortOrNull>)\n        return true;\n\n    return false;\n}\n\ntemplate<typename Name, typename ToDataType>\ninline bool isDateTime64(const ColumnsWithTypeAndName & arguments)\n{\n    if constexpr (std::is_same_v<ToDataType, DataTypeDateTime64>)\n        return true;\n    else if constexpr (std::is_same_v<Name, NameToDateTime> || std::is_same_v<Name, NameParseDateTimeBestEffort>\n        || std::is_same_v<Name, NameParseDateTimeBestEffortOrZero> || std::is_same_v<Name, NameParseDateTimeBestEffortOrNull>)\n    {\n        return (arguments.size() == 2 && isUInt(arguments[1].type)) || arguments.size() == 3;\n    }\n\n    return false;\n}\n\ntemplate <typename ToDataType, typename Name, typename MonotonicityImpl>\nclass FunctionConvert : public IFunction\n{\npublic:\n    using Monotonic = MonotonicityImpl;\n\n    static constexpr auto name = Name::name;\n    static constexpr bool to_datetime64 = std::is_same_v<ToDataType, DataTypeDateTime64>;\n    static constexpr bool to_decimal = IsDataTypeDecimal<ToDataType> && !to_datetime64;\n\n    static FunctionPtr create(ContextPtr context) { return std::make_shared<FunctionConvert>(context); }\n    explicit FunctionConvert(ContextPtr context_) : context(context_) {}\n\n    String getName() const override\n    {\n        return name;\n    }\n\n    bool isVariadic() const override { return true; }\n    size_t getNumberOfArguments() const override { return 0; }\n    bool isInjective(const ColumnsWithTypeAndName &) const override { return std::is_same_v<Name, NameToString>; }\n    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & arguments) const override\n    {\n        return !(IsDataTypeDateOrDateTime<ToDataType> && isNumber(*arguments[0].type));\n    }\n\n    using DefaultReturnTypeGetter = std::function<DataTypePtr(const ColumnsWithTypeAndName &)>;\n    static DataTypePtr getReturnTypeDefaultImplementationForNulls(const ColumnsWithTypeAndName & arguments, const DefaultReturnTypeGetter & getter)\n    {\n        NullPresence null_presence = getNullPresense(arguments);\n\n        if (null_presence.has_null_constant)\n        {\n            return makeNullable(std::make_shared<DataTypeNothing>());\n        }\n        if (null_presence.has_nullable)\n        {\n            auto nested_columns = Block(createBlockWithNestedColumns(arguments));\n            auto return_type = getter(ColumnsWithTypeAndName(nested_columns.begin(), nested_columns.end()));\n            return makeNullable(return_type);\n        }\n\n        return getter(arguments);\n    }\n\n    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n    {\n        auto getter = [&] (const auto & args) { return getReturnTypeImplRemovedNullable(args); };\n        auto res = getReturnTypeDefaultImplementationForNulls(arguments, getter);\n        to_nullable = res->isNullable();\n        checked_return_type = true;\n        return res;\n    }\n\n    DataTypePtr getReturnTypeImplRemovedNullable(const ColumnsWithTypeAndName & arguments) const\n    {\n        FunctionArgumentDescriptors mandatory_args = {{\"Value\", nullptr, nullptr, \"any type\"}};\n        FunctionArgumentDescriptors optional_args;\n\n        if constexpr (to_decimal)\n        {\n            mandatory_args.push_back({\"scale\", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isNativeInteger), &isColumnConst, \"const Integer\"});\n        }\n\n        if (!to_decimal && isDateTime64<Name, ToDataType>(arguments))\n        {\n            mandatory_args.push_back({\"scale\", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isNativeInteger), &isColumnConst, \"const Integer\"});\n        }\n\n        // toString(DateTime or DateTime64, [timezone: String])\n        if ((std::is_same_v<Name, NameToString> && !arguments.empty() && (isDateTime64(arguments[0].type) || isDateTime(arguments[0].type)))\n            // toUnixTimestamp(value[, timezone : String])\n            || std::is_same_v<Name, NameToUnixTimestamp>\n            // toDate(value[, timezone : String])\n            || std::is_same_v<ToDataType, DataTypeDate> // TODO: shall we allow timestamp argument for toDate? DateTime knows nothing about timezones and this argument is ignored below.\n            // toDate32(value[, timezone : String])\n            || std::is_same_v<ToDataType, DataTypeDate32>\n            // toDateTime(value[, timezone: String])\n            || std::is_same_v<ToDataType, DataTypeDateTime>\n            // toDateTime64(value, scale : Integer[, timezone: String])\n            || std::is_same_v<ToDataType, DataTypeDateTime64>)\n        {\n            optional_args.push_back({\"timezone\", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isString), nullptr, \"String\"});\n        }\n\n            validateFunctionArguments(*this, arguments, mandatory_args, optional_args);\n\n        if constexpr (std::is_same_v<ToDataType, DataTypeInterval>)\n        {\n            return std::make_shared<DataTypeInterval>(Name::kind);\n        }\n        else if constexpr (to_decimal)\n        {\n            UInt64 scale = extractToDecimalScale(arguments[1]);\n\n            if constexpr (std::is_same_v<Name, NameToDecimal32>)\n                return createDecimalMaxPrecision<Decimal32>(scale);\n            else if constexpr (std::is_same_v<Name, NameToDecimal64>)\n                return createDecimalMaxPrecision<Decimal64>(scale);\n            else if constexpr (std::is_same_v<Name, NameToDecimal128>)\n                return createDecimalMaxPrecision<Decimal128>(scale);\n            else if constexpr (std::is_same_v<Name, NameToDecimal256>)\n                return createDecimalMaxPrecision<Decimal256>(scale);\n\n            throw Exception(ErrorCodes::LOGICAL_ERROR, \"Unexpected branch in code of conversion function: it is a bug.\");\n        }\n        else\n        {\n            // Optional second argument with time zone for DateTime.\n            UInt8 timezone_arg_position = 1;\n            UInt32 scale [[maybe_unused]] = DataTypeDateTime64::default_scale;\n\n            // DateTime64 requires more arguments: scale and timezone. Since timezone is optional, scale should be first.\n            if (isDateTime64<Name, ToDataType>(arguments))\n            {\n                timezone_arg_position += 1;\n                scale = static_cast<UInt32>(arguments[1].column->get64(0));\n\n                if (to_datetime64 || scale != 0) /// toDateTime('xxxx-xx-xx xx:xx:xx', 0) return DateTime\n                    return std::make_shared<DataTypeDateTime64>(scale,\n                        extractTimeZoneNameFromFunctionArguments(arguments, timezone_arg_position, 0, false));\n\n                return std::make_shared<DataTypeDateTime>(extractTimeZoneNameFromFunctionArguments(arguments, timezone_arg_position, 0, false));\n            }\n\n            if constexpr (std::is_same_v<ToDataType, DataTypeDateTime>)\n                return std::make_shared<DataTypeDateTime>(extractTimeZoneNameFromFunctionArguments(arguments, timezone_arg_position, 0, false));\n            else if constexpr (std::is_same_v<ToDataType, DataTypeDateTime64>)\n                throw Exception(ErrorCodes::LOGICAL_ERROR, \"Unexpected branch in code of conversion function: it is a bug.\");\n            else\n                return std::make_shared<ToDataType>();\n        }\n    }\n\n    /// Function actually uses default implementation for nulls,\n    /// but we need to know if return type is Nullable or not,\n    /// so we use checked_return_type only to intercept the first call to getReturnTypeImpl(...).\n    bool useDefaultImplementationForNulls() const override\n    {\n        bool to_nullable_string = to_nullable && std::is_same_v<ToDataType, DataTypeString>;\n        return checked_return_type && !to_nullable_string;\n    }\n\n    bool useDefaultImplementationForConstants() const override { return true; }\n    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override\n    {\n        if constexpr (std::is_same_v<ToDataType, DataTypeString>)\n            return {};\n        else if constexpr (std::is_same_v<ToDataType, DataTypeDateTime64>)\n            return {2};\n        return {1};\n    }\n    bool canBeExecutedOnDefaultArguments() const override { return false; }\n\n    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override\n    {\n        try\n        {\n            return executeInternal(arguments, result_type, input_rows_count);\n        }\n        catch (Exception & e)\n        {\n            /// More convenient error message.\n            if (e.code() == ErrorCodes::ATTEMPT_TO_READ_AFTER_EOF)\n            {\n                e.addMessage(\"Cannot parse \"\n                    + result_type->getName() + \" from \"\n                    + arguments[0].type->getName()\n                    + \", because value is too short\");\n            }\n            else if (e.code() == ErrorCodes::CANNOT_PARSE_NUMBER\n                || e.code() == ErrorCodes::CANNOT_READ_ARRAY_FROM_TEXT\n                || e.code() == ErrorCodes::CANNOT_PARSE_INPUT_ASSERTION_FAILED\n                || e.code() == ErrorCodes::CANNOT_PARSE_QUOTED_STRING\n                || e.code() == ErrorCodes::CANNOT_PARSE_ESCAPE_SEQUENCE\n                || e.code() == ErrorCodes::CANNOT_PARSE_DATE\n                || e.code() == ErrorCodes::CANNOT_PARSE_DATETIME\n                || e.code() == ErrorCodes::CANNOT_PARSE_UUID\n                || e.code() == ErrorCodes::CANNOT_PARSE_IPV4\n                || e.code() == ErrorCodes::CANNOT_PARSE_IPV6)\n            {\n                e.addMessage(\"Cannot parse \"\n                    + result_type->getName() + \" from \"\n                    + arguments[0].type->getName());\n            }\n\n            throw;\n        }\n    }\n\n    bool hasInformationAboutMonotonicity() const override\n    {\n        return Monotonic::has();\n    }\n\n    Monotonicity getMonotonicityForRange(const IDataType & type, const Field & left, const Field & right) const override\n    {\n        return Monotonic::get(type, left, right);\n    }\n\nprivate:\n    ContextPtr context;\n    mutable bool checked_return_type = false;\n    mutable bool to_nullable = false;\n\n    ColumnPtr executeInternal(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const\n    {\n        if (arguments.empty())\n            throw Exception(ErrorCodes::TOO_FEW_ARGUMENTS_FOR_FUNCTION, \"Function {} expects at least 1 argument\", getName());\n\n        if (result_type->onlyNull())\n            return result_type->createColumnConstWithDefaultValue(input_rows_count);\n\n        const DataTypePtr from_type = removeNullable(arguments[0].type);\n        ColumnPtr result_column;\n\n        FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior = default_date_time_overflow_behavior;\n\n        if (context)\n            date_time_overflow_behavior = context->getSettingsRef()[Setting::date_time_overflow_behavior].value;\n\n        auto call = [&](const auto & types, BehaviourOnErrorFromString from_string_tag) -> bool\n        {\n            using Types = std::decay_t<decltype(types)>;\n            using LeftDataType = typename Types::LeftType;\n            using RightDataType = typename Types::RightType;\n\n            if constexpr (IsDataTypeDecimal<RightDataType>)\n            {\n                if constexpr (std::is_same_v<RightDataType, DataTypeDateTime64>)\n                {\n                    /// Account for optional timezone argument.\n                    if (arguments.size() != 2 && arguments.size() != 3)\n                        throw Exception(ErrorCodes::TOO_FEW_ARGUMENTS_FOR_FUNCTION, \"Function {} expects 2 or 3 arguments for DataTypeDateTime64.\", getName());\n                }\n                else if (arguments.size() != 2)\n                {\n                    throw Exception(ErrorCodes::TOO_FEW_ARGUMENTS_FOR_FUNCTION, \"Function {} expects 2 arguments for Decimal.\", getName());\n                }\n\n                const ColumnWithTypeAndName & scale_column = arguments[1];\n                UInt32 scale = extractToDecimalScale(scale_column);\n\n                switch (date_time_overflow_behavior)\n                {\n                    case FormatSettings::DateTimeOverflowBehavior::Throw:\n                        result_column = ConvertImpl<LeftDataType, RightDataType, Name, FormatSettings::DateTimeOverflowBehavior::Throw>::execute(arguments, result_type, input_rows_count, from_string_tag, scale);\n                        break;\n                    case FormatSettings::DateTimeOverflowBehavior::Ignore:\n                        result_column = ConvertImpl<LeftDataType, RightDataType, Name, FormatSettings::DateTimeOverflowBehavior::Ignore>::execute(arguments, result_type, input_rows_count, from_string_tag, scale);\n                        break;\n                    case FormatSettings::DateTimeOverflowBehavior::Saturate:\n                        result_column = ConvertImpl<LeftDataType, RightDataType, Name, FormatSettings::DateTimeOverflowBehavior::Saturate>::execute(arguments, result_type, input_rows_count, from_string_tag, scale);\n                        break;\n                }\n            }\n            else if constexpr (IsDataTypeDateOrDateTime<RightDataType> && std::is_same_v<LeftDataType, DataTypeDateTime64>)\n            {\n                const auto * dt64 = assert_cast<const DataTypeDateTime64 *>(arguments[0].type.get());\n                switch (date_time_overflow_behavior)\n                {\n                    case FormatSettings::DateTimeOverflowBehavior::Throw:\n                        result_column = ConvertImpl<LeftDataType, RightDataType, Name, FormatSettings::DateTimeOverflowBehavior::Throw>::execute(arguments, result_type, input_rows_count, from_string_tag, dt64->getScale());\n                        break;\n                    case FormatSettings::DateTimeOverflowBehavior::Ignore:\n                        result_column = ConvertImpl<LeftDataType, RightDataType, Name, FormatSettings::DateTimeOverflowBehavior::Ignore>::execute(arguments, result_type, input_rows_count, from_string_tag, dt64->getScale());\n                        break;\n                    case FormatSettings::DateTimeOverflowBehavior::Saturate:\n                        result_column = ConvertImpl<LeftDataType, RightDataType, Name, FormatSettings::DateTimeOverflowBehavior::Saturate>::execute(arguments, result_type, input_rows_count, from_string_tag, dt64->getScale());\n                        break;\n                }\n            }\n            else if constexpr ((IsDataTypeNumber<LeftDataType>\n                                || IsDataTypeDateOrDateTime<LeftDataType>)&&IsDataTypeDateOrDateTime<RightDataType>)\n            {\n#define GENERATE_OVERFLOW_MODE_CASE(OVERFLOW_MODE) \\\n    case FormatSettings::DateTimeOverflowBehavior::OVERFLOW_MODE: \\\n        result_column = ConvertImpl<LeftDataType, RightDataType, Name, FormatSettings::DateTimeOverflowBehavior::OVERFLOW_MODE>::execute( \\\n            arguments, result_type, input_rows_count, from_string_tag); \\\n        break;\n                switch (date_time_overflow_behavior)\n                {\n                    GENERATE_OVERFLOW_MODE_CASE(Throw)\n                    GENERATE_OVERFLOW_MODE_CASE(Ignore)\n                    GENERATE_OVERFLOW_MODE_CASE(Saturate)\n                }\n\n#undef GENERATE_OVERFLOW_MODE_CASE\n            }\n            else if constexpr (IsDataTypeDecimalOrNumber<LeftDataType> && IsDataTypeDecimalOrNumber<RightDataType>)\n            {\n                using LeftT = typename LeftDataType::FieldType;\n                using RightT = typename RightDataType::FieldType;\n\n                static constexpr bool bad_left =\n                    is_decimal<LeftT> || std::is_floating_point_v<LeftT> || is_big_int_v<LeftT> || is_signed_v<LeftT>;\n                static constexpr bool bad_right =\n                    is_decimal<RightT> || std::is_floating_point_v<RightT> || is_big_int_v<RightT> || is_signed_v<RightT>;\n\n                /// Disallow int vs UUID conversion (but support int vs UInt128 conversion)\n                if constexpr ((bad_left && std::is_same_v<RightDataType, DataTypeUUID>) ||\n                              (bad_right && std::is_same_v<LeftDataType, DataTypeUUID>))\n                {\n                    throw Exception(ErrorCodes::CANNOT_CONVERT_TYPE, \"Wrong UUID conversion\");\n                }\n                else\n                {\n                    result_column = ConvertImpl<LeftDataType, RightDataType, Name>::execute(\n                        arguments, result_type, input_rows_count, from_string_tag);\n                }\n            }\n            else\n                result_column = ConvertImpl<LeftDataType, RightDataType, Name>::execute(arguments, result_type, input_rows_count, from_string_tag);\n\n            return true;\n        };\n\n        if constexpr (mightBeDateTime<Name, ToDataType>())\n        {\n            if (isDateTime64<Name, ToDataType>(arguments))\n            {\n                /// For toDateTime('xxxx-xx-xx xx:xx:xx.00', 2[, 'timezone']) we need to it convert to DateTime64\n                const ColumnWithTypeAndName & scale_column = arguments[1];\n                UInt32 scale = extractToDecimalScale(scale_column);\n\n                if (to_datetime64 || scale != 0) /// When scale = 0, the data type is DateTime otherwise the data type is DateTime64\n                {\n                    if (!callOnIndexAndDataType<DataTypeDateTime64>(\n                            from_type->getTypeId(), call, BehaviourOnErrorFromString::ConvertDefaultBehaviorTag))\n                        throw Exception(\n                            ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n                            \"Illegal type {} of argument of function {}\",\n                            arguments[0].type->getName(),\n                            getName());\n\n                    return result_column;\n                }\n            }\n        }\n\n        if constexpr (std::is_same_v<ToDataType, DataTypeString>)\n        {\n            if (from_type->getCustomSerialization())\n                return ConvertImplGenericToString<ColumnString>::execute(arguments, result_type, input_rows_count, context);\n        }\n\n        bool done = false;\n        if constexpr (is_any_of<ToDataType, DataTypeString, DataTypeFixedString>)\n        {\n            done = callOnIndexAndDataType<ToDataType>(from_type->getTypeId(), call, BehaviourOnErrorFromString::ConvertDefaultBehaviorTag);\n        }\n        else\n        {\n            bool cast_ipv4_ipv6_default_on_conversion_error = false;\n            if constexpr (is_any_of<ToDataType, DataTypeIPv4, DataTypeIPv6>)\n            {\n                if (context && (cast_ipv4_ipv6_default_on_conversion_error = context->getSettingsRef()[Setting::cast_ipv4_ipv6_default_on_conversion_error]))\n                    done = callOnIndexAndDataType<ToDataType>(from_type->getTypeId(), call, BehaviourOnErrorFromString::ConvertReturnZeroOnErrorTag);\n            }\n\n            if (!cast_ipv4_ipv6_default_on_conversion_error)\n            {\n                /// We should use ConvertFromStringExceptionMode::Null mode when converting from String (or FixedString)\n                /// to Nullable type, to avoid 'value is too short' error on attempt to parse empty string from NULL values.\n                if (to_nullable && WhichDataType(from_type).isStringOrFixedString())\n                    done = callOnIndexAndDataType<ToDataType>(from_type->getTypeId(), call, BehaviourOnErrorFromString::ConvertReturnNullOnErrorTag);\n                else\n                    done = callOnIndexAndDataType<ToDataType>(from_type->getTypeId(), call, BehaviourOnErrorFromString::ConvertDefaultBehaviorTag);\n            }\n\n            if constexpr (std::is_same_v<ToDataType, DataTypeInterval>)\n                if (WhichDataType(from_type).isInterval())\n                    done = callOnIndexAndDataType<ToDataType>(from_type->getTypeId(), call, BehaviourOnErrorFromString::ConvertDefaultBehaviorTag);\n        }\n\n        if (!done)\n        {\n            /// Generic conversion of any type to String.\n            if (std::is_same_v<ToDataType, DataTypeString>)\n            {\n                return ConvertImplGenericToString<ColumnString>::execute(arguments, result_type, input_rows_count, context);\n            }\n            else\n                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal type {} of argument of function {}\",\n                    arguments[0].type->getName(), getName());\n        }\n\n        return result_column;\n    }\n};\n\n\n/** Function toTOrZero (where T is number of date or datetime type):\n  *  try to convert from String to type T through parsing,\n  *  if cannot parse, return default value instead of throwing exception.\n  * Function toTOrNull will return Nullable type with NULL when cannot parse.\n  * NOTE Also need to implement tryToUnixTimestamp with timezone.\n  */\ntemplate <typename ToDataType, typename Name,\n    ConvertFromStringExceptionMode exception_mode,\n    ConvertFromStringParsingMode parsing_mode = ConvertFromStringParsingMode::Normal>\nclass FunctionConvertFromString : public IFunction\n{\npublic:\n    static constexpr auto name = Name::name;\n    static constexpr bool to_datetime64 = std::is_same_v<ToDataType, DataTypeDateTime64>;\n    static constexpr bool to_decimal = IsDataTypeDecimal<ToDataType> && !to_datetime64;\n\n    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionConvertFromString>(); }\n\n    String getName() const override\n    {\n        return name;\n    }\n\n    bool isVariadic() const override { return true; }\n    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n    size_t getNumberOfArguments() const override { return 0; }\n\n    bool useDefaultImplementationForConstants() const override { return true; }\n    bool canBeExecutedOnDefaultArguments() const override { return false; }\n\n    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1}; }\n\n    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n    {\n        DataTypePtr res;\n\n        if (isDateTime64<Name, ToDataType>(arguments))\n        {\n            validateFunctionArguments(*this, arguments,\n                FunctionArgumentDescriptors{{\"string\", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isStringOrFixedString), nullptr, \"String or FixedString\"}},\n                // optional\n                FunctionArgumentDescriptors{\n                    {\"precision\", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isUInt8), isColumnConst, \"const UInt8\"},\n                    {\"timezone\", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isStringOrFixedString), isColumnConst, \"const String or FixedString\"},\n                });\n\n            UInt64 scale = to_datetime64 ? DataTypeDateTime64::default_scale : 0;\n            if (arguments.size() > 1)\n                scale = extractToDecimalScale(arguments[1]);\n            const auto timezone = extractTimeZoneNameFromFunctionArguments(arguments, 2, 0, false);\n\n            res = scale == 0 ? res = std::make_shared<DataTypeDateTime>(timezone) : std::make_shared<DataTypeDateTime64>(scale, timezone);\n        }\n        else\n        {\n            if ((arguments.size() != 1 && arguments.size() != 2) || (to_decimal && arguments.size() != 2))\n                throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n                    \"Number of arguments for function {} doesn't match: passed {}, should be 1 or 2. \"\n                    \"Second argument only make sense for DateTime (time zone, optional) and Decimal (scale).\",\n                    getName(), arguments.size());\n\n            if (!isStringOrFixedString(arguments[0].type))\n            {\n                if (this->getName().find(\"OrZero\") != std::string::npos ||\n                    this->getName().find(\"OrNull\") != std::string::npos)\n                    throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal type {} of first argument of function {}. \"\n                            \"Conversion functions with postfix 'OrZero' or 'OrNull' should take String argument\",\n                            arguments[0].type->getName(), getName());\n                else\n                    throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal type {} of first argument of function {}\",\n                            arguments[0].type->getName(), getName());\n            }\n\n            if (arguments.size() == 2)\n            {\n                if constexpr (std::is_same_v<ToDataType, DataTypeDateTime>)\n                {\n                    if (!isString(arguments[1].type))\n                        throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal type {} of 2nd argument of function {}\",\n                            arguments[1].type->getName(), getName());\n                }\n                else if constexpr (to_decimal)\n                {\n                    if (!isInteger(arguments[1].type))\n                        throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal type {} of 2nd argument of function {}\",\n                            arguments[1].type->getName(), getName());\n                    if (!arguments[1].column)\n                        throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Second argument for function {} must be constant\", getName());\n                }\n                else\n                {\n                    throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n                        \"Number of arguments for function {} doesn't match: passed {}, should be 1. \"\n                        \"Second argument makes sense only for DateTime and Decimal.\",\n                        getName(), arguments.size());\n                }\n            }\n\n            if constexpr (std::is_same_v<ToDataType, DataTypeDateTime>)\n                res = std::make_shared<DataTypeDateTime>(extractTimeZoneNameFromFunctionArguments(arguments, 1, 0, false));\n            else if constexpr (std::is_same_v<ToDataType, DataTypeDateTime64>)\n                throw Exception(ErrorCodes::LOGICAL_ERROR, \"MaterializedMySQL is a bug.\");\n            else if constexpr (to_decimal)\n            {\n                UInt64 scale = extractToDecimalScale(arguments[1]);\n                res = createDecimalMaxPrecision<typename ToDataType::FieldType>(scale);\n                if (!res)\n                    throw Exception(ErrorCodes::LOGICAL_ERROR, \"Something wrong with toDecimalNNOrZero() or toDecimalNNOrNull()\");\n            }\n            else\n                res = std::make_shared<ToDataType>();\n        }\n\n        if constexpr (exception_mode == ConvertFromStringExceptionMode::Null)\n            res = std::make_shared<DataTypeNullable>(res);\n\n        return res;\n    }\n\n    template <typename ConvertToDataType>\n    ColumnPtr executeInternal(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count, UInt32 scale) const\n    {\n        const IDataType * from_type = arguments[0].type.get();\n\n        if (checkAndGetDataType<DataTypeString>(from_type))\n        {\n            return ConvertThroughParsing<DataTypeString, ConvertToDataType, Name, exception_mode, parsing_mode>::execute(\n                arguments, result_type, input_rows_count, scale);\n        }\n        else if (checkAndGetDataType<DataTypeFixedString>(from_type))\n        {\n            return ConvertThroughParsing<DataTypeFixedString, ConvertToDataType, Name, exception_mode, parsing_mode>::execute(\n                arguments, result_type, input_rows_count, scale);\n        }\n\n        return nullptr;\n    }\n\n    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override\n    {\n        ColumnPtr result_column;\n\n        if constexpr (to_decimal)\n        {\n            result_column = executeInternal<ToDataType>(arguments, result_type, input_rows_count,\n                assert_cast<const ToDataType &>(*removeNullable(result_type)).getScale());\n        }\n        else if constexpr (mightBeDateTime<Name, ToDataType>())\n        {\n            if (isDateTime64<Name, ToDataType>(arguments))\n            {\n                UInt64 scale = to_datetime64 ? DataTypeDateTime64::default_scale : 0;\n                if (arguments.size() > 1)\n                    scale = extractToDecimalScale(arguments[1]);\n\n                if (scale == 0)\n                {\n                    result_column = executeInternal<DataTypeDateTime>(arguments, result_type, input_rows_count, 0);\n                }\n                else\n                {\n                    result_column\n                        = executeInternal<DataTypeDateTime64>(arguments, result_type, input_rows_count, static_cast<UInt32>(scale));\n                }\n            }\n            else\n            {\n                result_column = executeInternal<ToDataType>(arguments, result_type, input_rows_count, 0);\n            }\n        }\n        else\n        {\n            result_column = executeInternal<ToDataType>(arguments, result_type, input_rows_count, 0);\n        }\n\n        if (!result_column)\n            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal type {} of argument of function {}. \"\n                \"Only String or FixedString argument is accepted for try-conversion function. For other arguments, \"\n                \"use function without 'orZero' or 'orNull'.\", arguments[0].type->getName(), getName());\n\n        return result_column;\n    }\n};\n\n\n/// Monotonicity.\n\nstruct PositiveMonotonicity\n{\n    static bool has() { return true; }\n    static IFunction::Monotonicity get(const IDataType &, const Field &, const Field &)\n    {\n        return { .is_monotonic = true };\n    }\n};\n\nstruct UnknownMonotonicity\n{\n    static bool has() { return false; }\n    static IFunction::Monotonicity get(const IDataType &, const Field &, const Field &)\n    {\n        return { };\n    }\n};\n\ntemplate <typename T>\nstruct ToNumberMonotonicity\n{\n    static bool has() { return true; }\n\n    static UInt64 divideByRangeOfType(UInt64 x)\n    {\n        if constexpr (sizeof(T) < sizeof(UInt64))\n            return x >> (sizeof(T) * 8);\n        else\n            return 0;\n    }\n\n    static IFunction::Monotonicity get(const IDataType & type, const Field & left, const Field & right)\n    {\n        if (!type.isValueRepresentedByNumber())\n            return {};\n\n        /// If type is same, the conversion is always monotonic.\n        /// (Enum has separate case, because it is different data type)\n        if (checkAndGetDataType<DataTypeNumber<T>>(&type) ||\n            checkAndGetDataType<DataTypeEnum<T>>(&type))\n            return { .is_monotonic = true, .is_always_monotonic = true };\n\n        /// Float cases.\n\n        /// When converting to Float, the conversion is always monotonic.\n        if constexpr (std::is_floating_point_v<T>)\n            return { .is_monotonic = true, .is_always_monotonic = true };\n\n        const auto * low_cardinality = typeid_cast<const DataTypeLowCardinality *>(&type);\n        const IDataType * low_cardinality_dictionary_type = nullptr;\n        if (low_cardinality)\n            low_cardinality_dictionary_type = low_cardinality->getDictionaryType().get();\n\n        WhichDataType which_type(type);\n        WhichDataType which_inner_type = low_cardinality\n            ? WhichDataType(low_cardinality_dictionary_type)\n            : WhichDataType(type);\n\n        /// If converting from Float, for monotonicity, arguments must fit in range of result type.\n        if (which_inner_type.isFloat())\n        {\n            if (left.isNull() || right.isNull())\n                return {};\n\n            Float64 left_float = left.safeGet<Float64>();\n            Float64 right_float = right.safeGet<Float64>();\n\n            if (left_float >= static_cast<Float64>(std::numeric_limits<T>::min())\n                && left_float <= static_cast<Float64>(std::numeric_limits<T>::max())\n                && right_float >= static_cast<Float64>(std::numeric_limits<T>::min())\n                && right_float <= static_cast<Float64>(std::numeric_limits<T>::max()))\n                return { .is_monotonic = true };\n\n            return {};\n        }\n\n        /// Integer cases.\n\n        /// Only support types represented by native integers.\n        /// It can be extended to big integers, decimals and DateTime64 later.\n        /// By the way, NULLs are representing unbounded ranges.\n        if (!((left.isNull() || left.getType() == Field::Types::UInt64 || left.getType() == Field::Types::Int64)\n            && (right.isNull() || right.getType() == Field::Types::UInt64 || right.getType() == Field::Types::Int64)))\n            return {};\n\n        const bool from_is_unsigned = type.isValueRepresentedByUnsignedInteger();\n        const bool to_is_unsigned = is_unsigned_v<T>;\n\n        const size_t size_of_from = type.getSizeOfValueInMemory();\n        const size_t size_of_to = sizeof(T);\n\n        const bool left_in_first_half = left.isNull()\n            ? from_is_unsigned\n            : (left.safeGet<Int64>() >= 0);\n\n        const bool right_in_first_half = right.isNull()\n            ? !from_is_unsigned\n            : (right.safeGet<Int64>() >= 0);\n\n        /// Size of type is the same.\n        if (size_of_from == size_of_to)\n        {\n            if (from_is_unsigned == to_is_unsigned)\n                return { .is_monotonic = true, .is_always_monotonic = true };\n\n            if (left_in_first_half == right_in_first_half)\n                return { .is_monotonic = true };\n\n            return {};\n        }\n\n        /// Size of type is expanded.\n        if (size_of_from < size_of_to)\n        {\n            if (from_is_unsigned == to_is_unsigned)\n                return { .is_monotonic = true, .is_always_monotonic = true };\n\n            if (!to_is_unsigned)\n                return { .is_monotonic = true, .is_always_monotonic = true };\n\n            /// signed -> unsigned. If arguments from the same half, then function is monotonic.\n            if (left_in_first_half == right_in_first_half)\n                return { .is_monotonic = true };\n\n            return {};\n        }\n\n        /// Size of type is shrunk.\n        if (size_of_from > size_of_to)\n        {\n            /// Function cannot be monotonic on unbounded ranges.\n            if (left.isNull() || right.isNull())\n                return {};\n\n            /// Function cannot be monotonic when left and right are not on the same ranges.\n            if (divideByRangeOfType(left.safeGet<UInt64>()) != divideByRangeOfType(right.safeGet<UInt64>()))\n                return {};\n\n            if (to_is_unsigned)\n                return { .is_monotonic = true };\n            else\n            {\n                // If To is signed, it's possible that the signedness is different after conversion. So we check it explicitly.\n                const bool is_monotonic = (T(left.safeGet<UInt64>()) >= 0) == (T(right.safeGet<UInt64>()) >= 0);\n\n                return { .is_monotonic = is_monotonic };\n            }\n        }\n\n        UNREACHABLE();\n    }\n};\n\nstruct ToDateMonotonicity\n{\n    static bool has() { return true; }\n\n    static IFunction::Monotonicity get(const IDataType & type, const Field & left, const Field & right)\n    {\n        auto which = WhichDataType(type);\n        if (which.isDateOrDate32() || which.isDateTime() || which.isDateTime64() || which.isInt8() || which.isInt16() || which.isUInt8()\n            || which.isUInt16())\n        {\n            return {.is_monotonic = true, .is_always_monotonic = true};\n        }\n        else if (\n            ((left.getType() == Field::Types::UInt64 || left.isNull()) && (right.getType() == Field::Types::UInt64 || right.isNull())\n             && ((left.isNull() || left.safeGet<UInt64>() < 0xFFFF) && (right.isNull() || right.safeGet<UInt64>() >= 0xFFFF)))\n            || ((left.getType() == Field::Types::Int64 || left.isNull()) && (right.getType() == Field::Types::Int64 || right.isNull())\n                && ((left.isNull() || left.safeGet<Int64>() < 0xFFFF) && (right.isNull() || right.safeGet<Int64>() >= 0xFFFF)))\n            || ((\n                (left.getType() == Field::Types::Float64 || left.isNull())\n                && (right.getType() == Field::Types::Float64 || right.isNull())\n                && ((left.isNull() || left.safeGet<Float64>() < 0xFFFF) && (right.isNull() || right.safeGet<Float64>() >= 0xFFFF))))\n            || !isNativeNumber(type))\n        {\n            return {};\n        }\n        else\n        {\n            return {.is_monotonic = true, .is_always_monotonic = true};\n        }\n    }\n};\n\nstruct ToDateTimeMonotonicity\n{\n    static bool has() { return true; }\n\n    static IFunction::Monotonicity get(const IDataType & type, const Field &, const Field &)\n    {\n        if (type.isValueRepresentedByNumber())\n            return {.is_monotonic = true, .is_always_monotonic = true};\n        else\n            return {};\n    }\n};\n\n/** The monotonicity for the `toString` function is mainly determined for test purposes.\n  * It is doubtful that anyone is looking to optimize queries with conditions `toString(CounterID) = 34`.\n  */\nstruct ToStringMonotonicity\n{\n    static bool has() { return true; }\n\n    static IFunction::Monotonicity get(const IDataType & type, const Field & left, const Field & right)\n    {\n        IFunction::Monotonicity positive{ .is_monotonic = true };\n        IFunction::Monotonicity not_monotonic;\n\n        const auto * type_ptr = &type;\n        if (const auto * low_cardinality_type = checkAndGetDataType<DataTypeLowCardinality>(type_ptr))\n            type_ptr = low_cardinality_type->getDictionaryType().get();\n\n        /// Order on enum values (which is the order on integers) is completely arbitrary in respect to the order on strings.\n        if (WhichDataType(type).isEnum())\n            return not_monotonic;\n\n        /// `toString` function is monotonous if the argument is Date or Date32 or DateTime or String, or non-negative numbers with the same number of symbols.\n        if (checkDataTypes<DataTypeDate, DataTypeDate32, DataTypeDateTime, DataTypeString>(type_ptr))\n            return positive;\n\n        if (left.isNull() || right.isNull())\n            return {};\n\n        if (left.getType() == Field::Types::UInt64\n            && right.getType() == Field::Types::UInt64)\n        {\n            return (left.safeGet<Int64>() == 0 && right.safeGet<Int64>() == 0)\n                || (floor(log10(left.safeGet<UInt64>())) == floor(log10(right.safeGet<UInt64>())))\n                ? positive : not_monotonic;\n        }\n\n        if (left.getType() == Field::Types::Int64\n            && right.getType() == Field::Types::Int64)\n        {\n            return (left.safeGet<Int64>() == 0 && right.safeGet<Int64>() == 0)\n                || (left.safeGet<Int64>() > 0 && right.safeGet<Int64>() > 0 && floor(log10(left.safeGet<Int64>())) == floor(log10(right.safeGet<Int64>())))\n                ? positive : not_monotonic;\n        }\n\n        return not_monotonic;\n    }\n};\n\n\nstruct NameToUInt8 { static constexpr auto name = \"toUInt8\"; };\nstruct NameToUInt16 { static constexpr auto name = \"toUInt16\"; };\nstruct NameToUInt32 { static constexpr auto name = \"toUInt32\"; };\nstruct NameToUInt64 { static constexpr auto name = \"toUInt64\"; };\nstruct NameToUInt128 { static constexpr auto name = \"toUInt128\"; };\nstruct NameToUInt256 { static constexpr auto name = \"toUInt256\"; };\nstruct NameToInt8 { static constexpr auto name = \"toInt8\"; };\nstruct NameToInt16 { static constexpr auto name = \"toInt16\"; };\nstruct NameToInt32 { static constexpr auto name = \"toInt32\"; };\nstruct NameToInt64 { static constexpr auto name = \"toInt64\"; };\nstruct NameToInt128 { static constexpr auto name = \"toInt128\"; };\nstruct NameToInt256 { static constexpr auto name = \"toInt256\"; };\nstruct NameToFloat32 { static constexpr auto name = \"toFloat32\"; };\nstruct NameToFloat64 { static constexpr auto name = \"toFloat64\"; };\nstruct NameToUUID { static constexpr auto name = \"toUUID\"; };\nstruct NameToIPv4 { static constexpr auto name = \"toIPv4\"; };\nstruct NameToIPv6 { static constexpr auto name = \"toIPv6\"; };\n\nusing FunctionToUInt8 = FunctionConvert<DataTypeUInt8, NameToUInt8, ToNumberMonotonicity<UInt8>>;\nusing FunctionToUInt16 = FunctionConvert<DataTypeUInt16, NameToUInt16, ToNumberMonotonicity<UInt16>>;\nusing FunctionToUInt32 = FunctionConvert<DataTypeUInt32, NameToUInt32, ToNumberMonotonicity<UInt32>>;\nusing FunctionToUInt64 = FunctionConvert<DataTypeUInt64, NameToUInt64, ToNumberMonotonicity<UInt64>>;\nusing FunctionToUInt128 = FunctionConvert<DataTypeUInt128, NameToUInt128, ToNumberMonotonicity<UInt128>>;\nusing FunctionToUInt256 = FunctionConvert<DataTypeUInt256, NameToUInt256, ToNumberMonotonicity<UInt256>>;\nusing FunctionToInt8 = FunctionConvert<DataTypeInt8, NameToInt8, ToNumberMonotonicity<Int8>>;\nusing FunctionToInt16 = FunctionConvert<DataTypeInt16, NameToInt16, ToNumberMonotonicity<Int16>>;\nusing FunctionToInt32 = FunctionConvert<DataTypeInt32, NameToInt32, ToNumberMonotonicity<Int32>>;\nusing FunctionToInt64 = FunctionConvert<DataTypeInt64, NameToInt64, ToNumberMonotonicity<Int64>>;\nusing FunctionToInt128 = FunctionConvert<DataTypeInt128, NameToInt128, ToNumberMonotonicity<Int128>>;\nusing FunctionToInt256 = FunctionConvert<DataTypeInt256, NameToInt256, ToNumberMonotonicity<Int256>>;\nusing FunctionToFloat32 = FunctionConvert<DataTypeFloat32, NameToFloat32, ToNumberMonotonicity<Float32>>;\nusing FunctionToFloat64 = FunctionConvert<DataTypeFloat64, NameToFloat64, ToNumberMonotonicity<Float64>>;\n\nusing FunctionToDate = FunctionConvert<DataTypeDate, NameToDate, ToDateMonotonicity>;\n\nusing FunctionToDate32 = FunctionConvert<DataTypeDate32, NameToDate32, ToDateMonotonicity>;\n\nusing FunctionToDateTime = FunctionConvert<DataTypeDateTime, NameToDateTime, ToDateTimeMonotonicity>;\n\nusing FunctionToDateTime32 = FunctionConvert<DataTypeDateTime, NameToDateTime32, ToDateTimeMonotonicity>;\n\nusing FunctionToDateTime64 = FunctionConvert<DataTypeDateTime64, NameToDateTime64, ToDateTimeMonotonicity>;\n\nusing FunctionToUUID = FunctionConvert<DataTypeUUID, NameToUUID, ToNumberMonotonicity<UInt128>>;\nusing FunctionToIPv4 = FunctionConvert<DataTypeIPv4, NameToIPv4, ToNumberMonotonicity<UInt32>>;\nusing FunctionToIPv6 = FunctionConvert<DataTypeIPv6, NameToIPv6, ToNumberMonotonicity<UInt128>>;\nusing FunctionToString = FunctionConvert<DataTypeString, NameToString, ToStringMonotonicity>;\nusing FunctionToUnixTimestamp = FunctionConvert<DataTypeUInt32, NameToUnixTimestamp, ToNumberMonotonicity<UInt32>>;\nusing FunctionToDecimal32 = FunctionConvert<DataTypeDecimal<Decimal32>, NameToDecimal32, UnknownMonotonicity>;\nusing FunctionToDecimal64 = FunctionConvert<DataTypeDecimal<Decimal64>, NameToDecimal64, UnknownMonotonicity>;\nusing FunctionToDecimal128 = FunctionConvert<DataTypeDecimal<Decimal128>, NameToDecimal128, UnknownMonotonicity>;\nusing FunctionToDecimal256 = FunctionConvert<DataTypeDecimal<Decimal256>, NameToDecimal256, UnknownMonotonicity>;\n\ntemplate <typename DataType, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior = default_date_time_overflow_behavior> struct FunctionTo;\n\ntemplate <> struct FunctionTo<DataTypeUInt8> { using Type = FunctionToUInt8; };\ntemplate <> struct FunctionTo<DataTypeUInt16> { using Type = FunctionToUInt16; };\ntemplate <> struct FunctionTo<DataTypeUInt32> { using Type = FunctionToUInt32; };\ntemplate <> struct FunctionTo<DataTypeUInt64> { using Type = FunctionToUInt64; };\ntemplate <> struct FunctionTo<DataTypeUInt128> { using Type = FunctionToUInt128; };\ntemplate <> struct FunctionTo<DataTypeUInt256> { using Type = FunctionToUInt256; };\ntemplate <> struct FunctionTo<DataTypeInt8> { using Type = FunctionToInt8; };\ntemplate <> struct FunctionTo<DataTypeInt16> { using Type = FunctionToInt16; };\ntemplate <> struct FunctionTo<DataTypeInt32> { using Type = FunctionToInt32; };\ntemplate <> struct FunctionTo<DataTypeInt64> { using Type = FunctionToInt64; };\ntemplate <> struct FunctionTo<DataTypeInt128> { using Type = FunctionToInt128; };\ntemplate <> struct FunctionTo<DataTypeInt256> { using Type = FunctionToInt256; };\ntemplate <> struct FunctionTo<DataTypeFloat32> { using Type = FunctionToFloat32; };\ntemplate <> struct FunctionTo<DataTypeFloat64> { using Type = FunctionToFloat64; };\n\ntemplate <FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\nstruct FunctionTo<DataTypeDate, date_time_overflow_behavior> { using Type = FunctionToDate; };\n\ntemplate <FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\nstruct FunctionTo<DataTypeDate32, date_time_overflow_behavior> { using Type = FunctionToDate32; };\n\ntemplate <FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\nstruct FunctionTo<DataTypeDateTime, date_time_overflow_behavior> { using Type = FunctionToDateTime; };\n\ntemplate <FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\nstruct FunctionTo<DataTypeDateTime64, date_time_overflow_behavior> { using Type = FunctionToDateTime64; };\n\ntemplate <> struct FunctionTo<DataTypeUUID> { using Type = FunctionToUUID; };\ntemplate <> struct FunctionTo<DataTypeIPv4> { using Type = FunctionToIPv4; };\ntemplate <> struct FunctionTo<DataTypeIPv6> { using Type = FunctionToIPv6; };\ntemplate <> struct FunctionTo<DataTypeString> { using Type = FunctionToString; };\ntemplate <> struct FunctionTo<DataTypeFixedString> { using Type = FunctionToFixedString; };\ntemplate <> struct FunctionTo<DataTypeDecimal<Decimal32>> { using Type = FunctionToDecimal32; };\ntemplate <> struct FunctionTo<DataTypeDecimal<Decimal64>> { using Type = FunctionToDecimal64; };\ntemplate <> struct FunctionTo<DataTypeDecimal<Decimal128>> { using Type = FunctionToDecimal128; };\ntemplate <> struct FunctionTo<DataTypeDecimal<Decimal256>> { using Type = FunctionToDecimal256; };\n\ntemplate <typename FieldType> struct FunctionTo<DataTypeEnum<FieldType>>\n    : FunctionTo<DataTypeNumber<FieldType>>\n{\n};\n\nstruct NameToUInt8OrZero { static constexpr auto name = \"toUInt8OrZero\"; };\nstruct NameToUInt16OrZero { static constexpr auto name = \"toUInt16OrZero\"; };\nstruct NameToUInt32OrZero { static constexpr auto name = \"toUInt32OrZero\"; };\nstruct NameToUInt64OrZero { static constexpr auto name = \"toUInt64OrZero\"; };\nstruct NameToUInt128OrZero { static constexpr auto name = \"toUInt128OrZero\"; };\nstruct NameToUInt256OrZero { static constexpr auto name = \"toUInt256OrZero\"; };\nstruct NameToInt8OrZero { static constexpr auto name = \"toInt8OrZero\"; };\nstruct NameToInt16OrZero { static constexpr auto name = \"toInt16OrZero\"; };\nstruct NameToInt32OrZero { static constexpr auto name = \"toInt32OrZero\"; };\nstruct NameToInt64OrZero { static constexpr auto name = \"toInt64OrZero\"; };\nstruct NameToInt128OrZero { static constexpr auto name = \"toInt128OrZero\"; };\nstruct NameToInt256OrZero { static constexpr auto name = \"toInt256OrZero\"; };\nstruct NameToFloat32OrZero { static constexpr auto name = \"toFloat32OrZero\"; };\nstruct NameToFloat64OrZero { static constexpr auto name = \"toFloat64OrZero\"; };\nstruct NameToDateOrZero { static constexpr auto name = \"toDateOrZero\"; };\nstruct NameToDate32OrZero { static constexpr auto name = \"toDate32OrZero\"; };\nstruct NameToDateTimeOrZero { static constexpr auto name = \"toDateTimeOrZero\"; };\nstruct NameToDateTime64OrZero { static constexpr auto name = \"toDateTime64OrZero\"; };\nstruct NameToDecimal32OrZero { static constexpr auto name = \"toDecimal32OrZero\"; };\nstruct NameToDecimal64OrZero { static constexpr auto name = \"toDecimal64OrZero\"; };\nstruct NameToDecimal128OrZero { static constexpr auto name = \"toDecimal128OrZero\"; };\nstruct NameToDecimal256OrZero { static constexpr auto name = \"toDecimal256OrZero\"; };\nstruct NameToUUIDOrZero { static constexpr auto name = \"toUUIDOrZero\"; };\nstruct NameToIPv4OrZero { static constexpr auto name = \"toIPv4OrZero\"; };\nstruct NameToIPv6OrZero { static constexpr auto name = \"toIPv6OrZero\"; };\n\nusing FunctionToUInt8OrZero = FunctionConvertFromString<DataTypeUInt8, NameToUInt8OrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToUInt16OrZero = FunctionConvertFromString<DataTypeUInt16, NameToUInt16OrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToUInt32OrZero = FunctionConvertFromString<DataTypeUInt32, NameToUInt32OrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToUInt64OrZero = FunctionConvertFromString<DataTypeUInt64, NameToUInt64OrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToUInt128OrZero = FunctionConvertFromString<DataTypeUInt128, NameToUInt128OrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToUInt256OrZero = FunctionConvertFromString<DataTypeUInt256, NameToUInt256OrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToInt8OrZero = FunctionConvertFromString<DataTypeInt8, NameToInt8OrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToInt16OrZero = FunctionConvertFromString<DataTypeInt16, NameToInt16OrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToInt32OrZero = FunctionConvertFromString<DataTypeInt32, NameToInt32OrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToInt64OrZero = FunctionConvertFromString<DataTypeInt64, NameToInt64OrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToInt128OrZero = FunctionConvertFromString<DataTypeInt128, NameToInt128OrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToInt256OrZero = FunctionConvertFromString<DataTypeInt256, NameToInt256OrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToFloat32OrZero = FunctionConvertFromString<DataTypeFloat32, NameToFloat32OrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToFloat64OrZero = FunctionConvertFromString<DataTypeFloat64, NameToFloat64OrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToDateOrZero = FunctionConvertFromString<DataTypeDate, NameToDateOrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToDate32OrZero = FunctionConvertFromString<DataTypeDate32, NameToDate32OrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToDateTimeOrZero = FunctionConvertFromString<DataTypeDateTime, NameToDateTimeOrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToDateTime64OrZero = FunctionConvertFromString<DataTypeDateTime64, NameToDateTime64OrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToDecimal32OrZero = FunctionConvertFromString<DataTypeDecimal<Decimal32>, NameToDecimal32OrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToDecimal64OrZero = FunctionConvertFromString<DataTypeDecimal<Decimal64>, NameToDecimal64OrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToDecimal128OrZero = FunctionConvertFromString<DataTypeDecimal<Decimal128>, NameToDecimal128OrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToDecimal256OrZero = FunctionConvertFromString<DataTypeDecimal<Decimal256>, NameToDecimal256OrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToUUIDOrZero = FunctionConvertFromString<DataTypeUUID, NameToUUIDOrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToIPv4OrZero = FunctionConvertFromString<DataTypeIPv4, NameToIPv4OrZero, ConvertFromStringExceptionMode::Zero>;\nusing FunctionToIPv6OrZero = FunctionConvertFromString<DataTypeIPv6, NameToIPv6OrZero, ConvertFromStringExceptionMode::Zero>;\n\nstruct NameToUInt8OrNull { static constexpr auto name = \"toUInt8OrNull\"; };\nstruct NameToUInt16OrNull { static constexpr auto name = \"toUInt16OrNull\"; };\nstruct NameToUInt32OrNull { static constexpr auto name = \"toUInt32OrNull\"; };\nstruct NameToUInt64OrNull { static constexpr auto name = \"toUInt64OrNull\"; };\nstruct NameToUInt128OrNull { static constexpr auto name = \"toUInt128OrNull\"; };\nstruct NameToUInt256OrNull { static constexpr auto name = \"toUInt256OrNull\"; };\nstruct NameToInt8OrNull { static constexpr auto name = \"toInt8OrNull\"; };\nstruct NameToInt16OrNull { static constexpr auto name = \"toInt16OrNull\"; };\nstruct NameToInt32OrNull { static constexpr auto name = \"toInt32OrNull\"; };\nstruct NameToInt64OrNull { static constexpr auto name = \"toInt64OrNull\"; };\nstruct NameToInt128OrNull { static constexpr auto name = \"toInt128OrNull\"; };\nstruct NameToInt256OrNull { static constexpr auto name = \"toInt256OrNull\"; };\nstruct NameToFloat32OrNull { static constexpr auto name = \"toFloat32OrNull\"; };\nstruct NameToFloat64OrNull { static constexpr auto name = \"toFloat64OrNull\"; };\nstruct NameToDateOrNull { static constexpr auto name = \"toDateOrNull\"; };\nstruct NameToDate32OrNull { static constexpr auto name = \"toDate32OrNull\"; };\nstruct NameToDateTimeOrNull { static constexpr auto name = \"toDateTimeOrNull\"; };\nstruct NameToDateTime64OrNull { static constexpr auto name = \"toDateTime64OrNull\"; };\nstruct NameToDecimal32OrNull { static constexpr auto name = \"toDecimal32OrNull\"; };\nstruct NameToDecimal64OrNull { static constexpr auto name = \"toDecimal64OrNull\"; };\nstruct NameToDecimal128OrNull { static constexpr auto name = \"toDecimal128OrNull\"; };\nstruct NameToDecimal256OrNull { static constexpr auto name = \"toDecimal256OrNull\"; };\nstruct NameToUUIDOrNull { static constexpr auto name = \"toUUIDOrNull\"; };\nstruct NameToIPv4OrNull { static constexpr auto name = \"toIPv4OrNull\"; };\nstruct NameToIPv6OrNull { static constexpr auto name = \"toIPv6OrNull\"; };\n\nusing FunctionToUInt8OrNull = FunctionConvertFromString<DataTypeUInt8, NameToUInt8OrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToUInt16OrNull = FunctionConvertFromString<DataTypeUInt16, NameToUInt16OrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToUInt32OrNull = FunctionConvertFromString<DataTypeUInt32, NameToUInt32OrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToUInt64OrNull = FunctionConvertFromString<DataTypeUInt64, NameToUInt64OrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToUInt128OrNull = FunctionConvertFromString<DataTypeUInt128, NameToUInt128OrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToUInt256OrNull = FunctionConvertFromString<DataTypeUInt256, NameToUInt256OrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToInt8OrNull = FunctionConvertFromString<DataTypeInt8, NameToInt8OrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToInt16OrNull = FunctionConvertFromString<DataTypeInt16, NameToInt16OrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToInt32OrNull = FunctionConvertFromString<DataTypeInt32, NameToInt32OrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToInt64OrNull = FunctionConvertFromString<DataTypeInt64, NameToInt64OrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToInt128OrNull = FunctionConvertFromString<DataTypeInt128, NameToInt128OrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToInt256OrNull = FunctionConvertFromString<DataTypeInt256, NameToInt256OrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToFloat32OrNull = FunctionConvertFromString<DataTypeFloat32, NameToFloat32OrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToFloat64OrNull = FunctionConvertFromString<DataTypeFloat64, NameToFloat64OrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToDateOrNull = FunctionConvertFromString<DataTypeDate, NameToDateOrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToDate32OrNull = FunctionConvertFromString<DataTypeDate32, NameToDate32OrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToDateTimeOrNull = FunctionConvertFromString<DataTypeDateTime, NameToDateTimeOrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToDateTime64OrNull = FunctionConvertFromString<DataTypeDateTime64, NameToDateTime64OrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToDecimal32OrNull = FunctionConvertFromString<DataTypeDecimal<Decimal32>, NameToDecimal32OrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToDecimal64OrNull = FunctionConvertFromString<DataTypeDecimal<Decimal64>, NameToDecimal64OrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToDecimal128OrNull = FunctionConvertFromString<DataTypeDecimal<Decimal128>, NameToDecimal128OrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToDecimal256OrNull = FunctionConvertFromString<DataTypeDecimal<Decimal256>, NameToDecimal256OrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToUUIDOrNull = FunctionConvertFromString<DataTypeUUID, NameToUUIDOrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToIPv4OrNull = FunctionConvertFromString<DataTypeIPv4, NameToIPv4OrNull, ConvertFromStringExceptionMode::Null>;\nusing FunctionToIPv6OrNull = FunctionConvertFromString<DataTypeIPv6, NameToIPv6OrNull, ConvertFromStringExceptionMode::Null>;\n\nstruct NameParseDateTimeBestEffort { static constexpr auto name = \"parseDateTimeBestEffort\"; };\nstruct NameParseDateTimeBestEffortOrZero { static constexpr auto name = \"parseDateTimeBestEffortOrZero\"; };\nstruct NameParseDateTimeBestEffortOrNull { static constexpr auto name = \"parseDateTimeBestEffortOrNull\"; };\nstruct NameParseDateTimeBestEffortUS { static constexpr auto name = \"parseDateTimeBestEffortUS\"; };\nstruct NameParseDateTimeBestEffortUSOrZero { static constexpr auto name = \"parseDateTimeBestEffortUSOrZero\"; };\nstruct NameParseDateTimeBestEffortUSOrNull { static constexpr auto name = \"parseDateTimeBestEffortUSOrNull\"; };\nstruct NameParseDateTime32BestEffort { static constexpr auto name = \"parseDateTime32BestEffort\"; };\nstruct NameParseDateTime32BestEffortOrZero { static constexpr auto name = \"parseDateTime32BestEffortOrZero\"; };\nstruct NameParseDateTime32BestEffortOrNull { static constexpr auto name = \"parseDateTime32BestEffortOrNull\"; };\nstruct NameParseDateTime64BestEffort { static constexpr auto name = \"parseDateTime64BestEffort\"; };\nstruct NameParseDateTime64BestEffortOrZero { static constexpr auto name = \"parseDateTime64BestEffortOrZero\"; };\nstruct NameParseDateTime64BestEffortOrNull { static constexpr auto name = \"parseDateTime64BestEffortOrNull\"; };\nstruct NameParseDateTime64BestEffortUS { static constexpr auto name = \"parseDateTime64BestEffortUS\"; };\nstruct NameParseDateTime64BestEffortUSOrZero { static constexpr auto name = \"parseDateTime64BestEffortUSOrZero\"; };\nstruct NameParseDateTime64BestEffortUSOrNull { static constexpr auto name = \"parseDateTime64BestEffortUSOrNull\"; };\n\n\nusing FunctionParseDateTimeBestEffort = FunctionConvertFromString<\n    DataTypeDateTime, NameParseDateTimeBestEffort, ConvertFromStringExceptionMode::Throw, ConvertFromStringParsingMode::BestEffort>;\nusing FunctionParseDateTimeBestEffortOrZero = FunctionConvertFromString<\n    DataTypeDateTime, NameParseDateTimeBestEffortOrZero, ConvertFromStringExceptionMode::Zero, ConvertFromStringParsingMode::BestEffort>;\nusing FunctionParseDateTimeBestEffortOrNull = FunctionConvertFromString<\n    DataTypeDateTime, NameParseDateTimeBestEffortOrNull, ConvertFromStringExceptionMode::Null, ConvertFromStringParsingMode::BestEffort>;\n\nusing FunctionParseDateTimeBestEffortUS = FunctionConvertFromString<\n    DataTypeDateTime, NameParseDateTimeBestEffortUS, ConvertFromStringExceptionMode::Throw, ConvertFromStringParsingMode::BestEffortUS>;\nusing FunctionParseDateTimeBestEffortUSOrZero = FunctionConvertFromString<\n    DataTypeDateTime, NameParseDateTimeBestEffortUSOrZero, ConvertFromStringExceptionMode::Zero, ConvertFromStringParsingMode::BestEffortUS>;\nusing FunctionParseDateTimeBestEffortUSOrNull = FunctionConvertFromString<\n    DataTypeDateTime, NameParseDateTimeBestEffortUSOrNull, ConvertFromStringExceptionMode::Null, ConvertFromStringParsingMode::BestEffortUS>;\n\nusing FunctionParseDateTime32BestEffort = FunctionConvertFromString<\n    DataTypeDateTime, NameParseDateTime32BestEffort, ConvertFromStringExceptionMode::Throw, ConvertFromStringParsingMode::BestEffort>;\nusing FunctionParseDateTime32BestEffortOrZero = FunctionConvertFromString<\n    DataTypeDateTime, NameParseDateTime32BestEffortOrZero, ConvertFromStringExceptionMode::Zero, ConvertFromStringParsingMode::BestEffort>;\nusing FunctionParseDateTime32BestEffortOrNull = FunctionConvertFromString<\n    DataTypeDateTime, NameParseDateTime32BestEffortOrNull, ConvertFromStringExceptionMode::Null, ConvertFromStringParsingMode::BestEffort>;\n\nusing FunctionParseDateTime64BestEffort = FunctionConvertFromString<\n    DataTypeDateTime64, NameParseDateTime64BestEffort, ConvertFromStringExceptionMode::Throw, ConvertFromStringParsingMode::BestEffort>;\nusing FunctionParseDateTime64BestEffortOrZero = FunctionConvertFromString<\n    DataTypeDateTime64, NameParseDateTime64BestEffortOrZero, ConvertFromStringExceptionMode::Zero, ConvertFromStringParsingMode::BestEffort>;\nusing FunctionParseDateTime64BestEffortOrNull = FunctionConvertFromString<\n    DataTypeDateTime64, NameParseDateTime64BestEffortOrNull, ConvertFromStringExceptionMode::Null, ConvertFromStringParsingMode::BestEffort>;\n\nusing FunctionParseDateTime64BestEffortUS = FunctionConvertFromString<\n    DataTypeDateTime64, NameParseDateTime64BestEffortUS, ConvertFromStringExceptionMode::Throw, ConvertFromStringParsingMode::BestEffortUS>;\nusing FunctionParseDateTime64BestEffortUSOrZero = FunctionConvertFromString<\n    DataTypeDateTime64, NameParseDateTime64BestEffortUSOrZero, ConvertFromStringExceptionMode::Zero, ConvertFromStringParsingMode::BestEffortUS>;\nusing FunctionParseDateTime64BestEffortUSOrNull = FunctionConvertFromString<\n    DataTypeDateTime64, NameParseDateTime64BestEffortUSOrNull, ConvertFromStringExceptionMode::Null, ConvertFromStringParsingMode::BestEffortUS>;\n\n\nclass ExecutableFunctionCast : public IExecutableFunction\n{\npublic:\n    using WrapperType = std::function<ColumnPtr(ColumnsWithTypeAndName &, const DataTypePtr &, const ColumnNullable *, size_t)>;\n\n    explicit ExecutableFunctionCast(\n            WrapperType && wrapper_function_, const char * name_, std::optional<CastDiagnostic> diagnostic_)\n            : wrapper_function(std::move(wrapper_function_)), name(name_), diagnostic(std::move(diagnostic_)) {}\n\n    String getName() const override { return name; }\n\nprotected:\n    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override\n    {\n        /// drop second argument, pass others\n        ColumnsWithTypeAndName new_arguments{arguments.front()};\n        if (arguments.size() > 2)\n            new_arguments.insert(std::end(new_arguments), std::next(std::begin(arguments), 2), std::end(arguments));\n\n        try\n        {\n            return wrapper_function(new_arguments, result_type, nullptr, input_rows_count);\n        }\n        catch (Exception & e)\n        {\n            if (diagnostic)\n                e.addMessage(\"while converting source column \" + backQuoteIfNeed(diagnostic->column_from) +\n                             \" to destination column \" + backQuoteIfNeed(diagnostic->column_to));\n            throw;\n        }\n    }\n\n    bool useDefaultImplementationForNulls() const override { return false; }\n    /// CAST(Nothing, T) -> T\n    bool useDefaultImplementationForNothing() const override { return false; }\n    bool useDefaultImplementationForConstants() const override { return true; }\n    bool useDefaultImplementationForLowCardinalityColumns() const override { return false; }\n    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1}; }\n\nprivate:\n    WrapperType wrapper_function;\n    const char * name;\n    std::optional<CastDiagnostic> diagnostic;\n};\n\n\nstruct FunctionCastName\n{\n    static constexpr auto name = \"CAST\";\n};\n\nclass FunctionCast final : public IFunctionBase\n{\npublic:\n    using MonotonicityForRange = std::function<Monotonicity(const IDataType &, const Field &, const Field &)>;\n    using WrapperType = std::function<ColumnPtr(ColumnsWithTypeAndName &, const DataTypePtr &, const ColumnNullable *, size_t)>;\n\n    FunctionCast(ContextPtr context_\n            , const char * cast_name_\n            , MonotonicityForRange && monotonicity_for_range_\n            , const DataTypes & argument_types_\n            , const DataTypePtr & return_type_\n            , std::optional<CastDiagnostic> diagnostic_\n            , CastType cast_type_)\n        : cast_name(cast_name_), monotonicity_for_range(std::move(monotonicity_for_range_))\n        , argument_types(argument_types_), return_type(return_type_), diagnostic(std::move(diagnostic_))\n        , cast_type(cast_type_)\n        , context(context_)\n    {\n    }\n\n    const DataTypes & getArgumentTypes() const override { return argument_types; }\n    const DataTypePtr & getResultType() const override { return return_type; }\n\n    ExecutableFunctionPtr prepare(const ColumnsWithTypeAndName & /*sample_columns*/) const override\n    {\n        try\n        {\n            return std::make_unique<ExecutableFunctionCast>(\n                prepareUnpackDictionaries(getArgumentTypes()[0], getResultType()), cast_name, diagnostic);\n        }\n        catch (Exception & e)\n        {\n            if (diagnostic)\n                e.addMessage(\"while converting source column \" + backQuoteIfNeed(diagnostic->column_from) +\n                             \" to destination column \" + backQuoteIfNeed(diagnostic->column_to));\n            throw;\n        }\n    }\n\n    String getName() const override { return cast_name; }\n\n    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n\n    bool hasInformationAboutMonotonicity() const override\n    {\n        return static_cast<bool>(monotonicity_for_range);\n    }\n\n    Monotonicity getMonotonicityForRange(const IDataType & type, const Field & left, const Field & right) const override\n    {\n        return monotonicity_for_range(type, left, right);\n    }\n\nprivate:\n    const char * cast_name;\n    MonotonicityForRange monotonicity_for_range;\n\n    DataTypes argument_types;\n    DataTypePtr return_type;\n\n    std::optional<CastDiagnostic> diagnostic;\n    CastType cast_type;\n    ContextPtr context;\n\n    static WrapperType createFunctionAdaptor(FunctionPtr function, const DataTypePtr & from_type)\n    {\n        auto function_adaptor = std::make_unique<FunctionToOverloadResolverAdaptor>(function)->build({ColumnWithTypeAndName{nullptr, from_type, \"\"}});\n\n        return [function_adaptor]\n            (ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable *, size_t input_rows_count)\n        {\n            return function_adaptor->execute(arguments, result_type, input_rows_count);\n        };\n    }\n\n    static WrapperType createToNullableColumnWrapper()\n    {\n        return [] (ColumnsWithTypeAndName &, const DataTypePtr & result_type, const ColumnNullable *, size_t input_rows_count)\n        {\n            ColumnPtr res = result_type->createColumn();\n            ColumnUInt8::Ptr col_null_map_to = ColumnUInt8::create(input_rows_count, true);\n            return ColumnNullable::create(res->cloneResized(input_rows_count), std::move(col_null_map_to));\n        };\n    }\n\n    template <typename ToDataType>\n    WrapperType createWrapper(const DataTypePtr & from_type, const ToDataType * const to_type, bool requested_result_is_nullable) const\n    {\n        TypeIndex from_type_index = from_type->getTypeId();\n        WhichDataType which(from_type_index);\n        TypeIndex to_type_index = to_type->getTypeId();\n        WhichDataType to(to_type_index);\n        bool can_apply_accurate_cast = (cast_type == CastType::accurate || cast_type == CastType::accurateOrNull)\n            && (which.isInt() || which.isUInt() || which.isFloat());\n        can_apply_accurate_cast |= cast_type == CastType::accurate && which.isStringOrFixedString() && to.isNativeInteger();\n\n        FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior = default_date_time_overflow_behavior;\n        if (context)\n            date_time_overflow_behavior = context->getSettingsRef()[Setting::date_time_overflow_behavior];\n\n        if (requested_result_is_nullable && checkAndGetDataType<DataTypeString>(from_type.get()))\n        {\n            /// In case when converting to Nullable type, we apply different parsing rule,\n            /// that will not throw an exception but return NULL in case of malformed input.\n            FunctionPtr function = FunctionConvertFromString<ToDataType, FunctionCastName, ConvertFromStringExceptionMode::Null>::create(context);\n            return createFunctionAdaptor(function, from_type);\n        }\n        else if (!can_apply_accurate_cast)\n        {\n            FunctionPtr function = FunctionTo<ToDataType>::Type::create(context);\n            return createFunctionAdaptor(function, from_type);\n        }\n\n        return [wrapper_cast_type = cast_type, from_type_index, to_type, date_time_overflow_behavior]\n            (ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable * column_nullable, size_t input_rows_count)\n        {\n            ColumnPtr result_column;\n            auto res = callOnIndexAndDataType<ToDataType>(from_type_index, [&](const auto & types) -> bool\n            {\n                using Types = std::decay_t<decltype(types)>;\n                using LeftDataType = typename Types::LeftType;\n                using RightDataType = typename Types::RightType;\n\n                if constexpr (IsDataTypeNumber<LeftDataType>)\n                {\n                    if constexpr (IsDataTypeDateOrDateTime<RightDataType>)\n                    {\n#define GENERATE_OVERFLOW_MODE_CASE(OVERFLOW_MODE, ADDITIONS) \\\n    case FormatSettings::DateTimeOverflowBehavior::OVERFLOW_MODE: \\\n        result_column \\\n            = ConvertImpl<LeftDataType, RightDataType, FunctionCastName, FormatSettings::DateTimeOverflowBehavior::OVERFLOW_MODE>:: \\\n                execute(arguments, result_type, input_rows_count, BehaviourOnErrorFromString::ConvertDefaultBehaviorTag, ADDITIONS()); \\\n        break;\n                        if (wrapper_cast_type == CastType::accurate)\n                        {\n                            switch (date_time_overflow_behavior)\n                            {\n                                GENERATE_OVERFLOW_MODE_CASE(Throw, DateTimeAccurateConvertStrategyAdditions)\n                                GENERATE_OVERFLOW_MODE_CASE(Ignore, DateTimeAccurateConvertStrategyAdditions)\n                                GENERATE_OVERFLOW_MODE_CASE(Saturate, DateTimeAccurateConvertStrategyAdditions)\n                            }\n                        }\n                        else\n                        {\n                            switch (date_time_overflow_behavior)\n                            {\n                                GENERATE_OVERFLOW_MODE_CASE(Throw, DateTimeAccurateOrNullConvertStrategyAdditions)\n                                GENERATE_OVERFLOW_MODE_CASE(Ignore, DateTimeAccurateOrNullConvertStrategyAdditions)\n                                GENERATE_OVERFLOW_MODE_CASE(Saturate, DateTimeAccurateOrNullConvertStrategyAdditions)\n                            }\n                        }\n#undef GENERATE_OVERFLOW_MODE_CASE\n\n                        return true;\n                    }\n                    else if constexpr (IsDataTypeNumber<RightDataType>)\n                    {\n                        if (wrapper_cast_type == CastType::accurate)\n                        {\n                            result_column = ConvertImpl<LeftDataType, RightDataType, FunctionCastName>::execute(\n                                arguments,\n                                result_type,\n                                input_rows_count,\n                                BehaviourOnErrorFromString::ConvertDefaultBehaviorTag,\n                                AccurateConvertStrategyAdditions());\n                        }\n                        else\n                        {\n                            result_column = ConvertImpl<LeftDataType, RightDataType, FunctionCastName>::execute(\n                                arguments,\n                                result_type,\n                                input_rows_count,\n                                BehaviourOnErrorFromString::ConvertDefaultBehaviorTag,\n                                AccurateOrNullConvertStrategyAdditions());\n                        }\n\n                        return true;\n                    }\n                }\n                else if constexpr (IsDataTypeStringOrFixedString<LeftDataType>)\n                {\n                    if constexpr (IsDataTypeNumber<RightDataType>)\n                    {\n                        chassert(wrapper_cast_type == CastType::accurate);\n                        result_column = ConvertImpl<LeftDataType, RightDataType, FunctionCastName>::execute(\n                            arguments,\n                            result_type,\n                            input_rows_count,\n                            BehaviourOnErrorFromString::ConvertDefaultBehaviorTag,\n                            AccurateConvertStrategyAdditions());\n                    }\n                    return true;\n                }\n\n                return false;\n            });\n\n            /// Additionally check if callOnIndexAndDataType wasn't called at all.\n            if (!res)\n            {\n                if (wrapper_cast_type == CastType::accurateOrNull)\n                {\n                    auto nullable_column_wrapper = FunctionCast::createToNullableColumnWrapper();\n                    return nullable_column_wrapper(arguments, result_type, column_nullable, input_rows_count);\n                }\n                else\n                {\n                    throw Exception(ErrorCodes::CANNOT_CONVERT_TYPE,\n                        \"Conversion from {} to {} is not supported\",\n                        from_type_index, to_type->getName());\n                }\n            }\n\n            return result_column;\n        };\n    }\n\n    template <typename ToDataType>\n    WrapperType createBoolWrapper(const DataTypePtr & from_type, const ToDataType * const to_type, bool requested_result_is_nullable) const\n    {\n        if (checkAndGetDataType<DataTypeString>(from_type.get()))\n        {\n            if (cast_type == CastType::accurateOrNull)\n            {\n                return [this](ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable * column_nullable, size_t input_rows_count) -> ColumnPtr\n                {\n                    return ConvertImplGenericFromString<false>::execute(arguments, result_type, column_nullable, input_rows_count, context);\n                };\n            }\n\n            return [this](ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable * column_nullable, size_t input_rows_count) -> ColumnPtr\n            {\n                return ConvertImplGenericFromString<true>::execute(arguments, result_type, column_nullable, input_rows_count, context);\n            };\n        }\n\n        return createWrapper<ToDataType>(from_type, to_type, requested_result_is_nullable);\n    }\n\n    WrapperType createUInt8ToBoolWrapper(const DataTypePtr from_type, const DataTypePtr to_type) const\n    {\n        return [from_type, to_type] (ColumnsWithTypeAndName & arguments, const DataTypePtr &, const ColumnNullable *, size_t /*input_rows_count*/) -> ColumnPtr\n        {\n            /// Special case when we convert UInt8 column to Bool column.\n            /// both columns have type UInt8, but we shouldn't use identity wrapper,\n            /// because Bool column can contain only 0 and 1.\n            auto res_column = to_type->createColumn();\n            const auto & data_from = checkAndGetColumn<ColumnUInt8>(*arguments[0].column).getData();\n            auto & data_to = assert_cast<ColumnUInt8 *>(res_column.get())->getData();\n            data_to.resize(data_from.size());\n            for (size_t i = 0; i != data_from.size(); ++i)\n                data_to[i] = static_cast<bool>(data_from[i]);\n            return res_column;\n        };\n    }\n\n    WrapperType createStringWrapper(const DataTypePtr & from_type) const\n    {\n        FunctionPtr function = FunctionToString::create(context);\n        return createFunctionAdaptor(function, from_type);\n    }\n\n    WrapperType createFixedStringWrapper(const DataTypePtr & from_type, const size_t N) const\n    {\n        if (!isStringOrFixedString(from_type))\n            throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"CAST AS FixedString is only implemented for types String and FixedString\");\n\n        bool exception_mode_null = cast_type == CastType::accurateOrNull;\n        return [exception_mode_null, N] (ColumnsWithTypeAndName & arguments, const DataTypePtr &, const ColumnNullable *, size_t /*input_rows_count*/)\n        {\n            if (exception_mode_null)\n                return FunctionToFixedString::executeForN<ConvertToFixedStringExceptionMode::Null>(arguments, N);\n            else\n                return FunctionToFixedString::executeForN<ConvertToFixedStringExceptionMode::Throw>(arguments, N);\n        };\n    }\n\n#define GENERATE_INTERVAL_CASE(INTERVAL_KIND) \\\n            case IntervalKind::Kind::INTERVAL_KIND: \\\n                return createFunctionAdaptor(FunctionConvert<DataTypeInterval, NameToInterval##INTERVAL_KIND, PositiveMonotonicity>::create(context), from_type);\n\n    WrapperType createIntervalWrapper(const DataTypePtr & from_type, IntervalKind kind) const\n    {\n        switch (kind.kind)\n        {\n            GENERATE_INTERVAL_CASE(Nanosecond)\n            GENERATE_INTERVAL_CASE(Microsecond)\n            GENERATE_INTERVAL_CASE(Millisecond)\n            GENERATE_INTERVAL_CASE(Second)\n            GENERATE_INTERVAL_CASE(Minute)\n            GENERATE_INTERVAL_CASE(Hour)\n            GENERATE_INTERVAL_CASE(Day)\n            GENERATE_INTERVAL_CASE(Week)\n            GENERATE_INTERVAL_CASE(Month)\n            GENERATE_INTERVAL_CASE(Quarter)\n            GENERATE_INTERVAL_CASE(Year)\n        }\n        throw Exception{ErrorCodes::CANNOT_CONVERT_TYPE, \"Conversion to unexpected IntervalKind: {}\", kind.toString()};\n    }\n\n#undef GENERATE_INTERVAL_CASE\n\n    template <typename ToDataType>\n    requires IsDataTypeDecimal<ToDataType>\n    WrapperType createDecimalWrapper(const DataTypePtr & from_type, const ToDataType * to_type, bool requested_result_is_nullable) const\n    {\n        TypeIndex type_index = from_type->getTypeId();\n        UInt32 scale = to_type->getScale();\n\n        WhichDataType which(type_index);\n        bool ok = which.isNativeInt() || which.isNativeUInt() || which.isDecimal() || which.isFloat() || which.isDateOrDate32() || which.isDateTime() || which.isDateTime64()\n            || which.isStringOrFixedString();\n        if (!ok)\n        {\n            if (cast_type == CastType::accurateOrNull)\n                return createToNullableColumnWrapper();\n            else\n                throw Exception(ErrorCodes::CANNOT_CONVERT_TYPE, \"Conversion from {} to {} is not supported\",\n                    from_type->getName(), to_type->getName());\n        }\n\n        auto wrapper_cast_type = cast_type;\n\n        return [wrapper_cast_type, type_index, scale, to_type, requested_result_is_nullable]\n            (ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable *column_nullable, size_t input_rows_count)\n        {\n            ColumnPtr result_column;\n            auto res = callOnIndexAndDataType<ToDataType>(type_index, [&](const auto & types) -> bool\n            {\n                using Types = std::decay_t<decltype(types)>;\n                using LeftDataType = typename Types::LeftType;\n                using RightDataType = typename Types::RightType;\n\n                if constexpr (IsDataTypeDecimalOrNumber<LeftDataType> && IsDataTypeDecimalOrNumber<RightDataType> && !std::is_same_v<DataTypeDateTime64, RightDataType>)\n                {\n                    if (wrapper_cast_type == CastType::accurate)\n                    {\n                        AccurateConvertStrategyAdditions additions;\n                        additions.scale = scale;\n                        result_column = ConvertImpl<LeftDataType, RightDataType, FunctionCastName>::execute(\n                            arguments, result_type, input_rows_count, BehaviourOnErrorFromString::ConvertDefaultBehaviorTag, additions);\n\n                        return true;\n                    }\n                    else if (wrapper_cast_type == CastType::accurateOrNull)\n                    {\n                        AccurateOrNullConvertStrategyAdditions additions;\n                        additions.scale = scale;\n                        result_column = ConvertImpl<LeftDataType, RightDataType, FunctionCastName>::execute(\n                            arguments, result_type, input_rows_count, BehaviourOnErrorFromString::ConvertDefaultBehaviorTag, additions);\n\n                        return true;\n                    }\n                }\n                else if constexpr (std::is_same_v<LeftDataType, DataTypeString>)\n                {\n                    if (requested_result_is_nullable)\n                    {\n                        /// Consistent with CAST(Nullable(String) AS Nullable(Numbers))\n                        /// In case when converting to Nullable type, we apply different parsing rule,\n                        /// that will not throw an exception but return NULL in case of malformed input.\n                        result_column = ConvertImpl<LeftDataType, RightDataType, FunctionCastName>::execute(\n                            arguments, result_type, input_rows_count, BehaviourOnErrorFromString::ConvertReturnNullOnErrorTag, scale);\n\n                        return true;\n                    }\n                }\n\n                result_column = ConvertImpl<LeftDataType, RightDataType, FunctionCastName>::execute(arguments, result_type, input_rows_count, BehaviourOnErrorFromString::ConvertDefaultBehaviorTag, scale);\n\n                return true;\n            });\n\n            /// Additionally check if callOnIndexAndDataType wasn't called at all.\n            if (!res)\n            {\n                if (wrapper_cast_type == CastType::accurateOrNull)\n                {\n                    auto nullable_column_wrapper = FunctionCast::createToNullableColumnWrapper();\n                    return nullable_column_wrapper(arguments, result_type, column_nullable, input_rows_count);\n                }\n                else\n                    throw Exception(ErrorCodes::CANNOT_CONVERT_TYPE,\n                        \"Conversion from {} to {} is not supported\",\n                        type_index, to_type->getName());\n            }\n\n            return result_column;\n        };\n    }\n\n    WrapperType createAggregateFunctionWrapper(const DataTypePtr & from_type_untyped, const DataTypeAggregateFunction * to_type) const\n    {\n        /// Conversion from String through parsing.\n        if (checkAndGetDataType<DataTypeString>(from_type_untyped.get()))\n        {\n            return [this](ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable * column_nullable, size_t input_rows_count) -> ColumnPtr\n            {\n                return ConvertImplGenericFromString<true>::execute(arguments, result_type, column_nullable, input_rows_count, context);\n            };\n        }\n        else if (const auto * agg_type = checkAndGetDataType<DataTypeAggregateFunction>(from_type_untyped.get()))\n        {\n            if (agg_type->getFunction()->haveSameStateRepresentation(*to_type->getFunction()))\n            {\n                return [function = to_type->getFunction()](\n                           ColumnsWithTypeAndName & arguments,\n                           const DataTypePtr & /* result_type */,\n                           const ColumnNullable * /* nullable_source */,\n                           size_t /*input_rows_count*/) -> ColumnPtr\n                {\n                    const auto & argument_column = arguments.front();\n                    const auto * col_agg = checkAndGetColumn<ColumnAggregateFunction>(argument_column.column.get());\n                    if (col_agg)\n                    {\n                        auto new_col_agg = ColumnAggregateFunction::create(*col_agg);\n                        new_col_agg->set(function);\n                        return new_col_agg;\n                    }\n                    else\n                    {\n                        throw Exception(\n                            ErrorCodes::LOGICAL_ERROR,\n                            \"Illegal column {} for function CAST AS AggregateFunction\",\n                            argument_column.column->getName());\n                    }\n                };\n            }\n        }\n\n        if (cast_type == CastType::accurateOrNull)\n            return createToNullableColumnWrapper();\n        else\n            throw Exception(ErrorCodes::CANNOT_CONVERT_TYPE, \"Conversion from {} to {} is not supported\",\n                from_type_untyped->getName(), to_type->getName());\n    }\n\n    WrapperType createArrayWrapper(const DataTypePtr & from_type_untyped, const DataTypeArray & to_type) const\n    {\n        /// Conversion from String through parsing.\n        if (checkAndGetDataType<DataTypeString>(from_type_untyped.get()))\n        {\n            return [this](ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable * column_nullable, size_t input_rows_count) -> ColumnPtr\n            {\n                return ConvertImplGenericFromString<true>::execute(arguments, result_type, column_nullable, input_rows_count, context);\n            };\n        }\n\n        DataTypePtr from_type_holder;\n        const auto * from_type = checkAndGetDataType<DataTypeArray>(from_type_untyped.get());\n        const auto * from_type_map = checkAndGetDataType<DataTypeMap>(from_type_untyped.get());\n\n        /// Convert from Map\n        if (from_type_map)\n        {\n            /// Recreate array of unnamed tuples because otherwise it may work\n            /// unexpectedly while converting to array of named tuples.\n            from_type_holder = from_type_map->getNestedTypeWithUnnamedTuple();\n            from_type = assert_cast<const DataTypeArray *>(from_type_holder.get());\n        }\n\n        if (!from_type)\n        {\n            throw Exception(ErrorCodes::TYPE_MISMATCH,\n                \"CAST AS Array can only be performed between same-dimensional Array, Map or String types\");\n        }\n\n        DataTypePtr from_nested_type = from_type->getNestedType();\n\n        /// In query SELECT CAST([] AS Array(Array(String))) from type is Array(Nothing)\n        bool from_empty_array = isNothing(from_nested_type);\n\n        if (from_type->getNumberOfDimensions() != to_type.getNumberOfDimensions() && !from_empty_array)\n            throw Exception(ErrorCodes::TYPE_MISMATCH,\n                \"CAST AS Array can only be performed between same-dimensional array types\");\n\n        const DataTypePtr & to_nested_type = to_type.getNestedType();\n\n        /// Prepare nested type conversion\n        const auto nested_function = prepareUnpackDictionaries(from_nested_type, to_nested_type);\n\n        return [nested_function, from_nested_type, to_nested_type](\n                ColumnsWithTypeAndName & arguments, const DataTypePtr &, const ColumnNullable * nullable_source, size_t /*input_rows_count*/) -> ColumnPtr\n        {\n            const auto & argument_column = arguments.front();\n\n            const ColumnArray * col_array = nullptr;\n\n            if (const ColumnMap * col_map = checkAndGetColumn<ColumnMap>(argument_column.column.get()))\n                col_array = &col_map->getNestedColumn();\n            else\n                col_array = checkAndGetColumn<ColumnArray>(argument_column.column.get());\n\n            if (col_array)\n            {\n                /// create columns for converting nested column containing original and result columns\n                ColumnsWithTypeAndName nested_columns{{ col_array->getDataPtr(), from_nested_type, \"\" }};\n\n                /// convert nested column\n                auto result_column = nested_function(nested_columns, to_nested_type, nullable_source, nested_columns.front().column->size());\n\n                /// set converted nested column to result\n                return ColumnArray::create(result_column, col_array->getOffsetsPtr());\n            }\n            else\n            {\n                throw Exception(ErrorCodes::LOGICAL_ERROR,\n                    \"Illegal column {} for function CAST AS Array\",\n                    argument_column.column->getName());\n            }\n        };\n    }\n\n    using ElementWrappers = std::vector<WrapperType>;\n\n    ElementWrappers getElementWrappers(const DataTypes & from_element_types, const DataTypes & to_element_types) const\n    {\n        ElementWrappers element_wrappers;\n        element_wrappers.reserve(from_element_types.size());\n\n        /// Create conversion wrapper for each element in tuple\n        for (size_t i = 0; i < from_element_types.size(); ++i)\n        {\n            const DataTypePtr & from_element_type = from_element_types[i];\n            const DataTypePtr & to_element_type = to_element_types[i];\n            element_wrappers.push_back(prepareUnpackDictionaries(from_element_type, to_element_type));\n        }\n\n        return element_wrappers;\n    }\n\n    WrapperType createTupleWrapper(const DataTypePtr & from_type_untyped, const DataTypeTuple * to_type) const\n    {\n        /// Conversion from String through parsing.\n        if (checkAndGetDataType<DataTypeString>(from_type_untyped.get()))\n        {\n            return [this](ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable * column_nullable, size_t input_rows_count) -> ColumnPtr\n            {\n                return ConvertImplGenericFromString<true>::execute(arguments, result_type, column_nullable, input_rows_count, context);\n            };\n        }\n\n        const auto * from_type = checkAndGetDataType<DataTypeTuple>(from_type_untyped.get());\n        if (!from_type)\n            throw Exception(ErrorCodes::TYPE_MISMATCH, \"CAST AS Tuple can only be performed between tuple types or from String.\\n\"\n                            \"Left type: {}, right type: {}\", from_type_untyped->getName(), to_type->getName());\n\n        const auto & from_element_types = from_type->getElements();\n        const auto & to_element_types = to_type->getElements();\n\n        std::vector<WrapperType> element_wrappers;\n        std::vector<std::optional<size_t>> to_reverse_index;\n\n        /// For named tuples allow conversions for tuples with\n        /// different sets of elements. If element exists in @to_type\n        /// and doesn't exist in @to_type it will be filled by default values.\n        if (from_type->haveExplicitNames() && to_type->haveExplicitNames())\n        {\n            const auto & from_names = from_type->getElementNames();\n            std::unordered_map<String, size_t> from_positions;\n            from_positions.reserve(from_names.size());\n            for (size_t i = 0; i < from_names.size(); ++i)\n                from_positions[from_names[i]] = i;\n\n            const auto & to_names = to_type->getElementNames();\n            element_wrappers.reserve(to_names.size());\n            to_reverse_index.reserve(from_names.size());\n\n            for (size_t i = 0; i < to_names.size(); ++i)\n            {\n                auto it = from_positions.find(to_names[i]);\n                if (it != from_positions.end())\n                {\n                    element_wrappers.emplace_back(prepareUnpackDictionaries(from_element_types[it->second], to_element_types[i]));\n                    to_reverse_index.emplace_back(it->second);\n                }\n                else\n                {\n                    element_wrappers.emplace_back();\n                    to_reverse_index.emplace_back();\n                }\n            }\n        }\n        else\n        {\n            if (from_element_types.size() != to_element_types.size())\n                throw Exception(ErrorCodes::TYPE_MISMATCH, \"CAST AS Tuple can only be performed between tuple types \"\n                                \"with the same number of elements or from String.\\nLeft type: {}, right type: {}\",\n                                from_type->getName(), to_type->getName());\n\n            element_wrappers = getElementWrappers(from_element_types, to_element_types);\n            to_reverse_index.reserve(to_element_types.size());\n            for (size_t i = 0; i < to_element_types.size(); ++i)\n                to_reverse_index.emplace_back(i);\n        }\n\n        return [element_wrappers, from_element_types, to_element_types, to_reverse_index]\n            (ColumnsWithTypeAndName & arguments, const DataTypePtr &, const ColumnNullable * nullable_source, size_t input_rows_count) -> ColumnPtr\n        {\n            const auto * col = arguments.front().column.get();\n\n            size_t tuple_size = to_element_types.size();\n            const ColumnTuple & column_tuple = typeid_cast<const ColumnTuple &>(*col);\n\n            Columns converted_columns(tuple_size);\n\n            /// invoke conversion for each element\n            for (size_t i = 0; i < tuple_size; ++i)\n            {\n                if (to_reverse_index[i])\n                {\n                    size_t from_idx = *to_reverse_index[i];\n                    ColumnsWithTypeAndName element = {{column_tuple.getColumns()[from_idx], from_element_types[from_idx], \"\" }};\n                    converted_columns[i] = element_wrappers[i](element, to_element_types[i], nullable_source, input_rows_count);\n                }\n                else\n                {\n                    converted_columns[i] = to_element_types[i]->createColumn()->cloneResized(input_rows_count);\n                }\n            }\n\n            return ColumnTuple::create(converted_columns);\n        };\n    }\n\n    /// The case of: tuple([key1, key2, ..., key_n], [value1, value2, ..., value_n])\n    WrapperType createTupleToMapWrapper(const DataTypes & from_kv_types, const DataTypes & to_kv_types) const\n    {\n        return [element_wrappers = getElementWrappers(from_kv_types, to_kv_types), from_kv_types, to_kv_types]\n            (ColumnsWithTypeAndName & arguments, const DataTypePtr &, const ColumnNullable * nullable_source, size_t /*input_rows_count*/) -> ColumnPtr\n        {\n            const auto * col = arguments.front().column.get();\n            const auto & column_tuple = assert_cast<const ColumnTuple &>(*col);\n\n            Columns offsets(2);\n            Columns converted_columns(2);\n            for (size_t i = 0; i < 2; ++i)\n            {\n                const auto & column_array = assert_cast<const ColumnArray &>(column_tuple.getColumn(i));\n                ColumnsWithTypeAndName element = {{column_array.getDataPtr(), from_kv_types[i], \"\"}};\n                converted_columns[i] = element_wrappers[i](element, to_kv_types[i], nullable_source, (element[0].column)->size());\n                offsets[i] = column_array.getOffsetsPtr();\n            }\n\n            const auto & keys_offsets = assert_cast<const ColumnArray::ColumnOffsets &>(*offsets[0]).getData();\n            const auto & values_offsets = assert_cast<const ColumnArray::ColumnOffsets &>(*offsets[1]).getData();\n            if (keys_offsets != values_offsets)\n                throw Exception(ErrorCodes::TYPE_MISMATCH,\n                    \"CAST AS Map can only be performed from tuple of arrays with equal sizes.\");\n\n            return ColumnMap::create(converted_columns[0], converted_columns[1], offsets[0]);\n        };\n    }\n\n    WrapperType createMapToMapWrapper(const DataTypes & from_kv_types, const DataTypes & to_kv_types) const\n    {\n        return [element_wrappers = getElementWrappers(from_kv_types, to_kv_types), from_kv_types, to_kv_types]\n            (ColumnsWithTypeAndName & arguments, const DataTypePtr &, const ColumnNullable * nullable_source, size_t /*input_rows_count*/) -> ColumnPtr\n        {\n            const auto * col = arguments.front().column.get();\n            const auto & column_map = typeid_cast<const ColumnMap &>(*col);\n            const auto & nested_data = column_map.getNestedData();\n\n            Columns converted_columns(2);\n            for (size_t i = 0; i < 2; ++i)\n            {\n                ColumnsWithTypeAndName element = {{nested_data.getColumnPtr(i), from_kv_types[i], \"\"}};\n                converted_columns[i] = element_wrappers[i](element, to_kv_types[i], nullable_source, (element[0].column)->size());\n            }\n\n            return ColumnMap::create(converted_columns[0], converted_columns[1], column_map.getNestedColumn().getOffsetsPtr());\n        };\n    }\n\n    /// The case of: [(key1, value1), (key2, value2), ...]\n    WrapperType createArrayToMapWrapper(const DataTypes & from_kv_types, const DataTypes & to_kv_types) const\n    {\n        return [element_wrappers = getElementWrappers(from_kv_types, to_kv_types), from_kv_types, to_kv_types]\n            (ColumnsWithTypeAndName & arguments, const DataTypePtr &, const ColumnNullable * nullable_source, size_t /*input_rows_count*/) -> ColumnPtr\n        {\n            const auto * col = arguments.front().column.get();\n            const auto & column_array = typeid_cast<const ColumnArray &>(*col);\n            const auto & nested_data = typeid_cast<const ColumnTuple &>(column_array.getData());\n\n            Columns converted_columns(2);\n            for (size_t i = 0; i < 2; ++i)\n            {\n                ColumnsWithTypeAndName element = {{nested_data.getColumnPtr(i), from_kv_types[i], \"\"}};\n                converted_columns[i] = element_wrappers[i](element, to_kv_types[i], nullable_source, (element[0].column)->size());\n            }\n\n            return ColumnMap::create(converted_columns[0], converted_columns[1], column_array.getOffsetsPtr());\n        };\n    }\n\n\n    WrapperType createMapWrapper(const DataTypePtr & from_type_untyped, const DataTypeMap * to_type) const\n    {\n        if (const auto * from_tuple = checkAndGetDataType<DataTypeTuple>(from_type_untyped.get()))\n        {\n            if (from_tuple->getElements().size() != 2)\n                throw Exception(\n                    ErrorCodes::TYPE_MISMATCH,\n                    \"CAST AS Map from tuple requires 2 elements. \"\n                    \"Left type: {}, right type: {}\",\n                    from_tuple->getName(),\n                    to_type->getName());\n\n            DataTypes from_kv_types;\n            const auto & to_kv_types = to_type->getKeyValueTypes();\n\n            for (const auto & elem : from_tuple->getElements())\n            {\n                const auto * type_array = checkAndGetDataType<DataTypeArray>(elem.get());\n                if (!type_array)\n                    throw Exception(ErrorCodes::TYPE_MISMATCH,\n                        \"CAST AS Map can only be performed from tuples of array. Got: {}\", from_tuple->getName());\n\n                from_kv_types.push_back(type_array->getNestedType());\n            }\n\n            return createTupleToMapWrapper(from_kv_types, to_kv_types);\n        }\n        else if (const auto * from_array = typeid_cast<const DataTypeArray *>(from_type_untyped.get()))\n        {\n            if (typeid_cast<const DataTypeNothing *>(from_array->getNestedType().get()))\n                return [nested = to_type->getNestedType()](ColumnsWithTypeAndName &, const DataTypePtr &, const ColumnNullable *, size_t size)\n                {\n                    return ColumnMap::create(nested->createColumnConstWithDefaultValue(size)->convertToFullColumnIfConst());\n                };\n\n            const auto * nested_tuple = typeid_cast<const DataTypeTuple *>(from_array->getNestedType().get());\n            if (!nested_tuple || nested_tuple->getElements().size() != 2)\n                throw Exception(\n                    ErrorCodes::TYPE_MISMATCH,\n                    \"CAST AS Map from array requires nested tuple of 2 elements. \"\n                    \"Left type: {}, right type: {}\",\n                    from_array->getName(),\n                    to_type->getName());\n\n            return createArrayToMapWrapper(nested_tuple->getElements(), to_type->getKeyValueTypes());\n        }\n        else if (const auto * from_type = checkAndGetDataType<DataTypeMap>(from_type_untyped.get()))\n        {\n            return createMapToMapWrapper(from_type->getKeyValueTypes(), to_type->getKeyValueTypes());\n        }\n        else\n        {\n            throw Exception(ErrorCodes::TYPE_MISMATCH, \"Unsupported types to CAST AS Map. \"\n                \"Left type: {}, right type: {}\", from_type_untyped->getName(), to_type->getName());\n        }\n    }\n\n    WrapperType createTupleToObjectWrapper(const DataTypeTuple & from_tuple, bool has_nullable_subcolumns) const\n    {\n        if (!from_tuple.haveExplicitNames())\n            throw Exception(ErrorCodes::TYPE_MISMATCH,\n            \"Cast to Object can be performed only from flatten Named Tuple. Got: {}\", from_tuple.getName());\n\n        PathsInData paths;\n        DataTypes from_types;\n\n        std::tie(paths, from_types) = flattenTuple(from_tuple.getPtr());\n        auto to_types = from_types;\n\n        for (auto & type : to_types)\n        {\n            if (isTuple(type) || isNested(type))\n                throw Exception(ErrorCodes::TYPE_MISMATCH,\n                    \"Cast to Object can be performed only from flatten Named Tuple. Got: {}\",\n                    from_tuple.getName());\n\n            type = recursiveRemoveLowCardinality(type);\n        }\n\n        return [element_wrappers = getElementWrappers(from_types, to_types),\n            has_nullable_subcolumns, from_types, to_types, paths]\n            (ColumnsWithTypeAndName & arguments, const DataTypePtr &, const ColumnNullable * nullable_source, size_t input_rows_count)\n        {\n            size_t tuple_size = to_types.size();\n            auto flattened_column = flattenTuple(arguments.front().column);\n            const auto & column_tuple = assert_cast<const ColumnTuple &>(*flattened_column);\n\n            if (tuple_size != column_tuple.getColumns().size())\n                throw Exception(ErrorCodes::TYPE_MISMATCH,\n                    \"Expected tuple with {} subcolumn, but got {} subcolumns\",\n                    tuple_size, column_tuple.getColumns().size());\n\n            auto res = ColumnObjectDeprecated::create(has_nullable_subcolumns);\n            for (size_t i = 0; i < tuple_size; ++i)\n            {\n                ColumnsWithTypeAndName element = {{column_tuple.getColumns()[i], from_types[i], \"\" }};\n                auto converted_column = element_wrappers[i](element, to_types[i], nullable_source, input_rows_count);\n                res->addSubcolumn(paths[i], converted_column->assumeMutable());\n            }\n\n            return res;\n        };\n    }\n\n    WrapperType createMapToObjectWrapper(const DataTypeMap & from_map, bool has_nullable_subcolumns) const\n    {\n        auto key_value_types = from_map.getKeyValueTypes();\n\n        if (!isStringOrFixedString(key_value_types[0]))\n            throw Exception(ErrorCodes::TYPE_MISMATCH,\n                \"Cast to Object from Map can be performed only from Map \"\n                \"with String or FixedString key. Got: {}\", from_map.getName());\n\n        const auto & value_type = key_value_types[1];\n        auto to_value_type = value_type;\n\n        if (!has_nullable_subcolumns && value_type->isNullable())\n            to_value_type = removeNullable(value_type);\n\n        if (has_nullable_subcolumns && !value_type->isNullable())\n            to_value_type = makeNullable(value_type);\n\n        DataTypes to_key_value_types{std::make_shared<DataTypeString>(), std::move(to_value_type)};\n        auto element_wrappers = getElementWrappers(key_value_types, to_key_value_types);\n\n        return [has_nullable_subcolumns, element_wrappers, key_value_types, to_key_value_types]\n            (ColumnsWithTypeAndName & arguments, const DataTypePtr &, const ColumnNullable * nullable_source, size_t) -> ColumnPtr\n        {\n            const auto & column_map = assert_cast<const ColumnMap &>(*arguments.front().column);\n            const auto & offsets = column_map.getNestedColumn().getOffsets();\n            auto key_value_columns = column_map.getNestedData().getColumnsCopy();\n\n            for (size_t i = 0; i < 2; ++i)\n            {\n                ColumnsWithTypeAndName element{{key_value_columns[i], key_value_types[i], \"\"}};\n                key_value_columns[i] = element_wrappers[i](element, to_key_value_types[i], nullable_source, key_value_columns[i]->size());\n            }\n\n            const auto & key_column_str = assert_cast<const ColumnString &>(*key_value_columns[0]);\n            const auto & value_column = *key_value_columns[1];\n\n            using SubcolumnsMap = HashMap<StringRef, MutableColumnPtr, StringRefHash>;\n            SubcolumnsMap subcolumns;\n\n            for (size_t row = 0; row < offsets.size(); ++row)\n            {\n                for (size_t i = offsets[static_cast<ssize_t>(row) - 1]; i < offsets[row]; ++i)\n                {\n                    auto ref = key_column_str.getDataAt(i);\n\n                    bool inserted;\n                    SubcolumnsMap::LookupResult it;\n                    subcolumns.emplace(ref, it, inserted);\n                    auto & subcolumn = it->getMapped();\n\n                    if (inserted)\n                        subcolumn = value_column.cloneEmpty()->cloneResized(row);\n\n                    /// Map can have duplicated keys. We insert only first one.\n                    if (subcolumn->size() == row)\n                        subcolumn->insertFrom(value_column, i);\n                }\n\n                /// Insert default values for keys missed in current row.\n                for (const auto & [_, subcolumn] : subcolumns)\n                    if (subcolumn->size() == row)\n                        subcolumn->insertDefault();\n            }\n\n            auto column_object = ColumnObjectDeprecated::create(has_nullable_subcolumns);\n            for (auto && [key, subcolumn] : subcolumns)\n            {\n                PathInData path(key.toView());\n                column_object->addSubcolumn(path, std::move(subcolumn));\n            }\n\n            return column_object;\n        };\n    }\n\n    WrapperType createObjectDeprecatedWrapper(const DataTypePtr & from_type, const DataTypeObjectDeprecated * to_type) const\n    {\n        if (const auto * from_tuple = checkAndGetDataType<DataTypeTuple>(from_type.get()))\n        {\n            return createTupleToObjectWrapper(*from_tuple, to_type->hasNullableSubcolumns());\n        }\n        else if (const auto * from_map = checkAndGetDataType<DataTypeMap>(from_type.get()))\n        {\n            return createMapToObjectWrapper(*from_map, to_type->hasNullableSubcolumns());\n        }\n        else if (checkAndGetDataType<DataTypeString>(from_type.get()))\n        {\n            return [this](ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable * nullable_source, size_t input_rows_count)\n            {\n                auto res = ConvertImplGenericFromString<true>::execute(arguments, result_type, nullable_source, input_rows_count, context)->assumeMutable();\n                res->finalize();\n                return res;\n            };\n        }\n        else if (checkAndGetDataType<DataTypeObjectDeprecated>(from_type.get()))\n        {\n            return [is_nullable = to_type->hasNullableSubcolumns()] (ColumnsWithTypeAndName & arguments, const DataTypePtr & , const ColumnNullable * , size_t) -> ColumnPtr\n            {\n                const auto & column_object = assert_cast<const ColumnObjectDeprecated &>(*arguments.front().column);\n                auto res = ColumnObjectDeprecated::create(is_nullable);\n                for (size_t i = 0; i < column_object.size(); i++)\n                    res->insert(column_object[i]);\n\n                res->finalize();\n                return res;\n            };\n        }\n\n        throw Exception(ErrorCodes::TYPE_MISMATCH,\n            \"Cast to Object can be performed only from flatten named Tuple, Map or String. Got: {}\", from_type->getName());\n    }\n\n    WrapperType createObjectWrapper(const DataTypePtr & from_type, const DataTypeObject * to_object) const\n    {\n        if (checkAndGetDataType<DataTypeString>(from_type.get()))\n        {\n            return [this](ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable * nullable_source, size_t input_rows_count)\n            {\n                auto res = ConvertImplGenericFromString<true>::execute(arguments, result_type, nullable_source, input_rows_count, context)->assumeMutable();\n                res->finalize();\n                return res;\n            };\n        }\n\n        /// TODO: support CAST between JSON types with different parameters\n        ///       support CAST from Map to JSON\n        ///       support CAST from Tuple to JSON\n        ///       support CAST from Object('json') to JSON\n        throw Exception(ErrorCodes::TYPE_MISMATCH, \"Cast to {} can be performed only from String. Got: {}\", magic_enum::enum_name(to_object->getSchemaFormat()), from_type->getName());\n    }\n\n    WrapperType createVariantToVariantWrapper(const DataTypeVariant & from_variant, const DataTypeVariant & to_variant) const\n    {\n        /// We support only extension of variant type, so, only new types can be added.\n        /// For example: Variant(T1, T2) -> Variant(T1, T2, T3) is supported, but Variant(T1, T2) -> Variant(T1, T3) is not supported.\n        /// We want to extend Variant type for free without rewriting the data, but we sort data types inside Variant during type creation\n        /// (we do it because we want Variant(T1, T2) to be the same as Variant(T2, T1)), but after extension the order of variant types\n        /// (and so their discriminators) can be different. For example: Variant(T1, T3) -> Variant(T1, T2, T3).\n        /// To avoid full rewrite of discriminators column, ColumnVariant supports it's local order of variant columns (and so local\n        /// discriminators) and stores mapping global order -> local order.\n        /// So, to extend Variant with new types for free, we should keep old local order for old variants, append new variants and change\n        /// mapping global order -> local order according to the new global order.\n\n        /// Create map (new variant type) -> (it's global discriminator in new order).\n        const auto & new_variants = to_variant.getVariants();\n        std::unordered_map<String, ColumnVariant::Discriminator> new_variant_types_to_new_global_discriminator;\n        new_variant_types_to_new_global_discriminator.reserve(new_variants.size());\n        for (size_t i = 0; i != new_variants.size(); ++i)\n            new_variant_types_to_new_global_discriminator[new_variants[i]->getName()] = i;\n\n        /// Create set of old variant types.\n        const auto & old_variants = from_variant.getVariants();\n        std::unordered_map<String, ColumnVariant::Discriminator> old_variant_types_to_old_global_discriminator;\n        old_variant_types_to_old_global_discriminator.reserve(old_variants.size());\n        for (size_t i = 0; i != old_variants.size(); ++i)\n            old_variant_types_to_old_global_discriminator[old_variants[i]->getName()] = i;\n\n        /// Check that the set of old variants types is a subset of new variant types and collect new global discriminator for each old global discriminator.\n        std::unordered_map<ColumnVariant::Discriminator, ColumnVariant::Discriminator> old_global_discriminator_to_new;\n        old_global_discriminator_to_new.reserve(old_variants.size());\n        for (const auto & [old_variant_type, old_discriminator] : old_variant_types_to_old_global_discriminator)\n        {\n            auto it = new_variant_types_to_new_global_discriminator.find(old_variant_type);\n            if (it == new_variant_types_to_new_global_discriminator.end())\n                throw Exception(\n                    ErrorCodes::CANNOT_CONVERT_TYPE,\n                    \"Cannot convert type {} to {}. Conversion between Variant types is allowed only when new Variant type is an extension \"\n                    \"of an initial one\", from_variant.getName(), to_variant.getName());\n            old_global_discriminator_to_new[old_discriminator] = it->second;\n        }\n\n        /// Collect variant types and their global discriminators that should be added to the old Variant to get the new Variant.\n        std::vector<std::pair<DataTypePtr, ColumnVariant::Discriminator>> variant_types_and_discriminators_to_add;\n        variant_types_and_discriminators_to_add.reserve(new_variants.size() - old_variants.size());\n        for (size_t i = 0; i != new_variants.size(); ++i)\n        {\n            if (!old_variant_types_to_old_global_discriminator.contains(new_variants[i]->getName()))\n                variant_types_and_discriminators_to_add.emplace_back(new_variants[i], i);\n        }\n\n        return [old_global_discriminator_to_new, variant_types_and_discriminators_to_add]\n               (ColumnsWithTypeAndName & arguments, const DataTypePtr &, const ColumnNullable *, size_t) -> ColumnPtr\n        {\n            const auto & column_variant = assert_cast<const ColumnVariant &>(*arguments.front().column.get());\n            size_t num_old_variants = column_variant.getNumVariants();\n            Columns new_variant_columns;\n            new_variant_columns.reserve(num_old_variants + variant_types_and_discriminators_to_add.size());\n            std::vector<ColumnVariant::Discriminator> new_local_to_global_discriminators;\n            new_local_to_global_discriminators.reserve(num_old_variants + variant_types_and_discriminators_to_add.size());\n            for (size_t i = 0; i != num_old_variants; ++i)\n            {\n                new_variant_columns.push_back(column_variant.getVariantPtrByLocalDiscriminator(i));\n                new_local_to_global_discriminators.push_back(old_global_discriminator_to_new.at(column_variant.globalDiscriminatorByLocal(i)));\n            }\n\n            for (const auto & [new_variant_type, new_global_discriminator] : variant_types_and_discriminators_to_add)\n            {\n                new_variant_columns.push_back(new_variant_type->createColumn());\n                new_local_to_global_discriminators.push_back(new_global_discriminator);\n            }\n\n            return ColumnVariant::create(column_variant.getLocalDiscriminatorsPtr(), column_variant.getOffsetsPtr(), new_variant_columns, new_local_to_global_discriminators);\n        };\n    }\n\n    /// Create wrapper only if we support this conversion.\n    WrapperType createWrapperIfCanConvert(const DataTypePtr & from, const DataTypePtr & to) const\n    {\n        try\n        {\n            /// We can avoid try/catch here if we will implement check that 2 types can be casted, but it\n            /// requires quite a lot of work. By now let's simply use try/catch.\n            /// First, check that we can create a wrapper.\n            WrapperType wrapper = prepareUnpackDictionaries(from, to);\n            /// Second, check if we can perform a conversion on column with default value.\n            /// (we cannot just check empty column as we do some checks only during iteration over rows).\n            auto test_col = from->createColumn();\n            test_col->insertDefault();\n            ColumnsWithTypeAndName column_from = {{test_col->getPtr(), from, \"\" }};\n            wrapper(column_from, to, nullptr, 1);\n            return wrapper;\n        }\n        catch (const Exception &)\n        {\n            return {};\n        }\n    }\n\n    WrapperType createVariantToColumnWrapper(const DataTypeVariant & from_variant, const DataTypePtr & to_type) const\n    {\n        const auto & variant_types = from_variant.getVariants();\n        std::vector<WrapperType> variant_wrappers;\n        variant_wrappers.reserve(variant_types.size());\n\n        /// Create conversion wrapper for each variant.\n        for (const auto & variant_type : variant_types)\n        {\n            WrapperType wrapper;\n            if (cast_type == CastType::accurateOrNull)\n            {\n                /// Create wrapper only if we support conversion from variant to the resulting type.\n                wrapper = createWrapperIfCanConvert(variant_type, to_type);\n            }\n            else\n            {\n                wrapper = prepareUnpackDictionaries(variant_type, to_type);\n            }\n            variant_wrappers.push_back(wrapper);\n        }\n\n        return [variant_wrappers, variant_types, to_type]\n               (ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable *, size_t input_rows_count) -> ColumnPtr\n        {\n            const auto & column_variant = assert_cast<const ColumnVariant &>(*arguments.front().column.get());\n\n            /// First, cast each variant to the result type.\n            std::vector<ColumnPtr> casted_variant_columns;\n            casted_variant_columns.reserve(variant_types.size());\n            for (size_t i = 0; i != variant_types.size(); ++i)\n            {\n                auto variant_col = column_variant.getVariantPtrByGlobalDiscriminator(i);\n                ColumnsWithTypeAndName variant = {{variant_col, variant_types[i], \"\" }};\n                const auto & variant_wrapper = variant_wrappers[i];\n                ColumnPtr casted_variant;\n                /// Check if we have wrapper for this variant.\n                if (variant_wrapper)\n                    casted_variant = variant_wrapper(variant, result_type, nullptr, variant_col->size());\n                casted_variant_columns.push_back(std::move(casted_variant));\n            }\n\n            /// Second, construct resulting column from casted variant columns according to discriminators.\n            const auto & local_discriminators = column_variant.getLocalDiscriminators();\n            auto res = result_type->createColumn();\n            res->reserve(input_rows_count);\n            for (size_t i = 0; i != input_rows_count; ++i)\n            {\n                auto global_discr = column_variant.globalDiscriminatorByLocal(local_discriminators[i]);\n                if (global_discr == ColumnVariant::NULL_DISCRIMINATOR || !casted_variant_columns[global_discr])\n                    res->insertDefault();\n                else\n                    res->insertFrom(*casted_variant_columns[global_discr], column_variant.offsetAt(i));\n            }\n\n            return res;\n        };\n    }\n\n    static ColumnPtr createVariantFromDescriptorsAndOneNonEmptyVariant(const DataTypes & variant_types, const ColumnPtr & discriminators, const ColumnPtr & variant, ColumnVariant::Discriminator variant_discr)\n    {\n        Columns variants;\n        variants.reserve(variant_types.size());\n        for (size_t i = 0; i != variant_types.size(); ++i)\n        {\n            if (i == variant_discr)\n                variants.emplace_back(variant);\n            else\n                variants.push_back(variant_types[i]->createColumn());\n        }\n\n        return ColumnVariant::create(discriminators, variants);\n    }\n\n    WrapperType createStringToVariantWrapper() const\n    {\n        return [&](ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable *, size_t input_rows_count) -> ColumnPtr\n        {\n            auto column = arguments[0].column->convertToFullColumnIfLowCardinality();\n            auto args = arguments;\n            args[0].column = column;\n\n            const ColumnNullable * column_nullable = nullptr;\n            if (isColumnNullable(*args[0].column))\n            {\n                column_nullable = assert_cast<const ColumnNullable *>(args[0].column.get());\n                args[0].column = column_nullable->getNestedColumnPtr();\n            }\n\n            args[0].type = removeNullable(removeLowCardinality(args[0].type));\n\n            if (cast_type == CastType::accurateOrNull)\n                return ConvertImplGenericFromString<false>::execute(args, result_type, column_nullable, input_rows_count, context);\n            return ConvertImplGenericFromString<true>::execute(args, result_type, column_nullable, input_rows_count, context);\n        };\n    }\n\n    WrapperType createColumnToVariantWrapper(const DataTypePtr & from_type, const DataTypeVariant & to_variant) const\n    {\n        /// We allow converting NULL to Variant(...) as Variant can store NULLs.\n        if (from_type->onlyNull())\n        {\n            return [](ColumnsWithTypeAndName &, const DataTypePtr & result_type, const ColumnNullable *, size_t input_rows_count) -> ColumnPtr\n            {\n                auto result_column = result_type->createColumn();\n                result_column->insertManyDefaults(input_rows_count);\n                return result_column;\n            };\n        }\n\n        auto variant_discr_opt = to_variant.tryGetVariantDiscriminator(removeNullableOrLowCardinalityNullable(from_type)->getName());\n        /// Cast String to Variant through parsing if it's not Variant(String).\n        if (isStringOrFixedString(removeNullable(removeLowCardinality(from_type))) && (!variant_discr_opt || to_variant.getVariants().size() > 1))\n            return createStringToVariantWrapper();\n\n        if (!variant_discr_opt)\n            throw Exception(ErrorCodes::CANNOT_CONVERT_TYPE, \"Cannot convert type {} to {}. Conversion to Variant allowed only for types from this Variant\", from_type->getName(), to_variant.getName());\n\n        return [variant_discr = *variant_discr_opt]\n               (ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable *, size_t) -> ColumnPtr\n        {\n            const auto & result_variant_type = assert_cast<const DataTypeVariant &>(*result_type);\n            const auto & variant_types = result_variant_type.getVariants();\n            if (const ColumnNullable * col_nullable = typeid_cast<const ColumnNullable *>(arguments.front().column.get()))\n            {\n                const auto & column = col_nullable->getNestedColumnPtr();\n                const auto & null_map = col_nullable->getNullMapData();\n                IColumn::Filter filter;\n                filter.reserve(column->size());\n                auto discriminators = ColumnVariant::ColumnDiscriminators::create();\n                auto & discriminators_data = discriminators->getData();\n                discriminators_data.reserve(column->size());\n                size_t variant_size_hint = 0;\n                for (size_t i = 0; i != column->size(); ++i)\n                {\n                    if (null_map[i])\n                    {\n                        discriminators_data.push_back(ColumnVariant::NULL_DISCRIMINATOR);\n                        filter.push_back(0);\n                    }\n                    else\n                    {\n                        discriminators_data.push_back(variant_discr);\n                        filter.push_back(1);\n                        ++variant_size_hint;\n                    }\n                }\n\n                ColumnPtr variant_column;\n                /// If there were no NULLs, just use the column.\n                if (variant_size_hint == column->size())\n                    variant_column = column;\n                /// Otherwise we should use filtered column.\n                else\n                    variant_column = column->filter(filter, variant_size_hint);\n                return createVariantFromDescriptorsAndOneNonEmptyVariant(variant_types, std::move(discriminators), variant_column, variant_discr);\n            }\n            else if (isColumnLowCardinalityNullable(*arguments.front().column))\n            {\n                const auto & column = arguments.front().column;\n\n                /// Variant column cannot have LowCardinality(Nullable(...)) variant, as Variant column stores NULLs itself.\n                /// We should create a null-map, insert NULL_DISCRIMINATOR on NULL values and filter initial column.\n                const auto & col_lc = assert_cast<const ColumnLowCardinality &>(*column);\n                const auto & indexes = col_lc.getIndexes();\n                auto null_index = col_lc.getDictionary().getNullValueIndex();\n                IColumn::Filter filter;\n                filter.reserve(col_lc.size());\n                auto discriminators = ColumnVariant::ColumnDiscriminators::create();\n                auto & discriminators_data = discriminators->getData();\n                discriminators_data.reserve(col_lc.size());\n                size_t variant_size_hint = 0;\n                for (size_t i = 0; i != col_lc.size(); ++i)\n                {\n                    if (indexes.getUInt(i) == null_index)\n                    {\n                        discriminators_data.push_back(ColumnVariant::NULL_DISCRIMINATOR);\n                        filter.push_back(0);\n                    }\n                    else\n                    {\n                        discriminators_data.push_back(variant_discr);\n                        filter.push_back(1);\n                        ++variant_size_hint;\n                    }\n                }\n\n                MutableColumnPtr variant_column;\n                /// If there were no NULLs, we can just clone the column.\n                if (variant_size_hint == col_lc.size())\n                    variant_column = IColumn::mutate(column);\n                /// Otherwise we should filter column.\n                else\n                    variant_column = column->filter(filter, variant_size_hint)->assumeMutable();\n\n                assert_cast<ColumnLowCardinality &>(*variant_column).nestedRemoveNullable();\n                return createVariantFromDescriptorsAndOneNonEmptyVariant(variant_types, std::move(discriminators), std::move(variant_column), variant_discr);\n            }\n            else\n            {\n                const auto & column = arguments.front().column;\n                auto discriminators = ColumnVariant::ColumnDiscriminators::create();\n                discriminators->getData().resize_fill(column->size(), variant_discr);\n                return createVariantFromDescriptorsAndOneNonEmptyVariant(variant_types, std::move(discriminators), column, variant_discr);\n            }\n        };\n    }\n\n    /// Wrapper for conversion to/from Variant type\n    WrapperType createVariantWrapper(const DataTypePtr & from_type, const DataTypePtr & to_type) const\n    {\n        if (const auto * from_variant = checkAndGetDataType<DataTypeVariant>(from_type.get()))\n        {\n            if (const auto * to_variant = checkAndGetDataType<DataTypeVariant>(to_type.get()))\n                return createVariantToVariantWrapper(*from_variant, *to_variant);\n\n            return createVariantToColumnWrapper(*from_variant, to_type);\n        }\n\n        return createColumnToVariantWrapper(from_type, assert_cast<const DataTypeVariant &>(*to_type));\n    }\n\n    WrapperType createDynamicToColumnWrapper(const DataTypePtr &) const\n    {\n        return [this]\n               (ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable *, size_t input_rows_count) -> ColumnPtr\n        {\n            /// When casting Dynamic to regular column we should cast all variants from current Dynamic column\n            /// and construct the result based on discriminators.\n            const auto & column_dynamic = assert_cast<const ColumnDynamic &>(*arguments.front().column.get());\n            const auto & variant_column = column_dynamic.getVariantColumn();\n            const auto & variant_info = column_dynamic.getVariantInfo();\n\n            /// First, cast usual variants to result type.\n            const auto & variant_types = assert_cast<const DataTypeVariant &>(*variant_info.variant_type).getVariants();\n            std::vector<ColumnPtr> casted_variant_columns;\n            casted_variant_columns.reserve(variant_types.size());\n            for (size_t i = 0; i != variant_types.size(); ++i)\n            {\n                /// Skip shared variant, it will be processed later.\n                if (i == column_dynamic.getSharedVariantDiscriminator())\n                {\n                    casted_variant_columns.push_back(nullptr);\n                    continue;\n                }\n\n                const auto & variant_col = variant_column.getVariantPtrByGlobalDiscriminator(i);\n                ColumnsWithTypeAndName variant = {{variant_col, variant_types[i], \"\"}};\n                WrapperType variant_wrapper;\n                if (cast_type == CastType::accurateOrNull)\n                    /// Create wrapper only if we support conversion from variant to the resulting type.\n                    variant_wrapper = createWrapperIfCanConvert(variant_types[i], result_type);\n                else\n                    variant_wrapper = prepareUnpackDictionaries(variant_types[i], result_type);\n\n                ColumnPtr casted_variant;\n                /// Check if we have wrapper for this variant.\n                if (variant_wrapper)\n                    casted_variant = variant_wrapper(variant, result_type, nullptr, variant_col->size());\n                casted_variant_columns.push_back(casted_variant);\n            }\n\n            /// Second, collect all variants stored in shared variant and cast them to result type.\n            std::vector<MutableColumnPtr> variant_columns_from_shared_variant;\n            DataTypes variant_types_from_shared_variant;\n            /// We will need to know what variant to use when we see discriminator of a shared variant.\n            /// To do it, we remember what variant was extracted from each row and what was it's offset.\n            PaddedPODArray<UInt64> shared_variant_indexes;\n            PaddedPODArray<UInt64> shared_variant_offsets;\n            std::unordered_map<String, UInt64> shared_variant_to_index;\n            const auto & shared_variant = column_dynamic.getSharedVariant();\n            const auto shared_variant_discr = column_dynamic.getSharedVariantDiscriminator();\n            const auto & local_discriminators = variant_column.getLocalDiscriminators();\n            const auto & offsets = variant_column.getOffsets();\n            if (!shared_variant.empty())\n            {\n                shared_variant_indexes.reserve(input_rows_count);\n                shared_variant_offsets.reserve(input_rows_count);\n                FormatSettings format_settings;\n                const auto shared_variant_local_discr = variant_column.localDiscriminatorByGlobal(shared_variant_discr);\n                for (size_t i = 0; i != input_rows_count; ++i)\n                {\n                    if (local_discriminators[i] == shared_variant_local_discr)\n                    {\n                        auto value = shared_variant.getDataAt(offsets[i]);\n                        ReadBufferFromMemory buf(value.data, value.size);\n                        auto type = decodeDataType(buf);\n                        auto type_name = type->getName();\n                        auto it = shared_variant_to_index.find(type_name);\n                        /// Check if we didn't create column for this variant yet.\n                        if (it == shared_variant_to_index.end())\n                        {\n                            it = shared_variant_to_index.emplace(type_name, variant_columns_from_shared_variant.size()).first;\n                            variant_columns_from_shared_variant.push_back(type->createColumn());\n                            variant_types_from_shared_variant.push_back(type);\n                        }\n\n                        shared_variant_indexes.push_back(it->second);\n                        shared_variant_offsets.push_back(variant_columns_from_shared_variant[it->second]->size());\n                        type->getDefaultSerialization()->deserializeBinary(*variant_columns_from_shared_variant[it->second], buf, format_settings);\n                    }\n                    else\n                    {\n                        shared_variant_indexes.emplace_back();\n                        shared_variant_offsets.emplace_back();\n                    }\n                }\n            }\n\n            /// Cast all extracted variants into result type.\n            std::vector<ColumnPtr> casted_shared_variant_columns;\n            casted_shared_variant_columns.reserve(variant_types_from_shared_variant.size());\n            for (size_t i = 0; i != variant_types_from_shared_variant.size(); ++i)\n            {\n                ColumnsWithTypeAndName variant = {{variant_columns_from_shared_variant[i]->getPtr(), variant_types_from_shared_variant[i], \"\"}};\n                WrapperType variant_wrapper;\n                if (cast_type == CastType::accurateOrNull)\n                    /// Create wrapper only if we support conversion from variant to the resulting type.\n                    variant_wrapper = createWrapperIfCanConvert(variant_types_from_shared_variant[i], result_type);\n                else\n                    variant_wrapper = prepareUnpackDictionaries(variant_types_from_shared_variant[i], result_type);\n\n                ColumnPtr casted_variant;\n                /// Check if we have wrapper for this variant.\n                if (variant_wrapper)\n                    casted_variant = variant_wrapper(variant, result_type, nullptr, variant_columns_from_shared_variant[i]->size());\n                casted_shared_variant_columns.push_back(casted_variant);\n            }\n\n            /// Construct result column from all casted variants.\n            auto res = result_type->createColumn();\n            res->reserve(input_rows_count);\n            for (size_t i = 0; i != input_rows_count; ++i)\n            {\n                auto global_discr = variant_column.globalDiscriminatorByLocal(local_discriminators[i]);\n                if (global_discr == ColumnVariant::NULL_DISCRIMINATOR)\n                {\n                    res->insertDefault();\n                }\n                else if (global_discr == shared_variant_discr)\n                {\n                    if (casted_shared_variant_columns[shared_variant_indexes[i]])\n                        res->insertFrom(*casted_shared_variant_columns[shared_variant_indexes[i]], shared_variant_offsets[i]);\n                    else\n                        res->insertDefault();\n                }\n                else\n                {\n                    if (casted_variant_columns[global_discr])\n                        res->insertFrom(*casted_variant_columns[global_discr], offsets[i]);\n                    else\n                        res->insertDefault();\n                }\n            }\n\n            return res;\n        };\n    }\n\n    WrapperType createStringToDynamicThroughParsingWrapper() const\n    {\n        return [&](ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable *, size_t input_rows_count) -> ColumnPtr\n        {\n            auto column = arguments[0].column->convertToFullColumnIfLowCardinality();\n            auto args = arguments;\n            args[0].column = column;\n\n            const ColumnNullable * column_nullable = nullptr;\n            if (isColumnNullable(*args[0].column))\n            {\n                column_nullable = assert_cast<const ColumnNullable *>(args[0].column.get());\n                args[0].column = column_nullable->getNestedColumnPtr();\n            }\n\n            args[0].type = removeNullable(removeLowCardinality(args[0].type));\n\n            if (cast_type == CastType::accurateOrNull)\n                return ConvertImplGenericFromString<false>::execute(args, result_type, column_nullable, input_rows_count, context);\n            return ConvertImplGenericFromString<true>::execute(args, result_type, column_nullable, input_rows_count, context);\n        };\n    }\n\n    WrapperType createVariantToDynamicWrapper(const DataTypeVariant & from_variant_type, const DataTypeDynamic & dynamic_type) const\n    {\n        /// First create extended Variant with shared variant type and cast this Variant to it.\n        auto variants_for_dynamic = from_variant_type.getVariants();\n        size_t number_of_variants = variants_for_dynamic.size();\n        variants_for_dynamic.push_back(ColumnDynamic::getSharedVariantDataType());\n        const auto & variant_type_for_dynamic = std::make_shared<DataTypeVariant>(variants_for_dynamic);\n        auto old_to_new_variant_wrapper = createVariantToVariantWrapper(from_variant_type, *variant_type_for_dynamic);\n        auto max_dynamic_types = dynamic_type.getMaxDynamicTypes();\n        return [old_to_new_variant_wrapper, variant_type_for_dynamic, number_of_variants, max_dynamic_types]\n               (ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable * col_nullable, size_t input_rows_count) -> ColumnPtr\n        {\n            auto variant_column_for_dynamic = old_to_new_variant_wrapper(arguments, result_type, col_nullable, input_rows_count);\n            /// If resulting Dynamic column can contain all variants from this Variant column, just create Dynamic column from it.\n            if (max_dynamic_types >= number_of_variants)\n                return ColumnDynamic::create(variant_column_for_dynamic, variant_type_for_dynamic, max_dynamic_types, max_dynamic_types);\n\n            /// Otherwise some variants should go to the shared variant. Create temporary Dynamic column from this Variant and insert\n            /// all data to the resulting Dynamic column, this insertion will do all the logic with shared variant.\n            auto tmp_dynamic_column = ColumnDynamic::create(variant_column_for_dynamic, variant_type_for_dynamic, number_of_variants, number_of_variants);\n            auto result_dynamic_column = ColumnDynamic::create(max_dynamic_types);\n            result_dynamic_column->insertRangeFrom(*tmp_dynamic_column, 0, tmp_dynamic_column->size());\n            return result_dynamic_column;\n        };\n    }\n\n    WrapperType createColumnToDynamicWrapper(const DataTypePtr & from_type, const DataTypeDynamic & dynamic_type) const\n    {\n        if (const auto * variant_type = typeid_cast<const DataTypeVariant *>(from_type.get()))\n            return createVariantToDynamicWrapper(*variant_type, dynamic_type);\n\n        if (context && context->getSettingsRef()[Setting::cast_string_to_dynamic_use_inference] && isStringOrFixedString(removeNullable(removeLowCardinality(from_type))))\n            return createStringToDynamicThroughParsingWrapper();\n\n        /// First, cast column to Variant with 2 variants - the type of the column we cast and shared variant type.\n        auto variant_type = std::make_shared<DataTypeVariant>(DataTypes{removeNullableOrLowCardinalityNullable(from_type)});\n        auto column_to_variant_wrapper = createColumnToVariantWrapper(from_type, *variant_type);\n        /// Second, cast this Variant to Dynamic.\n        auto variant_to_dynamic_wrapper = createVariantToDynamicWrapper(*variant_type, dynamic_type);\n        return [column_to_variant_wrapper, variant_to_dynamic_wrapper, variant_type]\n               (ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable * col_nullable, size_t input_rows_count) -> ColumnPtr\n        {\n            auto variant_res = column_to_variant_wrapper(arguments, variant_type, col_nullable, input_rows_count);\n            ColumnsWithTypeAndName args = {{variant_res, variant_type, \"\"}};\n            return variant_to_dynamic_wrapper(args, result_type, nullptr, input_rows_count);\n        };\n    }\n\n    WrapperType createDynamicToDynamicWrapper(const DataTypeDynamic & from_dynamic, const DataTypeDynamic & to_dynamic) const\n    {\n        size_t from_max_types = from_dynamic.getMaxDynamicTypes();\n        size_t to_max_types = to_dynamic.getMaxDynamicTypes();\n        if (from_max_types == to_max_types)\n            return createIdentityWrapper(from_dynamic.getPtr());\n\n        if (to_max_types > from_max_types)\n        {\n            return [to_max_types]\n                   (ColumnsWithTypeAndName & arguments, const DataTypePtr &, const ColumnNullable *, size_t) -> ColumnPtr\n            {\n                const auto & dynamic_column = assert_cast<const ColumnDynamic &>(*arguments[0].column);\n                /// We should use the same limit as already used in column and change only global limit.\n                /// It's needed because shared variant should contain values only when limit is exceeded,\n                /// so if there are already some data, we cannot increase the limit.\n                return ColumnDynamic::create(dynamic_column.getVariantColumnPtr(), dynamic_column.getVariantInfo(), dynamic_column.getMaxDynamicTypes(), to_max_types);\n            };\n        }\n\n        return [to_max_types]\n               (ColumnsWithTypeAndName & arguments, const DataTypePtr &, const ColumnNullable *, size_t) -> ColumnPtr\n        {\n            const auto & dynamic_column = assert_cast<const ColumnDynamic &>(*arguments[0].column);\n            /// If real limit in the column is not greater than desired, just use the same variant column.\n            if (dynamic_column.getMaxDynamicTypes() <= to_max_types)\n                return ColumnDynamic::create(dynamic_column.getVariantColumnPtr(), dynamic_column.getVariantInfo(), dynamic_column.getMaxDynamicTypes(), to_max_types);\n\n            /// Otherwise some variants should go to the shared variant. We try to keep the most frequent variants.\n            const auto & variant_info = dynamic_column.getVariantInfo();\n            const auto & variants = assert_cast<const DataTypeVariant &>(*variant_info.variant_type).getVariants();\n            const auto & statistics = dynamic_column.getStatistics();\n            const auto & variant_column = dynamic_column.getVariantColumn();\n            auto shared_variant_discr = dynamic_column.getSharedVariantDiscriminator();\n            std::vector<std::tuple<size_t, String, DataTypePtr>> variants_with_sizes;\n            variants_with_sizes.reserve(variant_info.variant_names.size());\n            for (const auto & [name, discr] : variant_info.variant_name_to_discriminator)\n            {\n                /// Don't include shared variant.\n                if (discr == shared_variant_discr)\n                    continue;\n\n                size_t size = variant_column.getVariantByGlobalDiscriminator(discr).size();\n                /// If column has statistics from the data part, use size from it for consistency.\n                /// It's important to keep the same dynamic structure of the result column during ALTER.\n                if (statistics)\n                {\n                    auto statistics_it = statistics->variants_statistics.find(name);\n                    if (statistics_it != statistics->variants_statistics.end())\n                        size = statistics_it->second;\n                }\n                variants_with_sizes.emplace_back(size, name, variants[discr]);\n            }\n\n            std::sort(variants_with_sizes.begin(), variants_with_sizes.end(), std::greater());\n            DataTypes result_variants;\n            result_variants.reserve(to_max_types + 1); /// +1 for shared variant.\n            /// Add new variants from sorted list until we reach to_max_types.\n            for (const auto & [size, name, type] : variants_with_sizes)\n            {\n                if (result_variants.size() < to_max_types)\n                    result_variants.push_back(type);\n                else\n                    break;\n            }\n\n            /// Add shared variant.\n            result_variants.push_back(ColumnDynamic::getSharedVariantDataType());\n            /// Create resulting Variant type and Dynamic column.\n            auto result_variant_type = std::make_shared<DataTypeVariant>(result_variants);\n            auto result_dynamic_column = ColumnDynamic::create(result_variant_type->createColumn(), result_variant_type, to_max_types, to_max_types);\n            const auto & result_variant_info = result_dynamic_column->getVariantInfo();\n            auto & result_variant_column = result_dynamic_column->getVariantColumn();\n            auto result_shared_variant_discr = result_dynamic_column->getSharedVariantDiscriminator();\n            /// Create mapping from old discriminators to the new ones.\n            std::vector<ColumnVariant::Discriminator> old_to_new_discriminators;\n            old_to_new_discriminators.resize(variant_info.variant_name_to_discriminator.size(), result_shared_variant_discr);\n            for (const auto & [name, discr] : result_variant_info.variant_name_to_discriminator)\n            {\n                auto old_discr = variant_info.variant_name_to_discriminator.at(name);\n                old_to_new_discriminators[old_discr] = discr;\n                /// Reuse old variant column if it's not shared variant.\n                if (discr != result_shared_variant_discr)\n                    result_variant_column.getVariantPtrByGlobalDiscriminator(discr) = variant_column.getVariantPtrByGlobalDiscriminator(old_discr);\n            }\n\n            const auto & local_discriminators = variant_column.getLocalDiscriminators();\n            const auto & offsets = variant_column.getOffsets();\n            const auto & shared_variant = dynamic_column.getSharedVariant();\n            auto & result_local_discriminators = result_variant_column.getLocalDiscriminators();\n            result_local_discriminators.reserve(local_discriminators.size());\n            auto & result_offsets = result_variant_column.getOffsets();\n            result_offsets.reserve(offsets.size());\n            auto & result_shared_variant = result_dynamic_column->getSharedVariant();\n            for (size_t i = 0; i != local_discriminators.size(); ++i)\n            {\n                auto global_discr = variant_column.globalDiscriminatorByLocal(local_discriminators[i]);\n                if (global_discr == ColumnVariant::NULL_DISCRIMINATOR)\n                {\n                    result_local_discriminators.push_back(ColumnVariant::NULL_DISCRIMINATOR);\n                    result_offsets.emplace_back();\n                }\n                else if (global_discr == shared_variant_discr)\n                {\n                    result_local_discriminators.push_back(result_variant_column.localDiscriminatorByGlobal(result_shared_variant_discr));\n                    result_offsets.push_back(result_shared_variant.size());\n                    result_shared_variant.insertFrom(shared_variant, offsets[i]);\n                }\n                else\n                {\n                    auto result_global_discr = old_to_new_discriminators[global_discr];\n                    if (result_global_discr == result_shared_variant_discr)\n                    {\n                        result_local_discriminators.push_back(result_variant_column.localDiscriminatorByGlobal(result_shared_variant_discr));\n                        result_offsets.push_back(result_shared_variant.size());\n                        ColumnDynamic::serializeValueIntoSharedVariant(\n                            result_shared_variant,\n                            variant_column.getVariantByGlobalDiscriminator(global_discr),\n                            variants[global_discr],\n                            variants[global_discr]->getDefaultSerialization(),\n                            offsets[i]);\n                    }\n                    else\n                    {\n                        result_local_discriminators.push_back(result_variant_column.localDiscriminatorByGlobal(result_global_discr));\n                        result_offsets.push_back(offsets[i]);\n                    }\n                }\n            }\n\n            return result_dynamic_column;\n        };\n    }\n\n    /// Wrapper for conversion to/from Dynamic type\n    WrapperType createDynamicWrapper(const DataTypePtr & from_type, const DataTypePtr & to_type) const\n    {\n        if (const auto * from_dynamic = checkAndGetDataType<DataTypeDynamic>(from_type.get()))\n        {\n            if (const auto * to_dynamic = checkAndGetDataType<DataTypeDynamic>(to_type.get()))\n                return createDynamicToDynamicWrapper(*from_dynamic, *to_dynamic);\n\n            return createDynamicToColumnWrapper(to_type);\n        }\n\n        return createColumnToDynamicWrapper(from_type, *checkAndGetDataType<DataTypeDynamic>(to_type.get()));\n    }\n\n    template <typename FieldType>\n    WrapperType createEnumWrapper(const DataTypePtr & from_type, const DataTypeEnum<FieldType> * to_type) const\n    {\n        using EnumType = DataTypeEnum<FieldType>;\n        using Function = typename FunctionTo<EnumType>::Type;\n\n        if (const auto * from_enum8 = checkAndGetDataType<DataTypeEnum8>(from_type.get()))\n            checkEnumToEnumConversion(from_enum8, to_type);\n        else if (const auto * from_enum16 = checkAndGetDataType<DataTypeEnum16>(from_type.get()))\n            checkEnumToEnumConversion(from_enum16, to_type);\n\n        if (checkAndGetDataType<DataTypeString>(from_type.get()))\n            return createStringToEnumWrapper<ColumnString, EnumType>();\n        else if (checkAndGetDataType<DataTypeFixedString>(from_type.get()))\n            return createStringToEnumWrapper<ColumnFixedString, EnumType>();\n        else if (isNativeNumber(from_type) || isEnum(from_type))\n        {\n            auto function = Function::create(context);\n            return createFunctionAdaptor(function, from_type);\n        }\n        else\n        {\n            if (cast_type == CastType::accurateOrNull)\n                return createToNullableColumnWrapper();\n            else\n                throw Exception(ErrorCodes::CANNOT_CONVERT_TYPE, \"Conversion from {} to {} is not supported\",\n                    from_type->getName(), to_type->getName());\n        }\n    }\n\n    template <typename EnumTypeFrom, typename EnumTypeTo>\n    void checkEnumToEnumConversion(const EnumTypeFrom * from_type, const EnumTypeTo * to_type) const\n    {\n        const auto & from_values = from_type->getValues();\n        const auto & to_values = to_type->getValues();\n\n        using ValueType = std::common_type_t<typename EnumTypeFrom::FieldType, typename EnumTypeTo::FieldType>;\n        using NameValuePair = std::pair<std::string, ValueType>;\n        using EnumValues = std::vector<NameValuePair>;\n\n        EnumValues name_intersection;\n        std::set_intersection(std::begin(from_values), std::end(from_values),\n            std::begin(to_values), std::end(to_values), std::back_inserter(name_intersection),\n            [] (auto && from, auto && to) { return from.first < to.first; });\n\n        for (const auto & name_value : name_intersection)\n        {\n            const auto & old_value = name_value.second;\n            const auto & new_value = to_type->getValue(name_value.first);\n            if (old_value != new_value)\n                throw Exception(ErrorCodes::CANNOT_CONVERT_TYPE, \"Enum conversion changes value for element '{}' from {} to {}\",\n                    name_value.first, toString(old_value), toString(new_value));\n        }\n    }\n\n    template <typename ColumnStringType, typename EnumType>\n    WrapperType createStringToEnumWrapper() const\n    {\n        const char * function_name = cast_name;\n        return [function_name] (\n            ColumnsWithTypeAndName & arguments, const DataTypePtr & res_type, const ColumnNullable * nullable_col, size_t /*input_rows_count*/)\n        {\n            const auto & first_col = arguments.front().column.get();\n            const auto & result_type = typeid_cast<const EnumType &>(*res_type);\n\n            const ColumnStringType * col = typeid_cast<const ColumnStringType *>(first_col);\n\n            if (col && nullable_col && nullable_col->size() != col->size())\n                throw Exception(ErrorCodes::LOGICAL_ERROR, \"ColumnNullable is not compatible with original\");\n\n            if (col)\n            {\n                const auto size = col->size();\n\n                auto res = result_type.createColumn();\n                auto & out_data = static_cast<typename EnumType::ColumnType &>(*res).getData();\n                out_data.resize(size);\n\n                auto default_enum_value = result_type.getValues().front().second;\n\n                if (nullable_col)\n                {\n                    for (size_t i = 0; i < size; ++i)\n                    {\n                        if (!nullable_col->isNullAt(i))\n                            out_data[i] = result_type.getValue(col->getDataAt(i));\n                        else\n                            out_data[i] = default_enum_value;\n                    }\n                }\n                else\n                {\n                    for (size_t i = 0; i < size; ++i)\n                        out_data[i] = result_type.getValue(col->getDataAt(i));\n                }\n\n                return res;\n            }\n            else\n                throw Exception(ErrorCodes::LOGICAL_ERROR, \"Unexpected column {} as first argument of function {}\",\n                    first_col->getName(), function_name);\n        };\n    }\n\n    template <typename EnumType>\n    WrapperType createEnumToStringWrapper() const\n    {\n        const char * function_name = cast_name;\n        return [function_name] (\n            ColumnsWithTypeAndName & arguments, const DataTypePtr & res_type, const ColumnNullable * nullable_col, size_t /*input_rows_count*/)\n        {\n            using ColumnEnumType = typename EnumType::ColumnType;\n\n            const auto & first_col = arguments.front().column.get();\n            const auto & first_type = arguments.front().type.get();\n\n            const ColumnEnumType * enum_col = typeid_cast<const ColumnEnumType *>(first_col);\n            const EnumType * enum_type = typeid_cast<const EnumType *>(first_type);\n\n            if (enum_col && nullable_col && nullable_col->size() != enum_col->size())\n                throw Exception(ErrorCodes::LOGICAL_ERROR, \"ColumnNullable is not compatible with original\");\n\n            if (enum_col && enum_type)\n            {\n                const auto size = enum_col->size();\n                const auto & enum_data = enum_col->getData();\n\n                auto res = res_type->createColumn();\n\n                if (nullable_col)\n                {\n                    for (size_t i = 0; i < size; ++i)\n                    {\n                        if (!nullable_col->isNullAt(i))\n                        {\n                            const auto & value = enum_type->getNameForValue(enum_data[i]);\n                            res->insertData(value.data, value.size);\n                        }\n                        else\n                            res->insertDefault();\n                    }\n                }\n                else\n                {\n                    for (size_t i = 0; i < size; ++i)\n                    {\n                        const auto & value = enum_type->getNameForValue(enum_data[i]);\n                        res->insertData(value.data, value.size);\n                    }\n                }\n\n                return res;\n            }\n            else\n                throw Exception(ErrorCodes::LOGICAL_ERROR, \"Unexpected column {} as first argument of function {}\",\n                    first_col->getName(), function_name);\n        };\n    }\n\n    static WrapperType createIdentityWrapper(const DataTypePtr &)\n    {\n        return [] (ColumnsWithTypeAndName & arguments, const DataTypePtr &, const ColumnNullable *, size_t /*input_rows_count*/)\n        {\n            return arguments.front().column;\n        };\n    }\n\n    static WrapperType createNothingWrapper(const IDataType * to_type)\n    {\n        ColumnPtr res = to_type->createColumnConstWithDefaultValue(1);\n        return [res] (ColumnsWithTypeAndName &, const DataTypePtr &, const ColumnNullable *, size_t input_rows_count)\n        {\n            /// Column of Nothing type is trivially convertible to any other column\n            return res->cloneResized(input_rows_count)->convertToFullColumnIfConst();\n        };\n    }\n\n    WrapperType prepareUnpackDictionaries(const DataTypePtr & from_type, const DataTypePtr & to_type) const\n    {\n        /// Conversion from/to Variant/Dynamic data type is processed in a special way.\n        /// We don't need to remove LowCardinality/Nullable.\n        if (isDynamic(to_type) || isDynamic(from_type))\n            return createDynamicWrapper(from_type, to_type);\n\n        if (isVariant(to_type) || isVariant(from_type))\n            return createVariantWrapper(from_type, to_type);\n\n        const auto * from_low_cardinality = typeid_cast<const DataTypeLowCardinality *>(from_type.get());\n        const auto * to_low_cardinality = typeid_cast<const DataTypeLowCardinality *>(to_type.get());\n        const auto & from_nested = from_low_cardinality ? from_low_cardinality->getDictionaryType() : from_type;\n        const auto & to_nested = to_low_cardinality ? to_low_cardinality->getDictionaryType() : to_type;\n\n        if (from_type->onlyNull())\n        {\n            if (!to_nested->isNullable() && !isVariant(to_type))\n            {\n                if (cast_type == CastType::accurateOrNull)\n                {\n                    return createToNullableColumnWrapper();\n                }\n                else\n                {\n                    throw Exception(ErrorCodes::CANNOT_CONVERT_TYPE, \"Cannot convert NULL to a non-nullable type\");\n                }\n            }\n\n            return [](ColumnsWithTypeAndName &, const DataTypePtr & result_type, const ColumnNullable *, size_t input_rows_count)\n            {\n                return result_type->createColumnConstWithDefaultValue(input_rows_count)->convertToFullColumnIfConst();\n            };\n        }\n\n        bool skip_not_null_check = false;\n\n        if (from_low_cardinality && from_nested->isNullable() && !to_nested->isNullable())\n            /// Disable check for dictionary. Will check that column doesn't contain NULL in wrapper below.\n            skip_not_null_check = true;\n\n        auto wrapper = prepareRemoveNullable(from_nested, to_nested, skip_not_null_check);\n        if (!from_low_cardinality && !to_low_cardinality)\n            return wrapper;\n\n        return [wrapper, from_low_cardinality, to_low_cardinality, skip_not_null_check]\n                (ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable * nullable_source, size_t input_rows_count) -> ColumnPtr\n        {\n            ColumnsWithTypeAndName args = {arguments[0]};\n            auto & arg = args.front();\n            auto res_type = result_type;\n\n            ColumnPtr converted_column;\n\n            ColumnPtr res_indexes;\n            /// For some types default can't be casted (for example, String to Int). In that case convert column to full.\n            bool src_converted_to_full_column = false;\n\n            {\n                auto tmp_rows_count = input_rows_count;\n\n                if (to_low_cardinality)\n                    res_type = to_low_cardinality->getDictionaryType();\n\n                if (from_low_cardinality)\n                {\n                    const auto & col_low_cardinality = typeid_cast<const ColumnLowCardinality &>(*arguments[0].column);\n\n                    if (skip_not_null_check && col_low_cardinality.containsNull())\n                        throw Exception(ErrorCodes::CANNOT_INSERT_NULL_IN_ORDINARY_COLUMN, \"Cannot convert NULL value to non-Nullable type\");\n\n                    arg.column = col_low_cardinality.getDictionary().getNestedColumn();\n                    arg.type = from_low_cardinality->getDictionaryType();\n\n                    /// TODO: Make map with defaults conversion.\n                    src_converted_to_full_column = !removeNullable(arg.type)->equals(*removeNullable(res_type));\n                    if (src_converted_to_full_column)\n                        arg.column = arg.column->index(col_low_cardinality.getIndexes(), 0);\n                    else\n                        res_indexes = col_low_cardinality.getIndexesPtr();\n\n                    tmp_rows_count = arg.column->size();\n                }\n\n                /// Perform the requested conversion.\n                converted_column = wrapper(args, res_type, nullable_source, tmp_rows_count);\n            }\n\n            if (to_low_cardinality)\n            {\n                auto res_column = to_low_cardinality->createColumn();\n                auto & col_low_cardinality = typeid_cast<ColumnLowCardinality &>(*res_column);\n\n                if (from_low_cardinality && !src_converted_to_full_column)\n                    col_low_cardinality.insertRangeFromDictionaryEncodedColumn(*converted_column, *res_indexes);\n                else\n                    col_low_cardinality.insertRangeFromFullColumn(*converted_column, 0, converted_column->size());\n\n                return res_column;\n            }\n            else if (!src_converted_to_full_column)\n                return converted_column->index(*res_indexes, 0);\n            else\n                return converted_column;\n        };\n    }\n\n    WrapperType prepareRemoveNullable(const DataTypePtr & from_type, const DataTypePtr & to_type, bool skip_not_null_check) const\n    {\n        /// Determine whether pre-processing and/or post-processing must take place during conversion.\n\n        bool source_is_nullable = from_type->isNullable();\n        bool result_is_nullable = to_type->isNullable();\n\n        auto wrapper = prepareImpl(removeNullable(from_type), removeNullable(to_type), result_is_nullable);\n\n        if (result_is_nullable)\n        {\n            return [wrapper, source_is_nullable]\n                (ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable *, size_t input_rows_count) -> ColumnPtr\n            {\n                /// Create a temporary columns on which to perform the operation.\n                const auto & nullable_type = static_cast<const DataTypeNullable &>(*result_type);\n                const auto & nested_type = nullable_type.getNestedType();\n\n                ColumnsWithTypeAndName tmp_args;\n                if (source_is_nullable)\n                    tmp_args = createBlockWithNestedColumns(arguments);\n                else\n                    tmp_args = arguments;\n\n                const ColumnNullable * nullable_source = nullptr;\n\n                /// Add original ColumnNullable for createStringToEnumWrapper()\n                if (source_is_nullable)\n                {\n                    if (arguments.size() != 1)\n                        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Invalid number of arguments\");\n                    nullable_source = typeid_cast<const ColumnNullable *>(arguments.front().column.get());\n                }\n\n                /// Perform the requested conversion.\n                auto tmp_res = wrapper(tmp_args, nested_type, nullable_source, input_rows_count);\n\n                /// May happen in fuzzy tests. For debug purpose.\n                if (!tmp_res)\n                    throw Exception(ErrorCodes::LOGICAL_ERROR, \"Couldn't convert {} to {} in prepareRemoveNullable wrapper.\",\n                                    arguments[0].type->getName(), nested_type->getName());\n\n                return wrapInNullable(tmp_res, arguments, nested_type, input_rows_count);\n            };\n        }\n        else if (source_is_nullable)\n        {\n            /// Conversion from Nullable to non-Nullable.\n\n            return [wrapper, skip_not_null_check]\n                (ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable *, size_t input_rows_count) -> ColumnPtr\n            {\n                auto tmp_args = createBlockWithNestedColumns(arguments);\n                auto nested_type = removeNullable(result_type);\n\n                /// Check that all values are not-NULL.\n                /// Check can be skipped in case if LowCardinality dictionary is transformed.\n                /// In that case, correctness will be checked beforehand.\n                if (!skip_not_null_check)\n                {\n                    const auto & col = arguments[0].column;\n                    const auto & nullable_col = assert_cast<const ColumnNullable &>(*col);\n                    const auto & null_map = nullable_col.getNullMapData();\n\n                    if (!memoryIsZero(null_map.data(), 0, null_map.size()))\n                        throw Exception(ErrorCodes::CANNOT_INSERT_NULL_IN_ORDINARY_COLUMN, \"Cannot convert NULL value to non-Nullable type\");\n                }\n                const ColumnNullable * nullable_source = typeid_cast<const ColumnNullable *>(arguments.front().column.get());\n                return wrapper(tmp_args, nested_type, nullable_source, input_rows_count);\n            };\n        }\n        else\n            return wrapper;\n    }\n\n    /// 'from_type' and 'to_type' are nested types in case of Nullable.\n    /// 'requested_result_is_nullable' is true if CAST to Nullable type is requested.\n    WrapperType prepareImpl(const DataTypePtr & from_type, const DataTypePtr & to_type, bool requested_result_is_nullable) const\n    {\n        if (isUInt8(from_type) && isBool(to_type))\n            return createUInt8ToBoolWrapper(from_type, to_type);\n\n        /// We can cast IPv6 into IPv6, IPv4 into IPv4, but we should not allow to cast FixedString(16) into IPv6 as part of identity cast\n        bool safe_convert_custom_types = true;\n\n        if (const auto * to_type_custom_name = to_type->getCustomName())\n            safe_convert_custom_types = from_type->getCustomName() && from_type->getCustomName()->getName() == to_type_custom_name->getName();\n        else if (const auto * from_type_custom_name = from_type->getCustomName())\n            safe_convert_custom_types = to_type->getCustomName() && from_type_custom_name->getName() == to_type->getCustomName()->getName();\n\n        if (from_type->equals(*to_type) && safe_convert_custom_types)\n        {\n            /// We can only use identity conversion for DataTypeAggregateFunction when they are strictly equivalent.\n            if (typeid_cast<const DataTypeAggregateFunction *>(from_type.get()))\n            {\n                if (DataTypeAggregateFunction::strictEquals(from_type, to_type))\n                    return createIdentityWrapper(from_type);\n            }\n            else\n                return createIdentityWrapper(from_type);\n        }\n        else if (WhichDataType(from_type).isNothing())\n            return createNothingWrapper(to_type.get());\n\n        WrapperType ret;\n\n        auto make_default_wrapper = [&](const auto & types) -> bool\n        {\n            using Types = std::decay_t<decltype(types)>;\n            using ToDataType = typename Types::LeftType;\n\n            if constexpr (is_any_of<ToDataType,\n                DataTypeUInt16, DataTypeUInt32, DataTypeUInt64, DataTypeUInt128, DataTypeUInt256,\n                DataTypeInt8, DataTypeInt16, DataTypeInt32, DataTypeInt64, DataTypeInt128, DataTypeInt256,\n                DataTypeFloat32, DataTypeFloat64,\n                DataTypeDate, DataTypeDate32, DataTypeDateTime,\n                DataTypeUUID, DataTypeIPv4, DataTypeIPv6>)\n            {\n                ret = createWrapper(from_type, checkAndGetDataType<ToDataType>(to_type.get()), requested_result_is_nullable);\n                return true;\n            }\n            if constexpr (std::is_same_v<ToDataType, DataTypeUInt8>)\n            {\n                if (isBool(to_type))\n                    ret = createBoolWrapper<ToDataType>(from_type, checkAndGetDataType<ToDataType>(to_type.get()), requested_result_is_nullable);\n                else\n                    ret = createWrapper(from_type, checkAndGetDataType<ToDataType>(to_type.get()), requested_result_is_nullable);\n                return true;\n            }\n            if constexpr (\n                std::is_same_v<ToDataType, DataTypeEnum8> ||\n                std::is_same_v<ToDataType, DataTypeEnum16>)\n            {\n                ret = createEnumWrapper(from_type, checkAndGetDataType<ToDataType>(to_type.get()));\n                return true;\n            }\n            if constexpr (is_any_of<ToDataType,\n                DataTypeDecimal<Decimal32>, DataTypeDecimal<Decimal64>,\n                DataTypeDecimal<Decimal128>, DataTypeDecimal<Decimal256>,\n                DataTypeDateTime64>)\n            {\n                ret = createDecimalWrapper(from_type, checkAndGetDataType<ToDataType>(to_type.get()), requested_result_is_nullable);\n                return true;\n            }\n\n            return false;\n        };\n\n        bool cast_ipv4_ipv6_default_on_conversion_error_value = context && context->getSettingsRef()[Setting::cast_ipv4_ipv6_default_on_conversion_error];\n        bool input_format_ipv4_default_on_conversion_error_value = context && context->getSettingsRef()[Setting::input_format_ipv4_default_on_conversion_error];\n        bool input_format_ipv6_default_on_conversion_error_value = context && context->getSettingsRef()[Setting::input_format_ipv6_default_on_conversion_error];\n\n        auto make_custom_serialization_wrapper = [&, cast_ipv4_ipv6_default_on_conversion_error_value, input_format_ipv4_default_on_conversion_error_value, input_format_ipv6_default_on_conversion_error_value](const auto & types) -> bool\n        {\n            using Types = std::decay_t<decltype(types)>;\n            using ToDataType = typename Types::RightType;\n            using FromDataType = typename Types::LeftType;\n\n            if constexpr (WhichDataType(FromDataType::type_id).isStringOrFixedString())\n            {\n                if constexpr (std::is_same_v<ToDataType, DataTypeIPv4>)\n                {\n                    ret = [cast_ipv4_ipv6_default_on_conversion_error_value,\n                           input_format_ipv4_default_on_conversion_error_value,\n                           requested_result_is_nullable](\n                              ColumnsWithTypeAndName & arguments,\n                              const DataTypePtr & result_type,\n                              const ColumnNullable * column_nullable,\n                              size_t) -> ColumnPtr\n                    {\n                        if (!WhichDataType(result_type).isIPv4())\n                            throw Exception(ErrorCodes::TYPE_MISMATCH, \"Wrong result type {}. Expected IPv4\", result_type->getName());\n\n                        const auto * null_map = column_nullable ? &column_nullable->getNullMapData() : nullptr;\n                        if (requested_result_is_nullable)\n                            return convertToIPv4<IPStringToNumExceptionMode::Null>(arguments[0].column, null_map);\n                        else if (cast_ipv4_ipv6_default_on_conversion_error_value || input_format_ipv4_default_on_conversion_error_value)\n                            return convertToIPv4<IPStringToNumExceptionMode::Default>(arguments[0].column, null_map);\n                        else\n                            return convertToIPv4<IPStringToNumExceptionMode::Throw>(arguments[0].column, null_map);\n                    };\n\n                    return true;\n                }\n\n                if constexpr (std::is_same_v<ToDataType, DataTypeIPv6>)\n                {\n                    ret = [cast_ipv4_ipv6_default_on_conversion_error_value,\n                           input_format_ipv6_default_on_conversion_error_value,\n                           requested_result_is_nullable](\n                              ColumnsWithTypeAndName & arguments,\n                              const DataTypePtr & result_type,\n                              const ColumnNullable * column_nullable,\n                              size_t) -> ColumnPtr\n                    {\n                        if (!WhichDataType(result_type).isIPv6())\n                            throw Exception(\n                                ErrorCodes::TYPE_MISMATCH, \"Wrong result type {}. Expected IPv6\", result_type->getName());\n\n                        const auto * null_map = column_nullable ? &column_nullable->getNullMapData() : nullptr;\n                        if (requested_result_is_nullable)\n                            return convertToIPv6<IPStringToNumExceptionMode::Null>(arguments[0].column, null_map);\n                        else if (cast_ipv4_ipv6_default_on_conversion_error_value || input_format_ipv6_default_on_conversion_error_value)\n                            return convertToIPv6<IPStringToNumExceptionMode::Default>(arguments[0].column, null_map);\n                        else\n                            return convertToIPv6<IPStringToNumExceptionMode::Throw>(arguments[0].column, null_map);\n                    };\n\n                    return true;\n                }\n\n                if (to_type->getCustomSerialization() && to_type->getCustomName())\n                {\n                    ret = [requested_result_is_nullable, this](\n                              ColumnsWithTypeAndName & arguments,\n                              const DataTypePtr & result_type,\n                              const ColumnNullable * column_nullable,\n                              size_t input_rows_count) -> ColumnPtr\n                    {\n                        auto wrapped_result_type = result_type;\n                        if (requested_result_is_nullable)\n                            wrapped_result_type = makeNullable(result_type);\n                        if (this->cast_type == CastType::accurateOrNull)\n                            return ConvertImplGenericFromString<false>::execute(\n                                arguments, wrapped_result_type, column_nullable, input_rows_count, context);\n                        return ConvertImplGenericFromString<true>::execute(\n                            arguments, wrapped_result_type, column_nullable, input_rows_count, context);\n                    };\n                    return true;\n                }\n            }\n            else if constexpr (WhichDataType(FromDataType::type_id).isIPv6() && WhichDataType(ToDataType::type_id).isIPv4())\n            {\n                ret = [cast_ipv4_ipv6_default_on_conversion_error_value, requested_result_is_nullable](\n                                ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable * column_nullable, size_t)\n                        -> ColumnPtr\n                {\n                    if (!WhichDataType(result_type).isIPv4())\n                        throw Exception(\n                            ErrorCodes::TYPE_MISMATCH, \"Wrong result type {}. Expected IPv4\", result_type->getName());\n\n                    const auto * null_map = column_nullable ? &column_nullable->getNullMapData() : nullptr;\n                    if (requested_result_is_nullable)\n                        return convertIPv6ToIPv4<IPStringToNumExceptionMode::Null>(arguments[0].column, null_map);\n                    else if (cast_ipv4_ipv6_default_on_conversion_error_value)\n                        return convertIPv6ToIPv4<IPStringToNumExceptionMode::Default>(arguments[0].column, null_map);\n                    else\n                        return convertIPv6ToIPv4<IPStringToNumExceptionMode::Throw>(arguments[0].column, null_map);\n                };\n\n                return true;\n            }\n\n            if constexpr (WhichDataType(ToDataType::type_id).isStringOrFixedString())\n            {\n                if constexpr (WhichDataType(FromDataType::type_id).isEnum())\n                {\n                    ret = createEnumToStringWrapper<FromDataType>();\n                    return true;\n                }\n                else if (from_type->getCustomSerialization())\n                {\n                    ret = [this](ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable *, size_t input_rows_count) -> ColumnPtr\n                    {\n                        return ConvertImplGenericToString<typename ToDataType::ColumnType>::execute(arguments, result_type, input_rows_count, context);\n                    };\n                    return true;\n                }\n            }\n\n            return false;\n        };\n\n        if (callOnTwoTypeIndexes(from_type->getTypeId(), to_type->getTypeId(), make_custom_serialization_wrapper))\n            return ret;\n\n        if (callOnIndexAndDataType<void>(to_type->getTypeId(), make_default_wrapper))\n            return ret;\n\n        switch (to_type->getTypeId())\n        {\n            case TypeIndex::String:\n                return createStringWrapper(from_type);\n            case TypeIndex::FixedString:\n                return createFixedStringWrapper(from_type, checkAndGetDataType<DataTypeFixedString>(to_type.get())->getN());\n            case TypeIndex::Array:\n                return createArrayWrapper(from_type, static_cast<const DataTypeArray &>(*to_type));\n            case TypeIndex::Tuple:\n                return createTupleWrapper(from_type, checkAndGetDataType<DataTypeTuple>(to_type.get()));\n            case TypeIndex::Map:\n                return createMapWrapper(from_type, checkAndGetDataType<DataTypeMap>(to_type.get()));\n            case TypeIndex::ObjectDeprecated:\n                return createObjectDeprecatedWrapper(from_type, checkAndGetDataType<DataTypeObjectDeprecated>(to_type.get()));\n            case TypeIndex::Object:\n                return createObjectWrapper(from_type, checkAndGetDataType<DataTypeObject>(to_type.get()));\n            case TypeIndex::AggregateFunction:\n                return createAggregateFunctionWrapper(from_type, checkAndGetDataType<DataTypeAggregateFunction>(to_type.get()));\n            case TypeIndex::Interval:\n                return createIntervalWrapper(from_type, checkAndGetDataType<DataTypeInterval>(to_type.get())->getKind());\n            default:\n                break;\n        }\n\n        if (cast_type == CastType::accurateOrNull)\n            return createToNullableColumnWrapper();\n        else\n            throw Exception(ErrorCodes::CANNOT_CONVERT_TYPE, \"Conversion from {} to {} is not supported\",\n                from_type->getName(), to_type->getName());\n    }\n};\n\n}\n\n\nFunctionBasePtr createFunctionBaseCast(\n    ContextPtr context,\n    const char * name,\n    const ColumnsWithTypeAndName & arguments,\n    const DataTypePtr & return_type,\n    std::optional<CastDiagnostic> diagnostic,\n    CastType cast_type)\n{\n    DataTypes data_types(arguments.size());\n\n    for (size_t i = 0; i < arguments.size(); ++i)\n        data_types[i] = arguments[i].type;\n\n    FunctionCast::MonotonicityForRange monotonicity;\n\n    if (isEnum(arguments.front().type)\n        && castTypeToEither<DataTypeEnum8, DataTypeEnum16>(return_type.get(), [&](auto & type)\n        {\n            monotonicity = FunctionTo<std::decay_t<decltype(type)>>::Type::Monotonic::get;\n            return true;\n        }))\n    {\n    }\n    else if (castTypeToEither<\n        DataTypeUInt8, DataTypeUInt16, DataTypeUInt32, DataTypeUInt64, DataTypeUInt128, DataTypeUInt256,\n        DataTypeInt8, DataTypeInt16, DataTypeInt32, DataTypeInt64, DataTypeInt128, DataTypeInt256,\n        DataTypeFloat32, DataTypeFloat64,\n        DataTypeDate, DataTypeDate32, DataTypeDateTime, DataTypeDateTime64,\n        DataTypeString>(return_type.get(), [&](auto & type)\n        {\n            monotonicity = FunctionTo<std::decay_t<decltype(type)>>::Type::Monotonic::get;\n            return true;\n        }))\n    {\n    }\n\n    return std::make_unique<FunctionCast>(context, name, std::move(monotonicity), data_types, return_type, diagnostic, cast_type);\n}\n\nREGISTER_FUNCTION(Conversion)\n{\n    factory.registerFunction<FunctionToUInt8>();\n    factory.registerFunction<FunctionToUInt16>();\n    factory.registerFunction<FunctionToUInt32>();\n    factory.registerFunction<FunctionToUInt64>();\n    factory.registerFunction<FunctionToUInt128>();\n    factory.registerFunction<FunctionToUInt256>();\n    factory.registerFunction<FunctionToInt8>();\n    factory.registerFunction<FunctionToInt16>();\n    factory.registerFunction<FunctionToInt32>();\n    factory.registerFunction<FunctionToInt64>();\n    factory.registerFunction<FunctionToInt128>();\n    factory.registerFunction<FunctionToInt256>();\n    factory.registerFunction<FunctionToFloat32>();\n    factory.registerFunction<FunctionToFloat64>();\n\n    factory.registerFunction<FunctionToDecimal32>();\n    factory.registerFunction<FunctionToDecimal64>();\n    factory.registerFunction<FunctionToDecimal128>();\n    factory.registerFunction<FunctionToDecimal256>();\n\n    factory.registerFunction<FunctionToDate>();\n\n    /// MySQL compatibility alias. Cannot be registered as alias,\n    /// because we don't want it to be normalized to toDate in queries,\n    /// otherwise CREATE DICTIONARY query breaks.\n    factory.registerFunction(\"DATE\", &FunctionToDate::create, {}, FunctionFactory::Case::Insensitive);\n\n    factory.registerFunction<FunctionToDate32>();\n    factory.registerFunction<FunctionToDateTime>();\n    factory.registerFunction<FunctionToDateTime32>();\n    factory.registerFunction<FunctionToDateTime64>();\n    factory.registerFunction<FunctionToUUID>();\n    factory.registerFunction<FunctionToIPv4>();\n    factory.registerFunction<FunctionToIPv6>();\n    factory.registerFunction<FunctionToString>();\n\n    factory.registerFunction<FunctionToUnixTimestamp>();\n\n    factory.registerFunction<FunctionToUInt8OrZero>();\n    factory.registerFunction<FunctionToUInt16OrZero>();\n    factory.registerFunction<FunctionToUInt32OrZero>();\n    factory.registerFunction<FunctionToUInt64OrZero>();\n    factory.registerFunction<FunctionToUInt128OrZero>();\n    factory.registerFunction<FunctionToUInt256OrZero>();\n    factory.registerFunction<FunctionToInt8OrZero>();\n    factory.registerFunction<FunctionToInt16OrZero>();\n    factory.registerFunction<FunctionToInt32OrZero>();\n    factory.registerFunction<FunctionToInt64OrZero>();\n    factory.registerFunction<FunctionToInt128OrZero>();\n    factory.registerFunction<FunctionToInt256OrZero>();\n    factory.registerFunction<FunctionToFloat32OrZero>();\n    factory.registerFunction<FunctionToFloat64OrZero>();\n    factory.registerFunction<FunctionToDateOrZero>();\n    factory.registerFunction<FunctionToDate32OrZero>();\n    factory.registerFunction<FunctionToDateTimeOrZero>();\n    factory.registerFunction<FunctionToDateTime64OrZero>();\n\n    factory.registerFunction<FunctionToDecimal32OrZero>();\n    factory.registerFunction<FunctionToDecimal64OrZero>();\n    factory.registerFunction<FunctionToDecimal128OrZero>();\n    factory.registerFunction<FunctionToDecimal256OrZero>();\n\n    factory.registerFunction<FunctionToUUIDOrZero>();\n    factory.registerFunction<FunctionToIPv4OrZero>();\n    factory.registerFunction<FunctionToIPv6OrZero>();\n\n    factory.registerFunction<FunctionToUInt8OrNull>();\n    factory.registerFunction<FunctionToUInt16OrNull>();\n    factory.registerFunction<FunctionToUInt32OrNull>();\n    factory.registerFunction<FunctionToUInt64OrNull>();\n    factory.registerFunction<FunctionToUInt128OrNull>();\n    factory.registerFunction<FunctionToUInt256OrNull>();\n    factory.registerFunction<FunctionToInt8OrNull>();\n    factory.registerFunction<FunctionToInt16OrNull>();\n    factory.registerFunction<FunctionToInt32OrNull>();\n    factory.registerFunction<FunctionToInt64OrNull>();\n    factory.registerFunction<FunctionToInt128OrNull>();\n    factory.registerFunction<FunctionToInt256OrNull>();\n    factory.registerFunction<FunctionToFloat32OrNull>();\n    factory.registerFunction<FunctionToFloat64OrNull>();\n    factory.registerFunction<FunctionToDateOrNull>();\n    factory.registerFunction<FunctionToDate32OrNull>();\n    factory.registerFunction<FunctionToDateTimeOrNull>();\n    factory.registerFunction<FunctionToDateTime64OrNull>();\n\n    factory.registerFunction<FunctionToDecimal32OrNull>();\n    factory.registerFunction<FunctionToDecimal64OrNull>();\n    factory.registerFunction<FunctionToDecimal128OrNull>();\n    factory.registerFunction<FunctionToDecimal256OrNull>();\n\n    factory.registerFunction<FunctionToUUIDOrNull>();\n    factory.registerFunction<FunctionToIPv4OrNull>();\n    factory.registerFunction<FunctionToIPv6OrNull>();\n\n    factory.registerFunction<FunctionParseDateTimeBestEffort>();\n    factory.registerFunction<FunctionParseDateTimeBestEffortOrZero>();\n    factory.registerFunction<FunctionParseDateTimeBestEffortOrNull>();\n    factory.registerFunction<FunctionParseDateTimeBestEffortUS>();\n    factory.registerFunction<FunctionParseDateTimeBestEffortUSOrZero>();\n    factory.registerFunction<FunctionParseDateTimeBestEffortUSOrNull>();\n    factory.registerFunction<FunctionParseDateTime32BestEffort>();\n    factory.registerFunction<FunctionParseDateTime32BestEffortOrZero>();\n    factory.registerFunction<FunctionParseDateTime32BestEffortOrNull>();\n    factory.registerFunction<FunctionParseDateTime64BestEffort>();\n    factory.registerFunction<FunctionParseDateTime64BestEffortOrZero>();\n    factory.registerFunction<FunctionParseDateTime64BestEffortOrNull>();\n    factory.registerFunction<FunctionParseDateTime64BestEffortUS>();\n    factory.registerFunction<FunctionParseDateTime64BestEffortUSOrZero>();\n    factory.registerFunction<FunctionParseDateTime64BestEffortUSOrNull>();",
        "res_region": "",
        "lookback": "    return std::make_unique<detail::FunctionCast>(context, name, std::move(monotonicity), data_types, return_type, diagnostic, cast_type);",
        "lookahead": "",
        "label": [
            "base",
            "base_empty"
        ],
        "start_line": 76,
        "end_line": 9701,
        "merge_gen_region": null,
        "confidence": 0.5509652495384216,
        "hesitated": true
    }
]