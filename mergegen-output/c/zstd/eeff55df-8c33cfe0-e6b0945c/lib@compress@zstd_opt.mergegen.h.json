[
    {
        "a_contents": "#define ZSTD_LITFREQ_ADD    2\n#define ZSTD_FREQ_DIV       4\n#define ZSTD_MAX_PRICE      (1<<30)\n\n/*-*************************************\n*  Price functions for optimal parser\n***************************************/\nstatic void ZSTD_setLog2Prices(optState_t* optPtr)\n{\n    optPtr->log2matchLengthSum = ZSTD_highbit32(optPtr->matchLengthSum+1);\n    optPtr->log2litLengthSum = ZSTD_highbit32(optPtr->litLengthSum+1);\n    optPtr->log2litSum = ZSTD_highbit32(optPtr->litSum+1);\n    optPtr->log2offCodeSum = ZSTD_highbit32(optPtr->offCodeSum+1);\n    optPtr->factor = 1 + ((optPtr->litSum>>5) / optPtr->litLengthSum) + ((optPtr->litSum<<1) / (optPtr->litSum + optPtr->matchSum));\n}\n\n\nstatic void ZSTD_rescaleFreqs(optState_t* optPtr, const BYTE* src, size_t srcSize)\n{\n    unsigned u;\n\n    optPtr->cachedLiterals = NULL;\n    optPtr->cachedPrice = optPtr->cachedLitLength = 0;\n    optPtr->staticPrices = 0;\n\n    if (optPtr->litLengthSum == 0) {\n        if (srcSize <= 1024) optPtr->staticPrices = 1;\n\n        assert(optPtr->litFreq!=NULL);\n        for (u=0; u<=MaxLit; u++)\n            optPtr->litFreq[u] = 0;\n        for (u=0; u<srcSize; u++)\n            optPtr->litFreq[src[u]]++;\n\n        optPtr->litSum = 0;\n        optPtr->litLengthSum = MaxLL+1;\n        optPtr->matchLengthSum = MaxML+1;\n        optPtr->offCodeSum = (MaxOff+1);\n        optPtr->matchSum = (ZSTD_LITFREQ_ADD<<Litbits);\n\n        for (u=0; u<=MaxLit; u++) {\n            optPtr->litFreq[u] = 1 + (optPtr->litFreq[u]>>ZSTD_FREQ_DIV);\n            optPtr->litSum += optPtr->litFreq[u];\n        }\n        for (u=0; u<=MaxLL; u++)\n            optPtr->litLengthFreq[u] = 1;\n        for (u=0; u<=MaxML; u++)\n            optPtr->matchLengthFreq[u] = 1;\n        for (u=0; u<=MaxOff; u++)\n            optPtr->offCodeFreq[u] = 1;\n    } else {\n        optPtr->matchLengthSum = 0;\n        optPtr->litLengthSum = 0;\n        optPtr->offCodeSum = 0;\n        optPtr->matchSum = 0;\n        optPtr->litSum = 0;\n\n        for (u=0; u<=MaxLit; u++) {\n            optPtr->litFreq[u] = 1 + (optPtr->litFreq[u]>>(ZSTD_FREQ_DIV+1));\n            optPtr->litSum += optPtr->litFreq[u];\n        }\n        for (u=0; u<=MaxLL; u++) {\n            optPtr->litLengthFreq[u] = 1 + (optPtr->litLengthFreq[u]>>(ZSTD_FREQ_DIV+1));\n            optPtr->litLengthSum += optPtr->litLengthFreq[u];\n        }\n        for (u=0; u<=MaxML; u++) {\n            optPtr->matchLengthFreq[u] = 1 + (optPtr->matchLengthFreq[u]>>ZSTD_FREQ_DIV);\n            optPtr->matchLengthSum += optPtr->matchLengthFreq[u];\n            optPtr->matchSum += optPtr->matchLengthFreq[u] * (u + 3);\n        }\n        optPtr->matchSum *= ZSTD_LITFREQ_ADD;\n        for (u=0; u<=MaxOff; u++) {\n            optPtr->offCodeFreq[u] = 1 + (optPtr->offCodeFreq[u]>>ZSTD_FREQ_DIV);\n            optPtr->offCodeSum += optPtr->offCodeFreq[u];\n        }\n    }\n\n    ZSTD_setLog2Prices(optPtr);\n}\n\n\nstatic U32 ZSTD_getLiteralPrice(optState_t* optPtr, U32 litLength, const BYTE* literals)\n{\n    U32 price, u;\n\n    if (optPtr->staticPrices)\n        return ZSTD_highbit32((U32)litLength+1) + (litLength*6);\n\n    if (litLength == 0)\n        return optPtr->log2litLengthSum - ZSTD_highbit32(optPtr->litLengthFreq[0]+1);\n\n    /* literals */\n    if (optPtr->cachedLiterals == literals) {\n        U32 const additional = litLength - optPtr->cachedLitLength;\n        const BYTE* literals2 = optPtr->cachedLiterals + optPtr->cachedLitLength;\n        price = optPtr->cachedPrice + additional * optPtr->log2litSum;\n        for (u=0; u < additional; u++)\n            price -= ZSTD_highbit32(optPtr->litFreq[literals2[u]]+1);\n        optPtr->cachedPrice = price;\n        optPtr->cachedLitLength = litLength;\n    } else {\n        price = litLength * optPtr->log2litSum;\n        for (u=0; u < litLength; u++)\n            price -= ZSTD_highbit32(optPtr->litFreq[literals[u]]+1);\n\n        if (litLength >= 12) {\n            optPtr->cachedLiterals = literals;\n            optPtr->cachedPrice = price;\n            optPtr->cachedLitLength = litLength;\n        }\n    }\n\n    /* literal Length */\n    {   const BYTE LL_deltaCode = 19;\n        const BYTE llCode = (litLength>63) ? (BYTE)ZSTD_highbit32(litLength) + LL_deltaCode : LL_Code[litLength];\n        price += LL_bits[llCode] + optPtr->log2litLengthSum - ZSTD_highbit32(optPtr->litLengthFreq[llCode]+1);\n    }\n\n    return price;\n}\n\n\nFORCE_INLINE_TEMPLATE U32 ZSTD_getPrice(optState_t* optPtr, U32 litLength, const BYTE* literals, U32 offset, U32 matchLength, const int ultra)\n{\n    /* offset */\n    U32 price;\n    BYTE const offCode = (BYTE)ZSTD_highbit32(offset+1);\n\n    if (optPtr->staticPrices)\n        return ZSTD_getLiteralPrice(optPtr, litLength, literals) + ZSTD_highbit32((U32)matchLength+1) + 16 + offCode;\n\n    price = offCode + optPtr->log2offCodeSum - ZSTD_highbit32(optPtr->offCodeFreq[offCode]+1);\n    if (!ultra && offCode >= 20) price += (offCode-19)*2;\n\n    /* match Length */\n    {   const BYTE ML_deltaCode = 36;\n        const BYTE mlCode = (matchLength>127) ? (BYTE)ZSTD_highbit32(matchLength) + ML_deltaCode : ML_Code[matchLength];\n        price += ML_bits[mlCode] + optPtr->log2matchLengthSum - ZSTD_highbit32(optPtr->matchLengthFreq[mlCode]+1);\n    }\n\n    return price + ZSTD_getLiteralPrice(optPtr, litLength, literals) + optPtr->factor;\n}\n\n\nstatic void ZSTD_updatePrice(optState_t* optPtr, U32 litLength, const BYTE* literals, U32 offset, U32 matchLength)\n{\n    U32 u;\n\n    /* literals */\n    optPtr->litSum += litLength*ZSTD_LITFREQ_ADD;\n    for (u=0; u < litLength; u++)\n        optPtr->litFreq[literals[u]] += ZSTD_LITFREQ_ADD;\n\n    /* literal Length */\n    {   const BYTE LL_deltaCode = 19;\n        const BYTE llCode = (litLength>63) ? (BYTE)ZSTD_highbit32(litLength) + LL_deltaCode : LL_Code[litLength];\n        optPtr->litLengthFreq[llCode]++;\n        optPtr->litLengthSum++;\n    }\n\n    /* match offset */\n    {   BYTE const offCode = (BYTE)ZSTD_highbit32(offset+1);\n        optPtr->offCodeSum++;\n        optPtr->offCodeFreq[offCode]++;\n    }\n\n    /* match Length */\n    {   const BYTE ML_deltaCode = 36;\n        const BYTE mlCode = (matchLength>127) ? (BYTE)ZSTD_highbit32(matchLength) + ML_deltaCode : ML_Code[matchLength];\n        optPtr->matchLengthFreq[mlCode]++;\n        optPtr->matchLengthSum++;\n    }\n\n    ZSTD_setLog2Prices(optPtr);\n}\n\n\n#define SET_PRICE(pos, mlen_, offset_, litlen_, price_)   \\\n    {                                                 \\\n        while (last_pos < pos)  { opt[last_pos+1].price = ZSTD_MAX_PRICE; last_pos++; } \\\n        opt[pos].mlen = mlen_;                         \\\n        opt[pos].off = offset_;                        \\\n        opt[pos].litlen = litlen_;                     \\\n        opt[pos].price = price_;                       \\\n    }\n\n\n/* function safe only for comparisons */\nstatic U32 ZSTD_readMINMATCH(const void* memPtr, U32 length)\n{\n    switch (length)\n    {\n    default :\n    case 4 : return MEM_read32(memPtr);\n    case 3 : if (MEM_isLittleEndian())\n                return MEM_read32(memPtr)<<8;\n             else\n                return MEM_read32(memPtr)>>8;\n    }\n}\n\n\n/* Update hashTable3 up to ip (excluded)\n   Assumption : always within prefix (i.e. not within extDict) */\nstatic\nU32 ZSTD_insertAndFindFirstIndexHash3 (ZSTD_CCtx* zc, const BYTE* ip)\n{\n    U32* const hashTable3  = zc->hashTable3;\n    U32 const hashLog3  = zc->hashLog3;\n    const BYTE* const base = zc->base;\n    U32 idx = zc->nextToUpdate3;\n    const U32 target = zc->nextToUpdate3 = (U32)(ip - base);\n    const size_t hash3 = ZSTD_hash3Ptr(ip, hashLog3);\n\n    while(idx < target) {\n        hashTable3[ZSTD_hash3Ptr(base+idx, hashLog3)] = idx;\n        idx++;\n    }\n\n    return hashTable3[hash3];\n}\n\n\n/*-*************************************\n*  Binary Tree search\n***************************************/\nstatic U32 ZSTD_insertBtAndGetAllMatches (\n                        ZSTD_CCtx* zc,\n                        const BYTE* const ip, const BYTE* const iLimit,\n                        U32 nbCompares, const U32 mls,\n                        U32 extDict, ZSTD_match_t* matches, const U32 minMatchLen)\n{\n    const BYTE* const base = zc->base;\n    const U32 current = (U32)(ip-base);\n    const U32 hashLog = zc->appliedParams.cParams.hashLog;\n    const size_t h  = ZSTD_hashPtr(ip, hashLog, mls);\n    U32* const hashTable = zc->hashTable;\n    U32 matchIndex  = hashTable[h];\n    U32* const bt   = zc->chainTable;\n    const U32 btLog = zc->appliedParams.cParams.chainLog - 1;\n    const U32 btMask= (1U << btLog) - 1;\n    size_t commonLengthSmaller=0, commonLengthLarger=0;\n    const BYTE* const dictBase = zc->dictBase;\n    const U32 dictLimit = zc->dictLimit;\n    const BYTE* const dictEnd = dictBase + dictLimit;\n    const BYTE* const prefixStart = base + dictLimit;\n    const U32 btLow = btMask >= current ? 0 : current - btMask;\n    const U32 windowLow = zc->lowLimit;\n    U32* smallerPtr = bt + 2*(current&btMask);\n    U32* largerPtr  = bt + 2*(current&btMask) + 1;\n    U32 matchEndIdx = current+8;\n    U32 dummy32;   /* to be nullified at the end */\n    U32 mnum = 0;\n\n    const U32 minMatch = (mls == 3) ? 3 : 4;\n    size_t bestLength = minMatchLen-1;\n\n    if (minMatch == 3) { /* HC3 match finder */\n        U32 const matchIndex3 = ZSTD_insertAndFindFirstIndexHash3 (zc, ip);\n        if (matchIndex3>windowLow && (current - matchIndex3 < (1<<18))) {\n            const BYTE* match;\n            size_t currentMl=0;\n            if ((!extDict) || matchIndex3 >= dictLimit) {\n                match = base + matchIndex3;\n                if (match[bestLength] == ip[bestLength]) currentMl = ZSTD_count(ip, match, iLimit);\n            } else {\n                match = dictBase + matchIndex3;\n                if (ZSTD_readMINMATCH(match, MINMATCH) == ZSTD_readMINMATCH(ip, MINMATCH))    /* assumption : matchIndex3 <= dictLimit-4 (by table construction) */\n                    currentMl = ZSTD_count_2segments(ip+MINMATCH, match+MINMATCH, iLimit, dictEnd, prefixStart) + MINMATCH;\n            }\n\n            /* save best solution */\n            if (currentMl > bestLength) {\n                bestLength = currentMl;\n                matches[mnum].off = ZSTD_REP_MOVE_OPT + current - matchIndex3;\n                matches[mnum].len = (U32)currentMl;\n                mnum++;\n                if (currentMl > ZSTD_OPT_NUM) goto update;\n                if (ip+currentMl == iLimit) goto update; /* best possible, and avoid read overflow*/\n            }\n        }\n    }\n\n    hashTable[h] = current;   /* Update Hash Table */\n\n    while (nbCompares-- && (matchIndex > windowLow)) {\n        U32* nextPtr = bt + 2*(matchIndex & btMask);\n        size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */\n        const BYTE* match;\n\n        if ((!extDict) || (matchIndex+matchLength >= dictLimit)) {\n            match = base + matchIndex;\n            if (match[matchLength] == ip[matchLength]) {\n                matchLength += ZSTD_count(ip+matchLength+1, match+matchLength+1, iLimit) +1;\n            }\n        } else {\n            match = dictBase + matchIndex;\n            matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);\n            if (matchIndex+matchLength >= dictLimit)\n                match = base + matchIndex;   /* to prepare for next usage of match[matchLength] */\n        }\n\n        if (matchLength > bestLength) {\n            if (matchLength > matchEndIdx - matchIndex) matchEndIdx = matchIndex + (U32)matchLength;\n            bestLength = matchLength;\n            matches[mnum].off = ZSTD_REP_MOVE_OPT + current - matchIndex;\n            matches[mnum].len = (U32)matchLength;\n            mnum++;\n            if (matchLength > ZSTD_OPT_NUM) break;\n            if (ip+matchLength == iLimit)   /* equal : no way to know if inf or sup */\n                break;   /* drop, to guarantee consistency (miss a little bit of compression) */\n        }\n\n        if (match[matchLength] < ip[matchLength]) {\n            /* match is smaller than current */\n            *smallerPtr = matchIndex;             /* update smaller idx */\n            commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */\n            if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */\n            smallerPtr = nextPtr+1;               /* new \"smaller\" => larger of match */\n            matchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */\n        } else {\n            /* match is larger than current */\n            *largerPtr = matchIndex;\n            commonLengthLarger = matchLength;\n            if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */\n            largerPtr = nextPtr;\n            matchIndex = nextPtr[0];\n    }   }\n\n    *smallerPtr = *largerPtr = 0;\n\nupdate:\n    zc->nextToUpdate = (matchEndIdx > current + 8) ? matchEndIdx - 8 : current+1;\n    return mnum;\n}\n\n\n/** Tree updater, providing best match */\nstatic U32 ZSTD_BtGetAllMatches (\n                        ZSTD_CCtx* zc,\n                        const BYTE* const ip, const BYTE* const iLimit,\n                        const U32 maxNbAttempts, const U32 mls, ZSTD_match_t* matches, const U32 minMatchLen)\n{\n    if (ip < zc->base + zc->nextToUpdate) return 0;   /* skipped area */\n    ZSTD_updateTree(zc, ip, iLimit, maxNbAttempts, mls);\n    return ZSTD_insertBtAndGetAllMatches(zc, ip, iLimit, maxNbAttempts, mls, 0, matches, minMatchLen);\n}\n\n\nstatic U32 ZSTD_BtGetAllMatches_selectMLS (\n                        ZSTD_CCtx* zc,   /* Index table will be updated */\n                        const BYTE* ip, const BYTE* const iHighLimit,\n                        const U32 maxNbAttempts, const U32 matchLengthSearch, ZSTD_match_t* matches, const U32 minMatchLen)\n{\n    switch(matchLengthSearch)\n    {\n    case 3 : return ZSTD_BtGetAllMatches(zc, ip, iHighLimit, maxNbAttempts, 3, matches, minMatchLen);\n    default :\n    case 4 : return ZSTD_BtGetAllMatches(zc, ip, iHighLimit, maxNbAttempts, 4, matches, minMatchLen);\n    case 5 : return ZSTD_BtGetAllMatches(zc, ip, iHighLimit, maxNbAttempts, 5, matches, minMatchLen);\n    case 7 :\n    case 6 : return ZSTD_BtGetAllMatches(zc, ip, iHighLimit, maxNbAttempts, 6, matches, minMatchLen);\n    }\n}\n\n/** Tree updater, providing best match */\nstatic U32 ZSTD_BtGetAllMatches_extDict (\n                        ZSTD_CCtx* zc,\n                        const BYTE* const ip, const BYTE* const iLimit,\n                        const U32 maxNbAttempts, const U32 mls, ZSTD_match_t* matches, const U32 minMatchLen)\n{\n    if (ip < zc->base + zc->nextToUpdate) return 0;   /* skipped area */\n    ZSTD_updateTree_extDict(zc, ip, iLimit, maxNbAttempts, mls);\n    return ZSTD_insertBtAndGetAllMatches(zc, ip, iLimit, maxNbAttempts, mls, 1, matches, minMatchLen);\n}\n\n\nstatic U32 ZSTD_BtGetAllMatches_selectMLS_extDict (\n                        ZSTD_CCtx* zc,   /* Index table will be updated */\n                        const BYTE* ip, const BYTE* const iHighLimit,\n                        const U32 maxNbAttempts, const U32 matchLengthSearch, ZSTD_match_t* matches, const U32 minMatchLen)\n{\n    switch(matchLengthSearch)\n    {\n    case 3 : return ZSTD_BtGetAllMatches_extDict(zc, ip, iHighLimit, maxNbAttempts, 3, matches, minMatchLen);\n    default :\n    case 4 : return ZSTD_BtGetAllMatches_extDict(zc, ip, iHighLimit, maxNbAttempts, 4, matches, minMatchLen);\n    case 5 : return ZSTD_BtGetAllMatches_extDict(zc, ip, iHighLimit, maxNbAttempts, 5, matches, minMatchLen);\n    case 7 :\n    case 6 : return ZSTD_BtGetAllMatches_extDict(zc, ip, iHighLimit, maxNbAttempts, 6, matches, minMatchLen);\n    }\n}\n\n\n/*-*******************************\n*  Optimal parser\n*********************************/\nFORCE_INLINE_TEMPLATE\nsize_t ZSTD_compressBlock_opt_generic(ZSTD_CCtx* ctx,\n                                      const void* src, size_t srcSize, const int ultra)\n{\n    seqStore_t* seqStorePtr = &(ctx->seqStore);\n    optState_t* optStatePtr = &(ctx->optState);\n    const BYTE* const istart = (const BYTE*)src;\n    const BYTE* ip = istart;\n    const BYTE* anchor = istart;\n    const BYTE* const iend = istart + srcSize;\n    const BYTE* const ilimit = iend - 8;\n    const BYTE* const base = ctx->base;\n    const BYTE* const prefixStart = base + ctx->dictLimit;\n\n    const U32 maxSearches = 1U << ctx->appliedParams.cParams.searchLog;\n    const U32 sufficient_len = ctx->appliedParams.cParams.targetLength;\n    const U32 mls = ctx->appliedParams.cParams.searchLength;\n    const U32 minMatch = (ctx->appliedParams.cParams.searchLength == 3) ? 3 : 4;\n\n    ZSTD_optimal_t* opt = optStatePtr->priceTable;\n    ZSTD_match_t* matches = optStatePtr->matchTable;\n    const BYTE* inr;\n    U32 offset, rep[ZSTD_REP_NUM];\n\n    /* init */\n    ctx->nextToUpdate3 = ctx->nextToUpdate;\n    ZSTD_rescaleFreqs(optStatePtr, (const BYTE*)src, srcSize);\n    ip += (ip==prefixStart);\n    { U32 i; for (i=0; i<ZSTD_REP_NUM; i++) rep[i]=seqStorePtr->rep[i]; }\n\n    /* Match Loop */\n    while (ip < ilimit) {\n        U32 cur, match_num, last_pos, litlen, price;\n        U32 u, mlen, best_mlen, best_off, litLength;\n        memset(opt, 0, sizeof(ZSTD_optimal_t));\n        last_pos = 0;\n        litlen = (U32)(ip - anchor);\n\n        /* check repCode */\n        {   U32 i, last_i = ZSTD_REP_CHECK + (ip==anchor);\n            for (i=(ip == anchor); i<last_i; i++) {\n                const S32 repCur = (i==ZSTD_REP_MOVE_OPT) ? (rep[0] - 1) : rep[i];\n                if ( (repCur > 0) && (repCur < (S32)(ip-prefixStart))\n                    && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repCur, minMatch))) {\n                    mlen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repCur, iend) + minMatch;\n                    if (mlen > sufficient_len || mlen >= ZSTD_OPT_NUM) {\n                        best_mlen = mlen; best_off = i; cur = 0; last_pos = 1;\n                        goto _storeSequence;\n                    }\n                    best_off = i - (ip == anchor);\n                    do {\n                        price = ZSTD_getPrice(optStatePtr, litlen, anchor, best_off, mlen - MINMATCH, ultra);\n                        if (mlen > last_pos || price < opt[mlen].price)\n                            SET_PRICE(mlen, mlen, i, litlen, price);   /* note : macro modifies last_pos */\n                        mlen--;\n                    } while (mlen >= minMatch);\n        }   }   }\n\n        match_num = ZSTD_BtGetAllMatches_selectMLS(ctx, ip, iend, maxSearches, mls, matches, minMatch);\n\n        if (!last_pos && !match_num) { ip++; continue; }\n\n        if (match_num && (matches[match_num-1].len > sufficient_len || matches[match_num-1].len >= ZSTD_OPT_NUM)) {\n            best_mlen = matches[match_num-1].len;\n            best_off = matches[match_num-1].off;\n            cur = 0;\n            last_pos = 1;\n            goto _storeSequence;\n        }\n\n        /* set prices using matches at position = 0 */\n        best_mlen = (last_pos) ? last_pos : minMatch;\n        for (u = 0; u < match_num; u++) {\n            mlen = (u>0) ? matches[u-1].len+1 : best_mlen;\n            best_mlen = matches[u].len;\n            while (mlen <= best_mlen) {\n                price = ZSTD_getPrice(optStatePtr, litlen, anchor, matches[u].off-1, mlen - MINMATCH, ultra);\n                if (mlen > last_pos || price < opt[mlen].price)\n                    SET_PRICE(mlen, mlen, matches[u].off, litlen, price);   /* note : macro modifies last_pos */\n                mlen++;\n        }   }\n\n        if (last_pos < minMatch) { ip++; continue; }\n\n        /* initialize opt[0] */\n        { U32 i ; for (i=0; i<ZSTD_REP_NUM; i++) opt[0].rep[i] = rep[i]; }\n        opt[0].mlen = 1;\n        opt[0].litlen = litlen;\n\n         /* check further positions */\n        for (cur = 1; cur <= last_pos; cur++) {\n           inr = ip + cur;\n\n           if (opt[cur-1].mlen == 1) {\n                litlen = opt[cur-1].litlen + 1;\n                if (cur > litlen) {\n                    price = opt[cur - litlen].price + ZSTD_getLiteralPrice(optStatePtr, litlen, inr-litlen);\n                } else\n                    price = ZSTD_getLiteralPrice(optStatePtr, litlen, anchor);\n           } else {\n                litlen = 1;\n                price = opt[cur - 1].price + ZSTD_getLiteralPrice(optStatePtr, litlen, inr-1);\n           }\n\n           if (cur > last_pos || price <= opt[cur].price)\n                SET_PRICE(cur, 1, 0, litlen, price);\n\n           if (cur == last_pos) break;\n\n           if (inr > ilimit)  /* last match must start at a minimum distance of 8 from oend */\n               continue;\n\n           mlen = opt[cur].mlen;\n           if (opt[cur].off > ZSTD_REP_MOVE_OPT) {\n                opt[cur].rep[2] = opt[cur-mlen].rep[1];\n                opt[cur].rep[1] = opt[cur-mlen].rep[0];\n                opt[cur].rep[0] = opt[cur].off - ZSTD_REP_MOVE_OPT;\n           } else {\n                opt[cur].rep[2] = (opt[cur].off > 1) ? opt[cur-mlen].rep[1] : opt[cur-mlen].rep[2];\n                opt[cur].rep[1] = (opt[cur].off > 0) ? opt[cur-mlen].rep[0] : opt[cur-mlen].rep[1];\n                opt[cur].rep[0] = ((opt[cur].off==ZSTD_REP_MOVE_OPT) && (mlen != 1)) ? (opt[cur-mlen].rep[0] - 1) : (opt[cur-mlen].rep[opt[cur].off]);\n           }\n\n            best_mlen = minMatch;\n            {   U32 i, last_i = ZSTD_REP_CHECK + (mlen != 1);\n                for (i=(opt[cur].mlen != 1); i<last_i; i++) {  /* check rep */\n                    const S32 repCur = (i==ZSTD_REP_MOVE_OPT) ? (opt[cur].rep[0] - 1) : opt[cur].rep[i];\n                    if ( (repCur > 0) && (repCur < (S32)(inr-prefixStart))\n                       && (ZSTD_readMINMATCH(inr, minMatch) == ZSTD_readMINMATCH(inr - repCur, minMatch))) {\n                       mlen = (U32)ZSTD_count(inr+minMatch, inr+minMatch - repCur, iend) + minMatch;\n\n                       if (mlen > sufficient_len || cur + mlen >= ZSTD_OPT_NUM) {\n                            best_mlen = mlen; best_off = i; last_pos = cur + 1;\n                            goto _storeSequence;\n                       }\n\n                       best_off = i - (opt[cur].mlen != 1);\n                       if (mlen > best_mlen) best_mlen = mlen;\n\n                       do {\n                           if (opt[cur].mlen == 1) {\n                                litlen = opt[cur].litlen;\n                                if (cur > litlen) {\n                                    price = opt[cur - litlen].price + ZSTD_getPrice(optStatePtr, litlen, inr-litlen, best_off, mlen - MINMATCH, ultra);\n                                } else\n                                    price = ZSTD_getPrice(optStatePtr, litlen, anchor, best_off, mlen - MINMATCH, ultra);\n                            } else {\n                                litlen = 0;\n                                price = opt[cur].price + ZSTD_getPrice(optStatePtr, 0, NULL, best_off, mlen - MINMATCH, ultra);\n                            }\n\n                            if (cur + mlen > last_pos || price <= opt[cur + mlen].price)\n                                SET_PRICE(cur + mlen, mlen, i, litlen, price);\n                            mlen--;\n                        } while (mlen >= minMatch);\n            }   }   }\n\n            match_num = ZSTD_BtGetAllMatches_selectMLS(ctx, inr, iend, maxSearches, mls, matches, best_mlen);\n\n            if (match_num > 0 && (matches[match_num-1].len > sufficient_len || cur + matches[match_num-1].len >= ZSTD_OPT_NUM)) {\n                best_mlen = matches[match_num-1].len;\n                best_off = matches[match_num-1].off;\n                last_pos = cur + 1;\n                goto _storeSequence;\n            }\n\n            /* set prices using matches at position = cur */\n            for (u = 0; u < match_num; u++) {\n                mlen = (u>0) ? matches[u-1].len+1 : best_mlen;\n                best_mlen = matches[u].len;\n\n                while (mlen <= best_mlen) {\n                    if (opt[cur].mlen == 1) {\n                        litlen = opt[cur].litlen;\n                        if (cur > litlen)\n                            price = opt[cur - litlen].price + ZSTD_getPrice(optStatePtr, litlen, ip+cur-litlen, matches[u].off-1, mlen - MINMATCH, ultra);\n                        else\n                            price = ZSTD_getPrice(optStatePtr, litlen, anchor, matches[u].off-1, mlen - MINMATCH, ultra);\n                    } else {\n                        litlen = 0;\n                        price = opt[cur].price + ZSTD_getPrice(optStatePtr, 0, NULL, matches[u].off-1, mlen - MINMATCH, ultra);\n                    }\n\n                    if (cur + mlen > last_pos || (price < opt[cur + mlen].price))\n                        SET_PRICE(cur + mlen, mlen, matches[u].off, litlen, price);\n\n                    mlen++;\n        }   }   }\n\n        best_mlen = opt[last_pos].mlen;\n        best_off = opt[last_pos].off;\n        cur = last_pos - best_mlen;\n\n        /* store sequence */\n_storeSequence:   /* cur, last_pos, best_mlen, best_off have to be set */\n        opt[0].mlen = 1;\n\n        while (1) {\n            mlen = opt[cur].mlen;\n            offset = opt[cur].off;\n            opt[cur].mlen = best_mlen;\n            opt[cur].off = best_off;\n            best_mlen = mlen;\n            best_off = offset;\n            if (mlen > cur) break;\n            cur -= mlen;\n        }\n\n        for (u = 0; u <= last_pos;) {\n            u += opt[u].mlen;\n        }\n\n        for (cur=0; cur < last_pos; ) {\n            mlen = opt[cur].mlen;\n            if (mlen == 1) { ip++; cur++; continue; }\n            offset = opt[cur].off;\n            cur += mlen;\n            litLength = (U32)(ip - anchor);\n\n            if (offset > ZSTD_REP_MOVE_OPT) {\n                rep[2] = rep[1];\n                rep[1] = rep[0];\n                rep[0] = offset - ZSTD_REP_MOVE_OPT;\n                offset--;\n            } else {\n                if (offset != 0) {\n                    best_off = (offset==ZSTD_REP_MOVE_OPT) ? (rep[0] - 1) : (rep[offset]);\n                    if (offset != 1) rep[2] = rep[1];\n                    rep[1] = rep[0];\n                    rep[0] = best_off;\n                }\n                if (litLength==0) offset--;\n            }\n\n            ZSTD_updatePrice(optStatePtr, litLength, anchor, offset, mlen-MINMATCH);\n            ZSTD_storeSeq(seqStorePtr, litLength, anchor, offset, mlen-MINMATCH);\n            anchor = ip = ip + mlen;\n    }    }   /* for (cur=0; cur < last_pos; ) */\n\n    /* Save reps for next block */\n    { int i; for (i=0; i<ZSTD_REP_NUM; i++) seqStorePtr->repToConfirm[i] = rep[i]; }\n\n    /* Return the last literals size */\n    return iend - anchor;\n}\n\n\nFORCE_INLINE_TEMPLATE\nsize_t ZSTD_compressBlock_opt_extDict_generic(ZSTD_CCtx* ctx,\n                                     const void* src, size_t srcSize, const int ultra)\n{\n    seqStore_t* seqStorePtr = &(ctx->seqStore);\n    optState_t* optStatePtr = &(ctx->optState);\n    const BYTE* const istart = (const BYTE*)src;\n    const BYTE* ip = istart;\n    const BYTE* anchor = istart;\n    const BYTE* const iend = istart + srcSize;\n    const BYTE* const ilimit = iend - 8;\n    const BYTE* const base = ctx->base;\n    const U32 lowestIndex = ctx->lowLimit;\n    const U32 dictLimit = ctx->dictLimit;\n    const BYTE* const prefixStart = base + dictLimit;\n    const BYTE* const dictBase = ctx->dictBase;\n    const BYTE* const dictEnd  = dictBase + dictLimit;\n\n    const U32 maxSearches = 1U << ctx->appliedParams.cParams.searchLog;\n    const U32 sufficient_len = ctx->appliedParams.cParams.targetLength;\n    const U32 mls = ctx->appliedParams.cParams.searchLength;\n    const U32 minMatch = (ctx->appliedParams.cParams.searchLength == 3) ? 3 : 4;\n\n    ZSTD_optimal_t* opt = optStatePtr->priceTable;\n    ZSTD_match_t* matches = optStatePtr->matchTable;\n    const BYTE* inr;\n\n    /* init */\n    U32 offset, rep[ZSTD_REP_NUM];\n    { U32 i; for (i=0; i<ZSTD_REP_NUM; i++) rep[i]=seqStorePtr->rep[i]; }\n\n    ctx->nextToUpdate3 = ctx->nextToUpdate;\n    ZSTD_rescaleFreqs(optStatePtr, (const BYTE*)src, srcSize);\n    ip += (ip==prefixStart);\n\n    /* Match Loop */\n    while (ip < ilimit) {\n        U32 cur, match_num, last_pos, litlen, price;\n        U32 u, mlen, best_mlen, best_off, litLength;\n        U32 current = (U32)(ip-base);\n        memset(opt, 0, sizeof(ZSTD_optimal_t));\n        last_pos = 0;\n        opt[0].litlen = (U32)(ip - anchor);\n\n        /* check repCode */\n        {   U32 i, last_i = ZSTD_REP_CHECK + (ip==anchor);\n            for (i = (ip==anchor); i<last_i; i++) {\n                const S32 repCur = (i==ZSTD_REP_MOVE_OPT) ? (rep[0] - 1) : rep[i];\n                const U32 repIndex = (U32)(current - repCur);\n                const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;\n                const BYTE* const repMatch = repBase + repIndex;\n                if ( (repCur > 0 && repCur <= (S32)current)\n                   && (((U32)((dictLimit-1) - repIndex) >= 3) & (repIndex>lowestIndex))  /* intentional overflow */\n                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {\n                    /* repcode detected we should take it */\n                    const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;\n                    mlen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iend, repEnd, prefixStart) + minMatch;\n\n                    if (mlen > sufficient_len || mlen >= ZSTD_OPT_NUM) {\n                        best_mlen = mlen; best_off = i; cur = 0; last_pos = 1;\n                        goto _storeSequence;\n                    }\n\n                    best_off = i - (ip==anchor);\n                    litlen = opt[0].litlen;\n                    do {\n                        price = ZSTD_getPrice(optStatePtr, litlen, anchor, best_off, mlen - MINMATCH, ultra);\n                        if (mlen > last_pos || price < opt[mlen].price)\n                            SET_PRICE(mlen, mlen, i, litlen, price);   /* note : macro modifies last_pos */\n                        mlen--;\n                    } while (mlen >= minMatch);\n        }   }   }\n\n        match_num = ZSTD_BtGetAllMatches_selectMLS_extDict(ctx, ip, iend, maxSearches, mls, matches, minMatch);  /* first search (depth 0) */\n\n        if (!last_pos && !match_num) { ip++; continue; }\n\n        { U32 i; for (i=0; i<ZSTD_REP_NUM; i++) opt[0].rep[i] = rep[i]; }\n        opt[0].mlen = 1;\n\n        if (match_num && (matches[match_num-1].len > sufficient_len || matches[match_num-1].len >= ZSTD_OPT_NUM)) {\n            best_mlen = matches[match_num-1].len;\n            best_off = matches[match_num-1].off;\n            cur = 0;\n            last_pos = 1;\n            goto _storeSequence;\n        }\n\n        best_mlen = (last_pos) ? last_pos : minMatch;\n\n        /* set prices using matches at position = 0 */\n        for (u = 0; u < match_num; u++) {\n            mlen = (u>0) ? matches[u-1].len+1 : best_mlen;\n            best_mlen = matches[u].len;\n            litlen = opt[0].litlen;\n            while (mlen <= best_mlen) {\n                price = ZSTD_getPrice(optStatePtr, litlen, anchor, matches[u].off-1, mlen - MINMATCH, ultra);\n                if (mlen > last_pos || price < opt[mlen].price)\n                    SET_PRICE(mlen, mlen, matches[u].off, litlen, price);\n                mlen++;\n        }   }\n\n        if (last_pos < minMatch) {\n            ip++; continue;\n        }\n\n        /* check further positions */\n        for (cur = 1; cur <= last_pos; cur++) {\n            inr = ip + cur;\n\n            if (opt[cur-1].mlen == 1) {\n                litlen = opt[cur-1].litlen + 1;\n                if (cur > litlen) {\n                    price = opt[cur - litlen].price + ZSTD_getLiteralPrice(optStatePtr, litlen, inr-litlen);\n                } else\n                    price = ZSTD_getLiteralPrice(optStatePtr, litlen, anchor);\n            } else {\n                litlen = 1;\n                price = opt[cur - 1].price + ZSTD_getLiteralPrice(optStatePtr, litlen, inr-1);\n            }\n\n            if (cur > last_pos || price <= opt[cur].price)\n                SET_PRICE(cur, 1, 0, litlen, price);\n\n            if (cur == last_pos) break;\n\n            if (inr > ilimit)  /* last match must start at a minimum distance of 8 from oend */\n                continue;\n\n            mlen = opt[cur].mlen;\n            if (opt[cur].off > ZSTD_REP_MOVE_OPT) {\n                opt[cur].rep[2] = opt[cur-mlen].rep[1];\n                opt[cur].rep[1] = opt[cur-mlen].rep[0];\n                opt[cur].rep[0] = opt[cur].off - ZSTD_REP_MOVE_OPT;\n            } else {\n                opt[cur].rep[2] = (opt[cur].off > 1) ? opt[cur-mlen].rep[1] : opt[cur-mlen].rep[2];\n                opt[cur].rep[1] = (opt[cur].off > 0) ? opt[cur-mlen].rep[0] : opt[cur-mlen].rep[1];\n                opt[cur].rep[0] = ((opt[cur].off==ZSTD_REP_MOVE_OPT) && (mlen != 1)) ? (opt[cur-mlen].rep[0] - 1) : (opt[cur-mlen].rep[opt[cur].off]);\n            }\n\n            best_mlen = minMatch;\n            {   U32 i, last_i = ZSTD_REP_CHECK + (mlen != 1);\n                for (i = (mlen != 1); i<last_i; i++) {\n                    const S32 repCur = (i==ZSTD_REP_MOVE_OPT) ? (opt[cur].rep[0] - 1) : opt[cur].rep[i];\n                    const U32 repIndex = (U32)(current+cur - repCur);\n                    const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;\n                    const BYTE* const repMatch = repBase + repIndex;\n                    if ( (repCur > 0 && repCur <= (S32)(current+cur))\n                      && (((U32)((dictLimit-1) - repIndex) >= 3) & (repIndex>lowestIndex))  /* intentional overflow */\n                      && (ZSTD_readMINMATCH(inr, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {\n                        /* repcode detected */\n                        const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;\n                        mlen = (U32)ZSTD_count_2segments(inr+minMatch, repMatch+minMatch, iend, repEnd, prefixStart) + minMatch;\n\n                        if (mlen > sufficient_len || cur + mlen >= ZSTD_OPT_NUM) {\n                            best_mlen = mlen; best_off = i; last_pos = cur + 1;\n                            goto _storeSequence;\n                        }\n\n                        best_off = i - (opt[cur].mlen != 1);\n                        if (mlen > best_mlen) best_mlen = mlen;\n\n                        do {\n                            if (opt[cur].mlen == 1) {\n                                litlen = opt[cur].litlen;\n                                if (cur > litlen) {\n                                    price = opt[cur - litlen].price + ZSTD_getPrice(optStatePtr, litlen, inr-litlen, best_off, mlen - MINMATCH, ultra);\n                                } else\n                                    price = ZSTD_getPrice(optStatePtr, litlen, anchor, best_off, mlen - MINMATCH, ultra);\n                            } else {\n                                litlen = 0;\n                                price = opt[cur].price + ZSTD_getPrice(optStatePtr, 0, NULL, best_off, mlen - MINMATCH, ultra);\n                            }\n\n                            if (cur + mlen > last_pos || price <= opt[cur + mlen].price)\n                                SET_PRICE(cur + mlen, mlen, i, litlen, price);\n                            mlen--;\n                        } while (mlen >= minMatch);\n            }   }   }\n\n            match_num = ZSTD_BtGetAllMatches_selectMLS_extDict(ctx, inr, iend, maxSearches, mls, matches, minMatch);\n\n            if (match_num > 0 && (matches[match_num-1].len > sufficient_len || cur + matches[match_num-1].len >= ZSTD_OPT_NUM)) {\n                best_mlen = matches[match_num-1].len;\n                best_off = matches[match_num-1].off;\n                last_pos = cur + 1;\n                goto _storeSequence;\n            }\n\n            /* set prices using matches at position = cur */\n            for (u = 0; u < match_num; u++) {\n                mlen = (u>0) ? matches[u-1].len+1 : best_mlen;\n                best_mlen = matches[u].len;\n\n                while (mlen <= best_mlen) {\n                    if (opt[cur].mlen == 1) {\n                        litlen = opt[cur].litlen;\n                        if (cur > litlen)\n                            price = opt[cur - litlen].price + ZSTD_getPrice(optStatePtr, litlen, ip+cur-litlen, matches[u].off-1, mlen - MINMATCH, ultra);\n                        else\n                            price = ZSTD_getPrice(optStatePtr, litlen, anchor, matches[u].off-1, mlen - MINMATCH, ultra);\n                    } else {\n                        litlen = 0;\n                        price = opt[cur].price + ZSTD_getPrice(optStatePtr, 0, NULL, matches[u].off-1, mlen - MINMATCH, ultra);\n                    }\n\n                    if (cur + mlen > last_pos || (price < opt[cur + mlen].price))\n                        SET_PRICE(cur + mlen, mlen, matches[u].off, litlen, price);\n\n                    mlen++;\n        }   }   }   /* for (cur = 1; cur <= last_pos; cur++) */\n\n        best_mlen = opt[last_pos].mlen;\n        best_off = opt[last_pos].off;\n        cur = last_pos - best_mlen;\n\n        /* store sequence */\n_storeSequence:   /* cur, last_pos, best_mlen, best_off have to be set */\n        opt[0].mlen = 1;\n\n        while (1) {\n            mlen = opt[cur].mlen;\n            offset = opt[cur].off;\n            opt[cur].mlen = best_mlen;\n            opt[cur].off = best_off;\n            best_mlen = mlen;\n            best_off = offset;\n            if (mlen > cur) break;\n            cur -= mlen;\n        }\n\n        for (u = 0; u <= last_pos; ) {\n            u += opt[u].mlen;\n        }\n\n        for (cur=0; cur < last_pos; ) {\n            mlen = opt[cur].mlen;\n            if (mlen == 1) { ip++; cur++; continue; }\n            offset = opt[cur].off;\n            cur += mlen;\n            litLength = (U32)(ip - anchor);\n\n            if (offset > ZSTD_REP_MOVE_OPT) {\n                rep[2] = rep[1];\n                rep[1] = rep[0];\n                rep[0] = offset - ZSTD_REP_MOVE_OPT;\n                offset--;\n            } else {\n                if (offset != 0) {\n                    best_off = (offset==ZSTD_REP_MOVE_OPT) ? (rep[0] - 1) : (rep[offset]);\n                    if (offset != 1) rep[2] = rep[1];\n                    rep[1] = rep[0];\n                    rep[0] = best_off;\n                }\n\n                if (litLength==0) offset--;\n            }\n\n            ZSTD_updatePrice(optStatePtr, litLength, anchor, offset, mlen-MINMATCH);\n            ZSTD_storeSeq(seqStorePtr, litLength, anchor, offset, mlen-MINMATCH);\n            anchor = ip = ip + mlen;\n    }    }   /* for (cur=0; cur < last_pos; ) */\n\n    /* Save reps for next block */\n    { int i; for (i=0; i<ZSTD_REP_NUM; i++) seqStorePtr->repToConfirm[i] = rep[i]; }\n\n    /* Return the last literals size */\n    return iend - anchor;",
        "b_contents": "#if defined (__cplusplus)",
        "base_contents": "#define ZSTD_LITFREQ_ADD    2\n#define ZSTD_FREQ_DIV       4\n#define ZSTD_MAX_PRICE      (1<<30)\n\n/*-*************************************\n*  Price functions for optimal parser\n***************************************/\nstatic void ZSTD_setLog2Prices(optState_t* optPtr)\n{\n    optPtr->log2matchLengthSum = ZSTD_highbit32(optPtr->matchLengthSum+1);\n    optPtr->log2litLengthSum = ZSTD_highbit32(optPtr->litLengthSum+1);\n    optPtr->log2litSum = ZSTD_highbit32(optPtr->litSum+1);\n    optPtr->log2offCodeSum = ZSTD_highbit32(optPtr->offCodeSum+1);\n    optPtr->factor = 1 + ((optPtr->litSum>>5) / optPtr->litLengthSum) + ((optPtr->litSum<<1) / (optPtr->litSum + optPtr->matchSum));\n}\n\n\nstatic void ZSTD_rescaleFreqs(optState_t* optPtr, const BYTE* src, size_t srcSize)\n{\n    unsigned u;\n\n    optPtr->cachedLiterals = NULL;\n    optPtr->cachedPrice = optPtr->cachedLitLength = 0;\n    optPtr->staticPrices = 0;\n\n    if (optPtr->litLengthSum == 0) {\n        if (srcSize <= 1024) optPtr->staticPrices = 1;\n\n        assert(optPtr->litFreq!=NULL);\n        for (u=0; u<=MaxLit; u++)\n            optPtr->litFreq[u] = 0;\n        for (u=0; u<srcSize; u++)\n            optPtr->litFreq[src[u]]++;\n\n        optPtr->litSum = 0;\n        optPtr->litLengthSum = MaxLL+1;\n        optPtr->matchLengthSum = MaxML+1;\n        optPtr->offCodeSum = (MaxOff+1);\n        optPtr->matchSum = (ZSTD_LITFREQ_ADD<<Litbits);\n\n        for (u=0; u<=MaxLit; u++) {\n            optPtr->litFreq[u] = 1 + (optPtr->litFreq[u]>>ZSTD_FREQ_DIV);\n            optPtr->litSum += optPtr->litFreq[u];\n        }\n        for (u=0; u<=MaxLL; u++)\n            optPtr->litLengthFreq[u] = 1;\n        for (u=0; u<=MaxML; u++)\n            optPtr->matchLengthFreq[u] = 1;\n        for (u=0; u<=MaxOff; u++)\n            optPtr->offCodeFreq[u] = 1;\n    } else {\n        optPtr->matchLengthSum = 0;\n        optPtr->litLengthSum = 0;\n        optPtr->offCodeSum = 0;\n        optPtr->matchSum = 0;\n        optPtr->litSum = 0;\n\n        for (u=0; u<=MaxLit; u++) {\n            optPtr->litFreq[u] = 1 + (optPtr->litFreq[u]>>(ZSTD_FREQ_DIV+1));\n            optPtr->litSum += optPtr->litFreq[u];\n        }\n        for (u=0; u<=MaxLL; u++) {\n            optPtr->litLengthFreq[u] = 1 + (optPtr->litLengthFreq[u]>>(ZSTD_FREQ_DIV+1));\n            optPtr->litLengthSum += optPtr->litLengthFreq[u];\n        }\n        for (u=0; u<=MaxML; u++) {\n            optPtr->matchLengthFreq[u] = 1 + (optPtr->matchLengthFreq[u]>>ZSTD_FREQ_DIV);\n            optPtr->matchLengthSum += optPtr->matchLengthFreq[u];\n            optPtr->matchSum += optPtr->matchLengthFreq[u] * (u + 3);\n        }\n        optPtr->matchSum *= ZSTD_LITFREQ_ADD;\n        for (u=0; u<=MaxOff; u++) {\n            optPtr->offCodeFreq[u] = 1 + (optPtr->offCodeFreq[u]>>ZSTD_FREQ_DIV);\n            optPtr->offCodeSum += optPtr->offCodeFreq[u];\n        }\n    }\n\n    ZSTD_setLog2Prices(optPtr);\n}\n\n\nstatic U32 ZSTD_getLiteralPrice(optState_t* optPtr, U32 litLength, const BYTE* literals)\n{\n    U32 price, u;\n\n    if (optPtr->staticPrices)\n        return ZSTD_highbit32((U32)litLength+1) + (litLength*6);\n\n    if (litLength == 0)\n        return optPtr->log2litLengthSum - ZSTD_highbit32(optPtr->litLengthFreq[0]+1);\n\n    /* literals */\n    if (optPtr->cachedLiterals == literals) {\n        U32 const additional = litLength - optPtr->cachedLitLength;\n        const BYTE* literals2 = optPtr->cachedLiterals + optPtr->cachedLitLength;\n        price = optPtr->cachedPrice + additional * optPtr->log2litSum;\n        for (u=0; u < additional; u++)\n            price -= ZSTD_highbit32(optPtr->litFreq[literals2[u]]+1);\n        optPtr->cachedPrice = price;\n        optPtr->cachedLitLength = litLength;\n    } else {\n        price = litLength * optPtr->log2litSum;\n        for (u=0; u < litLength; u++)\n            price -= ZSTD_highbit32(optPtr->litFreq[literals[u]]+1);\n\n        if (litLength >= 12) {\n            optPtr->cachedLiterals = literals;\n            optPtr->cachedPrice = price;\n            optPtr->cachedLitLength = litLength;\n        }\n    }\n\n    /* literal Length */\n    {   const BYTE LL_deltaCode = 19;\n        const BYTE llCode = (litLength>63) ? (BYTE)ZSTD_highbit32(litLength) + LL_deltaCode : LL_Code[litLength];\n        price += LL_bits[llCode] + optPtr->log2litLengthSum - ZSTD_highbit32(optPtr->litLengthFreq[llCode]+1);\n    }\n\n    return price;\n}\n\n\nFORCE_INLINE_TEMPLATE U32 ZSTD_getPrice(optState_t* optPtr, U32 litLength, const BYTE* literals, U32 offset, U32 matchLength, const int ultra)\n{\n    /* offset */\n    U32 price;\n    BYTE const offCode = (BYTE)ZSTD_highbit32(offset+1);\n\n    if (optPtr->staticPrices)\n        return ZSTD_getLiteralPrice(optPtr, litLength, literals) + ZSTD_highbit32((U32)matchLength+1) + 16 + offCode;\n\n    price = offCode + optPtr->log2offCodeSum - ZSTD_highbit32(optPtr->offCodeFreq[offCode]+1);\n    if (!ultra && offCode >= 20) price += (offCode-19)*2;\n\n    /* match Length */\n    {   const BYTE ML_deltaCode = 36;\n        const BYTE mlCode = (matchLength>127) ? (BYTE)ZSTD_highbit32(matchLength) + ML_deltaCode : ML_Code[matchLength];\n        price += ML_bits[mlCode] + optPtr->log2matchLengthSum - ZSTD_highbit32(optPtr->matchLengthFreq[mlCode]+1);\n    }\n\n    return price + ZSTD_getLiteralPrice(optPtr, litLength, literals) + optPtr->factor;\n}\n\n\nstatic void ZSTD_updatePrice(optState_t* optPtr, U32 litLength, const BYTE* literals, U32 offset, U32 matchLength)\n{\n    U32 u;\n\n    /* literals */\n    optPtr->litSum += litLength*ZSTD_LITFREQ_ADD;\n    for (u=0; u < litLength; u++)\n        optPtr->litFreq[literals[u]] += ZSTD_LITFREQ_ADD;\n\n    /* literal Length */\n    {   const BYTE LL_deltaCode = 19;\n        const BYTE llCode = (litLength>63) ? (BYTE)ZSTD_highbit32(litLength) + LL_deltaCode : LL_Code[litLength];\n        optPtr->litLengthFreq[llCode]++;\n        optPtr->litLengthSum++;\n    }\n\n    /* match offset */\n    {   BYTE const offCode = (BYTE)ZSTD_highbit32(offset+1);\n        optPtr->offCodeSum++;\n        optPtr->offCodeFreq[offCode]++;\n    }\n\n    /* match Length */\n    {   const BYTE ML_deltaCode = 36;\n        const BYTE mlCode = (matchLength>127) ? (BYTE)ZSTD_highbit32(matchLength) + ML_deltaCode : ML_Code[matchLength];\n        optPtr->matchLengthFreq[mlCode]++;\n        optPtr->matchLengthSum++;\n    }\n\n    ZSTD_setLog2Prices(optPtr);\n}\n\n\n#define SET_PRICE(pos, mlen_, offset_, litlen_, price_)   \\\n    {                                                 \\\n        while (last_pos < pos)  { opt[last_pos+1].price = ZSTD_MAX_PRICE; last_pos++; } \\\n        opt[pos].mlen = mlen_;                         \\\n        opt[pos].off = offset_;                        \\\n        opt[pos].litlen = litlen_;                     \\\n        opt[pos].price = price_;                       \\\n    }\n\n\n/* function safe only for comparisons */\nstatic U32 ZSTD_readMINMATCH(const void* memPtr, U32 length)\n{\n    switch (length)\n    {\n    default :\n    case 4 : return MEM_read32(memPtr);\n    case 3 : if (MEM_isLittleEndian())\n                return MEM_read32(memPtr)<<8;\n             else\n                return MEM_read32(memPtr)>>8;\n    }\n}\n\n\n/* Update hashTable3 up to ip (excluded)\n   Assumption : always within prefix (i.e. not within extDict) */\nstatic\nU32 ZSTD_insertAndFindFirstIndexHash3 (ZSTD_CCtx* zc, const BYTE* ip)\n{\n    U32* const hashTable3  = zc->hashTable3;\n    U32 const hashLog3  = zc->hashLog3;\n    const BYTE* const base = zc->base;\n    U32 idx = zc->nextToUpdate3;\n    const U32 target = zc->nextToUpdate3 = (U32)(ip - base);\n    const size_t hash3 = ZSTD_hash3Ptr(ip, hashLog3);\n\n    while(idx < target) {\n        hashTable3[ZSTD_hash3Ptr(base+idx, hashLog3)] = idx;\n        idx++;\n    }\n\n    return hashTable3[hash3];\n}\n\n\n/*-*************************************\n*  Binary Tree search\n***************************************/\nstatic U32 ZSTD_insertBtAndGetAllMatches (\n                        ZSTD_CCtx* zc,\n                        const BYTE* const ip, const BYTE* const iLimit,\n                        U32 nbCompares, const U32 mls,\n                        U32 extDict, ZSTD_match_t* matches, const U32 minMatchLen)\n{\n    const BYTE* const base = zc->base;\n    const U32 current = (U32)(ip-base);\n    const U32 hashLog = zc->appliedParams.cParams.hashLog;\n    const size_t h  = ZSTD_hashPtr(ip, hashLog, mls);\n    U32* const hashTable = zc->hashTable;\n    U32 matchIndex  = hashTable[h];\n    U32* const bt   = zc->chainTable;\n    const U32 btLog = zc->appliedParams.cParams.chainLog - 1;\n    const U32 btMask= (1U << btLog) - 1;\n    size_t commonLengthSmaller=0, commonLengthLarger=0;\n    const BYTE* const dictBase = zc->dictBase;\n    const U32 dictLimit = zc->dictLimit;\n    const BYTE* const dictEnd = dictBase + dictLimit;\n    const BYTE* const prefixStart = base + dictLimit;\n    const U32 btLow = btMask >= current ? 0 : current - btMask;\n    const U32 windowLow = zc->lowLimit;\n    U32* smallerPtr = bt + 2*(current&btMask);\n    U32* largerPtr  = bt + 2*(current&btMask) + 1;\n    U32 matchEndIdx = current+8;\n    U32 dummy32;   /* to be nullified at the end */\n    U32 mnum = 0;\n\n    const U32 minMatch = (mls == 3) ? 3 : 4;\n    size_t bestLength = minMatchLen-1;\n\n    if (minMatch == 3) { /* HC3 match finder */\n        U32 const matchIndex3 = ZSTD_insertAndFindFirstIndexHash3 (zc, ip);\n        if (matchIndex3>windowLow && (current - matchIndex3 < (1<<18))) {\n            const BYTE* match;\n            size_t currentMl=0;\n            if ((!extDict) || matchIndex3 >= dictLimit) {\n                match = base + matchIndex3;\n                if (match[bestLength] == ip[bestLength]) currentMl = ZSTD_count(ip, match, iLimit);\n            } else {\n                match = dictBase + matchIndex3;\n                if (ZSTD_readMINMATCH(match, MINMATCH) == ZSTD_readMINMATCH(ip, MINMATCH))    /* assumption : matchIndex3 <= dictLimit-4 (by table construction) */\n                    currentMl = ZSTD_count_2segments(ip+MINMATCH, match+MINMATCH, iLimit, dictEnd, prefixStart) + MINMATCH;\n            }\n\n            /* save best solution */\n            if (currentMl > bestLength) {\n                bestLength = currentMl;\n                matches[mnum].off = ZSTD_REP_MOVE_OPT + current - matchIndex3;\n                matches[mnum].len = (U32)currentMl;\n                mnum++;\n                if (currentMl > ZSTD_OPT_NUM) goto update;\n                if (ip+currentMl == iLimit) goto update; /* best possible, and avoid read overflow*/\n            }\n        }\n    }\n\n    hashTable[h] = current;   /* Update Hash Table */\n\n    while (nbCompares-- && (matchIndex > windowLow)) {\n        U32* nextPtr = bt + 2*(matchIndex & btMask);\n        size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */\n        const BYTE* match;\n\n        if ((!extDict) || (matchIndex+matchLength >= dictLimit)) {\n            match = base + matchIndex;\n            if (match[matchLength] == ip[matchLength]) {\n                matchLength += ZSTD_count(ip+matchLength+1, match+matchLength+1, iLimit) +1;\n            }\n        } else {\n            match = dictBase + matchIndex;\n            matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);\n            if (matchIndex+matchLength >= dictLimit)\n                match = base + matchIndex;   /* to prepare for next usage of match[matchLength] */\n        }\n\n        if (matchLength > bestLength) {\n            if (matchLength > matchEndIdx - matchIndex) matchEndIdx = matchIndex + (U32)matchLength;\n            bestLength = matchLength;\n            matches[mnum].off = ZSTD_REP_MOVE_OPT + current - matchIndex;\n            matches[mnum].len = (U32)matchLength;\n            mnum++;\n            if (matchLength > ZSTD_OPT_NUM) break;\n            if (ip+matchLength == iLimit)   /* equal : no way to know if inf or sup */\n                break;   /* drop, to guarantee consistency (miss a little bit of compression) */\n        }\n\n        if (match[matchLength] < ip[matchLength]) {\n            /* match is smaller than current */\n            *smallerPtr = matchIndex;             /* update smaller idx */\n            commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */\n            if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */\n            smallerPtr = nextPtr+1;               /* new \"smaller\" => larger of match */\n            matchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */\n        } else {\n            /* match is larger than current */\n            *largerPtr = matchIndex;\n            commonLengthLarger = matchLength;\n            if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */\n            largerPtr = nextPtr;\n            matchIndex = nextPtr[0];\n    }   }\n\n    *smallerPtr = *largerPtr = 0;\n\nupdate:\n    zc->nextToUpdate = (matchEndIdx > current + 8) ? matchEndIdx - 8 : current+1;\n    return mnum;\n}\n\n\n/** Tree updater, providing best match */\nstatic U32 ZSTD_BtGetAllMatches (\n                        ZSTD_CCtx* zc,\n                        const BYTE* const ip, const BYTE* const iLimit,\n                        const U32 maxNbAttempts, const U32 mls, ZSTD_match_t* matches, const U32 minMatchLen)\n{\n    if (ip < zc->base + zc->nextToUpdate) return 0;   /* skipped area */\n    ZSTD_updateTree(zc, ip, iLimit, maxNbAttempts, mls);\n    return ZSTD_insertBtAndGetAllMatches(zc, ip, iLimit, maxNbAttempts, mls, 0, matches, minMatchLen);\n}\n\n\nstatic U32 ZSTD_BtGetAllMatches_selectMLS (\n                        ZSTD_CCtx* zc,   /* Index table will be updated */\n                        const BYTE* ip, const BYTE* const iHighLimit,\n                        const U32 maxNbAttempts, const U32 matchLengthSearch, ZSTD_match_t* matches, const U32 minMatchLen)\n{\n    switch(matchLengthSearch)\n    {\n    case 3 : return ZSTD_BtGetAllMatches(zc, ip, iHighLimit, maxNbAttempts, 3, matches, minMatchLen);\n    default :\n    case 4 : return ZSTD_BtGetAllMatches(zc, ip, iHighLimit, maxNbAttempts, 4, matches, minMatchLen);\n    case 5 : return ZSTD_BtGetAllMatches(zc, ip, iHighLimit, maxNbAttempts, 5, matches, minMatchLen);\n    case 7 :\n    case 6 : return ZSTD_BtGetAllMatches(zc, ip, iHighLimit, maxNbAttempts, 6, matches, minMatchLen);\n    }\n}\n\n/** Tree updater, providing best match */\nstatic U32 ZSTD_BtGetAllMatches_extDict (\n                        ZSTD_CCtx* zc,\n                        const BYTE* const ip, const BYTE* const iLimit,\n                        const U32 maxNbAttempts, const U32 mls, ZSTD_match_t* matches, const U32 minMatchLen)\n{\n    if (ip < zc->base + zc->nextToUpdate) return 0;   /* skipped area */\n    ZSTD_updateTree_extDict(zc, ip, iLimit, maxNbAttempts, mls);\n    return ZSTD_insertBtAndGetAllMatches(zc, ip, iLimit, maxNbAttempts, mls, 1, matches, minMatchLen);\n}\n\n\nstatic U32 ZSTD_BtGetAllMatches_selectMLS_extDict (\n                        ZSTD_CCtx* zc,   /* Index table will be updated */\n                        const BYTE* ip, const BYTE* const iHighLimit,\n                        const U32 maxNbAttempts, const U32 matchLengthSearch, ZSTD_match_t* matches, const U32 minMatchLen)\n{\n    switch(matchLengthSearch)\n    {\n    case 3 : return ZSTD_BtGetAllMatches_extDict(zc, ip, iHighLimit, maxNbAttempts, 3, matches, minMatchLen);\n    default :\n    case 4 : return ZSTD_BtGetAllMatches_extDict(zc, ip, iHighLimit, maxNbAttempts, 4, matches, minMatchLen);\n    case 5 : return ZSTD_BtGetAllMatches_extDict(zc, ip, iHighLimit, maxNbAttempts, 5, matches, minMatchLen);\n    case 7 :\n    case 6 : return ZSTD_BtGetAllMatches_extDict(zc, ip, iHighLimit, maxNbAttempts, 6, matches, minMatchLen);\n    }\n}\n\n\n/*-*******************************\n*  Optimal parser\n*********************************/\nFORCE_INLINE_TEMPLATE\nvoid ZSTD_compressBlock_opt_generic(ZSTD_CCtx* ctx,\n                                    const void* src, size_t srcSize, const int ultra)\n{\n    seqStore_t* seqStorePtr = &(ctx->seqStore);\n    optState_t* optStatePtr = &(ctx->optState);\n    const BYTE* const istart = (const BYTE*)src;\n    const BYTE* ip = istart;\n    const BYTE* anchor = istart;\n    const BYTE* const iend = istart + srcSize;\n    const BYTE* const ilimit = iend - 8;\n    const BYTE* const base = ctx->base;\n    const BYTE* const prefixStart = base + ctx->dictLimit;\n\n    const U32 maxSearches = 1U << ctx->appliedParams.cParams.searchLog;\n    const U32 sufficient_len = ctx->appliedParams.cParams.targetLength;\n    const U32 mls = ctx->appliedParams.cParams.searchLength;\n    const U32 minMatch = (ctx->appliedParams.cParams.searchLength == 3) ? 3 : 4;\n\n    ZSTD_optimal_t* opt = optStatePtr->priceTable;\n    ZSTD_match_t* matches = optStatePtr->matchTable;\n    const BYTE* inr;\n    U32 offset, rep[ZSTD_REP_NUM];\n\n    /* init */\n    ctx->nextToUpdate3 = ctx->nextToUpdate;\n    ZSTD_rescaleFreqs(optStatePtr, (const BYTE*)src, srcSize);\n    ip += (ip==prefixStart);\n    { U32 i; for (i=0; i<ZSTD_REP_NUM; i++) rep[i]=seqStorePtr->rep[i]; }\n\n    /* Match Loop */\n    while (ip < ilimit) {\n        U32 cur, match_num, last_pos, litlen, price;\n        U32 u, mlen, best_mlen, best_off, litLength;\n        memset(opt, 0, sizeof(ZSTD_optimal_t));\n        last_pos = 0;\n        litlen = (U32)(ip - anchor);\n\n        /* check repCode */\n        {   U32 i, last_i = ZSTD_REP_CHECK + (ip==anchor);\n            for (i=(ip == anchor); i<last_i; i++) {\n                const S32 repCur = (i==ZSTD_REP_MOVE_OPT) ? (rep[0] - 1) : rep[i];\n                if ( (repCur > 0) && (repCur < (S32)(ip-prefixStart))\n                    && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repCur, minMatch))) {\n                    mlen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repCur, iend) + minMatch;\n                    if (mlen > sufficient_len || mlen >= ZSTD_OPT_NUM) {\n                        best_mlen = mlen; best_off = i; cur = 0; last_pos = 1;\n                        goto _storeSequence;\n                    }\n                    best_off = i - (ip == anchor);\n                    do {\n                        price = ZSTD_getPrice(optStatePtr, litlen, anchor, best_off, mlen - MINMATCH, ultra);\n                        if (mlen > last_pos || price < opt[mlen].price)\n                            SET_PRICE(mlen, mlen, i, litlen, price);   /* note : macro modifies last_pos */\n                        mlen--;\n                    } while (mlen >= minMatch);\n        }   }   }\n\n        match_num = ZSTD_BtGetAllMatches_selectMLS(ctx, ip, iend, maxSearches, mls, matches, minMatch);\n\n        if (!last_pos && !match_num) { ip++; continue; }\n\n        if (match_num && (matches[match_num-1].len > sufficient_len || matches[match_num-1].len >= ZSTD_OPT_NUM)) {\n            best_mlen = matches[match_num-1].len;\n            best_off = matches[match_num-1].off;\n            cur = 0;\n            last_pos = 1;\n            goto _storeSequence;\n        }\n\n        /* set prices using matches at position = 0 */\n        best_mlen = (last_pos) ? last_pos : minMatch;\n        for (u = 0; u < match_num; u++) {\n            mlen = (u>0) ? matches[u-1].len+1 : best_mlen;\n            best_mlen = matches[u].len;\n            while (mlen <= best_mlen) {\n                price = ZSTD_getPrice(optStatePtr, litlen, anchor, matches[u].off-1, mlen - MINMATCH, ultra);\n                if (mlen > last_pos || price < opt[mlen].price)\n                    SET_PRICE(mlen, mlen, matches[u].off, litlen, price);   /* note : macro modifies last_pos */\n                mlen++;\n        }   }\n\n        if (last_pos < minMatch) { ip++; continue; }\n\n        /* initialize opt[0] */\n        { U32 i ; for (i=0; i<ZSTD_REP_NUM; i++) opt[0].rep[i] = rep[i]; }\n        opt[0].mlen = 1;\n        opt[0].litlen = litlen;\n\n         /* check further positions */\n        for (cur = 1; cur <= last_pos; cur++) {\n           inr = ip + cur;\n\n           if (opt[cur-1].mlen == 1) {\n                litlen = opt[cur-1].litlen + 1;\n                if (cur > litlen) {\n                    price = opt[cur - litlen].price + ZSTD_getLiteralPrice(optStatePtr, litlen, inr-litlen);\n                } else\n                    price = ZSTD_getLiteralPrice(optStatePtr, litlen, anchor);\n           } else {\n                litlen = 1;\n                price = opt[cur - 1].price + ZSTD_getLiteralPrice(optStatePtr, litlen, inr-1);\n           }\n\n           if (cur > last_pos || price <= opt[cur].price)\n                SET_PRICE(cur, 1, 0, litlen, price);\n\n           if (cur == last_pos) break;\n\n           if (inr > ilimit)  /* last match must start at a minimum distance of 8 from oend */\n               continue;\n\n           mlen = opt[cur].mlen;\n           if (opt[cur].off > ZSTD_REP_MOVE_OPT) {\n                opt[cur].rep[2] = opt[cur-mlen].rep[1];\n                opt[cur].rep[1] = opt[cur-mlen].rep[0];\n                opt[cur].rep[0] = opt[cur].off - ZSTD_REP_MOVE_OPT;\n           } else {\n                opt[cur].rep[2] = (opt[cur].off > 1) ? opt[cur-mlen].rep[1] : opt[cur-mlen].rep[2];\n                opt[cur].rep[1] = (opt[cur].off > 0) ? opt[cur-mlen].rep[0] : opt[cur-mlen].rep[1];\n                opt[cur].rep[0] = ((opt[cur].off==ZSTD_REP_MOVE_OPT) && (mlen != 1)) ? (opt[cur-mlen].rep[0] - 1) : (opt[cur-mlen].rep[opt[cur].off]);\n           }\n\n            best_mlen = minMatch;\n            {   U32 i, last_i = ZSTD_REP_CHECK + (mlen != 1);\n                for (i=(opt[cur].mlen != 1); i<last_i; i++) {  /* check rep */\n                    const S32 repCur = (i==ZSTD_REP_MOVE_OPT) ? (opt[cur].rep[0] - 1) : opt[cur].rep[i];\n                    if ( (repCur > 0) && (repCur < (S32)(inr-prefixStart))\n                       && (ZSTD_readMINMATCH(inr, minMatch) == ZSTD_readMINMATCH(inr - repCur, minMatch))) {\n                       mlen = (U32)ZSTD_count(inr+minMatch, inr+minMatch - repCur, iend) + minMatch;\n\n                       if (mlen > sufficient_len || cur + mlen >= ZSTD_OPT_NUM) {\n                            best_mlen = mlen; best_off = i; last_pos = cur + 1;\n                            goto _storeSequence;\n                       }\n\n                       best_off = i - (opt[cur].mlen != 1);\n                       if (mlen > best_mlen) best_mlen = mlen;\n\n                       do {\n                           if (opt[cur].mlen == 1) {\n                                litlen = opt[cur].litlen;\n                                if (cur > litlen) {\n                                    price = opt[cur - litlen].price + ZSTD_getPrice(optStatePtr, litlen, inr-litlen, best_off, mlen - MINMATCH, ultra);\n                                } else\n                                    price = ZSTD_getPrice(optStatePtr, litlen, anchor, best_off, mlen - MINMATCH, ultra);\n                            } else {\n                                litlen = 0;\n                                price = opt[cur].price + ZSTD_getPrice(optStatePtr, 0, NULL, best_off, mlen - MINMATCH, ultra);\n                            }\n\n                            if (cur + mlen > last_pos || price <= opt[cur + mlen].price)\n                                SET_PRICE(cur + mlen, mlen, i, litlen, price);\n                            mlen--;\n                        } while (mlen >= minMatch);\n            }   }   }\n\n            match_num = ZSTD_BtGetAllMatches_selectMLS(ctx, inr, iend, maxSearches, mls, matches, best_mlen);\n\n            if (match_num > 0 && (matches[match_num-1].len > sufficient_len || cur + matches[match_num-1].len >= ZSTD_OPT_NUM)) {\n                best_mlen = matches[match_num-1].len;\n                best_off = matches[match_num-1].off;\n                last_pos = cur + 1;\n                goto _storeSequence;\n            }\n\n            /* set prices using matches at position = cur */\n            for (u = 0; u < match_num; u++) {\n                mlen = (u>0) ? matches[u-1].len+1 : best_mlen;\n                best_mlen = matches[u].len;\n\n                while (mlen <= best_mlen) {\n                    if (opt[cur].mlen == 1) {\n                        litlen = opt[cur].litlen;\n                        if (cur > litlen)\n                            price = opt[cur - litlen].price + ZSTD_getPrice(optStatePtr, litlen, ip+cur-litlen, matches[u].off-1, mlen - MINMATCH, ultra);\n                        else\n                            price = ZSTD_getPrice(optStatePtr, litlen, anchor, matches[u].off-1, mlen - MINMATCH, ultra);\n                    } else {\n                        litlen = 0;\n                        price = opt[cur].price + ZSTD_getPrice(optStatePtr, 0, NULL, matches[u].off-1, mlen - MINMATCH, ultra);\n                    }\n\n                    if (cur + mlen > last_pos || (price < opt[cur + mlen].price))\n                        SET_PRICE(cur + mlen, mlen, matches[u].off, litlen, price);\n\n                    mlen++;\n        }   }   }\n\n        best_mlen = opt[last_pos].mlen;\n        best_off = opt[last_pos].off;\n        cur = last_pos - best_mlen;\n\n        /* store sequence */\n_storeSequence:   /* cur, last_pos, best_mlen, best_off have to be set */\n        opt[0].mlen = 1;\n\n        while (1) {\n            mlen = opt[cur].mlen;\n            offset = opt[cur].off;\n            opt[cur].mlen = best_mlen;\n            opt[cur].off = best_off;\n            best_mlen = mlen;\n            best_off = offset;\n            if (mlen > cur) break;\n            cur -= mlen;\n        }\n\n        for (u = 0; u <= last_pos;) {\n            u += opt[u].mlen;\n        }\n\n        for (cur=0; cur < last_pos; ) {\n            mlen = opt[cur].mlen;\n            if (mlen == 1) { ip++; cur++; continue; }\n            offset = opt[cur].off;\n            cur += mlen;\n            litLength = (U32)(ip - anchor);\n\n            if (offset > ZSTD_REP_MOVE_OPT) {\n                rep[2] = rep[1];\n                rep[1] = rep[0];\n                rep[0] = offset - ZSTD_REP_MOVE_OPT;\n                offset--;\n            } else {\n                if (offset != 0) {\n                    best_off = (offset==ZSTD_REP_MOVE_OPT) ? (rep[0] - 1) : (rep[offset]);\n                    if (offset != 1) rep[2] = rep[1];\n                    rep[1] = rep[0];\n                    rep[0] = best_off;\n                }\n                if (litLength==0) offset--;\n            }\n\n            ZSTD_updatePrice(optStatePtr, litLength, anchor, offset, mlen-MINMATCH);\n            ZSTD_storeSeq(seqStorePtr, litLength, anchor, offset, mlen-MINMATCH);\n            anchor = ip = ip + mlen;\n    }    }   /* for (cur=0; cur < last_pos; ) */\n\n    /* Save reps for next block */\n    { int i; for (i=0; i<ZSTD_REP_NUM; i++) seqStorePtr->repToConfirm[i] = rep[i]; }\n\n    /* Last Literals */\n    {   size_t const lastLLSize = iend - anchor;\n        memcpy(seqStorePtr->lit, anchor, lastLLSize);\n        seqStorePtr->lit += lastLLSize;\n    }\n}\n\n\nFORCE_INLINE_TEMPLATE\nvoid ZSTD_compressBlock_opt_extDict_generic(ZSTD_CCtx* ctx,\n                                     const void* src, size_t srcSize, const int ultra)\n{\n    seqStore_t* seqStorePtr = &(ctx->seqStore);\n    optState_t* optStatePtr = &(ctx->optState);\n    const BYTE* const istart = (const BYTE*)src;\n    const BYTE* ip = istart;\n    const BYTE* anchor = istart;\n    const BYTE* const iend = istart + srcSize;\n    const BYTE* const ilimit = iend - 8;\n    const BYTE* const base = ctx->base;\n    const U32 lowestIndex = ctx->lowLimit;\n    const U32 dictLimit = ctx->dictLimit;\n    const BYTE* const prefixStart = base + dictLimit;\n    const BYTE* const dictBase = ctx->dictBase;\n    const BYTE* const dictEnd  = dictBase + dictLimit;\n\n    const U32 maxSearches = 1U << ctx->appliedParams.cParams.searchLog;\n    const U32 sufficient_len = ctx->appliedParams.cParams.targetLength;\n    const U32 mls = ctx->appliedParams.cParams.searchLength;\n    const U32 minMatch = (ctx->appliedParams.cParams.searchLength == 3) ? 3 : 4;\n\n    ZSTD_optimal_t* opt = optStatePtr->priceTable;\n    ZSTD_match_t* matches = optStatePtr->matchTable;\n    const BYTE* inr;\n\n    /* init */\n    U32 offset, rep[ZSTD_REP_NUM];\n    { U32 i; for (i=0; i<ZSTD_REP_NUM; i++) rep[i]=seqStorePtr->rep[i]; }\n\n    ctx->nextToUpdate3 = ctx->nextToUpdate;\n    ZSTD_rescaleFreqs(optStatePtr, (const BYTE*)src, srcSize);\n    ip += (ip==prefixStart);\n\n    /* Match Loop */\n    while (ip < ilimit) {\n        U32 cur, match_num, last_pos, litlen, price;\n        U32 u, mlen, best_mlen, best_off, litLength;\n        U32 current = (U32)(ip-base);\n        memset(opt, 0, sizeof(ZSTD_optimal_t));\n        last_pos = 0;\n        opt[0].litlen = (U32)(ip - anchor);\n\n        /* check repCode */\n        {   U32 i, last_i = ZSTD_REP_CHECK + (ip==anchor);\n            for (i = (ip==anchor); i<last_i; i++) {\n                const S32 repCur = (i==ZSTD_REP_MOVE_OPT) ? (rep[0] - 1) : rep[i];\n                const U32 repIndex = (U32)(current - repCur);\n                const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;\n                const BYTE* const repMatch = repBase + repIndex;\n                if ( (repCur > 0 && repCur <= (S32)current)\n                   && (((U32)((dictLimit-1) - repIndex) >= 3) & (repIndex>lowestIndex))  /* intentional overflow */\n                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {\n                    /* repcode detected we should take it */\n                    const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;\n                    mlen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iend, repEnd, prefixStart) + minMatch;\n\n                    if (mlen > sufficient_len || mlen >= ZSTD_OPT_NUM) {\n                        best_mlen = mlen; best_off = i; cur = 0; last_pos = 1;\n                        goto _storeSequence;\n                    }\n\n                    best_off = i - (ip==anchor);\n                    litlen = opt[0].litlen;\n                    do {\n                        price = ZSTD_getPrice(optStatePtr, litlen, anchor, best_off, mlen - MINMATCH, ultra);\n                        if (mlen > last_pos || price < opt[mlen].price)\n                            SET_PRICE(mlen, mlen, i, litlen, price);   /* note : macro modifies last_pos */\n                        mlen--;\n                    } while (mlen >= minMatch);\n        }   }   }\n\n        match_num = ZSTD_BtGetAllMatches_selectMLS_extDict(ctx, ip, iend, maxSearches, mls, matches, minMatch);  /* first search (depth 0) */\n\n        if (!last_pos && !match_num) { ip++; continue; }\n\n        { U32 i; for (i=0; i<ZSTD_REP_NUM; i++) opt[0].rep[i] = rep[i]; }\n        opt[0].mlen = 1;\n\n        if (match_num && (matches[match_num-1].len > sufficient_len || matches[match_num-1].len >= ZSTD_OPT_NUM)) {\n            best_mlen = matches[match_num-1].len;\n            best_off = matches[match_num-1].off;\n            cur = 0;\n            last_pos = 1;\n            goto _storeSequence;\n        }\n\n        best_mlen = (last_pos) ? last_pos : minMatch;\n\n        /* set prices using matches at position = 0 */\n        for (u = 0; u < match_num; u++) {\n            mlen = (u>0) ? matches[u-1].len+1 : best_mlen;\n            best_mlen = matches[u].len;\n            litlen = opt[0].litlen;\n            while (mlen <= best_mlen) {\n                price = ZSTD_getPrice(optStatePtr, litlen, anchor, matches[u].off-1, mlen - MINMATCH, ultra);\n                if (mlen > last_pos || price < opt[mlen].price)\n                    SET_PRICE(mlen, mlen, matches[u].off, litlen, price);\n                mlen++;\n        }   }\n\n        if (last_pos < minMatch) {\n            ip++; continue;\n        }\n\n        /* check further positions */\n        for (cur = 1; cur <= last_pos; cur++) {\n            inr = ip + cur;\n\n            if (opt[cur-1].mlen == 1) {\n                litlen = opt[cur-1].litlen + 1;\n                if (cur > litlen) {\n                    price = opt[cur - litlen].price + ZSTD_getLiteralPrice(optStatePtr, litlen, inr-litlen);\n                } else\n                    price = ZSTD_getLiteralPrice(optStatePtr, litlen, anchor);\n            } else {\n                litlen = 1;\n                price = opt[cur - 1].price + ZSTD_getLiteralPrice(optStatePtr, litlen, inr-1);\n            }\n\n            if (cur > last_pos || price <= opt[cur].price)\n                SET_PRICE(cur, 1, 0, litlen, price);\n\n            if (cur == last_pos) break;\n\n            if (inr > ilimit)  /* last match must start at a minimum distance of 8 from oend */\n                continue;\n\n            mlen = opt[cur].mlen;\n            if (opt[cur].off > ZSTD_REP_MOVE_OPT) {\n                opt[cur].rep[2] = opt[cur-mlen].rep[1];\n                opt[cur].rep[1] = opt[cur-mlen].rep[0];\n                opt[cur].rep[0] = opt[cur].off - ZSTD_REP_MOVE_OPT;\n            } else {\n                opt[cur].rep[2] = (opt[cur].off > 1) ? opt[cur-mlen].rep[1] : opt[cur-mlen].rep[2];\n                opt[cur].rep[1] = (opt[cur].off > 0) ? opt[cur-mlen].rep[0] : opt[cur-mlen].rep[1];\n                opt[cur].rep[0] = ((opt[cur].off==ZSTD_REP_MOVE_OPT) && (mlen != 1)) ? (opt[cur-mlen].rep[0] - 1) : (opt[cur-mlen].rep[opt[cur].off]);\n            }\n\n            best_mlen = minMatch;\n            {   U32 i, last_i = ZSTD_REP_CHECK + (mlen != 1);\n                for (i = (mlen != 1); i<last_i; i++) {\n                    const S32 repCur = (i==ZSTD_REP_MOVE_OPT) ? (opt[cur].rep[0] - 1) : opt[cur].rep[i];\n                    const U32 repIndex = (U32)(current+cur - repCur);\n                    const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;\n                    const BYTE* const repMatch = repBase + repIndex;\n                    if ( (repCur > 0 && repCur <= (S32)(current+cur))\n                      && (((U32)((dictLimit-1) - repIndex) >= 3) & (repIndex>lowestIndex))  /* intentional overflow */\n                      && (ZSTD_readMINMATCH(inr, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {\n                        /* repcode detected */\n                        const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;\n                        mlen = (U32)ZSTD_count_2segments(inr+minMatch, repMatch+minMatch, iend, repEnd, prefixStart) + minMatch;\n\n                        if (mlen > sufficient_len || cur + mlen >= ZSTD_OPT_NUM) {\n                            best_mlen = mlen; best_off = i; last_pos = cur + 1;\n                            goto _storeSequence;\n                        }\n\n                        best_off = i - (opt[cur].mlen != 1);\n                        if (mlen > best_mlen) best_mlen = mlen;\n\n                        do {\n                            if (opt[cur].mlen == 1) {\n                                litlen = opt[cur].litlen;\n                                if (cur > litlen) {\n                                    price = opt[cur - litlen].price + ZSTD_getPrice(optStatePtr, litlen, inr-litlen, best_off, mlen - MINMATCH, ultra);\n                                } else\n                                    price = ZSTD_getPrice(optStatePtr, litlen, anchor, best_off, mlen - MINMATCH, ultra);\n                            } else {\n                                litlen = 0;\n                                price = opt[cur].price + ZSTD_getPrice(optStatePtr, 0, NULL, best_off, mlen - MINMATCH, ultra);\n                            }\n\n                            if (cur + mlen > last_pos || price <= opt[cur + mlen].price)\n                                SET_PRICE(cur + mlen, mlen, i, litlen, price);\n                            mlen--;\n                        } while (mlen >= minMatch);\n            }   }   }\n\n            match_num = ZSTD_BtGetAllMatches_selectMLS_extDict(ctx, inr, iend, maxSearches, mls, matches, minMatch);\n\n            if (match_num > 0 && (matches[match_num-1].len > sufficient_len || cur + matches[match_num-1].len >= ZSTD_OPT_NUM)) {\n                best_mlen = matches[match_num-1].len;\n                best_off = matches[match_num-1].off;\n                last_pos = cur + 1;\n                goto _storeSequence;\n            }\n\n            /* set prices using matches at position = cur */\n            for (u = 0; u < match_num; u++) {\n                mlen = (u>0) ? matches[u-1].len+1 : best_mlen;\n                best_mlen = matches[u].len;\n\n                while (mlen <= best_mlen) {\n                    if (opt[cur].mlen == 1) {\n                        litlen = opt[cur].litlen;\n                        if (cur > litlen)\n                            price = opt[cur - litlen].price + ZSTD_getPrice(optStatePtr, litlen, ip+cur-litlen, matches[u].off-1, mlen - MINMATCH, ultra);\n                        else\n                            price = ZSTD_getPrice(optStatePtr, litlen, anchor, matches[u].off-1, mlen - MINMATCH, ultra);\n                    } else {\n                        litlen = 0;\n                        price = opt[cur].price + ZSTD_getPrice(optStatePtr, 0, NULL, matches[u].off-1, mlen - MINMATCH, ultra);\n                    }\n\n                    if (cur + mlen > last_pos || (price < opt[cur + mlen].price))\n                        SET_PRICE(cur + mlen, mlen, matches[u].off, litlen, price);\n\n                    mlen++;\n        }   }   }   /* for (cur = 1; cur <= last_pos; cur++) */\n\n        best_mlen = opt[last_pos].mlen;\n        best_off = opt[last_pos].off;\n        cur = last_pos - best_mlen;\n\n        /* store sequence */\n_storeSequence:   /* cur, last_pos, best_mlen, best_off have to be set */\n        opt[0].mlen = 1;\n\n        while (1) {\n            mlen = opt[cur].mlen;\n            offset = opt[cur].off;\n            opt[cur].mlen = best_mlen;\n            opt[cur].off = best_off;\n            best_mlen = mlen;\n            best_off = offset;\n            if (mlen > cur) break;\n            cur -= mlen;\n        }\n\n        for (u = 0; u <= last_pos; ) {\n            u += opt[u].mlen;\n        }\n\n        for (cur=0; cur < last_pos; ) {\n            mlen = opt[cur].mlen;\n            if (mlen == 1) { ip++; cur++; continue; }\n            offset = opt[cur].off;\n            cur += mlen;\n            litLength = (U32)(ip - anchor);\n\n            if (offset > ZSTD_REP_MOVE_OPT) {\n                rep[2] = rep[1];\n                rep[1] = rep[0];\n                rep[0] = offset - ZSTD_REP_MOVE_OPT;\n                offset--;\n            } else {\n                if (offset != 0) {\n                    best_off = (offset==ZSTD_REP_MOVE_OPT) ? (rep[0] - 1) : (rep[offset]);\n                    if (offset != 1) rep[2] = rep[1];\n                    rep[1] = rep[0];\n                    rep[0] = best_off;\n                }\n\n                if (litLength==0) offset--;\n            }\n\n            ZSTD_updatePrice(optStatePtr, litLength, anchor, offset, mlen-MINMATCH);\n            ZSTD_storeSeq(seqStorePtr, litLength, anchor, offset, mlen-MINMATCH);\n            anchor = ip = ip + mlen;\n    }    }   /* for (cur=0; cur < last_pos; ) */\n\n    /* Save reps for next block */\n    { int i; for (i=0; i<ZSTD_REP_NUM; i++) seqStorePtr->repToConfirm[i] = rep[i]; }\n\n    /* Last Literals */\n    {   size_t lastLLSize = iend - anchor;\n        memcpy(seqStorePtr->lit, anchor, lastLLSize);\n        seqStorePtr->lit += lastLLSize;\n    }",
        "res_region": "#if defined (__cplusplus)",
        "lookback": "}",
        "lookahead": "}",
        "label": [
            "base",
            "complex_conflict"
        ],
        "start_line": 24,
        "end_line": 1858,
        "merge_gen_region": null,
        "confidence": 0.8160443902015686,
        "hesitated": true
    }
]