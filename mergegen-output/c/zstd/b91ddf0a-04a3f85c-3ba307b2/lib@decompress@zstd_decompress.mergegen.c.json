[
    {
        "a_contents": "static size_t ZSTD_decompressSequences(\n                               ZSTD_DCtx* dctx,\n                               void* dst, size_t maxDstSize,\n                         const void* seqStart, size_t seqSize, int nbSeq,\n                         const ZSTD_longOffset_e isLongOffset)\n{\n    const BYTE* ip = (const BYTE*)seqStart;\n    const BYTE* const iend = ip + seqSize;\n    BYTE* const ostart = (BYTE* const)dst;\n    BYTE* const oend = ostart + maxDstSize;\n    BYTE* op = ostart;\n    const BYTE* litPtr = dctx->litPtr;\n    const BYTE* const litEnd = litPtr + dctx->litSize;\n    const BYTE* const base = (const BYTE*) (dctx->base);\n    const BYTE* const vBase = (const BYTE*) (dctx->vBase);\n    const BYTE* const dictEnd = (const BYTE*) (dctx->dictEnd);\n\n    DEBUGLOG(5, \"ZSTD_decompressSequences\");\n\n    /* Regen sequences */\n    if (nbSeq) {\n        seqState_t seqState;\n        dctx->fseEntropy = 1;\n        { U32 i; for (i=0; i<ZSTD_REP_NUM; i++) seqState.prevOffset[i] = dctx->entropy.rep[i]; }\n        CHECK_E(BIT_initDStream(&seqState.DStream, ip, iend-ip), corruption_detected);\n        FSE_initDState(&seqState.stateLL, &seqState.DStream, dctx->LLTptr);\n        FSE_initDState(&seqState.stateOffb, &seqState.DStream, dctx->OFTptr);\n        FSE_initDState(&seqState.stateML, &seqState.DStream, dctx->MLTptr);\n\n        for ( ; (BIT_reloadDStream(&(seqState.DStream)) <= BIT_DStream_completed) && nbSeq ; ) {\n            nbSeq--;\n            {   seq_t const sequence = ZSTD_decodeSequence(&seqState, isLongOffset);\n                size_t const oneSeqSize = ZSTD_execSequence(op, oend, sequence, &litPtr, litEnd, base, vBase, dictEnd);\n                DEBUGLOG(6, \"regenerated sequence size : %u\", (U32)oneSeqSize);\n                if (ZSTD_isError(oneSeqSize)) return oneSeqSize;\n                op += oneSeqSize;\n        }   }\n\n        /* check if reached exact end */\n        DEBUGLOG(5, \"after decode loop, remaining nbSeq : %i\", nbSeq);\n        if (nbSeq) return ERROR(corruption_detected);\n        /* save reps for next block */\n        { U32 i; for (i=0; i<ZSTD_REP_NUM; i++) dctx->entropy.rep[i] = (U32)(seqState.prevOffset[i]); }\n    }\n\n    /* last literal segment */\n    {   size_t const lastLLSize = litEnd - litPtr;\n        if (lastLLSize > (size_t)(oend-op)) return ERROR(dstSize_tooSmall);\n        memcpy(op, litPtr, lastLLSize);\n        op += lastLLSize;\n    }\n\n    return op-ostart;\n}\n\n\nHINT_INLINE\nseq_t ZSTD_decodeSequenceLong(seqState_t* seqState, ZSTD_longOffset_e const longOffsets)\n{\n    seq_t seq;\n\n    U32 const llCode = FSE_peekSymbol(&seqState->stateLL);\n    U32 const mlCode = FSE_peekSymbol(&seqState->stateML);\n    U32 const ofCode = FSE_peekSymbol(&seqState->stateOffb);   /* <= MaxOff, by table construction */\n\n    U32 const llBits = LL_bits[llCode];\n    U32 const mlBits = ML_bits[mlCode];\n    U32 const ofBits = ofCode;\n    U32 const totalBits = llBits+mlBits+ofBits;\n\n    static const U32 LL_base[MaxLL+1] = {\n                             0,  1,    2,     3,     4,     5,     6,      7,\n                             8,  9,   10,    11,    12,    13,    14,     15,\n                            16, 18,   20,    22,    24,    28,    32,     40,\n                            48, 64, 0x80, 0x100, 0x200, 0x400, 0x800, 0x1000,\n                            0x2000, 0x4000, 0x8000, 0x10000 };\n\n    static const U32 ML_base[MaxML+1] = {\n                             3,  4,  5,    6,     7,     8,     9,    10,\n                            11, 12, 13,   14,    15,    16,    17,    18,\n                            19, 20, 21,   22,    23,    24,    25,    26,\n                            27, 28, 29,   30,    31,    32,    33,    34,\n                            35, 37, 39,   41,    43,    47,    51,    59,\n                            67, 83, 99, 0x83, 0x103, 0x203, 0x403, 0x803,\n                            0x1003, 0x2003, 0x4003, 0x8003, 0x10003 };\n\n    static const U32 OF_base[MaxOff+1] = {\n                     0,        1,       1,       5,     0xD,     0x1D,     0x3D,     0x7D,\n                     0xFD,   0x1FD,   0x3FD,   0x7FD,   0xFFD,   0x1FFD,   0x3FFD,   0x7FFD,\n                     0xFFFD, 0x1FFFD, 0x3FFFD, 0x7FFFD, 0xFFFFD, 0x1FFFFD, 0x3FFFFD, 0x7FFFFD,\n                     0xFFFFFD, 0x1FFFFFD, 0x3FFFFFD, 0x7FFFFFD, 0xFFFFFFD, 0x1FFFFFFD, 0x3FFFFFFD, 0x7FFFFFFD };\n\n    /* sequence */\n    {   size_t offset;\n        if (!ofCode)\n            offset = 0;\n        else {\n            ZSTD_STATIC_ASSERT(ZSTD_lo_isLongOffset == 1);\n            ZSTD_STATIC_ASSERT(LONG_OFFSETS_MAX_EXTRA_BITS_32 == 5);\n            assert(ofBits <= MaxOff);\n            if (MEM_32bits() && longOffsets) {\n                U32 const extraBits = ofBits - MIN(ofBits, STREAM_ACCUMULATOR_MIN_32-1);\n                offset = OF_base[ofCode] + (BIT_readBitsFast(&seqState->DStream, ofBits - extraBits) << extraBits);\n                if (MEM_32bits() || extraBits) BIT_reloadDStream(&seqState->DStream);\n                if (extraBits) offset += BIT_readBitsFast(&seqState->DStream, extraBits);\n            } else {\n                offset = OF_base[ofCode] + BIT_readBitsFast(&seqState->DStream, ofBits);   /* <=  (ZSTD_WINDOWLOG_MAX-1) bits */\n                if (MEM_32bits()) BIT_reloadDStream(&seqState->DStream);\n            }\n        }\n\n        if (ofCode <= 1) {\n            offset += (llCode==0);\n            if (offset) {\n                size_t temp = (offset==3) ? seqState->prevOffset[0] - 1 : seqState->prevOffset[offset];\n                temp += !temp;   /* 0 is not valid; input is corrupted; force offset to 1 */\n                if (offset != 1) seqState->prevOffset[2] = seqState->prevOffset[1];\n                seqState->prevOffset[1] = seqState->prevOffset[0];\n                seqState->prevOffset[0] = offset = temp;\n            } else {\n                offset = seqState->prevOffset[0];\n            }\n        } else {\n            seqState->prevOffset[2] = seqState->prevOffset[1];\n            seqState->prevOffset[1] = seqState->prevOffset[0];\n            seqState->prevOffset[0] = offset;\n        }\n        seq.offset = offset;\n    }\n\n    seq.matchLength = ML_base[mlCode] + ((mlCode>31) ? BIT_readBitsFast(&seqState->DStream, mlBits) : 0);  /* <=  16 bits */\n    if (MEM_32bits() && (mlBits+llBits >= STREAM_ACCUMULATOR_MIN_32-LONG_OFFSETS_MAX_EXTRA_BITS_32))\n        BIT_reloadDStream(&seqState->DStream);\n    if (MEM_64bits() && (totalBits >= STREAM_ACCUMULATOR_MIN_64-(LLFSELog+MLFSELog+OffFSELog)))\n        BIT_reloadDStream(&seqState->DStream);\n    /* Verify that there is enough bits to read the rest of the data in 64-bit mode. */\n    ZSTD_STATIC_ASSERT(16+LLFSELog+MLFSELog+OffFSELog < STREAM_ACCUMULATOR_MIN_64);\n\n    seq.litLength = LL_base[llCode] + ((llCode>15) ? BIT_readBitsFast(&seqState->DStream, llBits) : 0);    /* <=  16 bits */\n    if (MEM_32bits())\n        BIT_reloadDStream(&seqState->DStream);\n\n    {   size_t const pos = seqState->pos + seq.litLength;\n        const BYTE* const matchBase = (seq.offset > pos) ? seqState->dictEnd : seqState->prefixStart;\n        seq.match = matchBase + pos - seq.offset;  /* note : this operation can overflow when seq.offset is really too large, which can only happen when input is corrupted.\n                                                    * No consequence though : no memory access will occur, overly large offset will be detected in ZSTD_execSequenceLong() */\n        seqState->pos = pos + seq.matchLength;\n    }\n\n    /* ANS state update */\n    FSE_updateState(&seqState->stateLL, &seqState->DStream);    /* <=  9 bits */\n    FSE_updateState(&seqState->stateML, &seqState->DStream);    /* <=  9 bits */\n    if (MEM_32bits()) BIT_reloadDStream(&seqState->DStream);    /* <= 18 bits */\n    FSE_updateState(&seqState->stateOffb, &seqState->DStream);  /* <=  8 bits */\n\n    return seq;\n}\n\n",
        "b_contents": "",
        "base_contents": "static size_t ZSTD_decompressSequences(\n                               ZSTD_DCtx* dctx,\n                               void* dst, size_t maxDstSize,\n                         const void* seqStart, size_t seqSize,\n                         const ZSTD_longOffset_e isLongOffset)\n{\n    const BYTE* ip = (const BYTE*)seqStart;\n    const BYTE* const iend = ip + seqSize;\n    BYTE* const ostart = (BYTE* const)dst;\n    BYTE* const oend = ostart + maxDstSize;\n    BYTE* op = ostart;\n    const BYTE* litPtr = dctx->litPtr;\n    const BYTE* const litEnd = litPtr + dctx->litSize;\n    const BYTE* const base = (const BYTE*) (dctx->base);\n    const BYTE* const vBase = (const BYTE*) (dctx->vBase);\n    const BYTE* const dictEnd = (const BYTE*) (dctx->dictEnd);\n    int nbSeq;\n    DEBUGLOG(5, \"ZSTD_decompressSequences\");\n\n    /* Build Decoding Tables */\n    {   size_t const seqHSize = ZSTD_decodeSeqHeaders(dctx, &nbSeq, ip, seqSize);\n        DEBUGLOG(5, \"ZSTD_decodeSeqHeaders: size=%u, nbSeq=%i\",\n                    (U32)seqHSize, nbSeq);\n        if (ZSTD_isError(seqHSize)) return seqHSize;\n        ip += seqHSize;\n    }\n\n    /* Regen sequences */\n    if (nbSeq) {\n        seqState_t seqState;\n        dctx->fseEntropy = 1;\n        { U32 i; for (i=0; i<ZSTD_REP_NUM; i++) seqState.prevOffset[i] = dctx->entropy.rep[i]; }\n        CHECK_E(BIT_initDStream(&seqState.DStream, ip, iend-ip), corruption_detected);\n        FSE_initDState(&seqState.stateLL, &seqState.DStream, dctx->LLTptr);\n        FSE_initDState(&seqState.stateOffb, &seqState.DStream, dctx->OFTptr);\n        FSE_initDState(&seqState.stateML, &seqState.DStream, dctx->MLTptr);\n\n        for ( ; (BIT_reloadDStream(&(seqState.DStream)) <= BIT_DStream_completed) && nbSeq ; ) {\n            nbSeq--;\n            {   seq_t const sequence = ZSTD_decodeSequence(&seqState, isLongOffset);\n                size_t const oneSeqSize = ZSTD_execSequence(op, oend, sequence, &litPtr, litEnd, base, vBase, dictEnd);\n                DEBUGLOG(6, \"regenerated sequence size : %u\", (U32)oneSeqSize);\n                if (ZSTD_isError(oneSeqSize)) return oneSeqSize;\n                op += oneSeqSize;\n        }   }\n\n        /* check if reached exact end */\n        DEBUGLOG(5, \"after decode loop, remaining nbSeq : %i\", nbSeq);\n        if (nbSeq) return ERROR(corruption_detected);\n        /* save reps for next block */\n        { U32 i; for (i=0; i<ZSTD_REP_NUM; i++) dctx->entropy.rep[i] = (U32)(seqState.prevOffset[i]); }\n    }\n\n    /* last literal segment */\n    {   size_t const lastLLSize = litEnd - litPtr;\n        if (lastLLSize > (size_t)(oend-op)) return ERROR(dstSize_tooSmall);\n        memcpy(op, litPtr, lastLLSize);\n        op += lastLLSize;\n    }\n\n    return op-ostart;\n}\n\n\nHINT_INLINE\nseq_t ZSTD_decodeSequenceLong(seqState_t* seqState, ZSTD_longOffset_e const longOffsets)\n{\n    seq_t seq;\n\n    U32 const llCode = FSE_peekSymbol(&seqState->stateLL);\n    U32 const mlCode = FSE_peekSymbol(&seqState->stateML);\n    U32 const ofCode = FSE_peekSymbol(&seqState->stateOffb);   /* <= MaxOff, by table construction */\n\n    U32 const llBits = LL_bits[llCode];\n    U32 const mlBits = ML_bits[mlCode];\n    U32 const ofBits = ofCode;\n    U32 const totalBits = llBits+mlBits+ofBits;\n\n    static const U32 LL_base[MaxLL+1] = {\n                             0,  1,    2,     3,     4,     5,     6,      7,\n                             8,  9,   10,    11,    12,    13,    14,     15,\n                            16, 18,   20,    22,    24,    28,    32,     40,\n                            48, 64, 0x80, 0x100, 0x200, 0x400, 0x800, 0x1000,\n                            0x2000, 0x4000, 0x8000, 0x10000 };\n\n    static const U32 ML_base[MaxML+1] = {\n                             3,  4,  5,    6,     7,     8,     9,    10,\n                            11, 12, 13,   14,    15,    16,    17,    18,\n                            19, 20, 21,   22,    23,    24,    25,    26,\n                            27, 28, 29,   30,    31,    32,    33,    34,\n                            35, 37, 39,   41,    43,    47,    51,    59,\n                            67, 83, 99, 0x83, 0x103, 0x203, 0x403, 0x803,\n                            0x1003, 0x2003, 0x4003, 0x8003, 0x10003 };\n\n    static const U32 OF_base[MaxOff+1] = {\n                     0,        1,       1,       5,     0xD,     0x1D,     0x3D,     0x7D,\n                     0xFD,   0x1FD,   0x3FD,   0x7FD,   0xFFD,   0x1FFD,   0x3FFD,   0x7FFD,\n                     0xFFFD, 0x1FFFD, 0x3FFFD, 0x7FFFD, 0xFFFFD, 0x1FFFFD, 0x3FFFFD, 0x7FFFFD,\n                     0xFFFFFD, 0x1FFFFFD, 0x3FFFFFD, 0x7FFFFFD, 0xFFFFFFD, 0x1FFFFFFD, 0x3FFFFFFD, 0x7FFFFFFD };\n\n    /* sequence */\n    {   size_t offset;\n        if (!ofCode)\n            offset = 0;\n        else {\n            ZSTD_STATIC_ASSERT(ZSTD_lo_isLongOffset == 1);\n            ZSTD_STATIC_ASSERT(LONG_OFFSETS_MAX_EXTRA_BITS_32 == 5);\n            assert(ofBits <= MaxOff);\n            if (MEM_32bits() && longOffsets) {\n                U32 const extraBits = ofBits - MIN(ofBits, STREAM_ACCUMULATOR_MIN_32-1);\n                offset = OF_base[ofCode] + (BIT_readBitsFast(&seqState->DStream, ofBits - extraBits) << extraBits);\n                if (MEM_32bits() || extraBits) BIT_reloadDStream(&seqState->DStream);\n                if (extraBits) offset += BIT_readBitsFast(&seqState->DStream, extraBits);\n            } else {\n                offset = OF_base[ofCode] + BIT_readBitsFast(&seqState->DStream, ofBits);   /* <=  (ZSTD_WINDOWLOG_MAX-1) bits */\n                if (MEM_32bits()) BIT_reloadDStream(&seqState->DStream);\n            }\n        }\n\n        if (ofCode <= 1) {\n            offset += (llCode==0);\n            if (offset) {\n                size_t temp = (offset==3) ? seqState->prevOffset[0] - 1 : seqState->prevOffset[offset];\n                temp += !temp;   /* 0 is not valid; input is corrupted; force offset to 1 */\n                if (offset != 1) seqState->prevOffset[2] = seqState->prevOffset[1];\n                seqState->prevOffset[1] = seqState->prevOffset[0];\n                seqState->prevOffset[0] = offset = temp;\n            } else {\n                offset = seqState->prevOffset[0];\n            }\n        } else {\n            seqState->prevOffset[2] = seqState->prevOffset[1];\n            seqState->prevOffset[1] = seqState->prevOffset[0];\n            seqState->prevOffset[0] = offset;\n        }\n        seq.offset = offset;\n    }\n\n    seq.matchLength = ML_base[mlCode] + ((mlCode>31) ? BIT_readBitsFast(&seqState->DStream, mlBits) : 0);  /* <=  16 bits */\n    if (MEM_32bits() && (mlBits+llBits >= STREAM_ACCUMULATOR_MIN_32-LONG_OFFSETS_MAX_EXTRA_BITS_32))\n        BIT_reloadDStream(&seqState->DStream);\n    if (MEM_64bits() && (totalBits >= STREAM_ACCUMULATOR_MIN_64-(LLFSELog+MLFSELog+OffFSELog)))\n        BIT_reloadDStream(&seqState->DStream);\n    /* Verify that there is enough bits to read the rest of the data in 64-bit mode. */\n    ZSTD_STATIC_ASSERT(16+LLFSELog+MLFSELog+OffFSELog < STREAM_ACCUMULATOR_MIN_64);\n\n    seq.litLength = LL_base[llCode] + ((llCode>15) ? BIT_readBitsFast(&seqState->DStream, llBits) : 0);    /* <=  16 bits */\n    if (MEM_32bits())\n        BIT_reloadDStream(&seqState->DStream);\n\n    {   size_t const pos = seqState->pos + seq.litLength;\n        const BYTE* const matchBase = (seq.offset > pos) ? seqState->dictEnd : seqState->prefixStart;\n        seq.match = matchBase + pos - seq.offset;  /* note : this operation can overflow when seq.offset is really too large, which can only happen when input is corrupted.\n                                                    * No consequence though : no memory access will occur, overly large offset will be detected in ZSTD_execSequenceLong() */\n        seqState->pos = pos + seq.matchLength;\n    }\n\n    /* ANS state update */\n    FSE_updateState(&seqState->stateLL, &seqState->DStream);    /* <=  9 bits */\n    FSE_updateState(&seqState->stateML, &seqState->DStream);    /* <=  9 bits */\n    if (MEM_32bits()) BIT_reloadDStream(&seqState->DStream);    /* <= 18 bits */\n    FSE_updateState(&seqState->stateOffb, &seqState->DStream);  /* <=  8 bits */\n\n    return seq;\n}\n\n",
        "res_region": "",
        "lookback": "size_t ZSTD_execSequenceLong(BYTE* op,",
        "lookahead": "HINT_INLINE",
        "label": [
            "base",
            "base_empty"
        ],
        "start_line": 1152,
        "end_line": 1481,
        "merge_gen_region": null,
        "confidence": 0.8794346451759338,
        "hesitated": true
    },
    {
        "a_contents": "static size_t ZSTD_decompressSequencesLong(\n                               ZSTD_DCtx* dctx,\n                               void* dst, size_t maxDstSize,\n                         const void* seqStart, size_t seqSize, int nbSeq,\n                         const ZSTD_longOffset_e isLongOffset)\n{\n    const BYTE* ip = (const BYTE*)seqStart;\n    const BYTE* const iend = ip + seqSize;\n    BYTE* const ostart = (BYTE* const)dst;\n    BYTE* const oend = ostart + maxDstSize;\n    BYTE* op = ostart;\n    const BYTE* litPtr = dctx->litPtr;\n    const BYTE* const litEnd = litPtr + dctx->litSize;\n    const BYTE* const prefixStart = (const BYTE*) (dctx->base);\n    const BYTE* const dictStart = (const BYTE*) (dctx->vBase);\n    const BYTE* const dictEnd = (const BYTE*) (dctx->dictEnd);",
        "b_contents": "typedef enum { ZSTD_lo_isRegularOffset, ZSTD_lo_isLongOffset=1 } ZSTD_longOffset_e;",
        "base_contents": "static size_t ZSTD_decompressSequencesLong(\n                               ZSTD_DCtx* dctx,\n                               void* dst, size_t maxDstSize,\n                         const void* seqStart, size_t seqSize,\n                         const ZSTD_longOffset_e isLongOffset)\n{\n    const BYTE* ip = (const BYTE*)seqStart;\n    const BYTE* const iend = ip + seqSize;\n    BYTE* const ostart = (BYTE* const)dst;\n    BYTE* const oend = ostart + maxDstSize;\n    BYTE* op = ostart;\n    const BYTE* litPtr = dctx->litPtr;\n    const BYTE* const litEnd = litPtr + dctx->litSize;\n    const BYTE* const prefixStart = (const BYTE*) (dctx->base);\n    const BYTE* const dictStart = (const BYTE*) (dctx->vBase);\n    const BYTE* const dictEnd = (const BYTE*) (dctx->dictEnd);\n    int nbSeq;\n\n    /* Build Decoding Tables */\n    {   size_t const seqHSize = ZSTD_decodeSeqHeaders(dctx, &nbSeq, ip, seqSize);\n        if (ZSTD_isError(seqHSize)) return seqHSize;\n        ip += seqHSize;\n    }",
        "res_region": "typedef enum { ZSTD_lo_isRegularOffset, ZSTD_lo_isLongOffset=1 } ZSTD_longOffset_e;",
        "lookback": "",
        "lookahead": "",
        "label": [
            "base",
            "complex_conflict"
        ],
        "start_line": 1561,
        "end_line": 1604,
        "merge_gen_region": null,
        "confidence": 0.7770431041717529,
        "hesitated": true
    },
    {
        "a_contents": "\n    /* Build Decoding Tables */\n    {   int nbSeq;\n        size_t const seqHSize = ZSTD_decodeSeqHeaders(dctx, &nbSeq, ip, srcSize);\n        if (ZSTD_isError(seqHSize)) return seqHSize;\n        ip += seqHSize;\n        srcSize -= seqHSize;\n\n        if (dctx->fParams.windowSize > (1<<24)) {\n            U32 const shareLongOffsets = ZSTD_getLongOffsetsShare(dctx->OFTptr);\n            U32 const minShare = MEM_64bits() ? 5 : 13;\n            if (shareLongOffsets >= minShare)\n                return ZSTD_decompressSequencesLong(dctx, dst, dstCapacity, ip, srcSize, nbSeq, isLongOffset);\n        }\n\n        return ZSTD_decompressSequences(dctx, dst, dstCapacity, ip, srcSize, nbSeq, isLongOffset);\n    }",
        "b_contents": "\n    if ( frame /* windowSize exists */\n      && (dctx->fParams.windowSize > (1<<24))\n      && MEM_64bits() /* x86 benefits less from long mode than x64 */ )\n        return ZSTD_decompressSequencesLong(dctx, dst, dstCapacity, ip, srcSize, isLongOffset);\n\n    return ZSTD_decompressSequences(dctx, dst, dstCapacity, ip, srcSize, isLongOffset);",
        "base_contents": "    if ( frame /* windowSize exists */\n      && (dctx->fParams.windowSize > (1<<24))\n      && MEM_64bits() /* x86 benefits less from long mode than x64 */ )\n        return ZSTD_decompressSequencesLong(dctx, dst, dstCapacity, ip, srcSize, isLongOffset);\n    return ZSTD_decompressSequences(dctx, dst, dstCapacity, ip, srcSize, isLongOffset);",
        "res_region": "\n    if ( frame /* windowSize exists */\n      && (dctx->fParams.windowSize > (1<<24))\n      && MEM_64bits() /* x86 benefits less from long mode than x64 */ )\n        return ZSTD_decompressSequencesLong(dctx, dst, dstCapacity, ip, srcSize, isLongOffset);\n\n    return ZSTD_decompressSequences(dctx, dst, dstCapacity, ip, srcSize, isLongOffset);",
        "lookback": "    if ( frame /* windowSize exists */",
        "lookahead": "}",
        "label": [
            "theirs",
            "base_underutilized"
        ],
        "start_line": 1691,
        "end_line": 1723,
        "merge_gen_region": null,
        "confidence": 0.8476371765136719,
        "hesitated": true
    }
]