[
    {
        "a_contents": "    \n    const U32 maxSearches = 1U << ctx->params.searchLog;\n    const U32 sufficient_len = ctx->params.targetLength;\n    const U32 mls = ctx->params.searchLength;\n    const U32 minMatch = (ctx->params.searchLength == 3) ? 3 : 4;",
        "b_contents": "\n    U32 rep_2=REPCODE_STARTVALUE, rep_1=REPCODE_STARTVALUE;\n    const U32 maxSearches = 1U << ctx->params.cParams.searchLog;\n    const U32 sufficient_len = ctx->params.cParams.targetLength;\n    const U32 mls = ctx->params.cParams.searchLength;\n    const U32 minMatch = (ctx->params.cParams.searchLength == 3) ? 3 : 4;",
        "base_contents": "    \n    U32 rep_2=REPCODE_STARTVALUE, rep_1=REPCODE_STARTVALUE;\n    const U32 maxSearches = 1U << ctx->params.searchLog;\n    const U32 sufficient_len = ctx->params.targetLength;\n    const U32 mls = ctx->params.searchLength;\n    const U32 minMatch = (ctx->params.searchLength == 3) ? 3 : 4;",
        "res_region": "\n    const U32 maxSearches = 1U << ctx->params.cParams.searchLog;\n    const U32 sufficient_len = ctx->params.cParams.targetLength;\n    const U32 mls = ctx->params.cParams.searchLength;\n    const U32 minMatch = (ctx->params.cParams.searchLength == 3) ? 3 : 4;",
        "lookback": "    const U32 maxSearches = 1U << ctx->params.cParams.searchLog;",
        "lookahead": "",
        "label": [
            "interleave",
            "complex_conflict"
        ],
        "start_line": 435,
        "end_line": 455,
        "merge_gen_region": null,
        "confidence": 0.8035547137260437,
        "hesitated": true
    },
    {
        "a_contents": "    (void)ctx; (void)src; (void)srcSize; (void)depth;\n    (void)ZSTD_BtGetAllMatches_selectMLS_extDict;\n    printf(\"ZSTD_compressBlock_opt_extDict_generic\\n\"), exit(0);",
        "b_contents": "    seqStore_t* seqStorePtr = &(ctx->seqStore);\n    const BYTE* const istart = (const BYTE*)src;\n    const BYTE* ip = istart;\n    const BYTE* anchor = istart;\n    const BYTE* litstart;\n    const BYTE* const iend = istart + srcSize;\n    const BYTE* const ilimit = iend - 8;\n    const BYTE* const base = ctx->base;\n    const U32 dictLimit = ctx->dictLimit;\n    const BYTE* const prefixStart = base + dictLimit;\n    const BYTE* const dictBase = ctx->dictBase;\n    const BYTE* const dictEnd  = dictBase + dictLimit;\n    const U32 lowLimit = ctx->lowLimit;\n\n    U32 rep_2=REPCODE_STARTVALUE, rep_1=REPCODE_STARTVALUE;\n    const U32 maxSearches = 1U << ctx->params.cParams.searchLog;\n    const U32 sufficient_len = ctx->params.cParams.targetLength;\n    const U32 mls = ctx->params.cParams.searchLength;\n    const U32 minMatch = (ctx->params.cParams.searchLength == 3) ? 3 : 4;\n\n    ZSTD_optimal_t* opt = seqStorePtr->priceTable;\n    ZSTD_match_t* matches = seqStorePtr->matchTable;\n    const BYTE* inr;\n    U32 cur, match_num, last_pos, litlen, price;\n\n    /* init */\n    ctx->nextToUpdate3 = ctx->nextToUpdate;\n    ZSTD_resetSeqStore(seqStorePtr);\n    ZSTD_rescaleFreqs(seqStorePtr);\n    if ((ip - prefixStart) < REPCODE_STARTVALUE) ip += REPCODE_STARTVALUE;\n\n    ZSTD_LOG_BLOCK(\"%d: COMPBLOCK_OPT_EXTDICT srcSz=%d maxSrch=%d mls=%d sufLen=%d\\n\", (int)(ip-base), (int)srcSize, maxSearches, mls, sufficient_len);\n\n    /* Match Loop */\n    while (ip < ilimit) {\n        U32 u, offset, best_off=0;\n        U32 mlen=0, best_mlen=0;\n        U32 current = (U32)(ip-base);\n        memset(opt, 0, sizeof(ZSTD_optimal_t));\n        last_pos = 0;\n        inr = ip;\n        litstart = ((U32)(ip - anchor) > 128) ? ip - 128 : anchor;\n        opt[0].litlen = (U32)(ip - litstart);\n\n        /* check repCode */\n        {\n            const U32 repIndex = (U32)(current+1 - rep_1);\n            const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;\n            const BYTE* const repMatch = repBase + repIndex;\n            if ( ((U32)((dictLimit-1) - repIndex) >= 3)   /* intentional overflow */\n               && (MEM_readMINMATCH(ip+1, minMatch) == MEM_readMINMATCH(repMatch, minMatch)) ) {\n                /* repcode detected we should take it */\n                const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;\n                mlen = (U32)ZSTD_count_2segments(ip+1+minMatch, repMatch+minMatch, iend, repEnd, prefixStart) + minMatch;\n\n                ZSTD_LOG_PARSER(\"%d: start try REP rep=%d mlen=%d\\n\", (int)(ip-base), (int)rep_1, (int)mlen);\n                if (depth==0 || mlen > sufficient_len || mlen >= ZSTD_OPT_NUM) {\n                    ip+=1; best_mlen = mlen; best_off = 0; cur = 0; last_pos = 1;\n                    goto _storeSequence;\n                }\n\n                litlen = opt[0].litlen + 1;\n                do {\n                    price = ZSTD_getPrice(seqStorePtr, litlen, litstart, 0, mlen - minMatch);\n                    if (mlen + 1 > last_pos || price < opt[mlen + 1].price)\n                        SET_PRICE(mlen + 1, mlen, 0, litlen, price);\n                    mlen--;\n                } while (mlen >= minMatch);\n        }   }\n\n       best_mlen = (last_pos) ? last_pos : minMatch;\n\n       match_num = ZSTD_BtGetAllMatches_selectMLS_extDict(ctx, ip, iend, maxSearches, mls, matches);  /* first search (depth 0) */\n\n       ZSTD_LOG_PARSER(\"%d: match_num=%d last_pos=%d\\n\", (int)(ip-base), match_num, last_pos);\n       if (!last_pos && !match_num) { ip++; continue; }\n\n       opt[0].rep = rep_1;\n       opt[0].rep2 = rep_2;\n       opt[0].mlen = 1;\n\n       if (match_num && matches[match_num-1].len > sufficient_len) {\n            best_mlen = matches[match_num-1].len;\n            best_off = matches[match_num-1].off;\n            cur = 0;\n            last_pos = 1;\n            goto _storeSequence;\n       }\n\n        // set prices using matches at position = 0\n        for (u = 0; u < match_num; u++) {\n            mlen = (u>0) ? matches[u-1].len+1 : best_mlen;\n            best_mlen = (matches[u].len < ZSTD_OPT_NUM) ? matches[u].len : ZSTD_OPT_NUM;\n            ZSTD_LOG_PARSER(\"%d: start Found mlen=%d off=%d best_mlen=%d last_pos=%d\\n\", (int)(ip-base), matches[u].len, matches[u].off, (int)best_mlen, (int)last_pos);\n            litlen = opt[0].litlen;\n            while (mlen <= best_mlen) {\n                price = ZSTD_getPrice(seqStorePtr, litlen, litstart, matches[u].off, mlen - minMatch);\n                if (mlen > last_pos || price < opt[mlen].price)\n                    SET_PRICE(mlen, mlen, matches[u].off, litlen, price);\n                mlen++;\n        }   }\n\n        if (last_pos < minMatch) {\n            // ip += ((ip-anchor) >> g_searchStrength) + 1;   /* jump faster over incompressible sections */\n            ip++; continue;\n        }\n\n        /* check further positions */\n        for (cur = 1; cur <= last_pos; cur++) {\n           size_t cur_rep;\n           inr = ip + cur;\n\n           if (opt[cur-1].mlen == 1) {\n                litlen = opt[cur-1].litlen + 1;\n                if (cur > litlen) {\n                    price = opt[cur - litlen].price + ZSTD_getLiteralPrice(seqStorePtr, litlen, inr-litlen);\n                } else\n                    price = ZSTD_getLiteralPrice(seqStorePtr, litlen, litstart);\n           } else {\n                litlen = 1;\n                price = opt[cur - 1].price + ZSTD_getLiteralPrice(seqStorePtr, litlen, inr-1);\n           }\n\n           if (cur > last_pos || price <= opt[cur].price) // || ((price == opt[cur].price) && (opt[cur-1].mlen == 1) && (cur != litlen)))\n                SET_PRICE(cur, 1, 0, litlen, price);\n\n           if (cur == last_pos) break;\n\n           if (inr > ilimit) // last match must start at a minimum distance of 8 from oend\n               continue;\n\n           mlen = opt[cur].mlen;\n\n           if (opt[cur].off) {\n                opt[cur].rep2 = opt[cur-mlen].rep;\n                opt[cur].rep = opt[cur].off;\n                ZSTD_LOG_ENCODE(\"%d: COPYREP_OFF cur=%d mlen=%d rep=%d rep2=%d\\n\", (int)(inr-base), cur, mlen, opt[cur].rep, opt[cur].rep2);\n           } else {\n                if (cur!=mlen && opt[cur].litlen == 0) {\n                    opt[cur].rep2 = opt[cur-mlen].rep;\n                    opt[cur].rep = opt[cur-mlen].rep2;\n                    ZSTD_LOG_ENCODE(\"%d: COPYREP_SWI cur=%d mlen=%d rep=%d rep2=%d\\n\", (int)(inr-base), cur, mlen, opt[cur].rep, opt[cur].rep2);\n                } else {\n                    opt[cur].rep2 = opt[cur-mlen].rep2;\n                    opt[cur].rep = opt[cur-mlen].rep;\n                    ZSTD_LOG_ENCODE(\"%d: COPYREP_NOR cur=%d mlen=%d rep=%d rep2=%d\\n\", (int)(inr-base), cur, mlen, opt[cur].rep, opt[cur].rep2);\n           }   }\n\n           ZSTD_LOG_PARSER(\"%d: CURRENT_Ext price[%d/%d]=%d off=%d mlen=%d litlen=%d rep=%d rep2=%d\\n\", (int)(inr-base), cur, last_pos, opt[cur].price, opt[cur].off, opt[cur].mlen, opt[cur].litlen, opt[cur].rep, opt[cur].rep2);\n\n           best_mlen = 0;\n\n           if (opt[cur].mlen != 1) {\n               cur_rep = opt[cur].rep2;\n               ZSTD_LOG_PARSER(\"%d: tryExt REP2 rep2=%u mlen=%u\\n\", (int)(inr-base), (U32)cur_rep, mlen);\n           } else {\n               cur_rep = opt[cur].rep;\n               ZSTD_LOG_PARSER(\"%d: tryExt REP1 rep=%u mlen=%u\\n\", (int)(inr-base), (U32)cur_rep, mlen);\n           }\n\n           const U32 repIndex = (U32)(current+cur - cur_rep);\n           const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;\n           const BYTE* const repMatch = repBase + repIndex;\n           if ( ((U32)((dictLimit-1) - repIndex) >= 3)   /* intentional overflow */\n              && (MEM_readMINMATCH(inr, minMatch) == MEM_readMINMATCH(repMatch, minMatch)) ) {\n                /* repcode detected */\n                const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;\n                mlen = (U32)ZSTD_count_2segments(inr+minMatch, repMatch+minMatch, iend, repEnd, prefixStart) + minMatch;\n                ZSTD_LOG_PARSER(\"%d: Found REP mlen=%d off=%d rep=%d opt[%d].off=%d\\n\", (int)(inr-base), mlen, 0, opt[cur].rep, cur, opt[cur].off);\n\n                if (mlen > sufficient_len || cur + mlen >= ZSTD_OPT_NUM) {\n                    best_mlen = mlen;\n                    best_off = 0;\n                    ZSTD_LOG_PARSER(\"%d: REP sufficient_len=%d best_mlen=%d best_off=%d last_pos=%d\\n\", (int)(inr-base), sufficient_len, best_mlen, best_off, last_pos);\n                    last_pos = cur + 1;\n                    goto _storeSequence;\n                }\n\n                if (opt[cur].mlen == 1) {\n                    litlen = opt[cur].litlen;\n                    if (cur > litlen) {\n                        price = opt[cur - litlen].price + ZSTD_getPrice(seqStorePtr, litlen, inr-litlen, 0, mlen - minMatch);\n                    } else\n                        price = ZSTD_getPrice(seqStorePtr, litlen, litstart, 0, mlen - minMatch);\n                } else {\n                    litlen = 0;\n                    price = opt[cur].price + ZSTD_getPrice(seqStorePtr, 0, NULL, 0, mlen - minMatch);\n                }\n\n                best_mlen = mlen;\n\n                ZSTD_LOG_PARSER(\"%d: Found REP mlen=%d off=%d price=%d litlen=%d\\n\", (int)(inr-base), mlen, 0, price, litlen);\n\n                do {\n                    if (cur + mlen > last_pos || price <= opt[cur + mlen].price) // || ((price == opt[cur + mlen].price) && (opt[cur].mlen == 1) && (cur != litlen))) // at equal price prefer REP instead of MATCH\n                        SET_PRICE(cur + mlen, mlen, 0, litlen, price);\n                    mlen--;\n                } while (mlen >= minMatch);\n            }\n\n            best_mlen = (best_mlen > minMatch) ? best_mlen : minMatch;\n\n            match_num = ZSTD_BtGetAllMatches_selectMLS_extDict(ctx, inr, iend, maxSearches, mls, matches);\n            ZSTD_LOG_PARSER(\"%d: ZSTD_GetAllMatches match_num=%d\\n\", (int)(inr-base), match_num);\n\n            if (match_num > 0 && matches[match_num-1].len > sufficient_len) {\n                best_mlen = matches[match_num-1].len;\n                best_off = matches[match_num-1].off;\n                last_pos = cur + 1;\n                goto _storeSequence;\n            }\n\n            // set prices using matches at position = cur\n            for (u = 0; u < match_num; u++) {\n                mlen = (u>0) ? matches[u-1].len+1 : best_mlen;\n                best_mlen = (cur + matches[u].len < ZSTD_OPT_NUM) ? matches[u].len : ZSTD_OPT_NUM - cur;\n\n            //    ZSTD_LOG_PARSER(\"%d: Found1 cur=%d mlen=%d off=%d best_mlen=%d last_pos=%d\\n\", (int)(inr-base), cur, matches[u].len, matches[u].off, best_mlen, last_pos);\n\n                while (mlen <= best_mlen) {\n                    if (opt[cur].mlen == 1) {\n                        litlen = opt[cur].litlen;\n                        if (cur > litlen)\n                            price = opt[cur - litlen].price + ZSTD_getPrice(seqStorePtr, litlen, ip+cur-litlen, matches[u].off, mlen - minMatch);\n                        else\n                            price = ZSTD_getPrice(seqStorePtr, litlen, litstart, matches[u].off, mlen - minMatch);\n                    } else {\n                        litlen = 0;\n                        price = opt[cur].price + ZSTD_getPrice(seqStorePtr, 0, NULL, matches[u].off, mlen - minMatch);\n                    }\n\n                //    ZSTD_LOG_PARSER(\"%d: Found2 mlen=%d best_mlen=%d off=%d price=%d litlen=%d\\n\", (int)(inr-base), mlen, best_mlen, matches[u].off, price, litlen);\n\n                    if (cur + mlen > last_pos || (price < opt[cur + mlen].price))\n                        SET_PRICE(cur + mlen, mlen, matches[u].off, litlen, price);\n\n                    mlen++;\n        }   }   }   //  for (cur = 1; cur <= last_pos; cur++)\n\n        best_mlen = opt[last_pos].mlen;\n        best_off = opt[last_pos].off;\n        cur = last_pos - best_mlen;\n\n        /* store sequence */\n_storeSequence: // cur, last_pos, best_mlen, best_off have to be set\n        for (u = 1; u <= last_pos; u++)\n            ZSTD_LOG_PARSER(\"%d: price[%u/%d]=%d off=%d mlen=%d litlen=%d rep=%d rep2=%d\\n\", (int)(ip-base+u), u, last_pos, opt[u].price, opt[u].off, opt[u].mlen, opt[u].litlen, opt[u].rep, opt[u].rep2);\n        ZSTD_LOG_PARSER(\"%d: cur=%d/%d best_mlen=%d best_off=%d rep=%d\\n\", (int)(ip-base+cur), (int)cur, (int)last_pos, (int)best_mlen, (int)best_off, opt[cur].rep);\n\n        opt[0].mlen = 1;\n\n        while (1) {\n            mlen = opt[cur].mlen;\n            offset = opt[cur].off;\n            opt[cur].mlen = best_mlen;\n            opt[cur].off = best_off;\n            best_mlen = mlen;\n            best_off = offset;\n            if (mlen > cur) break;\n            cur -= mlen;\n        }\n\n        for (u = 0; u <= last_pos; ) {\n            ZSTD_LOG_PARSER(\"%d: price2[%d/%d]=%d off=%d mlen=%d litlen=%d rep=%d rep2=%d\\n\", (int)(ip-base+u), u, last_pos, opt[u].price, opt[u].off, opt[u].mlen, opt[u].litlen, opt[u].rep, opt[u].rep2);\n            u += opt[u].mlen;\n        }\n\n        for (cur=0; cur < last_pos; ) {\n            U32 litLength;\n            ZSTD_LOG_PARSER(\"%d: price3[%d/%d]=%d off=%d mlen=%d litlen=%d rep=%d rep2=%d\\n\", (int)(ip-base+cur), cur, last_pos, opt[cur].price, opt[cur].off, opt[cur].mlen, opt[cur].litlen, opt[cur].rep, opt[cur].rep2);\n            mlen = opt[cur].mlen;\n            if (mlen == 1) { ip++; cur++; continue; }\n            offset = opt[cur].off;\n            cur += mlen;\n\n            litLength = (U32)(ip - anchor);\n            ZSTD_LOG_ENCODE(\"%d/%d: ENCODE1 literals=%d mlen=%d off=%d rep1=%d rep2=%d\\n\", (int)(ip-base), (int)(iend-base), (int)(litLength), (int)mlen, (int)(offset), (int)rep_1, (int)rep_2);\n\n            if (offset) {\n                rep_2 = rep_1;\n                rep_1 = offset;\n            } else {\n                if (litLength == 0) {\n                    best_off = rep_2;\n                    rep_2 = rep_1;\n                    rep_1 = best_off;\n            }   }\n\n            ZSTD_LOG_ENCODE(\"%d/%d: ENCODE2 literals=%d mlen=%d off=%d rep1=%d rep2=%d\\n\", (int)(ip-base), (int)(iend-base), (int)(litLength), (int)mlen, (int)(offset), (int)rep_1, (int)rep_2);\n\n#if ZSTD_OPT_DEBUG >= 5\n            U32 ml2;\n            if (offset) {\n                if (offset > (size_t)(ip - prefixStart))  {\n                    const BYTE* match = dictEnd - (offset - (ip - prefixStart));\n                    ml2 = ZSTD_count_2segments(ip, match, iend, dictEnd, prefixStart);\n                    ZSTD_LOG_PARSER(\"%d: ZSTD_count_2segments=%d offset=%d dictBase=%p dictEnd=%p prefixStart=%p ip=%p match=%p\\n\", (int)current, (int)ml2, (int)offset, dictBase, dictEnd, prefixStart, ip, match);\n                }\n                else ml2 = (U32)ZSTD_count(ip, ip-offset, iend);\n            }\n            else ml2 = (U32)ZSTD_count(ip, ip-rep_1, iend);\n            if ((offset >= 8) && (ml2 < mlen || ml2 < minMatch)) {\n                printf(\"%d: ERROR_Ext iend=%d mlen=%d offset=%d ml2=%d\\n\", (int)(ip - base), (int)(iend - ip), (int)mlen, (int)offset, (int)ml2); exit(0); }\n            if (ip < anchor) {\n                printf(\"%d: ERROR_Ext ip < anchor iend=%d mlen=%d offset=%d\\n\", (int)(ip - base), (int)(iend - ip), (int)mlen, (int)offset); exit(0); }\n            if (ip + mlen > iend) {\n                printf(\"%d: ERROR_Ext ip + mlen >= iend iend=%d mlen=%d offset=%d\\n\", (int)(ip - base), (int)(iend - ip), (int)mlen, (int)offset); exit(0); }\n#endif\n\n            ZSTD_updatePrice(seqStorePtr, litLength, anchor, offset, mlen-minMatch);\n            ZSTD_storeSeq(seqStorePtr, litLength, anchor, offset, mlen-minMatch);\n            anchor = ip = ip + mlen;\n        }\n\n#if 0\n        /* check immediate repcode */\n        while ((anchor >= base + lowLimit + rep_2) && (anchor <= ilimit)) {\n            if ((anchor - rep_2) >= prefixStart) {\n                if (MEM_readMINMATCH(anchor, minMatch) == MEM_readMINMATCH(anchor - rep_2, minMatch))\n                    mlen = (U32)ZSTD_count(anchor+minMatch, anchor - rep_2 + minMatch, iend) + minMatch;\n                else\n                    break;\n            } else {\n                const BYTE* repMatch = dictBase + ((anchor-base) - rep_2);\n                if ((repMatch + minMatch <= dictEnd) && (MEM_readMINMATCH(anchor, minMatch) == MEM_readMINMATCH(repMatch, minMatch)))\n                    mlen = (U32)ZSTD_count_2segments(anchor+minMatch, repMatch+minMatch, iend, dictEnd, prefixStart) + minMatch;\n                else\n                    break;\n            }\n\n            offset = rep_2; rep_2 = rep_1; rep_1 = offset;   /* swap offset history */\n            ZSTD_LOG_ENCODE(\"%d/%d: ENCODE REP literals=%d mlen=%d off=%d rep1=%d rep2=%d\\n\", (int)(anchor-base), (int)(iend-base), (int)(0), (int)best_mlen, (int)(0), (int)rep_1, (int)rep_2);\n            ZSTD_updatePrice(seqStorePtr, 0, anchor, 0, mlen-minMatch);\n            ZSTD_storeSeq(seqStorePtr, 0, anchor, 0, mlen-minMatch);\n            anchor += mlen;\n        }\n#else\n        /* check immediate repcode */\n        /* minimal correctness condition = while ((anchor >= prefixStart + REPCODE_STARTVALUE) && (anchor <= ilimit)) { */\n        while ((anchor >= base + lowLimit + rep_2) && (anchor <= ilimit)) {\n            const U32 repIndex = (U32)((anchor-base) - rep_2);\n            const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;\n            const BYTE* const repMatch = repBase + repIndex;\n            if ( ((U32)((dictLimit-1) - repIndex) >= 3)   /* intentional overflow */\n               && (MEM_readMINMATCH(anchor, minMatch) == MEM_readMINMATCH(repMatch, minMatch)) ) {\n                /* repcode detected, let's take it */\n                const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;\n                mlen = (U32)ZSTD_count_2segments(anchor+minMatch, repMatch+minMatch, iend, repEnd, prefixStart) + minMatch;\n                offset = rep_2; rep_2 = rep_1; rep_1 = offset;   /* swap offset history */\n                ZSTD_LOG_ENCODE(\"%d/%d: ENCODE REP literals=%d mlen=%d off=%d rep1=%d rep2=%d\\n\", (int)(anchor-base), (int)(iend-base), (int)(0), (int)best_mlen, (int)(0), (int)rep_1, (int)rep_2);\n                ZSTD_updatePrice(seqStorePtr, 0, anchor, 0, mlen-minMatch);\n                ZSTD_storeSeq(seqStorePtr, 0, anchor, 0, mlen-minMatch);\n                anchor += mlen;\n                continue;   /* faster when present ... (?) */\n            }\n            break;\n        }\n#endif\n        if (anchor > ip) ip = anchor;\n    }\n\n    {   /* Last Literals */\n        size_t lastLLSize = iend - anchor;\n        ZSTD_LOG_ENCODE(\"%d: lastLLSize literals=%u\\n\", (int)(ip-base), (U32)(lastLLSize));\n        memcpy(seqStorePtr->lit, anchor, lastLLSize);\n        seqStorePtr->lit += lastLLSize;\n    }",
        "base_contents": "    seqStore_t* seqStorePtr = &(ctx->seqStore);\n    const BYTE* const istart = (const BYTE*)src;\n    const BYTE* ip = istart;\n    const BYTE* anchor = istart;\n    const BYTE* litstart;\n    const BYTE* const iend = istart + srcSize;\n    const BYTE* const ilimit = iend - 8;\n    const BYTE* const base = ctx->base;\n    const U32 dictLimit = ctx->dictLimit;\n    const BYTE* const prefixStart = base + dictLimit;\n    const BYTE* const dictBase = ctx->dictBase;\n    const BYTE* const dictEnd  = dictBase + dictLimit;\n    const U32 lowLimit = ctx->lowLimit;\n   \n    U32 rep_2=REPCODE_STARTVALUE, rep_1=REPCODE_STARTVALUE;\n    const U32 maxSearches = 1U << ctx->params.searchLog;\n    const U32 sufficient_len = ctx->params.targetLength;\n    const U32 mls = ctx->params.searchLength;\n    const U32 minMatch = (ctx->params.searchLength == 3) ? 3 : 4;\n\n    ZSTD_optimal_t* opt = seqStorePtr->priceTable;\n    ZSTD_match_t* matches = seqStorePtr->matchTable;\n    const BYTE* inr;\n    U32 cur, match_num, last_pos, litlen, price;\n\n    /* init */\n    ctx->nextToUpdate3 = ctx->nextToUpdate;\n    ZSTD_resetSeqStore(seqStorePtr);\n    ZSTD_rescaleFreqs(seqStorePtr);\n    if ((ip - prefixStart) < REPCODE_STARTVALUE) ip += REPCODE_STARTVALUE;\n\n    ZSTD_LOG_BLOCK(\"%d: COMPBLOCK_OPT_EXTDICT srcSz=%d maxSrch=%d mls=%d sufLen=%d\\n\", (int)(ip-base), (int)srcSize, maxSearches, mls, sufficient_len);\n\n    /* Match Loop */\n    while (ip < ilimit) {\n        U32 u, offset, best_off=0;\n        U32 mlen=0, best_mlen=0;\n        U32 current = (U32)(ip-base);\n        memset(opt, 0, sizeof(ZSTD_optimal_t));\n        last_pos = 0;\n        inr = ip;\n        litstart = ((U32)(ip - anchor) > 128) ? ip - 128 : anchor;\n        opt[0].litlen = (U32)(ip - litstart);\n\n        /* check repCode */\n        {\n            const U32 repIndex = (U32)(current+1 - rep_1);\n            const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;\n            const BYTE* const repMatch = repBase + repIndex;\n            if ( ((U32)((dictLimit-1) - repIndex) >= 3)   /* intentional overflow */\n               && (MEM_readMINMATCH(ip+1, minMatch) == MEM_readMINMATCH(repMatch, minMatch)) ) {\n                /* repcode detected we should take it */\n                const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;\n                mlen = (U32)ZSTD_count_2segments(ip+1+minMatch, repMatch+minMatch, iend, repEnd, prefixStart) + minMatch;\n\n                ZSTD_LOG_PARSER(\"%d: start try REP rep=%d mlen=%d\\n\", (int)(ip-base), (int)rep_1, (int)mlen);\n                if (depth==0 || mlen > sufficient_len || mlen >= ZSTD_OPT_NUM) {\n                    ip+=1; best_mlen = mlen; best_off = 0; cur = 0; last_pos = 1;\n                    goto _storeSequence;\n                }\n\n                litlen = opt[0].litlen + 1;\n                do {\n                    price = ZSTD_getPrice(seqStorePtr, litlen, litstart, 0, mlen - minMatch);\n                    if (mlen + 1 > last_pos || price < opt[mlen + 1].price)\n                        SET_PRICE(mlen + 1, mlen, 0, litlen, price);\n                    mlen--;\n                } while (mlen >= minMatch);\n        }   }\n\n       best_mlen = (last_pos) ? last_pos : minMatch;\n\n       match_num = ZSTD_BtGetAllMatches_selectMLS_extDict(ctx, ip, iend, maxSearches, mls, matches);  /* first search (depth 0) */\n\n       ZSTD_LOG_PARSER(\"%d: match_num=%d last_pos=%d\\n\", (int)(ip-base), match_num, last_pos);\n       if (!last_pos && !match_num) { ip++; continue; }\n\n       opt[0].rep = rep_1;\n       opt[0].rep2 = rep_2;\n       opt[0].mlen = 1;\n\n       if (match_num && matches[match_num-1].len > sufficient_len) {\n            best_mlen = matches[match_num-1].len;\n            best_off = matches[match_num-1].off;\n            cur = 0;\n            last_pos = 1;\n            goto _storeSequence;\n       }\n\n        // set prices using matches at position = 0\n        for (u = 0; u < match_num; u++) {\n            mlen = (u>0) ? matches[u-1].len+1 : best_mlen;\n            best_mlen = (matches[u].len < ZSTD_OPT_NUM) ? matches[u].len : ZSTD_OPT_NUM;\n            ZSTD_LOG_PARSER(\"%d: start Found mlen=%d off=%d best_mlen=%d last_pos=%d\\n\", (int)(ip-base), matches[u].len, matches[u].off, (int)best_mlen, (int)last_pos);\n            litlen = opt[0].litlen;\n            while (mlen <= best_mlen) {\n                price = ZSTD_getPrice(seqStorePtr, litlen, litstart, matches[u].off, mlen - minMatch);\n                if (mlen > last_pos || price < opt[mlen].price)\n                    SET_PRICE(mlen, mlen, matches[u].off, litlen, price);\n                mlen++;\n        }   }\n\n        if (last_pos < minMatch) {\n            // ip += ((ip-anchor) >> g_searchStrength) + 1;   /* jump faster over incompressible sections */\n            ip++; continue;\n        }\n\n        /* check further positions */\n        for (cur = 1; cur <= last_pos; cur++) {\n           size_t cur_rep;\n           inr = ip + cur;\n\n           if (opt[cur-1].mlen == 1) {\n                litlen = opt[cur-1].litlen + 1;\n                if (cur > litlen) {\n                    price = opt[cur - litlen].price + ZSTD_getLiteralPrice(seqStorePtr, litlen, inr-litlen);\n                } else\n                    price = ZSTD_getLiteralPrice(seqStorePtr, litlen, litstart);\n           } else {\n                litlen = 1;\n                price = opt[cur - 1].price + ZSTD_getLiteralPrice(seqStorePtr, litlen, inr-1);\n           }\n\n           if (cur > last_pos || price <= opt[cur].price) // || ((price == opt[cur].price) && (opt[cur-1].mlen == 1) && (cur != litlen)))\n                SET_PRICE(cur, 1, 0, litlen, price);\n\n           if (cur == last_pos) break;\n\n           if (inr > ilimit) // last match must start at a minimum distance of 8 from oend\n               continue;\n\n           mlen = opt[cur].mlen;\n\n           if (opt[cur].off) {\n                opt[cur].rep2 = opt[cur-mlen].rep;\n                opt[cur].rep = opt[cur].off;\n                ZSTD_LOG_ENCODE(\"%d: COPYREP_OFF cur=%d mlen=%d rep=%d rep2=%d\\n\", (int)(inr-base), cur, mlen, opt[cur].rep, opt[cur].rep2);\n           } else {\n                if (cur!=mlen && opt[cur].litlen == 0) {\n                    opt[cur].rep2 = opt[cur-mlen].rep;\n                    opt[cur].rep = opt[cur-mlen].rep2;\n                    ZSTD_LOG_ENCODE(\"%d: COPYREP_SWI cur=%d mlen=%d rep=%d rep2=%d\\n\", (int)(inr-base), cur, mlen, opt[cur].rep, opt[cur].rep2);\n                } else {\n                    opt[cur].rep2 = opt[cur-mlen].rep2;\n                    opt[cur].rep = opt[cur-mlen].rep;\n                    ZSTD_LOG_ENCODE(\"%d: COPYREP_NOR cur=%d mlen=%d rep=%d rep2=%d\\n\", (int)(inr-base), cur, mlen, opt[cur].rep, opt[cur].rep2);\n           }   }\n\n           ZSTD_LOG_PARSER(\"%d: CURRENT_Ext price[%d/%d]=%d off=%d mlen=%d litlen=%d rep=%d rep2=%d\\n\", (int)(inr-base), cur, last_pos, opt[cur].price, opt[cur].off, opt[cur].mlen, opt[cur].litlen, opt[cur].rep, opt[cur].rep2);\n\n           best_mlen = 0;\n\n           if (opt[cur].mlen != 1) {\n               cur_rep = opt[cur].rep2;\n               ZSTD_LOG_PARSER(\"%d: tryExt REP2 rep2=%u mlen=%u\\n\", (int)(inr-base), (U32)cur_rep, mlen);\n           } else {\n               cur_rep = opt[cur].rep;\n               ZSTD_LOG_PARSER(\"%d: tryExt REP1 rep=%u mlen=%u\\n\", (int)(inr-base), (U32)cur_rep, mlen);\n           }\n\n           const U32 repIndex = (U32)(current+cur - cur_rep);\n           const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;\n           const BYTE* const repMatch = repBase + repIndex;\n           if ( ((U32)((dictLimit-1) - repIndex) >= 3)   /* intentional overflow */\n              && (MEM_readMINMATCH(inr, minMatch) == MEM_readMINMATCH(repMatch, minMatch)) ) {\n                /* repcode detected */\n                const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;\n                mlen = (U32)ZSTD_count_2segments(inr+minMatch, repMatch+minMatch, iend, repEnd, prefixStart) + minMatch;\n                ZSTD_LOG_PARSER(\"%d: Found REP mlen=%d off=%d rep=%d opt[%d].off=%d\\n\", (int)(inr-base), mlen, 0, opt[cur].rep, cur, opt[cur].off);\n\n                if (mlen > sufficient_len || cur + mlen >= ZSTD_OPT_NUM) {\n                    best_mlen = mlen;\n                    best_off = 0;\n                    ZSTD_LOG_PARSER(\"%d: REP sufficient_len=%d best_mlen=%d best_off=%d last_pos=%d\\n\", (int)(inr-base), sufficient_len, best_mlen, best_off, last_pos);\n                    last_pos = cur + 1;\n                    goto _storeSequence;\n                }\n\n                if (opt[cur].mlen == 1) {\n                    litlen = opt[cur].litlen;\n                    if (cur > litlen) {\n                        price = opt[cur - litlen].price + ZSTD_getPrice(seqStorePtr, litlen, inr-litlen, 0, mlen - minMatch);\n                    } else\n                        price = ZSTD_getPrice(seqStorePtr, litlen, litstart, 0, mlen - minMatch);\n                } else {\n                    litlen = 0;\n                    price = opt[cur].price + ZSTD_getPrice(seqStorePtr, 0, NULL, 0, mlen - minMatch);\n                }\n\n                best_mlen = mlen;\n\n                ZSTD_LOG_PARSER(\"%d: Found REP mlen=%d off=%d price=%d litlen=%d\\n\", (int)(inr-base), mlen, 0, price, litlen);\n\n                do {\n                    if (cur + mlen > last_pos || price <= opt[cur + mlen].price) // || ((price == opt[cur + mlen].price) && (opt[cur].mlen == 1) && (cur != litlen))) // at equal price prefer REP instead of MATCH\n                        SET_PRICE(cur + mlen, mlen, 0, litlen, price);\n                    mlen--;\n                } while (mlen >= minMatch);\n            }\n\n            best_mlen = (best_mlen > minMatch) ? best_mlen : minMatch;\n\n            match_num = ZSTD_BtGetAllMatches_selectMLS_extDict(ctx, inr, iend, maxSearches, mls, matches);\n            ZSTD_LOG_PARSER(\"%d: ZSTD_GetAllMatches match_num=%d\\n\", (int)(inr-base), match_num);\n\n            if (match_num > 0 && matches[match_num-1].len > sufficient_len) {\n                best_mlen = matches[match_num-1].len;\n                best_off = matches[match_num-1].off;\n                last_pos = cur + 1;\n                goto _storeSequence;\n            }\n\n            // set prices using matches at position = cur\n            for (u = 0; u < match_num; u++) {\n                mlen = (u>0) ? matches[u-1].len+1 : best_mlen;\n                best_mlen = (cur + matches[u].len < ZSTD_OPT_NUM) ? matches[u].len : ZSTD_OPT_NUM - cur;\n\n            //    ZSTD_LOG_PARSER(\"%d: Found1 cur=%d mlen=%d off=%d best_mlen=%d last_pos=%d\\n\", (int)(inr-base), cur, matches[u].len, matches[u].off, best_mlen, last_pos);\n\n                while (mlen <= best_mlen) {\n                    if (opt[cur].mlen == 1) {\n                        litlen = opt[cur].litlen;\n                        if (cur > litlen)\n                            price = opt[cur - litlen].price + ZSTD_getPrice(seqStorePtr, litlen, ip+cur-litlen, matches[u].off, mlen - minMatch);\n                        else\n                            price = ZSTD_getPrice(seqStorePtr, litlen, litstart, matches[u].off, mlen - minMatch);\n                    } else {\n                        litlen = 0;\n                        price = opt[cur].price + ZSTD_getPrice(seqStorePtr, 0, NULL, matches[u].off, mlen - minMatch);\n                    }\n\n                //    ZSTD_LOG_PARSER(\"%d: Found2 mlen=%d best_mlen=%d off=%d price=%d litlen=%d\\n\", (int)(inr-base), mlen, best_mlen, matches[u].off, price, litlen);\n\n                    if (cur + mlen > last_pos || (price < opt[cur + mlen].price))\n                        SET_PRICE(cur + mlen, mlen, matches[u].off, litlen, price);\n\n                    mlen++;\n        }   }   }   //  for (cur = 1; cur <= last_pos; cur++)\n\n        best_mlen = opt[last_pos].mlen;\n        best_off = opt[last_pos].off;\n        cur = last_pos - best_mlen;\n\n        /* store sequence */\n_storeSequence: // cur, last_pos, best_mlen, best_off have to be set\n        for (u = 1; u <= last_pos; u++)\n            ZSTD_LOG_PARSER(\"%d: price[%u/%d]=%d off=%d mlen=%d litlen=%d rep=%d rep2=%d\\n\", (int)(ip-base+u), u, last_pos, opt[u].price, opt[u].off, opt[u].mlen, opt[u].litlen, opt[u].rep, opt[u].rep2);\n        ZSTD_LOG_PARSER(\"%d: cur=%d/%d best_mlen=%d best_off=%d rep=%d\\n\", (int)(ip-base+cur), (int)cur, (int)last_pos, (int)best_mlen, (int)best_off, opt[cur].rep);\n\n        opt[0].mlen = 1;\n\n        while (1) {\n            mlen = opt[cur].mlen;\n            offset = opt[cur].off;\n            opt[cur].mlen = best_mlen;\n            opt[cur].off = best_off;\n            best_mlen = mlen;\n            best_off = offset;\n            if (mlen > cur) break;\n            cur -= mlen;\n        }\n\n        for (u = 0; u <= last_pos; ) {\n            ZSTD_LOG_PARSER(\"%d: price2[%d/%d]=%d off=%d mlen=%d litlen=%d rep=%d rep2=%d\\n\", (int)(ip-base+u), u, last_pos, opt[u].price, opt[u].off, opt[u].mlen, opt[u].litlen, opt[u].rep, opt[u].rep2);\n            u += opt[u].mlen;\n        }\n\n        for (cur=0; cur < last_pos; ) {\n            U32 litLength;\n            ZSTD_LOG_PARSER(\"%d: price3[%d/%d]=%d off=%d mlen=%d litlen=%d rep=%d rep2=%d\\n\", (int)(ip-base+cur), cur, last_pos, opt[cur].price, opt[cur].off, opt[cur].mlen, opt[cur].litlen, opt[cur].rep, opt[cur].rep2);\n            mlen = opt[cur].mlen;\n            if (mlen == 1) { ip++; cur++; continue; }\n            offset = opt[cur].off;\n            cur += mlen;\n\n            litLength = (U32)(ip - anchor);\n            ZSTD_LOG_ENCODE(\"%d/%d: ENCODE1 literals=%d mlen=%d off=%d rep1=%d rep2=%d\\n\", (int)(ip-base), (int)(iend-base), (int)(litLength), (int)mlen, (int)(offset), (int)rep_1, (int)rep_2);\n\n            if (offset) {\n                rep_2 = rep_1;\n                rep_1 = offset;\n            } else {\n                if (litLength == 0) {\n                    best_off = rep_2;\n                    rep_2 = rep_1;\n                    rep_1 = best_off;\n            }   }\n\n            ZSTD_LOG_ENCODE(\"%d/%d: ENCODE2 literals=%d mlen=%d off=%d rep1=%d rep2=%d\\n\", (int)(ip-base), (int)(iend-base), (int)(litLength), (int)mlen, (int)(offset), (int)rep_1, (int)rep_2);\n\n#if ZSTD_OPT_DEBUG >= 5\n            U32 ml2;\n            if (offset) {\n                if (offset > (size_t)(ip - prefixStart))  {\n                    const BYTE* match = dictEnd - (offset - (ip - prefixStart));\n                    ml2 = ZSTD_count_2segments(ip, match, iend, dictEnd, prefixStart);\n                    ZSTD_LOG_PARSER(\"%d: ZSTD_count_2segments=%d offset=%d dictBase=%p dictEnd=%p prefixStart=%p ip=%p match=%p\\n\", (int)current, (int)ml2, (int)offset, dictBase, dictEnd, prefixStart, ip, match);\n                }\n                else ml2 = (U32)ZSTD_count(ip, ip-offset, iend);\n            }\n            else ml2 = (U32)ZSTD_count(ip, ip-rep_1, iend);\n            if ((offset >= 8) && (ml2 < mlen || ml2 < minMatch)) {\n                printf(\"%d: ERROR_Ext iend=%d mlen=%d offset=%d ml2=%d\\n\", (int)(ip - base), (int)(iend - ip), (int)mlen, (int)offset, (int)ml2); exit(0); }\n            if (ip < anchor) {\n                printf(\"%d: ERROR_Ext ip < anchor iend=%d mlen=%d offset=%d\\n\", (int)(ip - base), (int)(iend - ip), (int)mlen, (int)offset); exit(0); }\n            if (ip + mlen > iend) {\n                printf(\"%d: ERROR_Ext ip + mlen >= iend iend=%d mlen=%d offset=%d\\n\", (int)(ip - base), (int)(iend - ip), (int)mlen, (int)offset); exit(0); }\n#endif\n\n            ZSTD_updatePrice(seqStorePtr, litLength, anchor, offset, mlen-minMatch);\n            ZSTD_storeSeq(seqStorePtr, litLength, anchor, offset, mlen-minMatch);\n            anchor = ip = ip + mlen;\n        }\n\n#if 0\n        /* check immediate repcode */\n        while ((anchor >= base + lowLimit + rep_2) && (anchor <= ilimit)) {\n            if ((anchor - rep_2) >= prefixStart) {\n                if (MEM_readMINMATCH(anchor, minMatch) == MEM_readMINMATCH(anchor - rep_2, minMatch))\n                    mlen = (U32)ZSTD_count(anchor+minMatch, anchor - rep_2 + minMatch, iend) + minMatch;\n                else\n                    break;\n            } else {\n                const BYTE* repMatch = dictBase + ((anchor-base) - rep_2);\n                if ((repMatch + minMatch <= dictEnd) && (MEM_readMINMATCH(anchor, minMatch) == MEM_readMINMATCH(repMatch, minMatch))) \n                    mlen = (U32)ZSTD_count_2segments(anchor+minMatch, repMatch+minMatch, iend, dictEnd, prefixStart) + minMatch;\n                else\n                    break;\n            }\n                   \n            offset = rep_2; rep_2 = rep_1; rep_1 = offset;   /* swap offset history */\n            ZSTD_LOG_ENCODE(\"%d/%d: ENCODE REP literals=%d mlen=%d off=%d rep1=%d rep2=%d\\n\", (int)(anchor-base), (int)(iend-base), (int)(0), (int)best_mlen, (int)(0), (int)rep_1, (int)rep_2);\n            ZSTD_updatePrice(seqStorePtr, 0, anchor, 0, mlen-minMatch);\n            ZSTD_storeSeq(seqStorePtr, 0, anchor, 0, mlen-minMatch);\n            anchor += mlen;\n        }\n#else\n        /* check immediate repcode */\n        /* minimal correctness condition = while ((anchor >= prefixStart + REPCODE_STARTVALUE) && (anchor <= ilimit)) { */\n        while ((anchor >= base + lowLimit + rep_2) && (anchor <= ilimit)) {\n            const U32 repIndex = (U32)((anchor-base) - rep_2);\n            const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;\n            const BYTE* const repMatch = repBase + repIndex;\n            if ( ((U32)((dictLimit-1) - repIndex) >= 3)   /* intentional overflow */\n               && (MEM_readMINMATCH(anchor, minMatch) == MEM_readMINMATCH(repMatch, minMatch)) ) {\n                /* repcode detected, let's take it */\n                const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;\n                mlen = (U32)ZSTD_count_2segments(anchor+minMatch, repMatch+minMatch, iend, repEnd, prefixStart) + minMatch;\n                offset = rep_2; rep_2 = rep_1; rep_1 = offset;   /* swap offset history */\n                ZSTD_LOG_ENCODE(\"%d/%d: ENCODE REP literals=%d mlen=%d off=%d rep1=%d rep2=%d\\n\", (int)(anchor-base), (int)(iend-base), (int)(0), (int)best_mlen, (int)(0), (int)rep_1, (int)rep_2);\n                ZSTD_updatePrice(seqStorePtr, 0, anchor, 0, mlen-minMatch);\n                ZSTD_storeSeq(seqStorePtr, 0, anchor, 0, mlen-minMatch);\n                anchor += mlen;\n                continue;   /* faster when present ... (?) */\n            }\n            break;\n        }\n#endif\n        if (anchor > ip) ip = anchor;\n    }\n\n    {   /* Last Literals */\n        size_t lastLLSize = iend - anchor;\n        ZSTD_LOG_ENCODE(\"%d: lastLLSize literals=%u\\n\", (int)(ip-base), (U32)(lastLLSize));\n        memcpy(seqStorePtr->lit, anchor, lastLLSize);\n        seqStorePtr->lit += lastLLSize;\n    }",
        "res_region": "    printf(\"NOT IMPLEMENTED: ZSTD_compressBlock_opt_extDict_generic\\n\"), exit(0);\n    (void)ctx; (void)src; (void)srcSize; (void)depth; (void)ZSTD_BtGetAllMatches_selectMLS_extDict;\n#if 0\n    seqStore_t* seqStorePtr = &(ctx->seqStore);\n    const BYTE* const istart = (const BYTE*)src;\n    const BYTE* ip = istart;\n    const BYTE* anchor = istart;\n    const BYTE* litstart;\n    const BYTE* const iend = istart + srcSize;\n    const BYTE* const ilimit = iend - 8;\n    const BYTE* const base = ctx->base;\n    const U32 dictLimit = ctx->dictLimit;\n    const BYTE* const prefixStart = base + dictLimit;\n    const BYTE* const dictBase = ctx->dictBase;\n    const BYTE* const dictEnd  = dictBase + dictLimit;\n    const U32 lowLimit = ctx->lowLimit;\n\n    const U32 maxSearches = 1U << ctx->params.cParams.searchLog;\n    const U32 sufficient_len = ctx->params.cParams.targetLength;\n    const U32 mls = ctx->params.cParams.searchLength;\n    const U32 minMatch = (ctx->params.cParams.searchLength == 3) ? 3 : 4;\n\n    ZSTD_optimal_t* opt = seqStorePtr->priceTable;\n    ZSTD_match_t* matches = seqStorePtr->matchTable;\n    const BYTE* inr;\n    U32 cur, match_num, last_pos, litlen, price;\n\n    /* init */\n    U32 rep[ZSTD_REP_INIT];\n    for (int i=0; i<ZSTD_REP_INIT; i++)\n        rep[i]=REPCODE_STARTVALUE;\n\n    ctx->nextToUpdate3 = ctx->nextToUpdate;\n    ZSTD_resetSeqStore(seqStorePtr);\n    ZSTD_rescaleFreqs(seqStorePtr);\n    if ((ip - prefixStart) < REPCODE_STARTVALUE) ip += REPCODE_STARTVALUE;\n\n    ZSTD_LOG_BLOCK(\"%d: COMPBLOCK_OPT_EXTDICT srcSz=%d maxSrch=%d mls=%d sufLen=%d\\n\", (int)(ip-base), (int)srcSize, maxSearches, mls, sufficient_len);\n\n    /* Match Loop */\n    while (ip < ilimit) {\n        U32 u, offset, best_off=0;\n        U32 mlen=0, best_mlen=0;\n        U32 current = (U32)(ip-base);\n        memset(opt, 0, sizeof(ZSTD_optimal_t));\n        last_pos = 0;\n        inr = ip;\n        litstart = ((U32)(ip - anchor) > 128) ? ip - 128 : anchor;\n        opt[0].litlen = (U32)(ip - litstart);\n\n        /* check repCode */\n        {\n            const U32 repIndex = (U32)(current+1 - rep_1);\n            const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;\n            const BYTE* const repMatch = repBase + repIndex;\n            if ( ((U32)((dictLimit-1) - repIndex) >= 3)   /* intentional overflow */\n               && (MEM_readMINMATCH(ip+1, minMatch) == MEM_readMINMATCH(repMatch, minMatch)) ) {\n                /* repcode detected we should take it */\n                const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;\n                mlen = (U32)ZSTD_count_2segments(ip+1+minMatch, repMatch+minMatch, iend, repEnd, prefixStart) + minMatch;\n\n                ZSTD_LOG_PARSER(\"%d: start try REP rep=%d mlen=%d\\n\", (int)(ip-base), (int)rep_1, (int)mlen);\n                if (depth==0 || mlen > sufficient_len || mlen >= ZSTD_OPT_NUM) {\n                    ip+=1; best_mlen = mlen; best_off = 0; cur = 0; last_pos = 1;\n                    goto _storeSequence;\n                }\n\n                litlen = opt[0].litlen + 1;\n                do {\n                    price = ZSTD_getPrice(seqStorePtr, litlen, litstart, 0, mlen - minMatch);\n                    if (mlen + 1 > last_pos || price < opt[mlen + 1].price)\n                        SET_PRICE(mlen + 1, mlen, 0, litlen, price);\n                    mlen--;\n                } while (mlen >= minMatch);\n        }   }\n\n       best_mlen = (last_pos) ? last_pos : minMatch;\n\n       match_num = ZSTD_BtGetAllMatches_selectMLS_extDict(ctx, ip, iend, maxSearches, mls, matches);  /* first search (depth 0) */\n\n       ZSTD_LOG_PARSER(\"%d: match_num=%d last_pos=%d\\n\", (int)(ip-base), match_num, last_pos);\n       if (!last_pos && !match_num) { ip++; continue; }\n\n       opt[0].rep = rep_1;\n       opt[0].rep2 = rep_2;\n       opt[0].mlen = 1;\n\n       if (match_num && matches[match_num-1].len > sufficient_len) {\n            best_mlen = matches[match_num-1].len;\n            best_off = matches[match_num-1].off;\n            cur = 0;\n            last_pos = 1;\n            goto _storeSequence;\n       }\n\n        // set prices using matches at position = 0\n        for (u = 0; u < match_num; u++) {\n            mlen = (u>0) ? matches[u-1].len+1 : best_mlen;\n            best_mlen = (matches[u].len < ZSTD_OPT_NUM) ? matches[u].len : ZSTD_OPT_NUM;\n            ZSTD_LOG_PARSER(\"%d: start Found mlen=%d off=%d best_mlen=%d last_pos=%d\\n\", (int)(ip-base), matches[u].len, matches[u].off, (int)best_mlen, (int)last_pos);\n            litlen = opt[0].litlen;\n            while (mlen <= best_mlen) {\n                price = ZSTD_getPrice(seqStorePtr, litlen, litstart, matches[u].off, mlen - minMatch);\n                if (mlen > last_pos || price < opt[mlen].price)\n                    SET_PRICE(mlen, mlen, matches[u].off, litlen, price);\n                mlen++;\n        }   }\n\n        if (last_pos < minMatch) {\n            // ip += ((ip-anchor) >> g_searchStrength) + 1;   /* jump faster over incompressible sections */\n            ip++; continue;\n        }\n\n        /* check further positions */\n        for (cur = 1; cur <= last_pos; cur++) {\n           size_t cur_rep;\n           inr = ip + cur;\n\n           if (opt[cur-1].mlen == 1) {\n                litlen = opt[cur-1].litlen + 1;\n                if (cur > litlen) {\n                    price = opt[cur - litlen].price + ZSTD_getLiteralPrice(seqStorePtr, litlen, inr-litlen);\n                } else\n                    price = ZSTD_getLiteralPrice(seqStorePtr, litlen, litstart);\n           } else {\n                litlen = 1;\n                price = opt[cur - 1].price + ZSTD_getLiteralPrice(seqStorePtr, litlen, inr-1);\n           }\n\n           if (cur > last_pos || price <= opt[cur].price) // || ((price == opt[cur].price) && (opt[cur-1].mlen == 1) && (cur != litlen)))\n                SET_PRICE(cur, 1, 0, litlen, price);\n\n           if (cur == last_pos) break;\n\n           if (inr > ilimit) // last match must start at a minimum distance of 8 from oend\n               continue;\n\n           mlen = opt[cur].mlen;\n\n           if (opt[cur].off) {\n                opt[cur].rep2 = opt[cur-mlen].rep;\n                opt[cur].rep = opt[cur].off;\n                ZSTD_LOG_ENCODE(\"%d: COPYREP_OFF cur=%d mlen=%d rep=%d rep2=%d\\n\", (int)(inr-base), cur, mlen, opt[cur].rep, opt[cur].rep2);\n           } else {\n                if (cur!=mlen && opt[cur].litlen == 0) {\n                    opt[cur].rep2 = opt[cur-mlen].rep;\n                    opt[cur].rep = opt[cur-mlen].rep2;\n                    ZSTD_LOG_ENCODE(\"%d: COPYREP_SWI cur=%d mlen=%d rep=%d rep2=%d\\n\", (int)(inr-base), cur, mlen, opt[cur].rep, opt[cur].rep2);\n                } else {\n                    opt[cur].rep2 = opt[cur-mlen].rep2;\n                    opt[cur].rep = opt[cur-mlen].rep;\n                    ZSTD_LOG_ENCODE(\"%d: COPYREP_NOR cur=%d mlen=%d rep=%d rep2=%d\\n\", (int)(inr-base), cur, mlen, opt[cur].rep, opt[cur].rep2);\n           }   }\n\n           ZSTD_LOG_PARSER(\"%d: CURRENT_Ext price[%d/%d]=%d off=%d mlen=%d litlen=%d rep=%d rep2=%d\\n\", (int)(inr-base), cur, last_pos, opt[cur].price, opt[cur].off, opt[cur].mlen, opt[cur].litlen, opt[cur].rep, opt[cur].rep2);\n\n           best_mlen = 0;\n\n           if (opt[cur].mlen != 1) {\n               cur_rep = opt[cur].rep2;\n               ZSTD_LOG_PARSER(\"%d: tryExt REP2 rep2=%u mlen=%u\\n\", (int)(inr-base), (U32)cur_rep, mlen);\n           } else {\n               cur_rep = opt[cur].rep;\n               ZSTD_LOG_PARSER(\"%d: tryExt REP1 rep=%u mlen=%u\\n\", (int)(inr-base), (U32)cur_rep, mlen);\n           }\n\n           const U32 repIndex = (U32)(current+cur - cur_rep);\n           const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;\n           const BYTE* const repMatch = repBase + repIndex;\n           if ( ((U32)((dictLimit-1) - repIndex) >= 3)   /* intentional overflow */\n              && (MEM_readMINMATCH(inr, minMatch) == MEM_readMINMATCH(repMatch, minMatch)) ) {\n                /* repcode detected */\n                const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;\n                mlen = (U32)ZSTD_count_2segments(inr+minMatch, repMatch+minMatch, iend, repEnd, prefixStart) + minMatch;\n                ZSTD_LOG_PARSER(\"%d: Found REP mlen=%d off=%d rep=%d opt[%d].off=%d\\n\", (int)(inr-base), mlen, 0, opt[cur].rep, cur, opt[cur].off);\n\n                if (mlen > sufficient_len || cur + mlen >= ZSTD_OPT_NUM) {\n                    best_mlen = mlen;\n                    best_off = 0;\n                    ZSTD_LOG_PARSER(\"%d: REP sufficient_len=%d best_mlen=%d best_off=%d last_pos=%d\\n\", (int)(inr-base), sufficient_len, best_mlen, best_off, last_pos);\n                    last_pos = cur + 1;\n                    goto _storeSequence;\n                }\n\n                if (opt[cur].mlen == 1) {\n                    litlen = opt[cur].litlen;\n                    if (cur > litlen) {\n                        price = opt[cur - litlen].price + ZSTD_getPrice(seqStorePtr, litlen, inr-litlen, 0, mlen - minMatch);\n                    } else\n                        price = ZSTD_getPrice(seqStorePtr, litlen, litstart, 0, mlen - minMatch);\n                } else {\n                    litlen = 0;\n                    price = opt[cur].price + ZSTD_getPrice(seqStorePtr, 0, NULL, 0, mlen - minMatch);\n                }\n\n                best_mlen = mlen;\n\n                ZSTD_LOG_PARSER(\"%d: Found REP mlen=%d off=%d price=%d litlen=%d\\n\", (int)(inr-base), mlen, 0, price, litlen);\n\n                do {\n                    if (cur + mlen > last_pos || price <= opt[cur + mlen].price) // || ((price == opt[cur + mlen].price) && (opt[cur].mlen == 1) && (cur != litlen))) // at equal price prefer REP instead of MATCH\n                        SET_PRICE(cur + mlen, mlen, 0, litlen, price);\n                    mlen--;\n                } while (mlen >= minMatch);\n            }\n\n            best_mlen = (best_mlen > minMatch) ? best_mlen : minMatch;\n\n            match_num = ZSTD_BtGetAllMatches_selectMLS_extDict(ctx, inr, iend, maxSearches, mls, matches);\n            ZSTD_LOG_PARSER(\"%d: ZSTD_GetAllMatches match_num=%d\\n\", (int)(inr-base), match_num);\n\n            if (match_num > 0 && matches[match_num-1].len > sufficient_len) {\n                best_mlen = matches[match_num-1].len;\n                best_off = matches[match_num-1].off;\n                last_pos = cur + 1;\n                goto _storeSequence;\n            }\n\n            // set prices using matches at position = cur\n            for (u = 0; u < match_num; u++) {\n                mlen = (u>0) ? matches[u-1].len+1 : best_mlen;\n                best_mlen = (cur + matches[u].len < ZSTD_OPT_NUM) ? matches[u].len : ZSTD_OPT_NUM - cur;\n\n            //    ZSTD_LOG_PARSER(\"%d: Found1 cur=%d mlen=%d off=%d best_mlen=%d last_pos=%d\\n\", (int)(inr-base), cur, matches[u].len, matches[u].off, best_mlen, last_pos);\n\n                while (mlen <= best_mlen) {\n                    if (opt[cur].mlen == 1) {\n                        litlen = opt[cur].litlen;\n                        if (cur > litlen)\n                            price = opt[cur - litlen].price + ZSTD_getPrice(seqStorePtr, litlen, ip+cur-litlen, matches[u].off, mlen - minMatch);\n                        else\n                            price = ZSTD_getPrice(seqStorePtr, litlen, litstart, matches[u].off, mlen - minMatch);\n                    } else {\n                        litlen = 0;\n                        price = opt[cur].price + ZSTD_getPrice(seqStorePtr, 0, NULL, matches[u].off, mlen - minMatch);\n                    }\n\n                //    ZSTD_LOG_PARSER(\"%d: Found2 mlen=%d best_mlen=%d off=%d price=%d litlen=%d\\n\", (int)(inr-base), mlen, best_mlen, matches[u].off, price, litlen);\n\n                    if (cur + mlen > last_pos || (price < opt[cur + mlen].price))\n                        SET_PRICE(cur + mlen, mlen, matches[u].off, litlen, price);\n\n                    mlen++;\n        }   }   }   //  for (cur = 1; cur <= last_pos; cur++)\n\n        best_mlen = opt[last_pos].mlen;\n        best_off = opt[last_pos].off;\n        cur = last_pos - best_mlen;\n\n        /* store sequence */\n_storeSequence: // cur, last_pos, best_mlen, best_off have to be set\n        for (u = 1; u <= last_pos; u++)\n            ZSTD_LOG_PARSER(\"%d: price[%u/%d]=%d off=%d mlen=%d litlen=%d rep=%d rep2=%d\\n\", (int)(ip-base+u), u, last_pos, opt[u].price, opt[u].off, opt[u].mlen, opt[u].litlen, opt[u].rep, opt[u].rep2);\n        ZSTD_LOG_PARSER(\"%d: cur=%d/%d best_mlen=%d best_off=%d rep=%d\\n\", (int)(ip-base+cur), (int)cur, (int)last_pos, (int)best_mlen, (int)best_off, opt[cur].rep);\n\n        opt[0].mlen = 1;\n\n        while (1) {\n            mlen = opt[cur].mlen;\n            offset = opt[cur].off;\n            opt[cur].mlen = best_mlen;\n            opt[cur].off = best_off;\n            best_mlen = mlen;\n            best_off = offset;\n            if (mlen > cur) break;\n            cur -= mlen;\n        }\n\n        for (u = 0; u <= last_pos; ) {\n            ZSTD_LOG_PARSER(\"%d: price2[%d/%d]=%d off=%d mlen=%d litlen=%d rep=%d rep2=%d\\n\", (int)(ip-base+u), u, last_pos, opt[u].price, opt[u].off, opt[u].mlen, opt[u].litlen, opt[u].rep, opt[u].rep2);\n            u += opt[u].mlen;\n        }\n\n        for (cur=0; cur < last_pos; ) {\n            U32 litLength;\n            ZSTD_LOG_PARSER(\"%d: price3[%d/%d]=%d off=%d mlen=%d litlen=%d rep=%d rep2=%d\\n\", (int)(ip-base+cur), cur, last_pos, opt[cur].price, opt[cur].off, opt[cur].mlen, opt[cur].litlen, opt[cur].rep, opt[cur].rep2);\n            mlen = opt[cur].mlen;\n            if (mlen == 1) { ip++; cur++; continue; }\n            offset = opt[cur].off;\n            cur += mlen;\n\n            litLength = (U32)(ip - anchor);\n            ZSTD_LOG_ENCODE(\"%d/%d: ENCODE1 literals=%d mlen=%d off=%d rep1=%d rep2=%d\\n\", (int)(ip-base), (int)(iend-base), (int)(litLength), (int)mlen, (int)(offset), (int)rep_1, (int)rep_2);\n\n            if (offset) {\n                rep_2 = rep_1;\n                rep_1 = offset;\n            } else {\n                if (litLength == 0) {\n                    best_off = rep_2;\n                    rep_2 = rep_1;\n                    rep_1 = best_off;\n            }   }\n\n            ZSTD_LOG_ENCODE(\"%d/%d: ENCODE2 literals=%d mlen=%d off=%d rep1=%d rep2=%d\\n\", (int)(ip-base), (int)(iend-base), (int)(litLength), (int)mlen, (int)(offset), (int)rep_1, (int)rep_2);\n\n#if ZSTD_OPT_DEBUG >= 5\n            U32 ml2;\n            if (offset) {\n                if (offset > (size_t)(ip - prefixStart))  {\n                    const BYTE* match = dictEnd - (offset - (ip - prefixStart));\n                    ml2 = ZSTD_count_2segments(ip, match, iend, dictEnd, prefixStart);\n                    ZSTD_LOG_PARSER(\"%d: ZSTD_count_2segments=%d offset=%d dictBase=%p dictEnd=%p prefixStart=%p ip=%p match=%p\\n\", (int)current, (int)ml2, (int)offset, dictBase, dictEnd, prefixStart, ip, match);\n                }\n                else ml2 = (U32)ZSTD_count(ip, ip-offset, iend);\n            }\n            else ml2 = (U32)ZSTD_count(ip, ip-rep_1, iend);\n            if ((offset >= 8) && (ml2 < mlen || ml2 < minMatch)) {\n                printf(\"%d: ERROR_Ext iend=%d mlen=%d offset=%d ml2=%d\\n\", (int)(ip - base), (int)(iend - ip), (int)mlen, (int)offset, (int)ml2); exit(0); }\n            if (ip < anchor) {\n                printf(\"%d: ERROR_Ext ip < anchor iend=%d mlen=%d offset=%d\\n\", (int)(ip - base), (int)(iend - ip), (int)mlen, (int)offset); exit(0); }\n            if (ip + mlen > iend) {\n                printf(\"%d: ERROR_Ext ip + mlen >= iend iend=%d mlen=%d offset=%d\\n\", (int)(ip - base), (int)(iend - ip), (int)mlen, (int)offset); exit(0); }\n#endif\n\n            ZSTD_updatePrice(seqStorePtr, litLength, anchor, offset, mlen-minMatch);\n            ZSTD_storeSeq(seqStorePtr, litLength, anchor, offset, mlen-minMatch);\n            anchor = ip = ip + mlen;\n        }\n\n#if 0\n        /* check immediate repcode */\n        while ((anchor >= base + lowLimit + rep_2) && (anchor <= ilimit)) {\n            if ((anchor - rep_2) >= prefixStart) {\n                if (MEM_readMINMATCH(anchor, minMatch) == MEM_readMINMATCH(anchor - rep_2, minMatch))\n                    mlen = (U32)ZSTD_count(anchor+minMatch, anchor - rep_2 + minMatch, iend) + minMatch;\n                else\n                    break;\n            } else {\n                const BYTE* repMatch = dictBase + ((anchor-base) - rep_2);\n                if ((repMatch + minMatch <= dictEnd) && (MEM_readMINMATCH(anchor, minMatch) == MEM_readMINMATCH(repMatch, minMatch)))\n                    mlen = (U32)ZSTD_count_2segments(anchor+minMatch, repMatch+minMatch, iend, dictEnd, prefixStart) + minMatch;\n                else\n                    break;\n            }\n\n            offset = rep_2; rep_2 = rep_1; rep_1 = offset;   /* swap offset history */\n            ZSTD_LOG_ENCODE(\"%d/%d: ENCODE REP literals=%d mlen=%d off=%d rep1=%d rep2=%d\\n\", (int)(anchor-base), (int)(iend-base), (int)(0), (int)best_mlen, (int)(0), (int)rep_1, (int)rep_2);\n            ZSTD_updatePrice(seqStorePtr, 0, anchor, 0, mlen-minMatch);\n            ZSTD_storeSeq(seqStorePtr, 0, anchor, 0, mlen-minMatch);\n            anchor += mlen;\n        }\n#else\n        /* check immediate repcode */\n        /* minimal correctness condition = while ((anchor >= prefixStart + REPCODE_STARTVALUE) && (anchor <= ilimit)) { */\n        while ((anchor >= base + lowLimit + rep_2) && (anchor <= ilimit)) {\n            const U32 repIndex = (U32)((anchor-base) - rep_2);\n            const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;\n            const BYTE* const repMatch = repBase + repIndex;\n            if ( ((U32)((dictLimit-1) - repIndex) >= 3)   /* intentional overflow */\n               && (MEM_readMINMATCH(anchor, minMatch) == MEM_readMINMATCH(repMatch, minMatch)) ) {\n                /* repcode detected, let's take it */\n                const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;\n                mlen = (U32)ZSTD_count_2segments(anchor+minMatch, repMatch+minMatch, iend, repEnd, prefixStart) + minMatch;\n                offset = rep_2; rep_2 = rep_1; rep_1 = offset;   /* swap offset history */\n                ZSTD_LOG_ENCODE(\"%d/%d: ENCODE REP literals=%d mlen=%d off=%d rep1=%d rep2=%d\\n\", (int)(anchor-base), (int)(iend-base), (int)(0), (int)best_mlen, (int)(0), (int)rep_1, (int)rep_2);\n                ZSTD_updatePrice(seqStorePtr, 0, anchor, 0, mlen-minMatch);\n                ZSTD_storeSeq(seqStorePtr, 0, anchor, 0, mlen-minMatch);\n                anchor += mlen;\n                continue;   /* faster when present ... (?) */\n            }\n            break;\n        }\n#endif\n        if (anchor > ip) ip = anchor;\n    }\n\n    {   /* Last Literals */\n        size_t lastLLSize = iend - anchor;\n        ZSTD_LOG_ENCODE(\"%d: lastLLSize literals=%u\\n\", (int)(ip-base), (U32)(lastLLSize));\n        memcpy(seqStorePtr->lit, anchor, lastLLSize);\n        seqStorePtr->lit += lastLLSize;\n    }\n#endif",
        "lookback": "    (void)ctx; (void)src; (void)srcSize; (void)depth; (void)ZSTD_BtGetAllMatches_selectMLS_extDict;",
        "lookahead": "}",
        "label": [
            "newcode",
            "complex_conflict"
        ],
        "start_line": 756,
        "end_line": 1496,
        "merge_gen_region": null,
        "confidence": 0.46691271662712097,
        "hesitated": true
    }
]