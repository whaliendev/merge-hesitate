[
    {
        "a_contents": "#define _POSIX_C_SOURCE 199309L /* before time.h */",
        "b_contents": "#define _POSIX_C_SOURCE 199309L /* before <time.h> - needed for nanosleep() */",
        "base_contents": "",
        "res_region": "#define _POSIX_C_SOURCE 199309L /* before <time.h> - needed for nanosleep() */",
        "lookback": "#include <stdlib.h>      /* malloc, free */",
        "lookahead": "#include <stdlib.h>      /* malloc, free */",
        "label": [
            "base",
            "one_side_deletion"
        ],
        "start_line": 46,
        "end_line": 51,
        "merge_gen_region": null,
        "confidence": 0.7384488582611084,
        "hesitated": true
    },
    {
        "a_contents": "#include <time.h>        /* clock_t, clock, nanosleep, CLOCKS_PER_SEC */",
        "b_contents": "#include <time.h>         /* clock_t, nanosleep, clock, CLOCKS_PER_SEC */",
        "base_contents": "#include <time.h>         /* clock_t, clock, CLOCKS_PER_SEC */",
        "res_region": "#include <time.h>         /* clock_t, nanosleep, clock, CLOCKS_PER_SEC */",
        "lookback": "",
        "lookahead": "",
        "label": [
            "base",
            "complex_conflict"
        ],
        "start_line": 57,
        "end_line": 63,
        "merge_gen_region": null,
        "confidence": 0.7473400235176086,
        "hesitated": true
    },
    {
        "a_contents": "#  define mili_sleep(mili) { struct timespec t; t.tv_sec=0; t.tv_nsec=mili*1000000L; nanosleep(&t, NULL); }",
        "b_contents": "#  define mili_sleep(mili) { struct timespec t; t.tv_sec=0; t.tv_nsec=mili*1000000ULL; nanosleep(&t, NULL); }\n#  define SET_HIGH_PRIORITY setpriority(PRIO_PROCESS, 0, -20)",
        "base_contents": "",
        "res_region": "#  define mili_sleep(mili) { struct timespec t; t.tv_sec=0; t.tv_nsec=mili*1000000ULL; nanosleep(&t, NULL); }\n#  define SET_HIGH_PRIORITY setpriority(PRIO_PROCESS, 0, -20)",
        "lookback": "#  define SET_HIGH_PRIORITY setpriority(PRIO_PROCESS, 0, -20)",
        "lookahead": "#elif defined(_WIN32)",
        "label": [
            "base",
            "one_side_deletion"
        ],
        "start_line": 70,
        "end_line": 76,
        "merge_gen_region": null,
        "confidence": 0.7086246013641357,
        "hesitated": true
    },
    {
        "a_contents": "#  define mili_sleep(mili) Sleep(mili)",
        "b_contents": "#  define mili_sleep(mili) Sleep(mili)\n#  define SET_HIGH_PRIORITY SetPriorityClass(GetCurrentProcess(), REALTIME_PRIORITY_CLASS)",
        "base_contents": "",
        "res_region": "#  define mili_sleep(mili) Sleep(mili)\n#  define SET_HIGH_PRIORITY SetPriorityClass(GetCurrentProcess(), REALTIME_PRIORITY_CLASS)",
        "lookback": "#  define SET_HIGH_PRIORITY SetPriorityClass(GetCurrentProcess(), REALTIME_PRIORITY_CLASS)",
        "lookahead": "#else",
        "label": [
            "base",
            "one_side_deletion"
        ],
        "start_line": 80,
        "end_line": 86,
        "merge_gen_region": null,
        "confidence": 0.5936306715011597,
        "hesitated": true
    },
    {
        "a_contents": "#  define mili_sleep(mili) /* disabled */\n#error \"disabled\"",
        "b_contents": "#  define mili_sleep(mili) /* disabled */\n#  define SET_HIGH_PRIORITY /* disabled */\n#endif\n\n#if !defined(_WIN32) && (defined(__unix__) || defined(__unix) || (defined(__APPLE__) && defined(__MACH__)))\n   typedef clock_t BMK_time_t;\n#  define BMK_initTimer(ticksPerSecond) ticksPerSecond=0\n#  define BMK_getTime(x) x = clock()\n#  define BMK_getSpanTimeMicro(ticksPerSecond, clockStart, clockEnd) (1000000ULL * (clockEnd - clockStart) / CLOCKS_PER_SEC)\n#  define BMK_getSpanTimeNano(ticksPerSecond, clockStart, clockEnd) (1000000000ULL * (clockEnd - clockStart) / CLOCKS_PER_SEC)\n#elif defined(_WIN32)\n   typedef LARGE_INTEGER BMK_time_t;\n#  define BMK_initTimer(x) if (!QueryPerformanceFrequency(&x)) { fprintf(stderr, \"ERROR: QueryPerformance not present\\n\"); }\n#  define BMK_getTime(x) QueryPerformanceCounter(&x)\n#  define BMK_getSpanTimeMicro(ticksPerSecond, clockStart, clockEnd) (1000000ULL*(clockEnd.QuadPart - clockStart.QuadPart)/ticksPerSecond.QuadPart)\n#  define BMK_getSpanTimeNano(ticksPerSecond, clockStart, clockEnd) (1000000000ULL*(clockEnd.QuadPart - clockStart.QuadPart)/ticksPerSecond.QuadPart)\n#else\n   typedef int BMK_time_t;\n#  define BMK_initTimer(ticksPerSecond) ticksPerSecond=0\n#  define BMK_getTimeMicro(clockStart) clockStart=1\n#  define BMK_getSpanTimeMicro(ticksPerSecond, clockStart, clockEnd) (TIMELOOP_S*1000000ULL+clockEnd-clockStart)\n#  define BMK_getSpanTimeNano(ticksPerSecond, clockStart, clockEnd) (TIMELOOP_S*1000000000ULL+clockEnd-clockStart)",
        "base_contents": "",
        "res_region": "#  define mili_sleep(mili) /* disabled */\n#  define SET_HIGH_PRIORITY /* disabled */\n#endif\n\n#if !defined(_WIN32) && (defined(__unix__) || defined(__unix) || (defined(__APPLE__) && defined(__MACH__)))\n   typedef clock_t BMK_time_t;\n#  define BMK_initTimer(ticksPerSecond) ticksPerSecond=0\n#  define BMK_getTime(x) x = clock()\n#  define BMK_getSpanTimeMicro(ticksPerSecond, clockStart, clockEnd) (1000000ULL * (clockEnd - clockStart) / CLOCKS_PER_SEC)\n#  define BMK_getSpanTimeNano(ticksPerSecond, clockStart, clockEnd) (1000000000ULL * (clockEnd - clockStart) / CLOCKS_PER_SEC)\n#elif defined(_WIN32)\n   typedef LARGE_INTEGER BMK_time_t;\n#  define BMK_initTimer(x) if (!QueryPerformanceFrequency(&x)) { fprintf(stderr, \"ERROR: QueryPerformance not present\\n\"); }\n#  define BMK_getTime(x) QueryPerformanceCounter(&x)\n#  define BMK_getSpanTimeMicro(ticksPerSecond, clockStart, clockEnd) (1000000ULL*(clockEnd.QuadPart - clockStart.QuadPart)/ticksPerSecond.QuadPart)\n#  define BMK_getSpanTimeNano(ticksPerSecond, clockStart, clockEnd) (1000000000ULL*(clockEnd.QuadPart - clockStart.QuadPart)/ticksPerSecond.QuadPart)\n#else\n   typedef int BMK_time_t;\n#  define BMK_initTimer(ticksPerSecond) ticksPerSecond=0\n#  define BMK_getTimeMicro(clockStart) clockStart=1\n#  define BMK_getSpanTimeMicro(ticksPerSecond, clockStart, clockEnd) (TIMELOOP_S*1000000ULL+clockEnd-clockStart)\n#  define BMK_getSpanTimeNano(ticksPerSecond, clockStart, clockEnd) (TIMELOOP_S*1000000000ULL+clockEnd-clockStart)",
        "lookback": "#  define SET_HIGH_PRIORITY /* disabled */",
        "lookahead": "#endif",
        "label": [
            "base",
            "one_side_deletion"
        ],
        "start_line": 89,
        "end_line": 116,
        "merge_gen_region": null,
        "confidence": 0.847894012928009,
        "hesitated": true
    },
    {
        "a_contents": "#include \"zstd_internal.h\" /* ZSTD_setAdditionalParam */",
        "b_contents": "#include \"zstd_internal.h\" /* ZSTD_compressBegin_targetSrcSize */\n#include \"datagen.h\"       /* RDG_genBuffer */",
        "base_contents": "",
        "res_region": "#include \"zstd_internal.h\" /* ZSTD_compressBegin_targetSrcSize */\n#include \"datagen.h\"       /* RDG_genBuffer */",
        "lookback": "#include \"datagen.h\"       /* RDG_genBuffer */",
        "lookahead": "#include \"xxhash.h\"",
        "label": [
            "base",
            "one_side_deletion"
        ],
        "start_line": 121,
        "end_line": 127,
        "merge_gen_region": null,
        "confidence": 0.7713804841041565,
        "hesitated": true
    },
    {
        "a_contents": "    U64 crcOrig = XXH64(srcBuffer, srcSize, 0);\n    U32 nbBlocks = 0;\n    size_t cSize = 0;\n        \n    /* init */\n    if (strlen(displayName)>17) displayName += strlen(displayName)-17;   /* can only display 17 characters */",
        "b_contents": "    U32 nbBlocks;\n    BMK_time_t ticksPerSecond;",
        "base_contents": "    U64 crcOrig = XXH64(srcBuffer, srcSize, 0);\n    U32 nbBlocks = 0;\n\n    /* init */\n    if (strlen(displayName)>17) displayName += strlen(displayName)-17;   /* can only display 17 characters */",
        "res_region": "    U32 nbBlocks;\n    BMK_time_t ticksPerSecond;",
        "lookback": "    BMK_time_t ticksPerSecond;",
        "lookahead": "",
        "label": [
            "base",
            "complex_conflict"
        ],
        "start_line": 287,
        "end_line": 303,
        "merge_gen_region": null,
        "confidence": 0.6240798234939575,
        "hesitated": true
    },
    {
        "a_contents": "    {\n        U32 loopNb;\n        double fastestC = 100000000., fastestD = 100000000.;",
        "b_contents": "    {   double fastestC = 100000000., fastestD = 100000000.;\n        U64 const crcOrig = XXH64(srcBuffer, srcSize, 0);\n        U64 crcCheck = 0;\n        BMK_time_t coolTime;\n        U32 testNb;\n        size_t cSize = 0;",
        "base_contents": "    {\n        U32 loopNb;\n        size_t cSize = 0;\n        double fastestC = 100000000., fastestD = 100000000.;",
        "res_region": "    {   double fastestC = 100000000., fastestD = 100000000.;\n        U64 const crcOrig = XXH64(srcBuffer, srcSize, 0);\n        U64 crcCheck = 0;\n        BMK_time_t coolTime;\n        U32 testNb;\n        size_t cSize = 0;",
        "lookback": "        U64 const crcOrig = XXH64(srcBuffer, srcSize, 0);",
        "lookahead": "        double ratio = 0.;",
        "label": [
            "base",
            "complex_conflict"
        ],
        "start_line": 341,
        "end_line": 357,
        "merge_gen_region": null,
        "confidence": 0.7252837419509888,
        "hesitated": true
    },
    {
        "a_contents": "        DISPLAYLEVEL(2, \"\\r%79s\\r\", \"\");\n        for (loopNb = 1; loopNb <= (g_nbIterations + !g_nbIterations); loopNb++) {\n            int nbLoops;\n            U32 blockNb;\n            clock_t clockStart, clockSpan;\n            clock_t const clockLoop = g_nbIterations ? TIMELOOP_S * CLOCKS_PER_SEC : 10;",
        "b_contents": "        BMK_getTime(coolTime);\n        DISPLAYLEVEL(2, \"\\r%79s\\r\", \"\");\n        for (testNb = 1; testNb <= (g_nbIterations + !g_nbIterations); testNb++) {\n            BMK_time_t clockStart, clockEnd;\n            U64 clockLoop = g_nbIterations ? TIMELOOP_S*1000000ULL : 10;",
        "base_contents": "        DISPLAY(\"\\r%79s\\r\", \"\");\n        for (loopNb = 1; loopNb <= (g_nbIterations + !g_nbIterations); loopNb++) {\n            int nbLoops;\n            U32 blockNb;\n            clock_t clockStart, clockSpan;\n            clock_t const clockLoop = g_nbIterations ? TIMELOOP_S * CLOCKS_PER_SEC : 10;",
        "res_region": "        BMK_getTime(coolTime);\n        DISPLAYLEVEL(2, \"\\r%79s\\r\", \"\");\n        for (testNb = 1; testNb <= (g_nbIterations + !g_nbIterations); testNb++) {\n            BMK_time_t clockStart, clockEnd;\n            U64 clockLoop = g_nbIterations ? TIMELOOP_S*1000000ULL : 10;",
        "lookback": "        DISPLAYLEVEL(2, \"\\r%79s\\r\", \"\");",
        "lookahead": "",
        "label": [
            "base",
            "complex_conflict"
        ],
        "start_line": 360,
        "end_line": 380,
        "merge_gen_region": "&&&&&&&&DISPLAYdex&",
        "confidence": 0.8987312316894531,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "            DISPLAYLEVEL(2, \"%2i-%-17.17s :%10u ->\\r\", loopNb, displayName, (U32)srcSize);",
        "b_contents": "            DISPLAYLEVEL(2, \"%2i-%-17.17s :%10u ->\\r\", testNb, displayName, (U32)srcSize);",
        "base_contents": "            DISPLAY(\"%2i-%-17.17s :%10u ->\\r\", loopNb, displayName, (U32)srcSize);",
        "res_region": "            DISPLAYLEVEL(2, \"%2i-%-17.17s :%10u ->\\r\", testNb, displayName, (U32)srcSize);",
        "lookback": "            memset(compressedBuffer, 0xE5, maxCompressedSize);  /* warm up and erase result buffer */",
        "lookahead": "            memset(compressedBuffer, 0xE5, maxCompressedSize);  /* warm up and erase result buffer */",
        "label": [
            "base",
            "complex_conflict"
        ],
        "start_line": 390,
        "end_line": 396,
        "merge_gen_region": null,
        "confidence": 0.8223295211791992,
        "hesitated": true
    },
    {
        "a_contents": "            nbLoops = 0;\n            mili_sleep(1); // give processor to other processes\n            clockStart = clock();\n            while (clock() == clockStart);\n            clockStart = clock();\n            while (BMK_clockSpan(clockStart) < clockLoop) {\n                ZSTD_compressBegin_advanced(refCtx, dictBuffer, dictBufferSize, ZSTD_getParams(cLevel, MAX(dictBufferSize, largestBlockSize)));\n                for (blockNb=0; blockNb<nbBlocks; blockNb++) {\n                    size_t rSize = ZSTD_compress_usingPreparedCCtx(ctx, refCtx,\n                                        blockTable[blockNb].cPtr,  blockTable[blockNb].cRoom,\n                                        blockTable[blockNb].srcPtr,blockTable[blockNb].srcSize);\n                    if (ZSTD_isError(rSize)) EXM_THROW(1, \"ZSTD_compress_usingPreparedCCtx() failed : %s\", ZSTD_getErrorName(rSize));\n                    blockTable[blockNb].cSize = rSize;\n                }\n                nbLoops++;\n            }\n            clockSpan = BMK_clockSpan(clockStart);",
        "b_contents": "            mili_sleep(1); /* give processor time to other processes */\n            BMK_getTime(clockStart);\n            do { BMK_getTime(clockEnd); }\n            while (BMK_getSpanTimeNano(ticksPerSecond, clockStart, clockEnd) == 0);\n            BMK_getTime(clockStart);\n\n            {   U32 nbLoops;\n                for (nbLoops = 0 ; BMK_clockSpan(clockStart, ticksPerSecond) < clockLoop ; nbLoops++) {\n                    U32 blockNb;\n                    ZSTD_compressBegin_targetSrcSize(refCtx, dictBuffer, dictBufferSize, blockSize, cLevel);\n                  //  ZSTD_compressBegin_usingDict(refCtx, dictBuffer, dictBufferSize, cLevel);\n                    for (blockNb=0; blockNb<nbBlocks; blockNb++) {\n                        size_t const rSize = ZSTD_compress_usingPreparedCCtx(ctx, refCtx,\n                                            blockTable[blockNb].cPtr,  blockTable[blockNb].cRoom,\n                                            blockTable[blockNb].srcPtr,blockTable[blockNb].srcSize);\n                        if (ZSTD_isError(rSize)) EXM_THROW(1, \"ZSTD_compress_usingPreparedCCtx() failed : %s\", ZSTD_getErrorName(rSize));\n                        blockTable[blockNb].cSize = rSize;\n                }   }\n                {   U64 const clockSpan = BMK_clockSpan(clockStart, ticksPerSecond);\n                    if ((double)clockSpan < fastestC*nbLoops) fastestC = (double)clockSpan / nbLoops;\n            }   }",
        "base_contents": "            nbLoops = 0;\n            clockStart = clock();\n            while (clock() == clockStart);\n            clockStart = clock();\n            while (BMK_clockSpan(clockStart) < clockLoop) {\n                ZSTD_compressBegin_advanced(refCtx, dictBuffer, dictBufferSize, ZSTD_getParams(cLevel, MAX(dictBufferSize, largestBlockSize)));\n                for (blockNb=0; blockNb<nbBlocks; blockNb++) {\n                    size_t rSize = ZSTD_compress_usingPreparedCCtx(ctx, refCtx,\n                                        blockTable[blockNb].cPtr,  blockTable[blockNb].cRoom,\n                                        blockTable[blockNb].srcPtr,blockTable[blockNb].srcSize);\n                    if (ZSTD_isError(rSize)) EXM_THROW(1, \"ZSTD_compress_usingPreparedCCtx() failed : %s\", ZSTD_getErrorName(rSize));\n                    blockTable[blockNb].cSize = rSize;\n                }\n                nbLoops++;\n            }\n            clockSpan = BMK_clockSpan(clockStart);",
        "res_region": "            mili_sleep(1); /* give processor time to other processes */\n            BMK_getTime(clockStart);\n            do { BMK_getTime(clockEnd); }\n            while (BMK_getSpanTimeNano(ticksPerSecond, clockStart, clockEnd) == 0);\n            BMK_getTime(clockStart);\n\n            {   U32 nbLoops;\n                for (nbLoops = 0 ; BMK_clockSpan(clockStart, ticksPerSecond) < clockLoop ; nbLoops++) {\n                    U32 blockNb;\n                    ZSTD_compressBegin_targetSrcSize(refCtx, dictBuffer, dictBufferSize, blockSize, cLevel);\n                  //  ZSTD_compressBegin_usingDict(refCtx, dictBuffer, dictBufferSize, cLevel);\n                    for (blockNb=0; blockNb<nbBlocks; blockNb++) {\n                        size_t const rSize = ZSTD_compress_usingPreparedCCtx(ctx, refCtx,\n                                            blockTable[blockNb].cPtr,  blockTable[blockNb].cRoom,\n                                            blockTable[blockNb].srcPtr,blockTable[blockNb].srcSize);\n                        if (ZSTD_isError(rSize)) EXM_THROW(1, \"ZSTD_compress_usingPreparedCCtx() failed : %s\", ZSTD_getErrorName(rSize));\n                        blockTable[blockNb].cSize = rSize;\n                }   }\n                {   U64 const clockSpan = BMK_clockSpan(clockStart, ticksPerSecond);\n                    if ((double)clockSpan < fastestC*nbLoops) fastestC = (double)clockSpan / nbLoops;\n            }   }",
        "lookback": "            BMK_getTime(clockStart);",
        "lookahead": "",
        "label": [
            "base",
            "complex_conflict"
        ],
        "start_line": 399,
        "end_line": 456,
        "merge_gen_region": null,
        "confidence": 0.7027292251586914,
        "hesitated": true
    },
    {
        "a_contents": "            DISPLAYLEVEL(2, \"%2i-%-17.17s :%10u ->%10u (%5.3f),%6.1f MB/s\\r\",\n                    loopNb, displayName, (U32)srcSize, (U32)cSize, ratio,\n                    (double)srcSize / 1000000. / (fastestC / CLOCKS_PER_SEC) );",
        "b_contents": "            DISPLAYLEVEL(2, \"%2i-%-17.17s :%10u ->%10u (%5.3f),%6.1f MB/s\\r\",\n                    testNb, displayName, (U32)srcSize, (U32)cSize, ratio,\n                    (double)srcSize / fastestC );",
        "base_contents": "            DISPLAY(\"%2i-%-17.17s :%10u ->%10u (%5.3f),%6.1f MB/s\\r\",\n                    loopNb, displayName, (U32)srcSize, (U32)cSize, ratio,\n                    (double)srcSize / 1000000. / (fastestC / CLOCKS_PER_SEC) );",
        "res_region": "            DISPLAYLEVEL(2, \"%2i-%-17.17s :%10u ->%10u (%5.3f),%6.1f MB/s\\r\",\n                    testNb, displayName, (U32)srcSize, (U32)cSize, ratio,\n                    (double)srcSize / fastestC );",
        "lookback": "                    testNb, displayName, (U32)srcSize, (U32)cSize, ratio,",
        "lookahead": "",
        "label": [
            "base",
            "complex_conflict"
        ],
        "start_line": 461,
        "end_line": 473,
        "merge_gen_region": null,
        "confidence": 0.77473384141922,
        "hesitated": true
    },
    {
        "a_contents": "            nbLoops = 0;\n            mili_sleep(1); // give processor to other processes\n            clockStart = clock();\n            while (clock() == clockStart);\n            clockStart = clock();\n\n            for ( ; BMK_clockSpan(clockStart) < clockLoop; nbLoops++) {\n                ZSTD_decompressBegin_usingDict(refDCtx, dictBuffer, dictBufferSize);\n                for (blockNb=0; blockNb<nbBlocks; blockNb++) {\n                    size_t regenSize = ZSTD_decompress_usingPreparedDCtx(dctx, refDCtx,\n                        blockTable[blockNb].resPtr, blockTable[blockNb].srcSize,\n                        blockTable[blockNb].cPtr, blockTable[blockNb].cSize);\n                    if (ZSTD_isError(regenSize)) {\n                        DISPLAY(\"ZSTD_decompress_usingPreparedDCtx() failed on block %u : %s\",\n                                  blockNb, ZSTD_getErrorName(regenSize));\n                        goto _findError;\n                    }\n                    blockTable[blockNb].resSize = regenSize;",
        "b_contents": "            mili_sleep(1); /* give processor time to other processes */\n            BMK_getTime(clockStart);\n            do { BMK_getTime(clockEnd); }\n            while (BMK_getSpanTimeNano(ticksPerSecond, clockStart, clockEnd) == 0);\n            BMK_getTime(clockStart);\n\n            {   U32 nbLoops;\n                for (nbLoops = 0 ; BMK_clockSpan(clockStart, ticksPerSecond) < clockLoop ; nbLoops++) {\n                    U32 blockNb;\n                    ZSTD_decompressBegin_usingDict(refDCtx, dictBuffer, dictBufferSize);\n                    for (blockNb=0; blockNb<nbBlocks; blockNb++) {\n                        size_t const regenSize = ZSTD_decompress_usingPreparedDCtx(dctx, refDCtx,\n                            blockTable[blockNb].resPtr, blockTable[blockNb].srcSize,\n                            blockTable[blockNb].cPtr, blockTable[blockNb].cSize);\n                        if (ZSTD_isError(regenSize)) {\n                            DISPLAY(\"ZSTD_decompress_usingPreparedDCtx() failed on block %u : %s  \\n\",\n                                      blockNb, ZSTD_getErrorName(regenSize));\n                            clockLoop = 0;   /* force immediate test end */\n                            break;\n                        }\n                        blockTable[blockNb].resSize = regenSize;\n                }   }\n                {   U64 const clockSpan = BMK_clockSpan(clockStart, ticksPerSecond);\n                    if ((double)clockSpan < fastestD*nbLoops) fastestD = (double)clockSpan / nbLoops;",
        "base_contents": "            nbLoops = 0;\n            clockStart = clock();\n            while (clock() == clockStart);\n            clockStart = clock();\n\n            for ( ; BMK_clockSpan(clockStart) < clockLoop; nbLoops++) {\n                ZSTD_decompressBegin_usingDict(refDCtx, dictBuffer, dictBufferSize);\n                for (blockNb=0; blockNb<nbBlocks; blockNb++) {\n                    size_t regenSize = ZSTD_decompress_usingPreparedDCtx(dctx, refDCtx,\n                        blockTable[blockNb].resPtr, blockTable[blockNb].srcSize,\n                        blockTable[blockNb].cPtr, blockTable[blockNb].cSize);\n                    if (ZSTD_isError(regenSize)) {\n                        DISPLAY(\"ZSTD_decompress_usingPreparedDCtx() failed on block %u : %s\",\n                                  blockNb, ZSTD_getErrorName(regenSize));\n                        goto _findError;\n                    }\n                    blockTable[blockNb].resSize = regenSize;",
        "res_region": "            mili_sleep(1); /* give processor time to other processes */\n            BMK_getTime(clockStart);\n            do { BMK_getTime(clockEnd); }\n            while (BMK_getSpanTimeNano(ticksPerSecond, clockStart, clockEnd) == 0);\n            BMK_getTime(clockStart);\n\n            {   U32 nbLoops;\n                for (nbLoops = 0 ; BMK_clockSpan(clockStart, ticksPerSecond) < clockLoop ; nbLoops++) {\n                    U32 blockNb;\n                    ZSTD_decompressBegin_usingDict(refDCtx, dictBuffer, dictBufferSize);\n                    for (blockNb=0; blockNb<nbBlocks; blockNb++) {\n                        size_t const regenSize = ZSTD_decompress_usingPreparedDCtx(dctx, refDCtx,\n                            blockTable[blockNb].resPtr, blockTable[blockNb].srcSize,\n                            blockTable[blockNb].cPtr, blockTable[blockNb].cSize);\n                        if (ZSTD_isError(regenSize)) {\n                            DISPLAY(\"ZSTD_decompress_usingPreparedDCtx() failed on block %u : %s  \\n\",\n                                      blockNb, ZSTD_getErrorName(regenSize));\n                            clockLoop = 0;   /* force immediate test end */\n                            break;\n                        }\n                        blockTable[blockNb].resSize = regenSize;\n                }   }\n                {   U64 const clockSpan = BMK_clockSpan(clockStart, ticksPerSecond);\n                    if ((double)clockSpan < fastestD*nbLoops) fastestD = (double)clockSpan / nbLoops;",
        "lookback": "            BMK_getTime(clockStart);",
        "lookahead": "            }   }",
        "label": [
            "base",
            "complex_conflict"
        ],
        "start_line": 480,
        "end_line": 542,
        "merge_gen_region": null,
        "confidence": 0.7190841436386108,
        "hesitated": true
    },
    {
        "a_contents": "            clockSpan = BMK_clockSpan(clockStart);\n            if ((double)clockSpan < fastestD*nbLoops) fastestD = (double)clockSpan / nbLoops;\n            DISPLAYLEVEL(2, \"%2i-%-17.17s :%10u ->%10u (%5.3f),%6.1f MB/s ,%6.1f MB/s\\r\",\n                    loopNb, displayName, (U32)srcSize, (U32)cSize, ratio,\n                    (double)srcSize / 1000000. / (fastestC / CLOCKS_PER_SEC),\n                    (double)srcSize / 1000000. / (fastestD / CLOCKS_PER_SEC) );",
        "b_contents": "            DISPLAYLEVEL(2, \"%2i-%-17.17s :%10u ->%10u (%5.3f),%6.1f MB/s ,%6.1f MB/s\\r\",\n                    testNb, displayName, (U32)srcSize, (U32)cSize, ratio,\n                    (double)srcSize / fastestC,\n                    (double)srcSize / fastestD );",
        "base_contents": "            clockSpan = BMK_clockSpan(clockStart);\n            if ((double)clockSpan < fastestD*nbLoops) fastestD = (double)clockSpan / nbLoops;\n            DISPLAY(\"%2i-%-17.17s :%10u ->%10u (%5.3f),%6.1f MB/s ,%6.1f MB/s\\r\",\n                    loopNb, displayName, (U32)srcSize, (U32)cSize, ratio,\n                    (double)srcSize / 1000000. / (fastestC / CLOCKS_PER_SEC),\n                    (double)srcSize / 1000000. / (fastestD / CLOCKS_PER_SEC) );",
        "res_region": "            DISPLAYLEVEL(2, \"%2i-%-17.17s :%10u ->%10u (%5.3f),%6.1f MB/s ,%6.1f MB/s\\r\",\n                    testNb, displayName, (U32)srcSize, (U32)cSize, ratio,\n                    (double)srcSize / fastestC,\n                    (double)srcSize / fastestD );",
        "lookback": "                    testNb, displayName, (U32)srcSize, (U32)cSize, ratio,",
        "lookahead": "",
        "label": [
            "base",
            "complex_conflict"
        ],
        "start_line": 545,
        "end_line": 564,
        "merge_gen_region": null,
        "confidence": 0.7817886471748352,
        "hesitated": true
    },
    {
        "a_contents": "        if (crcOrig == crcCheck)\n        {\n            result->ratio = ratio;\n            result->cSize = cSize;\n            result->cSpeed = (double)srcSize / 1000000. / (fastestC / CLOCKS_PER_SEC); \n            result->dSpeed = (double)srcSize / 1000000. / (fastestD / CLOCKS_PER_SEC);\n            DISPLAYLEVEL(2, \"%2i-%-17.17s :%10i ->%10i (%5.3f),%6.1f MB/s ,%6.1f MB/s \\n\", cLevel, displayName, (int)srcSize, (int)cSize, ratio, result->cSpeed, result->dSpeed);\n        }\n        else\n            DISPLAYLEVEL(2, \"%2i-\\n\", cLevel);\n    }",
        "b_contents": "        if (crcOrig == crcCheck) {\n            result->ratio = ratio;\n            result->cSize = cSize;\n            result->cSpeed = (double)srcSize / fastestC; \n            result->dSpeed = (double)srcSize / fastestD;\n        }\n        DISPLAYLEVEL(2, \"%2i#\\n\", cLevel);\n    }   /* Bench */",
        "base_contents": "        DISPLAY(\"%2i-\\n\", cLevel);\n    }",
        "res_region": "        if (crcOrig == crcCheck) {\n            result->ratio = ratio;\n            result->cSize = cSize;\n            result->cSpeed = (double)srcSize / fastestC; \n            result->dSpeed = (double)srcSize / fastestD;\n        }\n        DISPLAYLEVEL(2, \"%2i#\\n\", cLevel);\n    }   /* Bench */",
        "lookback": "            result->ratio = ratio;",
        "lookahead": "",
        "label": [
            "base",
            "complex_conflict"
        ],
        "start_line": 593,
        "end_line": 617,
        "merge_gen_region": " (Orig crc/resultoutputoutputdexdexoutputoutputdexoutputoutputoutputoutputoutputoutputoutputdexReplacedexReplacedexoutputdexdexoutput2outputWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDWORDoutputoutputdexdexdexdexdexdexdexdexdexdexdexdexdexdexdexoutput2outputdexdexdexoutputdexdexoutputdexoutputdexoutputdexoutputdexoutputdexoutputdexoutputdexoutputdexoutputdexoutputdexoutputdexoutputdexoutputdexoutputdexoutput",
        "confidence": 0.9266552925109863,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "                            const char* displayName, int cLevel, int cLevelLast, int additionalParam,",
        "b_contents": "                            const char* displayName, int cLevel, int cLevelLast,",
        "base_contents": "                            const char* displayName, int cLevel,",
        "res_region": "                            const char* displayName, int cLevel, int cLevelLast,",
        "lookback": "                            const size_t* fileSizes, unsigned nbFiles,",
        "lookahead": "                            const size_t* fileSizes, unsigned nbFiles,",
        "label": [
            "base",
            "complex_conflict"
        ],
        "start_line": 649,
        "end_line": 655,
        "merge_gen_region": null,
        "confidence": 0.4580499529838562,
        "hesitated": true
    },
    {
        "a_contents": "    benchResult_t result, total;\n    int l;\n#ifdef _WIN32\n    SetPriorityClass(GetCurrentProcess(), REALTIME_PRIORITY_CLASS);\n#else\n    setpriority(PRIO_PROCESS, 0, -20);\n#endif\n\n    const char* pch = strrchr(displayName, '\\\\'); /* Windows */\n    if (!pch) pch = strrchr(displayName, '/'); /* Linux */\n    if (pch) displayName = pch+1;\n\n    memset(&result, 0, sizeof(result));\n    memset(&total, 0, sizeof(total));\n\n  //  if (g_displayLevel == 1 && !additionalParam)\n //       DISPLAY(\"bench %s: input %u bytes, %i iterations, %u KB blocks\\n\", ZSTD_VERSION, (U32)benchedSize, g_nbIterations, (U32)(g_blockSize>>10));\n\n    if (cLevelLast < cLevel) cLevelLast = cLevel;\n\n    for (l=cLevel; l <= cLevelLast; l++) {           \n        BMK_benchMem(srcBuffer, benchedSize,\n                     displayName, l, additionalParam,\n                     fileSizes, nbFiles,\n                     dictBuffer, dictBufferSize, &result);\n        if (g_displayLevel == 1) {\n            if (1)// && additionalParam)\n                DISPLAY(\"%-3i%11i (%5.3f) %6.1f MB/s %6.1f MB/s  %s (kSlotNew=%d)\\n\", -l, (int)result.cSize, result.ratio, result.cSpeed, result.dSpeed, displayName, additionalParam);\n            else\n                DISPLAY(\"%-3i%11i (%5.3f) %6.1f MB/s %6.1f MB/s  %s\\n\", -l, (int)result.cSize, result.ratio, result.cSpeed, result.dSpeed, displayName);\n            total.cSize += result.cSize;\n            total.cSpeed += result.cSpeed;\n            total.dSpeed += result.dSpeed;\n            total.ratio += result.ratio;",
        "b_contents": "    benchResult_t result, total;\n    int l;\n\n    SET_HIGH_PRIORITY;\n\n    const char* pch = strrchr(displayName, '\\\\'); /* Windows */\n    if (!pch) pch = strrchr(displayName, '/'); /* Linux */\n    if (pch) displayName = pch+1;\n\n    memset(&result, 0, sizeof(result));\n    memset(&total, 0, sizeof(total));\n\n    if (g_displayLevel == 1 && !g_additionalParam)\n        DISPLAY(\"bench %s: input %u bytes, %i iterations, %u KB blocks\\n\", ZSTD_VERSION, (U32)benchedSize, g_nbIterations, (U32)(g_blockSize>>10));\n\n    if (cLevelLast < cLevel) cLevelLast = cLevel;\n\n    for (l=cLevel; l <= cLevelLast; l++) {           \n        BMK_benchMem(srcBuffer, benchedSize,\n                     displayName, l,\n                     fileSizes, nbFiles,\n                     dictBuffer, dictBufferSize, &result);\n        if (g_displayLevel == 1) {\n            if (g_additionalParam)\n                DISPLAY(\"%-3i%11i (%5.3f) %6.1f MB/s %6.1f MB/s  %s (param=%d)\\n\", -l, (int)result.cSize, result.ratio, result.cSpeed, result.dSpeed, displayName, g_additionalParam);\n            else\n                DISPLAY(\"%-3i%11i (%5.3f) %6.1f MB/s %6.1f MB/s  %s\\n\", -l, (int)result.cSize, result.ratio, result.cSpeed, result.dSpeed, displayName);\n            total.cSize += result.cSize;\n            total.cSpeed += result.cSpeed;\n            total.dSpeed += result.dSpeed;\n            total.ratio += result.ratio;",
        "base_contents": "    if (cLevel < 0) {  /* range mode : test all levels from 1 to l */\n        int l;\n        for (l=1; l <= -cLevel; l++) {\n            BMK_benchMem(srcBuffer, benchedSize,\n                         displayName, l,\n                         fileSizes, nbFiles,\n                         dictBuffer, dictBufferSize);",
        "res_region": "    benchResult_t result, total;\n    int l;\n#ifdef _WIN32\n    SetPriorityClass(GetCurrentProcess(), REALTIME_PRIORITY_CLASS);\n#else\n    setpriority(PRIO_PROCESS, 0, -20);\n#endif\n\n    SET_HIGH_PRIORITY;\n\n    const char* pch = strrchr(displayName, '\\\\'); /* Windows */\n    if (!pch) pch = strrchr(displayName, '/'); /* Linux */\n    if (pch) displayName = pch+1;\n\n    memset(&result, 0, sizeof(result));\n    memset(&total, 0, sizeof(total));\n\n    kSlotNew = g_additionalParam;\n    if (g_displayLevel == 1 && !g_additionalParam)\n        DISPLAY(\"bench %s: input %u bytes, %i iterations, %u KB blocks\\n\", ZSTD_VERSION, (U32)benchedSize, g_nbIterations, (U32)(g_blockSize>>10));\n\n    if (cLevelLast < cLevel) cLevelLast = cLevel;\n\n    for (l=cLevel; l <= cLevelLast; l++) {           \n        BMK_benchMem(srcBuffer, benchedSize,\n                     displayName, l,\n                     fileSizes, nbFiles,\n                     dictBuffer, dictBufferSize, &result);\n        if (g_displayLevel == 1) {\n            if (g_additionalParam)\n                DISPLAY(\"%-3i%11i (%5.3f) %6.1f MB/s %6.1f MB/s  %s (param=%d)\\n\", -l, (int)result.cSize, result.ratio, result.cSpeed, result.dSpeed, displayName, g_additionalParam);\n            else\n                DISPLAY(\"%-3i%11i (%5.3f) %6.1f MB/s %6.1f MB/s  %s\\n\", -l, (int)result.cSize, result.ratio, result.cSpeed, result.dSpeed, displayName);\n            total.cSize += result.cSize;\n            total.cSpeed += result.cSpeed;\n            total.dSpeed += result.dSpeed;\n            total.ratio += result.ratio;",
        "lookback": "    int l;",
        "lookahead": "        }",
        "label": [
            "newcode",
            "complex_conflict"
        ],
        "start_line": 659,
        "end_line": 734,
        "merge_gen_region": null,
        "confidence": 0.5755264759063721,
        "hesitated": true
    },
    {
        "a_contents": "                               const char* dictFileName, int cLevel, int cLevelLast, int additionalParam)",
        "b_contents": "                               const char* dictFileName, int cLevel, int cLevelLast)",
        "base_contents": "                               const char* dictFileName, int cLevel)",
        "res_region": "                               const char* dictFileName, int cLevel, int cLevelLast)",
        "lookback": "{",
        "lookahead": "{",
        "label": [
            "base",
            "complex_conflict"
        ],
        "start_line": 781,
        "end_line": 787,
        "merge_gen_region": null,
        "confidence": 0.772237241268158,
        "hesitated": true
    },
    {
        "a_contents": "                    displayName, cLevel, cLevelLast, additionalParam,",
        "b_contents": "                    displayName, cLevel, cLevelLast,",
        "base_contents": "                    displayName, cLevel,",
        "res_region": "                    displayName, cLevel, cLevelLast,",
        "lookback": "                    fileSizes, nbFiles,",
        "lookahead": "                    fileSizes, nbFiles,",
        "label": [
            "base",
            "complex_conflict"
        ],
        "start_line": 827,
        "end_line": 833,
        "merge_gen_region": null,
        "confidence": 0.6186686158180237,
        "hesitated": true
    },
    {
        "a_contents": "static void BMK_syntheticTest(int cLevel, int cLevelLast, int additionalParam, double compressibility)",
        "b_contents": "static void BMK_syntheticTest(int cLevel, int cLevelLast, double compressibility)",
        "base_contents": "static void BMK_syntheticTest(int cLevel, double compressibility)",
        "res_region": "static void BMK_syntheticTest(int cLevel, int cLevelLast, double compressibility)",
        "lookback": "{",
        "lookahead": "{",
        "label": [
            "base",
            "complex_conflict"
        ],
        "start_line": 844,
        "end_line": 850,
        "merge_gen_region": null,
        "confidence": 0.8049589991569519,
        "hesitated": true
    },
    {
        "a_contents": "    BMK_benchCLevel(srcBuffer, benchedSize, name, cLevel, cLevelLast, additionalParam, &benchedSize, 1, NULL, 0);",
        "b_contents": "    BMK_benchCLevel(srcBuffer, benchedSize, name, cLevel, cLevelLast, &benchedSize, 1, NULL, 0);",
        "base_contents": "    BMK_benchCLevel(srcBuffer, benchedSize, name, cLevel, &benchedSize, 1, NULL, 0);",
        "res_region": "    BMK_benchCLevel(srcBuffer, benchedSize, name, cLevel, cLevelLast, &benchedSize, 1, NULL, 0);",
        "lookback": "",
        "lookahead": "",
        "label": [
            "base",
            "complex_conflict"
        ],
        "start_line": 864,
        "end_line": 870,
        "merge_gen_region": null,
        "confidence": 0.7362735867500305,
        "hesitated": true
    },
    {
        "a_contents": "                   const char* dictFileName, int cLevel, int cLevelLast, int additionalParam)",
        "b_contents": "                   const char* dictFileName, int cLevel, int cLevelLast)",
        "base_contents": "                   const char* dictFileName, int cLevel)",
        "res_region": "                   const char* dictFileName, int cLevel, int cLevelLast)",
        "lookback": "{",
        "lookahead": "{",
        "label": [
            "base",
            "complex_conflict"
        ],
        "start_line": 878,
        "end_line": 884,
        "merge_gen_region": null,
        "confidence": 0.772237241268158,
        "hesitated": true
    },
    {
        "a_contents": "        BMK_syntheticTest(cLevel, cLevelLast, additionalParam, compressibility);",
        "b_contents": "        BMK_syntheticTest(cLevel, cLevelLast, compressibility);",
        "base_contents": "        BMK_syntheticTest(cLevel, compressibility);",
        "res_region": "        BMK_syntheticTest(cLevel, cLevelLast, compressibility);",
        "lookback": "    else",
        "lookahead": "    else",
        "label": [
            "base",
            "complex_conflict"
        ],
        "start_line": 889,
        "end_line": 895,
        "merge_gen_region": null,
        "confidence": 0.8421432375907898,
        "hesitated": true
    },
    {
        "a_contents": "        BMK_benchFileTable(fileNamesTable, nbFiles, dictFileName, cLevel, cLevelLast, additionalParam);",
        "b_contents": "        BMK_benchFileTable(fileNamesTable, nbFiles, dictFileName, cLevel, cLevelLast);",
        "base_contents": "        BMK_benchFileTable(fileNamesTable, nbFiles, dictFileName, cLevel);",
        "res_region": "        BMK_benchFileTable(fileNamesTable, nbFiles, dictFileName, cLevel, cLevelLast);",
        "lookback": "    return 0;",
        "lookahead": "    return 0;",
        "label": [
            "base",
            "complex_conflict"
        ],
        "start_line": 897,
        "end_line": 903,
        "merge_gen_region": null,
        "confidence": 0.8158730864524841,
        "hesitated": true
    }
]