[
    {
        "a_contents": "            /* check for single-pass mode opportunity */\n            if (zds->fParams.frameContentSize && zds->fParams.windowSize /* skippable frame if == 0 */\n                && (U64)(size_t)(oend-op) >= zds->fParams.frameContentSize) {\n                size_t const cSize = ZSTD_findFrameCompressedSize(istart, iend-istart);\n                if (cSize <= (size_t)(iend-istart)) {\n                    size_t const decompressedSize = ZSTD_decompress_usingDDict(zds, op, oend-op, istart, cSize, zds->ddict);\n                    if (ZSTD_isError(decompressedSize)) return decompressedSize;\n                    ip = istart + cSize;\n                    op += decompressedSize;\n                    zds->expected = 0;\n                    zds->streamStage = zdss_init;\n                    someMoreWork = 0;\n                    break;\n            }   }",
        "b_contents": "                /* check for single-pass mode opportunity */\n                if (zds->fParams.frameContentSize && zds->fParams.windowSize /* skippable frame if == 0 */\n                    && (U64)(size_t)(oend-op) >= zds->fParams.frameContentSize) {\n                    size_t const cSize = ZSTD_findFrameCompressedSize(istart, iend-istart);\n                    if (cSize <= (size_t)(iend-istart)) {\n                        size_t const decompressedSize = ZSTD_decompress_usingDDict(zds->dctx, op, oend-op, istart, cSize, zds->ddict);\n                        if (ZSTD_isError(decompressedSize)) return decompressedSize;\n                        ip = istart + cSize;\n                        op += decompressedSize;\n                        zds->dctx->expected = 0;\n                        zds->stage = zdss_init;\n                        someMoreWork = 0;\n                        break;\n                }   }",
        "base_contents": "            /* check for single-pass mode opportunity */\n            if (zds->fParams.frameContentSize && zds->fParams.windowSize /* skippable frame if == 0 */\n                && (U64)(size_t)(oend-op) >= zds->fParams.frameContentSize) {\n                size_t const cSize = ZSTD_findFrameCompressedSize(istart, iend-istart);\n                if (cSize <= (size_t)(iend-istart)) {\n                    size_t const decompressedSize = ZSTD_decompress_usingDDict(zds->dctx, op, oend-op, istart, cSize, zds->ddict);\n                    if (ZSTD_isError(decompressedSize)) return decompressedSize;\n                    ip = istart + cSize;\n                    op += decompressedSize;\n                    zds->dctx->expected = 0;\n                    zds->stage = zdss_init;\n                    someMoreWork = 0;\n                    break;\n            }   }",
        "res_region": "            /* check for single-pass mode opportunity */\n            if (zds->fParams.frameContentSize && zds->fParams.windowSize /* skippable frame if == 0 */\n                && (U64)(size_t)(oend-op) >= zds->fParams.frameContentSize) {\n                size_t const cSize = ZSTD_findFrameCompressedSize(istart, iend-istart);\n                if (cSize <= (size_t)(iend-istart)) {\n                    size_t const decompressedSize = ZSTD_decompress_usingDDict(zds, op, oend-op, istart, cSize, zds->ddict);\n                    if (ZSTD_isError(decompressedSize)) return decompressedSize;\n                    ip = istart + cSize;\n                    op += decompressedSize;\n                    zds->expected = 0;\n                    zds->streamStage = zdss_init;\n                    someMoreWork = 0;\n                    break;\n            }   }",
        "lookback": "            if (zds->fParams.frameContentSize && zds->fParams.windowSize /* skippable frame if == 0 */",
        "lookahead": "",
        "label": [
            "ours",
            "base_underutilized"
        ],
        "start_line": 2309,
        "end_line": 2354,
        "merge_gen_region": null,
        "confidence": 0.801301121711731,
        "hesitated": true
    },
    {
        "a_contents": "            /* Consume header */\n            CHECK_F(ZSTD_decompressBegin_usingDDict(zds, zds->ddict));\n            {   size_t const h1Size = ZSTD_nextSrcSizeToDecompress(zds);  /* == ZSTD_frameHeaderSize_prefix */\n                CHECK_F(ZSTD_decompressContinue(zds, NULL, 0, zds->headerBuffer, h1Size));\n                {   size_t const h2Size = ZSTD_nextSrcSizeToDecompress(zds);\n                    CHECK_F(ZSTD_decompressContinue(zds, NULL, 0, zds->headerBuffer+h1Size, h2Size));\n            }   }",
        "b_contents": "                /* Consume header */\n                CHECK_F(ZSTD_decompressBegin_usingDDict(zds->dctx, zds->ddict));\n                {   size_t const h1Size = ZSTD_nextSrcSizeToDecompress(zds->dctx);  /* == ZSTD_frameHeaderSize_prefix */\n                    CHECK_F(ZSTD_decompressContinue(zds->dctx, NULL, 0, zds->headerBuffer, h1Size));\n                    {   size_t const h2Size = ZSTD_nextSrcSizeToDecompress(zds->dctx);\n                        CHECK_F(ZSTD_decompressContinue(zds->dctx, NULL, 0, zds->headerBuffer+h1Size, h2Size));\n                }   }",
        "base_contents": "            /* Consume header */\n            CHECK_F(ZSTD_decompressBegin_usingDDict(zds->dctx, zds->ddict));\n            {   size_t const h1Size = ZSTD_nextSrcSizeToDecompress(zds->dctx);  /* == ZSTD_frameHeaderSize_prefix */\n                CHECK_F(ZSTD_decompressContinue(zds->dctx, NULL, 0, zds->headerBuffer, h1Size));\n                {   size_t const h2Size = ZSTD_nextSrcSizeToDecompress(zds->dctx);\n                    CHECK_F(ZSTD_decompressContinue(zds->dctx, NULL, 0, zds->headerBuffer+h1Size, h2Size));\n            }   }",
        "res_region": "            /* Consume header */\n            CHECK_F(ZSTD_decompressBegin_usingDDict(zds, zds->ddict));\n            {   size_t const h1Size = ZSTD_nextSrcSizeToDecompress(zds);  /* == ZSTD_frameHeaderSize_prefix */\n                CHECK_F(ZSTD_decompressContinue(zds, NULL, 0, zds->headerBuffer, h1Size));\n                {   size_t const h2Size = ZSTD_nextSrcSizeToDecompress(zds);\n                    CHECK_F(ZSTD_decompressContinue(zds, NULL, 0, zds->headerBuffer+h1Size, h2Size));\n            }   }",
        "lookback": "            CHECK_F(ZSTD_decompressBegin_usingDDict(zds, zds->ddict));",
        "lookahead": "",
        "label": [
            "ours",
            "base_underutilized"
        ],
        "start_line": 2356,
        "end_line": 2380,
        "merge_gen_region": null,
        "confidence": 0.7535415291786194,
        "hesitated": true
    },
    {
        "a_contents": "            zds->fParams.windowSize = MAX(zds->fParams.windowSize, 1U << ZSTD_WINDOWLOG_ABSOLUTEMIN);\n            if (zds->fParams.windowSize > zds->maxWindowSize) return ERROR(frameParameter_windowTooLarge);\n\n            /* Adapt buffer sizes to frame header instructions */\n            {   size_t const blockSize = MIN(zds->fParams.windowSize, ZSTD_BLOCKSIZE_MAX);\n                size_t const neededOutSize = zds->fParams.windowSize + blockSize + WILDCOPY_OVERLENGTH * 2;\n                zds->blockSize = blockSize;\n                if ((zds->inBuffSize < blockSize) || (zds->outBuffSize < neededOutSize)) {\n                    size_t const bufferSize = blockSize + neededOutSize;\n                    DEBUGLOG(5, \"inBuff  : from %u to %u\",\n                                (U32)zds->inBuffSize, (U32)blockSize);\n                    DEBUGLOG(5, \"outBuff : from %u to %u\",\n                                (U32)zds->outBuffSize, (U32)neededOutSize);\n                    if (zds->staticSize) {  /* static DCtx */\n                        DEBUGLOG(4, \"staticSize : %u\", (U32)zds->staticSize);\n                        assert(zds->staticSize >= sizeof(ZSTD_DCtx));  /* already checked at init */\n                        if (bufferSize > zds->staticSize - sizeof(ZSTD_DCtx))\n                            return ERROR(memory_allocation);\n                    } else {\n                        ZSTD_free(zds->inBuff, zds->customMem);\n                        zds->inBuffSize = 0;\n                        zds->outBuffSize = 0;\n                        zds->inBuff = (char*)ZSTD_malloc(bufferSize, zds->customMem);\n                        if (zds->inBuff == NULL) return ERROR(memory_allocation);\n                    }\n                    zds->inBuffSize = blockSize;\n                    zds->outBuff = zds->inBuff + zds->inBuffSize;\n                    zds->outBuffSize = neededOutSize;\n            }   }\n            zds->streamStage = zdss_read;",
        "b_contents": "                zds->fParams.windowSize = MAX(zds->fParams.windowSize, 1U << ZSTD_WINDOWLOG_ABSOLUTEMIN);\n                if (zds->fParams.windowSize > zds->maxWindowSize) return ERROR(frameParameter_windowTooLarge);\n\n                /* Adapt buffer sizes to frame header instructions */\n                {   size_t const blockSize = MIN(zds->fParams.windowSize, ZSTD_BLOCKSIZE_ABSOLUTEMAX);\n                    size_t const neededOutSize = zds->fParams.windowSize + blockSize + WILDCOPY_OVERLENGTH * 2;\n                    zds->blockSize = blockSize;\n                    if (zds->inBuffSize < blockSize) {\n                        ZSTD_free(zds->inBuff, zds->customMem);\n                        zds->inBuffSize = 0;\n                        zds->inBuff = (char*)ZSTD_malloc(blockSize, zds->customMem);\n                        if (zds->inBuff == NULL) return ERROR(memory_allocation);\n                        zds->inBuffSize = blockSize;\n                    }\n                    if (zds->outBuffSize < neededOutSize) {\n                        ZSTD_free(zds->outBuff, zds->customMem);\n                        zds->outBuffSize = 0;\n                        zds->outBuff = (char*)ZSTD_malloc(neededOutSize, zds->customMem);\n                        if (zds->outBuff == NULL) return ERROR(memory_allocation);\n                        zds->outBuffSize = neededOutSize;\n                }   }\n                zds->stage = zdss_read;\n            }",
        "base_contents": "            zds->fParams.windowSize = MAX(zds->fParams.windowSize, 1U << ZSTD_WINDOWLOG_ABSOLUTEMIN);\n            if (zds->fParams.windowSize > zds->maxWindowSize) return ERROR(frameParameter_windowTooLarge);\n\n            /* Adapt buffer sizes to frame header instructions */\n            {   size_t const blockSize = MIN(zds->fParams.windowSize, ZSTD_BLOCKSIZE_ABSOLUTEMAX);\n                size_t const neededOutSize = zds->fParams.windowSize + blockSize + WILDCOPY_OVERLENGTH * 2;\n                zds->blockSize = blockSize;\n                if (zds->inBuffSize < blockSize) {\n                    ZSTD_free(zds->inBuff, zds->customMem);\n                    zds->inBuffSize = 0;\n                    zds->inBuff = (char*)ZSTD_malloc(blockSize, zds->customMem);\n                    if (zds->inBuff == NULL) return ERROR(memory_allocation);\n                    zds->inBuffSize = blockSize;\n                }\n                if (zds->outBuffSize < neededOutSize) {\n                    ZSTD_free(zds->outBuff, zds->customMem);\n                    zds->outBuffSize = 0;\n                    zds->outBuff = (char*)ZSTD_malloc(neededOutSize, zds->customMem);\n                    if (zds->outBuff == NULL) return ERROR(memory_allocation);\n                    zds->outBuffSize = neededOutSize;\n            }   }\n            zds->stage = zdss_read;",
        "res_region": "            zds->fParams.windowSize = MAX(zds->fParams.windowSize, 1U << ZSTD_WINDOWLOG_ABSOLUTEMIN);\n            if (zds->fParams.windowSize > zds->maxWindowSize) return ERROR(frameParameter_windowTooLarge);\n\n            /* Adapt buffer sizes to frame header instructions */\n            {   size_t const blockSize = MIN(zds->fParams.windowSize, ZSTD_BLOCKSIZE_MAX);\n                size_t const neededOutSize = zds->fParams.windowSize + blockSize + WILDCOPY_OVERLENGTH * 2;\n                zds->blockSize = blockSize;\n                if ((zds->inBuffSize < blockSize) || (zds->outBuffSize < neededOutSize)) {\n                    size_t const bufferSize = blockSize + neededOutSize;\n                    DEBUGLOG(5, \"inBuff  : from %u to %u\",\n                                (U32)zds->inBuffSize, (U32)blockSize);\n                    DEBUGLOG(5, \"outBuff : from %u to %u\",\n                                (U32)zds->outBuffSize, (U32)neededOutSize);\n                    if (zds->staticSize) {  /* static DCtx */\n                        DEBUGLOG(4, \"staticSize : %u\", (U32)zds->staticSize);\n                        assert(zds->staticSize >= sizeof(ZSTD_DCtx));  /* already checked at init */\n                        if (bufferSize > zds->staticSize - sizeof(ZSTD_DCtx))\n                            return ERROR(memory_allocation);\n                    } else {\n                        ZSTD_free(zds->inBuff, zds->customMem);\n                        zds->inBuffSize = 0;\n                        zds->outBuffSize = 0;\n                        zds->inBuff = (char*)ZSTD_malloc(bufferSize, zds->customMem);\n                        if (zds->inBuff == NULL) return ERROR(memory_allocation);\n                    }\n                    zds->inBuffSize = blockSize;\n                    zds->outBuff = zds->inBuff + zds->inBuffSize;\n                    zds->outBuffSize = neededOutSize;\n            }   }\n            zds->streamStage = zdss_read;",
        "lookback": "            if (zds->fParams.windowSize > zds->maxWindowSize) return ERROR(frameParameter_windowTooLarge);",
        "lookahead": "            /* pass-through */",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 2382,
        "end_line": 2460,
        "merge_gen_region": null,
        "confidence": 0.8347753882408142,
        "hesitated": true
    }
]