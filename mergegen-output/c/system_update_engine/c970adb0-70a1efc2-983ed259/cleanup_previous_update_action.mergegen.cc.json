[
    {
        "a_contents": "//\n// Copyright (C) 2020 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n#include \"update_engine/cleanup_previous_update_action.h\"\n\n#include <chrono>  // NOLINT(build/c++11) -- for merge times\n#include <functional>\n#include <string>\n\n#include <android-base/properties.h>\n#include <base/bind.h>\n\n#ifndef __ANDROID_RECOVERY__\n#include <statslog.h>\n#endif\n\n#include \"update_engine/common/utils.h\"\n#include \"update_engine/payload_consumer/delta_performer.h\"\n\nusing android::snapshot::SnapshotManager;\nusing android::snapshot::SnapshotMergeStats;\nusing android::snapshot::UpdateState;\nusing brillo::MessageLoop;\n\nconstexpr char kBootCompletedProp[] = \"sys.boot_completed\";\n// Interval to check sys.boot_completed.\nconstexpr auto kCheckBootCompletedInterval = base::TimeDelta::FromSeconds(2);\n// Interval to check IBootControl::isSlotMarkedSuccessful\nconstexpr auto kCheckSlotMarkedSuccessfulInterval =\n    base::TimeDelta::FromSeconds(2);\n// Interval to call SnapshotManager::ProcessUpdateState\nconstexpr auto kWaitForMergeInterval = base::TimeDelta::FromSeconds(2);\n\nnamespace chromeos_update_engine {\n\nCleanupPreviousUpdateAction::CleanupPreviousUpdateAction(\n    PrefsInterface* prefs,\n    BootControlInterface* boot_control,\n    android::snapshot::SnapshotManager* snapshot,\n    CleanupPreviousUpdateActionDelegateInterface* delegate)\n    : prefs_(prefs),\n      boot_control_(boot_control),\n      snapshot_(snapshot),\n      delegate_(delegate),\n      running_(false),\n      cancel_failed_(false),\n      last_percentage_(0),\n      merge_stats_(SnapshotMergeStats::GetInstance(*snapshot)) {}\n\nvoid CleanupPreviousUpdateAction::PerformAction() {\n  ResumeAction();\n}\n\nvoid CleanupPreviousUpdateAction::TerminateProcessing() {\n  SuspendAction();\n}\n\nvoid CleanupPreviousUpdateAction::ResumeAction() {\n  CHECK(prefs_);\n  CHECK(boot_control_);\n\n  LOG(INFO) << \"Starting/resuming CleanupPreviousUpdateAction\";\n  running_ = true;\n  StartActionInternal();\n}\n\nvoid CleanupPreviousUpdateAction::SuspendAction() {\n  LOG(INFO) << \"Stopping/suspending CleanupPreviousUpdateAction\";\n  running_ = false;\n}\n\nvoid CleanupPreviousUpdateAction::ActionCompleted(ErrorCode error_code) {\n  running_ = false;\n  ReportMergeStats();\n}\n\nstd::string CleanupPreviousUpdateAction::Type() const {\n  return StaticType();\n}\n\nstd::string CleanupPreviousUpdateAction::StaticType() {\n  return \"CleanupPreviousUpdateAction\";\n}\n\nvoid CleanupPreviousUpdateAction::StartActionInternal() {\n  // Do nothing on non-VAB device.\n  if (!boot_control_->GetDynamicPartitionControl()\n           ->GetVirtualAbFeatureFlag()\n           .IsEnabled()) {\n    processor_->ActionComplete(this, ErrorCode::kSuccess);\n    return;\n  }\n  // SnapshotManager is only available on VAB devices.\n  CHECK(snapshot_);\n  WaitBootCompletedOrSchedule();\n}\n\nvoid CleanupPreviousUpdateAction::ScheduleWaitBootCompleted() {\n  TEST_AND_RETURN(running_);\n  MessageLoop::current()->PostDelayedTask(\n      FROM_HERE,\n      base::Bind(&CleanupPreviousUpdateAction::WaitBootCompletedOrSchedule,\n                 base::Unretained(this)),\n      kCheckBootCompletedInterval);\n}\n\nvoid CleanupPreviousUpdateAction::WaitBootCompletedOrSchedule() {\n  TEST_AND_RETURN(running_);\n  if (!android::base::GetBoolProperty(kBootCompletedProp, false)) {\n    // repeat\n    ScheduleWaitBootCompleted();\n    return;\n  }\n\n  LOG(INFO) << \"Boot completed, waiting on markBootSuccessful()\";\n  CheckSlotMarkedSuccessfulOrSchedule();\n}\n\nvoid CleanupPreviousUpdateAction::ScheduleWaitMarkBootSuccessful() {\n  TEST_AND_RETURN(running_);\n  MessageLoop::current()->PostDelayedTask(\n      FROM_HERE,\n      base::Bind(\n          &CleanupPreviousUpdateAction::CheckSlotMarkedSuccessfulOrSchedule,\n          base::Unretained(this)),\n      kCheckSlotMarkedSuccessfulInterval);\n}\n\nvoid CleanupPreviousUpdateAction::CheckSlotMarkedSuccessfulOrSchedule() {\n  TEST_AND_RETURN(running_);\n  if (!boot_control_->IsSlotMarkedSuccessful(boot_control_->GetCurrentSlot())) {\n    ScheduleWaitMarkBootSuccessful();\n  }\n  if (!merge_stats_->Start()) {\n    // Not an error because CleanupPreviousUpdateAction may be paused and\n    // resumed while kernel continues merging snapshots in the background.\n    LOG(WARNING) << \"SnapshotMergeStats::Start failed.\";\n  }\n  LOG(INFO) << \"Waiting for any previous merge request to complete. \"\n            << \"This can take up to several minutes.\";\n  WaitForMergeOrSchedule();\n}\n\nvoid CleanupPreviousUpdateAction::ScheduleWaitForMerge() {\n  TEST_AND_RETURN(running_);\n  MessageLoop::current()->PostDelayedTask(\n      FROM_HERE,\n      base::Bind(&CleanupPreviousUpdateAction::WaitForMergeOrSchedule,\n                 base::Unretained(this)),\n      kWaitForMergeInterval);\n}\n\nvoid CleanupPreviousUpdateAction::WaitForMergeOrSchedule() {\n  TEST_AND_RETURN(running_);\n  auto state = snapshot_->ProcessUpdateState(\n      std::bind(&CleanupPreviousUpdateAction::OnMergePercentageUpdate, this),\n      std::bind(&CleanupPreviousUpdateAction::BeforeCancel, this));\n  merge_stats_->set_state(state);\n\n  switch (state) {\n    case UpdateState::None: {\n      LOG(INFO) << \"Can't find any snapshot to merge.\";\n      processor_->ActionComplete(this, ErrorCode::kSuccess);\n      return;\n    }\n\n    case UpdateState::Initiated: {\n      LOG(ERROR) << \"Previous update has not been completed, not cleaning up\";\n      processor_->ActionComplete(this, ErrorCode::kSuccess);\n      return;\n    }\n\n    case UpdateState::Unverified: {\n      InitiateMergeAndWait();\n      return;\n    }\n\n    case UpdateState::Merging: {\n      ScheduleWaitForMerge();\n      return;\n    }\n\n    case UpdateState::MergeNeedsReboot: {\n      LOG(ERROR) << \"Need reboot to finish merging.\";\n      processor_->ActionComplete(this, ErrorCode::kError);\n      return;\n    }\n\n    case UpdateState::MergeCompleted: {\n      LOG(INFO) << \"Merge finished with state MergeCompleted.\";\n      processor_->ActionComplete(this, ErrorCode::kSuccess);\n      return;\n    }\n\n    case UpdateState::MergeFailed: {\n      LOG(ERROR) << \"Merge failed. Device may be corrupted.\";\n      processor_->ActionComplete(this, ErrorCode::kDeviceCorrupted);\n      return;\n    }\n\n    case UpdateState::Cancelled: {\n      // DeltaPerformer::ResetUpdateProgress failed, hence snapshots are\n      // not deleted to avoid inconsistency.\n      // Nothing can be done here; just try next time.\n      ErrorCode error_code =\n          cancel_failed_ ? ErrorCode::kError : ErrorCode::kSuccess;\n      processor_->ActionComplete(this, error_code);\n      return;\n    }\n\n    default: {\n      // Protobuf has some reserved enum values, so a default case is needed.\n      LOG(FATAL) << \"SnapshotManager::ProcessUpdateState returns \"\n                 << static_cast<int32_t>(state);\n    }\n  }\n}\n\nbool CleanupPreviousUpdateAction::OnMergePercentageUpdate() {\n  double percentage = 0.0;\n  snapshot_->GetUpdateState(&percentage);\n  if (delegate_) {\n    // libsnapshot uses [0, 100] percentage but update_engine uses [0, 1].\n    delegate_->OnCleanupProgressUpdate(percentage / 100);\n  }\n\n  // Log if percentage increments by at least 1.\n  if (last_percentage_ < static_cast<unsigned int>(percentage)) {\n    last_percentage_ = percentage;\n    LOG(INFO) << \"Waiting for merge to complete: \" << last_percentage_ << \"%.\";\n  }\n\n  // Do not continue to wait for merge. Instead, let ProcessUpdateState\n  // return Merging directly so that we can ScheduleWaitForMerge() in\n  // MessageLoop.\n  return false;\n}\n\nbool CleanupPreviousUpdateAction::BeforeCancel() {\n  if (DeltaPerformer::ResetUpdateProgress(\n          prefs_,\n          false /* quick */,\n          false /* skip dynamic partitions metadata*/)) {\n    return true;\n  }\n\n  // ResetUpdateProgress might not work on stub prefs. Do additional checks.\n  LOG(WARNING) << \"ProcessUpdateState returns Cancelled but cleanup failed.\";\n\n  std::string val;\n  ignore_result(prefs_->GetString(kPrefsDynamicPartitionMetadataUpdated, &val));\n  if (val.empty()) {\n    LOG(INFO) << kPrefsDynamicPartitionMetadataUpdated\n              << \" is empty, assuming successful cleanup\";\n    return true;\n  }\n  LOG(WARNING)\n      << kPrefsDynamicPartitionMetadataUpdated << \" is \" << val\n      << \", not deleting snapshots even though UpdateState is Cancelled.\";\n  cancel_failed_ = true;\n  return false;\n}\n\nvoid CleanupPreviousUpdateAction::InitiateMergeAndWait() {\n  TEST_AND_RETURN(running_);\n  LOG(INFO) << \"Attempting to initiate merge.\";\n\n  if (snapshot_->InitiateMerge()) {\n    WaitForMergeOrSchedule();\n    return;\n  }\n\n  LOG(WARNING) << \"InitiateMerge failed.\";\n  auto state = snapshot_->GetUpdateState();\n  merge_stats_->set_state(state);\n  if (state == UpdateState::Unverified) {\n    // We are stuck at unverified state. This can happen if the update has\n    // been applied, but it has not even been attempted yet (in libsnapshot,\n    // rollback indicator does not exist); for example, if update_engine\n    // restarts before the device reboots, then this state may be reached.\n    // Nothing should be done here.\n    LOG(WARNING) << \"InitiateMerge leaves the device at \"\n                 << \"UpdateState::Unverified. (Did update_engine \"\n                 << \"restarted?)\";\n    processor_->ActionComplete(this, ErrorCode::kSuccess);\n    return;\n  }\n\n  // State does seems to be advanced.\n  // It is possibly racy. For example, on a userdebug build, the user may\n  // manually initiate a merge with snapshotctl between last time\n  // update_engine checks UpdateState. Hence, just call\n  // WaitForMergeOrSchedule one more time.\n  LOG(WARNING) << \"IniitateMerge failed but GetUpdateState returned \"\n               << android::snapshot::UpdateState_Name(state)\n               << \", try to wait for merge again.\";\n  WaitForMergeOrSchedule();\n  return;\n}\n\nvoid CleanupPreviousUpdateAction::ReportMergeStats() {\n  auto result = merge_stats_->Finish();\n  if (result == nullptr) {\n    LOG(WARNING) << \"Not reporting merge stats because \"\n                    \"SnapshotMergeStats::Finish failed.\";\n    return;\n  }\n\n#ifdef __ANDROID_RECOVERY__\n  LOG(INFO) << \"Skip reporting merge stats in recovery.\";\n#else\n  const auto& report = result->report();\n\n  if (report.state() == UpdateState::None ||\n      report.state() == UpdateState::Initiated ||\n      report.state() == UpdateState::Unverified) {\n    LOG(INFO) << \"Not reporting merge stats because state is \"\n              << android::snapshot::UpdateState_Name(report.state());\n    return;\n  }\n\n  auto passed_ms = std::chrono::duration_cast<std::chrono::milliseconds>(\n      result->merge_time());\n  LOG(INFO) << \"Reporting merge stats: \"\n            << android::snapshot::UpdateState_Name(report.state()) << \" in \"\n            << passed_ms.count() << \"ms (resumed \" << report.resume_count()\n            << \" times)\";\n  android::util::stats_write(android::util::SNAPSHOT_MERGE_REPORTED,\n                             static_cast<int32_t>(report.state()),\n                             static_cast<int64_t>(passed_ms.count()),\n                             static_cast<int32_t>(report.resume_count()));\n#endif\n}\n\n}  // namespace chromeos_update_engine",
        "b_contents": "//\n// Copyright (C) 2020 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n#include \"update_engine/cleanup_previous_update_action.h\"\n\n#include <functional>\n#include <string>\n\n#include <android-base/properties.h>\n#include <base/bind.h>\n\n#include \"update_engine/common/utils.h\"\n#include \"update_engine/payload_consumer/delta_performer.h\"\n\nusing android::snapshot::SnapshotManager;\nusing android::snapshot::UpdateState;\nusing brillo::MessageLoop;\n\nconstexpr char kBootCompletedProp[] = \"sys.boot_completed\";\n// Interval to check sys.boot_completed.\nconstexpr auto kCheckBootCompletedInterval = base::TimeDelta::FromSeconds(2);\n// Interval to check IBootControl::isSlotMarkedSuccessful\nconstexpr auto kCheckSlotMarkedSuccessfulInterval =\n    base::TimeDelta::FromSeconds(2);\n// Interval to call SnapshotManager::ProcessUpdateState\nconstexpr auto kWaitForMergeInterval = base::TimeDelta::FromSeconds(2);\n\nnamespace chromeos_update_engine {\n\nCleanupPreviousUpdateAction::CleanupPreviousUpdateAction(\n    PrefsInterface* prefs,\n    BootControlInterface* boot_control,\n    android::snapshot::SnapshotManager* snapshot,\n    CleanupPreviousUpdateActionDelegateInterface* delegate)\n    : prefs_(prefs),\n      boot_control_(boot_control),\n      snapshot_(snapshot),\n      delegate_(delegate),\n      running_(false),\n      cancel_failed_(false),\n      last_percentage_(0) {}\n\nvoid CleanupPreviousUpdateAction::PerformAction() {\n  ResumeAction();\n}\n\nvoid CleanupPreviousUpdateAction::TerminateProcessing() {\n  SuspendAction();\n}\n\nvoid CleanupPreviousUpdateAction::ResumeAction() {\n  CHECK(prefs_);\n  CHECK(boot_control_);\n\n  LOG(INFO) << \"Starting/resuming CleanupPreviousUpdateAction\";\n  running_ = true;\n  StartActionInternal();\n}\n\nvoid CleanupPreviousUpdateAction::SuspendAction() {\n  LOG(INFO) << \"Stopping/suspending CleanupPreviousUpdateAction\";\n  running_ = false;\n}\n\nvoid CleanupPreviousUpdateAction::ActionCompleted(ErrorCode error_code) {\n  running_ = false;\n}\n\nstd::string CleanupPreviousUpdateAction::Type() const {\n  return StaticType();\n}\n\nstd::string CleanupPreviousUpdateAction::StaticType() {\n  return \"CleanupPreviousUpdateAction\";\n}\n\nvoid CleanupPreviousUpdateAction::StartActionInternal() {\n  // Do nothing on non-VAB device.\n  if (!boot_control_->GetDynamicPartitionControl()\n           ->GetVirtualAbFeatureFlag()\n           .IsEnabled()) {\n    processor_->ActionComplete(this, ErrorCode::kSuccess);\n    return;\n  }\n  // SnapshotManager is only available on VAB devices.\n  CHECK(snapshot_);\n  WaitBootCompletedOrSchedule();\n}\n\nvoid CleanupPreviousUpdateAction::ScheduleWaitBootCompleted() {\n  TEST_AND_RETURN(running_);\n  MessageLoop::current()->PostDelayedTask(\n      FROM_HERE,\n      base::Bind(&CleanupPreviousUpdateAction::WaitBootCompletedOrSchedule,\n                 base::Unretained(this)),\n      kCheckBootCompletedInterval);\n}\n\nvoid CleanupPreviousUpdateAction::WaitBootCompletedOrSchedule() {\n  TEST_AND_RETURN(running_);\n  if (!android::base::GetBoolProperty(kBootCompletedProp, false)) {\n    // repeat\n    ScheduleWaitBootCompleted();\n    return;\n  }\n\n  LOG(INFO) << \"Boot completed, waiting on markBootSuccessful()\";\n  CheckSlotMarkedSuccessfulOrSchedule();\n}\n\nvoid CleanupPreviousUpdateAction::ScheduleWaitMarkBootSuccessful() {\n  TEST_AND_RETURN(running_);\n  MessageLoop::current()->PostDelayedTask(\n      FROM_HERE,\n      base::Bind(\n          &CleanupPreviousUpdateAction::CheckSlotMarkedSuccessfulOrSchedule,\n          base::Unretained(this)),\n      kCheckSlotMarkedSuccessfulInterval);\n}\n\nvoid CleanupPreviousUpdateAction::CheckSlotMarkedSuccessfulOrSchedule() {\n  TEST_AND_RETURN(running_);\n  if (!boot_control_->IsSlotMarkedSuccessful(boot_control_->GetCurrentSlot())) {\n    ScheduleWaitMarkBootSuccessful();\n  }\n  LOG(INFO) << \"Waiting for any previous merge request to complete. \"\n            << \"This can take up to several minutes.\";\n  WaitForMergeOrSchedule();\n}\n\nvoid CleanupPreviousUpdateAction::ScheduleWaitForMerge() {\n  TEST_AND_RETURN(running_);\n  MessageLoop::current()->PostDelayedTask(\n      FROM_HERE,\n      base::Bind(&CleanupPreviousUpdateAction::WaitForMergeOrSchedule,\n                 base::Unretained(this)),\n      kWaitForMergeInterval);\n}\n\nvoid CleanupPreviousUpdateAction::WaitForMergeOrSchedule() {\n  TEST_AND_RETURN(running_);\n  auto state = snapshot_->ProcessUpdateState(\n      std::bind(&CleanupPreviousUpdateAction::OnMergePercentageUpdate, this),\n      std::bind(&CleanupPreviousUpdateAction::BeforeCancel, this));\n\n  // TODO(elsk): log stats\n  switch (state) {\n    case UpdateState::None: {\n      LOG(INFO) << \"Can't find any snapshot to merge.\";\n      processor_->ActionComplete(this, ErrorCode::kSuccess);\n      return;\n    }\n\n    case UpdateState::Initiated: {\n      LOG(ERROR) << \"Previous update has not been completed, not cleaning up\";\n      processor_->ActionComplete(this, ErrorCode::kSuccess);\n      return;\n    }\n\n    case UpdateState::Unverified: {\n      InitiateMergeAndWait();\n      return;\n    }\n\n    case UpdateState::Merging: {\n      ScheduleWaitForMerge();\n      return;\n    }\n\n    case UpdateState::MergeNeedsReboot: {\n      LOG(ERROR) << \"Need reboot to finish merging.\";\n      processor_->ActionComplete(this, ErrorCode::kError);\n      return;\n    }\n\n    case UpdateState::MergeCompleted: {\n      LOG(INFO) << \"Merge finished with state MergeCompleted.\";\n      processor_->ActionComplete(this, ErrorCode::kSuccess);\n      return;\n    }\n\n    case UpdateState::MergeFailed: {\n      LOG(ERROR) << \"Merge failed. Device may be corrupted.\";\n      processor_->ActionComplete(this, ErrorCode::kDeviceCorrupted);\n      return;\n    }\n\n    case UpdateState::Cancelled: {\n      // DeltaPerformer::ResetUpdateProgress failed, hence snapshots are\n      // not deleted to avoid inconsistency.\n      // Nothing can be done here; just try next time.\n      ErrorCode error_code =\n          cancel_failed_ ? ErrorCode::kError : ErrorCode::kSuccess;\n      processor_->ActionComplete(this, error_code);\n      return;\n    }\n\n    default: {\n      // Protobuf has some reserved enum values, so a default case is needed.\n      LOG(FATAL) << \"SnapshotManager::ProcessUpdateState returns \"\n                 << static_cast<int32_t>(state);\n    }\n  }\n}\n\nbool CleanupPreviousUpdateAction::OnMergePercentageUpdate() {\n  double percentage = 0.0;\n  snapshot_->GetUpdateState(&percentage);\n  if (delegate_) {\n    // libsnapshot uses [0, 100] percentage but update_engine uses [0, 1].\n    delegate_->OnCleanupProgressUpdate(percentage / 100);\n  }\n\n  // Log if percentage increments by at least 1.\n  if (last_percentage_ < static_cast<unsigned int>(percentage)) {\n    last_percentage_ = percentage;\n    LOG(INFO) << \"Waiting for merge to complete: \" << last_percentage_ << \"%.\";\n  }\n\n  // Do not continue to wait for merge. Instead, let ProcessUpdateState\n  // return Merging directly so that we can ScheduleWaitForMerge() in\n  // MessageLoop.\n  return false;\n}\n\nbool CleanupPreviousUpdateAction::BeforeCancel() {\n  if (DeltaPerformer::ResetUpdateProgress(\n          prefs_,\n          false /* quick */,\n          false /* skip dynamic partitions metadata*/)) {\n    return true;\n  }\n\n  // ResetUpdateProgress might not work on stub prefs. Do additional checks.\n  LOG(WARNING) << \"ProcessUpdateState returns Cancelled but cleanup failed.\";\n\n  std::string val;\n  ignore_result(prefs_->GetString(kPrefsDynamicPartitionMetadataUpdated, &val));\n  if (val.empty()) {\n    LOG(INFO) << kPrefsDynamicPartitionMetadataUpdated\n              << \" is empty, assuming successful cleanup\";\n    return true;\n  }\n  LOG(WARNING)\n      << kPrefsDynamicPartitionMetadataUpdated << \" is \" << val\n      << \", not deleting snapshots even though UpdateState is Cancelled.\";\n  cancel_failed_ = true;\n  return false;\n}\n\nvoid CleanupPreviousUpdateAction::InitiateMergeAndWait() {\n  TEST_AND_RETURN(running_);\n  LOG(INFO) << \"Attempting to initiate merge.\";\n\n  if (snapshot_->InitiateMerge()) {\n    WaitForMergeOrSchedule();\n    return;\n  }\n\n  LOG(WARNING) << \"InitiateMerge failed.\";\n  auto state = snapshot_->GetUpdateState();\n  if (state == UpdateState::Unverified) {\n    // We are stuck at unverified state. This can happen if the update has\n    // been applied, but it has not even been attempted yet (in libsnapshot,\n    // rollback indicator does not exist); for example, if update_engine\n    // restarts before the device reboots, then this state may be reached.\n    // Nothing should be done here.\n    LOG(WARNING) << \"InitiateMerge leaves the device at \"\n                 << \"UpdateState::Unverified. (Did update_engine \"\n                 << \"restarted?)\";\n    processor_->ActionComplete(this, ErrorCode::kSuccess);\n    return;\n  }\n\n  // State does seems to be advanced.\n  // It is possibly racy. For example, on a userdebug build, the user may\n  // manually initiate a merge with snapshotctl between last time\n  // update_engine checks UpdateState. Hence, just call\n  // WaitForMergeOrSchedule one more time.\n  LOG(WARNING) << \"IniitateMerge failed but GetUpdateState returned \"\n               << android::snapshot::UpdateState_Name(state)\n               << \", try to wait for merge again.\";\n  WaitForMergeOrSchedule();\n  return;\n}\n\n}  // namespace chromeos_update_engine",
        "base_contents": "",
        "res_region": "//\n// Copyright (C) 2020 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n#include \"update_engine/cleanup_previous_update_action.h\"\n\n#include <chrono>  // NOLINT(build/c++11) -- for merge times\n#include <functional>\n#include <string>\n\n#include <android-base/properties.h>\n#include <base/bind.h>\n\n#ifndef __ANDROID_RECOVERY__\n#include <statslog.h>\n#endif\n\n#include \"update_engine/common/utils.h\"\n#include \"update_engine/payload_consumer/delta_performer.h\"\n\nusing android::snapshot::SnapshotManager;\nusing android::snapshot::SnapshotMergeStats;\nusing android::snapshot::UpdateState;\nusing brillo::MessageLoop;\n\nconstexpr char kBootCompletedProp[] = \"sys.boot_completed\";\n// Interval to check sys.boot_completed.\nconstexpr auto kCheckBootCompletedInterval = base::TimeDelta::FromSeconds(2);\n// Interval to check IBootControl::isSlotMarkedSuccessful\nconstexpr auto kCheckSlotMarkedSuccessfulInterval =\n    base::TimeDelta::FromSeconds(2);\n// Interval to call SnapshotManager::ProcessUpdateState\nconstexpr auto kWaitForMergeInterval = base::TimeDelta::FromSeconds(2);\n\nnamespace chromeos_update_engine {\n\nCleanupPreviousUpdateAction::CleanupPreviousUpdateAction(\n    PrefsInterface* prefs,\n    BootControlInterface* boot_control,\n    android::snapshot::SnapshotManager* snapshot,\n    CleanupPreviousUpdateActionDelegateInterface* delegate)\n    : prefs_(prefs),\n      boot_control_(boot_control),\n      snapshot_(snapshot),\n      delegate_(delegate),\n      running_(false),\n      cancel_failed_(false),\n      last_percentage_(0),\n      merge_stats_(SnapshotMergeStats::GetInstance(*snapshot)) {}\n\nvoid CleanupPreviousUpdateAction::PerformAction() {\n  ResumeAction();\n}\n\nvoid CleanupPreviousUpdateAction::TerminateProcessing() {\n  SuspendAction();\n}\n\nvoid CleanupPreviousUpdateAction::ResumeAction() {\n  CHECK(prefs_);\n  CHECK(boot_control_);\n\n  LOG(INFO) << \"Starting/resuming CleanupPreviousUpdateAction\";\n  running_ = true;\n  StartActionInternal();\n}\n\nvoid CleanupPreviousUpdateAction::SuspendAction() {\n  LOG(INFO) << \"Stopping/suspending CleanupPreviousUpdateAction\";\n  running_ = false;\n}\n\nvoid CleanupPreviousUpdateAction::ActionCompleted(ErrorCode error_code) {\n  running_ = false;\n  ReportMergeStats();\n}\n\nstd::string CleanupPreviousUpdateAction::Type() const {\n  return StaticType();\n}\n\nstd::string CleanupPreviousUpdateAction::StaticType() {\n  return \"CleanupPreviousUpdateAction\";\n}\n\nvoid CleanupPreviousUpdateAction::StartActionInternal() {\n  // Do nothing on non-VAB device.\n  if (!boot_control_->GetDynamicPartitionControl()\n           ->GetVirtualAbFeatureFlag()\n           .IsEnabled()) {\n    processor_->ActionComplete(this, ErrorCode::kSuccess);\n    return;\n  }\n  // SnapshotManager is only available on VAB devices.\n  CHECK(snapshot_);\n  WaitBootCompletedOrSchedule();\n}\n\nvoid CleanupPreviousUpdateAction::ScheduleWaitBootCompleted() {\n  TEST_AND_RETURN(running_);\n  MessageLoop::current()->PostDelayedTask(\n      FROM_HERE,\n      base::Bind(&CleanupPreviousUpdateAction::WaitBootCompletedOrSchedule,\n                 base::Unretained(this)),\n      kCheckBootCompletedInterval);\n}\n\nvoid CleanupPreviousUpdateAction::WaitBootCompletedOrSchedule() {\n  TEST_AND_RETURN(running_);\n  if (!android::base::GetBoolProperty(kBootCompletedProp, false)) {\n    // repeat\n    ScheduleWaitBootCompleted();\n    return;\n  }\n\n  LOG(INFO) << \"Boot completed, waiting on markBootSuccessful()\";\n  CheckSlotMarkedSuccessfulOrSchedule();\n}\n\nvoid CleanupPreviousUpdateAction::ScheduleWaitMarkBootSuccessful() {\n  TEST_AND_RETURN(running_);\n  MessageLoop::current()->PostDelayedTask(\n      FROM_HERE,\n      base::Bind(\n          &CleanupPreviousUpdateAction::CheckSlotMarkedSuccessfulOrSchedule,\n          base::Unretained(this)),\n      kCheckSlotMarkedSuccessfulInterval);\n}\n\nvoid CleanupPreviousUpdateAction::CheckSlotMarkedSuccessfulOrSchedule() {\n  TEST_AND_RETURN(running_);\n  if (!boot_control_->IsSlotMarkedSuccessful(boot_control_->GetCurrentSlot())) {\n    ScheduleWaitMarkBootSuccessful();\n  }\n  if (!merge_stats_->Start()) {\n    // Not an error because CleanupPreviousUpdateAction may be paused and\n    // resumed while kernel continues merging snapshots in the background.\n    LOG(WARNING) << \"SnapshotMergeStats::Start failed.\";\n  }\n  LOG(INFO) << \"Waiting for any previous merge request to complete. \"\n            << \"This can take up to several minutes.\";\n  WaitForMergeOrSchedule();\n}\n\nvoid CleanupPreviousUpdateAction::ScheduleWaitForMerge() {\n  TEST_AND_RETURN(running_);\n  MessageLoop::current()->PostDelayedTask(\n      FROM_HERE,\n      base::Bind(&CleanupPreviousUpdateAction::WaitForMergeOrSchedule,\n                 base::Unretained(this)),\n      kWaitForMergeInterval);\n}\n\nvoid CleanupPreviousUpdateAction::WaitForMergeOrSchedule() {\n  TEST_AND_RETURN(running_);\n  auto state = snapshot_->ProcessUpdateState(\n      std::bind(&CleanupPreviousUpdateAction::OnMergePercentageUpdate, this),\n      std::bind(&CleanupPreviousUpdateAction::BeforeCancel, this));\n  merge_stats_->set_state(state);\n\n  switch (state) {\n    case UpdateState::None: {\n      LOG(INFO) << \"Can't find any snapshot to merge.\";\n      processor_->ActionComplete(this, ErrorCode::kSuccess);\n      return;\n    }\n\n    case UpdateState::Initiated: {\n      LOG(ERROR) << \"Previous update has not been completed, not cleaning up\";\n      processor_->ActionComplete(this, ErrorCode::kSuccess);\n      return;\n    }\n\n    case UpdateState::Unverified: {\n      InitiateMergeAndWait();\n      return;\n    }\n\n    case UpdateState::Merging: {\n      ScheduleWaitForMerge();\n      return;\n    }\n\n    case UpdateState::MergeNeedsReboot: {\n      LOG(ERROR) << \"Need reboot to finish merging.\";\n      processor_->ActionComplete(this, ErrorCode::kError);\n      return;\n    }\n\n    case UpdateState::MergeCompleted: {\n      LOG(INFO) << \"Merge finished with state MergeCompleted.\";\n      processor_->ActionComplete(this, ErrorCode::kSuccess);\n      return;\n    }\n\n    case UpdateState::MergeFailed: {\n      LOG(ERROR) << \"Merge failed. Device may be corrupted.\";\n      processor_->ActionComplete(this, ErrorCode::kDeviceCorrupted);\n      return;\n    }\n\n    case UpdateState::Cancelled: {\n      // DeltaPerformer::ResetUpdateProgress failed, hence snapshots are\n      // not deleted to avoid inconsistency.\n      // Nothing can be done here; just try next time.\n      ErrorCode error_code =\n          cancel_failed_ ? ErrorCode::kError : ErrorCode::kSuccess;\n      processor_->ActionComplete(this, error_code);\n      return;\n    }\n\n    default: {\n      // Protobuf has some reserved enum values, so a default case is needed.\n      LOG(FATAL) << \"SnapshotManager::ProcessUpdateState returns \"\n                 << static_cast<int32_t>(state);\n    }\n  }\n}\n\nbool CleanupPreviousUpdateAction::OnMergePercentageUpdate() {\n  double percentage = 0.0;\n  snapshot_->GetUpdateState(&percentage);\n  if (delegate_) {\n    // libsnapshot uses [0, 100] percentage but update_engine uses [0, 1].\n    delegate_->OnCleanupProgressUpdate(percentage / 100);\n  }\n\n  // Log if percentage increments by at least 1.\n  if (last_percentage_ < static_cast<unsigned int>(percentage)) {\n    last_percentage_ = percentage;\n    LOG(INFO) << \"Waiting for merge to complete: \" << last_percentage_ << \"%.\";\n  }\n\n  // Do not continue to wait for merge. Instead, let ProcessUpdateState\n  // return Merging directly so that we can ScheduleWaitForMerge() in\n  // MessageLoop.\n  return false;\n}\n\nbool CleanupPreviousUpdateAction::BeforeCancel() {\n  if (DeltaPerformer::ResetUpdateProgress(\n          prefs_,\n          false /* quick */,\n          false /* skip dynamic partitions metadata*/)) {\n    return true;\n  }\n\n  // ResetUpdateProgress might not work on stub prefs. Do additional checks.\n  LOG(WARNING) << \"ProcessUpdateState returns Cancelled but cleanup failed.\";\n\n  std::string val;\n  ignore_result(prefs_->GetString(kPrefsDynamicPartitionMetadataUpdated, &val));\n  if (val.empty()) {\n    LOG(INFO) << kPrefsDynamicPartitionMetadataUpdated\n              << \" is empty, assuming successful cleanup\";\n    return true;\n  }\n  LOG(WARNING)\n      << kPrefsDynamicPartitionMetadataUpdated << \" is \" << val\n      << \", not deleting snapshots even though UpdateState is Cancelled.\";\n  cancel_failed_ = true;\n  return false;\n}\n\nvoid CleanupPreviousUpdateAction::InitiateMergeAndWait() {\n  TEST_AND_RETURN(running_);\n  LOG(INFO) << \"Attempting to initiate merge.\";\n\n  if (snapshot_->InitiateMerge()) {\n    WaitForMergeOrSchedule();\n    return;\n  }\n\n  LOG(WARNING) << \"InitiateMerge failed.\";\n  auto state = snapshot_->GetUpdateState();\n  merge_stats_->set_state(state);\n  if (state == UpdateState::Unverified) {\n    // We are stuck at unverified state. This can happen if the update has\n    // been applied, but it has not even been attempted yet (in libsnapshot,\n    // rollback indicator does not exist); for example, if update_engine\n    // restarts before the device reboots, then this state may be reached.\n    // Nothing should be done here.\n    LOG(WARNING) << \"InitiateMerge leaves the device at \"\n                 << \"UpdateState::Unverified. (Did update_engine \"\n                 << \"restarted?)\";\n    processor_->ActionComplete(this, ErrorCode::kSuccess);\n    return;\n  }\n\n  // State does seems to be advanced.\n  // It is possibly racy. For example, on a userdebug build, the user may\n  // manually initiate a merge with snapshotctl between last time\n  // update_engine checks UpdateState. Hence, just call\n  // WaitForMergeOrSchedule one more time.\n  LOG(WARNING) << \"IniitateMerge failed but GetUpdateState returned \"\n               << android::snapshot::UpdateState_Name(state)\n               << \", try to wait for merge again.\";\n  WaitForMergeOrSchedule();\n  return;\n}\n\nvoid CleanupPreviousUpdateAction::ReportMergeStats() {\n  auto result = merge_stats_->Finish();\n  if (result == nullptr) {\n    LOG(WARNING) << \"Not reporting merge stats because \"\n                    \"SnapshotMergeStats::Finish failed.\";\n    return;\n  }\n\n#ifdef __ANDROID_RECOVERY__\n  LOG(INFO) << \"Skip reporting merge stats in recovery.\";\n#else\n  const auto& report = result->report();\n\n  if (report.state() == UpdateState::None ||\n      report.state() == UpdateState::Initiated ||\n      report.state() == UpdateState::Unverified) {\n    LOG(INFO) << \"Not reporting merge stats because state is \"\n              << android::snapshot::UpdateState_Name(report.state());\n    return;\n  }\n\n  auto passed_ms = std::chrono::duration_cast<std::chrono::milliseconds>(\n      result->merge_time());\n  LOG(INFO) << \"Reporting merge stats: \"\n            << android::snapshot::UpdateState_Name(report.state()) << \" in \"\n            << passed_ms.count() << \"ms (resumed \" << report.resume_count()\n            << \" times)\";\n  android::util::stats_write(android::util::SNAPSHOT_MERGE_REPORTED,\n                             static_cast<int32_t>(report.state()),\n                             static_cast<int64_t>(passed_ms.count()),\n                             static_cast<int32_t>(report.resume_count()));\n#endif\n}\n\n}  // namespace chromeos_update_engine",
        "lookback": "// Copyright (C) 2020 The Android Open Source Project",
        "lookahead": "",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 0,
        "end_line": 649,
        "merge_gen_region": " CopyrightC 2020 Android Source// // () The Open Project // Licensed the License Version. (theLicense // you not this except in with the. You obtain copy the License // // httpwwwapacheorglicensesLICENSE20 // Unless by law agreed in,, // under License distributed anAS\" BASIS // WITHOUT OR OF KIND either or.. See License for specific governing and limitations the License //includeupdateenginecleanuppreviousupdateactionh # <> NOLINTbuildc11 -- for timesincludefunctional # <>includestring # <-/.>h # </bindh # _____includestats.>endifincludeupdateenginecommonutilsh # \"__/_consumerdeltaperform.\" androidsnapshotSnapshot; androidsnapshotSnapshotMerge; androidsnapshotUpdate; bl::;; charBootCompleted[] =sysbootcompleted // to sysbootcompleted constexpr kBootInterval baseTimeDeltaFrom(); Interval checkoot::SlotedSuccess constexpr kSlotedSuccessInterval baseTimeDeltaFrom(); Interval callapshot:: shouldState autoWaitForInterval baseTimeDeltaFrom(); chromeosupdateengine CleanupUpdate::PreviousAction PInterface prefs BootInterface bootcontrol androidsnapshotSnapshot*,PreviousUpdateDelegate*) :_(),__(_),_(),_(),_(),_(),",
        "confidence": 0.9036878347396851,
        "hesitated": false,
        "resolved": false
    }
]