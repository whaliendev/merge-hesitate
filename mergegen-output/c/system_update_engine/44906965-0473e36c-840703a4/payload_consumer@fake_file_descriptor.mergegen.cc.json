[
    {
        "a_contents": "//\n// Copyright (C) 2017 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n#include \"update_engine/payload_consumer/fake_file_descriptor.h\"\n\nnamespace chromeos_update_engine {\n\nssize_t FakeFileDescriptor::Read(void* buf, size_t count) {\n  // Record the read operation so it can later be inspected.\n  read_ops_.emplace_back(offset_, count);\n\n  // Check for the EOF condition first to avoid reporting it as a failure.\n  if (offset_ >= static_cast<uint64_t>(size_) || !count)\n    return 0;\n  // Find the first offset greater or equal than the current position where a\n  // failure will occur. This will mark the end of the read chunk.\n  uint64_t first_failure = size_;\n  for (const auto& failure : failure_ranges_) {\n    // A failure range that includes the current offset results in an\n    // immediate failure to read any bytes.\n    if (failure.first <= offset_ && offset_ < failure.first + failure.second) {\n      errno = EIO;\n      return -1;\n    }\n    if (failure.first > offset_)\n      first_failure = std::min(first_failure, failure.first);\n  }\n  count = std::min(static_cast<uint64_t>(count), first_failure - offset_);\n  static const char kHexChars[] = \"0123456789ABCDEF\";\n  for (size_t i = 0; i < count; ++i) {\n    // Encode the 16-bit number \"offset_ / 4\" as a hex digit in big-endian.\n    uint16_t current_num = offset_ / 4;\n    uint8_t current_digit = (current_num >> (4 * (3 - offset_ % 4))) & 0x0f;\n\n    static_cast<uint8_t*>(buf)[i] = kHexChars[current_digit];\n    offset_++;\n  }\n\n  return count;\n}\n\noff64_t FakeFileDescriptor::Seek(off64_t offset, int whence) {\n  switch (whence) {\n    case SEEK_SET:\n      offset_ = offset;\n      break;\n    case SEEK_CUR:\n      offset_ += offset;\n      break;\n    case SEEK_END:\n      if (offset > size_)\n        offset_ = 0;\n      else\n        offset_ = size_ - offset_;\n      break;\n    default:\n      errno = EINVAL;\n      return -1;\n  }\n  return offset_;\n}\n\n}  // namespace chromeos_update_engine",
        "b_contents": "//\n// Copyright (C) 2017 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n#include \"update_engine/payload_consumer/fake_file_descriptor.h\"\n\nnamespace chromeos_update_engine {\n\nssize_t FakeFileDescriptor::Read(void* buf, size_t count) {\n  // Record the read operation so it can later be inspected.\n  read_ops_.emplace_back(offset_, count);\n\n  // Check for the EOF condition first to avoid reporting it as a failure.\n  if (offset_ >= static_cast<uint64_t>(size_) || count == 0)\n    return 0;\n  // Find the first offset greater or equal than the current position where a\n  // failure will occur. This will mark the end of the read chunk.\n  uint64_t first_failure = size_;\n  for (const auto& failure : failure_ranges_) {\n    // A failure range that includes the current offset results in an\n    // immediate failure to read any bytes.\n    if (failure.first <= offset_ && offset_ < failure.first + failure.second) {\n      errno = EIO;\n      return -1;\n    }\n    if (failure.first > offset_)\n      first_failure = std::min(first_failure, failure.first);\n  }\n  count = std::min(static_cast<uint64_t>(count), first_failure - offset_);\n  static const char kHexChars[] = \"0123456789ABCDEF\";\n  for (size_t i = 0; i < count; ++i) {\n    // Encode the 16-bit number \"offset_ / 4\" as a hex digit in big-endian.\n    uint16_t current_num = offset_ / 4;\n    uint8_t current_digit = (current_num >> (4 * (3 - offset_ % 4))) & 0x0f;\n\n    static_cast<uint8_t*>(buf)[i] = kHexChars[current_digit];\n    offset_++;\n  }\n\n  return count;\n}\n\noff64_t FakeFileDescriptor::Seek(off64_t offset, int whence) {\n  switch (whence) {\n    case SEEK_SET:\n      offset_ = offset;\n      break;\n    case SEEK_CUR:\n      offset_ += offset;\n      break;\n    case SEEK_END:\n      if (offset > size_)\n        offset_ = 0;\n      else\n        offset_ = size_ - offset_;\n      break;\n    default:\n      errno = EINVAL;\n      return -1;\n  }\n  return offset_;\n}\n\n}  // namespace chromeos_update_engine",
        "base_contents": "",
        "res_region": "//\n// Copyright (C) 2017 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n#include \"update_engine/payload_consumer/fake_file_descriptor.h\"\n\nnamespace chromeos_update_engine {\n\nssize_t FakeFileDescriptor::Read(void* buf, size_t count) {\n  // Record the read operation so it can later be inspected.\n  read_ops_.emplace_back(offset_, count);\n\n  // Check for the EOF condition first to avoid reporting it as a failure.\n  if (offset_ >= static_cast<uint64_t>(size_) || count == 0)\n    return 0;\n  // Find the first offset greater or equal than the current position where a\n  // failure will occur. This will mark the end of the read chunk.\n  uint64_t first_failure = size_;\n  for (const auto& failure : failure_ranges_) {\n    // A failure range that includes the current offset results in an\n    // immediate failure to read any bytes.\n    if (failure.first <= offset_ && offset_ < failure.first + failure.second) {\n      errno = EIO;\n      return -1;\n    }\n    if (failure.first > offset_)\n      first_failure = std::min(first_failure, failure.first);\n  }\n  count = std::min(static_cast<uint64_t>(count), first_failure - offset_);\n  static const char kHexChars[] = \"0123456789ABCDEF\";\n  for (size_t i = 0; i < count; ++i) {\n    // Encode the 16-bit number \"offset_ / 4\" as a hex digit in big-endian.\n    uint16_t current_num = offset_ / 4;\n    uint8_t current_digit = (current_num >> (4 * (3 - offset_ % 4))) & 0x0f;\n\n    static_cast<uint8_t*>(buf)[i] = kHexChars[current_digit];\n    offset_++;\n  }\n\n  return count;\n}\n\noff64_t FakeFileDescriptor::Seek(off64_t offset, int whence) {\n  switch (whence) {\n    case SEEK_SET:\n      offset_ = offset;\n      break;\n    case SEEK_CUR:\n      offset_ += offset;\n      break;\n    case SEEK_END:\n      if (offset > size_)\n        offset_ = 0;\n      else\n        offset_ = size_ - offset_;\n      break;\n    default:\n      errno = EINVAL;\n      return -1;\n  }\n  return offset_;\n}\n\n}  // namespace chromeos_update_engine",
        "lookback": "// Copyright (C) 2017 The Android Open Source Project",
        "lookahead": "",
        "label": [
            "base",
            "one_side_deletion"
        ],
        "start_line": 0,
        "end_line": 155,
        "merge_gen_region": null,
        "confidence": 0.8436001539230347,
        "hesitated": true
    }
]