[
    {
        "a_contents": "//\n// Copyright (C) 2017 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n#ifndef UPDATE_ENGINE_PAYLOAD_CONSUMER_FAKE_FILE_DESCRIPTOR_H_\n#define UPDATE_ENGINE_PAYLOAD_CONSUMER_FAKE_FILE_DESCRIPTOR_H_\n\n#include <algorithm>\n#include <limits>\n#include <utility>\n#include <vector>\n\n#include \"update_engine/payload_consumer/file_descriptor.h\"\n\nnamespace chromeos_update_engine {\n\n// A fake file descriptor with configurable errors. The file descriptor always\n// reads a fixed sequence of bytes, consisting on the concatenation of the\n// numbers 0, 1, 2... each one encoded in 4 bytes as the big-endian 16-bit\n// number encoded in hexadecimal. For example, the beginning of the stream in\n// ASCII is 0000000100020003... which corresponds to the numbers 0, 1, 2 and 3.\nclass FakeFileDescriptor : public FileDescriptor {\n public:\n  FakeFileDescriptor() = default;\n  ~FakeFileDescriptor() = default;\n\n  // FileDescriptor override methods.\n  bool Open(const char* path, int flags, mode_t mode) override {\n    if (open_)\n      return false;\n    open_ = true;\n    return true;\n  }\n\n  bool Open(const char* path, int flags) override {\n    return Open(path, flags, 0);\n  }\n\n  ssize_t Read(void* buf, size_t count) override;\n\n  ssize_t Write(const void* buf, size_t count) override {\n    // Read-only block device.\n    errno = EROFS;\n    return -1;\n  }\n\n  off64_t Seek(off64_t offset, int whence) override;\n\n  uint64_t BlockDevSize() override { return size_; }\n\n  bool BlkIoctl(int request,\n                uint64_t start,\n                uint64_t length,\n                int* result) override {\n    return false;\n  }\n\n  bool Close() override {\n    if (!open_)\n      return false;\n    open_ = false;\n    return true;\n  }\n\n  bool IsSettingErrno() override { return true; }\n\n  bool IsOpen() override { return open_; }\n\n  // Fake class configuration methods.\n\n  // Set the size of the file.\n  void SetFileSize(uint64_t size) { size_ = size; }\n\n  // Marks the range starting from |offset| bytes into the file and |length|\n  // size as a failure range. Reads from this range will always fail.\n  void AddFailureRange(uint64_t offset, uint64_t length) {\n    if (!length)\n      return;\n    failure_ranges_.emplace_back(offset, length);\n  }\n\n  // Return the list of ranges of bytes requested with a Read() as (offset,\n  // length), regardless of the Read() return value.\n  std::vector<std::pair<uint64_t, uint64_t>> GetReadOps() const {\n    return read_ops_;\n  }\n\n private:\n  // Whether the fake file is open.\n  bool open_{false};\n\n  // The current file pointer offset into the fake file.\n  uint64_t offset_{0};\n\n  // The size of the file. Reads beyond |max_size_| will an EOF condition.\n  off64_t size_{std::numeric_limits<off64_t>::max()};\n\n  // The list of ranges represented as (start, length) in bytes where reads will\n  // always fail.\n  std::vector<std::pair<uint64_t, uint64_t>> failure_ranges_;\n\n  // List of reads performed as (offset, length) of the read request.\n  std::vector<std::pair<uint64_t, uint64_t>> read_ops_;\n\n  DISALLOW_COPY_AND_ASSIGN(FakeFileDescriptor);\n};\n\n}  // namespace chromeos_update_engine\n\n#endif  // UPDATE_ENGINE_PAYLOAD_CONSUMER_FAKE_FILE_DESCRIPTOR_H_",
        "b_contents": "//\n// Copyright (C) 2017 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n#ifndef UPDATE_ENGINE_PAYLOAD_CONSUMER_FAKE_FILE_DESCRIPTOR_H_\n#define UPDATE_ENGINE_PAYLOAD_CONSUMER_FAKE_FILE_DESCRIPTOR_H_\n\n#include <algorithm>\n#include <limits>\n#include <utility>\n#include <vector>\n\n#include \"update_engine/payload_consumer/file_descriptor.h\"\n\nnamespace chromeos_update_engine {\n\n// A fake file descriptor with configurable errors. The file descriptor always\n// reads a fixed sequence of bytes, consisting of the concatenation of the\n// numbers 0, 1, 2... each one encoded in 4 bytes as the big-endian 16-bit\n// number encoded in hexadecimal. For example, the beginning of the stream in\n// ASCII is 0000000100020003... which corresponds to the numbers 0, 1, 2 and 3.\nclass FakeFileDescriptor : public FileDescriptor {\n public:\n  FakeFileDescriptor() = default;\n  ~FakeFileDescriptor() override = default;\n\n  // FileDescriptor override methods.\n  bool Open(const char* path, int flags, mode_t mode) override {\n    if (open_)\n      return false;\n    open_ = true;\n    return true;\n  }\n\n  bool Open(const char* path, int flags) override {\n    return Open(path, flags, 0);\n  }\n\n  ssize_t Read(void* buf, size_t count) override;\n\n  ssize_t Write(const void* buf, size_t count) override {\n    // Read-only block device.\n    errno = EROFS;\n    return -1;\n  }\n\n  off64_t Seek(off64_t offset, int whence) override;\n\n  uint64_t BlockDevSize() override { return size_; }\n\n  bool BlkIoctl(int request,\n                uint64_t start,\n                uint64_t length,\n                int* result) override {\n    return false;\n  }\n\n  bool Flush() override {\n    return open_;\n  }\n\n  bool Close() override {\n    if (!open_)\n      return false;\n    open_ = false;\n    return true;\n  }\n\n  bool IsSettingErrno() override { return true; }\n\n  bool IsOpen() override { return open_; }\n\n  // Fake class configuration methods.\n\n  // Set the size of the file.\n  void SetFileSize(uint64_t size) { size_ = size; }\n\n  // Marks the range starting from |offset| bytes into the file and |length|\n  // size as a failure range. Reads from this range will always fail.\n  void AddFailureRange(uint64_t offset, uint64_t length) {\n    if (length == 0)\n      return;\n    failure_ranges_.emplace_back(offset, length);\n  }\n\n  // Return the list of ranges of bytes requested with a Read() as (offset,\n  // length), regardless of the Read() return value.\n  std::vector<std::pair<uint64_t, uint64_t>> GetReadOps() const {\n    return read_ops_;\n  }\n\n private:\n  // Whether the fake file is open.\n  bool open_{false};\n\n  // The current file pointer offset into the fake file.\n  uint64_t offset_{0};\n\n  // The size of the file. Reads beyond |max_size_| will an EOF condition.\n  off64_t size_{std::numeric_limits<off64_t>::max()};\n\n  // The list of ranges represented as (start, length) in bytes where reads will\n  // always fail.\n  std::vector<std::pair<uint64_t, uint64_t>> failure_ranges_;\n\n  // List of reads performed as (offset, length) of the read request.\n  std::vector<std::pair<uint64_t, uint64_t>> read_ops_;\n\n  DISALLOW_COPY_AND_ASSIGN(FakeFileDescriptor);\n};\n\n}  // namespace chromeos_update_engine\n\n#endif  // UPDATE_ENGINE_PAYLOAD_CONSUMER_FAKE_FILE_DESCRIPTOR_H_",
        "base_contents": "",
        "res_region": "//\n// Copyright (C) 2017 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n#ifndef UPDATE_ENGINE_PAYLOAD_CONSUMER_FAKE_FILE_DESCRIPTOR_H_\n#define UPDATE_ENGINE_PAYLOAD_CONSUMER_FAKE_FILE_DESCRIPTOR_H_\n\n#include <algorithm>\n#include <limits>\n#include <utility>\n#include <vector>\n\n#include \"update_engine/payload_consumer/file_descriptor.h\"\n\nnamespace chromeos_update_engine {\n\n// A fake file descriptor with configurable errors. The file descriptor always\n// reads a fixed sequence of bytes, consisting of the concatenation of the\n// numbers 0, 1, 2... each one encoded in 4 bytes as the big-endian 16-bit\n// number encoded in hexadecimal. For example, the beginning of the stream in\n// ASCII is 0000000100020003... which corresponds to the numbers 0, 1, 2 and 3.\nclass FakeFileDescriptor : public FileDescriptor {\n public:\n  FakeFileDescriptor() = default;\n  ~FakeFileDescriptor() override = default;\n\n  // FileDescriptor override methods.\n  bool Open(const char* path, int flags, mode_t mode) override {\n    if (open_)\n      return false;\n    open_ = true;\n    return true;\n  }\n\n  bool Open(const char* path, int flags) override {\n    return Open(path, flags, 0);\n  }\n\n  ssize_t Read(void* buf, size_t count) override;\n\n  ssize_t Write(const void* buf, size_t count) override {\n    // Read-only block device.\n    errno = EROFS;\n    return -1;\n  }\n\n  off64_t Seek(off64_t offset, int whence) override;\n\n  uint64_t BlockDevSize() override { return size_; }\n\n  bool BlkIoctl(int request,\n                uint64_t start,\n                uint64_t length,\n                int* result) override {\n    return false;\n  }\n\n  bool Flush() override {\n    return open_;\n  }\n\n  bool Close() override {\n    if (!open_)\n      return false;\n    open_ = false;\n    return true;\n  }\n\n  bool IsSettingErrno() override { return true; }\n\n  bool IsOpen() override { return open_; }\n\n  // Fake class configuration methods.\n\n  // Set the size of the file.\n  void SetFileSize(uint64_t size) { size_ = size; }\n\n  // Marks the range starting from |offset| bytes into the file and |length|\n  // size as a failure range. Reads from this range will always fail.\n  void AddFailureRange(uint64_t offset, uint64_t length) {\n    if (length == 0)\n      return;\n    failure_ranges_.emplace_back(offset, length);\n  }\n\n  // Return the list of ranges of bytes requested with a Read() as (offset,\n  // length), regardless of the Read() return value.\n  std::vector<std::pair<uint64_t, uint64_t>> GetReadOps() const {\n    return read_ops_;\n  }\n\n private:\n  // Whether the fake file is open.\n  bool open_{false};\n\n  // The current file pointer offset into the fake file.\n  uint64_t offset_{0};\n\n  // The size of the file. Reads beyond |max_size_| will an EOF condition.\n  off64_t size_{std::numeric_limits<off64_t>::max()};\n\n  // The list of ranges represented as (start, length) in bytes where reads will\n  // always fail.\n  std::vector<std::pair<uint64_t, uint64_t>> failure_ranges_;\n\n  // List of reads performed as (offset, length) of the read request.\n  std::vector<std::pair<uint64_t, uint64_t>> read_ops_;\n\n  DISALLOW_COPY_AND_ASSIGN(FakeFileDescriptor);\n};\n\n}  // namespace chromeos_update_engine\n\n#endif  // UPDATE_ENGINE_PAYLOAD_CONSUMER_FAKE_FILE_DESCRIPTOR_H_",
        "lookback": "// Copyright (C) 2017 The Android Open Source Project",
        "lookahead": "",
        "label": [
            "base",
            "one_side_deletion"
        ],
        "start_line": 0,
        "end_line": 251,
        "merge_gen_region": " CopyrightC 2017 Android Source// // () The Open Project // Licensed the License Version. (theLicense // may use file in with License // may a of License // // httpwwwapacheorglicensesLICENSE20 // Unless by law agreed in,, // under License distributed anAS\" BASIS // WARRANTIES CONDITIONS ANY, express implied // the See License the for specific governing and limitations the. # UPDATEENGINEPAYLOADCONERFAKEFILEDESCRIPTORH # UPDATEENGINEPAYLOADCONERFAKEFILEDESCRIPTORH # <algorithm # <>includelimits # <>includeutility # <>include <>includeupdateenginepayloadconsumerfiledescriptorh namespace__engine // fake descriptor config errors The descriptor // reads fixed sequence bytes consist on concaten of // numbers,,,,,... one encoded 4 as bigendian- // number in hedecimal For, beginning the stream // is00000002... which to numbers,,,,, and. classFileDescriptor publicDescriptor public:FileDescriptor =;FakeDescriptor =; FileDescriptor methods bool( char path int,__ char path int,__ modet) { (_) false open =; true return; bool( char path int) { Open return(,,,,); ssizet(*,__ count override ssize",
        "confidence": 0.8859304785728455,
        "hesitated": false,
        "resolved": false
    }
]