[
    {
        "a_contents": "//\n// Copyright (C) 2017 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n#include \"update_engine/payload_consumer/file_descriptor_utils.h\"\n\n#include <string>\n#include <utility>\n#include <vector>\n\n#include <gtest/gtest.h>\n\n#include <brillo/data_encoding.h>\n\n#include \"update_engine/common/hash_calculator.h\"\n#include \"update_engine/common/test_utils.h\"\n#include \"update_engine/common/utils.h\"\n#include \"update_engine/payload_consumer/fake_file_descriptor.h\"\n#include \"update_engine/payload_consumer/file_descriptor.h\"\n#include \"update_engine/payload_generator/extent_ranges.h\"\n\nnamespace chromeos_update_engine {\n\nnamespace {\n\n::google::protobuf::RepeatedPtrField<Extent> CreateExtentList(\n    const std::vector<std::pair<uint64_t, uint64_t>>& lst) {\n  ::google::protobuf::RepeatedPtrField<Extent> result;\n  for (const auto& item : lst) {\n    *result.Add() = ExtentForRange(item.first, item.second);\n  }\n  return result;\n}\n\n}  // namespace\n\nclass FileDescriptorUtilsTest : public ::testing::Test {\n protected:\n  void SetUp() override {\n    EXPECT_TRUE(utils::MakeTempFile(\"fd_tgt.XXXXXX\", &tgt_path_, nullptr));\n    EXPECT_TRUE(target_->Open(tgt_path_.c_str(), O_RDWR));\n  }\n\n  // Check that the |target_| file contains |expected_contents|.\n  void ExpectTarget(const std::string& expected_contents) {\n    std::string target_contents;\n    EXPECT_TRUE(utils::ReadFile(tgt_path_, &target_contents));\n    EXPECT_EQ(expected_contents.size(), target_contents.size());\n    if (target_contents != expected_contents) {\n      ADD_FAILURE() << \"Contents don't match.\";\n      LOG(INFO) << \"Expected contents:\";\n      utils::HexDumpString(expected_contents);\n      LOG(INFO) << \"Actual contents:\";\n      utils::HexDumpString(target_contents);\n    }\n  }\n\n  // Path to the target temporary file.\n  std::string tgt_path_;\n\n  // Source and target file descriptor used for testing the tools.\n  FakeFileDescriptor* fake_source_{new FakeFileDescriptor()};\n  FileDescriptorPtr source_{fake_source_};\n  FileDescriptorPtr target_{new EintrSafeFileDescriptor()};\n};\n\n// Source and target extents should have the same number of blocks.\nTEST_F(FileDescriptorUtilsTest, CopyAndHashExtentsMismatchBlocksTest) {\n  auto src_extents = CreateExtentList({{1, 4}});\n  auto tgt_extents = CreateExtentList({{0, 5}});\n\n  EXPECT_FALSE(fd_utils::CopyAndHashExtents(\n      source_, src_extents, target_, tgt_extents, 4, nullptr));\n}\n\n// Failing to read from the source should fail the copy.\nTEST_F(FileDescriptorUtilsTest, CopyAndHashExtentsReadFailureTest) {\n  auto extents = CreateExtentList({{0, 5}});\n  fake_source_->AddFailureRange(10, 5);\n\n  EXPECT_FALSE(fd_utils::CopyAndHashExtents(\n      source_, extents, target_, extents, 4, nullptr));\n}\n\n// Failing to write to the target should fail the copy.\nTEST_F(FileDescriptorUtilsTest, CopyAndHashExtentsWriteFailureTest) {\n  auto src_extents = CreateExtentList({{0, 2}});\n  auto tgt_extents = CreateExtentList({{5, 2}});\n  fake_source_->AddFailureRange(5 * 4, 10);\n\n  // Note that we pass |source_| as the target as well, which should fail to\n  // write.\n  EXPECT_FALSE(fd_utils::CopyAndHashExtents(\n      source_, src_extents, source_, tgt_extents, 4, nullptr));\n}\n\n// Test that we can copy extents without hashing them, allowing a nullptr\n// pointer as hash_out.\nTEST_F(FileDescriptorUtilsTest, CopyAndHashExtentsWithoutHashingTest) {\n  auto extents = CreateExtentList({{0, 5}});\n\n  EXPECT_TRUE(fd_utils::CopyAndHashExtents(\n      source_, extents, target_, extents, 4, nullptr));\n  ExpectTarget(\"00000001000200030004\");\n}\n\n// CopyAndHash() can take different number of extents in the source and target\n// files, as long as the number of blocks is the same. Test that it handles it\n// properly.\nTEST_F(FileDescriptorUtilsTest, CopyAndHashExtentsManyToOneTest) {\n  brillo::Blob hash_out;\n  // Reorder the input as 1 4 2 3 0.\n  auto src_extents = CreateExtentList({{1, 1}, {4, 1}, {2, 2}, {0, 1}});\n  auto tgt_extents = CreateExtentList({{0, 5}});\n\n  EXPECT_TRUE(fd_utils::CopyAndHashExtents(\n      source_, src_extents, target_, tgt_extents, 4, &hash_out));\n  const char kExpectedResult[] = \"00010004000200030000\";\n  ExpectTarget(kExpectedResult);\n\n  brillo::Blob expected_hash;\n  EXPECT_TRUE(HashCalculator::RawHashOfBytes(\n      kExpectedResult, strlen(kExpectedResult), &expected_hash));\n  EXPECT_EQ(expected_hash, hash_out);\n}\n\nTEST_F(FileDescriptorUtilsTest, CopyAndHashExtentsManyToManyTest) {\n  brillo::Blob hash_out;\n  auto src_extents = CreateExtentList({{1, 1}, {4, 1}, {2, 2}, {0, 1}});\n  auto tgt_extents = CreateExtentList({{2, 3}, {0, 2}});\n\n  EXPECT_TRUE(fd_utils::CopyAndHashExtents(\n      source_, src_extents, target_, tgt_extents, 4, &hash_out));\n  // The reads always match the source extent list of blocks (up to the\n  // internal buffer size).\n  std::vector<std::pair<uint64_t, uint64_t>> kExpectedOps = {\n      {4, 4}, {16, 4}, {8, 8}, {0, 4}};\n  EXPECT_EQ(kExpectedOps, fake_source_->GetReadOps());\n\n  // The output here is as in the previous test but the first 3 4-byte blocks\n  // are at the end of the stream. The expected hash is as in the previous\n  // example anyway since the hash doesn't depend on the order of the target\n  // blocks.\n  const char kExpectedResult[] = \"00030000000100040002\";\n  ExpectTarget(kExpectedResult);\n\n  // The data in the order that the reader processes (and hashes) it.\n  const char kExpectedOrderedData[] = \"00010004000200030000\";\n  brillo::Blob expected_hash;\n  EXPECT_TRUE(HashCalculator::RawHashOfBytes(\n      kExpectedOrderedData, strlen(kExpectedOrderedData), &expected_hash));\n  EXPECT_EQ(expected_hash, hash_out);\n}\n\n}  // namespace chromeos_update_engine",
        "b_contents": "//\n// Copyright (C) 2017 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n#include \"update_engine/payload_consumer/file_descriptor_utils.h\"\n\n#include <fcntl.h>\n\n#include <string>\n#include <utility>\n#include <vector>\n\n#include <brillo/data_encoding.h>\n#include <gtest/gtest.h>\n\n#include \"update_engine/common/hash_calculator.h\"\n#include \"update_engine/common/test_utils.h\"\n#include \"update_engine/common/utils.h\"\n#include \"update_engine/payload_consumer/fake_file_descriptor.h\"\n#include \"update_engine/payload_consumer/file_descriptor.h\"\n#include \"update_engine/payload_generator/extent_ranges.h\"\n\nusing google::protobuf::RepeatedPtrField;\n\nnamespace chromeos_update_engine {\n\nnamespace {\n\nRepeatedPtrField<Extent> CreateExtentList(\n    const std::vector<std::pair<uint64_t, uint64_t>>& lst) {\n  RepeatedPtrField<Extent> result;\n  for (const auto& item : lst) {\n    *result.Add() = ExtentForRange(item.first, item.second);\n  }\n  return result;\n}\n\n}  // namespace\n\nclass FileDescriptorUtilsTest : public ::testing::Test {\n protected:\n  void SetUp() override {\n    EXPECT_TRUE(utils::MakeTempFile(\"fd_tgt.XXXXXX\", &tgt_path_, nullptr));\n    EXPECT_TRUE(target_->Open(tgt_path_.c_str(), O_RDWR));\n  }\n\n  // Check that the |target_| file contains |expected_contents|.\n  void ExpectTarget(const std::string& expected_contents) {\n    std::string target_contents;\n    EXPECT_TRUE(utils::ReadFile(tgt_path_, &target_contents));\n    EXPECT_EQ(expected_contents.size(), target_contents.size());\n    if (target_contents != expected_contents) {\n      ADD_FAILURE() << \"Contents don't match.\";\n      LOG(INFO) << \"Expected contents:\";\n      utils::HexDumpString(expected_contents);\n      LOG(INFO) << \"Actual contents:\";\n      utils::HexDumpString(target_contents);\n    }\n  }\n\n  // Path to the target temporary file.\n  std::string tgt_path_;\n\n  // Source and target file descriptor used for testing the tools.\n  FakeFileDescriptor* fake_source_{new FakeFileDescriptor()};\n  FileDescriptorPtr source_{fake_source_};\n  FileDescriptorPtr target_{new EintrSafeFileDescriptor()};\n};\n\n// Source and target extents should have the same number of blocks.\nTEST_F(FileDescriptorUtilsTest, CopyAndHashExtentsMismatchBlocksTest) {\n  auto src_extents = CreateExtentList({{1, 4}});\n  auto tgt_extents = CreateExtentList({{0, 5}});\n\n  EXPECT_FALSE(fd_utils::CopyAndHashExtents(\n      source_, src_extents, target_, tgt_extents, 4, nullptr));\n}\n\n// Failing to read from the source should fail the copy.\nTEST_F(FileDescriptorUtilsTest, CopyAndHashExtentsReadFailureTest) {\n  auto extents = CreateExtentList({{0, 5}});\n  fake_source_->AddFailureRange(10, 5);\n\n  EXPECT_FALSE(fd_utils::CopyAndHashExtents(\n      source_, extents, target_, extents, 4, nullptr));\n}\n\n// Failing to write to the target should fail the copy.\nTEST_F(FileDescriptorUtilsTest, CopyAndHashExtentsWriteFailureTest) {\n  auto src_extents = CreateExtentList({{0, 2}});\n  auto tgt_extents = CreateExtentList({{5, 2}});\n  fake_source_->AddFailureRange(5 * 4, 10);\n\n  // Note that we pass |source_| as the target as well, which should fail to\n  // write.\n  EXPECT_FALSE(fd_utils::CopyAndHashExtents(\n      source_, src_extents, source_, tgt_extents, 4, nullptr));\n}\n\n// Test that we can copy extents without hashing them, allowing a nullptr\n// pointer as hash_out.\nTEST_F(FileDescriptorUtilsTest, CopyAndHashExtentsWithoutHashingTest) {\n  auto extents = CreateExtentList({{0, 5}});\n\n  EXPECT_TRUE(fd_utils::CopyAndHashExtents(\n      source_, extents, target_, extents, 4, nullptr));\n  ExpectTarget(\"00000001000200030004\");\n}\n\n// CopyAndHash() can take different number of extents in the source and target\n// files, as long as the number of blocks is the same. Test that it handles it\n// properly.\nTEST_F(FileDescriptorUtilsTest, CopyAndHashExtentsManyToOneTest) {\n  brillo::Blob hash_out;\n  // Reorder the input as 1 4 2 3 0.\n  auto src_extents = CreateExtentList({{1, 1}, {4, 1}, {2, 2}, {0, 1}});\n  auto tgt_extents = CreateExtentList({{0, 5}});\n\n  EXPECT_TRUE(fd_utils::CopyAndHashExtents(\n      source_, src_extents, target_, tgt_extents, 4, &hash_out));\n  const char kExpectedResult[] = \"00010004000200030000\";\n  ExpectTarget(kExpectedResult);\n\n  brillo::Blob expected_hash;\n  EXPECT_TRUE(HashCalculator::RawHashOfBytes(\n      kExpectedResult, strlen(kExpectedResult), &expected_hash));\n  EXPECT_EQ(expected_hash, hash_out);\n}\n\nTEST_F(FileDescriptorUtilsTest, CopyAndHashExtentsManyToManyTest) {\n  brillo::Blob hash_out;\n  auto src_extents = CreateExtentList({{1, 1}, {4, 1}, {2, 2}, {0, 1}});\n  auto tgt_extents = CreateExtentList({{2, 3}, {0, 2}});\n\n  EXPECT_TRUE(fd_utils::CopyAndHashExtents(\n      source_, src_extents, target_, tgt_extents, 4, &hash_out));\n  // The reads always match the source extent list of blocks (up to the\n  // internal buffer size).\n  std::vector<std::pair<uint64_t, uint64_t>> kExpectedOps = {\n      {4, 4}, {16, 4}, {8, 8}, {0, 4}};\n  EXPECT_EQ(kExpectedOps, fake_source_->GetReadOps());\n\n  // The output here is as in the previous test but the first 3 4-byte blocks\n  // are at the end of the stream. The expected hash is as in the previous\n  // example anyway since the hash doesn't depend on the order of the target\n  // blocks.\n  const char kExpectedResult[] = \"00030000000100040002\";\n  ExpectTarget(kExpectedResult);\n\n  // The data in the order that the reader processes (and hashes) it.\n  const char kExpectedOrderedData[] = \"00010004000200030000\";\n  brillo::Blob expected_hash;\n  EXPECT_TRUE(HashCalculator::RawHashOfBytes(\n      kExpectedOrderedData, strlen(kExpectedOrderedData), &expected_hash));\n  EXPECT_EQ(expected_hash, hash_out);\n}\n\n}  // namespace chromeos_update_engine",
        "base_contents": "",
        "res_region": "//\n// Copyright (C) 2017 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n#include \"update_engine/payload_consumer/file_descriptor_utils.h\"\n\n#include <fcntl.h>\n\n#include <string>\n#include <utility>\n#include <vector>\n\n#include <brillo/data_encoding.h>\n#include <gtest/gtest.h>\n\n#include \"update_engine/common/hash_calculator.h\"\n#include \"update_engine/common/test_utils.h\"\n#include \"update_engine/common/utils.h\"\n#include \"update_engine/payload_consumer/fake_file_descriptor.h\"\n#include \"update_engine/payload_consumer/file_descriptor.h\"\n#include \"update_engine/payload_generator/extent_ranges.h\"\n\nusing google::protobuf::RepeatedPtrField;\n\nnamespace chromeos_update_engine {\n\nnamespace {\n\nRepeatedPtrField<Extent> CreateExtentList(\n    const std::vector<std::pair<uint64_t, uint64_t>>& lst) {\n  RepeatedPtrField<Extent> result;\n  for (const auto& item : lst) {\n    *result.Add() = ExtentForRange(item.first, item.second);\n  }\n  return result;\n}\n\n}  // namespace\n\nclass FileDescriptorUtilsTest : public ::testing::Test {\n protected:\n  void SetUp() override {\n    EXPECT_TRUE(utils::MakeTempFile(\"fd_tgt.XXXXXX\", &tgt_path_, nullptr));\n    EXPECT_TRUE(target_->Open(tgt_path_.c_str(), O_RDWR));\n  }\n\n  // Check that the |target_| file contains |expected_contents|.\n  void ExpectTarget(const std::string& expected_contents) {\n    std::string target_contents;\n    EXPECT_TRUE(utils::ReadFile(tgt_path_, &target_contents));\n    EXPECT_EQ(expected_contents.size(), target_contents.size());\n    if (target_contents != expected_contents) {\n      ADD_FAILURE() << \"Contents don't match.\";\n      LOG(INFO) << \"Expected contents:\";\n      utils::HexDumpString(expected_contents);\n      LOG(INFO) << \"Actual contents:\";\n      utils::HexDumpString(target_contents);\n    }\n  }\n\n  // Path to the target temporary file.\n  std::string tgt_path_;\n\n  // Source and target file descriptor used for testing the tools.\n  FakeFileDescriptor* fake_source_{new FakeFileDescriptor()};\n  FileDescriptorPtr source_{fake_source_};\n  FileDescriptorPtr target_{new EintrSafeFileDescriptor()};\n};\n\n// Source and target extents should have the same number of blocks.\nTEST_F(FileDescriptorUtilsTest, CopyAndHashExtentsMismatchBlocksTest) {\n  auto src_extents = CreateExtentList({{1, 4}});\n  auto tgt_extents = CreateExtentList({{0, 5}});\n\n  EXPECT_FALSE(fd_utils::CopyAndHashExtents(\n      source_, src_extents, target_, tgt_extents, 4, nullptr));\n}\n\n// Failing to read from the source should fail the copy.\nTEST_F(FileDescriptorUtilsTest, CopyAndHashExtentsReadFailureTest) {\n  auto extents = CreateExtentList({{0, 5}});\n  fake_source_->AddFailureRange(10, 5);\n\n  EXPECT_FALSE(fd_utils::CopyAndHashExtents(\n      source_, extents, target_, extents, 4, nullptr));\n}\n\n// Failing to write to the target should fail the copy.\nTEST_F(FileDescriptorUtilsTest, CopyAndHashExtentsWriteFailureTest) {\n  auto src_extents = CreateExtentList({{0, 2}});\n  auto tgt_extents = CreateExtentList({{5, 2}});\n  fake_source_->AddFailureRange(5 * 4, 10);\n\n  // Note that we pass |source_| as the target as well, which should fail to\n  // write.\n  EXPECT_FALSE(fd_utils::CopyAndHashExtents(\n      source_, src_extents, source_, tgt_extents, 4, nullptr));\n}\n\n// Test that we can copy extents without hashing them, allowing a nullptr\n// pointer as hash_out.\nTEST_F(FileDescriptorUtilsTest, CopyAndHashExtentsWithoutHashingTest) {\n  auto extents = CreateExtentList({{0, 5}});\n\n  EXPECT_TRUE(fd_utils::CopyAndHashExtents(\n      source_, extents, target_, extents, 4, nullptr));\n  ExpectTarget(\"00000001000200030004\");\n}\n\n// CopyAndHash() can take different number of extents in the source and target\n// files, as long as the number of blocks is the same. Test that it handles it\n// properly.\nTEST_F(FileDescriptorUtilsTest, CopyAndHashExtentsManyToOneTest) {\n  brillo::Blob hash_out;\n  // Reorder the input as 1 4 2 3 0.\n  auto src_extents = CreateExtentList({{1, 1}, {4, 1}, {2, 2}, {0, 1}});\n  auto tgt_extents = CreateExtentList({{0, 5}});\n\n  EXPECT_TRUE(fd_utils::CopyAndHashExtents(\n      source_, src_extents, target_, tgt_extents, 4, &hash_out));\n  const char kExpectedResult[] = \"00010004000200030000\";\n  ExpectTarget(kExpectedResult);\n\n  brillo::Blob expected_hash;\n  EXPECT_TRUE(HashCalculator::RawHashOfBytes(\n      kExpectedResult, strlen(kExpectedResult), &expected_hash));\n  EXPECT_EQ(expected_hash, hash_out);\n}\n\nTEST_F(FileDescriptorUtilsTest, CopyAndHashExtentsManyToManyTest) {\n  brillo::Blob hash_out;\n  auto src_extents = CreateExtentList({{1, 1}, {4, 1}, {2, 2}, {0, 1}});\n  auto tgt_extents = CreateExtentList({{2, 3}, {0, 2}});\n\n  EXPECT_TRUE(fd_utils::CopyAndHashExtents(\n      source_, src_extents, target_, tgt_extents, 4, &hash_out));\n  // The reads always match the source extent list of blocks (up to the\n  // internal buffer size).\n  std::vector<std::pair<uint64_t, uint64_t>> kExpectedOps = {\n      {4, 4}, {16, 4}, {8, 8}, {0, 4}};\n  EXPECT_EQ(kExpectedOps, fake_source_->GetReadOps());\n\n  // The output here is as in the previous test but the first 3 4-byte blocks\n  // are at the end of the stream. The expected hash is as in the previous\n  // example anyway since the hash doesn't depend on the order of the target\n  // blocks.\n  const char kExpectedResult[] = \"00030000000100040002\";\n  ExpectTarget(kExpectedResult);\n\n  // The data in the order that the reader processes (and hashes) it.\n  const char kExpectedOrderedData[] = \"00010004000200030000\";\n  brillo::Blob expected_hash;\n  EXPECT_TRUE(HashCalculator::RawHashOfBytes(\n      kExpectedOrderedData, strlen(kExpectedOrderedData), &expected_hash));\n  EXPECT_EQ(expected_hash, hash_out);\n}\n\n}  // namespace chromeos_update_engine",
        "lookback": "// Copyright (C) 2017 The Android Open Source Project",
        "lookahead": "",
        "label": [
            "base",
            "one_side_deletion"
        ],
        "start_line": 0,
        "end_line": 340,
        "merge_gen_region": " CopyrightC 2017 Android Source// // () The Open Android Source // Licensed the License Version. (theLicense // you not this except in with the. You obtain copy the License // // httpwwwapacheorglicensesLICENSE20 // Unless by law agreed in,, // under License distributed anAS\" BASIS // WARRANTIES CONDITIONS ANY, express implied // the See License the for specific governing and limitations the License //includeupdateenginepayloadconsumerfiledescriptorutilsh # <>includeutility # <> # <>includevector # <gtestgtestgtesth>includebrilodataencodingh # \"_/commonhashcalcul.\"includeupdateenginecommontestutilsh # \"_/commonutilsh # \"_/__/includeupdateenginepayloadconsumerfakefiledescriptorh # \"__/__/_.\"includeupdateenginepayloadconsumerfiledescriptorh # \"__/payloadgeneratorextentrangesh namespace__ { { {googleprotobufRepeatedFieldExtent CreateList const::<::<::<::<64t uint_> lst {googleprotobufRepeatedFieldExtent result forconst& :) *.() ExtFor(..,.); return; } // classDescriptorTest public :::::: {: SetUp override EXPECTTRUEutilsMake",
        "confidence": 0.9128596782684326,
        "hesitated": false,
        "resolved": false
    }
]