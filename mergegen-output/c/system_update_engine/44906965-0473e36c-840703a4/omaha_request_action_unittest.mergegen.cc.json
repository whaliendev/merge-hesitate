[
    {
        "a_contents": "",
        "b_contents": "TEST_F(OmahaRequestActionTest, ValidUpdateOverCellularAllowedByDevicePolicy) {\n  // This test tests that update over cellular is allowed as device policy\n  // says yes.\n  OmahaResponse response;\n  MockConnectionManager mock_cm;\n\n  fake_system_state_.set_connection_manager(&mock_cm);\n\n  EXPECT_CALL(mock_cm, GetConnectionProperties(_, _))\n      .WillRepeatedly(\n          DoAll(SetArgPointee<0>(ConnectionType::kCellular),\n                SetArgPointee<1>(ConnectionTethering::kUnknown),\n                Return(true)));\n  EXPECT_CALL(mock_cm, IsAllowedConnectionTypesForUpdateSet())\n      .WillRepeatedly(Return(true));\n  EXPECT_CALL(mock_cm, IsUpdateAllowedOver(ConnectionType::kCellular, _))\n      .WillRepeatedly(Return(true));\n\n  ASSERT_TRUE(\n      TestUpdateCheck(nullptr,  // request_params\n                      fake_update_response_.GetUpdateResponse(),\n                      -1,\n                      false,  // ping_only\n                      ErrorCode::kSuccess,\n                      metrics::CheckResult::kUpdateAvailable,\n                      metrics::CheckReaction::kUpdating,\n                      metrics::DownloadErrorCode::kUnset,\n                      &response,\n                      nullptr));\n  EXPECT_TRUE(response.update_exists);\n}\n\nTEST_F(OmahaRequestActionTest, ValidUpdateOverCellularBlockedByDevicePolicy) {\n  // This test tests that update over cellular is blocked as device policy\n  // says no.\n  OmahaResponse response;\n  MockConnectionManager mock_cm;\n\n  fake_system_state_.set_connection_manager(&mock_cm);\n\n  EXPECT_CALL(mock_cm, GetConnectionProperties(_, _))\n      .WillRepeatedly(\n          DoAll(SetArgPointee<0>(ConnectionType::kCellular),\n                SetArgPointee<1>(ConnectionTethering::kUnknown),\n                Return(true)));\n  EXPECT_CALL(mock_cm, IsAllowedConnectionTypesForUpdateSet())\n      .WillRepeatedly(Return(true));\n  EXPECT_CALL(mock_cm, IsUpdateAllowedOver(ConnectionType::kCellular, _))\n      .WillRepeatedly(Return(false));\n\n  ASSERT_FALSE(\n      TestUpdateCheck(nullptr,  // request_params\n                      fake_update_response_.GetUpdateResponse(),\n                      -1,\n                      false,  // ping_only\n                      ErrorCode::kOmahaUpdateIgnoredPerPolicy,\n                      metrics::CheckResult::kUpdateAvailable,\n                      metrics::CheckReaction::kIgnored,\n                      metrics::DownloadErrorCode::kUnset,\n                      &response,\n                      nullptr));\n  EXPECT_FALSE(response.update_exists);\n}\n\nTEST_F(OmahaRequestActionTest,\n       ValidUpdateOverCellularAllowedByUserPermissionTrue) {\n  // This test tests that, when device policy is not set, update over cellular\n  // is allowed as permission for update over cellular is set to true.\n  OmahaResponse response;\n  MockConnectionManager mock_cm;\n\n  fake_prefs_.SetBoolean(kPrefsUpdateOverCellularPermission, true);\n  fake_system_state_.set_connection_manager(&mock_cm);\n\n  EXPECT_CALL(mock_cm, GetConnectionProperties(_, _))\n      .WillRepeatedly(\n          DoAll(SetArgPointee<0>(ConnectionType::kCellular),\n                SetArgPointee<1>(ConnectionTethering::kUnknown),\n                Return(true)));\n  EXPECT_CALL(mock_cm, IsAllowedConnectionTypesForUpdateSet())\n      .WillRepeatedly(Return(false));\n  EXPECT_CALL(mock_cm, IsUpdateAllowedOver(ConnectionType::kCellular, _))\n      .WillRepeatedly(Return(true));\n\n  ASSERT_TRUE(\n      TestUpdateCheck(nullptr,  // request_params\n                      fake_update_response_.GetUpdateResponse(),\n                      -1,\n                      false,  // ping_only\n                      ErrorCode::kSuccess,\n                      metrics::CheckResult::kUpdateAvailable,\n                      metrics::CheckReaction::kUpdating,\n                      metrics::DownloadErrorCode::kUnset,\n                      &response,\n                      nullptr));\n  EXPECT_TRUE(response.update_exists);\n}\n\nTEST_F(OmahaRequestActionTest,\n       ValidUpdateOverCellularBlockedByUpdateTargetNotMatch) {\n  // This test tests that, when device policy is not set and permission for\n  // update over cellular is set to false or does not exist, update over\n  // cellular is blocked as update target does not match the omaha response.\n  OmahaResponse response;\n  MockConnectionManager mock_cm;\n  // A version different from the version in omaha response.\n  string diff_version = \"99.99.99\";\n  // A size different from the size in omaha response.\n  int64_t diff_size = 999;\n\n  fake_prefs_.SetString(kPrefsUpdateOverCellularTargetVersion, diff_version);\n  fake_prefs_.SetInt64(kPrefsUpdateOverCellularTargetSize, diff_size);\n  // This test tests cellular (3G) being the only connection type being allowed.\n  fake_system_state_.set_connection_manager(&mock_cm);\n\n  EXPECT_CALL(mock_cm, GetConnectionProperties(_, _))\n      .WillRepeatedly(\n          DoAll(SetArgPointee<0>(ConnectionType::kCellular),\n                SetArgPointee<1>(ConnectionTethering::kUnknown),\n                Return(true)));\n  EXPECT_CALL(mock_cm, IsAllowedConnectionTypesForUpdateSet())\n      .WillRepeatedly(Return(false));\n  EXPECT_CALL(mock_cm, IsUpdateAllowedOver(ConnectionType::kCellular, _))\n      .WillRepeatedly(Return(true));\n\n  ASSERT_FALSE(\n      TestUpdateCheck(nullptr,  // request_params\n                      fake_update_response_.GetUpdateResponse(),\n                      -1,\n                      false,  // ping_only\n                      ErrorCode::kOmahaUpdateIgnoredOverCellular,\n                      metrics::CheckResult::kUpdateAvailable,\n                      metrics::CheckReaction::kIgnored,\n                      metrics::DownloadErrorCode::kUnset,\n                      &response,\n                      nullptr));\n  EXPECT_FALSE(response.update_exists);\n}\n\nTEST_F(OmahaRequestActionTest,\n       ValidUpdateOverCellularAllowedByUpdateTargetMatch) {\n  // This test tests that, when device policy is not set and permission for\n  // update over cellular is set to false or does not exist, update over\n  // cellular is allowed as update target matches the omaha response.\n  OmahaResponse response;\n  MockConnectionManager mock_cm;\n  // A version same as the version in omaha response.\n  string new_version = fake_update_response_.version;\n  // A size same as the size in omaha response.\n  int64_t new_size = fake_update_response_.size;\n\n  fake_prefs_.SetString(kPrefsUpdateOverCellularTargetVersion, new_version);\n  fake_prefs_.SetInt64(kPrefsUpdateOverCellularTargetSize, new_size);\n  fake_system_state_.set_connection_manager(&mock_cm);\n\n  EXPECT_CALL(mock_cm, GetConnectionProperties(_, _))\n      .WillRepeatedly(\n          DoAll(SetArgPointee<0>(ConnectionType::kCellular),\n                SetArgPointee<1>(ConnectionTethering::kUnknown),\n                Return(true)));\n  EXPECT_CALL(mock_cm, IsAllowedConnectionTypesForUpdateSet())\n      .WillRepeatedly(Return(false));\n  EXPECT_CALL(mock_cm, IsUpdateAllowedOver(ConnectionType::kCellular, _))\n      .WillRepeatedly(Return(true));\n\n  ASSERT_TRUE(\n      TestUpdateCheck(nullptr,  // request_params\n                      fake_update_response_.GetUpdateResponse(),\n                      -1,\n                      false,  // ping_only\n                      ErrorCode::kSuccess,\n                      metrics::CheckResult::kUpdateAvailable,\n                      metrics::CheckReaction::kUpdating,\n                      metrics::DownloadErrorCode::kUnset,\n                      &response,\n                      nullptr));\n  EXPECT_TRUE(response.update_exists);\n}\n",
        "base_contents": "TEST_F(OmahaRequestActionTest, ValidUpdateOverCellularAllowedByDevicePolicy) {\n  // This test tests that update over cellular is allowed as device policy\n  // says yes.\n  OmahaResponse response;\n  MockConnectionManager mock_cm;\n\n  fake_system_state_.set_connection_manager(&mock_cm);\n\n  EXPECT_CALL(mock_cm, GetConnectionProperties(_, _))\n      .WillRepeatedly(\n          DoAll(SetArgumentPointee<0>(ConnectionType::kCellular),\n                SetArgumentPointee<1>(ConnectionTethering::kUnknown),\n                Return(true)));\n  EXPECT_CALL(mock_cm, IsAllowedConnectionTypesForUpdateSet())\n      .WillRepeatedly(Return(true));\n  EXPECT_CALL(mock_cm, IsUpdateAllowedOver(ConnectionType::kCellular, _))\n      .WillRepeatedly(Return(true));\n\n  ASSERT_TRUE(\n      TestUpdateCheck(nullptr,  // request_params\n                      fake_update_response_.GetUpdateResponse(),\n                      -1,\n                      false,  // ping_only\n                      ErrorCode::kSuccess,\n                      metrics::CheckResult::kUpdateAvailable,\n                      metrics::CheckReaction::kUpdating,\n                      metrics::DownloadErrorCode::kUnset,\n                      &response,\n                      nullptr));\n  EXPECT_TRUE(response.update_exists);\n}\n\nTEST_F(OmahaRequestActionTest, ValidUpdateOverCellularBlockedByDevicePolicy) {\n  // This test tests that update over cellular is blocked as device policy\n  // says no.\n  OmahaResponse response;\n  MockConnectionManager mock_cm;\n\n  fake_system_state_.set_connection_manager(&mock_cm);\n\n  EXPECT_CALL(mock_cm, GetConnectionProperties(_, _))\n      .WillRepeatedly(\n          DoAll(SetArgumentPointee<0>(ConnectionType::kCellular),\n                SetArgumentPointee<1>(ConnectionTethering::kUnknown),\n                Return(true)));\n  EXPECT_CALL(mock_cm, IsAllowedConnectionTypesForUpdateSet())\n      .WillRepeatedly(Return(true));\n  EXPECT_CALL(mock_cm, IsUpdateAllowedOver(ConnectionType::kCellular, _))\n      .WillRepeatedly(Return(false));\n\n  ASSERT_FALSE(\n      TestUpdateCheck(nullptr,  // request_params\n                      fake_update_response_.GetUpdateResponse(),\n                      -1,\n                      false,  // ping_only\n                      ErrorCode::kOmahaUpdateIgnoredPerPolicy,\n                      metrics::CheckResult::kUpdateAvailable,\n                      metrics::CheckReaction::kIgnored,\n                      metrics::DownloadErrorCode::kUnset,\n                      &response,\n                      nullptr));\n  EXPECT_FALSE(response.update_exists);\n}\n\nTEST_F(OmahaRequestActionTest,\n       ValidUpdateOverCellularAllowedByUserPermissionTrue) {\n  // This test tests that, when device policy is not set, update over cellular\n  // is allowed as permission for update over cellular is set to true.\n  OmahaResponse response;\n  MockConnectionManager mock_cm;\n\n  fake_prefs_.SetBoolean(kPrefsUpdateOverCellularPermission, true);\n  fake_system_state_.set_connection_manager(&mock_cm);\n\n  EXPECT_CALL(mock_cm, GetConnectionProperties(_, _))\n      .WillRepeatedly(\n          DoAll(SetArgumentPointee<0>(ConnectionType::kCellular),\n                SetArgumentPointee<1>(ConnectionTethering::kUnknown),\n                Return(true)));\n  EXPECT_CALL(mock_cm, IsAllowedConnectionTypesForUpdateSet())\n      .WillRepeatedly(Return(false));\n  EXPECT_CALL(mock_cm, IsUpdateAllowedOver(ConnectionType::kCellular, _))\n      .WillRepeatedly(Return(true));\n\n  ASSERT_TRUE(\n      TestUpdateCheck(nullptr,  // request_params\n                      fake_update_response_.GetUpdateResponse(),\n                      -1,\n                      false,  // ping_only\n                      ErrorCode::kSuccess,\n                      metrics::CheckResult::kUpdateAvailable,\n                      metrics::CheckReaction::kUpdating,\n                      metrics::DownloadErrorCode::kUnset,\n                      &response,\n                      nullptr));\n  EXPECT_TRUE(response.update_exists);\n}\n\nTEST_F(OmahaRequestActionTest,\n       ValidUpdateOverCellularBlockedByUpdateTargetNotMatch) {\n  // This test tests that, when device policy is not set and permission for\n  // update over cellular is set to false or does not exist, update over\n  // cellular is blocked as update target does not match the omaha response.\n  OmahaResponse response;\n  MockConnectionManager mock_cm;\n  // A version different from the version in omaha response.\n  string diff_version = \"99.99.99\";\n  // A size different from the size in omaha response.\n  int64_t diff_size = 999;\n\n  fake_prefs_.SetString(kPrefsUpdateOverCellularTargetVersion, diff_version);\n  fake_prefs_.SetInt64(kPrefsUpdateOverCellularTargetSize, diff_size);\n  // This test tests cellular (3G) being the only connection type being allowed.\n  fake_system_state_.set_connection_manager(&mock_cm);\n\n  EXPECT_CALL(mock_cm, GetConnectionProperties(_, _))\n      .WillRepeatedly(\n          DoAll(SetArgumentPointee<0>(ConnectionType::kCellular),\n                SetArgumentPointee<1>(ConnectionTethering::kUnknown),\n                Return(true)));\n  EXPECT_CALL(mock_cm, IsAllowedConnectionTypesForUpdateSet())\n      .WillRepeatedly(Return(false));\n  EXPECT_CALL(mock_cm, IsUpdateAllowedOver(ConnectionType::kCellular, _))\n      .WillRepeatedly(Return(true));\n\n  ASSERT_FALSE(\n      TestUpdateCheck(nullptr,  // request_params\n                      fake_update_response_.GetUpdateResponse(),\n                      -1,\n                      false,  // ping_only\n                      ErrorCode::kOmahaUpdateIgnoredOverCellular,\n                      metrics::CheckResult::kUpdateAvailable,\n                      metrics::CheckReaction::kIgnored,\n                      metrics::DownloadErrorCode::kUnset,\n                      &response,\n                      nullptr));\n  EXPECT_FALSE(response.update_exists);\n}\n\nTEST_F(OmahaRequestActionTest,\n       ValidUpdateOverCellularAllowedByUpdateTargetMatch) {\n  // This test tests that, when device policy is not set and permission for\n  // update over cellular is set to false or does not exist, update over\n  // cellular is allowed as update target matches the omaha response.\n  OmahaResponse response;\n  MockConnectionManager mock_cm;\n  // A version same as the version in omaha response.\n  string new_version = fake_update_response_.version;\n  // A size same as the size in omaha response.\n  int64_t new_size = fake_update_response_.size;\n\n  fake_prefs_.SetString(kPrefsUpdateOverCellularTargetVersion, new_version);\n  fake_prefs_.SetInt64(kPrefsUpdateOverCellularTargetSize, new_size);\n  fake_system_state_.set_connection_manager(&mock_cm);\n\n  EXPECT_CALL(mock_cm, GetConnectionProperties(_, _))\n      .WillRepeatedly(\n          DoAll(SetArgumentPointee<0>(ConnectionType::kCellular),\n                SetArgumentPointee<1>(ConnectionTethering::kUnknown),\n                Return(true)));\n  EXPECT_CALL(mock_cm, IsAllowedConnectionTypesForUpdateSet())\n      .WillRepeatedly(Return(false));\n  EXPECT_CALL(mock_cm, IsUpdateAllowedOver(ConnectionType::kCellular, _))\n      .WillRepeatedly(Return(true));\n\n  ASSERT_TRUE(\n      TestUpdateCheck(nullptr,  // request_params\n                      fake_update_response_.GetUpdateResponse(),\n                      -1,\n                      false,  // ping_only\n                      ErrorCode::kSuccess,\n                      metrics::CheckResult::kUpdateAvailable,\n                      metrics::CheckReaction::kUpdating,\n                      metrics::DownloadErrorCode::kUnset,\n                      &response,\n                      nullptr));\n  EXPECT_TRUE(response.update_exists);\n}\n",
        "res_region": "",
        "lookback": "  string rollback_version = \"1234.0.0\";",
        "lookahead": "TEST_F(OmahaRequestActionTest, ValidUpdateBlockedByRollback) {",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 784,
        "end_line": 1145,
        "merge_gen_region": "_(maRequestTest Valid",
        "confidence": 0.9582609534263611,
        "hesitated": false,
        "resolved": false
    }
]