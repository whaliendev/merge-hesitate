[
    {
        "a_contents": "//\n// Copyright (C) 2017 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n#include \"update_engine/payload_consumer/file_descriptor_utils.h\"\n\n#include <algorithm>\n\n#include <base/logging.h>\n\n#include \"update_engine/common/hash_calculator.h\"\n#include \"update_engine/common/utils.h\"\n#include \"update_engine/payload_consumer/extent_writer.h\"\n\nusing google::protobuf::RepeatedPtrField;\nusing std::min;\n\nnamespace chromeos_update_engine {\n\nnamespace {\n\n// Size of the buffer used to copy blocks.\nconst int kMaxCopyBufferSize = 1024 * 1024;\n\n// Return the total number of blocks in the passed |extents| list.\nuint64_t GetBlockCount(const RepeatedPtrField<Extent>& extents) {\n  uint64_t sum = 0;\n  for (const Extent& ext : extents) {\n    sum += ext.num_blocks();\n  }\n  return sum;\n}\n\n}  // namespace\n\nnamespace fd_utils {\n\nbool CopyAndHashExtents(FileDescriptorPtr source,\n                        const RepeatedPtrField<Extent>& src_extents,\n                        FileDescriptorPtr target,\n                        const RepeatedPtrField<Extent>& tgt_extents,\n                        uint32_t block_size,\n                        brillo::Blob* hash_out) {\n  HashCalculator source_hasher;\n\n  uint64_t buffer_blocks = kMaxCopyBufferSize / block_size;\n  // Ensure we copy at least one block at a time.\n  if (buffer_blocks < 1)\n    buffer_blocks = 1;\n\n  uint64_t total_blocks = GetBlockCount(src_extents);\n  TEST_AND_RETURN_FALSE(total_blocks == GetBlockCount(tgt_extents));\n\n  brillo::Blob buf(buffer_blocks * block_size);\n\n  DirectExtentWriter writer;\n  std::vector<Extent> vec_tgt_extents;\n  vec_tgt_extents.reserve(tgt_extents.size());\n  for (const auto& ext : tgt_extents) {\n    vec_tgt_extents.push_back(ext);\n  }\n  TEST_AND_RETURN_FALSE(writer.Init(target, vec_tgt_extents, block_size));\n\n  for (const Extent& src_ext : src_extents) {\n    for (uint64_t src_ext_block = 0; src_ext_block < src_ext.num_blocks();\n         src_ext_block += buffer_blocks) {\n      uint64_t iteration_blocks =\n          min(buffer_blocks,\n              static_cast<uint64_t>(src_ext.num_blocks() - src_ext_block));\n      uint64_t src_start_block = src_ext.start_block() + src_ext_block;\n\n      ssize_t bytes_read_this_iteration;\n      TEST_AND_RETURN_FALSE(utils::PReadAll(source,\n                                            buf.data(),\n                                            iteration_blocks * block_size,\n                                            src_start_block * block_size,\n                                            &bytes_read_this_iteration));\n\n      TEST_AND_RETURN_FALSE(\n          bytes_read_this_iteration ==\n          static_cast<ssize_t>(iteration_blocks * block_size));\n\n      TEST_AND_RETURN_FALSE(\n          writer.Write(buf.data(), iteration_blocks * block_size));\n\n      if (hash_out) {\n        TEST_AND_RETURN_FALSE(\n            source_hasher.Update(buf.data(), iteration_blocks * block_size));\n      }\n    }\n  }\n  TEST_AND_RETURN_FALSE(writer.End());\n\n  if (hash_out) {\n    TEST_AND_RETURN_FALSE(source_hasher.Finalize());\n    *hash_out = source_hasher.raw_hash();\n  }\n  return true;\n}\n\n}  // namespace fd_utils\n\n}  // namespace chromeos_update_engine",
        "b_contents": "//\n// Copyright (C) 2017 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n#include \"update_engine/payload_consumer/file_descriptor_utils.h\"\n\n#include <algorithm>\n\n#include <base/logging.h>\n\n#include \"update_engine/common/hash_calculator.h\"\n#include \"update_engine/common/utils.h\"\n#include \"update_engine/payload_consumer/extent_reader.h\"\n#include \"update_engine/payload_consumer/extent_writer.h\"\n\nusing google::protobuf::RepeatedPtrField;\nusing std::min;\n\nnamespace chromeos_update_engine {\n\nnamespace {\n\n// Size of the buffer used to copy blocks.\nconst int kMaxCopyBufferSize = 1024 * 1024;\n\n}  // namespace\n\nnamespace fd_utils {\n\nbool CopyAndHashExtents(FileDescriptorPtr source,\n                        const RepeatedPtrField<Extent>& src_extents,\n                        FileDescriptorPtr target,\n                        const RepeatedPtrField<Extent>& tgt_extents,\n                        uint32_t block_size,\n                        brillo::Blob* hash_out) {\n  uint64_t total_blocks = utils::BlocksInExtents(src_extents);\n  TEST_AND_RETURN_FALSE(total_blocks == utils::BlocksInExtents(tgt_extents));\n\n  DirectExtentReader reader;\n  TEST_AND_RETURN_FALSE(reader.Init(source, src_extents, block_size));\n  DirectExtentWriter writer;\n  TEST_AND_RETURN_FALSE(writer.Init(target, tgt_extents, block_size));\n\n  uint64_t buffer_blocks = kMaxCopyBufferSize / block_size;\n  // Ensure we copy at least one block at a time.\n  if (buffer_blocks < 1)\n    buffer_blocks = 1;\n  brillo::Blob buf(buffer_blocks * block_size);\n\n  HashCalculator source_hasher;\n  uint64_t blocks_left = total_blocks;\n  while (blocks_left > 0) {\n    uint64_t read_blocks = std::min(blocks_left, buffer_blocks);\n    TEST_AND_RETURN_FALSE(reader.Read(buf.data(), read_blocks * block_size));\n    if (hash_out) {\n      TEST_AND_RETURN_FALSE(\n          source_hasher.Update(buf.data(), read_blocks * block_size));\n    }\n    TEST_AND_RETURN_FALSE(writer.Write(buf.data(), read_blocks * block_size));\n    blocks_left -= read_blocks;\n  }\n  TEST_AND_RETURN_FALSE(writer.End());\n\n  if (hash_out) {\n    TEST_AND_RETURN_FALSE(source_hasher.Finalize());\n    *hash_out = source_hasher.raw_hash();\n  }\n  return true;\n}\n\n}  // namespace fd_utils\n\n}  // namespace chromeos_update_engine",
        "base_contents": "",
        "res_region": "//\n// Copyright (C) 2017 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n#include \"update_engine/payload_consumer/file_descriptor_utils.h\"\n\n#include <algorithm>\n\n#include <base/logging.h>\n\n#include \"update_engine/common/hash_calculator.h\"\n#include \"update_engine/common/utils.h\"\n#include \"update_engine/payload_consumer/extent_reader.h\"\n#include \"update_engine/payload_consumer/extent_writer.h\"\n\nusing google::protobuf::RepeatedPtrField;\nusing std::min;\n\nnamespace chromeos_update_engine {\n\nnamespace {\n\n// Size of the buffer used to copy blocks.\nconst int kMaxCopyBufferSize = 1024 * 1024;\n\n}  // namespace\n\nnamespace fd_utils {\n\nbool CopyAndHashExtents(FileDescriptorPtr source,\n                        const RepeatedPtrField<Extent>& src_extents,\n                        FileDescriptorPtr target,\n                        const RepeatedPtrField<Extent>& tgt_extents,\n                        uint32_t block_size,\n                        brillo::Blob* hash_out) {\n  uint64_t total_blocks = utils::BlocksInExtents(src_extents);\n  TEST_AND_RETURN_FALSE(total_blocks == utils::BlocksInExtents(tgt_extents));\n\n  DirectExtentReader reader;\n  TEST_AND_RETURN_FALSE(reader.Init(source, src_extents, block_size));\n  DirectExtentWriter writer;\n  TEST_AND_RETURN_FALSE(writer.Init(target, tgt_extents, block_size));\n\n  uint64_t buffer_blocks = kMaxCopyBufferSize / block_size;\n  // Ensure we copy at least one block at a time.\n  if (buffer_blocks < 1)\n    buffer_blocks = 1;\n  brillo::Blob buf(buffer_blocks * block_size);\n\n  HashCalculator source_hasher;\n  uint64_t blocks_left = total_blocks;\n  while (blocks_left > 0) {\n    uint64_t read_blocks = std::min(blocks_left, buffer_blocks);\n    TEST_AND_RETURN_FALSE(reader.Read(buf.data(), read_blocks * block_size));\n    if (hash_out) {\n      TEST_AND_RETURN_FALSE(\n          source_hasher.Update(buf.data(), read_blocks * block_size));\n    }\n    TEST_AND_RETURN_FALSE(writer.Write(buf.data(), read_blocks * block_size));\n    blocks_left -= read_blocks;\n  }\n  TEST_AND_RETURN_FALSE(writer.End());\n\n  if (hash_out) {\n    TEST_AND_RETURN_FALSE(source_hasher.Finalize());\n    *hash_out = source_hasher.raw_hash();\n  }\n  return true;\n}\n\n}  // namespace fd_utils\n\n}  // namespace chromeos_update_engine",
        "lookback": "// Copyright (C) 2017 The Android Open Source Project",
        "lookahead": "",
        "label": [
            "base",
            "one_side_deletion"
        ],
        "start_line": 0,
        "end_line": 203,
        "merge_gen_region": null,
        "confidence": 0.8481652736663818,
        "hesitated": true
    }
]