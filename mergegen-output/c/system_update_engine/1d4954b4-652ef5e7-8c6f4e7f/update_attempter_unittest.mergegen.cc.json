[
    {
        "a_contents": "TEST_F(UpdateAttempterTest, UpdateDeferredByPolicyTest) {\n  // Construct an OmahaResponseHandlerAction that has processed an InstallPlan,\n  // but the update is being deferred by the Policy.\n  OmahaResponseHandlerAction* response_action =\n      new OmahaResponseHandlerAction(&fake_system_state_);\n  response_action->install_plan_.version = \"a.b.c.d\";\n  response_action->install_plan_.system_version = \"b.c.d.e\";\n  response_action->install_plan_.payloads.push_back(\n      {.size = 1234ULL, .type = InstallPayloadType::kFull});\n  attempter_.response_handler_action_.reset(response_action);\n  // Inform the UpdateAttempter that the OmahaResponseHandlerAction has\n  // completed, with the deferred-update error code.\n  attempter_.ActionCompleted(\n      nullptr, response_action, ErrorCode::kOmahaUpdateDeferredPerPolicy);\n  {\n    UpdateEngineStatus status;\n    attempter_.GetStatus(&status);\n    EXPECT_EQ(UpdateStatus::UPDATE_AVAILABLE, status.status);\n    EXPECT_EQ(response_action->install_plan_.version, status.new_version);\n    EXPECT_EQ(response_action->install_plan_.system_version,\n              status.new_system_version);\n    EXPECT_EQ(response_action->install_plan_.payloads[0].size,\n              status.new_size_bytes);\n  }\n  // An \"error\" event should have been created to tell Omaha that the update is\n  // being deferred.\n  EXPECT_TRUE(nullptr != attempter_.error_event_);\n  EXPECT_EQ(OmahaEvent::kTypeUpdateComplete, attempter_.error_event_->type);\n  EXPECT_EQ(OmahaEvent::kResultUpdateDeferred, attempter_.error_event_->result);\n  ErrorCode expected_code = static_cast<ErrorCode>(\n      static_cast<int>(ErrorCode::kOmahaUpdateDeferredPerPolicy) |\n      static_cast<int>(ErrorCode::kTestOmahaUrlFlag));\n  EXPECT_EQ(expected_code, attempter_.error_event_->error_code);\n  // End the processing\n  attempter_.ProcessingDone(nullptr, ErrorCode::kOmahaUpdateDeferredPerPolicy);\n  // Validate the state of the attempter.\n  {\n    UpdateEngineStatus status;\n    attempter_.GetStatus(&status);\n    EXPECT_EQ(UpdateStatus::REPORTING_ERROR_EVENT, status.status);\n    EXPECT_EQ(response_action->install_plan_.version, status.new_version);\n    EXPECT_EQ(response_action->install_plan_.system_version,\n              status.new_system_version);\n    EXPECT_EQ(response_action->install_plan_.payloads[0].size,\n              status.new_size_bytes);\n  }\n}\n\nTEST_F(UpdateAttempterTest, UpdateIsNotRunningWhenUpdateAvailable) {\n  EXPECT_FALSE(attempter_.IsUpdateRunningOrScheduled());\n  // Verify in-progress update with UPDATE_AVAILABLE is running\n  attempter_.status_ = UpdateStatus::UPDATE_AVAILABLE;\n  EXPECT_TRUE(attempter_.IsUpdateRunningOrScheduled());\n}\n\nTEST_F(UpdateAttempterTest, UpdateAttemptFlagsCachedAtUpdateStart) {\n  attempter_.SetUpdateAttemptFlags(UpdateAttemptFlags::kFlagRestrictDownload);\n\n  UpdateCheckParams params = {.updates_enabled = true};\n  attempter_.OnUpdateScheduled(EvalStatus::kSucceeded, params);\n\n  EXPECT_EQ(UpdateAttemptFlags::kFlagRestrictDownload,\n            attempter_.GetCurrentUpdateAttemptFlags());\n}\n\nTEST_F(UpdateAttempterTest, InteractiveUpdateUsesPassedRestrictions) {\n  attempter_.SetUpdateAttemptFlags(UpdateAttemptFlags::kFlagRestrictDownload);\n\n  attempter_.CheckForUpdate(\"\", \"\", UpdateAttemptFlags::kNone);\n  EXPECT_EQ(UpdateAttemptFlags::kNone,\n            attempter_.GetCurrentUpdateAttemptFlags());\n}\n\nTEST_F(UpdateAttempterTest, NonInteractiveUpdateUsesSetRestrictions) {\n  attempter_.SetUpdateAttemptFlags(UpdateAttemptFlags::kNone);\n\n  // This tests that when CheckForUpdate() is called with the non-interactive\n  // flag set, that it doesn't change the current UpdateAttemptFlags.\n  attempter_.CheckForUpdate(\"\",\n                            \"\",\n                            UpdateAttemptFlags::kFlagNonInteractive |\n                                UpdateAttemptFlags::kFlagRestrictDownload);\n  EXPECT_EQ(UpdateAttemptFlags::kNone,\n            attempter_.GetCurrentUpdateAttemptFlags());\n}\n",
        "b_contents": "TEST_F(UpdateAttempterTest, UpdateDeferredByPolicyTest) {\n  // Construct an OmahaResponseHandlerAction that has processed an InstallPlan,\n  // but the update is being deferred by the Policy.\n  OmahaResponseHandlerAction* response_action =\n      new OmahaResponseHandlerAction(&fake_system_state_);\n  response_action->install_plan_.version = \"a.b.c.d\";\n  response_action->install_plan_.system_version = \"b.c.d.e\";\n  response_action->install_plan_.payloads.push_back(\n      {.size = 1234ULL, .type = InstallPayloadType::kFull});\n  attempter_.response_handler_action_.reset(response_action);\n  // Inform the UpdateAttempter that the OmahaResponseHandlerAction has\n  // completed, with the deferred-update error code.\n  attempter_.ActionCompleted(\n      nullptr, response_action, ErrorCode::kOmahaUpdateDeferredPerPolicy);\n  {\n    UpdateEngineStatus status;\n    attempter_.GetStatus(&status);\n    EXPECT_EQ(UpdateStatus::UPDATE_AVAILABLE, status.status);\n    EXPECT_EQ(response_action->install_plan_.version, status.new_version);\n    EXPECT_EQ(response_action->install_plan_.system_version,\n              status.new_system_version);\n    EXPECT_EQ(response_action->install_plan_.payloads[0].size,\n              status.new_size_bytes);\n  }\n  // An \"error\" event should have been created to tell Omaha that the update is\n  // being deferred.\n  EXPECT_TRUE(nullptr != attempter_.error_event_);\n  EXPECT_EQ(OmahaEvent::kTypeUpdateComplete, attempter_.error_event_->type);\n  EXPECT_EQ(OmahaEvent::kResultUpdateDeferred, attempter_.error_event_->result);\n  ErrorCode expected_code = static_cast<ErrorCode>(\n      static_cast<int>(ErrorCode::kOmahaUpdateDeferredPerPolicy) |\n      static_cast<int>(ErrorCode::kTestOmahaUrlFlag));\n  EXPECT_EQ(expected_code, attempter_.error_event_->error_code);\n  // End the processing\n  attempter_.ProcessingDone(nullptr, ErrorCode::kOmahaUpdateDeferredPerPolicy);\n  // Validate the state of the attempter.\n  {\n    UpdateEngineStatus status;\n    attempter_.GetStatus(&status);\n    EXPECT_EQ(UpdateStatus::REPORTING_ERROR_EVENT, status.status);\n    EXPECT_EQ(response_action->install_plan_.version, status.new_version);\n    EXPECT_EQ(response_action->install_plan_.system_version,\n              status.new_system_version);\n    EXPECT_EQ(response_action->install_plan_.payloads[0].size,\n              status.new_size_bytes);\n  }\n}\n\nTEST_F(UpdateAttempterTest, UpdateIsNotRunningWhenUpdateAvailable) {\n  EXPECT_FALSE(attempter_.IsUpdateRunningOrScheduled());\n  // Verify in-progress update with UPDATE_AVAILABLE is running\n  attempter_.status_ = UpdateStatus::UPDATE_AVAILABLE;\n  EXPECT_TRUE(attempter_.IsUpdateRunningOrScheduled());\n}\n",
        "base_contents": "",
        "res_region": "TEST_F(UpdateAttempterTest, UpdateDeferredByPolicyTest) {\n  // Construct an OmahaResponseHandlerAction that has processed an InstallPlan,\n  // but the update is being deferred by the Policy.\n  OmahaResponseHandlerAction* response_action =\n      new OmahaResponseHandlerAction(&fake_system_state_);\n  response_action->install_plan_.version = \"a.b.c.d\";\n  response_action->install_plan_.system_version = \"b.c.d.e\";\n  response_action->install_plan_.payloads.push_back(\n      {.size = 1234ULL, .type = InstallPayloadType::kFull});\n  attempter_.response_handler_action_.reset(response_action);\n  // Inform the UpdateAttempter that the OmahaResponseHandlerAction has\n  // completed, with the deferred-update error code.\n  attempter_.ActionCompleted(\n      nullptr, response_action, ErrorCode::kOmahaUpdateDeferredPerPolicy);\n  {\n    UpdateEngineStatus status;\n    attempter_.GetStatus(&status);\n    EXPECT_EQ(UpdateStatus::UPDATE_AVAILABLE, status.status);\n    EXPECT_EQ(response_action->install_plan_.version, status.new_version);\n    EXPECT_EQ(response_action->install_plan_.system_version,\n              status.new_system_version);\n    EXPECT_EQ(response_action->install_plan_.payloads[0].size,\n              status.new_size_bytes);\n  }\n  // An \"error\" event should have been created to tell Omaha that the update is\n  // being deferred.\n  EXPECT_TRUE(nullptr != attempter_.error_event_);\n  EXPECT_EQ(OmahaEvent::kTypeUpdateComplete, attempter_.error_event_->type);\n  EXPECT_EQ(OmahaEvent::kResultUpdateDeferred, attempter_.error_event_->result);\n  ErrorCode expected_code = static_cast<ErrorCode>(\n      static_cast<int>(ErrorCode::kOmahaUpdateDeferredPerPolicy) |\n      static_cast<int>(ErrorCode::kTestOmahaUrlFlag));\n  EXPECT_EQ(expected_code, attempter_.error_event_->error_code);\n  // End the processing\n  attempter_.ProcessingDone(nullptr, ErrorCode::kOmahaUpdateDeferredPerPolicy);\n  // Validate the state of the attempter.\n  {\n    UpdateEngineStatus status;\n    attempter_.GetStatus(&status);\n    EXPECT_EQ(UpdateStatus::REPORTING_ERROR_EVENT, status.status);\n    EXPECT_EQ(response_action->install_plan_.version, status.new_version);\n    EXPECT_EQ(response_action->install_plan_.system_version,\n              status.new_system_version);\n    EXPECT_EQ(response_action->install_plan_.payloads[0].size,\n              status.new_size_bytes);\n  }\n}\n\nTEST_F(UpdateAttempterTest, UpdateIsNotRunningWhenUpdateAvailable) {\n  EXPECT_FALSE(attempter_.IsUpdateRunningOrScheduled());\n  // Verify in-progress update with UPDATE_AVAILABLE is running\n  attempter_.status_ = UpdateStatus::UPDATE_AVAILABLE;\n  EXPECT_TRUE(attempter_.IsUpdateRunningOrScheduled());\n}\n\nTEST_F(UpdateAttempterTest, UpdateAttemptFlagsCachedAtUpdateStart) {\n  attempter_.SetUpdateAttemptFlags(UpdateAttemptFlags::kFlagRestrictDownload);\n\n  UpdateCheckParams params = {.updates_enabled = true};\n  attempter_.OnUpdateScheduled(EvalStatus::kSucceeded, params);\n\n  EXPECT_EQ(UpdateAttemptFlags::kFlagRestrictDownload,\n            attempter_.GetCurrentUpdateAttemptFlags());\n}\n\nTEST_F(UpdateAttempterTest, InteractiveUpdateUsesPassedRestrictions) {\n  attempter_.SetUpdateAttemptFlags(UpdateAttemptFlags::kFlagRestrictDownload);\n\n  attempter_.CheckForUpdate(\"\", \"\", UpdateAttemptFlags::kNone);\n  EXPECT_EQ(UpdateAttemptFlags::kNone,\n            attempter_.GetCurrentUpdateAttemptFlags());\n}\n\nTEST_F(UpdateAttempterTest, NonInteractiveUpdateUsesSetRestrictions) {\n  attempter_.SetUpdateAttemptFlags(UpdateAttemptFlags::kNone);\n\n  // This tests that when CheckForUpdate() is called with the non-interactive\n  // flag set, that it doesn't change the current UpdateAttemptFlags.\n  attempter_.CheckForUpdate(\"\",\n                            \"\",\n                            UpdateAttemptFlags::kFlagNonInteractive |\n                                UpdateAttemptFlags::kFlagRestrictDownload);\n  EXPECT_EQ(UpdateAttemptFlags::kNone,\n            attempter_.GetCurrentUpdateAttemptFlags());\n}\n",
        "lookback": "  // Construct an OmahaResponseHandlerAction that has processed an InstallPlan,",
        "lookahead": "}  // namespace chromeos_update_engine",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 1072,
        "end_line": 1216,
        "merge_gen_region": " Construct OhaHandler that processed Install,TESTFUpdatetempTest UpdateByTest { Construct OhaHandler that processed InstallPlan // the update being being by Policy OhaHandler*_ = OhaHandler(&____);_->installplanversion \"abcd\";_actioninstallplansystemversion \"bcde responseactioninstallplanpayload.__(_(size 1ULL . =Payload::Full attemp_.responsehandleractionresetresponseaction //form UpdateAtter themahaHandler has completed with deferredupdate code attemp_.Action(,,,,_,CodekmaUpdatePer); UpdateStatus;terGetStatusstatus EXPECTEQUpdateStatusUPDATEAVAILABLE statusstatus EXPECTEQresponseactioninstallplanversion statusnewversion EXPECTEQresponseactioninstallplansystemversion statusnewsystemversion EXPECTEQresponseactioninstallplanpayload[].,..___); // \"\" event have created tellma that update // deferred EXPECTTRUEnullptr attemp_.Action(,_,CodekmaUpdatePer); UpdateStatus;terGetStatusstatus EXPECTEQUpdateStatuskUpdate::TypeComplete attemp_.erroreventtype EXPECTEQOha::ResultDeferred attemp_.erroreventresult Error expectedcode staticcastErrorCode staticcastintErrorCode::OmaUpdatePer) static",
        "confidence": 0.944353461265564,
        "hesitated": false,
        "resolved": false
    }
]