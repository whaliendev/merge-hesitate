[
    {
        "a_contents": "namespace {\n\n// ExtentWriter class that writes to memory, used to test the decompression\n// step with the corresponding extent writer.\nclass MemoryExtentWriter : public ExtentWriter {\n public:\n  // Creates the ExtentWriter that will write all the bytes to the passed |data|\n  // blob.\n  explicit MemoryExtentWriter(brillo::Blob* data) : data_(data) {\n    data_->clear();\n  }\n  ~MemoryExtentWriter() override = default;\n\n  bool Init(FileDescriptorPtr fd,\n            const vector<Extent>& extents,\n            uint32_t block_size) override {\n    return true;\n  }\n  bool Write(const void* bytes, size_t count) override {\n    data_->reserve(data_->size() + count);\n    data_->insert(data_->end(),\n                  static_cast<const uint8_t*>(bytes),\n                  static_cast<const uint8_t*>(bytes) + count);\n    return true;\n  }\n  bool EndImpl() override { return true; }\n\n private:\n  brillo::Blob* data_;\n};\n\ntemplate <typename W>\nbool DecompressWithWriter(const brillo::Blob& in, brillo::Blob* out) {\n  std::unique_ptr<ExtentWriter> writer(\n      new W(brillo::make_unique_ptr(new MemoryExtentWriter(out))));\n  // Init() parameters are ignored by the testing MemoryExtentWriter.\n  bool ok = writer->Init(nullptr, {}, 1);\n  ok = writer->Write(in.data(), in.size()) && ok;\n  // Call End() even if the Write failed.\n  ok = writer->End() && ok;\n  return ok;\n}\n\n}  // namespace\n",
        "b_contents": "namespace {\n\n// ExtentWriter class that writes to memory, used to test the decompression\n// step with the corresponding extent writer.\nclass MemoryExtentWriter : public ExtentWriter {\n public:\n  // Creates the ExtentWriter that will write all the bytes to the passed |data|\n  // blob.\n  explicit MemoryExtentWriter(brillo::Blob* data) : data_(data) {\n    data_->clear();\n  }\n  ~MemoryExtentWriter() override = default;\n\n  bool Init(FileDescriptorPtr fd,\n            const vector<Extent>& extents,\n            uint32_t block_size) override {\n    return true;\n  }\n  bool Write(const void* bytes, size_t count) override {\n    data_->reserve(data_->size() + count);\n    data_->insert(data_->end(),\n                  static_cast<const uint8_t*>(bytes),\n                  static_cast<const uint8_t*>(bytes) + count);\n    return true;\n  }\n  bool EndImpl() override { return true; }\n\n private:\n  brillo::Blob* data_;\n};\n\ntemplate <typename W>\nbool DecompressWithWriter(const brillo::Blob& in, brillo::Blob* out) {\n  std::unique_ptr<ExtentWriter> writer(\n      new W(brillo::make_unique_ptr(new MemoryExtentWriter(out))));\n  // Init() parameters are ignored by the testing MemoryExtentWriter.\n  TEST_AND_RETURN_FALSE(writer->Init(nullptr, {}, 1));\n  TEST_AND_RETURN_FALSE(writer->Write(in.data(), in.size()));\n  TEST_AND_RETURN_FALSE(writer->End());\n  return true;\n}\n\n}  // namespace\n",
        "base_contents": "",
        "res_region": "namespace {\n\n// ExtentWriter class that writes to memory, used to test the decompression\n// step with the corresponding extent writer.\nclass MemoryExtentWriter : public ExtentWriter {\n public:\n  // Creates the ExtentWriter that will write all the bytes to the passed |data|\n  // blob.\n  explicit MemoryExtentWriter(brillo::Blob* data) : data_(data) {\n    data_->clear();\n  }\n  ~MemoryExtentWriter() override = default;\n\n  bool Init(FileDescriptorPtr fd,\n            const vector<Extent>& extents,\n            uint32_t block_size) override {\n    return true;\n  }\n  bool Write(const void* bytes, size_t count) override {\n    data_->reserve(data_->size() + count);\n    data_->insert(data_->end(),\n                  static_cast<const uint8_t*>(bytes),\n                  static_cast<const uint8_t*>(bytes) + count);\n    return true;\n  }\n  bool EndImpl() override { return true; }\n\n private:\n  brillo::Blob* data_;\n};\n\ntemplate <typename W>\nbool DecompressWithWriter(const brillo::Blob& in, brillo::Blob* out) {\n  std::unique_ptr<ExtentWriter> writer(\n      new W(brillo::make_unique_ptr(new MemoryExtentWriter(out))));\n  // Init() parameters are ignored by the testing MemoryExtentWriter.\n  bool ok = writer->Init(nullptr, {}, 1);\n  ok = writer->Write(in.data(), in.size()) && ok;\n  // Call End() even if the Write failed.\n  ok = writer->End() && ok;\n  return ok;\n}\n\n}  // namespace\n",
        "lookback": "",
        "lookahead": "template <typename T>",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 38,
        "end_line": 130,
        "merge_gen_region": null,
        "confidence": 0.42610499262809753,
        "hesitated": true
    }
]