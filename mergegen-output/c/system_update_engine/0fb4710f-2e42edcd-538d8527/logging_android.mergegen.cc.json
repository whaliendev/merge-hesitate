[
    {
        "a_contents": "//\n// Copyright (C) 2020 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n#include <inttypes.h>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include <string>\n#include <string_view>\n#include <vector>\n\n#include <android-base/file.h>\n#include <android-base/strings.h>\n#include <android-base/unique_fd.h>\n#include <base/files/dir_reader_posix.h>\n#include <base/logging.h>\n#include <base/strings/string_util.h>\n#include <base/strings/stringprintf.h>\n#include <log/log.h>\n\n#include \"update_engine/common/utils.h\"\n\nusing std::string;\n\nnamespace chromeos_update_engine {\nnamespace {\n\nconstexpr char kSystemLogsRoot[] = \"/data/misc/update_engine_log\";\nconstexpr size_t kLogCount = 5;\n\n// Keep the most recent |kLogCount| logs but remove the old ones in\n// \"/data/misc/update_engine_log/\".\nvoid DeleteOldLogs(const string& kLogsRoot) {\n  base::DirReaderPosix reader(kLogsRoot.c_str());\n  if (!reader.IsValid()) {\n    LOG(ERROR) << \"Failed to read \" << kLogsRoot;\n    return;\n  }\n\n  std::vector<string> old_logs;\n  while (reader.Next()) {\n    if (reader.name()[0] == '.')\n      continue;\n\n    // Log files are in format \"update_engine.%Y%m%d-%H%M%S\",\n    // e.g. update_engine.20090103-231425\n    uint64_t date;\n    uint64_t local_time;\n    if (sscanf(reader.name(),\n               \"update_engine.%\" PRIu64 \"-%\" PRIu64 \"\",\n               &date,\n               &local_time) == 2) {\n      old_logs.push_back(reader.name());\n    } else {\n      LOG(WARNING) << \"Unrecognized log file \" << reader.name();\n    }\n  }\n\n  std::sort(old_logs.begin(), old_logs.end(), std::greater<string>());\n  for (size_t i = kLogCount; i < old_logs.size(); i++) {\n    string log_path = kLogsRoot + \"/\" + old_logs[i];\n    if (unlink(log_path.c_str()) == -1) {\n      PLOG(WARNING) << \"Failed to unlink \" << log_path;\n    }\n  }\n}\n\nstring SetupLogFile(const string& kLogsRoot) {\n  DeleteOldLogs(kLogsRoot);\n\n  return base::StringPrintf(\"%s/update_engine.%s\",\n                            kLogsRoot.c_str(),\n                            utils::GetTimeAsString(::time(nullptr)).c_str());\n}\n\nconst char* LogPriorityToCString(int priority) {\n  switch (priority) {\n    case ANDROID_LOG_VERBOSE:\n      return \"VERBOSE\";\n    case ANDROID_LOG_DEBUG:\n      return \"DEBUG\";\n    case ANDROID_LOG_INFO:\n      return \"INFO\";\n    case ANDROID_LOG_WARN:\n      return \"WARN\";\n    case ANDROID_LOG_ERROR:\n      return \"ERROR\";\n    case ANDROID_LOG_FATAL:\n      return \"FATAL\";\n    default:\n      return \"UNKNOWN\";\n  }\n}\n\nusing LoggerFunction = std::function<void(const struct __android_logger_data*,\n                                          const char* message)>;\n\nclass FileLogger {\n public:\n  explicit FileLogger(const string& path) {\n    fd_.reset(TEMP_FAILURE_RETRY(\n        open(path.c_str(),\n             O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC | O_NOFOLLOW | O_SYNC,\n             0644)));\n    if (fd_ == -1) {\n      // Use ALOGE that logs to logd before __android_log_set_logger.\n      ALOGE(\"Cannot open persistent log %s: %s\", path.c_str(), strerror(errno));\n      return;\n    }\n    // The log file will have AID_LOG as group ID; this GID is inherited from\n    // the parent directory \"/data/misc/update_engine_log\" which sets the SGID\n    // bit.\n    if (fchmod(fd_.get(), 0640) == -1) {\n      // Use ALOGE that logs to logd before __android_log_set_logger.\n      ALOGE(\"Cannot chmod 0640 persistent log %s: %s\",\n            path.c_str(),\n            strerror(errno));\n      return;\n    }\n  }\n  // Copy-constructor needed to be converted to std::function.\n  FileLogger(const FileLogger& other) { fd_.reset(dup(other.fd_)); }\n  void operator()(const struct __android_logger_data* logger_data,\n                  const char* message) {\n    if (fd_ == -1) {\n      return;\n    }\n\n    // libchrome add a newline character to |message|. Strip it.\n    std::string_view message_no_newline = message != nullptr ? message : \"\";\n    ignore_result(android::base::ConsumeSuffix(&message_no_newline, \"\\n\"));\n\n    WriteToFd(GetPrefix(logger_data));\n    WriteToFd(message_no_newline);\n    WriteToFd(\"\\n\");\n  }\n\n private:\n  android::base::unique_fd fd_;\n  void WriteToFd(std::string_view message) {\n    ignore_result(\n        android::base::WriteFully(fd_, message.data(), message.size()));\n  }\n\n  string GetPrefix(const struct __android_logger_data* logger_data) {\n    std::stringstream ss;\n    timeval tv;\n    gettimeofday(&tv, nullptr);\n    time_t t = tv.tv_sec;\n    struct tm local_time;\n    localtime_r(&t, &local_time);\n    struct tm* tm_time = &local_time;\n    ss << \"[\" << std::setfill('0') << std::setw(2) << 1 + tm_time->tm_mon\n       << std::setw(2) << tm_time->tm_mday << '/' << std::setw(2)\n       << tm_time->tm_hour << std::setw(2) << tm_time->tm_min << std::setw(2)\n       << tm_time->tm_sec << '.' << std::setw(6) << tv.tv_usec << \"] \";\n    // libchrome logs prepends |message| with severity, file and line, but\n    // leave logger_data->file as nullptr.\n    // libbase / liblog logs doesn't. Hence, add them to match the style.\n    // For liblog logs that doesn't set logger_data->file, not printing the\n    // priority is acceptable.\n    if (logger_data->file) {\n      ss << \"[\" << LogPriorityToCString(logger_data->priority) << ':'\n         << logger_data->file << '(' << logger_data->line << \")] \";\n    }\n    return ss.str();\n  }\n};\n\nclass CombinedLogger {\n public:\n  CombinedLogger(bool log_to_system, bool log_to_file) {\n    if (log_to_system) {\n      loggers_.push_back(__android_log_logd_logger);\n    }\n    if (log_to_file) {\n      loggers_.push_back(std::move(FileLogger(SetupLogFile(kSystemLogsRoot))));\n    }\n  }\n  void operator()(const struct __android_logger_data* logger_data,\n                  const char* message) {\n    for (auto&& logger : loggers_) {\n      logger(logger_data, message != nullptr ? message : \"\");\n    }\n  }\n\n private:\n  std::vector<LoggerFunction> loggers_;\n};\n\n}  // namespace\n\nvoid SetupLogging(bool log_to_system, bool log_to_file) {\n  // Note that libchrome logging uses liblog.\n  // By calling liblog's __android_log_set_logger function, all of libchrome\n  // (used by update_engine) / libbase / liblog (used by depended modules)\n  // logging eventually redirects to CombinedLogger.\n  static auto g_logger =\n      std::make_unique<CombinedLogger>(log_to_system, log_to_file);\n  __android_log_set_logger(\n      [](const struct __android_logger_data* logger_data, const char* message) {\n        (*g_logger)(logger_data, message);\n      });\n\n  // libchrome logging should not log to file.\n  logging::LoggingSettings log_settings;\n  log_settings.lock_log = logging::DONT_LOCK_LOG_FILE;\n  log_settings.logging_dest = static_cast<logging::LoggingDestination>(\n      logging::LOG_TO_SYSTEM_DEBUG_LOG);\n  log_settings.log_file = nullptr;\n  logging::InitLogging(log_settings);\n  logging::SetLogItems(false /* enable_process_id */,\n                       false /* enable_thread_id */,\n                       false /* enable_timestamp */,\n                       false /* enable_tickcount */);\n}\n\n}  // namespace chromeos_update_engine",
        "b_contents": "//\n// Copyright (C) 2020 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n#include <inttypes.h>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n#include <algorithm>\n#include <string>\n#include <vector>\n\n#include <base/files/dir_reader_posix.h>\n#include <base/logging.h>\n#include <base/strings/string_util.h>\n#include <base/strings/stringprintf.h>\n\n#include \"update_engine/common/utils.h\"\n\nusing std::string;\n\nnamespace chromeos_update_engine {\nnamespace {\n\nconstexpr char kSystemLogsRoot[] = \"/data/misc/update_engine_log\";\nconstexpr size_t kLogCount = 5;\n\n// Keep the most recent |kLogCount| logs but remove the old ones in\n// \"/data/misc/update_engine_log/\".\nvoid DeleteOldLogs(const string& kLogsRoot) {\n  base::DirReaderPosix reader(kLogsRoot.c_str());\n  if (!reader.IsValid()) {\n    LOG(ERROR) << \"Failed to read \" << kLogsRoot;\n    return;\n  }\n\n  std::vector<string> old_logs;\n  while (reader.Next()) {\n    if (reader.name()[0] == '.')\n      continue;\n\n    // Log files are in format \"update_engine.%Y%m%d-%H%M%S\",\n    // e.g. update_engine.20090103-231425\n    uint64_t date;\n    uint64_t local_time;\n    if (sscanf(reader.name(),\n               \"update_engine.%\" PRIu64 \"-%\" PRIu64 \"\",\n               &date,\n               &local_time) == 2) {\n      old_logs.push_back(reader.name());\n    } else {\n      LOG(WARNING) << \"Unrecognized log file \" << reader.name();\n    }\n  }\n\n  std::sort(old_logs.begin(), old_logs.end(), std::greater<string>());\n  for (size_t i = kLogCount; i < old_logs.size(); i++) {\n    string log_path = kLogsRoot + \"/\" + old_logs[i];\n    if (unlink(log_path.c_str()) == -1) {\n      PLOG(WARNING) << \"Failed to unlink \" << log_path;\n    }\n  }\n}\n\nstring SetupLogFile(const string& kLogsRoot) {\n  DeleteOldLogs(kLogsRoot);\n\n  return base::StringPrintf(\"%s/update_engine.%s\",\n                            kLogsRoot.c_str(),\n                            utils::GetTimeAsString(::time(nullptr)).c_str());\n}\n\n}  // namespace\n\nvoid SetupLogging(bool log_to_system, bool log_to_file) {\n  logging::LoggingSettings log_settings;\n  log_settings.lock_log = logging::DONT_LOCK_LOG_FILE;\n  log_settings.logging_dest = static_cast<logging::LoggingDestination>(\n      (log_to_system ? logging::LOG_TO_SYSTEM_DEBUG_LOG : 0) |\n      (log_to_file ? logging::LOG_TO_FILE : 0));\n  log_settings.log_file = nullptr;\n\n  string log_file;\n  if (log_to_file) {\n    log_file = SetupLogFile(kSystemLogsRoot);\n    log_settings.delete_old = logging::APPEND_TO_OLD_LOG_FILE;\n    log_settings.log_file = log_file.c_str();\n  }\n  logging::InitLogging(log_settings);\n\n  // The log file will have AID_LOG as group ID; this GID is inherited from the\n  // parent directory \"/data/misc/update_engine_log\" which sets the SGID bit.\n  chmod(log_file.c_str(), 0640);\n}\n\n}  // namespace chromeos_update_engine",
        "base_contents": "",
        "res_region": "//\n// Copyright (C) 2020 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n#include <inttypes.h>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include <string>\n#include <string_view>\n#include <vector>\n\n#include <android-base/file.h>\n#include <android-base/strings.h>\n#include <android-base/unique_fd.h>\n#include <base/files/dir_reader_posix.h>\n#include <base/logging.h>\n#include <base/strings/string_util.h>\n#include <base/strings/stringprintf.h>\n#include <log/log.h>\n\n#include \"update_engine/common/utils.h\"\n\nusing std::string;\n\nnamespace chromeos_update_engine {\nnamespace {\n\nconstexpr char kSystemLogsRoot[] = \"/data/misc/update_engine_log\";\nconstexpr size_t kLogCount = 5;\n\n// Keep the most recent |kLogCount| logs but remove the old ones in\n// \"/data/misc/update_engine_log/\".\nvoid DeleteOldLogs(const string& kLogsRoot) {\n  base::DirReaderPosix reader(kLogsRoot.c_str());\n  if (!reader.IsValid()) {\n    LOG(ERROR) << \"Failed to read \" << kLogsRoot;\n    return;\n  }\n\n  std::vector<string> old_logs;\n  while (reader.Next()) {\n    if (reader.name()[0] == '.')\n      continue;\n\n    // Log files are in format \"update_engine.%Y%m%d-%H%M%S\",\n    // e.g. update_engine.20090103-231425\n    uint64_t date;\n    uint64_t local_time;\n    if (sscanf(reader.name(),\n               \"update_engine.%\" PRIu64 \"-%\" PRIu64 \"\",\n               &date,\n               &local_time) == 2) {\n      old_logs.push_back(reader.name());\n    } else {\n      LOG(WARNING) << \"Unrecognized log file \" << reader.name();\n    }\n  }\n\n  std::sort(old_logs.begin(), old_logs.end(), std::greater<string>());\n  for (size_t i = kLogCount; i < old_logs.size(); i++) {\n    string log_path = kLogsRoot + \"/\" + old_logs[i];\n    if (unlink(log_path.c_str()) == -1) {\n      PLOG(WARNING) << \"Failed to unlink \" << log_path;\n    }\n  }\n}\n\nstring SetupLogFile(const string& kLogsRoot) {\n  DeleteOldLogs(kLogsRoot);\n\n  return base::StringPrintf(\"%s/update_engine.%s\",\n                            kLogsRoot.c_str(),\n                            utils::GetTimeAsString(::time(nullptr)).c_str());\n}\n\nconst char* LogPriorityToCString(int priority) {\n  switch (priority) {\n    case ANDROID_LOG_VERBOSE:\n      return \"VERBOSE\";\n    case ANDROID_LOG_DEBUG:\n      return \"DEBUG\";\n    case ANDROID_LOG_INFO:\n      return \"INFO\";\n    case ANDROID_LOG_WARN:\n      return \"WARN\";\n    case ANDROID_LOG_ERROR:\n      return \"ERROR\";\n    case ANDROID_LOG_FATAL:\n      return \"FATAL\";\n    default:\n      return \"UNKNOWN\";\n  }\n}\n\nusing LoggerFunction = std::function<void(const struct __android_logger_data*,\n                                          const char* message)>;\n\nclass FileLogger {\n public:\n  explicit FileLogger(const string& path) {\n    fd_.reset(TEMP_FAILURE_RETRY(\n        open(path.c_str(),\n             O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC | O_NOFOLLOW | O_SYNC,\n             0644)));\n    if (fd_ == -1) {\n      // Use ALOGE that logs to logd before __android_log_set_logger.\n      ALOGE(\"Cannot open persistent log %s: %s\", path.c_str(), strerror(errno));\n      return;\n    }\n    // The log file will have AID_LOG as group ID; this GID is inherited from\n    // the parent directory \"/data/misc/update_engine_log\" which sets the SGID\n    // bit.\n    if (fchmod(fd_.get(), 0640) == -1) {\n      // Use ALOGE that logs to logd before __android_log_set_logger.\n      ALOGE(\"Cannot chmod 0640 persistent log %s: %s\",\n            path.c_str(),\n            strerror(errno));\n      return;\n    }\n  }\n  // Copy-constructor needed to be converted to std::function.\n  FileLogger(const FileLogger& other) { fd_.reset(dup(other.fd_)); }\n  void operator()(const struct __android_logger_data* logger_data,\n                  const char* message) {\n    if (fd_ == -1) {\n      return;\n    }\n\n    // libchrome add a newline character to |message|. Strip it.\n    std::string_view message_no_newline = message != nullptr ? message : \"\";\n    ignore_result(android::base::ConsumeSuffix(&message_no_newline, \"\\n\"));\n\n    WriteToFd(GetPrefix(logger_data));\n    WriteToFd(message_no_newline);\n    WriteToFd(\"\\n\");\n  }\n\n private:\n  android::base::unique_fd fd_;\n  void WriteToFd(std::string_view message) {\n    ignore_result(\n        android::base::WriteFully(fd_, message.data(), message.size()));\n  }\n\n  string GetPrefix(const struct __android_logger_data* logger_data) {\n    std::stringstream ss;\n    timeval tv;\n    gettimeofday(&tv, nullptr);\n    time_t t = tv.tv_sec;\n    struct tm local_time;\n    localtime_r(&t, &local_time);\n    struct tm* tm_time = &local_time;\n    ss << \"[\" << std::setfill('0') << std::setw(2) << 1 + tm_time->tm_mon\n       << std::setw(2) << tm_time->tm_mday << '/' << std::setw(2)\n       << tm_time->tm_hour << std::setw(2) << tm_time->tm_min << std::setw(2)\n       << tm_time->tm_sec << '.' << std::setw(6) << tv.tv_usec << \"] \";\n    // libchrome logs prepends |message| with severity, file and line, but\n    // leave logger_data->file as nullptr.\n    // libbase / liblog logs doesn't. Hence, add them to match the style.\n    // For liblog logs that doesn't set logger_data->file, not printing the\n    // priority is acceptable.\n    if (logger_data->file) {\n      ss << \"[\" << LogPriorityToCString(logger_data->priority) << ':'\n         << logger_data->file << '(' << logger_data->line << \")] \";\n    }\n    return ss.str();\n  }\n};\n\nclass CombinedLogger {\n public:\n  CombinedLogger(bool log_to_system, bool log_to_file) {\n    if (log_to_system) {\n      loggers_.push_back(__android_log_logd_logger);\n    }\n    if (log_to_file) {\n      loggers_.push_back(std::move(FileLogger(SetupLogFile(kSystemLogsRoot))));\n    }\n  }\n  void operator()(const struct __android_logger_data* logger_data,\n                  const char* message) {\n    for (auto&& logger : loggers_) {\n      logger(logger_data, message != nullptr ? message : \"\");\n    }\n  }\n\n private:\n  std::vector<LoggerFunction> loggers_;\n};\n\n}  // namespace\n\nvoid SetupLogging(bool log_to_system, bool log_to_file) {\n  // Note that libchrome logging uses liblog.\n  // By calling liblog's __android_log_set_logger function, all of libchrome\n  // (used by update_engine) / libbase / liblog (used by depended modules)\n  // logging eventually redirects to CombinedLogger.\n  static auto g_logger =\n      std::make_unique<CombinedLogger>(log_to_system, log_to_file);\n  __android_log_set_logger(\n      [](const struct __android_logger_data* logger_data, const char* message) {\n        (*g_logger)(logger_data, message);\n      });\n\n  // libchrome logging should not log to file.\n  logging::LoggingSettings log_settings;\n  log_settings.lock_log = logging::DONT_LOCK_LOG_FILE;\n  log_settings.logging_dest = static_cast<logging::LoggingDestination>(\n      logging::LOG_TO_SYSTEM_DEBUG_LOG);\n  log_settings.log_file = nullptr;\n  logging::InitLogging(log_settings);\n  logging::SetLogItems(false /* enable_process_id */,\n                       false /* enable_thread_id */,\n                       false /* enable_timestamp */,\n                       false /* enable_tickcount */);\n}\n\n}  // namespace chromeos_update_engine",
        "lookback": "// Copyright (C) 2020 The Android Open Source Project",
        "lookahead": "",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 0,
        "end_line": 347,
        "merge_gen_region": null,
        "confidence": 0.8529403805732727,
        "hesitated": true
    }
]