[
    {
        "a_contents": "",
        "b_contents": "  if (manifest_.has_old_rootfs_info() || manifest_.has_new_rootfs_info() ||\n      manifest_.has_old_kernel_info() || manifest_.has_new_kernel_info() ||\n      manifest_.install_operations_size() != 0 ||\n      manifest_.kernel_install_operations_size() != 0) {\n    LOG(ERROR) << \"Manifest contains deprecated fields.\";\n    return ErrorCode::kPayloadMismatchedType;\n  }\n  ErrorCode error_code = CheckTimestampError();\n  if (error_code != ErrorCode::kSuccess) {\n    if (error_code == ErrorCode::kPayloadTimestampError) {\n      if (!hardware_->AllowDowngrade()) {\n        return ErrorCode::kPayloadTimestampError;\n      }\n      LOG(INFO) << \"The current OS build allows downgrade, continuing to apply\"\n                   \" the payload with an older timestamp.\";\n    } else {\n      LOG(ERROR) << \"Timestamp check returned \"\n                 << utils::ErrorCodeToString(error_code);\n      return error_code;\n    }\n  }\n\n  // TODO(crbug.com/37661) we should be adding more and more manifest checks,\n  // such as partition boundaries, etc.\n\n  return ErrorCode::kSuccess;\n}\n\nErrorCode DeltaPerformer::CheckTimestampError() const {\n  bool is_partial_update =\n      manifest_.has_partial_update() && manifest_.partial_update();\n  const auto& partitions = manifest_.partitions();\n\n  // Check version field for a given PartitionUpdate object. If an error\n  // is encountered, set |error_code| accordingly. If downgrade is detected,\n  // |downgrade_detected| is set. Return true if the program should continue to\n  // check the next partition or not, or false if it should exit early due to\n  // errors.\n  auto&& timestamp_valid = [this](const PartitionUpdate& partition,\n                                  bool allow_empty_version,\n                                  bool* downgrade_detected) -> ErrorCode {\n    if (!partition.has_version()) {\n      if (allow_empty_version) {\n        return ErrorCode::kSuccess;\n      }\n      LOG(ERROR)\n          << \"PartitionUpdate \" << partition.partition_name()\n          << \" does ot have a version field. Not allowed in partial updates.\";\n      return ErrorCode::kDownloadManifestParseError;\n    }\n\n    auto error_code = hardware_->IsPartitionUpdateValid(\n        partition.partition_name(), partition.version());\n    switch (error_code) {\n      case ErrorCode::kSuccess:\n        break;\n      case ErrorCode::kPayloadTimestampError:\n        *downgrade_detected = true;\n        LOG(WARNING) << \"PartitionUpdate \" << partition.partition_name()\n                     << \" has an older version than partition on device.\";\n        break;\n      default:\n        LOG(ERROR) << \"IsPartitionUpdateValid(\" << partition.partition_name()\n                   << \") returned\" << utils::ErrorCodeToString(error_code);\n        break;\n    }\n    return error_code;\n  };\n\n  bool downgrade_detected = false;\n\n  if (is_partial_update) {\n    // for partial updates, all partition MUST have valid timestamps\n    // But max_timestamp can be empty\n    for (const auto& partition : partitions) {\n      auto error_code = timestamp_valid(\n          partition, false /* allow_empty_version */, &downgrade_detected);\n      if (error_code != ErrorCode::kSuccess &&\n          error_code != ErrorCode::kPayloadTimestampError) {\n        return error_code;\n      }\n    }\n    if (downgrade_detected) {\n      return ErrorCode::kPayloadTimestampError;\n    }\n    return ErrorCode::kSuccess;\n  }\n\n  // For non-partial updates, check max_timestamp first.",
        "base_contents": "  if (manifest_.has_old_rootfs_info() || manifest_.has_new_rootfs_info() ||\n      manifest_.has_old_kernel_info() || manifest_.has_new_kernel_info() ||\n      manifest_.install_operations_size() != 0 ||\n      manifest_.kernel_install_operations_size() != 0) {\n    LOG(ERROR) << \"Manifest contains deprecated fields.\";\n    return ErrorCode::kPayloadMismatchedType;\n  }\n",
        "res_region": "  ErrorCode error_code = CheckTimestampError();\n  if (error_code != ErrorCode::kSuccess) {\n    if (error_code == ErrorCode::kPayloadTimestampError) {\n      if (!hardware_->AllowDowngrade()) {\n        return ErrorCode::kPayloadTimestampError;\n      }\n      LOG(INFO) << \"The current OS build allows downgrade, continuing to apply\"\n                   \" the payload with an older timestamp.\";\n    } else {\n      LOG(ERROR) << \"Timestamp check returned \"\n                 << utils::ErrorCodeToString(error_code);\n      return error_code;\n    }\n  }\n\n  // TODO(crbug.com/37661) we should be adding more and more manifest checks,\n  // such as partition boundaries, etc.\n\n  return ErrorCode::kSuccess;\n}\n\nErrorCode DeltaPerformer::CheckTimestampError() const {\n  bool is_partial_update =\n      manifest_.has_partial_update() && manifest_.partial_update();\n  const auto& partitions = manifest_.partitions();\n\n  // Check version field for a given PartitionUpdate object. If an error\n  // is encountered, set |error_code| accordingly. If downgrade is detected,\n  // |downgrade_detected| is set. Return true if the program should continue to\n  // check the next partition or not, or false if it should exit early due to\n  // errors.\n  auto&& timestamp_valid = [this](const PartitionUpdate& partition,\n                                  bool allow_empty_version,\n                                  bool* downgrade_detected) -> ErrorCode {\n    if (!partition.has_version()) {\n      if (allow_empty_version) {\n        return ErrorCode::kSuccess;\n      }\n      LOG(ERROR)\n          << \"PartitionUpdate \" << partition.partition_name()\n          << \" does ot have a version field. Not allowed in partial updates.\";\n      return ErrorCode::kDownloadManifestParseError;\n    }\n\n    auto error_code = hardware_->IsPartitionUpdateValid(\n        partition.partition_name(), partition.version());\n    switch (error_code) {\n      case ErrorCode::kSuccess:\n        break;\n      case ErrorCode::kPayloadTimestampError:\n        *downgrade_detected = true;\n        LOG(WARNING) << \"PartitionUpdate \" << partition.partition_name()\n                     << \" has an older version than partition on device.\";\n        break;\n      default:\n        LOG(ERROR) << \"IsPartitionUpdateValid(\" << partition.partition_name()\n                   << \") returned\" << utils::ErrorCodeToString(error_code);\n        break;\n    }\n    return error_code;\n  };\n\n  bool downgrade_detected = false;\n\n  if (is_partial_update) {\n    // for partial updates, all partition MUST have valid timestamps\n    // But max_timestamp can be empty\n    for (const auto& partition : partitions) {\n      auto error_code = timestamp_valid(\n          partition, false /* allow_empty_version */, &downgrade_detected);\n      if (error_code != ErrorCode::kSuccess &&\n          error_code != ErrorCode::kPayloadTimestampError) {\n        return error_code;\n      }\n    }\n    if (downgrade_detected) {\n      return ErrorCode::kPayloadTimestampError;\n    }\n    return ErrorCode::kSuccess;\n  }\n\n  // For non-partial updates, check max_timestamp first.",
        "lookback": "  if (error_code != ErrorCode::kSuccess) {",
        "lookahead": "  if (manifest_.max_timestamp() < hardware_->GetBuildTimestamp()) {",
        "label": [
            "interleave",
            "one_side_deletion"
        ],
        "start_line": 1625,
        "end_line": 1725,
        "merge_gen_region": null,
        "confidence": 0.5220492482185364,
        "hesitated": true
    }
]