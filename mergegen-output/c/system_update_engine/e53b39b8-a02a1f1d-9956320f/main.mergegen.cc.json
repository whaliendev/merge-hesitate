[
    {
        "a_contents": "namespace chromeos_update_engine {\nnamespace {\n\nstring GetTimeAsString(time_t utime) {\n  struct tm tm;\n  CHECK_EQ(localtime_r(&utime, &tm), &tm);\n  char str[16];\n  CHECK_EQ(strftime(str, sizeof(str), \"%Y%m%d-%H%M%S\", &tm), 15u);\n  return str;\n}\n\n#ifdef __ANDROID__\nconstexpr char kSystemLogsRoot[] = \"/data/misc/update_engine_log\";\nconstexpr size_t kLogCount = 5;\n\n// Keep the most recent |kLogCount| logs but remove the old ones in\n// \"/data/misc/update_engine_log/\".\nvoid DeleteOldLogs(const string& kLogsRoot) {\n  base::DirReaderPosix reader(kLogsRoot.c_str());\n  if (!reader.IsValid()) {\n    LOG(ERROR) << \"Failed to read \" << kLogsRoot;\n    return;\n  }\n\n  std::vector<string> old_logs;\n  while (reader.Next()) {\n    if (reader.name()[0] == '.')\n      continue;\n\n    // Log files are in format \"update_engine.%Y%m%d-%H%M%S\",\n    // e.g. update_engine.20090103-231425\n    uint64_t date;\n    uint64_t local_time;\n    if (sscanf(reader.name(),\n               \"update_engine.%\" PRIu64 \"-%\" PRIu64 \"\",\n               &date,\n               &local_time) == 2) {\n      old_logs.push_back(reader.name());\n    } else {\n      LOG(WARNING) << \"Unrecognized log file \" << reader.name();\n    }\n  }\n\n  std::sort(old_logs.begin(), old_logs.end(), std::greater<string>());\n  for (size_t i = kLogCount; i < old_logs.size(); i++) {\n    string log_path = kLogsRoot + \"/\" + old_logs[i];\n    if (unlink(log_path.c_str()) == -1) {\n      PLOG(WARNING) << \"Failed to unlink \" << log_path;\n    }\n  }\n}\n\nstring SetupLogFile(const string& kLogsRoot) {\n  DeleteOldLogs(kLogsRoot);\n\n  return base::StringPrintf(\"%s/update_engine.%s\",\n                            kLogsRoot.c_str(),\n                            GetTimeAsString(::time(nullptr)).c_str());\n}\n#else\nconstexpr char kSystemLogsRoot[] = \"/var/log\";\n\nvoid SetupLogSymlink(const string& symlink_path, const string& log_path) {\n  // TODO(petkov): To ensure a smooth transition between non-timestamped and\n  // timestamped logs, move an existing log to start the first timestamped\n  // one. This code can go away once all clients are switched to this version or\n  // we stop caring about the old-style logs.\n  if (utils::FileExists(symlink_path.c_str()) &&\n      !utils::IsSymlink(symlink_path.c_str())) {\n    base::ReplaceFile(\n        base::FilePath(symlink_path), base::FilePath(log_path), nullptr);\n  }\n  base::DeleteFile(base::FilePath(symlink_path), true);\n  if (symlink(log_path.c_str(), symlink_path.c_str()) == -1) {\n    PLOG(ERROR) << \"Unable to create symlink \" << symlink_path\n                << \" pointing at \" << log_path;\n  }\n}\n\nstring SetupLogFile(const string& kLogsRoot) {\n  const string kLogSymlink = kLogsRoot + \"/update_engine.log\";\n  const string kLogsDir = kLogsRoot + \"/update_engine\";\n  const string kLogPath =\n      base::StringPrintf(\"%s/update_engine.%s\",\n                         kLogsDir.c_str(),\n                         GetTimeAsString(::time(nullptr)).c_str());\n  mkdir(kLogsDir.c_str(), 0755);\n  SetupLogSymlink(kLogSymlink, kLogPath);\n  return kLogSymlink;\n}\n#endif  // __ANDROID__\n\nvoid SetupLogging(bool log_to_system, bool log_to_file) {\n  logging::LoggingSettings log_settings;\n  log_settings.lock_log = logging::DONT_LOCK_LOG_FILE;\n  log_settings.logging_dest = static_cast<logging::LoggingDestination>(\n      (log_to_system ? logging::LOG_TO_SYSTEM_DEBUG_LOG : 0) |\n      (log_to_file ? logging::LOG_TO_FILE : 0));\n  log_settings.log_file = nullptr;\n\n  string log_file;\n  if (log_to_file) {\n    log_file = SetupLogFile(kSystemLogsRoot);\n    log_settings.delete_old = logging::APPEND_TO_OLD_LOG_FILE;\n#if BASE_VER < 780000\n    log_settings.log_file = log_file.c_str();\n#else\n    log_settings.log_file_path = log_file.c_str();\n#endif\n  }\n  logging::InitLogging(log_settings);\n\n#ifdef __ANDROID__\n  // The log file will have AID_LOG as group ID; this GID is inherited from the\n  // parent directory \"/data/misc/update_engine_log\" which sets the SGID bit.\n  chmod(log_file.c_str(), 0640);\n#endif\n}\n\n}  // namespace\n}  // namespace chromeos_update_engine\n",
        "b_contents": "",
        "base_contents": "namespace chromeos_update_engine {\nnamespace {\n\nstring GetTimeAsString(time_t utime) {\n  struct tm tm;\n  CHECK_EQ(localtime_r(&utime, &tm), &tm);\n  char str[16];\n  CHECK_EQ(strftime(str, sizeof(str), \"%Y%m%d-%H%M%S\", &tm), 15u);\n  return str;\n}\n\n#ifdef __ANDROID__\nconstexpr char kSystemLogsRoot[] = \"/data/misc/update_engine_log\";\nconstexpr size_t kLogCount = 5;\n\n// Keep the most recent |kLogCount| logs but remove the old ones in\n// \"/data/misc/update_engine_log/\".\nvoid DeleteOldLogs(const string& kLogsRoot) {\n  base::DirReaderPosix reader(kLogsRoot.c_str());\n  if (!reader.IsValid()) {\n    LOG(ERROR) << \"Failed to read \" << kLogsRoot;\n    return;\n  }\n\n  std::vector<string> old_logs;\n  while (reader.Next()) {\n    if (reader.name()[0] == '.')\n      continue;\n\n    // Log files are in format \"update_engine.%Y%m%d-%H%M%S\",\n    // e.g. update_engine.20090103-231425\n    uint64_t date;\n    uint64_t local_time;\n    if (sscanf(reader.name(),\n               \"update_engine.%\" PRIu64 \"-%\" PRIu64 \"\",\n               &date,\n               &local_time) == 2) {\n      old_logs.push_back(reader.name());\n    } else {\n      LOG(WARNING) << \"Unrecognized log file \" << reader.name();\n    }\n  }\n\n  std::sort(old_logs.begin(), old_logs.end(), std::greater<string>());\n  for (size_t i = kLogCount; i < old_logs.size(); i++) {\n    string log_path = kLogsRoot + \"/\" + old_logs[i];\n    if (unlink(log_path.c_str()) == -1) {\n      PLOG(WARNING) << \"Failed to unlink \" << log_path;\n    }\n  }\n}\n\nstring SetupLogFile(const string& kLogsRoot) {\n  DeleteOldLogs(kLogsRoot);\n\n  return base::StringPrintf(\"%s/update_engine.%s\",\n                            kLogsRoot.c_str(),\n                            GetTimeAsString(::time(nullptr)).c_str());\n}\n#else\nconstexpr char kSystemLogsRoot[] = \"/var/log\";\n\nvoid SetupLogSymlink(const string& symlink_path, const string& log_path) {\n  // TODO(petkov): To ensure a smooth transition between non-timestamped and\n  // timestamped logs, move an existing log to start the first timestamped\n  // one. This code can go away once all clients are switched to this version or\n  // we stop caring about the old-style logs.\n  if (utils::FileExists(symlink_path.c_str()) &&\n      !utils::IsSymlink(symlink_path.c_str())) {\n    base::ReplaceFile(\n        base::FilePath(symlink_path), base::FilePath(log_path), nullptr);\n  }\n  base::DeleteFile(base::FilePath(symlink_path), true);\n  if (symlink(log_path.c_str(), symlink_path.c_str()) == -1) {\n    PLOG(ERROR) << \"Unable to create symlink \" << symlink_path\n                << \" pointing at \" << log_path;\n  }\n}\n\nstring SetupLogFile(const string& kLogsRoot) {\n  const string kLogSymlink = kLogsRoot + \"/update_engine.log\";\n  const string kLogsDir = kLogsRoot + \"/update_engine\";\n  const string kLogPath =\n      base::StringPrintf(\"%s/update_engine.%s\",\n                         kLogsDir.c_str(),\n                         GetTimeAsString(::time(nullptr)).c_str());\n  mkdir(kLogsDir.c_str(), 0755);\n  SetupLogSymlink(kLogSymlink, kLogPath);\n  return kLogSymlink;\n}\n#endif  // __ANDROID__\n\nvoid SetupLogging(bool log_to_system, bool log_to_file) {\n  logging::LoggingSettings log_settings;\n  log_settings.lock_log = logging::DONT_LOCK_LOG_FILE;\n  log_settings.logging_dest = static_cast<logging::LoggingDestination>(\n      (log_to_system ? logging::LOG_TO_SYSTEM_DEBUG_LOG : 0) |\n      (log_to_file ? logging::LOG_TO_FILE : 0));\n  log_settings.log_file = nullptr;\n\n  string log_file;\n  if (log_to_file) {\n    log_file = SetupLogFile(kSystemLogsRoot);\n    log_settings.delete_old = logging::APPEND_TO_OLD_LOG_FILE;\n    log_settings.log_file = log_file.c_str();\n  }\n  logging::InitLogging(log_settings);\n\n#ifdef __ANDROID__\n  // The log file will have AID_LOG as group ID; this GID is inherited from the\n  // parent directory \"/data/misc/update_engine_log\" which sets the SGID bit.\n  chmod(log_file.c_str(), 0640);\n#endif\n}\n\n}  // namespace\n}  // namespace chromeos_update_engine\n",
        "res_region": "",
        "lookback": "  DEFINE_bool(logtofile, false, \"Write logs to a file in log_dir.\");",
        "lookahead": "int main(int argc, char** argv) {",
        "label": [
            "base",
            "base_empty"
        ],
        "start_line": 33,
        "end_line": 276,
        "merge_gen_region": null,
        "confidence": 0.4837035834789276,
        "hesitated": true
    }
]