[
    {
        "a_contents": "/**\n * Rx Testing with various length payloads of zeros\n */\nTEST_P(TransportTests, RxPayloadOfZeros) {\n  mTransportContext.rxStatus.state = CHPP_STATE_PREAMBLE;\n  size_t len = static_cast<size_t>(GetParam());\n  bool isLenValid = (len <= chppTransportRxMtuSize(&mTransportContext));\n\n  mTransportContext.txStatus.hasPacketsToSend = true;\n  std::thread t1(chppWorkThreadStart, &mTransportContext);\n  WaitForTransport(&mTransportContext);\n\n  if (len <= kMaxChunkSize) {\n    size_t loc = 0;\n    addPreambleToBuf(mBuf, &loc);\n    ChppTransportHeader *transHeader = addTransportHeaderToBuf(mBuf, &loc);\n\n    transHeader->length = static_cast<uint16_t>(len);\n    loc += len;\n\n    addTransportFooterToBuf(mBuf, &loc);\n\n    // Send header and check for correct state\n    EXPECT_EQ(\n        chppRxDataCb(&mTransportContext, mBuf,\n                     CHPP_PREAMBLE_LEN_BYTES + sizeof(ChppTransportHeader)),\n        !isLenValid);\n\n    if (!isLenValid) {\n      EXPECT_EQ(mTransportContext.rxStatus.state, CHPP_STATE_PREAMBLE);\n    } else if (len > 0) {\n      EXPECT_EQ(mTransportContext.rxStatus.state, CHPP_STATE_PAYLOAD);\n    } else {\n      EXPECT_EQ(mTransportContext.rxStatus.state, CHPP_STATE_FOOTER);\n    }\n\n    // Correct decoding of packet length\n    EXPECT_EQ(mTransportContext.rxHeader.length, len);\n    EXPECT_EQ(mTransportContext.rxStatus.locInDatagram, 0);\n    EXPECT_EQ(mTransportContext.rxDatagram.length, isLenValid ? len : 0);\n\n    // Send payload if any and check for correct state\n    if (len > 0) {\n      EXPECT_EQ(\n          chppRxDataCb(\n              &mTransportContext,\n              &mBuf[CHPP_PREAMBLE_LEN_BYTES + sizeof(ChppTransportHeader)],\n              len),\n          !isLenValid);\n      EXPECT_EQ(mTransportContext.rxStatus.state,\n                isLenValid ? CHPP_STATE_FOOTER : CHPP_STATE_PREAMBLE);\n    }\n\n    // Should have complete packet payload by now\n    EXPECT_EQ(mTransportContext.rxStatus.locInDatagram, isLenValid ? len : 0);\n\n    // But no ACK yet\n    EXPECT_EQ(mTransportContext.rxStatus.expectedSeq, transHeader->seq);\n\n    // Send footer\n    EXPECT_TRUE(chppRxDataCb(\n        &mTransportContext,\n        &mBuf[CHPP_PREAMBLE_LEN_BYTES + sizeof(ChppTransportHeader) + len],\n        sizeof(ChppTransportFooter)));\n\n    // The next expected packet sequence # should incremented only if the\n    // received packet is payload-bearing.\n    uint8_t nextSeq = transHeader->seq + ((isLenValid && len > 0) ? 1 : 0);\n    EXPECT_EQ(mTransportContext.rxStatus.expectedSeq, nextSeq);\n\n    // Check for correct ACK crafting if applicable (i.e. if the received packet\n    // is payload-bearing).\n    if (isLenValid && len > 0) {\n      EXPECT_EQ(mTransportContext.txStatus.packetCodeToSend,\n                CHPP_TRANSPORT_ERROR_NONE);\n      EXPECT_EQ(mTransportContext.txDatagramQueue.pending, 0);\n\n      WaitForTransport(&mTransportContext);\n\n      // Check response packet fields\n      struct ChppTransportHeader *txHeader =\n          (struct ChppTransportHeader *)&gChppLinuxLinkContext\n              .buf[CHPP_PREAMBLE_LEN_BYTES];\n      EXPECT_EQ(txHeader->flags, CHPP_TRANSPORT_FLAG_FINISHED_DATAGRAM);\n      EXPECT_EQ(txHeader->packetCode, CHPP_TRANSPORT_ERROR_NONE);\n      EXPECT_EQ(txHeader->ackSeq, nextSeq);\n      EXPECT_EQ(txHeader->length, 0);\n\n      // Check outgoing packet length\n      EXPECT_EQ(mTransportContext.linkBufferSize,\n                CHPP_PREAMBLE_LEN_BYTES + sizeof(struct ChppTransportHeader) +\n                    sizeof(struct ChppTransportFooter));\n    }\n\n    // Check for correct state\n    EXPECT_EQ(mTransportContext.rxStatus.state, CHPP_STATE_PREAMBLE);\n\n    // Should have reset loc and length for next packet / datagram\n    EXPECT_EQ(mTransportContext.rxStatus.locInDatagram, 0);\n    EXPECT_EQ(mTransportContext.rxDatagram.length, 0);\n  }\n\n  chppWorkThreadStop(&mTransportContext);\n  t1.join();\n}",
        "b_contents": "// Disabled because flaky (fixed in U).\n// /**\n//  * Rx Testing with various length payloads of zeros\n//  */\n// TEST_P(TransportTests, RxPayloadOfZeros) {\n//   mTransportContext.rxStatus.state = CHPP_STATE_PREAMBLE;\n//   size_t len = static_cast<size_t>(GetParam());\n//   bool validLen = (len <= CHPP_TRANSPORT_RX_MTU_BYTES);\n\n//   mTransportContext.txStatus.hasPacketsToSend = true;\n//   std::thread t1(chppWorkThreadStart, &mTransportContext);\n//   WaitForTransport(&mTransportContext);\n\n//   if (len <= kMaxChunkSize) {\n//     size_t loc = 0;\n//     addPreambleToBuf(mBuf, &loc);\n//     ChppTransportHeader *transHeader = addTransportHeaderToBuf(mBuf, &loc);\n\n//     transHeader->length = static_cast<uint16_t>(len);\n//     loc += len;\n\n//     addTransportFooterToBuf(mBuf, &loc);\n\n//     // Send header and check for correct state\n//     EXPECT_EQ(\n//         chppRxDataCb(&mTransportContext, mBuf,\n//                      CHPP_PREAMBLE_LEN_BYTES + sizeof(ChppTransportHeader)),\n//         !validLen);\n\n//     if (!validLen) {\n//       EXPECT_EQ(mTransportContext.rxStatus.state, CHPP_STATE_PREAMBLE);\n//     } else if (len > 0) {\n//       EXPECT_EQ(mTransportContext.rxStatus.state, CHPP_STATE_PAYLOAD);\n//     } else {\n//       EXPECT_EQ(mTransportContext.rxStatus.state, CHPP_STATE_FOOTER);\n//     }\n\n//     // Correct decoding of packet length\n//     EXPECT_EQ(mTransportContext.rxHeader.length, len);\n//     EXPECT_EQ(mTransportContext.rxStatus.locInDatagram, 0);\n//     EXPECT_EQ(mTransportContext.rxDatagram.length, validLen ? len : 0);\n\n//     // Send payload if any and check for correct state\n//     if (len > 0) {\n//       EXPECT_EQ(\n//           chppRxDataCb(\n//               &mTransportContext,\n//               &mBuf[CHPP_PREAMBLE_LEN_BYTES + sizeof(ChppTransportHeader)],\n//               len),\n//           !validLen);\n//       EXPECT_EQ(mTransportContext.rxStatus.state,\n//                 validLen ? CHPP_STATE_FOOTER : CHPP_STATE_PREAMBLE);\n//     }\n\n//     // Should have complete packet payload by now\n//     EXPECT_EQ(mTransportContext.rxStatus.locInDatagram, validLen ? len : 0);\n\n//     // But no ACK yet\n//     EXPECT_EQ(mTransportContext.rxStatus.expectedSeq, transHeader->seq);\n\n//     // Send footer\n//     EXPECT_TRUE(chppRxDataCb(\n//         &mTransportContext,\n//         &mBuf[CHPP_PREAMBLE_LEN_BYTES + sizeof(ChppTransportHeader) + len],\n//         sizeof(ChppTransportFooter)));\n\n//     // The next expected packet sequence # should incremented only if the\n//     // received packet is payload-bearing.\n//     uint8_t nextSeq = transHeader->seq + ((validLen && len > 0) ? 1 : 0);\n//     EXPECT_EQ(mTransportContext.rxStatus.expectedSeq, nextSeq);\n\n//     // Check for correct ACK crafting if applicable (i.e. if the received\n//     packet\n//     // is payload-bearing).\n//     if (validLen && len > 0) {\n//       // TODO: Remove later as can cause flaky tests\n//       // These are expected to change shortly afterwards, as\n//       chppTransportDoWork\n//       // is run\n//       // EXPECT_TRUE(mTransportContext.txStatus.hasPacketsToSend);\n//       EXPECT_EQ(mTransportContext.txStatus.packetCodeToSend,\n//                 CHPP_TRANSPORT_ERROR_NONE);\n//       EXPECT_EQ(mTransportContext.txDatagramQueue.pending, 0);\n\n//       WaitForTransport(&mTransportContext);\n\n//       // Check response packet fields\n//       struct ChppTransportHeader *txHeader =\n//           (struct ChppTransportHeader *)&mTransportContext.pendingTxPacket\n//               .payload[CHPP_PREAMBLE_LEN_BYTES];\n//       EXPECT_EQ(txHeader->flags, CHPP_TRANSPORT_FLAG_FINISHED_DATAGRAM);\n//       EXPECT_EQ(txHeader->packetCode, CHPP_TRANSPORT_ERROR_NONE);\n//       EXPECT_EQ(txHeader->ackSeq, nextSeq);\n//       EXPECT_EQ(txHeader->length, 0);\n\n//       // Check outgoing packet length\n//       EXPECT_EQ(mTransportContext.pendingTxPacket.length,\n//                 CHPP_PREAMBLE_LEN_BYTES + sizeof(struct ChppTransportHeader)\n//                 +\n//                     sizeof(struct ChppTransportFooter));\n//     }\n\n//     // Check for correct state\n//     EXPECT_EQ(mTransportContext.rxStatus.state, CHPP_STATE_PREAMBLE);\n\n//     // Should have reset loc and length for next packet / datagram\n//     EXPECT_EQ(mTransportContext.rxStatus.locInDatagram, 0);\n//     EXPECT_EQ(mTransportContext.rxDatagram.length, 0);\n//   }\n\n//   chppWorkThreadStop(&mTransportContext);\n//   t1.join();\n// }",
        "base_contents": "/**\n * Rx Testing with various length payloads of zeros\n */\nTEST_P(TransportTests, RxPayloadOfZeros) {\n  mTransportContext.rxStatus.state = CHPP_STATE_PREAMBLE;\n  size_t len = static_cast<size_t>(GetParam());\n  bool validLen = (len <= CHPP_TRANSPORT_RX_MTU_BYTES);\n\n  mTransportContext.txStatus.hasPacketsToSend = true;\n  std::thread t1(chppWorkThreadStart, &mTransportContext);\n  WaitForTransport(&mTransportContext);\n\n  if (len <= kMaxChunkSize) {\n    size_t loc = 0;\n    addPreambleToBuf(mBuf, &loc);\n    ChppTransportHeader *transHeader = addTransportHeaderToBuf(mBuf, &loc);\n\n    transHeader->length = static_cast<uint16_t>(len);\n    loc += len;\n\n    addTransportFooterToBuf(mBuf, &loc);\n\n    // Send header and check for correct state\n    EXPECT_EQ(\n        chppRxDataCb(&mTransportContext, mBuf,\n                     CHPP_PREAMBLE_LEN_BYTES + sizeof(ChppTransportHeader)),\n        !validLen);\n\n    if (!validLen) {\n      EXPECT_EQ(mTransportContext.rxStatus.state, CHPP_STATE_PREAMBLE);\n    } else if (len > 0) {\n      EXPECT_EQ(mTransportContext.rxStatus.state, CHPP_STATE_PAYLOAD);\n    } else {\n      EXPECT_EQ(mTransportContext.rxStatus.state, CHPP_STATE_FOOTER);\n    }\n\n    // Correct decoding of packet length\n    EXPECT_EQ(mTransportContext.rxHeader.length, len);\n    EXPECT_EQ(mTransportContext.rxStatus.locInDatagram, 0);\n    EXPECT_EQ(mTransportContext.rxDatagram.length, validLen ? len : 0);\n\n    // Send payload if any and check for correct state\n    if (len > 0) {\n      EXPECT_EQ(\n          chppRxDataCb(\n              &mTransportContext,\n              &mBuf[CHPP_PREAMBLE_LEN_BYTES + sizeof(ChppTransportHeader)],\n              len),\n          !validLen);\n      EXPECT_EQ(mTransportContext.rxStatus.state,\n                validLen ? CHPP_STATE_FOOTER : CHPP_STATE_PREAMBLE);\n    }\n\n    // Should have complete packet payload by now\n    EXPECT_EQ(mTransportContext.rxStatus.locInDatagram, validLen ? len : 0);\n\n    // But no ACK yet\n    EXPECT_EQ(mTransportContext.rxStatus.expectedSeq, transHeader->seq);\n\n    // Send footer\n    EXPECT_TRUE(chppRxDataCb(\n        &mTransportContext,\n        &mBuf[CHPP_PREAMBLE_LEN_BYTES + sizeof(ChppTransportHeader) + len],\n        sizeof(ChppTransportFooter)));\n\n    // The next expected packet sequence # should incremented only if the\n    // received packet is payload-bearing.\n    uint8_t nextSeq = transHeader->seq + ((validLen && len > 0) ? 1 : 0);\n    EXPECT_EQ(mTransportContext.rxStatus.expectedSeq, nextSeq);\n\n    // Check for correct ACK crafting if applicable (i.e. if the received packet\n    // is payload-bearing).\n    if (validLen && len > 0) {\n      // TODO: Remove later as can cause flaky tests\n      // These are expected to change shortly afterwards, as chppTransportDoWork\n      // is run\n      // EXPECT_TRUE(mTransportContext.txStatus.hasPacketsToSend);\n      EXPECT_EQ(mTransportContext.txStatus.packetCodeToSend,\n                CHPP_TRANSPORT_ERROR_NONE);\n      EXPECT_EQ(mTransportContext.txDatagramQueue.pending, 0);\n\n      WaitForTransport(&mTransportContext);\n\n      // Check response packet fields\n      struct ChppTransportHeader *txHeader =\n          (struct ChppTransportHeader *)&mTransportContext.pendingTxPacket\n              .payload[CHPP_PREAMBLE_LEN_BYTES];\n      EXPECT_EQ(txHeader->flags, CHPP_TRANSPORT_FLAG_FINISHED_DATAGRAM);\n      EXPECT_EQ(txHeader->packetCode, CHPP_TRANSPORT_ERROR_NONE);\n      EXPECT_EQ(txHeader->ackSeq, nextSeq);\n      EXPECT_EQ(txHeader->length, 0);\n\n      // Check outgoing packet length\n      EXPECT_EQ(mTransportContext.pendingTxPacket.length,\n                CHPP_PREAMBLE_LEN_BYTES + sizeof(struct ChppTransportHeader) +\n                    sizeof(struct ChppTransportFooter));\n    }\n\n    // Check for correct state\n    EXPECT_EQ(mTransportContext.rxStatus.state, CHPP_STATE_PREAMBLE);\n\n    // Should have reset loc and length for next packet / datagram\n    EXPECT_EQ(mTransportContext.rxStatus.locInDatagram, 0);\n    EXPECT_EQ(mTransportContext.rxDatagram.length, 0);\n  }\n\n  chppWorkThreadStop(&mTransportContext);\n  t1.join();\n}",
        "res_region": "/**\n * Rx Testing with various length payloads of zeros\n */\nTEST_P(TransportTests, RxPayloadOfZeros) {\n  mTransportContext.rxStatus.state = CHPP_STATE_PREAMBLE;\n  size_t len = static_cast<size_t>(GetParam());\n  bool isLenValid = (len <= chppTransportRxMtuSize(&mTransportContext));\n\n  mTransportContext.txStatus.hasPacketsToSend = true;\n  std::thread t1(chppWorkThreadStart, &mTransportContext);\n  WaitForTransport(&mTransportContext);\n\n  if (len <= kMaxChunkSize) {\n    size_t loc = 0;\n    addPreambleToBuf(mBuf, &loc);\n    ChppTransportHeader *transHeader = addTransportHeaderToBuf(mBuf, &loc);\n\n    transHeader->length = static_cast<uint16_t>(len);\n    loc += len;\n\n    addTransportFooterToBuf(mBuf, &loc);\n\n    // Send header and check for correct state\n    EXPECT_EQ(\n        chppRxDataCb(&mTransportContext, mBuf,\n                     CHPP_PREAMBLE_LEN_BYTES + sizeof(ChppTransportHeader)),\n        !isLenValid);\n\n    if (!isLenValid) {\n      EXPECT_EQ(mTransportContext.rxStatus.state, CHPP_STATE_PREAMBLE);\n    } else if (len > 0) {\n      EXPECT_EQ(mTransportContext.rxStatus.state, CHPP_STATE_PAYLOAD);\n    } else {\n      EXPECT_EQ(mTransportContext.rxStatus.state, CHPP_STATE_FOOTER);\n    }\n\n    // Correct decoding of packet length\n    EXPECT_EQ(mTransportContext.rxHeader.length, len);\n    EXPECT_EQ(mTransportContext.rxStatus.locInDatagram, 0);\n    EXPECT_EQ(mTransportContext.rxDatagram.length, isLenValid ? len : 0);\n\n    // Send payload if any and check for correct state\n    if (len > 0) {\n      EXPECT_EQ(\n          chppRxDataCb(\n              &mTransportContext,\n              &mBuf[CHPP_PREAMBLE_LEN_BYTES + sizeof(ChppTransportHeader)],\n              len),\n          !isLenValid);\n      EXPECT_EQ(mTransportContext.rxStatus.state,\n                isLenValid ? CHPP_STATE_FOOTER : CHPP_STATE_PREAMBLE);\n    }\n\n    // Should have complete packet payload by now\n    EXPECT_EQ(mTransportContext.rxStatus.locInDatagram, isLenValid ? len : 0);\n\n    // But no ACK yet\n    EXPECT_EQ(mTransportContext.rxStatus.expectedSeq, transHeader->seq);\n\n    // Send footer\n    EXPECT_TRUE(chppRxDataCb(\n        &mTransportContext,\n        &mBuf[CHPP_PREAMBLE_LEN_BYTES + sizeof(ChppTransportHeader) + len],\n        sizeof(ChppTransportFooter)));\n\n    // The next expected packet sequence # should incremented only if the\n    // received packet is payload-bearing.\n    uint8_t nextSeq = transHeader->seq + ((isLenValid && len > 0) ? 1 : 0);\n    EXPECT_EQ(mTransportContext.rxStatus.expectedSeq, nextSeq);\n\n    // Check for correct ACK crafting if applicable (i.e. if the received packet\n    // is payload-bearing).\n    if (isLenValid && len > 0) {\n      EXPECT_EQ(mTransportContext.txStatus.packetCodeToSend,\n                CHPP_TRANSPORT_ERROR_NONE);\n      EXPECT_EQ(mTransportContext.txDatagramQueue.pending, 0);\n\n      WaitForTransport(&mTransportContext);\n\n      // Check response packet fields\n      struct ChppTransportHeader *txHeader =\n          (struct ChppTransportHeader *)&gChppLinuxLinkContext\n              .buf[CHPP_PREAMBLE_LEN_BYTES];\n      EXPECT_EQ(txHeader->flags, CHPP_TRANSPORT_FLAG_FINISHED_DATAGRAM);\n      EXPECT_EQ(txHeader->packetCode, CHPP_TRANSPORT_ERROR_NONE);\n      EXPECT_EQ(txHeader->ackSeq, nextSeq);\n      EXPECT_EQ(txHeader->length, 0);\n\n      // Check outgoing packet length\n      EXPECT_EQ(mTransportContext.linkBufferSize,\n                CHPP_PREAMBLE_LEN_BYTES + sizeof(struct ChppTransportHeader) +\n                    sizeof(struct ChppTransportFooter));\n    }\n\n    // Check for correct state\n    EXPECT_EQ(mTransportContext.rxStatus.state, CHPP_STATE_PREAMBLE);\n\n    // Should have reset loc and length for next packet / datagram\n    EXPECT_EQ(mTransportContext.rxStatus.locInDatagram, 0);\n    EXPECT_EQ(mTransportContext.rxDatagram.length, 0);\n  }\n\n  chppWorkThreadStop(&mTransportContext);\n  t1.join();\n}",
        "lookback": " * Rx Testing with various length payloads of zeros",
        "lookahead": "",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 386,
        "end_line": 716,
        "merge_gen_region": " Rx with length payload of// becauseakyfixed U // // Rx with length payload of// becauseakyfixed U // // * Testing various payload of // // TESTPTransport,PayloadZeros { mContextrx.Statusstate CH___; sizet = staticcastsizetGetParam // isValid ( <=ppRxtu(&Transport));TransportContexttx.hassTo =; stdthread1chWorkStart &Transport); WaitFor(&Transport);Context // ( <=Chunk) //_t =; addeambleBufm,loc // // ChTransport *Headertrans =TransportTo(Bufm,loc); trans-> = static staticcastuint_>(); loc len; addFTo(m,loc); // Send and for state EXPECTEQ //_( chRxData(&Transport,Buf //PPPREAMBLELENBYTES sizeofChTransportHeader //isValid // // (!Len) // EXPECTEQmContextrx.,PPSTATEPREAMBLE // else ( >) //_(TransportContextrx., CH___); } else ( >) //_(Transport.Statusstate CH___); } else // EXPECTEQmContextrx.,PPSTATEFO); } // Cor decoding packet // EXPECTEQmContextrx.Headerlength len);",
        "confidence": 0.9786704182624817,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "  // Validate capabilities\n  uint32_t *capabilities = (uint32_t *)&gChppLinuxLinkContext.buf[responseLoc];\n  responseLoc += sizeof(uint32_t);",
        "b_contents": "//   // Validate capabilities\n//   uint32_t *capabilities =\n//       (uint32_t *)&mTransportContext.pendingTxPacket.payload[responseLoc];\n//   responseLoc += sizeof(uint32_t);",
        "base_contents": "  // Validate capabilities\n  uint32_t *capabilities =\n      (uint32_t *)&mTransportContext.pendingTxPacket.payload[responseLoc];\n  responseLoc += sizeof(uint32_t);",
        "res_region": "  // Validate capabilities\n  uint32_t *capabilities = (uint32_t *)&gChppLinuxLinkContext.buf[responseLoc];\n  responseLoc += sizeof(uint32_t);",
        "lookback": "  uint32_t *capabilities = (uint32_t *)&gChppLinuxLinkContext.buf[responseLoc];",
        "lookahead": "",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 1165,
        "end_line": 1179,
        "merge_gen_region": null,
        "confidence": 0.7885169386863708,
        "hesitated": true
    }
]