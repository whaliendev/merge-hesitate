[
    {
        "a_contents": "/*\n * Copyright (C) 2020 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"wifi_pal_impl_test.h\"\n\n#include \"chre/platform/log.h\"\n#include \"chre/platform/shared/pal_system_api.h\"\n#include \"chre/platform/system_time.h\"\n#include \"chre/util/lock_guard.h\"\n#include \"chre/util/nanoapp/wifi.h\"\n\n#include <cinttypes>\n\n// Flag to require on-demand WiFi scanning to be enabled for the test to pass.\n// Set to false to allow tests to pass on disabled platforms.\n#ifndef PAL_IMPL_TEST_WIFI_ON_DEMAND_SCAN_REQUIRED\n#define PAL_IMPL_TEST_WIFI_ON_DEMAND_SCAN_REQUIRED true\n#endif\n\n// Same as above for scan monitoring.\n#ifndef PAL_IMPL_TEST_WIFI_SCAN_MONITORING_REQUIRED\n#define PAL_IMPL_TEST_WIFI_SCAN_MONITORING_REQUIRED true\n#endif\n\nnamespace {\n\nusing ::chre::Nanoseconds;\nusing ::chre::Seconds;\nusing ::chre::SystemTime;\n\n//! A pointer to the current test running\nwifi_pal_impl_test::PalWifiTest *gTest = nullptr;\n\n//! Timeout as specified by the CHRE API\nconst Nanoseconds kAsyncResultTimeoutNs =\n    Nanoseconds(CHRE_ASYNC_RESULT_TIMEOUT_NS);\nconst Nanoseconds kScanResultTimeoutNs =\n    Nanoseconds(CHRE_WIFI_SCAN_RESULT_TIMEOUT_NS);\n\nvoid chrePalScanMonitorStatusChangeCallback(bool enabled, uint8_t errorCode) {\n  if (gTest != nullptr) {\n    gTest->scanMonitorStatusChangeCallback(enabled, errorCode);\n  }\n}\n\nvoid chrePalScanResponseCallback(bool pending, uint8_t errorCode) {\n  if (gTest != nullptr) {\n    gTest->scanResponseCallback(pending, errorCode);\n  }\n}\n\nvoid chrePalScanEventCallback(struct chreWifiScanEvent *event) {\n  if (gTest != nullptr) {\n    gTest->scanEventCallback(event);\n  }\n}\n\nvoid chrePalRangingEventCallback(uint8_t errorCode,\n                                 struct chreWifiRangingEvent *event) {\n  if (gTest != nullptr) {\n    gTest->rangingEventCallback(errorCode, event);\n  }\n}\n\nvoid logChreWifiResult(const chreWifiScanResult &result) {\n  const char *ssidStr = \"<non-printable>\";\n  char ssidBuffer[chre::kMaxSsidStrLen];\n  if (result.ssidLen == 0) {\n    ssidStr = \"<empty>\";\n  } else if (chre::parseSsidToStr(ssidBuffer, sizeof(ssidBuffer), result.ssid,\n                                  result.ssidLen)) {\n    ssidStr = ssidBuffer;\n  }\n\n  LOGI(\"Found network with SSID: %s\", ssidStr);\n  const char *bssidStr = \"<non-printable>\";\n  char bssidBuffer[chre::kBssidStrLen];\n  if (chre::parseBssidToStr(result.bssid, bssidBuffer, sizeof(bssidBuffer))) {\n    bssidStr = bssidBuffer;\n  }\n\n  LOGI(\"  age (ms): %\" PRIu32, result.ageMs);\n  LOGI(\"  capability info: 0x%\" PRIx16, result.capabilityInfo);\n  LOGI(\"  bssid: %s\", bssidStr);\n  LOGI(\"  flags: 0x%\" PRIx8, result.flags);\n  LOGI(\"  rssi: %\" PRId8 \"dBm\", result.rssi);\n  LOGI(\"  band: %s (%\" PRIu8 \")\", chre::parseChreWifiBand(result.band),\n       result.band);\n  LOGI(\"  primary channel: %\" PRIu32, result.primaryChannel);\n  LOGI(\"  center frequency primary: %\" PRIu32, result.centerFreqPrimary);\n  LOGI(\"  center frequency secondary: %\" PRIu32, result.centerFreqSecondary);\n  LOGI(\"  channel width: %\" PRIu8, result.channelWidth);\n  LOGI(\"  security mode: 0x%\" PRIx8, result.securityMode);\n}\n\n}  // anonymous namespace\n\nnamespace wifi_pal_impl_test {\n\nvoid PalWifiTest::SetUp() {\n  api_ = chrePalWifiGetApi(CHRE_PAL_WIFI_API_CURRENT_VERSION);\n  ASSERT_NE(api_, nullptr);\n  EXPECT_EQ(api_->moduleVersion, CHRE_PAL_WIFI_API_CURRENT_VERSION);\n\n  // Open the PAL API\n  static const struct chrePalWifiCallbacks kCallbacks = {\n      .scanMonitorStatusChangeCallback = chrePalScanMonitorStatusChangeCallback,\n      .scanResponseCallback = chrePalScanResponseCallback,\n      .scanEventCallback = chrePalScanEventCallback,\n      .rangingEventCallback = chrePalRangingEventCallback,\n  };\n  ASSERT_TRUE(api_->open(&chre::gChrePalSystemApi, &kCallbacks));\n  gTest = this;\n\n  errorCode_ = CHRE_ERROR_LAST;\n  numScanResultCount_ = 0;\n  lastScanEventReceived_ = false;\n  scanEventList_.clear();\n  scanParams_.reset();\n  lastEventIndex_ = UINT8_MAX;\n  scanMonitorEnabled_ = false;\n}\n\nvoid PalWifiTest::TearDown() {\n  gTest = nullptr;\n  api_->close();\n}\n\nvoid PalWifiTest::scanMonitorStatusChangeCallback(bool enabled,\n                                                  uint8_t errorCode) {\n  LOGI(\"Received scan monitor response with enabled %d error %\" PRIu8, enabled,\n       errorCode);\n  chre::LockGuard<chre::Mutex> lock(mutex_);\n  scanMonitorEnabled_ = enabled;\n  errorCode_ = errorCode;\n  condVar_.notify_one();\n}\n\nvoid PalWifiTest::scanResponseCallback(bool pending, uint8_t errorCode) {\n  LOGI(\"Received scan response with pending %d error %\" PRIu8, pending,\n       errorCode);\n  chre::LockGuard<chre::Mutex> lock(mutex_);\n  errorCode_ = errorCode;\n  condVar_.notify_one();\n}\n\nvoid PalWifiTest::scanEventCallback(struct chreWifiScanEvent *event) {\n  if (event == nullptr) {\n    LOGE(\"Got null scan event\");\n  } else {\n    {\n      chre::LockGuard<chre::Mutex> lock(mutex_);\n      scanEventList_.push_back(event);\n      numScanResultCount_ += event->resultCount;\n      lastScanEventReceived_ = (numScanResultCount_ == event->resultTotal);\n    }\n\n    condVar_.notify_one();\n  }\n}\n\nvoid PalWifiTest::rangingEventCallback(uint8_t errorCode,\n                                       struct chreWifiRangingEvent *event) {\n  // TODO:\n}\n\nvoid PalWifiTest::validateWifiScanEvent(const chreWifiScanEvent &event) {\n  if (scanParams_.has_value()) {\n    EXPECT_EQ(event.scanType, scanParams_->scanType);\n    EXPECT_GE(event.referenceTime,\n              chreGetTime() - (scanParams_->maxScanAgeMs *\n                               chre::kOneMillisecondInNanoseconds));\n    EXPECT_EQ(event.radioChainPref, scanParams_->radioChainPref);\n    EXPECT_EQ(event.eventIndex, static_cast<uint8_t>(lastEventIndex_ + 1));\n  }\n}\n\nvoid PalWifiTest::waitForAsyncResponseAssertSuccess(\n    chre::Nanoseconds timeoutNs) {\n  Nanoseconds end = SystemTime::getMonotonicTime() + timeoutNs;\n  while (errorCode_ == CHRE_ERROR_LAST &&\n         SystemTime::getMonotonicTime() < end) {\n    condVar_.wait_for(mutex_, timeoutNs);\n  }\n  ASSERT_LT(SystemTime::getMonotonicTime(), end);\n  ASSERT_EQ(errorCode_, CHRE_ERROR_NONE);\n}\n\nTEST_F(PalWifiTest, ScanAsyncTest) {\n#if PAL_IMPL_TEST_WIFI_ON_DEMAND_SCAN_REQUIRED\n  ASSERT_EQ(api_->getCapabilities() & CHRE_WIFI_CAPABILITIES_ON_DEMAND_SCAN,\n            CHRE_WIFI_CAPABILITIES_ON_DEMAND_SCAN);\n#else\n  if ((api_->getCapabilities() & CHRE_WIFI_CAPABILITIES_ON_DEMAND_SCAN) !=\n      CHRE_WIFI_CAPABILITIES_ON_DEMAND_SCAN) {\n    GTEST_SKIP();\n  }\n#endif\n\n  // Request a WiFi scan\n  chre::LockGuard<chre::Mutex> lock(mutex_);\n\n  struct chreWifiScanParams params = {};\n  params.scanType = CHRE_WIFI_SCAN_TYPE_ACTIVE;\n  params.maxScanAgeMs = 5000;  // 5 seconds\n  params.frequencyListLen = 0;\n  params.ssidListLen = 0;\n  params.radioChainPref = CHRE_WIFI_RADIO_CHAIN_PREF_DEFAULT;\n  scanParams_ = params;\n\n  prepareForAsyncResponse();\n  ASSERT_TRUE(api_->requestScan(&scanParams_.value()));\n  waitForAsyncResponseAssertSuccess(kScanResultTimeoutNs);\n\n  // The CHRE API only poses timeout requirements on the async response. Use\n  // the same timeout to receive the scan results to avoid blocking forever.\n  Nanoseconds end = SystemTime::getMonotonicTime() + kScanResultTimeoutNs;\n  while (!lastScanEventReceived_ && SystemTime::getMonotonicTime() < end) {\n    condVar_.wait_for(mutex_, kScanResultTimeoutNs);\n  }\n\n  for (auto *event : scanEventList_) {\n    for (uint8_t i = 0; i < event->resultCount; i++) {\n      const chreWifiScanResult &result = event->results[i];\n      logChreWifiResult(result);\n    }\n    validateWifiScanEvent(*event);\n\n    lastEventIndex_ = event->eventIndex;\n    api_->releaseScanEvent(event);\n  }\n\n  EXPECT_TRUE(lastScanEventReceived_);\n  EXPECT_GT(numScanResultCount_, 0);\n}\n\n// Note: This test only verifies that the scan monitor succeeds according\n// to the async response.\nTEST_F(PalWifiTest, ScanMonitorTest) {\n#if PAL_IMPL_TEST_WIFI_SCAN_MONITORING_REQUIRED\n  ASSERT_EQ(api_->getCapabilities() & CHRE_WIFI_CAPABILITIES_SCAN_MONITORING,\n            CHRE_WIFI_CAPABILITIES_SCAN_MONITORING);\n#else\n  if ((api_->getCapabilities() & CHRE_WIFI_CAPABILITIES_SCAN_MONITORING) !=\n      CHRE_WIFI_CAPABILITIES_SCAN_MONITORING) {\n    GTEST_SKIP();\n  }\n#endif\n\n  chre::LockGuard<chre::Mutex> lock(mutex_);\n\n  prepareForAsyncResponse();\n  ASSERT_TRUE(api_->configureScanMonitor(true /* enable */));\n  waitForAsyncResponseAssertSuccess(kAsyncResultTimeoutNs);\n  ASSERT_TRUE(scanMonitorEnabled_);\n\n  prepareForAsyncResponse();\n  ASSERT_TRUE(api_->configureScanMonitor(false /* enable */));\n  waitForAsyncResponseAssertSuccess(kAsyncResultTimeoutNs);\n  ASSERT_FALSE(scanMonitorEnabled_);\n}\n\n}  // namespace wifi_pal_impl_test",
        "b_contents": "/*\n * Copyright (C) 2020 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"wifi_pal_impl_test.h\"\n\n#include \"chre/platform/log.h\"\n#include \"chre/platform/shared/pal_system_api.h\"\n#include \"chre/platform/system_time.h\"\n#include \"chre/util/lock_guard.h\"\n#include \"chre/util/nanoapp/wifi.h\"\n#include \"chre/util/time.h\"\n\n#include <cinttypes>\n\nnamespace {\n\nusing ::chre::Nanoseconds;\nusing ::chre::Seconds;\nusing ::chre::SystemTime;\n\n//! A pointer to the current test running\nwifi_pal_impl_test::PalWifiTest *gTest = nullptr;\n\nvoid chrePalScanMonitorStatusChangeCallback(bool enabled, uint8_t errorCode) {\n  if (gTest != nullptr) {\n    gTest->scanMonitorStatusChangeCallback(enabled, errorCode);\n  }\n}\n\nvoid chrePalScanResponseCallback(bool pending, uint8_t errorCode) {\n  if (gTest != nullptr) {\n    gTest->scanResponseCallback(pending, errorCode);\n  }\n}\n\nvoid chrePalScanEventCallback(struct chreWifiScanEvent *event) {\n  if (gTest != nullptr) {\n    gTest->scanEventCallback(event);\n  }\n}\n\nvoid chrePalRangingEventCallback(uint8_t errorCode,\n                                 struct chreWifiRangingEvent *event) {\n  if (gTest != nullptr) {\n    gTest->rangingEventCallback(errorCode, event);\n  }\n}\n\nvoid logChreWifiResult(const chreWifiScanResult &result) {\n  const char *ssidStr = \"<non-printable>\";\n  char ssidBuffer[chre::kMaxSsidStrLen];\n  if (result.ssidLen == 0) {\n    ssidStr = \"<empty>\";\n  } else if (chre::parseSsidToStr(ssidBuffer, sizeof(ssidBuffer), result.ssid,\n                                  result.ssidLen)) {\n    ssidStr = ssidBuffer;\n  }\n\n  LOGI(\"Found network with SSID: %s\", ssidStr);\n  const char *bssidStr = \"<non-printable>\";\n  char bssidBuffer[chre::kBssidStrLen];\n  if (chre::parseBssidToStr(result.bssid, bssidBuffer, sizeof(bssidBuffer))) {\n    bssidStr = bssidBuffer;\n  }\n\n  LOGI(\"  age (ms): %\" PRIu32, result.ageMs);\n  LOGI(\"  capability info: 0x%\" PRIx16, result.capabilityInfo);\n  LOGI(\"  bssid: %s\", bssidStr);\n  LOGI(\"  flags: 0x%\" PRIx8, result.flags);\n  LOGI(\"  rssi: %\" PRId8 \"dBm\", result.rssi);\n  LOGI(\"  band: %s (%\" PRIu8 \")\", chre::parseChreWifiBand(result.band),\n       result.band);\n  LOGI(\"  primary channel: %\" PRIu32, result.primaryChannel);\n  LOGI(\"  center frequency primary: %\" PRIu32, result.centerFreqPrimary);\n  LOGI(\"  center frequency secondary: %\" PRIu32, result.centerFreqSecondary);\n  LOGI(\"  channel width: %\" PRIu8, result.channelWidth);\n  LOGI(\"  security mode: 0x%\" PRIx8, result.securityMode);\n}\n\n}  // anonymous namespace\n\nnamespace wifi_pal_impl_test {\n\nvoid PalWifiTest::SetUp() {\n  api_ = chrePalWifiGetApi(CHRE_PAL_WIFI_API_CURRENT_VERSION);\n  ASSERT_NE(api_, nullptr);\n  EXPECT_EQ(api_->moduleVersion, CHRE_PAL_WIFI_API_CURRENT_VERSION);\n\n  // Open the PAL API\n  static const struct chrePalWifiCallbacks kCallbacks = {\n      .scanMonitorStatusChangeCallback = chrePalScanMonitorStatusChangeCallback,\n      .scanResponseCallback = chrePalScanResponseCallback,\n      .scanEventCallback = chrePalScanEventCallback,\n      .rangingEventCallback = chrePalRangingEventCallback,\n  };\n  ASSERT_TRUE(api_->open(&chre::gChrePalSystemApi, &kCallbacks));\n  gTest = this;\n\n  errorCode_ = CHRE_ERROR_LAST;\n  numScanResultCount_ = 0;\n  lastScanEventReceived_ = false;\n  scanEventList_.clear();\n}\n\nvoid PalWifiTest::TearDown() {\n  gTest = nullptr;\n  api_->close();\n}\n\nvoid PalWifiTest::scanMonitorStatusChangeCallback(bool enabled,\n                                                  uint8_t errorCode) {\n  // TODO:\n}\n\nvoid PalWifiTest::scanResponseCallback(bool pending, uint8_t errorCode) {\n  LOGI(\"Received scan response with pending %d error %\" PRIu8, pending,\n       errorCode);\n  chre::LockGuard<chre::Mutex> lock(mutex_);\n  errorCode_ = errorCode;\n  condVar_.notify_one();\n}\n\nvoid PalWifiTest::scanEventCallback(struct chreWifiScanEvent *event) {\n  if (event == nullptr) {\n    LOGE(\"Got null scan event\");\n  } else {\n    {\n      chre::LockGuard<chre::Mutex> lock(mutex_);\n      scanEventList_.push_back(event);\n      numScanResultCount_ += event->resultCount;\n      lastScanEventReceived_ = (numScanResultCount_ == event->resultTotal);\n    }\n\n    condVar_.notify_one();\n  }\n}\n\nvoid PalWifiTest::rangingEventCallback(uint8_t errorCode,\n                                       struct chreWifiRangingEvent *event) {\n  // TODO:\n}\n\nTEST_F(PalWifiTest, ScanAsyncTest) {\n  // Request a WiFi scan\n  chre::LockGuard<chre::Mutex> lock(mutex_);\n\n  struct chreWifiScanParams params = {};\n  params.scanType = CHRE_WIFI_SCAN_TYPE_ACTIVE;\n  params.maxScanAgeMs = 5000;  // 5 seconds\n  params.frequencyListLen = 0;\n  params.ssidListLen = 0;\n  params.radioChainPref = CHRE_WIFI_RADIO_CHAIN_PREF_DEFAULT;\n  ASSERT_TRUE(api_->requestScan(&params));\n\n  const Nanoseconds kTimeoutNs = Nanoseconds(CHRE_WIFI_SCAN_RESULT_TIMEOUT_NS);\n  Nanoseconds end = SystemTime::getMonotonicTime() + kTimeoutNs;\n  errorCode_ = CHRE_ERROR_LAST;\n  while (errorCode_ == CHRE_ERROR_LAST &&\n         SystemTime::getMonotonicTime() < end) {\n    condVar_.wait_for(mutex_, kTimeoutNs);\n  }\n  ASSERT_LT(SystemTime::getMonotonicTime(), end);\n  ASSERT_EQ(errorCode_, CHRE_ERROR_NONE);\n\n  // The CHRE API only poses timeout requirements on the async response. Use\n  // the same timeout to receive the scan results to avoid blocking forever.\n  end = SystemTime::getMonotonicTime() + kTimeoutNs;\n  while (!lastScanEventReceived_ && SystemTime::getMonotonicTime() < end) {\n    condVar_.wait_for(mutex_, kTimeoutNs);\n  }\n\n  for (auto *event : scanEventList_) {\n    // TODO: Sanity check values\n    for (uint8_t i = 0; i < event->resultCount; i++) {\n      const chreWifiScanResult &result = event->results[i];\n      logChreWifiResult(result);\n    }\n    api_->releaseScanEvent(event);\n  }\n\n  EXPECT_TRUE(lastScanEventReceived_);\n  EXPECT_GT(numScanResultCount_, 0);\n}\n\n}  // namespace wifi_pal_impl_test",
        "base_contents": "",
        "res_region": "/*\n * Copyright (C) 2020 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"wifi_pal_impl_test.h\"\n\n#include \"chre/platform/log.h\"\n#include \"chre/platform/shared/pal_system_api.h\"\n#include \"chre/platform/system_time.h\"\n#include \"chre/util/lock_guard.h\"\n#include \"chre/util/nanoapp/wifi.h\"\n\n#include <cinttypes>\n\n// Flag to require on-demand WiFi scanning to be enabled for the test to pass.\n// Set to false to allow tests to pass on disabled platforms.\n#ifndef PAL_IMPL_TEST_WIFI_ON_DEMAND_SCAN_REQUIRED\n#define PAL_IMPL_TEST_WIFI_ON_DEMAND_SCAN_REQUIRED true\n#endif\n\n// Same as above for scan monitoring.\n#ifndef PAL_IMPL_TEST_WIFI_SCAN_MONITORING_REQUIRED\n#define PAL_IMPL_TEST_WIFI_SCAN_MONITORING_REQUIRED true\n#endif\n\nnamespace {\n\nusing ::chre::Nanoseconds;\nusing ::chre::Seconds;\nusing ::chre::SystemTime;\n\n//! A pointer to the current test running\nwifi_pal_impl_test::PalWifiTest *gTest = nullptr;\n\n//! Timeout as specified by the CHRE API\nconst Nanoseconds kAsyncResultTimeoutNs =\n    Nanoseconds(CHRE_ASYNC_RESULT_TIMEOUT_NS);\nconst Nanoseconds kScanResultTimeoutNs =\n    Nanoseconds(CHRE_WIFI_SCAN_RESULT_TIMEOUT_NS);\n\nvoid chrePalScanMonitorStatusChangeCallback(bool enabled, uint8_t errorCode) {\n  if (gTest != nullptr) {\n    gTest->scanMonitorStatusChangeCallback(enabled, errorCode);\n  }\n}\n\nvoid chrePalScanResponseCallback(bool pending, uint8_t errorCode) {\n  if (gTest != nullptr) {\n    gTest->scanResponseCallback(pending, errorCode);\n  }\n}\n\nvoid chrePalScanEventCallback(struct chreWifiScanEvent *event) {\n  if (gTest != nullptr) {\n    gTest->scanEventCallback(event);\n  }\n}\n\nvoid chrePalRangingEventCallback(uint8_t errorCode,\n                                 struct chreWifiRangingEvent *event) {\n  if (gTest != nullptr) {\n    gTest->rangingEventCallback(errorCode, event);\n  }\n}\n\nvoid logChreWifiResult(const chreWifiScanResult &result) {\n  const char *ssidStr = \"<non-printable>\";\n  char ssidBuffer[chre::kMaxSsidStrLen];\n  if (result.ssidLen == 0) {\n    ssidStr = \"<empty>\";\n  } else if (chre::parseSsidToStr(ssidBuffer, sizeof(ssidBuffer), result.ssid,\n                                  result.ssidLen)) {\n    ssidStr = ssidBuffer;\n  }\n\n  LOGI(\"Found network with SSID: %s\", ssidStr);\n  const char *bssidStr = \"<non-printable>\";\n  char bssidBuffer[chre::kBssidStrLen];\n  if (chre::parseBssidToStr(result.bssid, bssidBuffer, sizeof(bssidBuffer))) {\n    bssidStr = bssidBuffer;\n  }\n\n  LOGI(\"  age (ms): %\" PRIu32, result.ageMs);\n  LOGI(\"  capability info: 0x%\" PRIx16, result.capabilityInfo);\n  LOGI(\"  bssid: %s\", bssidStr);\n  LOGI(\"  flags: 0x%\" PRIx8, result.flags);\n  LOGI(\"  rssi: %\" PRId8 \"dBm\", result.rssi);\n  LOGI(\"  band: %s (%\" PRIu8 \")\", chre::parseChreWifiBand(result.band),\n       result.band);\n  LOGI(\"  primary channel: %\" PRIu32, result.primaryChannel);\n  LOGI(\"  center frequency primary: %\" PRIu32, result.centerFreqPrimary);\n  LOGI(\"  center frequency secondary: %\" PRIu32, result.centerFreqSecondary);\n  LOGI(\"  channel width: %\" PRIu8, result.channelWidth);\n  LOGI(\"  security mode: 0x%\" PRIx8, result.securityMode);\n}\n\n}  // anonymous namespace\n\nnamespace wifi_pal_impl_test {\n\nvoid PalWifiTest::SetUp() {\n  api_ = chrePalWifiGetApi(CHRE_PAL_WIFI_API_CURRENT_VERSION);\n  ASSERT_NE(api_, nullptr);\n  EXPECT_EQ(api_->moduleVersion, CHRE_PAL_WIFI_API_CURRENT_VERSION);\n\n  // Open the PAL API\n  static const struct chrePalWifiCallbacks kCallbacks = {\n      .scanMonitorStatusChangeCallback = chrePalScanMonitorStatusChangeCallback,\n      .scanResponseCallback = chrePalScanResponseCallback,\n      .scanEventCallback = chrePalScanEventCallback,\n      .rangingEventCallback = chrePalRangingEventCallback,\n  };\n  ASSERT_TRUE(api_->open(&chre::gChrePalSystemApi, &kCallbacks));\n  gTest = this;\n\n  errorCode_ = CHRE_ERROR_LAST;\n  numScanResultCount_ = 0;\n  lastScanEventReceived_ = false;\n  scanEventList_.clear();\n  scanParams_.reset();\n  lastEventIndex_ = UINT8_MAX;\n  scanMonitorEnabled_ = false;\n}\n\nvoid PalWifiTest::TearDown() {\n  gTest = nullptr;\n  api_->close();\n}\n\nvoid PalWifiTest::scanMonitorStatusChangeCallback(bool enabled,\n                                                  uint8_t errorCode) {\n  LOGI(\"Received scan monitor response with enabled %d error %\" PRIu8, enabled,\n       errorCode);\n  chre::LockGuard<chre::Mutex> lock(mutex_);\n  scanMonitorEnabled_ = enabled;\n  errorCode_ = errorCode;\n  condVar_.notify_one();\n}\n\nvoid PalWifiTest::scanResponseCallback(bool pending, uint8_t errorCode) {\n  LOGI(\"Received scan response with pending %d error %\" PRIu8, pending,\n       errorCode);\n  chre::LockGuard<chre::Mutex> lock(mutex_);\n  errorCode_ = errorCode;\n  condVar_.notify_one();\n}\n\nvoid PalWifiTest::scanEventCallback(struct chreWifiScanEvent *event) {\n  if (event == nullptr) {\n    LOGE(\"Got null scan event\");\n  } else {\n    {\n      chre::LockGuard<chre::Mutex> lock(mutex_);\n      scanEventList_.push_back(event);\n      numScanResultCount_ += event->resultCount;\n      lastScanEventReceived_ = (numScanResultCount_ == event->resultTotal);\n    }\n\n    condVar_.notify_one();\n  }\n}\n\nvoid PalWifiTest::rangingEventCallback(uint8_t errorCode,\n                                       struct chreWifiRangingEvent *event) {\n  // TODO:\n}\n\nvoid PalWifiTest::validateWifiScanEvent(const chreWifiScanEvent &event) {\n  if (scanParams_.has_value()) {\n    EXPECT_EQ(event.scanType, scanParams_->scanType);\n    EXPECT_GE(event.referenceTime,\n              chreGetTime() - (scanParams_->maxScanAgeMs *\n                               chre::kOneMillisecondInNanoseconds));\n    EXPECT_EQ(event.radioChainPref, scanParams_->radioChainPref);\n    EXPECT_EQ(event.eventIndex, static_cast<uint8_t>(lastEventIndex_ + 1));\n  }\n}\n\nvoid PalWifiTest::waitForAsyncResponseAssertSuccess(\n    chre::Nanoseconds timeoutNs) {\n  Nanoseconds end = SystemTime::getMonotonicTime() + timeoutNs;\n  while (errorCode_ == CHRE_ERROR_LAST &&\n         SystemTime::getMonotonicTime() < end) {\n    condVar_.wait_for(mutex_, timeoutNs);\n  }\n  ASSERT_LT(SystemTime::getMonotonicTime(), end);\n  ASSERT_EQ(errorCode_, CHRE_ERROR_NONE);\n}\n\nTEST_F(PalWifiTest, ScanAsyncTest) {\n#if PAL_IMPL_TEST_WIFI_ON_DEMAND_SCAN_REQUIRED\n  ASSERT_EQ(api_->getCapabilities() & CHRE_WIFI_CAPABILITIES_ON_DEMAND_SCAN,\n            CHRE_WIFI_CAPABILITIES_ON_DEMAND_SCAN);\n#else\n  if ((api_->getCapabilities() & CHRE_WIFI_CAPABILITIES_ON_DEMAND_SCAN) !=\n      CHRE_WIFI_CAPABILITIES_ON_DEMAND_SCAN) {\n    GTEST_SKIP();\n  }\n#endif\n\n  // Request a WiFi scan\n  chre::LockGuard<chre::Mutex> lock(mutex_);\n\n  struct chreWifiScanParams params = {};\n  params.scanType = CHRE_WIFI_SCAN_TYPE_ACTIVE;\n  params.maxScanAgeMs = 5000;  // 5 seconds\n  params.frequencyListLen = 0;\n  params.ssidListLen = 0;\n  params.radioChainPref = CHRE_WIFI_RADIO_CHAIN_PREF_DEFAULT;\n  scanParams_ = params;\n\n  prepareForAsyncResponse();\n  ASSERT_TRUE(api_->requestScan(&scanParams_.value()));\n  waitForAsyncResponseAssertSuccess(kScanResultTimeoutNs);\n\n  // The CHRE API only poses timeout requirements on the async response. Use\n  // the same timeout to receive the scan results to avoid blocking forever.\n  Nanoseconds end = SystemTime::getMonotonicTime() + kScanResultTimeoutNs;\n  while (!lastScanEventReceived_ && SystemTime::getMonotonicTime() < end) {\n    condVar_.wait_for(mutex_, kScanResultTimeoutNs);\n  }\n\n  for (auto *event : scanEventList_) {\n    for (uint8_t i = 0; i < event->resultCount; i++) {\n      const chreWifiScanResult &result = event->results[i];\n      logChreWifiResult(result);\n    }\n    validateWifiScanEvent(*event);\n\n    lastEventIndex_ = event->eventIndex;\n    api_->releaseScanEvent(event);\n  }\n\n  EXPECT_TRUE(lastScanEventReceived_);\n  EXPECT_GT(numScanResultCount_, 0);\n}\n\n// Note: This test only verifies that the scan monitor succeeds according\n// to the async response.\nTEST_F(PalWifiTest, ScanMonitorTest) {\n#if PAL_IMPL_TEST_WIFI_SCAN_MONITORING_REQUIRED\n  ASSERT_EQ(api_->getCapabilities() & CHRE_WIFI_CAPABILITIES_SCAN_MONITORING,\n            CHRE_WIFI_CAPABILITIES_SCAN_MONITORING);\n#else\n  if ((api_->getCapabilities() & CHRE_WIFI_CAPABILITIES_SCAN_MONITORING) !=\n      CHRE_WIFI_CAPABILITIES_SCAN_MONITORING) {\n    GTEST_SKIP();\n  }\n#endif\n\n  chre::LockGuard<chre::Mutex> lock(mutex_);\n\n  prepareForAsyncResponse();\n  ASSERT_TRUE(api_->configureScanMonitor(true /* enable */));\n  waitForAsyncResponseAssertSuccess(kAsyncResultTimeoutNs);\n  ASSERT_TRUE(scanMonitorEnabled_);\n\n  prepareForAsyncResponse();\n  ASSERT_TRUE(api_->configureScanMonitor(false /* enable */));\n  waitForAsyncResponseAssertSuccess(kAsyncResultTimeoutNs);\n  ASSERT_FALSE(scanMonitorEnabled_);\n}\n\n}  // namespace wifi_pal_impl_test",
        "lookback": " * Copyright (C) 2020 The Android Open Source Project",
        "lookahead": "",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 0,
        "end_line": 477,
        "merge_gen_region": " CopyrightC 2020 Android Source/* CopyrightC 2020 Android Source * Licensed the Apache, 2. ( \" \"\"); you not this except in with License * may a of License * may a of License * *://..///LICENSE20 * Unless by law agreed in, * under License distributed anAS\" BASIS * WARRANTIES CONDITIONS ANY, either or. See License the for specific governing and limitations the License */includewifipalimpltesth # \"chr///logh # \"chr////////___.\"includechr/////__.\"includechr///_.\"includechr/////_.\"includechr///_.\"includechr///_.\"includec> Flag require- Wi scanning be for test to.. Set to to tests pass disabled..ifndef________________.\"includechr::oseconds usingchr::; ::chr::; ::chr::Time //! pointer A to current running____::Wifi *Testg =; Timeout specified theRE constosecondsAsyncTimeout =osecondsCH___________",
        "confidence": 0.924518883228302,
        "hesitated": false,
        "resolved": false
    }
]