[
    {
        "a_contents": "",
        "b_contents": "namespace {\n\n#ifdef CHRE_SLPI_UIMG_ENABLED\n#ifndef CHREX_SENSOR_SUPPORT\n// The current implementation uses vendor sensor type 3 to remap into accel,\n// with requests made through QMI instead of QSockets, as SEE does not support\n// micro-image batching in QCM.\n#error \"CHRE extensions are required for micro-image SEE support\"\n#endif  // CHREX_SENSOR_SUPPORT\n\nbool isBigImageSensorType(SensorType sensorType) {\n  return (sensorType == SensorType::VendorType3       // accel\n          || sensorType == SensorType::VendorType6    // uncal accel\n          || sensorType == SensorType::VendorType7    // uncal gyro\n          || sensorType == SensorType::VendorType8);  // uncal mag\n}\n\n/**\n * Obtains the big-image sensor type given the specified data type and whether\n * the sensor is runtime-calibrated or not.\n */\nSensorType getBigImageSensorTypeFromDataType(const char *dataType,\n                                             bool calibrated) {\n  SensorType sensorType = SensorType::Unknown;\n  if (strcmp(dataType, \"accel\") == 0) {\n    if (calibrated) {\n      sensorType = SensorType::VendorType3;\n    } else {\n      sensorType = SensorType::VendorType6;\n    }\n  } else if (strcmp(dataType, \"gyro\") == 0 && !calibrated) {\n    sensorType = SensorType::VendorType7;\n  } else if (strcmp(dataType, \"mag\") == 0 && !calibrated) {\n    sensorType = SensorType::VendorType8;\n  }\n  return sensorType;\n}\n\n/**\n * Obtains the micro-image sensor type given the specified sensor type.\n *\n * @param sensorType The sensor type to convert from.\n * @return The associated micro-image sensor type, or the input sensor type\n *     if not associated with one\n */\nSensorType getUimgSensorType(SensorType sensorType) {\n  switch (sensorType) {\n    case SensorType::VendorType3:\n      return SensorType::Accelerometer;\n    case SensorType::VendorType6:\n      return SensorType::UncalibratedAccelerometer;\n    case SensorType::VendorType7:\n      return SensorType::UncalibratedGyroscope;\n    case SensorType::VendorType8:\n      return SensorType::UncalibratedGeomagneticField;\n    default:\n      return sensorType;\n  }\n}\n#endif  // CHRE_SLPI_UIMG_ENABLED\n\n//! A class that implements SeeHelperCallbackInterface.\nclass SeeHelperCallback : public SeeHelperCallbackInterface {\n  void onSamplingStatusUpdate(\n      UniquePtr<SeeHelperCallbackInterface::SamplingStatusData>&& status)\n      override;\n\n  void onSensorDataEvent(\n      SensorType sensorType, UniquePtr<uint8_t>&& eventData) override;\n\n  void onHostWakeSuspendEvent(bool awake) override;\n\n  void onSensorBiasEvent(UniquePtr<struct chreSensorThreeAxisData>&& biasData)\n      override;\n\n  void onFlushCompleteEvent(SensorType sensorType) override;\n};\n\n//! A struct to facilitate sensor discovery\nstruct SuidAttr {\n  sns_std_suid suid;\n  SeeAttributes attr;\n};\n\n#ifndef CHRE_VARIANT_SUPPLIES_SEE_SENSORS_LIST\n\n//! The list of SEE platform sensor data types that CHRE intends to support.\n//! The standardized strings are defined in sns_xxx.proto.\nconst char *kSeeDataTypes[] = {\n  \"accel\",\n  \"gyro\",\n  \"mag\",\n  \"pressure\",\n  \"ambient_light\",\n  \"proximity\",\n#ifdef CHRE_SLPI_DEFAULT_BUILD\n  // Both instant motion and stationary detect share the same data type.\n  \"amd\",\n  \"amd\",\n#else\n  \"motion_detect\", \"stationary_detect\",\n#endif\n};\n\n#endif  // CHRE_VARIANT_SUPPLIES_SEE_SENSORS_LIST\n\nvoid handleMissingSensor() {\n  // Try rebooting if a sensor is missing, which might help recover from a\n  // transient failure/race condition at startup. But to avoid endless crashes,\n  // only do this within 15 seconds of the timeout on initializing SEE - we rely\n  // on knowledge that getMonotonicTime() maps into QTimer here, and QTimer only\n  // resets when the entire system is rebooted (it continues increasing after\n  // SLPI SSR).\n#ifndef CHRE_LOG_ONLY_NO_SENSOR\n  if (SystemTime::getMonotonicTime() < (kDefaultSeeWaitTimeout + Seconds(15))) {\n    FATAL_ERROR(\"Missing required sensor(s)\");\n  } else\n#endif\n  {\n    LOGE(\"Missing required sensor(s)\");\n  }\n}\n\n/**\n * Obtains the sensor type given the specified data type and whether the sensor\n * is runtime-calibrated or not.\n */\nSensorType getSensorTypeFromDataType(const char *dataType, bool calibrated) {\n  SensorType sensorType;\n  if (strcmp(dataType, \"accel\") == 0) {\n    if (calibrated) {\n      sensorType = SensorType::Accelerometer;\n    } else {\n      sensorType = SensorType::UncalibratedAccelerometer;\n    }\n  } else if (strcmp(dataType, \"gyro\") == 0) {\n    if (calibrated) {\n      sensorType = SensorType::Gyroscope;\n    } else {\n      sensorType = SensorType::UncalibratedGyroscope;\n    }\n  } else if (strcmp(dataType, \"mag\") == 0) {\n    if (calibrated) {\n      sensorType = SensorType::GeomagneticField;\n    } else {\n      sensorType = SensorType::UncalibratedGeomagneticField;\n    }\n  } else if (strcmp(dataType, \"pressure\") == 0) {\n    sensorType = SensorType::Pressure;\n  } else if (strcmp(dataType, \"ambient_light\") == 0) {\n    sensorType = SensorType::Light;\n  } else if (strcmp(dataType, \"proximity\") == 0) {\n    sensorType = SensorType::Proximity;\n  } else if (strcmp(dataType, \"motion_detect\") == 0 ||\n             strcmp(dataType, \"amd\") == 0) {\n    sensorType = SensorType::InstantMotion;\n  } else if (strcmp(dataType, \"stationary_detect\") == 0) {\n    sensorType = SensorType::StationaryDetect;\n  } else if (strcmp(dataType, \"step_detect\") == 0) {\n    sensorType = SensorType::StepDetect;\n#ifdef CHREX_SENSOR_SUPPORT\n  } else if (strcmp(dataType, kVendorDataTypes[0]) == 0) {\n    sensorType = SensorType::VendorType0;\n#endif  // CHREX_SENSOR_SUPPORT\n  } else {\n    sensorType = SensorType::Unknown;\n  }\n  return sensorType;\n}\n\n/**\n * Posts a CHRE_EVENT_SENSOR_SAMPLING_CHANGE event to the specified Nanoapp.\n *\n * @param instaceId The instance ID of the nanoapp with an open request.\n * @param sensorHandle The handle of the sensor.\n * @param status A reference of the sampling status to be posted.\n */\nvoid postSamplingStatusEvent(uint32_t instanceId, uint32_t sensorHandle,\n                             const struct chreSensorSamplingStatus& status) {\n  auto *event = memoryAlloc<struct chreSensorSamplingStatusEvent>();\n  if (event == nullptr) {\n    LOG_OOM();\n  } else {\n    event->sensorHandle = sensorHandle;\n    event->status = status;\n\n    EventLoopManagerSingleton::get()->getEventLoop().postEventOrDie(\n        CHRE_EVENT_SENSOR_SAMPLING_CHANGE, event, freeEventDataCallback,\n        instanceId);\n  }\n}\n\n/**\n * Helper function to post a bias event given the bias data.\n *\n * @param sensorType The sensor type to post the event for.\n * @param bias The bias data.\n */\nvoid postSensorBiasEvent(SensorType sensorType,\n                         const chreSensorThreeAxisData& bias) {\n  uint16_t eventType;\n  if (getSensorBiasEventType(sensorType, &eventType)) {\n    auto *event = memoryAlloc<struct chreSensorThreeAxisData>();\n    if (event == nullptr) {\n      LOG_OOM();\n    } else {\n      *event = bias;\n      event->header.sensorHandle = getSensorHandleFromSensorType(sensorType);\n      EventLoopManagerSingleton::get()->getEventLoop().postEventOrDie(\n          eventType, event, freeEventDataCallback);\n    }\n  }\n}\n\n/**\n * Updates the sampling status.\n *\n * This should only be called when the new SamplingStatusData is different\n * from the most recently processed SamplingStatusData to avoid duplicate\n * updates being posted to nanoapps.\n */\nvoid updateSamplingStatus(\n    const SeeHelperCallbackInterface::SamplingStatusData& update) {\n  Sensor *sensor = EventLoopManagerSingleton::get()->getSensorRequestManager()\n      .getSensor(update.sensorType);\n  struct chreSensorSamplingStatus newStatus;\n\n  if (sensor != nullptr && !sensorTypeIsOneShot(update.sensorType)\n      && sensor->getSamplingStatus(&newStatus)) {\n    if (update.enabledValid) {\n      newStatus.enabled = update.status.enabled;\n    }\n    if (update.intervalValid) {\n      newStatus.interval = update.status.interval;\n    }\n    if (update.latencyValid) {\n      newStatus.latency = update.status.latency;\n    }\n\n    sensor->setSamplingStatus(newStatus);\n\n    // Only post to Nanoapps with an open request.\n    uint32_t sensorHandle = getSensorHandleFromSensorType(update.sensorType);\n    const DynamicVector<SensorRequest>& requests =\n        EventLoopManagerSingleton::get()->getSensorRequestManager()\n        .getRequests(update.sensorType);\n    for (const auto& req : requests) {\n      postSamplingStatusEvent(req.getInstanceId(), sensorHandle, newStatus);\n    }\n  }\n}\n\n/**\n * Compares the given status updates and returns true if they are the same.\n *\n * A simple memcmp cannot be done because if a given field is not valid, then\n * the field may be different across updates, but doesn't indicate the update\n * is different.\n */\nbool isSameStatusUpdate(\n    const SeeHelperCallbackInterface::SamplingStatusData& status1,\n    const SeeHelperCallbackInterface::SamplingStatusData& status2) {\n  bool sameStatus = status1.enabledValid == status2.enabledValid;\n  if (sameStatus && status1.enabledValid) {\n    sameStatus &= status1.status.enabled == status2.status.enabled;\n  }\n\n  // Only check interval / latency fields if both status updates say the sensor\n  // is enabled since CHRE doesn't care what the fields are set to if the sensor\n  // is disabled.\n  if (sameStatus && status1.status.enabled) {\n    sameStatus &= status1.intervalValid == status2.intervalValid;\n    if (sameStatus && status1.intervalValid) {\n      sameStatus &= status1.status.interval == status2.status.interval;\n    }\n\n    sameStatus &= status1.latencyValid == status2.latencyValid;\n    if (sameStatus && status1.latencyValid) {\n      sameStatus &= status1.status.latency == status2.status.latency;\n    }\n  }\n\n  return sameStatus;\n}\n\nvoid SeeHelperCallback::onSamplingStatusUpdate(\n    UniquePtr<SeeHelperCallbackInterface::SamplingStatusData>&& status) {\n  Sensor *sensor = EventLoopManagerSingleton::get()->getSensorRequestManager()\n      .getSensor(status->sensorType);\n\n  // TODO: Once the latency field is actually filled in by SEE, modify this\n  // logic to avoid reacting if the latency and interval of the sensor are\n  // updated separately, but contain the same info as before.\n  if (sensor != nullptr &&\n      !isSameStatusUpdate(sensor->mLastReceivedSamplingStatus, *status.get())) {\n    sensor->mLastReceivedSamplingStatus = *status.get();\n\n    auto callback = [](uint16_t /* type */, void *data) {\n      auto cbData = UniquePtr<SeeHelperCallbackInterface::SamplingStatusData>(\n          static_cast<SeeHelperCallbackInterface::SamplingStatusData *>(data));\n      updateSamplingStatus(*cbData);\n    };\n\n    // Schedule a deferred callback to handle sensor status change in the main\n    // thread.\n    EventLoopManagerSingleton::get()->deferCallback(\n        SystemCallbackType::SensorStatusUpdate, status.release(), callback);\n }\n}\n\nvoid SeeHelperCallback::onSensorDataEvent(\n    SensorType sensorType, UniquePtr<uint8_t>&& eventData) {\n  // Schedule a deferred callback to update on-change sensor's last event in\n  // the main thread.\n  if (sensorTypeIsOnChange(sensorType)) {\n    updateLastEvent(sensorType, eventData.get());\n  }\n\n  EventLoopManagerSingleton::get()->getSensorRequestManager().handleSensorEvent(\n      sensorType, eventData.get());\n  eventData.release();\n}\n\nvoid SeeHelperCallback::onHostWakeSuspendEvent(bool awake) {\n  if (EventLoopManagerSingleton::isInitialized()) {\n    EventLoopManagerSingleton::get()->getEventLoop()\n        .getPowerControlManager().onHostWakeSuspendEvent(awake);\n  }\n}\n\nvoid SeeHelperCallback::onSensorBiasEvent(\n    UniquePtr<struct chreSensorThreeAxisData>&& biasData) {\n  SensorType sensorType = getSensorTypeFromSensorHandle(\n      biasData->header.sensorHandle);\n\n  uint16_t eventType;\n  if (!sensorTypeIsCalibrated(sensorType) ||\n      !getSensorBiasEventType(sensorType, &eventType)) {\n    LOGE(\"Received bias event for unsupported sensor type %\" PRIu8, sensorType);\n  } else {\n    // Posts a newly allocated event for the uncalibrated type\n    postSensorBiasEvent(toUncalibratedSensorType(sensorType), *biasData.get());\n\n    EventLoopManagerSingleton::get()->getEventLoop().postEventOrDie(\n        eventType, biasData.release(), freeEventDataCallback);\n  }\n}\n\nvoid SeeHelperCallback::onFlushCompleteEvent(SensorType sensorType) {\n  if (EventLoopManagerSingleton::isInitialized()) {\n    EventLoopManagerSingleton::get()->getSensorRequestManager()\n        .handleFlushCompleteEvent(CHRE_ERROR_NONE, sensorType);\n  }\n}\n\n/**\n * Allocates memory and specifies the memory size for an on-change sensor to\n * store its last data event.\n *\n * @param sensorType The sensorType of this sensor.\n * @param eventSize A non-null pointer to indicate the memory size allocated.\n * @return Pointer to the memory allocated.\n */\nChreSensorData *allocateLastEvent(SensorType sensorType, size_t *eventSize) {\n  CHRE_ASSERT(eventSize);\n\n  *eventSize = 0;\n  ChreSensorData *event = nullptr;\n  if (sensorTypeIsOnChange(sensorType)) {\n    SensorSampleType sampleType = getSensorSampleTypeFromSensorType(sensorType);\n    switch (sampleType) {\n      case SensorSampleType::ThreeAxis:\n        *eventSize = sizeof(chreSensorThreeAxisData);\n        break;\n      case SensorSampleType::Float:\n        *eventSize = sizeof(chreSensorFloatData);\n        break;\n      case SensorSampleType::Byte:\n        *eventSize = sizeof(chreSensorByteData);\n        break;\n      case SensorSampleType::Occurrence:\n        *eventSize = sizeof(chreSensorOccurrenceData);\n        break;\n      default:\n        CHRE_ASSERT_LOG(false, \"Unhandled sample type\");\n        break;\n    }\n\n    event = static_cast<ChreSensorData *>(memoryAlloc(*eventSize));\n    if (event == nullptr) {\n      *eventSize = 0;\n      FATAL_ERROR(\"Failed to allocate last event memory for SensorType %\" PRIu8,\n                  static_cast<uint8_t>(sensorType));\n    }\n  }\n  return event;\n}\n\n/**\n * Constructs and initializes a sensor, and adds it to the sensor list.\n *\n * @param seeHelper SeeHelper instance to register sensor with\n * @param suid The SUID of the sensor as provided by SEE.\n * @param sensorType The sensor type of the sensor.\n * @param calibrated Whether the sensor is runtime-calibrated or not.\n * @param attr A reference to SeeAttrbutes.\n * @param sensor The sensor list.\n */\nvoid addSensor(SeeHelper& seeHelper, SensorType sensorType,\n               const sns_std_suid& suid, const SeeAttributes& attr,\n               DynamicVector<Sensor> *sensors) {\n  // Concatenate vendor and name with a space in between.\n  char sensorName[kSensorNameMaxLen];\n  strlcpy(sensorName, attr.vendor, sizeof(sensorName));\n  strlcat(sensorName, \" \", sizeof(sensorName));\n  strlcat(sensorName, attr.name, sizeof(sensorName));\n\n  // Some sensors have a max sample rate of 0 which makes ceilf return infinity\n  // for on-change or continuous sensors when that's not the correct\n  // minInterval.\n  float maxSampleRate =\n      (attr.maxSampleRate == 0.0f) ? 10 : attr.maxSampleRate;\n\n  // Override one-shot sensor's minInterval to default\n  uint64_t minInterval = sensorTypeIsOneShot(sensorType) ?\n      CHRE_SENSOR_INTERVAL_DEFAULT : static_cast<uint64_t>(\n          ceilf(Seconds(1).toRawNanoseconds() / maxSampleRate));\n\n  // Allocates memory for on-change sensor's last event.\n  size_t lastEventSize;\n  ChreSensorData *lastEvent = allocateLastEvent(sensorType, &lastEventSize);\n\n  // Constructs and initializes PlatformSensorBase.\n  Sensor sensor;\n  sensor.initBase(sensorType, minInterval, sensorName, lastEvent,\n                  lastEventSize, attr.passiveRequest);\n\n  if (!sensors->push_back(std::move(sensor))) {\n    FATAL_ERROR(\"Failed to allocate new sensor: out of memory\");\n  }\n\n  // Resample big image sensors to reduce system load during sw flush.\n#ifdef CHRE_SLPI_UIMG_ENABLED\n  bool resample = isBigImageSensorType(sensorType);\n#else\n  bool resample = false;\n#endif\n  bool prevRegistered;\n  bool registered = seeHelper.registerSensor(\n      sensorType, suid, resample, &prevRegistered);\n  if (!registered && prevRegistered) {\n    LOGW(\"SUID has been previously registered\");\n  } else if (!registered) {\n    FATAL_ERROR(\"Failed to register SUID/SensorType mapping.\");\n  }\n}\n\n/**\n * Compare SEE reported stream type attribute to the expected one. Some SEE\n * sensors may support more than one stream type.\n */\nbool isStreamTypeCorrect(SensorType sensorType, uint8_t streamType) {\n  bool success = true;\n  if ((sensorTypeIsContinuous(sensorType)\n       && streamType != SNS_STD_SENSOR_STREAM_TYPE_STREAMING)\n      || (sensorTypeIsOnChange(sensorType)\n          && streamType != SNS_STD_SENSOR_STREAM_TYPE_ON_CHANGE)\n// The default SLPI build exposes instant motion / stationary sensors as\n// on-change, but CHRE uses them as one-shot\n#ifndef CHRE_SLPI_DEFAULT_BUILD\n      || (sensorTypeIsOneShot(sensorType)\n          && streamType != SNS_STD_SENSOR_STREAM_TYPE_SINGLE_OUTPUT)\n#endif\n      ) {\n    success = false;\n    LOGW(\"Inconsistent sensor type %\" PRIu8 \" and stream type %\" PRIu8,\n         static_cast<uint8_t>(sensorType), streamType);\n  }\n  return success;\n}\n\n/**\n * Obtains the list of SUIDs and their attributes that support the specified\n * data type.\n */\nbool getSuidAndAttrs(SeeHelper& seeHelper, const char *dataType,\n                     DynamicVector<SuidAttr> *suidAttrs, uint8_t minNumSuids) {\n  DynamicVector<sns_std_suid> suids;\n  bool success = seeHelper.findSuidSync(dataType, &suids, minNumSuids);\n  if (!success) {\n    LOGE(\"Failed to find sensor '%s'\", dataType);\n  } else {\n    LOGD(\"Num of SUIDs found for '%s': %zu\", dataType, suids.size());\n\n    for (const auto& suid : suids) {\n      SeeAttributes attr;\n      if (!seeHelper.getAttributesSync(suid, &attr)) {\n        success = false;\n        LOGE(\"Failed to get attributes of SUID 0x%\" PRIx64 \" %\" PRIx64,\n             suid.suid_high, suid.suid_low);\n      } else {\n        LOGI(\"%s %s, hw id %\" PRId64 \", max ODR %f Hz, stream type %\" PRIu8\n             \" passive %d\",\n             attr.vendor, attr.name, attr.hwId, attr.maxSampleRate,\n             attr.streamType, attr.passiveRequest);\n        SuidAttr sensor = {\n          .suid = suid,\n          .attr = attr,\n        };\n        if (!suidAttrs->push_back(sensor)) {\n          success = false;\n          LOG_OOM();\n        }\n      }\n    }\n  }\n  return success;\n}\n\n#ifndef CHRE_SLPI_DEFAULT_BUILD\n//! Check whether two sensors with the specified attrtibutes belong to the same\n//! sensor hardware module.\nbool sensorHwMatch(const SeeAttributes& attr0, const SeeAttributes& attr1) {\n  // When HW ID is absent, it's default to 0 and won't be a factor.\n  return ((strncmp(attr0.vendor, attr1.vendor, kSeeAttrStrValLen) == 0)\n          && (strncmp(attr0.name, attr1.name, kSeeAttrStrValLen) == 0)\n          && (attr0.hwId == attr1.hwId));\n}\n#endif\n\n/**\n * Looks up SUID(s) associated with a given sensor data type string and sensor\n * type enum, registers them with SeeHelper, and adds a Sensor instance to the\n * supplied vector for use in CHRE. When given an uncalibrated sensor type, will\n * also look for and add the calibrated sensor type.\n *\n * @param seeHelper SeeHelper instance to use for lookup/registration\n * @param temperatureSensors List of previously discovered temperature sensor\n *        info to use for adding temp sensors associated with this sensor type\n * @param dataType SEE data type string\n * @param sensorType CHRE sensor type enum associated with dataType\n * @param skipAdditionalTypes if true, don't attempt to add\n *        calibrated/temperature sensor types associated with this sensorType\n * @param sensors Vector to append found sensor(s) to\n */\nvoid findAndAddSensorsForType(\n    SeeHelper& seeHelper, const DynamicVector<SuidAttr>& temperatureSensors,\n    const char *dataType, SensorType sensorType, bool skipAdditionalTypes,\n    DynamicVector<Sensor> *sensors) {\n  DynamicVector<SuidAttr> primarySensors;\n  if (!getSuidAndAttrs(seeHelper, dataType, &primarySensors,\n                       1 /* minNumSuids */)) {\n    handleMissingSensor();\n  }\n\n  for (const auto& primarySensor : primarySensors) {\n    sns_std_suid suid = primarySensor.suid;\n    SeeAttributes attr = primarySensor.attr;\n\n    // Some sensors support both continuous and on-change streams.\n    // If there are more than one SUIDs that support the data type,\n    // choose the first one that has the expected stream type.\n    if (isStreamTypeCorrect(sensorType, attr.streamType)) {\n      addSensor(seeHelper, sensorType, suid, attr, sensors);\n\n      if (!skipAdditionalTypes) {\n        // Check if this sensor has a runtime-calibrated version.\n        SensorType calibratedType = getSensorTypeFromDataType(\n            dataType, true /* calibrated */);\n        if (calibratedType != sensorType) {\n          addSensor(seeHelper, calibratedType, suid, attr, sensors);\n        }\n\n        // Check if this sensor has a secondary temperature sensor.\n        SensorType temperatureType = getTempSensorType(sensorType);\n        if (temperatureType != SensorType::Unknown) {\n          bool tempFound = false;\n          for (const auto& tempSensor : temperatureSensors) {\n            sns_std_suid tempSuid = tempSensor.suid;\n            SeeAttributes tempAttr = tempSensor.attr;\n\n#ifdef CHRE_SLPI_DEFAULT_BUILD\n            // The default build exposes a single temp sensor to be used for\n            // all temperature sensors that doesn't have the same attributes\n            // as the primarySensor.\n            if (true) {\n#else\n            if (sensorHwMatch(attr, tempAttr)) {\n#endif\n              LOGD(\"Found matching temperature sensor type\");\n              tempFound = true;\n              addSensor(seeHelper, temperatureType, tempSuid, tempAttr,\n                        sensors);\n              break;\n            }\n          }\n          if (!tempFound) {\n            LOGW(\"Temperature sensor type %\" PRIu8 \" not found!\",\n                 static_cast<uint8_t>(temperatureType));\n          }\n        }\n      }\n      break;\n    }\n  }\n}\n\n#ifdef CHRE_SLPI_UIMG_ENABLED\n/**\n * Registers alternate sensor(s) to be used separately by big image nanoapps.\n */\nvoid getBigImageSensors(DynamicVector<Sensor> *sensors) {\n  CHRE_ASSERT(sensors);\n\n  // Currently, just adding calibrated accel and uncal accel/gyro/mag as they\n  // are the ones we know that big image nanoapps will need at a different\n  // batching rate compared to uimg.\n  const char *kBigImageDataTypes[] = {\n    \"accel\",\n    \"gyro\",\n    \"mag\",\n  };\n\n  SeeHelper& seeHelper = *getBigImageSeeHelper();\n  DynamicVector<SuidAttr> nullTemperatureSensorList;\n\n  for (size_t i = 0; i < ARRAY_SIZE(kBigImageDataTypes); i++) {\n    const char *dataType = kBigImageDataTypes[i];\n    // Loop through potential cal/uncal sensors.\n    for (size_t j = 0; j < 2; j++) {\n      SensorType sensorType = getBigImageSensorTypeFromDataType(\n          dataType, (j == 0) /* calibrated */);\n      if (sensorType != SensorType::Unknown) {\n        findAndAddSensorsForType(\n            seeHelper, nullTemperatureSensorList, dataType, sensorType,\n            true /* skipAdditionalTypes */, sensors);\n      }\n    }\n  }\n}\n#endif  // CHRE_SLPI_UIMG_ENABLED\n\n/**\n * Helper function to retrieve the SeeHelper for a given sensor type.\n * @param sensorType the sensor type\n * @return the appropriate (bimg or uimg) SeeHelper\n */\nSeeHelper *getSeeHelperForSensorType(SensorType sensorType) {\n  SeeHelper *seeHelper = getSeeHelper();\n#ifdef CHRE_SLPI_UIMG_ENABLED\n  if (isBigImageSensorType(sensorType)) {\n    seeHelper = getBigImageSeeHelper();\n    slpiForceBigImage();\n  }\n#endif\n\n  return seeHelper;\n}\n\n\n}  // anonymous namespace\n\nPlatformSensor::~PlatformSensor() {\n  if (mLastEvent != nullptr) {\n    LOGD(\"Releasing lastEvent: sensor %s, size %zu\",\n         getSensorTypeName(getSensorType()), mLastEventSize);\n    memoryFree(mLastEvent);\n  }\n}\n\nvoid PlatformSensor::init() {\n  SeeHelperSingleton::init();\n\n  static SeeHelperCallback seeHelperCallback;\n  if (!getSeeHelper()->init(&seeHelperCallback)) {\n    FATAL_ERROR(\"Failed to initialize SEE helper\");\n  }\n\n#ifdef CHRE_SLPI_UIMG_ENABLED\n  BigImageSeeHelperSingleton::init(getSeeHelper()->getCalHelper());\n  if (!getBigImageSeeHelper()->init(&seeHelperCallback, kDefaultSeeWaitTimeout,\n                                    true /* skipDefaultSensorInit */)) {\n    FATAL_ERROR(\"Failed to init bimg SEE helper\");\n  }\n#endif  // CHRE_SLPI_UIMG_ENABLED\n}\n\nvoid PlatformSensor::deinit() {\n#ifdef CHRE_SLPI_UIMG_ENABLED\n  BigImageSeeHelperSingleton::deinit();\n#endif\n\n  SeeHelperSingleton::deinit();\n}\n\nbool PlatformSensor::getSensors(DynamicVector<Sensor> *sensors) {\n  CHRE_ASSERT(sensors);\n\n  SeeHelper& seeHelper = *getSeeHelper();\n  DynamicVector<SuidAttr> tempSensors;\n  if (!getSuidAndAttrs(seeHelper, \"sensor_temperature\", &tempSensors,\n                       CHRE_SEE_NUM_TEMP_SENSORS)) {\n    handleMissingSensor();\n  }\n\n#ifndef CHREX_SENSOR_SUPPORT\n  const char *kVendorDataTypes[] = {};\n#endif  // CHREX_SENSOR_SUPPORT\n  constexpr size_t kNumSeeTypes = ARRAY_SIZE(kSeeDataTypes);\n  constexpr size_t kNumVendorTypes = ARRAY_SIZE(kVendorDataTypes);\n  for (size_t i = 0; i < kNumSeeTypes + kNumVendorTypes; i++) {\n    const char *dataType = (i < kNumSeeTypes)\n        ? kSeeDataTypes[i] : kVendorDataTypes[i - kNumSeeTypes];\n\n    SensorType sensorType = getSensorTypeFromDataType(\n        dataType, false /* calibrated */);\n    if (sensorType == SensorType::Unknown) {\n      LOGE(\"Unknown sensor type found for '%s'\", dataType);\n      continue;\n    }\n\n    bool skipAdditionalTypes = false;\n\n#ifdef CHRE_SLPI_DEFAULT_BUILD\n    // Stationary and motion detect share the same dataType on the default build\n    if (sensorType == SensorType::InstantMotion && i == kNumSeeTypes - 1) {\n      sensorType = SensorType::StationaryDetect;\n      // Skip additional types or InstantMotion will be added to the sensor list\n      // twice.\n      skipAdditionalTypes = true;\n    }\n#endif\n\n    findAndAddSensorsForType(seeHelper, tempSensors, dataType, sensorType,\n                             skipAdditionalTypes, sensors);\n  }",
        "base_contents": "namespace {\n\n#ifdef CHRE_SLPI_UIMG_ENABLED\n#ifndef CHREX_SENSOR_SUPPORT\n// The current implementation uses vendor sensor type 3 to remap into accel,\n// with requests made through QMI instead of QSockets, as SEE does not support\n// micro-image batching in QCM.\n#error \"CHRE extensions are required for micro-image SEE support\"\n#endif  // CHREX_SENSOR_SUPPORT\n\nbool isBigImageSensorType(SensorType sensorType) {\n  return (sensorType == SensorType::VendorType3       // accel\n          || sensorType == SensorType::VendorType6    // uncal accel\n          || sensorType == SensorType::VendorType7    // uncal gyro\n          || sensorType == SensorType::VendorType8);  // uncal mag\n}\n\n/**\n * Obtains the big-image sensor type given the specified data type and whether\n * the sensor is runtime-calibrated or not.\n */\nSensorType getBigImageSensorTypeFromDataType(const char *dataType,\n                                             bool calibrated) {\n  SensorType sensorType = SensorType::Unknown;\n  if (strcmp(dataType, \"accel\") == 0) {\n    if (calibrated) {\n      sensorType = SensorType::VendorType3;\n    } else {\n      sensorType = SensorType::VendorType6;\n    }\n  } else if (strcmp(dataType, \"gyro\") == 0 && !calibrated) {\n    sensorType = SensorType::VendorType7;\n  } else if (strcmp(dataType, \"mag\") == 0 && !calibrated) {\n    sensorType = SensorType::VendorType8;\n  }\n  return sensorType;\n}\n\n/**\n * Obtains the micro-image sensor type given the specified sensor type.\n *\n * @param sensorType The sensor type to convert from.\n * @return The associated micro-image sensor type, or the input sensor type\n *     if not associated with one\n */\nSensorType getUimgSensorType(SensorType sensorType) {\n  switch (sensorType) {\n    case SensorType::VendorType3:\n      return SensorType::Accelerometer;\n    case SensorType::VendorType6:\n      return SensorType::UncalibratedAccelerometer;\n    case SensorType::VendorType7:\n      return SensorType::UncalibratedGyroscope;\n    case SensorType::VendorType8:\n      return SensorType::UncalibratedGeomagneticField;\n    default:\n      return sensorType;\n  }\n}\n#endif  // CHRE_SLPI_UIMG_ENABLED\n\n//! A class that implements SeeHelperCallbackInterface.\nclass SeeHelperCallback : public SeeHelperCallbackInterface {\n  void onSamplingStatusUpdate(\n      UniquePtr<SeeHelperCallbackInterface::SamplingStatusData>&& status)\n      override;\n\n  void onSensorDataEvent(\n      SensorType sensorType, UniquePtr<uint8_t>&& eventData) override;\n\n  void onHostWakeSuspendEvent(bool awake) override;\n\n  void onSensorBiasEvent(UniquePtr<struct chreSensorThreeAxisData>&& biasData)\n      override;\n\n  void onFlushCompleteEvent(SensorType sensorType) override;\n};\n\n//! A struct to facilitate sensor discovery\nstruct SuidAttr {\n  sns_std_suid suid;\n  SeeAttributes attr;\n};\n\n#ifndef CHRE_VARIANT_SUPPLIES_SEE_SENSORS_LIST\n\n//! The list of SEE platform sensor data types that CHRE intends to support.\n//! The standardized strings are defined in sns_xxx.proto.\nconst char *kSeeDataTypes[] = {\n  \"accel\",\n  \"gyro\",\n  \"mag\",\n  \"pressure\",\n  \"ambient_light\",\n  \"proximity\",\n  \"amd\",  // Instant motion\n  \"amd\",  // Stationary detect shares the same data type as instant motion\n};\n\n#endif  // CHRE_VARIANT_SUPPLIES_SEE_SENSORS_LIST\n\nvoid handleMissingSensor() {\n  // Try rebooting if a sensor is missing, which might help recover from a\n  // transient failure/race condition at startup. But to avoid endless crashes,\n  // only do this within 15 seconds of the timeout on initializing SEE - we rely\n  // on knowledge that getMonotonicTime() maps into QTimer here, and QTimer only\n  // resets when the entire system is rebooted (it continues increasing after\n  // SLPI SSR).\n#ifndef CHRE_LOG_ONLY_NO_SENSOR\n  if (SystemTime::getMonotonicTime() < (kDefaultSeeWaitTimeout + Seconds(15))) {\n    FATAL_ERROR(\"Missing required sensor(s)\");\n  } else\n#endif\n  {\n    LOGE(\"Missing required sensor(s)\");\n  }\n}\n\n/**\n * Obtains the sensor type given the specified data type and whether the sensor\n * is runtime-calibrated or not.\n */\nSensorType getSensorTypeFromDataType(const char *dataType, bool calibrated) {\n  SensorType sensorType;\n  if (strcmp(dataType, \"accel\") == 0) {\n    if (calibrated) {\n      sensorType = SensorType::Accelerometer;\n    } else {\n      sensorType = SensorType::UncalibratedAccelerometer;\n    }\n  } else if (strcmp(dataType, \"gyro\") == 0) {\n    if (calibrated) {\n      sensorType = SensorType::Gyroscope;\n    } else {\n      sensorType = SensorType::UncalibratedGyroscope;\n    }\n  } else if (strcmp(dataType, \"mag\") == 0) {\n    if (calibrated) {\n      sensorType = SensorType::GeomagneticField;\n    } else {\n      sensorType = SensorType::UncalibratedGeomagneticField;\n    }\n  } else if (strcmp(dataType, \"pressure\") == 0) {\n    sensorType = SensorType::Pressure;\n  } else if (strcmp(dataType, \"ambient_light\") == 0) {\n    sensorType = SensorType::Light;\n  } else if (strcmp(dataType, \"proximity\") == 0) {\n    sensorType = SensorType::Proximity;\n  } else if (strcmp(dataType, \"motion_detect\") == 0 ||\n             strcmp(dataType, \"amd\") == 0) {\n    sensorType = SensorType::InstantMotion;\n  } else if (strcmp(dataType, \"stationary_detect\") == 0) {\n    sensorType = SensorType::StationaryDetect;\n  } else if (strcmp(dataType, \"step_detect\") == 0) {\n    sensorType = SensorType::StepDetect;\n#ifdef CHREX_SENSOR_SUPPORT\n  } else if (strcmp(dataType, kVendorDataTypes[0]) == 0) {\n    sensorType = SensorType::VendorType0;\n#endif  // CHREX_SENSOR_SUPPORT\n  } else {\n    sensorType = SensorType::Unknown;\n  }\n  return sensorType;\n}\n\n/**\n * Posts a CHRE_EVENT_SENSOR_SAMPLING_CHANGE event to the specified Nanoapp.\n *\n * @param instaceId The instance ID of the nanoapp with an open request.\n * @param sensorHandle The handle of the sensor.\n * @param status A reference of the sampling status to be posted.\n */\nvoid postSamplingStatusEvent(uint32_t instanceId, uint32_t sensorHandle,\n                             const struct chreSensorSamplingStatus& status) {\n  auto *event = memoryAlloc<struct chreSensorSamplingStatusEvent>();\n  if (event == nullptr) {\n    LOG_OOM();\n  } else {\n    event->sensorHandle = sensorHandle;\n    event->status = status;\n\n    EventLoopManagerSingleton::get()->getEventLoop().postEventOrDie(\n        CHRE_EVENT_SENSOR_SAMPLING_CHANGE, event, freeEventDataCallback,\n        instanceId);\n  }\n}\n\n/**\n * Helper function to post a bias event given the bias data.\n *\n * @param sensorType The sensor type to post the event for.\n * @param bias The bias data.\n */\nvoid postSensorBiasEvent(SensorType sensorType,\n                         const chreSensorThreeAxisData& bias) {\n  uint16_t eventType;\n  if (getSensorBiasEventType(sensorType, &eventType)) {\n    auto *event = memoryAlloc<struct chreSensorThreeAxisData>();\n    if (event == nullptr) {\n      LOG_OOM();\n    } else {\n      *event = bias;\n      event->header.sensorHandle = getSensorHandleFromSensorType(sensorType);\n      EventLoopManagerSingleton::get()->getEventLoop().postEventOrDie(\n          eventType, event, freeEventDataCallback);\n    }\n  }\n}\n\n/**\n * Updates the sampling status.\n *\n * This should only be called when the new SamplingStatusData is different\n * from the most recently processed SamplingStatusData to avoid duplicate\n * updates being posted to nanoapps.\n */\nvoid updateSamplingStatus(\n    const SeeHelperCallbackInterface::SamplingStatusData& update) {\n  Sensor *sensor = EventLoopManagerSingleton::get()->getSensorRequestManager()\n      .getSensor(update.sensorType);\n  struct chreSensorSamplingStatus newStatus;\n\n  if (sensor != nullptr && !sensorTypeIsOneShot(update.sensorType)\n      && sensor->getSamplingStatus(&newStatus)) {\n    if (update.enabledValid) {\n      newStatus.enabled = update.status.enabled;\n    }\n    if (update.intervalValid) {\n      newStatus.interval = update.status.interval;\n    }\n    if (update.latencyValid) {\n      newStatus.latency = update.status.latency;\n    }\n\n    sensor->setSamplingStatus(newStatus);\n\n    // Only post to Nanoapps with an open request.\n    uint32_t sensorHandle = getSensorHandleFromSensorType(update.sensorType);\n    const DynamicVector<SensorRequest>& requests =\n        EventLoopManagerSingleton::get()->getSensorRequestManager()\n        .getRequests(update.sensorType);\n    for (const auto& req : requests) {\n      postSamplingStatusEvent(req.getInstanceId(), sensorHandle, newStatus);\n    }\n  }\n}\n\n/**\n * Compares the given status updates and returns true if they are the same.\n *\n * A simple memcmp cannot be done because if a given field is not valid, then\n * the field may be different across updates, but doesn't indicate the update\n * is different.\n */\nbool isSameStatusUpdate(\n    const SeeHelperCallbackInterface::SamplingStatusData& status1,\n    const SeeHelperCallbackInterface::SamplingStatusData& status2) {\n  bool sameStatus = status1.enabledValid == status2.enabledValid;\n  if (sameStatus && status1.enabledValid) {\n    sameStatus &= status1.status.enabled == status2.status.enabled;\n  }\n\n  // Only check interval / latency fields if both status updates say the sensor\n  // is enabled since CHRE doesn't care what the fields are set to if the sensor\n  // is disabled.\n  if (sameStatus && status1.status.enabled) {\n    sameStatus &= status1.intervalValid == status2.intervalValid;\n    if (sameStatus && status1.intervalValid) {\n      sameStatus &= status1.status.interval == status2.status.interval;\n    }\n\n    sameStatus &= status1.latencyValid == status2.latencyValid;\n    if (sameStatus && status1.latencyValid) {\n      sameStatus &= status1.status.latency == status2.status.latency;\n    }\n  }\n\n  return sameStatus;\n}\n\nvoid SeeHelperCallback::onSamplingStatusUpdate(\n    UniquePtr<SeeHelperCallbackInterface::SamplingStatusData>&& status) {\n  Sensor *sensor = EventLoopManagerSingleton::get()->getSensorRequestManager()\n      .getSensor(status->sensorType);\n\n  // TODO: Once the latency field is actually filled in by SEE, modify this\n  // logic to avoid reacting if the latency and interval of the sensor are\n  // updated separately, but contain the same info as before.\n  if (sensor != nullptr &&\n      !isSameStatusUpdate(sensor->mLastReceivedSamplingStatus, *status.get())) {\n    sensor->mLastReceivedSamplingStatus = *status.get();\n\n    auto callback = [](uint16_t /* type */, void *data) {\n      auto cbData = UniquePtr<SeeHelperCallbackInterface::SamplingStatusData>(\n          static_cast<SeeHelperCallbackInterface::SamplingStatusData *>(data));\n      updateSamplingStatus(*cbData);\n    };\n\n    // Schedule a deferred callback to handle sensor status change in the main\n    // thread.\n    EventLoopManagerSingleton::get()->deferCallback(\n        SystemCallbackType::SensorStatusUpdate, status.release(), callback);\n }\n}\n\nvoid SeeHelperCallback::onSensorDataEvent(\n    SensorType sensorType, UniquePtr<uint8_t>&& eventData) {\n  // Schedule a deferred callback to update on-change sensor's last event in\n  // the main thread.\n  if (sensorTypeIsOnChange(sensorType)) {\n    updateLastEvent(sensorType, eventData.get());\n  }\n\n  EventLoopManagerSingleton::get()->getSensorRequestManager().handleSensorEvent(\n      sensorType, eventData.get());\n  eventData.release();\n}\n\nvoid SeeHelperCallback::onHostWakeSuspendEvent(bool awake) {\n  if (EventLoopManagerSingleton::isInitialized()) {\n    EventLoopManagerSingleton::get()->getEventLoop()\n        .getPowerControlManager().onHostWakeSuspendEvent(awake);\n  }\n}\n\nvoid SeeHelperCallback::onSensorBiasEvent(\n    UniquePtr<struct chreSensorThreeAxisData>&& biasData) {\n  SensorType sensorType = getSensorTypeFromSensorHandle(\n      biasData->header.sensorHandle);\n\n  uint16_t eventType;\n  if (!sensorTypeIsCalibrated(sensorType) ||\n      !getSensorBiasEventType(sensorType, &eventType)) {\n    LOGE(\"Received bias event for unsupported sensor type %\" PRIu8, sensorType);\n  } else {\n    // Posts a newly allocated event for the uncalibrated type\n    postSensorBiasEvent(toUncalibratedSensorType(sensorType), *biasData.get());\n\n    EventLoopManagerSingleton::get()->getEventLoop().postEventOrDie(\n        eventType, biasData.release(), freeEventDataCallback);\n  }\n}\n\nvoid SeeHelperCallback::onFlushCompleteEvent(SensorType sensorType) {\n  if (EventLoopManagerSingleton::isInitialized()) {\n    EventLoopManagerSingleton::get()->getSensorRequestManager()\n        .handleFlushCompleteEvent(CHRE_ERROR_NONE, sensorType);\n  }\n}\n\n/**\n * Allocates memory and specifies the memory size for an on-change sensor to\n * store its last data event.\n *\n * @param sensorType The sensorType of this sensor.\n * @param eventSize A non-null pointer to indicate the memory size allocated.\n * @return Pointer to the memory allocated.\n */\nChreSensorData *allocateLastEvent(SensorType sensorType, size_t *eventSize) {\n  CHRE_ASSERT(eventSize);\n\n  *eventSize = 0;\n  ChreSensorData *event = nullptr;\n  if (sensorTypeIsOnChange(sensorType)) {\n    SensorSampleType sampleType = getSensorSampleTypeFromSensorType(sensorType);\n    switch (sampleType) {\n      case SensorSampleType::ThreeAxis:\n        *eventSize = sizeof(chreSensorThreeAxisData);\n        break;\n      case SensorSampleType::Float:\n        *eventSize = sizeof(chreSensorFloatData);\n        break;\n      case SensorSampleType::Byte:\n        *eventSize = sizeof(chreSensorByteData);\n        break;\n      case SensorSampleType::Occurrence:\n        *eventSize = sizeof(chreSensorOccurrenceData);\n        break;\n      default:\n        CHRE_ASSERT_LOG(false, \"Unhandled sample type\");\n        break;\n    }\n\n    event = static_cast<ChreSensorData *>(memoryAlloc(*eventSize));\n    if (event == nullptr) {\n      *eventSize = 0;\n      FATAL_ERROR(\"Failed to allocate last event memory for SensorType %\" PRIu8,\n                  static_cast<uint8_t>(sensorType));\n    }\n  }\n  return event;\n}\n\n/**\n * Constructs and initializes a sensor, and adds it to the sensor list.\n *\n * @param seeHelper SeeHelper instance to register sensor with\n * @param suid The SUID of the sensor as provided by SEE.\n * @param sensorType The sensor type of the sensor.\n * @param calibrated Whether the sensor is runtime-calibrated or not.\n * @param attr A reference to SeeAttrbutes.\n * @param sensor The sensor list.\n */\nvoid addSensor(SeeHelper& seeHelper, SensorType sensorType,\n               const sns_std_suid& suid, const SeeAttributes& attr,\n               DynamicVector<Sensor> *sensors) {\n  // Concatenate vendor and name with a space in between.\n  char sensorName[kSensorNameMaxLen];\n  strlcpy(sensorName, attr.vendor, sizeof(sensorName));\n  strlcat(sensorName, \" \", sizeof(sensorName));\n  strlcat(sensorName, attr.name, sizeof(sensorName));\n\n  // Some sensors have a max sample rate of 0 which makes ceilf return infinity\n  // for on-change or continuous sensors when that's not the correct\n  // minInterval.\n  float maxSampleRate =\n      (attr.maxSampleRate == 0.0f) ? 10 : attr.maxSampleRate;\n\n  // Override one-shot sensor's minInterval to default\n  uint64_t minInterval = sensorTypeIsOneShot(sensorType) ?\n      CHRE_SENSOR_INTERVAL_DEFAULT : static_cast<uint64_t>(\n          ceilf(Seconds(1).toRawNanoseconds() / maxSampleRate));\n\n  // Allocates memory for on-change sensor's last event.\n  size_t lastEventSize;\n  ChreSensorData *lastEvent = allocateLastEvent(sensorType, &lastEventSize);\n\n  // Constructs and initializes PlatformSensorBase.\n  Sensor sensor;\n  sensor.initBase(sensorType, minInterval, sensorName, lastEvent,\n                  lastEventSize, attr.passiveRequest);\n\n  if (!sensors->push_back(std::move(sensor))) {\n    FATAL_ERROR(\"Failed to allocate new sensor: out of memory\");\n  }\n\n  // Resample big image sensors to reduce system load during sw flush.\n#ifdef CHRE_SLPI_UIMG_ENABLED\n  bool resample = isBigImageSensorType(sensorType);\n#else\n  bool resample = false;\n#endif\n  bool prevRegistered;\n  bool registered = seeHelper.registerSensor(\n      sensorType, suid, resample, &prevRegistered);\n  if (!registered && prevRegistered) {\n    LOGW(\"SUID has been previously registered\");\n  } else if (!registered) {\n    FATAL_ERROR(\"Failed to register SUID/SensorType mapping.\");\n  }\n}\n\n/**\n * Compare SEE reported stream type attribute to the expected one. Some SEE\n * sensors may support more than one stream type.\n */\nbool isStreamTypeCorrect(SensorType sensorType, uint8_t streamType) {\n  bool success = true;\n  if ((sensorTypeIsContinuous(sensorType)\n       && streamType != SNS_STD_SENSOR_STREAM_TYPE_STREAMING)\n      || (sensorTypeIsOnChange(sensorType)\n          && streamType != SNS_STD_SENSOR_STREAM_TYPE_ON_CHANGE)\n// The default SLPI build exposes instant motion / stationary sensors as\n// on-change, but CHRE uses them as one-shot\n#ifndef CHRE_SLPI_DEFAULT_BUILD\n      || (sensorTypeIsOneShot(sensorType)\n          && streamType != SNS_STD_SENSOR_STREAM_TYPE_SINGLE_OUTPUT)\n#endif\n      ) {\n    success = false;\n    LOGW(\"Inconsistent sensor type %\" PRIu8 \" and stream type %\" PRIu8,\n         static_cast<uint8_t>(sensorType), streamType);\n  }\n  return success;\n}\n\n/**\n * Obtains the list of SUIDs and their attributes that support the specified\n * data type.\n */\nbool getSuidAndAttrs(SeeHelper& seeHelper, const char *dataType,\n                     DynamicVector<SuidAttr> *suidAttrs, uint8_t minNumSuids) {\n  DynamicVector<sns_std_suid> suids;\n  bool success = seeHelper.findSuidSync(dataType, &suids, minNumSuids);\n  if (!success) {\n    LOGE(\"Failed to find sensor '%s'\", dataType);\n  } else {\n    LOGD(\"Num of SUIDs found for '%s': %zu\", dataType, suids.size());\n\n    for (const auto& suid : suids) {\n      SeeAttributes attr;\n      if (!seeHelper.getAttributesSync(suid, &attr)) {\n        success = false;\n        LOGE(\"Failed to get attributes of SUID 0x%\" PRIx64 \" %\" PRIx64,\n             suid.suid_high, suid.suid_low);\n      } else {\n        LOGI(\"%s %s, hw id %\" PRId64 \", max ODR %f Hz, stream type %\" PRIu8\n             \" passive %d\",\n             attr.vendor, attr.name, attr.hwId, attr.maxSampleRate,\n             attr.streamType, attr.passiveRequest);\n        SuidAttr sensor = {\n          .suid = suid,\n          .attr = attr,\n        };\n        if (!suidAttrs->push_back(sensor)) {\n          success = false;\n          LOG_OOM();\n        }\n      }\n    }\n  }\n  return success;\n}\n\n#ifndef CHRE_SLPI_DEFAULT_BUILD\n//! Check whether two sensors with the specified attrtibutes belong to the same\n//! sensor hardware module.\nbool sensorHwMatch(const SeeAttributes& attr0, const SeeAttributes& attr1) {\n  // When HW ID is absent, it's default to 0 and won't be a factor.\n  return ((strncmp(attr0.vendor, attr1.vendor, kSeeAttrStrValLen) == 0)\n          && (strncmp(attr0.name, attr1.name, kSeeAttrStrValLen) == 0)\n          && (attr0.hwId == attr1.hwId));\n}\n#endif\n\n/**\n * Looks up SUID(s) associated with a given sensor data type string and sensor\n * type enum, registers them with SeeHelper, and adds a Sensor instance to the\n * supplied vector for use in CHRE. When given an uncalibrated sensor type, will\n * also look for and add the calibrated sensor type.\n *\n * @param seeHelper SeeHelper instance to use for lookup/registration\n * @param temperatureSensors List of previously discovered temperature sensor\n *        info to use for adding temp sensors associated with this sensor type\n * @param dataType SEE data type string\n * @param sensorType CHRE sensor type enum associated with dataType\n * @param skipAdditionalTypes if true, don't attempt to add\n *        calibrated/temperature sensor types associated with this sensorType\n * @param sensors Vector to append found sensor(s) to\n */\nvoid findAndAddSensorsForType(\n    SeeHelper& seeHelper, const DynamicVector<SuidAttr>& temperatureSensors,\n    const char *dataType, SensorType sensorType, bool skipAdditionalTypes,\n    DynamicVector<Sensor> *sensors) {\n  DynamicVector<SuidAttr> primarySensors;\n  if (!getSuidAndAttrs(seeHelper, dataType, &primarySensors,\n                       1 /* minNumSuids */)) {\n    handleMissingSensor();\n  }\n\n  for (const auto& primarySensor : primarySensors) {\n    sns_std_suid suid = primarySensor.suid;\n    SeeAttributes attr = primarySensor.attr;\n\n    // Some sensors support both continuous and on-change streams.\n    // If there are more than one SUIDs that support the data type,\n    // choose the first one that has the expected stream type.\n    if (isStreamTypeCorrect(sensorType, attr.streamType)) {\n      addSensor(seeHelper, sensorType, suid, attr, sensors);\n\n      if (!skipAdditionalTypes) {\n        // Check if this sensor has a runtime-calibrated version.\n        SensorType calibratedType = getSensorTypeFromDataType(\n            dataType, true /* calibrated */);\n        if (calibratedType != sensorType) {\n          addSensor(seeHelper, calibratedType, suid, attr, sensors);\n        }\n\n        // Check if this sensor has a secondary temperature sensor.\n        SensorType temperatureType = getTempSensorType(sensorType);\n        if (temperatureType != SensorType::Unknown) {\n          bool tempFound = false;\n          for (const auto& tempSensor : temperatureSensors) {\n            sns_std_suid tempSuid = tempSensor.suid;\n            SeeAttributes tempAttr = tempSensor.attr;\n\n#ifdef CHRE_SLPI_DEFAULT_BUILD\n            // The default build exposes a single temp sensor to be used for\n            // all temperature sensors that doesn't have the same attributes\n            // as the primarySensor.\n            if (true) {\n#else\n            if (sensorHwMatch(attr, tempAttr)) {\n#endif\n              LOGD(\"Found matching temperature sensor type\");\n              tempFound = true;\n              addSensor(seeHelper, temperatureType, tempSuid, tempAttr,\n                        sensors);\n              break;\n            }\n          }\n          if (!tempFound) {\n            LOGW(\"Temperature sensor type %\" PRIu8 \" not found!\",\n                 static_cast<uint8_t>(temperatureType));\n          }\n        }\n      }\n      break;\n    }\n  }\n}\n\n#ifdef CHRE_SLPI_UIMG_ENABLED\n/**\n * Registers alternate sensor(s) to be used separately by big image nanoapps.\n */\nvoid getBigImageSensors(DynamicVector<Sensor> *sensors) {\n  CHRE_ASSERT(sensors);\n\n  // Currently, just adding calibrated accel and uncal accel/gyro/mag as they\n  // are the ones we know that big image nanoapps will need at a different\n  // batching rate compared to uimg.\n  const char *kBigImageDataTypes[] = {\n    \"accel\",\n    \"gyro\",\n    \"mag\",\n  };\n\n  SeeHelper& seeHelper = *getBigImageSeeHelper();\n  DynamicVector<SuidAttr> nullTemperatureSensorList;\n\n  for (size_t i = 0; i < ARRAY_SIZE(kBigImageDataTypes); i++) {\n    const char *dataType = kBigImageDataTypes[i];\n    // Loop through potential cal/uncal sensors.\n    for (size_t j = 0; j < 2; j++) {\n      SensorType sensorType = getBigImageSensorTypeFromDataType(\n          dataType, (j == 0) /* calibrated */);\n      if (sensorType != SensorType::Unknown) {\n        findAndAddSensorsForType(\n            seeHelper, nullTemperatureSensorList, dataType, sensorType,\n            true /* skipAdditionalTypes */, sensors);\n      }\n    }\n  }\n}\n#endif  // CHRE_SLPI_UIMG_ENABLED\n\n/**\n * Helper function to retrieve the SeeHelper for a given sensor type.\n * @param sensorType the sensor type\n * @return the appropriate (bimg or uimg) SeeHelper\n */\nSeeHelper *getSeeHelperForSensorType(SensorType sensorType) {\n  SeeHelper *seeHelper = getSeeHelper();\n#ifdef CHRE_SLPI_UIMG_ENABLED\n  if (isBigImageSensorType(sensorType)) {\n    seeHelper = getBigImageSeeHelper();\n    slpiForceBigImage();\n  }\n#endif\n\n  return seeHelper;\n}\n\n\n}  // anonymous namespace\n\nPlatformSensor::~PlatformSensor() {\n  if (mLastEvent != nullptr) {\n    LOGD(\"Releasing lastEvent: sensor %s, size %zu\",\n         getSensorTypeName(getSensorType()), mLastEventSize);\n    memoryFree(mLastEvent);\n  }\n}\n\nvoid PlatformSensor::init() {\n  SeeHelperSingleton::init();\n\n  static SeeHelperCallback seeHelperCallback;\n  if (!getSeeHelper()->init(&seeHelperCallback)) {\n    FATAL_ERROR(\"Failed to initialize SEE helper\");\n  }\n\n#ifdef CHRE_SLPI_UIMG_ENABLED\n  BigImageSeeHelperSingleton::init(getSeeHelper()->getCalHelper());\n  if (!getBigImageSeeHelper()->init(&seeHelperCallback, kDefaultSeeWaitTimeout,\n                                    true /* skipDefaultSensorInit */)) {\n    FATAL_ERROR(\"Failed to init bimg SEE helper\");\n  }\n#endif  // CHRE_SLPI_UIMG_ENABLED\n}\n\nvoid PlatformSensor::deinit() {\n#ifdef CHRE_SLPI_UIMG_ENABLED\n  BigImageSeeHelperSingleton::deinit();\n#endif\n\n  SeeHelperSingleton::deinit();\n}\n\nbool PlatformSensor::getSensors(DynamicVector<Sensor> *sensors) {\n  CHRE_ASSERT(sensors);\n\n  SeeHelper& seeHelper = *getSeeHelper();\n  DynamicVector<SuidAttr> tempSensors;\n  if (!getSuidAndAttrs(seeHelper, \"sensor_temperature\", &tempSensors,\n                       CHRE_SEE_NUM_TEMP_SENSORS)) {\n    handleMissingSensor();\n  }\n\n#ifndef CHREX_SENSOR_SUPPORT\n  const char *kVendorDataTypes[] = {};\n#endif  // CHREX_SENSOR_SUPPORT\n  constexpr size_t kNumSeeTypes = ARRAY_SIZE(kSeeDataTypes);\n  constexpr size_t kNumVendorTypes = ARRAY_SIZE(kVendorDataTypes);\n  for (size_t i = 0; i < kNumSeeTypes + kNumVendorTypes; i++) {\n    const char *dataType = (i < kNumSeeTypes)\n        ? kSeeDataTypes[i] : kVendorDataTypes[i - kNumSeeTypes];\n\n    SensorType sensorType = getSensorTypeFromDataType(\n        dataType, false /* calibrated */);\n    if (sensorType == SensorType::Unknown) {\n      LOGE(\"Unknown sensor type found for '%s'\", dataType);\n      continue;\n    }\n\n    bool skipAdditionalTypes = false;\n\n#ifdef CHRE_SLPI_DEFAULT_BUILD\n    // Stationary and motion detect share the same dataType on the default build\n    if (sensorType == SensorType::InstantMotion && i == kNumSeeTypes - 1) {\n      sensorType = SensorType::StationaryDetect;\n      // Skip additional types or InstantMotion will be added to the sensor list\n      // twice.\n      skipAdditionalTypes = true;\n    }\n#endif\n\n    findAndAddSensorsForType(seeHelper, tempSensors, dataType, sensorType,\n                             skipAdditionalTypes, sensors);\n  }",
        "res_region": "",
        "lookback": "void PlatformSensorBase::initBase(uint8_t sensorType, uint64_t minInterval,",
        "lookahead": "void PlatformSensorBase::initBase(uint8_t sensorType, uint64_t minInterval,",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 19,
        "end_line": 1489,
        "merge_gen_region": null,
        "confidence": 0.5338871479034424,
        "hesitated": true
    },
    {
        "a_contents": "void PlatformSensorBase::initBase(uint8_t sensorType, uint64_t minInterval,\n                                  const char *sensorName,\n                                  bool passiveSupported) {\n  mSensorType = sensorType;\n  mMinInterval = minInterval;\n  memcpy(mSensorName, sensorName, kSensorNameMaxLen);",
        "b_contents": "#ifdef CHRE_SLPI_UIMG_ENABLED\n  getBigImageSensors(sensors);\n#endif\n\n  return true;\n}\n\nbool PlatformSensor::applyRequest(const SensorRequest& request) {\n  SeeSensorRequest req = {\n    .sensorType = getSensorType(),\n    .enable = (request.getMode() != SensorMode::Off),\n    .passive = sensorModeIsPassive(request.getMode()),\n    .samplingRateHz = static_cast<float>(\n        kOneSecondInNanoseconds / request.getInterval().toRawNanoseconds()),\n    // Override batch period to 0 for non-continuous sensors to ensure one\n    // sample per batch.\n    .batchPeriodUs = !sensorTypeIsContinuous(mSensorType) ? 0\n        : static_cast<uint32_t>(request.getLatency().toRawNanoseconds()\n                                / kOneMicrosecondInNanoseconds),\n  };\n\n  if (req.enable && req.passive && !mPassiveSupported) {\n    LOGD(\"Promoting sensor %\" PRIu8 \" passive request to active\",\n         static_cast<uint8_t>(getSensorType()));\n  }\n\n  SeeHelper *seeHelper = getSeeHelperForSensorType(getSensorType());\n  bool wasInUImage = slpiInUImage();\n\n  bool success = true;\n\n  // TODO(b/150144912): Merge the two implementations to avoid having separate\n  // code paths.\n#ifdef CHRE_SLPI_DEFAULT_BUILD\n  // Calibration updates are not enabled automatically in the default build.\n  SeeCalHelper *calHelper = seeHelper->getCalHelper();\n\n  const sns_std_suid *suid =\n      calHelper->getCalSuidFromSensorType(getSensorType());\n  bool wereCalUpdatesEnabled = false;\n  if (suid != nullptr) {\n    wereCalUpdatesEnabled = calHelper->areCalUpdatesEnabled(*suid);\n    success = calHelper->configureCalUpdates(*suid, req.enable, *seeHelper);\n  }\n#endif\n\n  if (success) {\n    success = seeHelper->makeRequest(req);\n  }\n\n#ifdef CHRE_SLPI_DEFAULT_BUILD\n  // If any part of the configuration process failed, reset our subscription\n  // for calibration updates to its previous value to attempt to restore state.\n  if (suid != nullptr && !success) {\n    bool areCalUpdatesEnabled = calHelper->areCalUpdatesEnabled(*suid);\n    if (areCalUpdatesEnabled != wereCalUpdatesEnabled) {\n      calHelper->configureCalUpdates(*suid, wereCalUpdatesEnabled, *seeHelper);\n    }\n  }\n#endif\n\n  // If we dropped into micro-image during that blocking call to SEE, go back to\n  // big image. This won't happen if the calling nanoapp is a big image one, but\n  // other code paths currently assume that we will only transition from big\n  // image to micro-image from CHRE's perspective while it's waiting for an\n  // event to arrive in its empty queue.\n  // TODO: transition back to big image only when needed, at the point of\n  // invoking a nanoapp's free event/message callback\n  if (!wasInUImage && slpiInUImage()) {\n    LOGD(\"Restoring big image operating mode\");\n    slpiForceBigImage();\n  }\n\n  if (success) {\n    if (request.getMode() == SensorMode::Off) {\n      mLastEventValid = false;\n    }\n\n    // TODO: remove setSamplingStatus when .latency is available in status\n    // update from SEE.\n    struct chreSensorSamplingStatus status;\n    if (getSamplingStatus(&status)) {\n\n      // If passive request is not supported by this SEE sensor, it won't be\n      // dynamically enabled/disabled and its status stays the same as set here.\n      if (!mPassiveSupported) {\n        status.enabled = req.enable;\n      }\n      status.latency = req.batchPeriodUs * kOneMicrosecondInNanoseconds;\n      setSamplingStatus(status);\n    }\n  }\n  return success;\n}",
        "base_contents": "#ifdef CHRE_SLPI_UIMG_ENABLED\n  getBigImageSensors(sensors);\n#endif\n\n  return true;\n}\n\nbool PlatformSensor::applyRequest(const SensorRequest& request) {\n  SeeSensorRequest req = {\n    .sensorType = getSensorType(),\n    .enable = (request.getMode() != SensorMode::Off),\n    .passive = sensorModeIsPassive(request.getMode()),\n    .samplingRateHz = static_cast<float>(\n        kOneSecondInNanoseconds / request.getInterval().toRawNanoseconds()),\n    // Override batch period to 0 for non-continuous sensors to ensure one\n    // sample per batch.\n    .batchPeriodUs = !sensorTypeIsContinuous(mSensorType) ? 0\n        : static_cast<uint32_t>(request.getLatency().toRawNanoseconds()\n                                / kOneMicrosecondInNanoseconds),\n  };\n\n  if (req.enable && req.passive && !mPassiveSupported) {\n    LOGD(\"Promoting sensor %\" PRIu8 \" passive request to active\",\n         static_cast<uint8_t>(getSensorType()));\n  }\n\n  SeeHelper *seeHelper = getSeeHelperForSensorType(getSensorType());\n  bool wasInUImage = slpiInUImage();\n  bool success = seeHelper->makeRequest(req);\n\n  // If we dropped into micro-image during that blocking call to SEE, go back to\n  // big image. This won't happen if the calling nanoapp is a big image one, but\n  // other code paths currently assume that we will only transition from big\n  // image to micro-image from CHRE's perspective while it's waiting for an\n  // event to arrive in its empty queue.\n  // TODO: transition back to big image only when needed, at the point of\n  // invoking a nanoapp's free event/message callback\n  if (!wasInUImage && slpiInUImage()) {\n    LOGD(\"Restoring big image operating mode\");\n    slpiForceBigImage();\n  }\n\n  if (success) {\n    if (request.getMode() == SensorMode::Off) {\n      mLastEventValid = false;\n    }\n\n    // TODO: remove setSamplingStatus when .latency is available in status\n    // update from SEE.\n    struct chreSensorSamplingStatus status;\n    if (getSamplingStatus(&status)) {\n\n      // If passive request is not supported by this SEE sensor, it won't be\n      // dynamically enabled/disabled and its status stays the same as set here.\n      if (!mPassiveSupported) {\n        status.enabled = req.enable;\n      }\n      status.latency = req.batchPeriodUs * kOneMicrosecondInNanoseconds;\n      setSamplingStatus(status);\n    }\n  }\n  return success;\n}",
        "res_region": "void PlatformSensorBase::initBase(uint8_t sensorType, uint64_t minInterval,\n                                  const char *sensorName,\n                                  bool passiveSupported) {\n  mSensorType = sensorType;\n  mMinInterval = minInterval;\n  memcpy(mSensorName, sensorName, kSensorNameMaxLen);",
        "lookback": "                                  const char *sensorName,",
        "lookahead": "",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 1491,
        "end_line": 1657,
        "merge_gen_region": " charsensorNamevoidSensor::Baseuint_ sensor,64tInterval const charsensor, passive) mType sensor;Sensor = sensor;",
        "confidence": 0.8832665085792542,
        "hesitated": false,
        "resolved": false
    }
]