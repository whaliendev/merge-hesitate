[
    {
        "a_contents": "Status VersionSet::ListColumnFamilies(std::vector<std::string>* column_families,\n                                      const std::string& dbname, Env* env) {\n\n  // these are just for performance reasons, not correcntes,\n  // so we're fine using the defaults\n  EnvOptions soptions;\n  // Read \"CURRENT\" file, which contains a pointer to the current manifest file\n  std::string current;\n  Status s = ReadFileToString(env, CurrentFileName(dbname), &current);\n  if (!s.ok()) {\n    return s;\n  }\n  if (current.empty() || current[current.size()-1] != '\\n') {\n    return Status::Corruption(\"CURRENT file does not end with newline\");\n  }\n  current.resize(current.size() - 1);\n\n  std::string dscname = dbname + \"/\" + current;\n  unique_ptr<SequentialFile> file;\n  s = env->NewSequentialFile(dscname, &file, soptions);\n  if (!s.ok()) {\n    return s;\n  }\n\n  std::map<uint32_t, std::string> column_family_names;\n  // default column family is always implicitly there\n  column_family_names.insert({0, default_column_family_name});\n  VersionSet::LogReporter reporter;\n  reporter.status = &s;\n  log::Reader reader(std::move(file), &reporter, true /*checksum*/,\n                     0 /*initial_offset*/);\n  Slice record;\n  std::string scratch;\n  while (reader.ReadRecord(&record, &scratch) && s.ok()) {\n      VersionEdit edit;\n      s = edit.DecodeFrom(record);\n      if (!s.ok()) {\n        break;\n      }\n      if (edit.is_column_family_add_) {\n        column_family_names.insert(\n            {edit.column_family_, edit.column_family_name_});\n      } else if (edit.is_column_family_drop_) {\n        column_family_names.erase(edit.column_family_);\n      }\n  }\n\n  column_families->clear();\n  if (s.ok()) {\n    for (const auto& iter : column_family_names) {\n      column_families->push_back(iter.second);",
        "b_contents": "Status VersionSet::ReduceNumberOfLevels(const std::string& dbname,\n                                        const Options* options,\n                                        const EnvOptions& storage_options,\n                                        int new_levels) {\n  if (new_levels <= 1) {\n    return Status::InvalidArgument(\n        \"Number of levels needs to be bigger than 1\");\n  }\n\n  const InternalKeyComparator cmp(options->comparator);\n  TableCache tc(dbname, options, storage_options, 10);\n  VersionSet versions(dbname, options, storage_options, &tc, &cmp);\n  Status status;\n\n  status = versions.Recover();\n  if (!status.ok()) {\n    return status;\n  }\n\n  Version* current_version = versions.current();\n  int current_levels = current_version->NumberLevels();\n\n  if (current_levels <= new_levels) {\n    return Status::OK();\n  }\n\n  // Make sure there are file only on one level from\n  // (new_levels-1) to (current_levels-1)\n  int first_nonempty_level = -1;\n  int first_nonempty_level_filenum = 0;\n  for (int i = new_levels - 1; i < current_levels; i++) {\n    int file_num = current_version->NumLevelFiles(i);\n    if (file_num != 0) {\n      if (first_nonempty_level < 0) {\n        first_nonempty_level = i;\n        first_nonempty_level_filenum = file_num;\n      } else {\n        char msg[255];\n        snprintf(msg, sizeof(msg),\n                 \"Found at least two levels containing files: \"\n                 \"[%d:%d],[%d:%d].\\n\",\n                 first_nonempty_level, first_nonempty_level_filenum, i,\n                 file_num);\n        return Status::InvalidArgument(msg);\n      }\n    }\n  }\n\n  std::vector<FileMetaData*>* old_files_list = current_version->files_;\n  std::vector<FileMetaData*>* new_files_list =\n      new std::vector<FileMetaData*>[new_levels];\n  for (int i = 0; i < new_levels - 1; i++) {\n    new_files_list[i] = old_files_list[i];\n  }\n\n  if (first_nonempty_level > 0) {\n    new_files_list[new_levels - 1] = old_files_list[first_nonempty_level];\n  }\n\n  delete[] current_version->files_;\n  current_version->files_ = new_files_list;\n  current_version->num_levels_ = new_levels;\n\n  VersionEdit ve;\n  port::Mutex dummy_mutex;\n  MutexLock l(&dummy_mutex);\n  return versions.LogAndApply(&ve, &dummy_mutex, true);\n}\n\nStatus VersionSet::DumpManifest(Options& options, std::string& dscname,\n                                bool verbose, bool hex) {\n  struct LogReporter : public log::Reader::Reporter {\n    Status* status;\n    virtual void Corruption(size_t bytes, const Status& s) {\n      if (this->status->ok()) *this->status = s;",
        "base_contents": "Status VersionSet::DumpManifest(Options& options, std::string& dscname,\n                                bool verbose, bool hex) {\n  struct LogReporter : public log::Reader::Reporter {\n    Status* status;\n    virtual void Corruption(size_t bytes, const Status& s) {\n      if (this->status->ok()) *this->status = s;",
        "res_region": "Status VersionSet::ListColumnFamilies(std::vector<std::string>* column_families,\n                                      const std::string& dbname, Env* env) {\n\n  // these are just for performance reasons, not correcntes,\n  // so we're fine using the defaults\n  EnvOptions soptions;\n  // Read \"CURRENT\" file, which contains a pointer to the current manifest file\n  std::string current;\n  Status s = ReadFileToString(env, CurrentFileName(dbname), &current);\n  if (!s.ok()) {\n    return s;\n  }\n  if (current.empty() || current[current.size()-1] != '\\n') {\n    return Status::Corruption(\"CURRENT file does not end with newline\");\n  }\n  current.resize(current.size() - 1);\n\n  std::string dscname = dbname + \"/\" + current;\n  unique_ptr<SequentialFile> file;\n  s = env->NewSequentialFile(dscname, &file, soptions);\n  if (!s.ok()) {\n    return s;\n  }\n\n  std::map<uint32_t, std::string> column_family_names;\n  // default column family is always implicitly there\n  column_family_names.insert({0, default_column_family_name});\n  VersionSet::LogReporter reporter;\n  reporter.status = &s;\n  log::Reader reader(std::move(file), &reporter, true /*checksum*/,\n                     0 /*initial_offset*/);\n  Slice record;\n  std::string scratch;\n  while (reader.ReadRecord(&record, &scratch) && s.ok()) {\n      VersionEdit edit;\n      s = edit.DecodeFrom(record);\n      if (!s.ok()) {\n        break;\n      }\n      if (edit.is_column_family_add_) {\n        column_family_names.insert(\n            {edit.column_family_, edit.column_family_name_});\n      } else if (edit.is_column_family_drop_) {\n        column_family_names.erase(edit.column_family_);\n      }\n  }\n\n  column_families->clear();\n  if (s.ok()) {\n    for (const auto& iter : column_family_names) {\n      column_families->push_back(iter.second);\n    }\n  }\n\n  return s;\n}\n\nStatus VersionSet::ReduceNumberOfLevels(const std::string& dbname,\n                                        const Options* options,\n                                        const EnvOptions& storage_options,\n                                        int new_levels) {\n  if (new_levels <= 1) {\n    return Status::InvalidArgument(\n        \"Number of levels needs to be bigger than 1\");\n  }\n\n  const InternalKeyComparator cmp(options->comparator);\n  TableCache tc(dbname, options, storage_options, 10);\n  VersionSet versions(dbname, options, storage_options, &tc, &cmp);\n  Status status;\n\n  std::vector<ColumnFamilyDescriptor> dummy;\n  dummy.push_back(ColumnFamilyDescriptor());\n  status = versions.Recover(dummy);\n  if (!status.ok()) {\n    return status;\n  }\n\n  Version* current_version = versions.current();\n  int current_levels = current_version->NumberLevels();\n\n  if (current_levels <= new_levels) {\n    return Status::OK();\n  }\n\n  // Make sure there are file only on one level from\n  // (new_levels-1) to (current_levels-1)\n  int first_nonempty_level = -1;\n  int first_nonempty_level_filenum = 0;\n  for (int i = new_levels - 1; i < current_levels; i++) {\n    int file_num = current_version->NumLevelFiles(i);\n    if (file_num != 0) {\n      if (first_nonempty_level < 0) {\n        first_nonempty_level = i;\n        first_nonempty_level_filenum = file_num;\n      } else {\n        char msg[255];\n        snprintf(msg, sizeof(msg),\n                 \"Found at least two levels containing files: \"\n                 \"[%d:%d],[%d:%d].\\n\",\n                 first_nonempty_level, first_nonempty_level_filenum, i,\n                 file_num);\n        return Status::InvalidArgument(msg);\n      }\n    }\n  }\n\n  std::vector<FileMetaData*>* old_files_list = current_version->files_;\n  std::vector<FileMetaData*>* new_files_list =\n      new std::vector<FileMetaData*>[new_levels];\n  for (int i = 0; i < new_levels - 1; i++) {\n    new_files_list[i] = old_files_list[i];\n  }\n\n  if (first_nonempty_level > 0) {\n    new_files_list[new_levels - 1] = old_files_list[first_nonempty_level];\n  }\n\n  delete[] current_version->files_;\n  current_version->files_ = new_files_list;\n  current_version->num_levels_ = new_levels;\n\n  VersionEdit ve;\n  port::Mutex dummy_mutex;\n  MutexLock l(&dummy_mutex);\n  return versions.LogAndApply(&ve, &dummy_mutex, true);",
        "lookback": "                                      const std::string& dbname, Env* env) {",
        "lookahead": "}",
        "label": [
            "newcode",
            "complex_conflict"
        ],
        "start_line": 1819,
        "end_line": 1954,
        "merge_gen_region": null,
        "confidence": 0.7757924199104309,
        "hesitated": true
    }
]