[
    {
        "a_contents": "  void TEST_GetFilesMetaData(ColumnFamilyHandle* column_family,\n                             std::vector<std::vector<FileMetaData>>* metadata);",
        "b_contents": "  void TEST_GetFilesMetaData(std::vector<std::vector<FileMetaData>>* metadata);\n\n  // holds references to memtable, all immutable memtables and version\n  struct SuperVersion {\n    MemTable* mem;\n    MemTableListVersion* imm;\n    Version* current;\n    std::atomic<uint32_t> refs;\n    // We need to_delete because during Cleanup(), imm->Unref() returns\n    // all memtables that we need to free through this vector. We then\n    // delete all those memtables outside of mutex, during destruction\n    autovector<MemTable*> to_delete;\n    // Version number of the current SuperVersion\n    uint64_t version_number;\n    DBImpl* db;\n\n    // should be called outside the mutex\n    SuperVersion() = default;\n    ~SuperVersion();\n    SuperVersion* Ref();\n    // Returns true if this was the last reference and caller should\n    // call Clenaup() and delete the object\n    bool Unref();\n\n    // call these two methods with db mutex held\n    // Cleanup unrefs mem, imm and current. Also, it stores all memtables\n    // that needs to be deleted in to_delete vector. Unrefing those\n    // objects needs to be done in the mutex\n    void Cleanup();\n    void Init(MemTable* new_mem, MemTableListVersion* new_imm,\n              Version* new_current);\n\n    // The value of dummy is not actually used. kSVInUse takes its address as a\n    // mark in the thread local storage to indicate the SuperVersion is in use\n    // by thread. This way, the value of kSVInUse is guaranteed to have no\n    // conflict with SuperVersion object address and portable on different\n    // platform.\n    static int dummy;\n    static void* const kSVInUse;\n    static void* const kSVObsolete;\n  };\n\n  static void SuperVersionUnrefHandle(void* ptr) {\n    // UnrefHandle is called when a thread exists or a ThreadLocalPtr gets\n    // destroyed. When former happens, the thread shouldn't see kSVInUse.\n    // When latter happens, we are in ~DBImpl(), no get should happen as well.\n    assert(ptr != SuperVersion::kSVInUse);\n    DBImpl::SuperVersion* sv = static_cast<DBImpl::SuperVersion*>(ptr);\n    if (sv->Unref()) {\n      sv->db->mutex_.Lock();\n      sv->Cleanup();\n      sv->db->mutex_.Unlock();\n      delete sv;\n    }\n  }",
        "base_contents": "  void TEST_GetFilesMetaData(std::vector<std::vector<FileMetaData>>* metadata);\n\n  // holds references to memtable, all immutable memtables and version\n  struct SuperVersion {\n    MemTable* mem;\n    MemTableListVersion* imm;\n    Version* current;\n    std::atomic<uint32_t> refs;\n    // We need to_delete because during Cleanup(), imm->Unref() returns\n    // all memtables that we need to free through this vector. We then\n    // delete all those memtables outside of mutex, during destruction\n    autovector<MemTable*> to_delete;\n    // Version number of the current SuperVersion\n    uint64_t version_number;\n    DBImpl* db;\n\n    // should be called outside the mutex\n    SuperVersion() = default;\n    ~SuperVersion();\n    SuperVersion* Ref();\n    // Returns true if this was the last reference and caller should\n    // call Clenaup() and delete the object\n    bool Unref();\n\n    // call these two methods with db mutex held\n    // Cleanup unrefs mem, imm and current. Also, it stores all memtables\n    // that needs to be deleted in to_delete vector. Unrefing those\n    // objects needs to be done in the mutex\n    void Cleanup();\n    void Init(MemTable* new_mem, MemTableListVersion* new_imm,\n              Version* new_current);\n  };\n\n  static void SuperVersionUnrefHandle(void* ptr) {\n    DBImpl::SuperVersion* sv = static_cast<DBImpl::SuperVersion*>(ptr);\n    if (sv->Unref()) {\n      sv->db->mutex_.Lock();\n      sv->Cleanup();\n      sv->db->mutex_.Unlock();\n      delete sv;\n    }\n  }",
        "res_region": "  void TEST_GetFilesMetaData(ColumnFamilyHandle* column_family,\n                             std::vector<std::vector<FileMetaData>>* metadata);",
        "lookback": "                             std::vector<std::vector<FileMetaData>>* metadata);",
        "lookahead": "",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 181,
        "end_line": 283,
        "merge_gen_region": null,
        "confidence": 0.7418140172958374,
        "hesitated": true
    }
]