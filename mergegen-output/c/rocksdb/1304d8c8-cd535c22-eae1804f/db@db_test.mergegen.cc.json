[
    {
        "a_contents": "",
        "b_contents": "TEST(DBTest, LevelLimitReopen) {\n  Options options = CurrentOptions();\n  Reopen(&options);\n\n  const std::string value(1024 * 1024, ' ');\n  int i = 0;\n  while (NumTableFilesAtLevel(2) == 0) {\n    ASSERT_OK(Put(Key(i++), value));\n  }\n\n  options.num_levels = 1;\n  options.max_bytes_for_level_multiplier_additional.resize(1, 1);\n  Status s = TryReopen(&options);\n  ASSERT_EQ(s.IsInvalidArgument(), true);\n  ASSERT_EQ(s.ToString(),\n            \"Invalid argument: db has more levels than options.num_levels\");\n\n  options.num_levels = 10;\n  options.max_bytes_for_level_multiplier_additional.resize(10, 1);\n  ASSERT_OK(TryReopen(&options));\n}\n\nTEST(DBTest, Preallocation) {\n  const std::string src = dbname_ + \"/alloc_test\";\n  unique_ptr<WritableFile> srcfile;\n  const EnvOptions soptions;\n  ASSERT_OK(env_->NewWritableFile(src, &srcfile, soptions));\n  srcfile->SetPreallocationBlockSize(1024 * 1024);\n\n  // No writes should mean no preallocation\n  size_t block_size, last_allocated_block;\n  srcfile->GetPreallocationStatus(&block_size, &last_allocated_block);\n  ASSERT_EQ(last_allocated_block, 0UL);\n\n  // Small write should preallocate one block\n  srcfile->Append(\"test\");\n  srcfile->GetPreallocationStatus(&block_size, &last_allocated_block);\n  ASSERT_EQ(last_allocated_block, 1UL);\n\n  // Write an entire preallocation block, make sure we increased by two.\n  std::string buf(block_size, ' ');\n  srcfile->Append(buf);\n  srcfile->GetPreallocationStatus(&block_size, &last_allocated_block);\n  ASSERT_EQ(last_allocated_block, 2UL);\n\n  // Write five more blocks at once, ensure we're where we need to be.\n  buf = std::string(block_size * 5, ' ');\n  srcfile->Append(buf);\n  srcfile->GetPreallocationStatus(&block_size, &last_allocated_block);\n  ASSERT_EQ(last_allocated_block, 7UL);\n}\n\nTEST(DBTest, PutDeleteGet) {\n  do {\n    ASSERT_OK(db_->Put(WriteOptions(), \"foo\", \"v1\"));\n    ASSERT_EQ(\"v1\", Get(\"foo\"));\n    ASSERT_OK(db_->Put(WriteOptions(), \"foo\", \"v2\"));\n    ASSERT_EQ(\"v2\", Get(\"foo\"));\n    ASSERT_OK(db_->Delete(WriteOptions(), \"foo\"));\n    ASSERT_EQ(\"NOT_FOUND\", Get(\"foo\"));\n  } while (ChangeOptions());\n}\n\n\nTEST(DBTest, GetFromImmutableLayer) {\n  do {\n    Options options = CurrentOptions();\n    options.env = env_;\n    options.write_buffer_size = 100000;  // Small write buffer\n    Reopen(&options);\n\n    ASSERT_OK(Put(\"foo\", \"v1\"));\n    ASSERT_EQ(\"v1\", Get(\"foo\"));\n\n    env_->delay_sstable_sync_.Release_Store(env_);   // Block sync calls\n    Put(\"k1\", std::string(100000, 'x'));             // Fill memtable\n    Put(\"k2\", std::string(100000, 'y'));             // Trigger compaction\n    ASSERT_EQ(\"v1\", Get(\"foo\"));\n    env_->delay_sstable_sync_.Release_Store(nullptr);   // Release sync calls\n  } while (ChangeOptions());\n}\n\nTEST(DBTest, GetFromVersions) {\n  do {\n    ASSERT_OK(Put(\"foo\", \"v1\"));\n    dbfull()->TEST_FlushMemTable();\n    ASSERT_EQ(\"v1\", Get(\"foo\"));\n  } while (ChangeOptions());\n}\n\nTEST(DBTest, GetSnapshot) {\n  do {\n    // Try with both a short key and a long key\n    for (int i = 0; i < 2; i++) {\n      std::string key = (i == 0) ? std::string(\"foo\") : std::string(200, 'x');\n      ASSERT_OK(Put(key, \"v1\"));\n      const Snapshot* s1 = db_->GetSnapshot();\n      ASSERT_OK(Put(key, \"v2\"));\n      ASSERT_EQ(\"v2\", Get(key));\n      ASSERT_EQ(\"v1\", Get(key, s1));\n      dbfull()->TEST_FlushMemTable();\n      ASSERT_EQ(\"v2\", Get(key));\n      ASSERT_EQ(\"v1\", Get(key, s1));\n      db_->ReleaseSnapshot(s1);\n    }\n  } while (ChangeOptions());\n}\n\nTEST(DBTest, GetLevel0Ordering) {\n  do {\n    // Check that we process level-0 files in correct order.  The code\n    // below generates two level-0 files where the earlier one comes\n    // before the later one in the level-0 file list since the earlier\n    // one has a smaller \"smallest\" key.\n    ASSERT_OK(Put(\"bar\", \"b\"));\n    ASSERT_OK(Put(\"foo\", \"v1\"));\n    dbfull()->TEST_FlushMemTable();\n    ASSERT_OK(Put(\"foo\", \"v2\"));\n    dbfull()->TEST_FlushMemTable();\n    ASSERT_EQ(\"v2\", Get(\"foo\"));\n  } while (ChangeOptions());\n}\n\nTEST(DBTest, GetOrderedByLevels) {\n  do {\n    ASSERT_OK(Put(\"foo\", \"v1\"));\n    Compact(\"a\", \"z\");\n    ASSERT_EQ(\"v1\", Get(\"foo\"));\n    ASSERT_OK(Put(\"foo\", \"v2\"));\n    ASSERT_EQ(\"v2\", Get(\"foo\"));\n    dbfull()->TEST_FlushMemTable();\n    ASSERT_EQ(\"v2\", Get(\"foo\"));\n  } while (ChangeOptions());\n}\n\nTEST(DBTest, GetPicksCorrectFile) {\n  do {\n    // Arrange to have multiple files in a non-level-0 level.\n    ASSERT_OK(Put(\"a\", \"va\"));\n    Compact(\"a\", \"b\");\n    ASSERT_OK(Put(\"x\", \"vx\"));\n    Compact(\"x\", \"y\");\n    ASSERT_OK(Put(\"f\", \"vf\"));\n    Compact(\"f\", \"g\");\n    ASSERT_EQ(\"va\", Get(\"a\"));\n    ASSERT_EQ(\"vf\", Get(\"f\"));\n    ASSERT_EQ(\"vx\", Get(\"x\"));\n  } while (ChangeOptions());\n}\n",
        "base_contents": "TEST(DBTest, LevelLimitReopen) {\n  Options options = CurrentOptions();\n  Reopen(&options);\n\n  const std::string value(1024 * 1024, ' ');\n  int i = 0;\n  while (NumTableFilesAtLevel(2) == 0) {\n    ASSERT_OK(Put(Key(i++), value));\n  }\n\n  options.num_levels = 1;\n  options.max_bytes_for_level_multiplier_additional.resize(1, 1);\n  Status s = TryReopen(&options);\n  ASSERT_EQ(s.IsCorruption(), true);\n  ASSERT_EQ(s.ToString(),\n            \"Corruption: VersionEdit: db already has \"\n            \"more levels than options.num_levels\");\n\n  options.num_levels = 10;\n  options.max_bytes_for_level_multiplier_additional.resize(10, 1);\n  ASSERT_OK(TryReopen(&options));\n}\n\nTEST(DBTest, Preallocation) {\n  const std::string src = dbname_ + \"/alloc_test\";\n  unique_ptr<WritableFile> srcfile;\n  const EnvOptions soptions;\n  ASSERT_OK(env_->NewWritableFile(src, &srcfile, soptions));\n  srcfile->SetPreallocationBlockSize(1024 * 1024);\n\n  // No writes should mean no preallocation\n  size_t block_size, last_allocated_block;\n  srcfile->GetPreallocationStatus(&block_size, &last_allocated_block);\n  ASSERT_EQ(last_allocated_block, 0UL);\n\n  // Small write should preallocate one block\n  srcfile->Append(\"test\");\n  srcfile->GetPreallocationStatus(&block_size, &last_allocated_block);\n  ASSERT_EQ(last_allocated_block, 1UL);\n\n  // Write an entire preallocation block, make sure we increased by two.\n  std::string buf(block_size, ' ');\n  srcfile->Append(buf);\n  srcfile->GetPreallocationStatus(&block_size, &last_allocated_block);\n  ASSERT_EQ(last_allocated_block, 2UL);\n\n  // Write five more blocks at once, ensure we're where we need to be.\n  buf = std::string(block_size * 5, ' ');\n  srcfile->Append(buf);\n  srcfile->GetPreallocationStatus(&block_size, &last_allocated_block);\n  ASSERT_EQ(last_allocated_block, 7UL);\n}\n\nTEST(DBTest, PutDeleteGet) {\n  do {\n    ASSERT_OK(db_->Put(WriteOptions(), \"foo\", \"v1\"));\n    ASSERT_EQ(\"v1\", Get(\"foo\"));\n    ASSERT_OK(db_->Put(WriteOptions(), \"foo\", \"v2\"));\n    ASSERT_EQ(\"v2\", Get(\"foo\"));\n    ASSERT_OK(db_->Delete(WriteOptions(), \"foo\"));\n    ASSERT_EQ(\"NOT_FOUND\", Get(\"foo\"));\n  } while (ChangeOptions());\n}\n\n\nTEST(DBTest, GetFromImmutableLayer) {\n  do {\n    Options options = CurrentOptions();\n    options.env = env_;\n    options.write_buffer_size = 100000;  // Small write buffer\n    Reopen(&options);\n\n    ASSERT_OK(Put(\"foo\", \"v1\"));\n    ASSERT_EQ(\"v1\", Get(\"foo\"));\n\n    env_->delay_sstable_sync_.Release_Store(env_);   // Block sync calls\n    Put(\"k1\", std::string(100000, 'x'));             // Fill memtable\n    Put(\"k2\", std::string(100000, 'y'));             // Trigger compaction\n    ASSERT_EQ(\"v1\", Get(\"foo\"));\n    env_->delay_sstable_sync_.Release_Store(nullptr);   // Release sync calls\n  } while (ChangeOptions());\n}\n\nTEST(DBTest, GetFromVersions) {\n  do {\n    ASSERT_OK(Put(\"foo\", \"v1\"));\n    dbfull()->TEST_FlushMemTable();\n    ASSERT_EQ(\"v1\", Get(\"foo\"));\n  } while (ChangeOptions());\n}\n\nTEST(DBTest, GetSnapshot) {\n  do {\n    // Try with both a short key and a long key\n    for (int i = 0; i < 2; i++) {\n      std::string key = (i == 0) ? std::string(\"foo\") : std::string(200, 'x');\n      ASSERT_OK(Put(key, \"v1\"));\n      const Snapshot* s1 = db_->GetSnapshot();\n      ASSERT_OK(Put(key, \"v2\"));\n      ASSERT_EQ(\"v2\", Get(key));\n      ASSERT_EQ(\"v1\", Get(key, s1));\n      dbfull()->TEST_FlushMemTable();\n      ASSERT_EQ(\"v2\", Get(key));\n      ASSERT_EQ(\"v1\", Get(key, s1));\n      db_->ReleaseSnapshot(s1);\n    }\n  } while (ChangeOptions());\n}\n\nTEST(DBTest, GetLevel0Ordering) {\n  do {\n    // Check that we process level-0 files in correct order.  The code\n    // below generates two level-0 files where the earlier one comes\n    // before the later one in the level-0 file list since the earlier\n    // one has a smaller \"smallest\" key.\n    ASSERT_OK(Put(\"bar\", \"b\"));\n    ASSERT_OK(Put(\"foo\", \"v1\"));\n    dbfull()->TEST_FlushMemTable();\n    ASSERT_OK(Put(\"foo\", \"v2\"));\n    dbfull()->TEST_FlushMemTable();\n    ASSERT_EQ(\"v2\", Get(\"foo\"));\n  } while (ChangeOptions());\n}\n\nTEST(DBTest, GetOrderedByLevels) {\n  do {\n    ASSERT_OK(Put(\"foo\", \"v1\"));\n    Compact(\"a\", \"z\");\n    ASSERT_EQ(\"v1\", Get(\"foo\"));\n    ASSERT_OK(Put(\"foo\", \"v2\"));\n    ASSERT_EQ(\"v2\", Get(\"foo\"));\n    dbfull()->TEST_FlushMemTable();\n    ASSERT_EQ(\"v2\", Get(\"foo\"));\n  } while (ChangeOptions());\n}\n\nTEST(DBTest, GetPicksCorrectFile) {\n  do {\n    // Arrange to have multiple files in a non-level-0 level.\n    ASSERT_OK(Put(\"a\", \"va\"));\n    Compact(\"a\", \"b\");\n    ASSERT_OK(Put(\"x\", \"vx\"));\n    Compact(\"x\", \"y\");\n    ASSERT_OK(Put(\"f\", \"vf\"));\n    Compact(\"f\", \"g\");\n    ASSERT_EQ(\"va\", Get(\"a\"));\n    ASSERT_EQ(\"vf\", Get(\"f\"));\n    ASSERT_EQ(\"vx\", Get(\"x\"));\n  } while (ChangeOptions());\n}\n",
        "res_region": "TEST(DBTest, LevelLimitReopen) {\n  Options options = CurrentOptions();\n  Reopen(&options);\n\n  const std::string value(1024 * 1024, ' ');\n  int i = 0;\n  while (NumTableFilesAtLevel(2) == 0) {\n    ASSERT_OK(Put(Key(i++), value));\n  }\n\n  options.num_levels = 1;\n  options.max_bytes_for_level_multiplier_additional.resize(1, 1);\n  Status s = TryReopen(&options);\n  ASSERT_EQ(s.IsInvalidArgument(), true);\n  ASSERT_EQ(s.ToString(),\n            \"Invalid argument: db has more levels than options.num_levels\");\n\n  options.num_levels = 10;\n  options.max_bytes_for_level_multiplier_additional.resize(10, 1);\n  ASSERT_OK(TryReopen(&options));\n}\n\nTEST(DBTest, Preallocation) {\n  const std::string src = dbname_ + \"/alloc_test\";\n  unique_ptr<WritableFile> srcfile;\n  const EnvOptions soptions;\n  ASSERT_OK(env_->NewWritableFile(src, &srcfile, soptions));\n  srcfile->SetPreallocationBlockSize(1024 * 1024);\n\n  // No writes should mean no preallocation\n  size_t block_size, last_allocated_block;\n  srcfile->GetPreallocationStatus(&block_size, &last_allocated_block);\n  ASSERT_EQ(last_allocated_block, 0UL);\n\n  // Small write should preallocate one block\n  srcfile->Append(\"test\");\n  srcfile->GetPreallocationStatus(&block_size, &last_allocated_block);\n  ASSERT_EQ(last_allocated_block, 1UL);\n\n  // Write an entire preallocation block, make sure we increased by two.\n  std::string buf(block_size, ' ');\n  srcfile->Append(buf);\n  srcfile->GetPreallocationStatus(&block_size, &last_allocated_block);\n  ASSERT_EQ(last_allocated_block, 2UL);\n\n  // Write five more blocks at once, ensure we're where we need to be.\n  buf = std::string(block_size * 5, ' ');\n  srcfile->Append(buf);\n  srcfile->GetPreallocationStatus(&block_size, &last_allocated_block);\n  ASSERT_EQ(last_allocated_block, 7UL);\n}\n\nTEST(DBTest, PutDeleteGet) {\n  do {\n    ASSERT_OK(db_->Put(WriteOptions(), \"foo\", \"v1\"));\n    ASSERT_EQ(\"v1\", Get(\"foo\"));\n    ASSERT_OK(db_->Put(WriteOptions(), \"foo\", \"v2\"));\n    ASSERT_EQ(\"v2\", Get(\"foo\"));\n    ASSERT_OK(db_->Delete(WriteOptions(), \"foo\"));\n    ASSERT_EQ(\"NOT_FOUND\", Get(\"foo\"));\n  } while (ChangeOptions());\n}\n\n\nTEST(DBTest, GetFromImmutableLayer) {\n  do {\n    Options options = CurrentOptions();\n    options.env = env_;\n    options.write_buffer_size = 100000;  // Small write buffer\n    Reopen(&options);\n\n    ASSERT_OK(Put(\"foo\", \"v1\"));\n    ASSERT_EQ(\"v1\", Get(\"foo\"));\n\n    env_->delay_sstable_sync_.Release_Store(env_);   // Block sync calls\n    Put(\"k1\", std::string(100000, 'x'));             // Fill memtable\n    Put(\"k2\", std::string(100000, 'y'));             // Trigger compaction\n    ASSERT_EQ(\"v1\", Get(\"foo\"));\n    env_->delay_sstable_sync_.Release_Store(nullptr);   // Release sync calls\n  } while (ChangeOptions());\n}\n\nTEST(DBTest, GetFromVersions) {\n  do {\n    ASSERT_OK(Put(\"foo\", \"v1\"));\n    dbfull()->TEST_FlushMemTable();\n    ASSERT_EQ(\"v1\", Get(\"foo\"));\n  } while (ChangeOptions());\n}\n\nTEST(DBTest, GetSnapshot) {\n  do {\n    // Try with both a short key and a long key\n    for (int i = 0; i < 2; i++) {\n      std::string key = (i == 0) ? std::string(\"foo\") : std::string(200, 'x');\n      ASSERT_OK(Put(key, \"v1\"));\n      const Snapshot* s1 = db_->GetSnapshot();\n      ASSERT_OK(Put(key, \"v2\"));\n      ASSERT_EQ(\"v2\", Get(key));\n      ASSERT_EQ(\"v1\", Get(key, s1));\n      dbfull()->TEST_FlushMemTable();\n      ASSERT_EQ(\"v2\", Get(key));\n      ASSERT_EQ(\"v1\", Get(key, s1));\n      db_->ReleaseSnapshot(s1);\n    }\n  } while (ChangeOptions());\n}\n\nTEST(DBTest, GetLevel0Ordering) {\n  do {\n    // Check that we process level-0 files in correct order.  The code\n    // below generates two level-0 files where the earlier one comes\n    // before the later one in the level-0 file list since the earlier\n    // one has a smaller \"smallest\" key.\n    ASSERT_OK(Put(\"bar\", \"b\"));\n    ASSERT_OK(Put(\"foo\", \"v1\"));\n    dbfull()->TEST_FlushMemTable();\n    ASSERT_OK(Put(\"foo\", \"v2\"));\n    dbfull()->TEST_FlushMemTable();\n    ASSERT_EQ(\"v2\", Get(\"foo\"));\n  } while (ChangeOptions());\n}\n\nTEST(DBTest, GetOrderedByLevels) {\n  do {\n    ASSERT_OK(Put(\"foo\", \"v1\"));\n    Compact(\"a\", \"z\");\n    ASSERT_EQ(\"v1\", Get(\"foo\"));\n    ASSERT_OK(Put(\"foo\", \"v2\"));\n    ASSERT_EQ(\"v2\", Get(\"foo\"));\n    dbfull()->TEST_FlushMemTable();\n    ASSERT_EQ(\"v2\", Get(\"foo\"));\n  } while (ChangeOptions());\n}\n\nTEST(DBTest, GetPicksCorrectFile) {\n  do {\n    // Arrange to have multiple files in a non-level-0 level.\n    ASSERT_OK(Put(\"a\", \"va\"));\n    Compact(\"a\", \"b\");\n    ASSERT_OK(Put(\"x\", \"vx\"));\n    Compact(\"x\", \"y\");\n    ASSERT_OK(Put(\"f\", \"vf\"));\n    Compact(\"f\", \"g\");\n    ASSERT_EQ(\"va\", Get(\"a\"));\n    ASSERT_EQ(\"vf\", Get(\"f\"));\n    ASSERT_EQ(\"vx\", Get(\"x\"));\n  } while (ChangeOptions());\n}\n",
        "lookback": "  Options options = CurrentOptions();",
        "lookahead": "TEST(DBTest, GetEncountersEmptyLevel) {",
        "label": [
            "base",
            "one_side_deletion"
        ],
        "start_line": 834,
        "end_line": 1138,
        "merge_gen_region": null,
        "confidence": 0.7721443176269531,
        "hesitated": true
    }
]