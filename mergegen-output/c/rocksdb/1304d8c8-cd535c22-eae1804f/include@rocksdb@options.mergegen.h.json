[
    {
        "a_contents": "  typedef std::vector<std::shared_ptr<TablePropertiesCollector>>\n          TablePropertiesCollectors;\n  TablePropertiesCollectors table_properties_collectors;\n\n  // Allows thread-safe inplace updates.\n  // If inplace_callback function is not set,\n  //   Put(key, new_value) will update inplace the existing_value iff\n  //   * key exists in current memtable\n  //   * new sizeof(new_value) <= sizeof(existing_value)\n  //   * existing_value for that key is a put i.e. kTypeValue\n  // If inplace_callback function is set, check doc for inplace_callback.",
        "b_contents": "  std::vector<std::shared_ptr<TablePropertiesCollector>>\n  table_properties_collectors;\n\n  // Allows thread-safe inplace updates. Requires Updates iff\n  // * key exists in current memtable\n  // * new sizeof(new_value) <= sizeof(old_value)\n  // * old_value for that key is a put i.e. kTypeValue",
        "base_contents": "  std::vector<std::shared_ptr<TablePropertiesCollector>>\n    table_properties_collectors;\n\n  // Allows thread-safe inplace updates. Requires Updates iff\n  // * key exists in current memtable\n  // * new sizeof(new_value) <= sizeof(old_value)\n  // * old_value for that key is a put i.e. kTypeValue",
        "res_region": "  typedef std::vector<std::shared_ptr<TablePropertiesCollector>>\n          TablePropertiesCollectors;\n  TablePropertiesCollectors table_properties_collectors;\n\n  // Allows thread-safe inplace updates.\n  // If inplace_callback function is not set,\n  //   Put(key, new_value) will update inplace the existing_value iff\n  //   * key exists in current memtable\n  //   * new sizeof(new_value) <= sizeof(existing_value)\n  //   * existing_value for that key is a put i.e. kTypeValue\n  // If inplace_callback function is set, check doc for inplace_callback.",
        "lookback": "          TablePropertiesCollectors;",
        "lookahead": "  // Default: false.",
        "label": [
            "ours",
            "base_underutilized"
        ],
        "start_line": 634,
        "end_line": 662,
        "merge_gen_region": null,
        "confidence": 0.6727746725082397,
        "hesitated": true
    },
    {
        "a_contents": "\n\n  // * existing_value - pointer to previous value (from both memtable and sst).\n  //                    nullptr if key doesn't exist\n  // * existing_value_size - sizeof(existing_value). 0 if key doesn't exist\n  // * delta_value - Delta value to be merged with the 'existing_value'.\n  //                 Stored in transaction logs.\n  // * merged_value - Set when delta is applied on the previous value.\n\n  // Applicable only when inplace_update_support is true,\n  // this callback function is called at the time of updating the memtable\n  // as part of a Put operation, lets say Put(key, delta_value). It allows the\n  // 'delta_value' specified as part of the Put operation to be merged with\n  // an 'existing_value' of the 'key' in the database.\n\n  // If the merged value is smaller in size that the 'existing_value',\n  // then this function can update the 'existing_value' buffer inplace if it\n  // wishes to. The callback should return true in this case. (In this case,\n  // the snapshot-semantics of the rocksdb Iterator is not atomic anymore).\n\n  // If the application does not wish to modify the 'existing_value' buffer\n  // inplace, then it should allocate a new buffer and update it by merging the\n  // 'existing_value' and the Put 'delta_value' and set the 'merged_value'\n  // pointer to this buffer. The callback should return false in this case. It\n  // is upto the calling layer to manage the memory returned in 'merged_value'.\n\n  // Please remember that the original call from the application is Put(key,\n  // delta_value). So the transaction log (if enabled) will still contain\n  // (key, delta_value). The 'merged_value' is not stored in the transaction log\n  // Hence the inplace_callback function should be consistent across db reopens.\n\n  // Default: nullptr\n  bool (*inplace_callback)(char* existing_value, size_t existing_value_size,\n                           Slice delta_value, std::string* merged_value);\n\n  // if prefix_extractor is set and bloom_bits is not 0, create prefix bloom\n  // for memtable\n  uint32_t memtable_prefix_bloom_bits;\n\n  // number of hash probes per key\n  uint32_t memtable_prefix_bloom_probes;",
        "b_contents": "\n  // Maximum number of successive merge operations on a key in the memtable.\n  //\n  // When a merge operation is added to the memtable and the maximum number of\n  // successive merges is reached, the value of the key will be calculated and\n  // inserted into the memtable instead of the merge operation. This will\n  // ensure that there are never more than max_successive_merges merge\n  // operations in the memtable.\n  //\n  // Default: 0 (disabled)\n  size_t max_successive_merges;",
        "base_contents": "",
        "res_region": "\n  // * existing_value - pointer to previous value (from both memtable and sst).\n  //                    nullptr if key doesn't exist\n  // * existing_value_size - sizeof(existing_value). 0 if key doesn't exist\n  // * delta_value - Delta value to be merged with the 'existing_value'.\n  //                 Stored in transaction logs.\n  // * merged_value - Set when delta is applied on the previous value.\n\n  // Applicable only when inplace_update_support is true,\n  // this callback function is called at the time of updating the memtable\n  // as part of a Put operation, lets say Put(key, delta_value). It allows the\n  // 'delta_value' specified as part of the Put operation to be merged with\n  // an 'existing_value' of the 'key' in the database.\n\n  // If the merged value is smaller in size that the 'existing_value',\n  // then this function can update the 'existing_value' buffer inplace if it\n  // wishes to. The callback should return true in this case. (In this case,\n  // the snapshot-semantics of the rocksdb Iterator is not atomic anymore).\n\n  // If the application does not wish to modify the 'existing_value' buffer\n  // inplace, then it should allocate a new buffer and update it by merging the\n  // 'existing_value' and the Put 'delta_value' and set the 'merged_value'\n  // pointer to this buffer. The callback should return false in this case. It\n  // is upto the calling layer to manage the memory returned in 'merged_value'.\n\n  // Please remember that the original call from the application is Put(key,\n  // delta_value). So the transaction log (if enabled) will still contain\n  // (key, delta_value). The 'merged_value' is not stored in the transaction log\n  // Hence the inplace_callback function should be consistent across db reopens.\n\n  // Default: nullptr\n  bool (*inplace_callback)(char* existing_value, size_t existing_value_size,\n                           Slice delta_value, std::string* merged_value);\n\n  // if prefix_extractor is set and bloom_bits is not 0, create prefix bloom\n  // for memtable\n  uint32_t memtable_prefix_bloom_bits;\n\n  // number of hash probes per key\n  uint32_t memtable_prefix_bloom_probes;\n\n  // Maximum number of successive merge operations on a key in the memtable.\n  //\n  // When a merge operation is added to the memtable and the maximum number of\n  // successive merges is reached, the value of the key will be calculated and\n  // inserted into the memtable instead of the merge operation. This will\n  // ensure that there are never more than max_successive_merges merge\n  // operations in the memtable.\n  //\n  // Default: 0 (disabled)\n  size_t max_successive_merges;",
        "lookback": "  // * existing_value - pointer to previous value (from both memtable and sst).",
        "lookahead": "};",
        "label": [
            "interleave",
            "one_side_deletion"
        ],
        "start_line": 669,
        "end_line": 724,
        "merge_gen_region": " *_value pointer previous valuefrom mem and and). nullptr key doesn exist *___ - sizeofexistingvalue 0 key doesn exist *__ - value merged the '_'. St in logs // mergedvalue Set delta applied the previous. Apable whenplaceupdatesupport true, this callback is at time updating mem // // // of a operation lets Putkey deltavalue It allows //deltavalue specified part the Put to merged // '_' thekey' the. database // the value smaller size the '_', // this function update '_' bufferplace it whes. callback return in case ( this.In case // snapshotse of rocksdb is atomic). If application does wish modify '_' // in, it should a buffer update it merging //existingvalue and Putdeltavalue and the '_' pointer this. callback return in case It ispto calling to the memory in '_'. Please that original from application Putkey //_). the logif) still // (,_). '_' not in transaction // the in__ function be across res. Default nullptr (*_)(*_,_,::*_); if_actor is and b_ is 0 create b // mem uint_ mem___, delta",
        "confidence": 0.9119947552680969,
        "hesitated": false,
        "resolved": false
    }
]