[
    {
        "a_contents": "constexpr uint32_t kBccPayloadIssuer = 1;\nconstexpr uint32_t kBccPayloadSubject = 2;\nconstexpr int32_t kBccPayloadSubjPubKey = -4670552;\nconstexpr int32_t kBccPayloadKeyUsage = -4670553;\nconstexpr int kP256AffinePointSize = 32;\n\nusing EC_KEY_Ptr = bssl::UniquePtr<EC_KEY>;\nusing EVP_PKEY_Ptr = bssl::UniquePtr<EVP_PKEY>;\nusing EVP_PKEY_CTX_Ptr = bssl::UniquePtr<EVP_PKEY_CTX>;\n\nErrMsgOr<bytevec> ecKeyGetPrivateKey(const EC_KEY* ecKey) {\n    // Extract private key.\n    const BIGNUM* bignum = EC_KEY_get0_private_key(ecKey);\n    if (bignum == nullptr) {\n        return \"Error getting bignum from private key\";\n    }\n    // Pad with zeros in case the length is lesser than 32.\n    bytevec privKey(32, 0);\n    BN_bn2binpad(bignum, privKey.data(), privKey.size());\n    return privKey;\n}\n\nErrMsgOr<bytevec> ecKeyGetPublicKey(const EC_KEY* ecKey) {\n    // Extract public key.\n    auto group = EC_GROUP_Ptr(EC_GROUP_new_by_curve_name(NID_X9_62_prime256v1));\n    if (group.get() == nullptr) {\n        return \"Error creating EC group by curve name\";\n    }\n    const EC_POINT* point = EC_KEY_get0_public_key(ecKey);\n    if (point == nullptr) return \"Error getting ecpoint from public key\";\n\n    int size =\n        EC_POINT_point2oct(group.get(), point, POINT_CONVERSION_UNCOMPRESSED, nullptr, 0, nullptr);\n    if (size == 0) {\n        return \"Error generating public key encoding\";\n    }\n\n    bytevec publicKey;\n    publicKey.resize(size);\n    EC_POINT_point2oct(group.get(), point, POINT_CONVERSION_UNCOMPRESSED, publicKey.data(),\n                       publicKey.size(), nullptr);\n    return publicKey;\n}\n\nErrMsgOr<std::tuple<bytevec, bytevec>> getAffineCoordinates(const bytevec& pubKey) {\n    auto group = EC_GROUP_Ptr(EC_GROUP_new_by_curve_name(NID_X9_62_prime256v1));\n    if (group.get() == nullptr) {\n        return \"Error creating EC group by curve name\";\n    }\n    auto point = EC_POINT_Ptr(EC_POINT_new(group.get()));\n    if (EC_POINT_oct2point(group.get(), point.get(), pubKey.data(), pubKey.size(), nullptr) != 1) {\n        return \"Error decoding publicKey\";\n    }\n    BIGNUM_Ptr x(BN_new());\n    BIGNUM_Ptr y(BN_new());\n    BN_CTX_Ptr ctx(BN_CTX_new());\n    if (!ctx.get()) return \"Failed to create BN_CTX instance\";\n\n    if (!EC_POINT_get_affine_coordinates_GFp(group.get(), point.get(), x.get(), y.get(),\n                                             ctx.get())) {\n        return \"Failed to get affine coordinates from ECPoint\";\n    }\n    bytevec pubX(kP256AffinePointSize);\n    bytevec pubY(kP256AffinePointSize);\n    if (BN_bn2binpad(x.get(), pubX.data(), kP256AffinePointSize) != kP256AffinePointSize) {\n        return \"Error in converting absolute value of x coordinate to big-endian\";\n    }\n    if (BN_bn2binpad(y.get(), pubY.data(), kP256AffinePointSize) != kP256AffinePointSize) {\n        return \"Error in converting absolute value of y coordinate to big-endian\";\n    }\n    return std::make_tuple(std::move(pubX), std::move(pubY));\n}\n\nErrMsgOr<std::tuple<bytevec, bytevec>> generateEc256KeyPair() {\n    auto ec_key = EC_KEY_Ptr(EC_KEY_new());\n    if (ec_key.get() == nullptr) {\n        return \"Failed to allocate ec key\";\n    }\n\n    auto group = EC_GROUP_Ptr(EC_GROUP_new_by_curve_name(NID_X9_62_prime256v1));\n    if (group.get() == nullptr) {\n        return \"Error creating EC group by curve name\";\n    }\n\n    if (EC_KEY_set_group(ec_key.get(), group.get()) != 1 ||\n        EC_KEY_generate_key(ec_key.get()) != 1 || EC_KEY_check_key(ec_key.get()) < 0) {\n        return \"Error generating key\";\n    }\n\n    auto privKey = ecKeyGetPrivateKey(ec_key.get());\n    if (!privKey) return privKey.moveMessage();\n\n    auto pubKey = ecKeyGetPublicKey(ec_key.get());\n    if (!pubKey) return pubKey.moveMessage();\n\n    return std::make_tuple(pubKey.moveValue(), privKey.moveValue());\n}\n\nErrMsgOr<std::tuple<bytevec, bytevec>> generateX25519KeyPair() {\n    /* Generate X25519 key pair */\n    bytevec pubKey(X25519_PUBLIC_VALUE_LEN);\n    bytevec privKey(X25519_PRIVATE_KEY_LEN);\n    X25519_keypair(pubKey.data(), privKey.data());\n    return std::make_tuple(std::move(pubKey), std::move(privKey));\n}\n\nErrMsgOr<std::tuple<bytevec, bytevec>> generateED25519KeyPair() {\n    /* Generate ED25519 key pair */\n    bytevec pubKey(ED25519_PUBLIC_KEY_LEN);\n    bytevec privKey(ED25519_PRIVATE_KEY_LEN);\n    ED25519_keypair(pubKey.data(), privKey.data());\n    return std::make_tuple(std::move(pubKey), std::move(privKey));\n}\n\nErrMsgOr<std::tuple<bytevec, bytevec>> generateKeyPair(int32_t supportedEekCurve, bool isEek) {\n    switch (supportedEekCurve) {\n    case RpcHardwareInfo::CURVE_25519:\n        if (isEek) {\n            return generateX25519KeyPair();\n        }\n        return generateED25519KeyPair();\n    case RpcHardwareInfo::CURVE_P256:\n        return generateEc256KeyPair();\n    default:\n        return \"Unknown EEK Curve.\";\n    }\n}\n\nErrMsgOr<bytevec> constructCoseKey(int32_t supportedEekCurve, const bytevec& eekId,\n                                   const bytevec& pubKey) {\n    CoseKeyType keyType;\n    CoseKeyAlgorithm algorithm;\n    CoseKeyCurve curve;\n    bytevec pubX;\n    bytevec pubY;\n    switch (supportedEekCurve) {\n    case RpcHardwareInfo::CURVE_25519:\n        keyType = OCTET_KEY_PAIR;\n        algorithm = (eekId.empty()) ? EDDSA : ECDH_ES_HKDF_256;\n        curve = (eekId.empty()) ? ED25519 : cppcose::X25519;\n        pubX = pubKey;\n        break;\n    case RpcHardwareInfo::CURVE_P256: {\n        keyType = EC2;\n        algorithm = (eekId.empty()) ? ES256 : ECDH_ES_HKDF_256;\n        curve = P256;\n        auto affineCoordinates = getAffineCoordinates(pubKey);\n        if (!affineCoordinates) return affineCoordinates.moveMessage();\n        std::tie(pubX, pubY) = affineCoordinates.moveValue();\n    } break;\n    default:\n        return \"Unknown EEK Curve.\";\n    }\n    cppbor::Map coseKey = cppbor::Map()\n                              .add(CoseKey::KEY_TYPE, keyType)\n                              .add(CoseKey::ALGORITHM, algorithm)\n                              .add(CoseKey::CURVE, curve)\n                              .add(CoseKey::PUBKEY_X, pubX);\n\n    if (!pubY.empty()) coseKey.add(CoseKey::PUBKEY_Y, pubY);\n    if (!eekId.empty()) coseKey.add(CoseKey::KEY_ID, eekId);\n\n    return coseKey.canonicalize().encode();\n}\n",
        "b_contents": "constexpr uint32_t kBccPayloadIssuer = 1;\nconstexpr uint32_t kBccPayloadSubject = 2;\nconstexpr int32_t kBccPayloadSubjPubKey = -4670552;\nconstexpr int32_t kBccPayloadKeyUsage = -4670553;\n",
        "base_contents": "",
        "res_region": "constexpr uint32_t kBccPayloadIssuer = 1;\nconstexpr uint32_t kBccPayloadSubject = 2;\nconstexpr int32_t kBccPayloadSubjPubKey = -4670552;\nconstexpr int32_t kBccPayloadKeyUsage = -4670553;\nconstexpr int kP256AffinePointSize = 32;\n\nusing EC_KEY_Ptr = bssl::UniquePtr<EC_KEY>;\nusing EVP_PKEY_Ptr = bssl::UniquePtr<EVP_PKEY>;\nusing EVP_PKEY_CTX_Ptr = bssl::UniquePtr<EVP_PKEY_CTX>;\n\nErrMsgOr<bytevec> ecKeyGetPrivateKey(const EC_KEY* ecKey) {\n    // Extract private key.\n    const BIGNUM* bignum = EC_KEY_get0_private_key(ecKey);\n    if (bignum == nullptr) {\n        return \"Error getting bignum from private key\";\n    }\n    // Pad with zeros in case the length is lesser than 32.\n    bytevec privKey(32, 0);\n    BN_bn2binpad(bignum, privKey.data(), privKey.size());\n    return privKey;\n}\n\nErrMsgOr<bytevec> ecKeyGetPublicKey(const EC_KEY* ecKey) {\n    // Extract public key.\n    auto group = EC_GROUP_Ptr(EC_GROUP_new_by_curve_name(NID_X9_62_prime256v1));\n    if (group.get() == nullptr) {\n        return \"Error creating EC group by curve name\";\n    }\n    const EC_POINT* point = EC_KEY_get0_public_key(ecKey);\n    if (point == nullptr) return \"Error getting ecpoint from public key\";\n\n    int size =\n        EC_POINT_point2oct(group.get(), point, POINT_CONVERSION_UNCOMPRESSED, nullptr, 0, nullptr);\n    if (size == 0) {\n        return \"Error generating public key encoding\";\n    }\n\n    bytevec publicKey;\n    publicKey.resize(size);\n    EC_POINT_point2oct(group.get(), point, POINT_CONVERSION_UNCOMPRESSED, publicKey.data(),\n                       publicKey.size(), nullptr);\n    return publicKey;\n}\n\nErrMsgOr<std::tuple<bytevec, bytevec>> getAffineCoordinates(const bytevec& pubKey) {\n    auto group = EC_GROUP_Ptr(EC_GROUP_new_by_curve_name(NID_X9_62_prime256v1));\n    if (group.get() == nullptr) {\n        return \"Error creating EC group by curve name\";\n    }\n    auto point = EC_POINT_Ptr(EC_POINT_new(group.get()));\n    if (EC_POINT_oct2point(group.get(), point.get(), pubKey.data(), pubKey.size(), nullptr) != 1) {\n        return \"Error decoding publicKey\";\n    }\n    BIGNUM_Ptr x(BN_new());\n    BIGNUM_Ptr y(BN_new());\n    BN_CTX_Ptr ctx(BN_CTX_new());\n    if (!ctx.get()) return \"Failed to create BN_CTX instance\";\n\n    if (!EC_POINT_get_affine_coordinates_GFp(group.get(), point.get(), x.get(), y.get(),\n                                             ctx.get())) {\n        return \"Failed to get affine coordinates from ECPoint\";\n    }\n    bytevec pubX(kP256AffinePointSize);\n    bytevec pubY(kP256AffinePointSize);\n    if (BN_bn2binpad(x.get(), pubX.data(), kP256AffinePointSize) != kP256AffinePointSize) {\n        return \"Error in converting absolute value of x coordinate to big-endian\";\n    }\n    if (BN_bn2binpad(y.get(), pubY.data(), kP256AffinePointSize) != kP256AffinePointSize) {\n        return \"Error in converting absolute value of y coordinate to big-endian\";\n    }\n    return std::make_tuple(std::move(pubX), std::move(pubY));\n}\n\nErrMsgOr<std::tuple<bytevec, bytevec>> generateEc256KeyPair() {\n    auto ec_key = EC_KEY_Ptr(EC_KEY_new());\n    if (ec_key.get() == nullptr) {\n        return \"Failed to allocate ec key\";\n    }\n\n    auto group = EC_GROUP_Ptr(EC_GROUP_new_by_curve_name(NID_X9_62_prime256v1));\n    if (group.get() == nullptr) {\n        return \"Error creating EC group by curve name\";\n    }\n\n    if (EC_KEY_set_group(ec_key.get(), group.get()) != 1 ||\n        EC_KEY_generate_key(ec_key.get()) != 1 || EC_KEY_check_key(ec_key.get()) < 0) {\n        return \"Error generating key\";\n    }\n\n    auto privKey = ecKeyGetPrivateKey(ec_key.get());\n    if (!privKey) return privKey.moveMessage();\n\n    auto pubKey = ecKeyGetPublicKey(ec_key.get());\n    if (!pubKey) return pubKey.moveMessage();\n\n    return std::make_tuple(pubKey.moveValue(), privKey.moveValue());\n}\n\nErrMsgOr<std::tuple<bytevec, bytevec>> generateX25519KeyPair() {\n    /* Generate X25519 key pair */\n    bytevec pubKey(X25519_PUBLIC_VALUE_LEN);\n    bytevec privKey(X25519_PRIVATE_KEY_LEN);\n    X25519_keypair(pubKey.data(), privKey.data());\n    return std::make_tuple(std::move(pubKey), std::move(privKey));\n}\n\nErrMsgOr<std::tuple<bytevec, bytevec>> generateED25519KeyPair() {\n    /* Generate ED25519 key pair */\n    bytevec pubKey(ED25519_PUBLIC_KEY_LEN);\n    bytevec privKey(ED25519_PRIVATE_KEY_LEN);\n    ED25519_keypair(pubKey.data(), privKey.data());\n    return std::make_tuple(std::move(pubKey), std::move(privKey));\n}\n\nErrMsgOr<std::tuple<bytevec, bytevec>> generateKeyPair(int32_t supportedEekCurve, bool isEek) {\n    switch (supportedEekCurve) {\n    case RpcHardwareInfo::CURVE_25519:\n        if (isEek) {\n            return generateX25519KeyPair();\n        }\n        return generateED25519KeyPair();\n    case RpcHardwareInfo::CURVE_P256:\n        return generateEc256KeyPair();\n    default:\n        return \"Unknown EEK Curve.\";\n    }\n}\n\nErrMsgOr<bytevec> constructCoseKey(int32_t supportedEekCurve, const bytevec& eekId,\n                                   const bytevec& pubKey) {\n    CoseKeyType keyType;\n    CoseKeyAlgorithm algorithm;\n    CoseKeyCurve curve;\n    bytevec pubX;\n    bytevec pubY;\n    switch (supportedEekCurve) {\n    case RpcHardwareInfo::CURVE_25519:\n        keyType = OCTET_KEY_PAIR;\n        algorithm = (eekId.empty()) ? EDDSA : ECDH_ES_HKDF_256;\n        curve = (eekId.empty()) ? ED25519 : cppcose::X25519;\n        pubX = pubKey;\n        break;\n    case RpcHardwareInfo::CURVE_P256: {\n        keyType = EC2;\n        algorithm = (eekId.empty()) ? ES256 : ECDH_ES_HKDF_256;\n        curve = P256;\n        auto affineCoordinates = getAffineCoordinates(pubKey);\n        if (!affineCoordinates) return affineCoordinates.moveMessage();\n        std::tie(pubX, pubY) = affineCoordinates.moveValue();\n    } break;\n    default:\n        return \"Unknown EEK Curve.\";\n    }\n    cppbor::Map coseKey = cppbor::Map()\n                              .add(CoseKey::KEY_TYPE, keyType)\n                              .add(CoseKey::ALGORITHM, algorithm)\n                              .add(CoseKey::CURVE, curve)\n                              .add(CoseKey::PUBKEY_X, pubX);\n\n    if (!pubY.empty()) coseKey.add(CoseKey::PUBKEY_Y, pubY);\n    if (!eekId.empty()) coseKey.add(CoseKey::KEY_ID, eekId);\n\n    return coseKey.canonicalize().encode();\n}\n",
        "lookback": "constexpr uint32_t kBccPayloadSubject = 2;",
        "lookahead": "bytevec kTestMacKey(32 /* count */, 0 /* byte value */);",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 34,
        "end_line": 207,
        "merge_gen_region": " uint_ kBPayloadss =; uint_tccSubject =; int32tccSubPubKey -70; int32tccKey =4655; intPAffineSize 32 using___ =sslUnique<_>;ECKEY using___Ptr b::PtrEVPPKEY using EVPPKEYPtr b::PtrEVPPKEY using EVPPKEYCTXPtr b::PtrEVPPKEYCTX ErrOrbyte>KeyPrivate( ECKEY ec) // private. BIGNUM big = =__0privatekeyec); (num nullptr) returnError big from private\"; // with in case length less than.vec priv(32 0 BNbnbiadbig,Keydata priv.()); priv; }Msg<vec ecGet( ECKEY ec) // public. group ECGROUPPtrECGROUPnewbycurvenameNIDX_9____256v)); (.() nullptr { returnError EC by curve\"; const_* =__0publickeyec); ( ==) \" gettingpoint public\"; size ECPOINTpointoctgroupget point POINTCONVERSIONUN,COMPRESSED nullptr 0 nullptr ifsize 0 { \" generating key\"; byte public;Keyresizesize ECPOINTpointpoint);__2octgroupget point POINTCONVERSIONUN,COMPRESSED nullptr 0 nullptr",
        "confidence": 0.9472143650054932,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "",
        "b_contents": "    auto key = CoseKey::parseEd25519(selfSigned ? *serializedKey : signingCoseKey);\n    if (!key) return \"Bad signing key: \" + key.moveMessage();\n",
        "base_contents": "    auto key =\n            CoseKey::parseEd25519(selfSigned ? serializedKey->asBstr()->value() : signingCoseKey);\n    if (!key) return \"Bad signing key: \" + key.moveMessage();\n",
        "res_region": "",
        "lookback": "        cppbor::Array().add(\"Signature1\").add(*protectedParams).add(aad).add(*payload).encode();",
        "lookahead": "    bytevec signatureInput =",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 355,
        "end_line": 365,
        "merge_gen_region": null,
        "confidence": 0.7235945463180542,
        "hesitated": true
    }
]