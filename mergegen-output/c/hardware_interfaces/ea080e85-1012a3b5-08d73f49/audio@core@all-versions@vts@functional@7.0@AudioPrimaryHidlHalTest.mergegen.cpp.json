[
    {
        "a_contents": "\nstatic const std::vector<DeviceConfigParameter>& getOutputDeviceCompressedConfigParameters(\n        const AudioConfigBase& configToMatch) {\n    static const std::vector<DeviceConfigParameter> parameters = [&] {\n        auto allParams = getOutputDeviceConfigParameters();\n        std::vector<DeviceConfigParameter> compressedParams;\n        std::copy_if(allParams.begin(), allParams.end(), std::back_inserter(compressedParams),\n                     [&](auto cfg) {\n                         if (std::get<PARAM_CONFIG>(cfg).base != configToMatch) return false;\n                         const auto& flags = std::get<PARAM_FLAGS>(cfg);\n                         return std::find_if(flags.begin(), flags.end(), [](const auto& flag) {\n                                    return flag ==\n                                           toString(xsd::AudioInOutFlag::\n                                                            AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD);\n                                }) != flags.end();\n                     });\n        return compressedParams;\n    }();\n    return parameters;\n}\n\nclass CompressedOffloadOutputStreamTest : public PcmOnlyConfigOutputStreamTest {\n  public:\n    void loadData(const std::string& fileName, std::vector<uint8_t>* data) {\n        std::ifstream is(fileName, std::ios::in | std::ios::binary);\n        ASSERT_TRUE(is.good()) << \"Failed to open file \" << fileName;\n        is.seekg(0, is.end);\n        data->reserve(data->size() + is.tellg());\n        is.seekg(0, is.beg);\n        data->insert(data->end(), std::istreambuf_iterator<char>(is),\n                     std::istreambuf_iterator<char>());\n        ASSERT_TRUE(!is.fail()) << \"Failed to read from file \" << fileName;\n    }\n};\n\nclass OffloadCallbacks : public IStreamOutCallback {\n  public:\n    Return<void> onDrainReady() override {\n        ALOGI(\"onDrainReady\");\n        {\n            std::lock_guard lg(mLock);\n            mOnDrainReady = true;\n        }\n        mCondVar.notify_one();\n        return {};\n    }\n    Return<void> onWriteReady() override { return {}; }\n    Return<void> onError() override {\n        ALOGW(\"onError\");\n        {\n            std::lock_guard lg(mLock);\n            mOnError = true;\n        }\n        mCondVar.notify_one();\n        return {};\n    }\n    bool waitForDrainReadyOrError() {\n        std::unique_lock l(mLock);\n        if (!mOnDrainReady && !mOnError) {\n            mCondVar.wait(l, [&]() { return mOnDrainReady || mOnError; });\n        }\n        const bool success = !mOnError;\n        mOnDrainReady = mOnError = false;\n        return success;\n    }\n\n  private:\n    std::mutex mLock;\n    bool mOnDrainReady = false;\n    bool mOnError = false;\n    std::condition_variable mCondVar;\n};\n\nTEST_P(CompressedOffloadOutputStreamTest, Mp3FormatGaplessOffload) {\n    doc::test(\"Check that compressed offload mix ports for MP3 implement gapless offload\");\n    const auto& flags = getOutputFlags();\n    const bool isNewDeviceLaunchingOnTPlus = property_get_int32(\"ro.vendor.api_level\", 0) >= 33;\n    // See test instantiation, only offload MP3 mix ports are used.\n    if (std::find_if(flags.begin(), flags.end(), [](const auto& flag) {\n            return flag == toString(xsd::AudioInOutFlag::AUDIO_OUTPUT_FLAG_GAPLESS_OFFLOAD);\n        }) == flags.end()) {\n        if (isNewDeviceLaunchingOnTPlus) {\n            FAIL() << \"New devices launching on Android T+ must support gapless offload, \"\n                   << \"see VSR-4.3-001\";\n        } else {\n            GTEST_SKIP() << \"Compressed offload mix port does not support gapless offload\";\n        }\n    }\n    std::vector<uint8_t> offloadData;\n    ASSERT_NO_FATAL_FAILURE(loadData(\"/data/local/tmp/sine882hz3s.mp3\", &offloadData));\n    ASSERT_FALSE(offloadData.empty());\n    ASSERT_NO_FATAL_FAILURE(createPatchIfNeeded());\n    const int presentationeEndPrecisionMs = 1000;\n    const int sampleRate = 44100;\n    const int significantSampleNumber = (presentationeEndPrecisionMs * sampleRate) / 1000;\n    const int delay = 576 + 1000;\n    const int padding = 756 + 1000;\n    const int durationMs = 3000 - 44;\n    auto start = std::chrono::steady_clock::now();\n    auto callbacks = sp<OffloadCallbacks>::make();\n    std::mutex presentationEndLock;\n    std::vector<float> presentationEndTimes;\n    // StreamWriter plays 'offloadData' in a loop, possibly using multiple calls to 'write', this\n    // depends on the relative sizes of 'offloadData' and the HAL buffer. Writer calls 'onDataStart'\n    // each time it starts writing the buffer from the beginning, and 'onDataWrap' callback each\n    // time it wraps around the buffer.\n    StreamWriter writer(\n            stream.get(), stream->getBufferSize(), std::move(offloadData),\n            [&]() /* onDataStart */ { start = std::chrono::steady_clock::now(); },\n            [&]() /* onDataWrap */ {\n                Return<Result> ret(Result::OK);\n                // Decrease the volume since the test plays a loud sine wave.\n                ret = stream->setVolume(0.1, 0.1);\n                if (!ret.isOk() || ret != Result::OK) {\n                    ALOGE(\"%s: setVolume failed: %s\", __func__, toString(ret).c_str());\n                    return false;\n                }\n                ret = Parameters::set(\n                        stream, {{AUDIO_OFFLOAD_CODEC_DELAY_SAMPLES, std::to_string(delay)},\n                                 {AUDIO_OFFLOAD_CODEC_PADDING_SAMPLES, std::to_string(padding)}});\n                if (!ret.isOk() || ret != Result::OK) {\n                    ALOGE(\"%s: setParameters failed: %s\", __func__, toString(ret).c_str());\n                    return false;\n                }\n                ret = stream->drain(AudioDrain::EARLY_NOTIFY);\n                if (!ret.isOk() || ret != Result::OK) {\n                    ALOGE(\"%s: drain failed: %s\", __func__, toString(ret).c_str());\n                    return false;\n                }\n                // FIXME: On some SoCs intermittent errors are possible, ignore them.\n                if (callbacks->waitForDrainReadyOrError()) {\n                    const float duration = std::chrono::duration_cast<std::chrono::milliseconds>(\n                                                   std::chrono::steady_clock::now() - start)\n                                                   .count();\n                    std::lock_guard lg(presentationEndLock);\n                    presentationEndTimes.push_back(duration);\n                }\n                return true;\n            });\n    ASSERT_OK(stream->setCallback(callbacks));\n    ASSERT_TRUE(writer.start());\n    // How many times to loop the track so that the sum of gapless delay and padding from\n    // the first presentation end to the last is at least 'presentationeEndPrecisionMs'.\n    const int playbackNumber = (int)(significantSampleNumber / ((float)delay + padding) + 1);\n    for (bool done = false; !done;) {\n        usleep(presentationeEndPrecisionMs * 1000);\n        {\n            std::lock_guard lg(presentationEndLock);\n            done = presentationEndTimes.size() >= playbackNumber;\n        }\n        ASSERT_FALSE(writer.hasError()) << \"Recent write or drain operation has failed\";\n    }\n    const float avgDuration =\n            std::accumulate(presentationEndTimes.begin(), presentationEndTimes.end(), 0.0) /\n            presentationEndTimes.size();\n    std::stringstream observedEndTimes;\n    std::copy(presentationEndTimes.begin(), presentationEndTimes.end(),\n              std::ostream_iterator<float>(observedEndTimes, \", \"));\n    EXPECT_NEAR(durationMs, avgDuration, presentationeEndPrecisionMs * 0.1)\n            << \"Observed durations: \" << observedEndTimes.str();\n    writer.stop();\n    EXPECT_OK(stream->clearCallback());\n    releasePatchIfNeeded();\n}\n\nINSTANTIATE_TEST_CASE_P(\n        CompressedOffloadOutputStream, CompressedOffloadOutputStreamTest,\n        ::testing::ValuesIn(getOutputDeviceCompressedConfigParameters(AudioConfigBase{\n                .format = xsd::toString(xsd::AudioFormat::AUDIO_FORMAT_MP3),\n                .sampleRateHz = 44100,\n                .channelMask = xsd::toString(xsd::AudioChannelMask::AUDIO_CHANNEL_OUT_STEREO)})),\n        &DeviceConfigParameterToString);\nGTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(CompressedOffloadOutputStreamTest);",
        "b_contents": "\nstatic const std::vector<DeviceConfigParameter>& getOutputDeviceCompressedConfigParameters(\n        const AudioConfigBase& configToMatch) {\n    static const std::vector<DeviceConfigParameter> parameters = [&] {\n        auto allParams = getOutputDeviceConfigParameters();\n        std::vector<DeviceConfigParameter> compressedParams;\n        std::copy_if(allParams.begin(), allParams.end(), std::back_inserter(compressedParams),\n                     [&](auto cfg) {\n                         if (std::get<PARAM_CONFIG>(cfg).base != configToMatch) return false;\n                         const auto& flags = std::get<PARAM_FLAGS>(cfg);\n                         return std::find_if(flags.begin(), flags.end(), [](const auto& flag) {\n                                    return flag ==\n                                           toString(xsd::AudioInOutFlag::\n                                                            AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD);\n                                }) != flags.end();\n                     });\n        return compressedParams;\n    }();\n    return parameters;\n}\n\nclass CompressedOffloadOutputStreamTest : public PcmOnlyConfigOutputStreamTest {\n  public:\n    void loadData(const std::string& fileName, std::vector<uint8_t>* data) {\n        std::ifstream is(fileName, std::ios::in | std::ios::binary);\n        ASSERT_TRUE(is.good()) << \"Failed to open file \" << fileName;\n        is.seekg(0, is.end);\n        data->reserve(data->size() + is.tellg());\n        is.seekg(0, is.beg);\n        data->insert(data->end(), std::istreambuf_iterator<char>(is),\n                     std::istreambuf_iterator<char>());\n        ASSERT_TRUE(!is.fail()) << \"Failed to read from file \" << fileName;\n    }\n};\n\nTEST_P(CompressedOffloadOutputStreamTest, Mp3FormatGaplessOffload) {\n    doc::test(\"Check that compressed offload mix ports for MP3 implement gapless offload\");\n    const auto& flags = getOutputFlags();\n    if (std::find_if(flags.begin(), flags.end(), [](const auto& flag) {\n            return flag == toString(xsd::AudioInOutFlag::AUDIO_OUTPUT_FLAG_GAPLESS_OFFLOAD);\n        }) == flags.end()) {\n        GTEST_SKIP() << \"Compressed offload mix port does not support gapless offload\";\n    }\n    // FIXME: The presentation position is not updated if there is no zero padding in data.\n    std::vector<uint8_t> offloadData(stream->getBufferSize());\n    ASSERT_NO_FATAL_FAILURE(loadData(\"/data/local/tmp/sine882hz3s.mp3\", &offloadData));\n    ASSERT_FALSE(offloadData.empty());\n    ASSERT_NO_FATAL_FAILURE(createPatchIfNeeded());\n    const int presentationeEndPrecisionMs = 1000;\n    const int sampleRate = 44100;\n    const int significantSampleNumber = (presentationeEndPrecisionMs * sampleRate) / 1000;\n    const int delay = 576 + 1000;\n    const int padding = 756 + 1000;\n    const int durationMs = 3000 - 44;\n    // StreamWriter plays 'offloadData' in a loop, possibly using multiple calls to 'write',\n    // this depends on the relative sizes of 'offloadData' and the HAL buffer. Writer calls\n    // 'onDataWrap' callback each time it wraps around the buffer.\n    StreamWriter writer(\n            stream.get(), stream->getBufferSize(), std::move(offloadData), [&]() /* onDataWrap */ {\n                Parameters::set(stream,\n                                {{AUDIO_OFFLOAD_CODEC_DELAY_SAMPLES, std::to_string(delay)},\n                                 {AUDIO_OFFLOAD_CODEC_PADDING_SAMPLES, std::to_string(padding)}});\n                stream->drain(AudioDrain::EARLY_NOTIFY);\n            });\n    ASSERT_TRUE(writer.start());\n    ASSERT_TRUE(writer.waitForAtLeastOneCycle());\n    // Decrease the volume since the test plays a loud sine wave.\n    ASSERT_OK(stream->setVolume(0.1, 0.1));\n    // How many times to loop the track so that the sum of gapless delay and padding from\n    // the first presentation end to the last is at least 'presentationeEndPrecisionMs'.\n    const int playbackNumber = (int)(significantSampleNumber / ((float)delay + padding) + 1);\n    std::vector<float> presentationEndTimes;\n    uint64_t previousPosition = std::numeric_limits<uint64_t>::max();\n    for (int i = 0; i < playbackNumber; ++i) {\n        const auto start = std::chrono::steady_clock::now();\n        ASSERT_NO_FATAL_FAILURE(\n                waitForPresentationPositionAdvance(writer, &previousPosition, &previousPosition));\n        presentationEndTimes.push_back(std::chrono::duration_cast<std::chrono::milliseconds>(\n                                               std::chrono::steady_clock::now() - start)\n                                               .count());\n    }\n    const float avgDuration =\n            std::accumulate(presentationEndTimes.begin(), presentationEndTimes.end(), 0.0) /\n            presentationEndTimes.size();\n    EXPECT_NEAR(durationMs, avgDuration, presentationeEndPrecisionMs * 0.1);\n    writer.stop();\n    releasePatchIfNeeded();\n}\n\nINSTANTIATE_TEST_CASE_P(\n        CompressedOffloadOutputStream, CompressedOffloadOutputStreamTest,\n        ::testing::ValuesIn(getOutputDeviceCompressedConfigParameters(AudioConfigBase{\n                .format = xsd::toString(xsd::AudioFormat::AUDIO_FORMAT_MP3),\n                .sampleRateHz = 44100,\n                .channelMask = xsd::toString(xsd::AudioChannelMask::AUDIO_CHANNEL_OUT_STEREO)})),\n        &DeviceConfigParameterToString);\nGTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(CompressedOffloadOutputStreamTest);",
        "base_contents": "",
        "res_region": "\nstatic const std::vector<DeviceConfigParameter>& getOutputDeviceCompressedConfigParameters(\n        const AudioConfigBase& configToMatch) {\n    static const std::vector<DeviceConfigParameter> parameters = [&] {\n        auto allParams = getOutputDeviceConfigParameters();\n        std::vector<DeviceConfigParameter> compressedParams;\n        std::copy_if(allParams.begin(), allParams.end(), std::back_inserter(compressedParams),\n                     [&](auto cfg) {\n                         if (std::get<PARAM_CONFIG>(cfg).base != configToMatch) return false;\n                         const auto& flags = std::get<PARAM_FLAGS>(cfg);\n                         return std::find_if(flags.begin(), flags.end(), [](const auto& flag) {\n                                    return flag ==\n                                           toString(xsd::AudioInOutFlag::\n                                                            AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD);\n                                }) != flags.end();\n                     });\n        return compressedParams;\n    }();\n    return parameters;\n}\n\nclass CompressedOffloadOutputStreamTest : public PcmOnlyConfigOutputStreamTest {\n  public:\n    void loadData(const std::string& fileName, std::vector<uint8_t>* data) {\n        std::ifstream is(fileName, std::ios::in | std::ios::binary);\n        ASSERT_TRUE(is.good()) << \"Failed to open file \" << fileName;\n        is.seekg(0, is.end);\n        data->reserve(data->size() + is.tellg());\n        is.seekg(0, is.beg);\n        data->insert(data->end(), std::istreambuf_iterator<char>(is),\n                     std::istreambuf_iterator<char>());\n        ASSERT_TRUE(!is.fail()) << \"Failed to read from file \" << fileName;\n    }\n};\n\nclass OffloadCallbacks : public IStreamOutCallback {\n  public:\n    Return<void> onDrainReady() override {\n        ALOGI(\"onDrainReady\");\n        {\n            std::lock_guard lg(mLock);\n            mOnDrainReady = true;\n        }\n        mCondVar.notify_one();\n        return {};\n    }\n    Return<void> onWriteReady() override { return {}; }\n    Return<void> onError() override {\n        ALOGW(\"onError\");\n        {\n            std::lock_guard lg(mLock);\n            mOnError = true;\n        }\n        mCondVar.notify_one();\n        return {};\n    }\n    bool waitForDrainReadyOrError() {\n        std::unique_lock l(mLock);\n        if (!mOnDrainReady && !mOnError) {\n            mCondVar.wait(l, [&]() { return mOnDrainReady || mOnError; });\n        }\n        const bool success = !mOnError;\n        mOnDrainReady = mOnError = false;\n        return success;\n    }\n\n  private:\n    std::mutex mLock;\n    bool mOnDrainReady = false;\n    bool mOnError = false;\n    std::condition_variable mCondVar;\n};\n\nTEST_P(CompressedOffloadOutputStreamTest, Mp3FormatGaplessOffload) {\n    doc::test(\"Check that compressed offload mix ports for MP3 implement gapless offload\");\n    const auto& flags = getOutputFlags();\n    const bool isNewDeviceLaunchingOnTPlus = property_get_int32(\"ro.vendor.api_level\", 0) >= 33;\n    // See test instantiation, only offload MP3 mix ports are used.\n    if (std::find_if(flags.begin(), flags.end(), [](const auto& flag) {\n            return flag == toString(xsd::AudioInOutFlag::AUDIO_OUTPUT_FLAG_GAPLESS_OFFLOAD);\n        }) == flags.end()) {\n        if (isNewDeviceLaunchingOnTPlus) {\n            FAIL() << \"New devices launching on Android T+ must support gapless offload, \"\n                   << \"see VSR-4.3-001\";\n        } else {\n            GTEST_SKIP() << \"Compressed offload mix port does not support gapless offload\";\n        }\n    }\n    std::vector<uint8_t> offloadData;\n    ASSERT_NO_FATAL_FAILURE(loadData(\"/data/local/tmp/sine882hz3s.mp3\", &offloadData));\n    ASSERT_FALSE(offloadData.empty());\n    ASSERT_NO_FATAL_FAILURE(createPatchIfNeeded());\n    const int presentationeEndPrecisionMs = 1000;\n    const int sampleRate = 44100;\n    const int significantSampleNumber = (presentationeEndPrecisionMs * sampleRate) / 1000;\n    const int delay = 576 + 1000;\n    const int padding = 756 + 1000;\n    const int durationMs = 3000 - 44;\n    auto start = std::chrono::steady_clock::now();\n    auto callbacks = sp<OffloadCallbacks>::make();\n    std::mutex presentationEndLock;\n    std::vector<float> presentationEndTimes;\n    // StreamWriter plays 'offloadData' in a loop, possibly using multiple calls to 'write', this\n    // depends on the relative sizes of 'offloadData' and the HAL buffer. Writer calls 'onDataStart'\n    // each time it starts writing the buffer from the beginning, and 'onDataWrap' callback each\n    // time it wraps around the buffer.\n    StreamWriter writer(\n            stream.get(), stream->getBufferSize(), std::move(offloadData),\n            [&]() /* onDataStart */ { start = std::chrono::steady_clock::now(); },\n            [&]() /* onDataWrap */ {\n                Return<Result> ret(Result::OK);\n                // Decrease the volume since the test plays a loud sine wave.\n                ret = stream->setVolume(0.1, 0.1);\n                if (!ret.isOk() || ret != Result::OK) {\n                    ALOGE(\"%s: setVolume failed: %s\", __func__, toString(ret).c_str());\n                    return false;\n                }\n                ret = Parameters::set(\n                        stream, {{AUDIO_OFFLOAD_CODEC_DELAY_SAMPLES, std::to_string(delay)},\n                                 {AUDIO_OFFLOAD_CODEC_PADDING_SAMPLES, std::to_string(padding)}});\n                if (!ret.isOk() || ret != Result::OK) {\n                    ALOGE(\"%s: setParameters failed: %s\", __func__, toString(ret).c_str());\n                    return false;\n                }\n                ret = stream->drain(AudioDrain::EARLY_NOTIFY);\n                if (!ret.isOk() || ret != Result::OK) {\n                    ALOGE(\"%s: drain failed: %s\", __func__, toString(ret).c_str());\n                    return false;\n                }\n                // FIXME: On some SoCs intermittent errors are possible, ignore them.\n                if (callbacks->waitForDrainReadyOrError()) {\n                    const float duration = std::chrono::duration_cast<std::chrono::milliseconds>(\n                                                   std::chrono::steady_clock::now() - start)\n                                                   .count();\n                    std::lock_guard lg(presentationEndLock);\n                    presentationEndTimes.push_back(duration);\n                }\n                return true;\n            });\n    ASSERT_OK(stream->setCallback(callbacks));\n    ASSERT_TRUE(writer.start());\n    // How many times to loop the track so that the sum of gapless delay and padding from\n    // the first presentation end to the last is at least 'presentationeEndPrecisionMs'.\n    const int playbackNumber = (int)(significantSampleNumber / ((float)delay + padding) + 1);\n    for (bool done = false; !done;) {\n        usleep(presentationeEndPrecisionMs * 1000);\n        {\n            std::lock_guard lg(presentationEndLock);\n            done = presentationEndTimes.size() >= playbackNumber;\n        }\n        ASSERT_FALSE(writer.hasError()) << \"Recent write or drain operation has failed\";\n    }\n    const float avgDuration =\n            std::accumulate(presentationEndTimes.begin(), presentationEndTimes.end(), 0.0) /\n            presentationEndTimes.size();\n    std::stringstream observedEndTimes;\n    std::copy(presentationEndTimes.begin(), presentationEndTimes.end(),\n              std::ostream_iterator<float>(observedEndTimes, \", \"));\n    EXPECT_NEAR(durationMs, avgDuration, presentationeEndPrecisionMs * 0.1)\n            << \"Observed durations: \" << observedEndTimes.str();\n    writer.stop();\n    EXPECT_OK(stream->clearCallback());\n    releasePatchIfNeeded();\n}\n\nINSTANTIATE_TEST_CASE_P(\n        CompressedOffloadOutputStream, CompressedOffloadOutputStreamTest,\n        ::testing::ValuesIn(getOutputDeviceCompressedConfigParameters(AudioConfigBase{\n                .format = xsd::toString(xsd::AudioFormat::AUDIO_FORMAT_MP3),\n                .sampleRateHz = 44100,\n                .channelMask = xsd::toString(xsd::AudioChannelMask::AUDIO_CHANNEL_OUT_STEREO)})),\n        &DeviceConfigParameterToString);\nGTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(CompressedOffloadOutputStreamTest);",
        "lookback": "static const std::vector<DeviceConfigParameter>& getOutputDeviceCompressedConfigParameters(",
        "lookahead": "",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 863,
        "end_line": 1136,
        "merge_gen_region": " const::<Config>&OutputCompressedConfig( constConfig&To) static stdvectorDevice<Config>&OutputCompressedConfig( AudioBase configMatch { const::<DeviceParameter parameters [& { autoParams =Output getDeviceParameters stdvectorDeviceParameter compressed;::__(Paramsbegin all.(),::_inser(Params [&]( cfg { ifstdgetPARAMCONFIGcfgbase configMatch return; auto flags stdgetPARAMFLAGScfg return::__(.(), flagsend []( auto flag { flag toStringx::InOut::_______________); !=.(); returnParams } return; classressedOutputStream : POnlyOutputStream {: load( stdstring fileName stdstring&,::<8_>*) stdifstream(,::::::::n stdiosbinary ASSERTTRUEisgood <<Failed open \" <<; isseek(, isend datareservedatasize +.g());.seek(, isbeg datainsertdataend stdistream_<<>());_(!.()) \"Failed read from \" <<; }; OffCallbacks : IOut {:<>DrReady override {Ionain\"); stdlockguard();OnainReady true }::<>Write() { {}; Returnvoid onReady",
        "confidence": 0.9621766209602356,
        "hesitated": false,
        "resolved": false
    }
]