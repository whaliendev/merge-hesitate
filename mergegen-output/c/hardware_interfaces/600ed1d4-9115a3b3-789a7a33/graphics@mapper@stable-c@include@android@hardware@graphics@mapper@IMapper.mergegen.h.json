[
    {
        "a_contents": "/*\n * Copyright (C) 2022 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n *  IMapper Stable-C HAL interface\n *\n *  This file represents the sphal interface between libui & the IMapper HAL implementation.\n *  A vendor implementation of this interface is retrieved by looking up the vendor imapper\n *  implementation library via the IAllocator AIDL interface.\n *\n *  This interface is not intended for general use.\n */\n\n#pragma once\n\n#include <sys/cdefs.h>\n#include <cinttypes>\n#include <cstddef>\n#include <type_traits>\n\n#include <android/rect.h>\n#include <cutils/native_handle.h>\n\n__BEGIN_DECLS\n\n/**\n * AIMapper versioning\n *\n * IMapper versions 0-1 are pre-treble\n * IMapper versions 2-4 are HIDL\n * C-style AIMapper API starts at 5\n */\nenum AIMapper_Version : uint32_t {\n    AIMAPPER_VERSION_5 = 5,\n};\n\n/**\n * Possible AIMapper errors\n * Values are the same as IMapper 4.0's Error type for simplicity\n */\nenum AIMapper_Error : int32_t {\n    /**\n     * No error.\n     */\n    AIMAPPER_ERROR_NONE = 0,\n    /**\n     * Invalid BufferDescriptor.\n     */\n    AIMAPPER_ERROR_BAD_DESCRIPTOR = 1,\n    /**\n     * Invalid buffer handle.\n     */\n    AIMAPPER_ERROR_BAD_BUFFER = 2,\n    /**\n     * Invalid HardwareBufferDescription.\n     */\n    AIMAPPER_ERROR_BAD_VALUE = 3,\n    /**\n     * Resource unavailable.\n     */\n    AIMAPPER_ERROR_NO_RESOURCES = 5,\n    /**\n     * Permanent failure.\n     */\n    AIMAPPER_ERROR_UNSUPPORTED = 7,\n};\n\n/**\n * MetadataType represents the different types of buffer metadata that could be\n * associated with a buffer. It is used by IMapper to help get and set buffer metadata\n * on the buffer's native handle.\n *\n * Standard buffer metadata will have the name field set to\n * \"android.hardware.graphics.common.StandardMetadataType\" and will contain values\n * from StandardMetadataType.aidl.\n *\n * Vendor-provided metadata should be prefixed with a \"vendor.mycompanyname.*\" namespace. It is\n * recommended that the metadata follows the pattern of StandardMetadaType.aidl. That is, an\n * aidl-defined enum with @VendorStability on it and the naming then matching that type such\n * as \"vendor.mycompanyname.graphics.common.MetadataType\" with the value field then set to the\n * aidl's enum value.\n *\n * Each company should create their own enum & namespace. The name\n * field prevents values from different companies from colliding.\n */\ntypedef struct AIMapper_MetadataType {\n    const char* _Nonnull name;\n    int64_t value;\n} AIMapper_MetadataType;\n\ntypedef struct AIMapper_MetadataTypeDescription {\n    /**\n     * The `name` of the metadataType must be valid for the lifetime of the process\n     */\n    AIMapper_MetadataType metadataType;\n    /**\n     * description should contain a string representation of the MetadataType.\n     *\n     * For example: \"MyExampleMetadataType is a 64-bit timestamp in nanoseconds\n     * that indicates when a buffer is decoded. It is set by the media HAL after\n     * a buffer is decoded. It is used by the display HAL for hardware\n     * synchronization\".\n     *\n     * This field is required for any non-StandardMetadataTypes. For StandardMetadataTypes this\n     * field may be null. The lifetime of this pointer must be valid for the duration of the\n     * process (that is, a static const char*).\n     */\n    const char* _Nullable description;\n    /**\n     * isGettable represents if the MetadataType can be get.\n     */\n    bool isGettable;\n    /**\n     * isSettable represents if the MetadataType can be set.\n     */\n    bool isSettable;\n\n    /** Reserved for future use; must be zero-initialized currently */\n    uint8_t reserved[32];\n} AIMapper_MetadataTypeDescription;\n\n/**\n * Callback that is passed to dumpBuffer.\n *\n * @param context The caller-provided void* that was passed to dumpBuffer.\n * @param metadataType The type of the metadata passed to the callback\n * @param value A pointer to the value of the metadata. The lifetime of this pointer is only\n *              valid for the duration of the call\n * @param valueSize The size of the value buffer.\n */\ntypedef void (*AIMapper_DumpBufferCallback)(void* _Null_unspecified context,\n                                            AIMapper_MetadataType metadataType,\n                                            const void* _Nonnull value, size_t valueSize);\n\n/**\n * Callback that is passed to dumpAllBuffers.\n *\n * Indicates that a buffer is about to be dumped. Will be followed by N calls to\n * AIMapper_DumpBufferCallback for all the metadata for this buffer.\n *\n * @param context The caller-provided void* that was passed to dumpAllBuffers.\n */\ntypedef void (*AIMapper_BeginDumpBufferCallback)(void* _Null_unspecified context);\n\n/**\n * Implementation of AIMAPPER_VERSION_5\n * All functions must not be null & must provide a valid implementation.\n */\ntypedef struct AIMapperV5 {\n    /**\n     * Imports a raw buffer handle to create an imported buffer handle for use\n     * with the rest of the mapper or with other in-process libraries.\n     *\n     * A buffer handle is considered raw when it is cloned (e.g., with\n     * `native_handle_clone()`) from another buffer handle locally, or when it\n     * is received from another HAL server/client or another process. A raw\n     * buffer handle must not be used to access the underlying graphic\n     * buffer. It must be imported to create an imported handle first.\n     *\n     * This function must at least validate the raw handle before creating the\n     * imported handle. It must also support importing the same raw handle\n     * multiple times to create multiple imported handles. The imported handle\n     * must be considered valid everywhere in the process, including in\n     * another instance of the mapper.\n     *\n     * Because of passthrough HALs, a raw buffer handle received from a HAL\n     * may actually have been imported in the process. importBuffer() must treat\n     * such a handle as if it is raw and must not return `BAD_BUFFER`. The\n     * returned handle is independent from the input handle as usual, and\n     * freeBuffer() must be called on it when it is no longer needed.\n     *\n     * @param handle Raw buffer handle to import.\n     * @param outBufferHandle The resulting imported buffer handle.\n     * @return Error status of the call, which may be\n     *     - `NONE` upon success.\n     *     - `BAD_BUFFER` if the raw handle is invalid.\n     *     - `NO_RESOURCES` if the raw handle cannot be imported due to\n     *       unavailability of resources.\n     */\n    AIMapper_Error (*_Nonnull importBuffer)(const native_handle_t* _Nonnull handle,\n                                            buffer_handle_t _Nullable* _Nonnull outBufferHandle);\n\n    /**\n     * Frees a buffer handle. Buffer handles returned by importBuffer() must be\n     * freed with this function when no longer needed.\n     *\n     * This function must free up all resources allocated by importBuffer() for\n     * the imported handle. For example, if the imported handle was created\n     * with `native_handle_create()`, this function must call\n     * `native_handle_close()` and `native_handle_delete()`.\n     *\n     * @param buffer Imported buffer handle.\n     * @return error Error status of the call, which may be\n     *     - `NONE` upon success.\n     *     - `BAD_BUFFER` if the buffer is invalid.\n     */\n    AIMapper_Error (*_Nonnull freeBuffer)(buffer_handle_t _Nonnull buffer);\n\n    /**\n     * Calculates the transport size of a buffer. An imported buffer handle is a\n     * raw buffer handle with the process-local runtime data appended. This\n     * function, for example, allows a caller to omit the process-local runtime\n     * data at the tail when serializing the imported buffer handle.\n     *\n     * Note that a client might or might not omit the process-local runtime data\n     * when sending an imported buffer handle. The mapper must support both\n     * cases on the receiving end.\n     *\n     * @param buffer Buffer to get the transport size from.\n     * @param outNumFds The number of file descriptors needed for transport.\n     * @param outNumInts The number of integers needed for transport.\n     * @return error Error status of the call, which may be\n     *     - `NONE` upon success.\n     *     - `BAD_BUFFER` if the buffer is invalid.\n     */\n    AIMapper_Error (*_Nonnull getTransportSize)(buffer_handle_t _Nonnull buffer,\n                                                uint32_t* _Nonnull outNumFds,\n                                                uint32_t* _Nonnull outNumInts);\n\n    /**\n     * Locks the given buffer for the specified CPU usage.\n     *\n     * Locking the same buffer simultaneously from multiple threads is\n     * permitted, but if any of the threads attempt to lock the buffer for\n     * writing, the behavior is undefined, except that it must not cause\n     * process termination or block the client indefinitely. Leaving the\n     * buffer content in an indeterminate state or returning an error are both\n     * acceptable.\n     *\n     * 1D buffers (width = size in bytes, height = 1, pixel_format = BLOB) must\n     * \"lock in place\". The buffers must be directly accessible via mapping.\n     *\n     * The client must not modify the content of the buffer outside of\n     * @p accessRegion, and the device need not guarantee that content outside\n     * of @p accessRegion is valid for reading. The result of reading or writing\n     * outside of @p accessRegion is undefined, except that it must not cause\n     * process termination.\n     *\n     * An accessRegion of all-zeros means the entire buffer. That is, it is\n     * equivalent to '(0,0)-(buffer width, buffer height)'.\n     *\n     * This function can lock both single-planar and multi-planar formats. The caller\n     * should use get() to get information about the buffer they are locking.\n     * get() can be used to get information about the planes, offsets, stride,\n     * etc.\n     *\n     * This function must also work on buffers with\n     * `AHARDWAREBUFFER_FORMAT_Y8Cb8Cr8_*` if supported by the device, as well\n     * as with any other formats requested by multimedia codecs when they are\n     * configured with a flexible-YUV-compatible color format.\n     *\n     * On success, @p data must be filled with a pointer to the locked buffer\n     * memory. This address will represent the top-left corner of the entire\n     * buffer, even if @p accessRegion does not begin at the top-left corner.\n     *\n     * The locked buffer must adhere to the format requested at allocation time\n     * in the BufferDescriptorInfo.\n     *\n     * @param buffer Buffer to lock.\n     * @param cpuUsage CPU usage flags to request. See BufferUsage.aidl for possible values.\n     * @param accessRegion Portion of the buffer that the client intends to\n     *     access.\n     * @param acquireFence Handle containing a file descriptor referring to a\n     *     sync fence object, which will be signaled when it is safe for the\n     *     mapper to lock the buffer. @p acquireFence may be an empty fence (-1) if\n     *     it is already safe to lock. Ownership is passed to the callee and it is the\n     *     implementations responsibility to ensure it is closed even when an error\n     *     occurs.\n     * @param outData CPU-accessible pointer to the buffer data.\n     * @return error Error status of the call, which may be\n     *     - `NONE` upon success.\n     *     - `BAD_BUFFER` if the buffer is invalid or is incompatible with this\n     *       function.\n     *     - `BAD_VALUE` if @p cpuUsage is 0, contains non-CPU usage flags, or\n     *       is incompatible with the buffer. Also if the @p accessRegion is\n     *       outside the bounds of the buffer or the accessRegion is invalid.\n     *     - `NO_RESOURCES` if the buffer cannot be locked at this time. Note\n     *       that locking may succeed at a later time.\n     * @return data CPU-accessible pointer to the buffer data.\n     */\n    AIMapper_Error (*_Nonnull lock)(buffer_handle_t _Nonnull buffer, uint64_t cpuUsage,\n                                    ARect accessRegion, int acquireFence,\n                                    void* _Nullable* _Nonnull outData);\n\n    /**\n     * Unlocks a buffer to indicate all CPU accesses to the buffer have\n     * completed.\n     *\n     * @param buffer Buffer to unlock.\n     * @param releaseFence Handle containing a file descriptor referring to a\n     *     sync fence object. The sync fence object will be signaled when the\n     *     mapper has completed any pending work. @p releaseFence may be an\n     *     empty fence (-1).\n     * @return error Error status of the call, which may be\n     *     - `NONE` upon success.\n     *     - `BAD_BUFFER` if the buffer is invalid or not locked.\n     */\n    AIMapper_Error (*_Nonnull unlock)(buffer_handle_t _Nonnull buffer, int* _Nonnull releaseFence);\n\n    /**\n     * Flushes the contents of a locked buffer.\n     *\n     * This function flushes the CPUs caches for the range of all the buffer's\n     * planes and metadata. This should behave similarly to unlock() except the\n     * buffer should remain mapped to the CPU.\n     *\n     * The client is still responsible for calling unlock() when it is done\n     * with all CPU accesses to the buffer.\n     *\n     * If non-CPU blocks are simultaneously writing the buffer, the locked\n     * copy should still be flushed but what happens is undefined except that\n     * it should not cause any crashes.\n     *\n     * @param buffer Buffer to flush.\n     * @return error Error status of the call, which may be\n     *     - `NONE` upon success.\n     *     - `BAD_BUFFER` if the buffer is invalid or not locked.\n     */\n    AIMapper_Error (*_Nonnull flushLockedBuffer)(buffer_handle_t _Nonnull buffer);\n\n    /**\n     * Rereads the contents of a locked buffer.\n     *\n     * This should fetch the most recent copy of the locked buffer.\n     *\n     * It may reread locked copies of the buffer in other processes.\n     *\n     * The client is still responsible for calling unlock() when it is done\n     * with all CPU accesses to the buffer.\n     *\n     * @param buffer Buffer to reread.\n     * @return error Error status of the call, which may be\n     *     - `NONE` upon success.\n     *     - `BAD_BUFFER` if the buffer is invalid or not locked.\n     *     - `NO_RESOURCES` if the buffer cannot be reread at this time. Note\n     *       that rereading may succeed at a later time.\n     */\n    AIMapper_Error (*_Nonnull rereadLockedBuffer)(buffer_handle_t _Nonnull buffer);\n\n    /**\n     * Description for get(...), set(...) and getFromBufferDescriptorInfo(...)\n     *\n     * ------------ Overview -----------------------------------\n     * Gralloc 4 adds support for getting and setting buffer metadata on a buffer.\n     *\n     * To get buffer metadata, the client passes in a buffer handle and a token that\n     * represents the type of buffer metadata they would like to get. IMapper returns\n     * a byte stream that contains the buffer metadata. To set the buffer metadata, the\n     * client passes in a buffer handle and a token that represents the type of buffer\n     * metadata they would like to set and a byte stream that contains the buffer metadata\n     * they are setting.\n     *\n     * Buffer metadata is global for a buffer. When the metadata is set on the buffer\n     * in a process, the updated metadata should be available to all other processes.\n     * Please see \"Storing and Propagating Metadata\" below for more details.\n     *\n     * The getter and setter functions have been optimized for easy vendor extension.\n     * They do not require a formal extension to add support for getting and setting\n     * vendor defined buffer metadata. See \"Buffer Metadata Token\" and\n     * \"Buffer Metadata Stream\" below for more details.\n     *\n     * ------------ Storing and Propagating Metadata -----------\n     * Buffer metadata must be global. Any changes to the metadata must be propagated\n     * to all other processes immediately. Vendors may chose how they would like support\n     * this functionality.\n     *\n     * We recommend supporting this functionality by allocating an extra page of shared\n     * memory and storing it in the buffer's native_handle_t. The buffer metadata can\n     * be stored in the extra page of shared memory. Set operations are automatically\n     * propagated to all other processes.\n     *\n     * ------------ Buffer Metadata Synchronization ------------\n     * There are no explicit buffer metadata synchronization primitives. Many devices\n     * before gralloc 4 already support getting and setting of global buffer metadata\n     * with no explicit synchronization primitives. Adding synchronization primitives\n     * would just add unnecessary complexity.\n     *\n     * The general rule is if a process has permission to write to a buffer, they\n     * have permission to write to the buffer's writable metadata. If a process has permission\n     * to read from a buffer, they have permission to read the buffer's metadata.\n     *\n     * There is one exception to this rule. Fences CANNOT be used to protect a buffer's\n     * metadata. A process should finish writing to a buffer's metadata before\n     * sending the buffer to another process that will read or write to the buffer.\n     * This exception is needed because sometimes userspace needs to read the\n     * buffer's metadata before the buffer's contents are ready.\n     *\n     * As a simple example: an app renders to a buffer and then displays the buffer.\n     * In this example when the app renders to the buffer, both the buffer and its\n     * metadata need to be updated. The app's process queues up its work on the GPU\n     * and gets back an acquire fence. The app's process must update the buffer's\n     * metadata before enqueuing the buffer to SurfaceFlinger. The app process CANNOT\n     * update the buffer's metadata after enqueuing the buffer. When HardwareComposer\n     * receives the buffer, it is immediately safe to read the buffer's metadata\n     * and use it to program the display driver. To read the buffer's contents,\n     * display driver must still wait on the acquire fence.\n     *\n     * ------------ Buffer Metadata Token ----------------------\n     * In order to allow arbitrary vendor defined metadata, the token used to access\n     * metadata is defined defined as a struct that has a string representing\n     * the enum type and an int that represents the enum value. The string protects\n     * different enum values from colliding.\n     *\n     * The token struct (MetadataType) is defined as a C struct since it\n     * is passed into a C function. The standard buffer metadata types are NOT\n     * defined as a C enum but instead as an AIDL enum to allow for broader usage across\n     * other HALs and libraries. By putting the enum in the\n     * stable AIDL (hardware/interfaces/graphics/common/aidl/android/hardware/\n     * graphics/common/StandardMetadataType.aidl), vendors will be able to optionally\n     * choose to support future standard buffer metadata types without upgrading\n     * IMapper versions. For more information see the description of \"struct MetadataType\".\n     *\n     * ------------ Buffer Metadata Stream ---------------------\n     * The buffer metadata is get and set as a void* buffer. By getting\n     * and setting buffer metadata as a generic buffer, vendors can use the standard\n     * getters and setter functions defined here. Vendors do NOT need to add their own\n     * getters and setter functions for each new type of buffer metadata.\n     *\n     * Converting buffer metadata into a byte stream can be non-trivial. For the standard\n     * buffer metadata types defined in StandardMetadataType.aidl, there are also\n     * support functions that will encode the buffer metadata into a byte stream\n     * and decode the buffer metadata from a byte stream. We STRONGLY recommend using\n     * these support functions. The framework will use them when getting and setting\n     * metadata. The support functions are defined in\n     * frameworks/native/libs/gralloc/types/include/gralloctypes/Gralloc4.h.\n     */\n\n    /**\n     * Gets the buffer metadata for a given MetadataType.\n     *\n     * Buffer metadata can be changed after allocation so clients should avoid \"caching\"\n     * the buffer metadata. For example, if the video resolution changes and the buffers\n     * are not reallocated, several buffer metadata values may change without warning.\n     * Clients should not expect the values to be constant. They should requery them every\n     * frame. The only exception is buffer metadata that is determined at allocation\n     * time. For StandardMetadataType values, only BUFFER_ID, NAME, WIDTH,\n     * HEIGHT, LAYER_COUNT, PIXEL_FORMAT_REQUESTED and USAGE are safe to cache because\n     * they are determined at allocation time.\n     *\n     * @param buffer Buffer containing desired metadata\n     * @param metadataType MetadataType for the metadata value being queried\n     * @param destBuffer Pointer to a buffer in which to store the result of the get() call; if\n     * null, the computed output size or error must still be returned.\n     * @param destBufferSize How large the destBuffer buffer is. If destBuffer is null this must be\n     * 0.\n     * @return The number of bytes written to `destBuffer` or which would have been written\n     *         if `destBufferSize` was large enough.\n     *         A negative value indicates an error, which may be\n     *         - `BAD_BUFFER` if the raw handle is invalid.\n     *         - `UNSUPPORTED` when metadataType is unknown/unsupported.\n     *            IMapper must support getting all StandardMetadataType.aidl values defined\n     *            at the time the device first launches.\n     */\n    int32_t (*_Nonnull getMetadata)(buffer_handle_t _Nonnull buffer,\n                                    AIMapper_MetadataType metadataType, void* _Nullable destBuffer,\n                                    size_t destBufferSize);\n\n    /**\n     * Gets the buffer metadata for a StandardMetadataType.\n     *\n     * This is equivalent to `getMetadata` when passed an AIMapper_MetadataType with name\n     * set to \"android.hardware.graphics.common.StandardMetadataType\"\n     *\n     * Buffer metadata can be changed after allocation so clients should avoid \"caching\"\n     * the buffer metadata. For example, if the video resolution changes and the buffers\n     * are not reallocated, several buffer metadata values may change without warning.\n     * Clients should not expect the values to be constant. They should requery them every\n     * frame. The only exception is buffer metadata that is determined at allocation\n     * time. For StandardMetadataType values, only BUFFER_ID, NAME, WIDTH,\n     * HEIGHT, LAYER_COUNT, PIXEL_FORMAT_REQUESTED and USAGE are safe to cache because\n     * they are determined at allocation time.\n     *\n     * @param buffer Buffer containing desired metadata\n     * @param standardMetadataType StandardMetadataType for the metadata value being queried\n     * @param destBuffer Pointer to a buffer in which to store the result of the get() call; if\n     * null, the computed output size or error must still be returned.\n     * @param destBufferSize How large the destBuffer buffer is. If destBuffer is null this must be\n     * 0.\n     * @return The number of bytes written to `destBuffer` or which would have been written\n     *         if `destBufferSize` was large enough.\n     *         A negative value indicates an error, which may be\n     *         - `BAD_BUFFER` if the raw handle is invalid.\n     *         - `UNSUPPORTED` when metadataType is unknown/unsupported.\n     *            IMapper must support getting all StandardMetadataType.aidl values defined\n     *            at the time the device first launches.\n     */\n    int32_t (*_Nonnull getStandardMetadata)(buffer_handle_t _Nonnull buffer,\n                                            int64_t standardMetadataType,\n                                            void* _Nullable destBuffer, size_t destBufferSize);\n\n    /**\n     * Sets the global value for a given MetadataType.\n     *\n     * Metadata fields are not required to be settable. This function can\n     * return Error::UNSUPPORTED whenever it doesn't support setting a\n     * particular Metadata field.\n     *\n     * The framework will attempt to set the following StandardMetadataType\n     * values: DATASPACE, SMPTE2086, CTA861_3, and BLEND_MODE.\n     * We require everyone to support setting those fields. Framework will also attempt to set\n     * SMPTE2094_40 and SMPTE2094_10 if available, and it is required to support setting those\n     * if it is possible to get them. If a device's Composer implementation supports a field,\n     * it should be supported here. Over time these metadata fields will be moved out of\n     * Composer/BufferQueue/etc. and into the buffer's Metadata fields.\n     *\n     * @param buffer Buffer receiving desired metadata\n     * @param metadataType MetadataType for the metadata value being set\n     * @param metadata Pointer to a buffer of bytes representing the value associated with\n     * @param metadataSize The size of the metadata buffer\n     * @return error Error status of the call, which may be\n     *     - `NONE` upon success.\n     *     - `BAD_BUFFER` if the raw handle is invalid.\n     *     - `BAD_VALUE` when the field is constant and can never be set (such as\n     *       BUFFER_ID, NAME, WIDTH, HEIGHT, LAYER_COUNT, PIXEL_FORMAT_REQUESTED and\n     *       USAGE)\n     *     - `NO_RESOURCES` if the set cannot be fulfilled due to unavailability of\n     *        resources.\n     *     - `UNSUPPORTED` when metadataType is unknown/unsupported or setting\n     *       it is unsupported. Unsupported should also be returned if the metadata\n     *       is malformed.\n     */\n    AIMapper_Error (*_Nonnull setMetadata)(buffer_handle_t _Nonnull buffer,\n                                           AIMapper_MetadataType metadataType,\n                                           const void* _Nonnull metadata, size_t metadataSize);\n\n    /**\n     * Sets the global value for a given MetadataType.\n     *\n     * This is equivalent to `setMetadata` when passed an AIMapper_MetadataType with name\n     * set to \"android.hardware.graphics.common.StandardMetadataType\"\n     *\n     * Metadata fields are not required to be settable. This function can\n     * return Error::UNSUPPORTED whenever it doesn't support setting a\n     * particular Metadata field.\n     *\n     * The framework will attempt to set the following StandardMetadataType\n     * values: DATASPACE, SMPTE2086, CTA861_3, and BLEND_MODE.\n     * We require everyone to support setting those fields. Framework will also attempt to set\n     * SMPTE2094_40 and SMPTE2094_10 if available, and it is required to support setting those\n     * if it is possible to get them. If a device's Composer implementation supports a field,\n     * it should be supported here. Over time these metadata fields will be moved out of\n     * Composer/BufferQueue/etc. and into the buffer's Metadata fields.\n     *\n     * @param buffer Buffer receiving desired metadata\n     * @param standardMetadataType StandardMetadataType for the metadata value being set\n     * @param metadata Pointer to a buffer of bytes representing the value associated with\n     * @param metadataSize The size of the metadata buffer\n     * @return error Error status of the call, which may be\n     *     - `NONE` upon success.\n     *     - `BAD_BUFFER` if the raw handle is invalid.\n     *     - `BAD_VALUE` when the field is constant and can never be set (such as\n     *       BUFFER_ID, NAME, WIDTH, HEIGHT, LAYER_COUNT, PIXEL_FORMAT_REQUESTED and\n     *       USAGE)\n     *     - `NO_RESOURCES` if the set cannot be fulfilled due to unavailability of\n     *        resources.\n     *     - `UNSUPPORTED` when metadataType is unknown/unsupported or setting\n     *       it is unsupported. Unsupported should also be returned if the metadata\n     *       is malformed.\n     */\n    AIMapper_Error (*_Nonnull setStandardMetadata)(buffer_handle_t _Nonnull buffer,\n                                                   int64_t standardMetadataType,\n                                                   const void* _Nonnull metadata,\n                                                   size_t metadataSize);\n\n    /**\n     * Lists all the MetadataTypes supported by IMapper as well as a description\n     * of each supported MetadataType. For StandardMetadataTypes, the description\n     * string can be left empty.\n     *\n     * This list is expected to be static & thus the returned array must be valid for the\n     * lifetime of the process.\n     *\n     * @param outDescriptionList The list of descriptions\n     * @param outNumberOfDescriptions How many descriptions are in `outDescriptionList`\n     * @return error Error status of the call, which may be\n     *     - `NONE` upon success.\n     *     - `UNSUPPORTED` if there's any error\n     */\n    AIMapper_Error (*_Nonnull listSupportedMetadataTypes)(\n            const AIMapper_MetadataTypeDescription* _Nullable* _Nonnull outDescriptionList,\n            size_t* _Nonnull outNumberOfDescriptions);\n\n    /**\n     * Dumps a buffer's metadata.\n     *\n     * @param buffer The buffer to dump the metadata for\n     * @param dumpBufferCallback Callback that will be invoked for each of the metadata fields\n     * @param context A caller-provided context to be passed to the dumpBufferCallback\n     * @return error Error status of the call, which may be\n     *     - `NONE` upon success.\n     *     - `BAD_BUFFER` if the raw handle is invalid.\n     *     - `NO_RESOURCES` if the get cannot be fulfilled due to unavailability of\n     *       resources.\n     */\n    AIMapper_Error (*_Nonnull dumpBuffer)(buffer_handle_t _Nonnull buffer,\n                                          AIMapper_DumpBufferCallback _Nonnull dumpBufferCallback,\n                                          void* _Null_unspecified context);\n\n    /**\n     * Dump the metadata for all imported buffers in the current process\n     *\n     * The HAL implementation should invoke beginDumpCallback before dumping a buffer's metadata,\n     * followed by N calls to dumpBufferCallback for that buffer's metadata fields. The call\n     * sequence should follow this pseudocode:\n     *\n     * for (auto buffer : gListOfImportedBuffers) {\n     *    beginDumpCallback(context);\n     *    for (auto metadata : buffer->allMetadata()) {\n     *        dumpBufferCallback(context, metadata...);\n     *    }\n     * }\n     *\n     * @param beginDumpCallback Signals that a buffer is about to be dumped\n     * @param dumpBufferCallback Callback that will be invoked for each of the metadata fields\n     * @param context A caller-provided context to be passed to beginDumpCallback and\n     *                dumpBufferCallback\n     * @return error Error status of the call, which may be\n     *     - `NONE` upon success.\n     *     - `BAD_BUFFER` if the raw handle is invalid.\n     *     - `NO_RESOURCES` if the get cannot be fulfilled due to unavailability of\n     *       resources.\n     */\n    AIMapper_Error (*_Nonnull dumpAllBuffers)(\n            AIMapper_BeginDumpBufferCallback _Nonnull beginDumpCallback,\n            AIMapper_DumpBufferCallback _Nonnull dumpBufferCallback,\n            void* _Null_unspecified context);\n\n    /**\n     * Returns the region of shared memory associated with the buffer that is\n     * reserved for client use.\n     *\n     * The shared memory may be allocated from any shared memory allocator.\n     * The shared memory must be CPU-accessible and virtually contiguous. The\n     * starting address must be word-aligned.\n     *\n     * This function may only be called after importBuffer() has been called by the\n     * client. The reserved region must remain accessible until freeBuffer() has\n     * been called. After freeBuffer() has been called, the client must not access\n     * the reserved region.\n     *\n     * This reserved memory may be used in future versions of Android to\n     * help clients implement backwards compatible features without requiring\n     * IAllocator/IMapper updates.\n     *\n     * @param buffer Imported buffer handle.\n     * @param outReservedRegion CPU-accessible pointer to the reserved region\n     * @param outReservedSize the size of the reservedRegion that was requested\n     *    in the BufferDescriptorInfo.\n     * @return error Error status of the call, which may be\n     *     - `NONE` upon success.\n     *     - `BAD_BUFFER` if the buffer is invalid.\n     */\n    AIMapper_Error (*_Nonnull getReservedRegion)(buffer_handle_t _Nonnull buffer,\n                                                 void* _Nullable* _Nonnull outReservedRegion,\n                                                 uint64_t* _Nonnull outReservedSize);\n\n} AIMapperV5;\n\n/**\n * Return value for AIMapper_loadIMapper\n *\n * Note: This struct's size is not fixed and callers must never store it by-value as a result.\n *       Only fields up to those covered by `version` are allowed to be accessed.\n */\ntypedef struct AIMapper {\n    alignas(alignof(max_align_t)) AIMapper_Version version;\n    AIMapperV5 v5;\n} AIMapper;\n\n/**\n * Loads the vendor-provided implementation of AIMapper\n * @return Error status of the call.\n *          - `NONE` upon success\n *          - `UNSUPPORTED` if no implementation is available\n */\nAIMapper_Error AIMapper_loadIMapper(AIMapper* _Nullable* _Nonnull outImplementation);\n\n__END_DECLS",
        "b_contents": "/*\n * Copyright (C) 2022 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n *  IMapper Stable-C HAL interface\n *\n *  This file represents the sphal interface between libui & the IMapper HAL implementation.\n *  A vendor implementation of this interface is retrieved by looking up the vendor imapper\n *  implementation library via the IAllocator AIDL interface.\n *\n *  This interface is not intended for general use.\n */\n\n#pragma once\n\n#include <sys/cdefs.h>\n#include <cinttypes>\n#include <cstddef>\n#include <type_traits>\n\n#include <android/rect.h>\n#include <cutils/native_handle.h>\n\n__BEGIN_DECLS\n\n/**\n * AIMapper versioning\n *\n * IMapper versions 0-1 are pre-treble\n * IMapper versions 2-4 are HIDL\n * C-style AIMapper API starts at 5\n */\nenum AIMapper_Version : uint32_t {\n    AIMAPPER_VERSION_5 = 5,\n};\n\n/**\n * Possible AIMapper errors\n * Values are the same as IMapper 4.0's Error type for simplicity\n */\nenum AIMapper_Error : int32_t {\n    /**\n     * No error.\n     */\n    AIMAPPER_ERROR_NONE = 0,\n    /**\n     * Invalid BufferDescriptor.\n     */\n    AIMAPPER_ERROR_BAD_DESCRIPTOR = 1,\n    /**\n     * Invalid buffer handle.\n     */\n    AIMAPPER_ERROR_BAD_BUFFER = 2,\n    /**\n     * Invalid HardwareBufferDescription.\n     */\n    AIMAPPER_ERROR_BAD_VALUE = 3,\n    /**\n     * Resource unavailable.\n     */\n    AIMAPPER_ERROR_NO_RESOURCES = 5,\n    /**\n     * Permanent failure.\n     */\n    AIMAPPER_ERROR_UNSUPPORTED = 7,\n};\n\n/**\n * MetadataType represents the different types of buffer metadata that could be\n * associated with a buffer. It is used by IMapper to help get and set buffer metadata\n * on the buffer's native handle.\n *\n * Standard buffer metadata will have the name field set to\n * \"android.hardware.graphics.common.StandardMetadataType\" and will contain values\n * from StandardMetadataType.aidl.\n *\n * Vendor-provided metadata should be prefixed with a \"vendor.mycompanyname.*\" namespace. It is\n * recommended that the metadata follows the pattern of StandardMetadaType.aidl. That is, an\n * aidl-defined enum with @VendorStability on it and the naming then matching that type such\n * as \"vendor.mycompanyname.graphics.common.MetadataType\" with the value field then set to the\n * aidl's enum value.\n *\n * Each company should create their own enum & namespace. The name\n * field prevents values from different companies from colliding.\n */\ntypedef struct AIMapper_MetadataType {\n    const char* _Nonnull name;\n    int64_t value;\n} AIMapper_MetadataType;\n\ntypedef struct AIMapper_MetadataTypeDescription {\n    /**\n     * The `name` of the metadataType must be valid for the lifetime of the process\n     */\n    AIMapper_MetadataType metadataType;\n    /**\n     * description should contain a string representation of the MetadataType.\n     *\n     * For example: \"MyExampleMetadataType is a 64-bit timestamp in nanoseconds\n     * that indicates when a buffer is decoded. It is set by the media HAL after\n     * a buffer is decoded. It is used by the display HAL for hardware\n     * synchronization\".\n     *\n     * This field is required for any non-StandardMetadataTypes. For StandardMetadataTypes this\n     * field may be null. The lifetime of this pointer must be valid for the duration of the\n     * process (that is, a static const char*).\n     */\n    const char* _Nullable description;\n    /**\n     * isGettable represents if the MetadataType can be get.\n     */\n    bool isGettable;\n    /**\n     * isSettable represents if the MetadataType can be set.\n     */\n    bool isSettable;\n\n    /** Reserved for future use; must be zero-initialized currently */\n    uint8_t reserved[32];\n} AIMapper_MetadataTypeDescription;\n\n/**\n * Callback that is passed to dumpBuffer.\n *\n * @param context The caller-provided void* that was passed to dumpBuffer.\n * @param metadataType The type of the metadata passed to the callback\n * @param value A pointer to the value of the metadata. The lifetime of this pointer is only\n *              valid for the duration of the call\n * @param valueSize The size of the value buffer.\n */\ntypedef void (*AIMapper_DumpBufferCallback)(void* _Null_unspecified context,\n                                            AIMapper_MetadataType metadataType,\n                                            const void* _Nonnull value, size_t valueSize);\n\n/**\n * Callback that is passed to dumpAllBuffers.\n *\n * Indicates that a buffer is about to be dumped. Will be followed by N calls to\n * AIMapper_DumpBufferCallback for all the metadata for this buffer.\n *\n * @param context The caller-provided void* that was passed to dumpAllBuffers.\n */\ntypedef void (*AIMapper_BeginDumpBufferCallback)(void* _Null_unspecified context);\n\n/**\n * Implementation of AIMAPPER_VERSION_5\n * All functions must not be null & must provide a valid implementation.\n */\ntypedef struct AIMapperV5 {\n    /**\n     * Imports a raw buffer handle to create an imported buffer handle for use\n     * with the rest of the mapper or with other in-process libraries.\n     *\n     * A buffer handle is considered raw when it is cloned (e.g., with\n     * `native_handle_clone()`) from another buffer handle locally, or when it\n     * is received from another HAL server/client or another process. A raw\n     * buffer handle must not be used to access the underlying graphic\n     * buffer. It must be imported to create an imported handle first.\n     *\n     * This function must at least validate the raw handle before creating the\n     * imported handle. It must also support importing the same raw handle\n     * multiple times to create multiple imported handles. The imported handle\n     * must be considered valid everywhere in the process, including in\n     * another instance of the mapper.\n     *\n     * Because of passthrough HALs, a raw buffer handle received from a HAL\n     * may actually have been imported in the process. importBuffer() must treat\n     * such a handle as if it is raw and must not return `BAD_BUFFER`. The\n     * returned handle is independent from the input handle as usual, and\n     * freeBuffer() must be called on it when it is no longer needed.\n     *\n     * @param handle Raw buffer handle to import.\n     * @param outBufferHandle The resulting imported buffer handle.\n     * @return Error status of the call, which may be\n     *     - `NONE` upon success.\n     *     - `BAD_BUFFER` if the raw handle is invalid.\n     *     - `NO_RESOURCES` if the raw handle cannot be imported due to\n     *       unavailability of resources.\n     */\n    AIMapper_Error (*_Nonnull importBuffer)(const native_handle_t* _Nonnull handle,\n                                            buffer_handle_t _Nullable* _Nonnull outBufferHandle);\n\n    /**\n     * Frees a buffer handle. Buffer handles returned by importBuffer() must be\n     * freed with this function when no longer needed.\n     *\n     * This function must free up all resources allocated by importBuffer() for\n     * the imported handle. For example, if the imported handle was created\n     * with `native_handle_create()`, this function must call\n     * `native_handle_close()` and `native_handle_delete()`.\n     *\n     * @param buffer Imported buffer handle.\n     * @return error Error status of the call, which may be\n     *     - `NONE` upon success.\n     *     - `BAD_BUFFER` if the buffer is invalid.\n     */\n    AIMapper_Error (*_Nonnull freeBuffer)(buffer_handle_t _Nonnull buffer);\n\n    /**\n     * Calculates the transport size of a buffer. An imported buffer handle is a\n     * raw buffer handle with the process-local runtime data appended. This\n     * function, for example, allows a caller to omit the process-local runtime\n     * data at the tail when serializing the imported buffer handle.\n     *\n     * Note that a client might or might not omit the process-local runtime data\n     * when sending an imported buffer handle. The mapper must support both\n     * cases on the receiving end.\n     *\n     * @param buffer Buffer to get the transport size from.\n     * @param outNumFds The number of file descriptors needed for transport.\n     * @param outNumInts The number of integers needed for transport.\n     * @return error Error status of the call, which may be\n     *     - `NONE` upon success.\n     *     - `BAD_BUFFER` if the buffer is invalid.\n     */\n    AIMapper_Error (*_Nonnull getTransportSize)(buffer_handle_t _Nonnull buffer,\n                                                uint32_t* _Nonnull outNumFds,\n                                                uint32_t* _Nonnull outNumInts);\n\n    /**\n     * Locks the given buffer for the specified CPU usage.\n     *\n     * Locking the same buffer simultaneously from multiple threads is\n     * permitted, but if any of the threads attempt to lock the buffer for\n     * writing, the behavior is undefined, except that it must not cause\n     * process termination or block the client indefinitely. Leaving the\n     * buffer content in an indeterminate state or returning an error are both\n     * acceptable.\n     *\n     * 1D buffers (width = size in bytes, height = 1, pixel_format = BLOB) must\n     * \"lock in place\". The buffers must be directly accessible via mapping.\n     *\n     * The client must not modify the content of the buffer outside of\n     * @p accessRegion, and the device need not guarantee that content outside\n     * of @p accessRegion is valid for reading. The result of reading or writing\n     * outside of @p accessRegion is undefined, except that it must not cause\n     * process termination.\n     *\n     * An accessRegion of all-zeros means the entire buffer. That is, it is\n     * equivalent to '(0,0)-(buffer width, buffer height)'.\n     *\n     * This function can lock both single-planar and multi-planar formats. The caller\n     * should use get() to get information about the buffer they are locking.\n     * get() can be used to get information about the planes, offsets, stride,\n     * etc.\n     *\n     * This function must also work on buffers with\n     * `AHARDWAREBUFFER_FORMAT_Y8Cb8Cr8_*` if supported by the device, as well\n     * as with any other formats requested by multimedia codecs when they are\n     * configured with a flexible-YUV-compatible color format.\n     *\n     * On success, @p data must be filled with a pointer to the locked buffer\n     * memory. This address will represent the top-left corner of the entire\n     * buffer, even if @p accessRegion does not begin at the top-left corner.\n     *\n     * The locked buffer must adhere to the format requested at allocation time\n     * in the BufferDescriptorInfo.\n     *\n     * @param buffer Buffer to lock.\n     * @param cpuUsage CPU usage flags to request. See BufferUsage.aidl for possible values.\n     * @param accessRegion Portion of the buffer that the client intends to\n     *     access.\n     * @param acquireFence Handle containing a file descriptor referring to a\n     *     sync fence object, which will be signaled when it is safe for the\n     *     mapper to lock the buffer. @p acquireFence may be an empty fence (-1) if\n     *     it is already safe to lock. Ownership is passed to the callee and it is the\n     *     implementations responsibility to ensure it is closed even when an error\n     *     occurs.\n     * @param outData CPU-accessible pointer to the buffer data.\n     * @return error Error status of the call, which may be\n     *     - `NONE` upon success.\n     *     - `BAD_BUFFER` if the buffer is invalid or is incompatible with this\n     *       function.\n     *     - `BAD_VALUE` if @p cpuUsage is 0, contains non-CPU usage flags, or\n     *       is incompatible with the buffer. Also if the @p accessRegion is\n     *       outside the bounds of the buffer or the accessRegion is invalid.\n     *     - `NO_RESOURCES` if the buffer cannot be locked at this time. Note\n     *       that locking may succeed at a later time.\n     * @return data CPU-accessible pointer to the buffer data.\n     */\n    AIMapper_Error (*_Nonnull lock)(buffer_handle_t _Nonnull buffer, uint64_t cpuUsage,\n                                    ARect accessRegion, int acquireFence,\n                                    void* _Nullable* _Nonnull outData);\n\n    /**\n     * Unlocks a buffer to indicate all CPU accesses to the buffer have\n     * completed.\n     *\n     * @param buffer Buffer to unlock.\n     * @param releaseFence Handle containing a file descriptor referring to a\n     *     sync fence object. The sync fence object will be signaled when the\n     *     mapper has completed any pending work. @p releaseFence may be an\n     *     empty fence (-1).\n     * @return error Error status of the call, which may be\n     *     - `NONE` upon success.\n     *     - `BAD_BUFFER` if the buffer is invalid or not locked.\n     */\n    AIMapper_Error (*_Nonnull unlock)(buffer_handle_t _Nonnull buffer, int* _Nonnull releaseFence);\n\n    /**\n     * Flushes the contents of a locked buffer.\n     *\n     * This function flushes the CPUs caches for the range of all the buffer's\n     * planes and metadata. This should behave similarly to unlock() except the\n     * buffer should remain mapped to the CPU.\n     *\n     * The client is still responsible for calling unlock() when it is done\n     * with all CPU accesses to the buffer.\n     *\n     * If non-CPU blocks are simultaneously writing the buffer, the locked\n     * copy should still be flushed but what happens is undefined except that\n     * it should not cause any crashes.\n     *\n     * @param buffer Buffer to flush.\n     * @return error Error status of the call, which may be\n     *     - `NONE` upon success.\n     *     - `BAD_BUFFER` if the buffer is invalid or not locked.\n     */\n    AIMapper_Error (*_Nonnull flushLockedBuffer)(buffer_handle_t _Nonnull buffer);\n\n    /**\n     * Rereads the contents of a locked buffer.\n     *\n     * This should fetch the most recent copy of the locked buffer.\n     *\n     * It may reread locked copies of the buffer in other processes.\n     *\n     * The client is still responsible for calling unlock() when it is done\n     * with all CPU accesses to the buffer.\n     *\n     * @param buffer Buffer to reread.\n     * @return error Error status of the call, which may be\n     *     - `NONE` upon success.\n     *     - `BAD_BUFFER` if the buffer is invalid or not locked.\n     *     - `NO_RESOURCES` if the buffer cannot be reread at this time. Note\n     *       that rereading may succeed at a later time.\n     */\n    AIMapper_Error (*_Nonnull rereadLockedBuffer)(buffer_handle_t _Nonnull buffer);\n\n    /**\n     * Description for get(...), set(...) and getFromBufferDescriptorInfo(...)\n     *\n     * ------------ Overview -----------------------------------\n     * Gralloc 4 adds support for getting and setting buffer metadata on a buffer.\n     *\n     * To get buffer metadata, the client passes in a buffer handle and a token that\n     * represents the type of buffer metadata they would like to get. IMapper returns\n     * a byte stream that contains the buffer metadata. To set the buffer metadata, the\n     * client passes in a buffer handle and a token that represents the type of buffer\n     * metadata they would like to set and a byte stream that contains the buffer metadata\n     * they are setting.\n     *\n     * Buffer metadata is global for a buffer. When the metadata is set on the buffer\n     * in a process, the updated metadata should be available to all other processes.\n     * Please see \"Storing and Propagating Metadata\" below for more details.\n     *\n     * The getter and setter functions have been optimized for easy vendor extension.\n     * They do not require a formal extension to add support for getting and setting\n     * vendor defined buffer metadata. See \"Buffer Metadata Token\" and\n     * \"Buffer Metadata Stream\" below for more details.\n     *\n     * ------------ Storing and Propagating Metadata -----------\n     * Buffer metadata must be global. Any changes to the metadata must be propagated\n     * to all other processes immediately. Vendors may chose how they would like support\n     * this functionality.\n     *\n     * We recommend supporting this functionality by allocating an extra page of shared\n     * memory and storing it in the buffer's native_handle_t. The buffer metadata can\n     * be stored in the extra page of shared memory. Set operations are automatically\n     * propagated to all other processes.\n     *\n     * ------------ Buffer Metadata Synchronization ------------\n     * There are no explicit buffer metadata synchronization primitives. Many devices\n     * before gralloc 4 already support getting and setting of global buffer metadata\n     * with no explicit synchronization primitives. Adding synchronization primitives\n     * would just add unnecessary complexity.\n     *\n     * The general rule is if a process has permission to write to a buffer, they\n     * have permission to write to the buffer's writable metadata. If a process has permission\n     * to read from a buffer, they have permission to read the buffer's metadata.\n     *\n     * There is one exception to this rule. Fences CANNOT be used to protect a buffer's\n     * metadata. A process should finish writing to a buffer's metadata before\n     * sending the buffer to another process that will read or write to the buffer.\n     * This exception is needed because sometimes userspace needs to read the\n     * buffer's metadata before the buffer's contents are ready.\n     *\n     * As a simple example: an app renders to a buffer and then displays the buffer.\n     * In this example when the app renders to the buffer, both the buffer and its\n     * metadata need to be updated. The app's process queues up its work on the GPU\n     * and gets back an acquire fence. The app's process must update the buffer's\n     * metadata before enqueuing the buffer to SurfaceFlinger. The app process CANNOT\n     * update the buffer's metadata after enqueuing the buffer. When HardwareComposer\n     * receives the buffer, it is immediately safe to read the buffer's metadata\n     * and use it to program the display driver. To read the buffer's contents,\n     * display driver must still wait on the acquire fence.\n     *\n     * ------------ Buffer Metadata Token ----------------------\n     * In order to allow arbitrary vendor defined metadata, the token used to access\n     * metadata is defined defined as a struct that has a string representing\n     * the enum type and an int that represents the enum value. The string protects\n     * different enum values from colliding.\n     *\n     * The token struct (MetadataType) is defined as a C struct since it\n     * is passed into a C function. The standard buffer metadata types are NOT\n     * defined as a C enum but instead as an AIDL enum to allow for broader usage across\n     * other HALs and libraries. By putting the enum in the\n     * stable AIDL (hardware/interfaces/graphics/common/aidl/android/hardware/\n     * graphics/common/StandardMetadataType.aidl), vendors will be able to optionally\n     * choose to support future standard buffer metadata types without upgrading\n     * IMapper versions. For more information see the description of \"struct MetadataType\".\n     *\n     * ------------ Buffer Metadata Stream ---------------------\n     * The buffer metadata is get and set as a void* buffer. By getting\n     * and setting buffer metadata as a generic buffer, vendors can use the standard\n     * getters and setter functions defined here. Vendors do NOT need to add their own\n     * getters and setter functions for each new type of buffer metadata.\n     *\n     * Converting buffer metadata into a byte stream can be non-trivial. For the standard\n     * buffer metadata types defined in StandardMetadataType.aidl, there are also\n     * support functions that will encode the buffer metadata into a byte stream\n     * and decode the buffer metadata from a byte stream. We STRONGLY recommend using\n     * these support functions. The framework will use them when getting and setting\n     * metadata. The support functions are defined in\n     * frameworks/native/libs/gralloc/types/include/gralloctypes/Gralloc4.h.\n     */\n\n    /**\n     * Gets the buffer metadata for a given MetadataType.\n     *\n     * Buffer metadata can be changed after allocation so clients should avoid \"caching\"\n     * the buffer metadata. For example, if the video resolution changes and the buffers\n     * are not reallocated, several buffer metadata values may change without warning.\n     * Clients should not expect the values to be constant. They should requery them every\n     * frame. The only exception is buffer metadata that is determined at allocation\n     * time. For StandardMetadataType values, only BUFFER_ID, NAME, WIDTH,\n     * HEIGHT, LAYER_COUNT, PIXEL_FORMAT_REQUESTED and USAGE are safe to cache because\n     * they are determined at allocation time.\n     *\n     * @param buffer Buffer containing desired metadata\n     * @param metadataType MetadataType for the metadata value being queried\n     * @param destBuffer Pointer to a buffer in which to store the result of the get() call; if\n     * null, the computed output size or error must still be returned.\n     * @param destBufferSize How large the destBuffer buffer is. If destBuffer is null this must be\n     * 0.\n     * @return The number of bytes written to `destBuffer` or which would have been written\n     *         if `destBufferSize` was large enough.\n     *         A negative value indicates an error, which may be\n     *         - `BAD_BUFFER` if the raw handle is invalid.\n     *         - `UNSUPPORTED` when metadataType is unknown/unsupported.\n     *            IMapper must support getting all StandardMetadataType.aidl values defined\n     *            at the time the device first launches.\n     */\n    int32_t (*_Nonnull getMetadata)(buffer_handle_t _Nonnull buffer,\n                                    AIMapper_MetadataType metadataType, void* _Nullable destBuffer,\n                                    size_t destBufferSize);\n\n    /**\n     * Gets the buffer metadata for a StandardMetadataType.\n     *\n     * This is equivalent to `getMetadata` when passed an AIMapper_MetadataType with name\n     * set to \"android.hardware.graphics.common.StandardMetadataType\"\n     *\n     * Buffer metadata can be changed after allocation so clients should avoid \"caching\"\n     * the buffer metadata. For example, if the video resolution changes and the buffers\n     * are not reallocated, several buffer metadata values may change without warning.\n     * Clients should not expect the values to be constant. They should requery them every\n     * frame. The only exception is buffer metadata that is determined at allocation\n     * time. For StandardMetadataType values, only BUFFER_ID, NAME, WIDTH,\n     * HEIGHT, LAYER_COUNT, PIXEL_FORMAT_REQUESTED and USAGE are safe to cache because\n     * they are determined at allocation time.\n     *\n     * @param buffer Buffer containing desired metadata\n     * @param standardMetadataType StandardMetadataType for the metadata value being queried\n     * @param destBuffer Pointer to a buffer in which to store the result of the get() call; if\n     * null, the computed output size or error must still be returned.\n     * @param destBufferSize How large the destBuffer buffer is. If destBuffer is null this must be\n     * 0.\n     * @return The number of bytes written to `destBuffer` or which would have been written\n     *         if `destBufferSize` was large enough.\n     *         A negative value indicates an error, which may be\n     *         - `BAD_BUFFER` if the raw handle is invalid.\n     *         - `UNSUPPORTED` when metadataType is unknown/unsupported.\n     *            IMapper must support getting all StandardMetadataType.aidl values defined\n     *            at the time the device first launches.\n     */\n    int32_t (*_Nonnull getStandardMetadata)(buffer_handle_t _Nonnull buffer,\n                                            int64_t standardMetadataType,\n                                            void* _Nullable destBuffer, size_t destBufferSize);\n\n    /**\n     * Sets the global value for a given MetadataType.\n     *\n     * Metadata fields are not required to be settable. This function can\n     * return Error::UNSUPPORTED whenever it doesn't support setting a\n     * particular Metadata field.\n     *\n     * The framework will attempt to set the following StandardMetadataType\n     * values: DATASPACE, SMPTE2086, CTA861_3, SMPTE2094_40 and BLEND_MODE.\n     * We require everyone to support setting those fields. If a device's Composer\n     * implementation supports a field, it should be supported here. Over time these\n     * metadata fields will be moved out of Composer/BufferQueue/etc. and into the\n     * buffer's Metadata fields.\n     *\n     * @param buffer Buffer receiving desired metadata\n     * @param metadataType MetadataType for the metadata value being set\n     * @param metadata Pointer to a buffer of bytes representing the value associated with\n     * @param metadataSize The size of the metadata buffer\n     * @return error Error status of the call, which may be\n     *     - `NONE` upon success.\n     *     - `BAD_BUFFER` if the raw handle is invalid.\n     *     - `BAD_VALUE` when the field is constant and can never be set (such as\n     *       BUFFER_ID, NAME, WIDTH, HEIGHT, LAYER_COUNT, PIXEL_FORMAT_REQUESTED and\n     *       USAGE)\n     *     - `NO_RESOURCES` if the set cannot be fulfilled due to unavailability of\n     *        resources.\n     *     - `UNSUPPORTED` when metadataType is unknown/unsupported or setting\n     *       it is unsupported. Unsupported should also be returned if the metadata\n     *       is malformed.\n     */\n    AIMapper_Error (*_Nonnull setMetadata)(buffer_handle_t _Nonnull buffer,\n                                           AIMapper_MetadataType metadataType,\n                                           const void* _Nonnull metadata, size_t metadataSize);\n\n    /**\n     * Sets the global value for a given MetadataType.\n     *\n     * This is equivalent to `setMetadata` when passed an AIMapper_MetadataType with name\n     * set to \"android.hardware.graphics.common.StandardMetadataType\"\n     *\n     * Metadata fields are not required to be settable. This function can\n     * return Error::UNSUPPORTED whenever it doesn't support setting a\n     * particular Metadata field.\n     *\n     * The framework will attempt to set the following StandardMetadataType\n     * values: DATASPACE, SMPTE2086, CTA861_3, SMPTE2094_40 and BLEND_MODE.\n     * We require everyone to support setting those fields. If a device's Composer\n     * implementation supports a field, it should be supported here. Over time these\n     * metadata fields will be moved out of Composer/BufferQueue/etc. and into the\n     * buffer's Metadata fields.\n     *\n     * @param buffer Buffer receiving desired metadata\n     * @param standardMetadataType StandardMetadataType for the metadata value being set\n     * @param metadata Pointer to a buffer of bytes representing the value associated with\n     * @param metadataSize The size of the metadata buffer\n     * @return error Error status of the call, which may be\n     *     - `NONE` upon success.\n     *     - `BAD_BUFFER` if the raw handle is invalid.\n     *     - `BAD_VALUE` when the field is constant and can never be set (such as\n     *       BUFFER_ID, NAME, WIDTH, HEIGHT, LAYER_COUNT, PIXEL_FORMAT_REQUESTED and\n     *       USAGE)\n     *     - `NO_RESOURCES` if the set cannot be fulfilled due to unavailability of\n     *        resources.\n     *     - `UNSUPPORTED` when metadataType is unknown/unsupported or setting\n     *       it is unsupported. Unsupported should also be returned if the metadata\n     *       is malformed.\n     */\n    AIMapper_Error (*_Nonnull setStandardMetadata)(buffer_handle_t _Nonnull buffer,\n                                                   int64_t standardMetadataType,\n                                                   const void* _Nonnull metadata,\n                                                   size_t metadataSize);\n\n    /**\n     * Lists all the MetadataTypes supported by IMapper as well as a description\n     * of each supported MetadataType. For StandardMetadataTypes, the description\n     * string can be left empty.\n     *\n     * This list is expected to be static & thus the returned array must be valid for the\n     * lifetime of the process.\n     *\n     * @param outDescriptionList The list of descriptions\n     * @param outNumberOfDescriptions How many descriptions are in `outDescriptionList`\n     * @return error Error status of the call, which may be\n     *     - `NONE` upon success.\n     *     - `UNSUPPORTED` if there's any error\n     */\n    AIMapper_Error (*_Nonnull listSupportedMetadataTypes)(\n            const AIMapper_MetadataTypeDescription* _Nullable* _Nonnull outDescriptionList,\n            size_t* _Nonnull outNumberOfDescriptions);\n\n    /**\n     * Dumps a buffer's metadata.\n     *\n     * @param buffer The buffer to dump the metadata for\n     * @param dumpBufferCallback Callback that will be invoked for each of the metadata fields\n     * @param context A caller-provided context to be passed to the dumpBufferCallback\n     * @return error Error status of the call, which may be\n     *     - `NONE` upon success.\n     *     - `BAD_BUFFER` if the raw handle is invalid.\n     *     - `NO_RESOURCES` if the get cannot be fulfilled due to unavailability of\n     *       resources.\n     */\n    AIMapper_Error (*_Nonnull dumpBuffer)(buffer_handle_t _Nonnull buffer,\n                                          AIMapper_DumpBufferCallback _Nonnull dumpBufferCallback,\n                                          void* _Null_unspecified context);\n\n    /**\n     * Dump the metadata for all imported buffers in the current process\n     *\n     * The HAL implementation should invoke beginDumpCallback before dumping a buffer's metadata,\n     * followed by N calls to dumpBufferCallback for that buffer's metadata fields. The call\n     * sequence should follow this pseudocode:\n     *\n     * for (auto buffer : gListOfImportedBuffers) {\n     *    beginDumpCallback(context);\n     *    for (auto metadata : buffer->allMetadata()) {\n     *        dumpBufferCallback(context, metadata...);\n     *    }\n     * }\n     *\n     * @param beginDumpCallback Signals that a buffer is about to be dumped\n     * @param dumpBufferCallback Callback that will be invoked for each of the metadata fields\n     * @param context A caller-provided context to be passed to beginDumpCallback and\n     *                dumpBufferCallback\n     * @return error Error status of the call, which may be\n     *     - `NONE` upon success.\n     *     - `BAD_BUFFER` if the raw handle is invalid.\n     *     - `NO_RESOURCES` if the get cannot be fulfilled due to unavailability of\n     *       resources.\n     */\n    AIMapper_Error (*_Nonnull dumpAllBuffers)(\n            AIMapper_BeginDumpBufferCallback _Nonnull beginDumpCallback,\n            AIMapper_DumpBufferCallback _Nonnull dumpBufferCallback,\n            void* _Null_unspecified context);\n\n    /**\n     * Returns the region of shared memory associated with the buffer that is\n     * reserved for client use.\n     *\n     * The shared memory may be allocated from any shared memory allocator.\n     * The shared memory must be CPU-accessible and virtually contiguous. The\n     * starting address must be word-aligned.\n     *\n     * This function may only be called after importBuffer() has been called by the\n     * client. The reserved region must remain accessible until freeBuffer() has\n     * been called. After freeBuffer() has been called, the client must not access\n     * the reserved region.\n     *\n     * This reserved memory may be used in future versions of Android to\n     * help clients implement backwards compatible features without requiring\n     * IAllocator/IMapper updates.\n     *\n     * @param buffer Imported buffer handle.\n     * @param outReservedRegion CPU-accessible pointer to the reserved region\n     * @param outReservedSize the size of the reservedRegion that was requested\n     *    in the BufferDescriptorInfo.\n     * @return error Error status of the call, which may be\n     *     - `NONE` upon success.\n     *     - `BAD_BUFFER` if the buffer is invalid.\n     */\n    AIMapper_Error (*_Nonnull getReservedRegion)(buffer_handle_t _Nonnull buffer,\n                                                 void* _Nullable* _Nonnull outReservedRegion,\n                                                 uint64_t* _Nonnull outReservedSize);\n\n} AIMapperV5;\n\n/**\n * Return value for AIMapper_loadIMapper\n *\n * Note: This struct's size is not fixed and callers must never store it by-value as a result.\n *       Only fields up to those covered by `version` are allowed to be accessed.\n */\ntypedef struct AIMapper {\n    alignas(alignof(max_align_t)) AIMapper_Version version;\n    AIMapperV5 v5;\n} AIMapper;\n\n/**\n * Loads the vendor-provided implementation of AIMapper\n * @return Error status of the call.\n *          - `NONE` upon success\n *          - `UNSUPPORTED` if no implementation is available\n */\nAIMapper_Error AIMapper_loadIMapper(AIMapper* _Nullable* _Nonnull outImplementation);\n\n__END_DECLS",
        "base_contents": "",
        "res_region": "/*\n * Copyright (C) 2022 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n *  IMapper Stable-C HAL interface\n *\n *  This file represents the sphal interface between libui & the IMapper HAL implementation.\n *  A vendor implementation of this interface is retrieved by looking up the vendor imapper\n *  implementation library via the IAllocator AIDL interface.\n *\n *  This interface is not intended for general use.\n */\n\n#pragma once\n\n#include <sys/cdefs.h>\n#include <cinttypes>\n#include <cstddef>\n#include <type_traits>\n\n#include <android/rect.h>\n#include <cutils/native_handle.h>\n\n__BEGIN_DECLS\n\n/**\n * AIMapper versioning\n *\n * IMapper versions 0-1 are pre-treble\n * IMapper versions 2-4 are HIDL\n * C-style AIMapper API starts at 5\n */\nenum AIMapper_Version : uint32_t {\n    AIMAPPER_VERSION_5 = 5,\n};\n\n/**\n * Possible AIMapper errors\n * Values are the same as IMapper 4.0's Error type for simplicity\n */\nenum AIMapper_Error : int32_t {\n    /**\n     * No error.\n     */\n    AIMAPPER_ERROR_NONE = 0,\n    /**\n     * Invalid BufferDescriptor.\n     */\n    AIMAPPER_ERROR_BAD_DESCRIPTOR = 1,\n    /**\n     * Invalid buffer handle.\n     */\n    AIMAPPER_ERROR_BAD_BUFFER = 2,\n    /**\n     * Invalid HardwareBufferDescription.\n     */\n    AIMAPPER_ERROR_BAD_VALUE = 3,\n    /**\n     * Resource unavailable.\n     */\n    AIMAPPER_ERROR_NO_RESOURCES = 5,\n    /**\n     * Permanent failure.\n     */\n    AIMAPPER_ERROR_UNSUPPORTED = 7,\n};\n\n/**\n * MetadataType represents the different types of buffer metadata that could be\n * associated with a buffer. It is used by IMapper to help get and set buffer metadata\n * on the buffer's native handle.\n *\n * Standard buffer metadata will have the name field set to\n * \"android.hardware.graphics.common.StandardMetadataType\" and will contain values\n * from StandardMetadataType.aidl.\n *\n * Vendor-provided metadata should be prefixed with a \"vendor.mycompanyname.*\" namespace. It is\n * recommended that the metadata follows the pattern of StandardMetadaType.aidl. That is, an\n * aidl-defined enum with @VendorStability on it and the naming then matching that type such\n * as \"vendor.mycompanyname.graphics.common.MetadataType\" with the value field then set to the\n * aidl's enum value.\n *\n * Each company should create their own enum & namespace. The name\n * field prevents values from different companies from colliding.\n */\ntypedef struct AIMapper_MetadataType {\n    const char* _Nonnull name;\n    int64_t value;\n} AIMapper_MetadataType;\n\ntypedef struct AIMapper_MetadataTypeDescription {\n    /**\n     * The `name` of the metadataType must be valid for the lifetime of the process\n     */\n    AIMapper_MetadataType metadataType;\n    /**\n     * description should contain a string representation of the MetadataType.\n     *\n     * For example: \"MyExampleMetadataType is a 64-bit timestamp in nanoseconds\n     * that indicates when a buffer is decoded. It is set by the media HAL after\n     * a buffer is decoded. It is used by the display HAL for hardware\n     * synchronization\".\n     *\n     * This field is required for any non-StandardMetadataTypes. For StandardMetadataTypes this\n     * field may be null. The lifetime of this pointer must be valid for the duration of the\n     * process (that is, a static const char*).\n     */\n    const char* _Nullable description;\n    /**\n     * isGettable represents if the MetadataType can be get.\n     */\n    bool isGettable;\n    /**\n     * isSettable represents if the MetadataType can be set.\n     */\n    bool isSettable;\n\n    /** Reserved for future use; must be zero-initialized currently */\n    uint8_t reserved[32];\n} AIMapper_MetadataTypeDescription;\n\n/**\n * Callback that is passed to dumpBuffer.\n *\n * @param context The caller-provided void* that was passed to dumpBuffer.\n * @param metadataType The type of the metadata passed to the callback\n * @param value A pointer to the value of the metadata. The lifetime of this pointer is only\n *              valid for the duration of the call\n * @param valueSize The size of the value buffer.\n */\ntypedef void (*AIMapper_DumpBufferCallback)(void* _Null_unspecified context,\n                                            AIMapper_MetadataType metadataType,\n                                            const void* _Nonnull value, size_t valueSize);\n\n/**\n * Callback that is passed to dumpAllBuffers.\n *\n * Indicates that a buffer is about to be dumped. Will be followed by N calls to\n * AIMapper_DumpBufferCallback for all the metadata for this buffer.\n *\n * @param context The caller-provided void* that was passed to dumpAllBuffers.\n */\ntypedef void (*AIMapper_BeginDumpBufferCallback)(void* _Null_unspecified context);\n\n/**\n * Implementation of AIMAPPER_VERSION_5\n * All functions must not be null & must provide a valid implementation.\n */\ntypedef struct AIMapperV5 {\n    /**\n     * Imports a raw buffer handle to create an imported buffer handle for use\n     * with the rest of the mapper or with other in-process libraries.\n     *\n     * A buffer handle is considered raw when it is cloned (e.g., with\n     * `native_handle_clone()`) from another buffer handle locally, or when it\n     * is received from another HAL server/client or another process. A raw\n     * buffer handle must not be used to access the underlying graphic\n     * buffer. It must be imported to create an imported handle first.\n     *\n     * This function must at least validate the raw handle before creating the\n     * imported handle. It must also support importing the same raw handle\n     * multiple times to create multiple imported handles. The imported handle\n     * must be considered valid everywhere in the process, including in\n     * another instance of the mapper.\n     *\n     * Because of passthrough HALs, a raw buffer handle received from a HAL\n     * may actually have been imported in the process. importBuffer() must treat\n     * such a handle as if it is raw and must not return `BAD_BUFFER`. The\n     * returned handle is independent from the input handle as usual, and\n     * freeBuffer() must be called on it when it is no longer needed.\n     *\n     * @param handle Raw buffer handle to import.\n     * @param outBufferHandle The resulting imported buffer handle.\n     * @return Error status of the call, which may be\n     *     - `NONE` upon success.\n     *     - `BAD_BUFFER` if the raw handle is invalid.\n     *     - `NO_RESOURCES` if the raw handle cannot be imported due to\n     *       unavailability of resources.\n     */\n    AIMapper_Error (*_Nonnull importBuffer)(const native_handle_t* _Nonnull handle,\n                                            buffer_handle_t _Nullable* _Nonnull outBufferHandle);\n\n    /**\n     * Frees a buffer handle. Buffer handles returned by importBuffer() must be\n     * freed with this function when no longer needed.\n     *\n     * This function must free up all resources allocated by importBuffer() for\n     * the imported handle. For example, if the imported handle was created\n     * with `native_handle_create()`, this function must call\n     * `native_handle_close()` and `native_handle_delete()`.\n     *\n     * @param buffer Imported buffer handle.\n     * @return error Error status of the call, which may be\n     *     - `NONE` upon success.\n     *     - `BAD_BUFFER` if the buffer is invalid.\n     */\n    AIMapper_Error (*_Nonnull freeBuffer)(buffer_handle_t _Nonnull buffer);\n\n    /**\n     * Calculates the transport size of a buffer. An imported buffer handle is a\n     * raw buffer handle with the process-local runtime data appended. This\n     * function, for example, allows a caller to omit the process-local runtime\n     * data at the tail when serializing the imported buffer handle.\n     *\n     * Note that a client might or might not omit the process-local runtime data\n     * when sending an imported buffer handle. The mapper must support both\n     * cases on the receiving end.\n     *\n     * @param buffer Buffer to get the transport size from.\n     * @param outNumFds The number of file descriptors needed for transport.\n     * @param outNumInts The number of integers needed for transport.\n     * @return error Error status of the call, which may be\n     *     - `NONE` upon success.\n     *     - `BAD_BUFFER` if the buffer is invalid.\n     */\n    AIMapper_Error (*_Nonnull getTransportSize)(buffer_handle_t _Nonnull buffer,\n                                                uint32_t* _Nonnull outNumFds,\n                                                uint32_t* _Nonnull outNumInts);\n\n    /**\n     * Locks the given buffer for the specified CPU usage.\n     *\n     * Locking the same buffer simultaneously from multiple threads is\n     * permitted, but if any of the threads attempt to lock the buffer for\n     * writing, the behavior is undefined, except that it must not cause\n     * process termination or block the client indefinitely. Leaving the\n     * buffer content in an indeterminate state or returning an error are both\n     * acceptable.\n     *\n     * 1D buffers (width = size in bytes, height = 1, pixel_format = BLOB) must\n     * \"lock in place\". The buffers must be directly accessible via mapping.\n     *\n     * The client must not modify the content of the buffer outside of\n     * @p accessRegion, and the device need not guarantee that content outside\n     * of @p accessRegion is valid for reading. The result of reading or writing\n     * outside of @p accessRegion is undefined, except that it must not cause\n     * process termination.\n     *\n     * An accessRegion of all-zeros means the entire buffer. That is, it is\n     * equivalent to '(0,0)-(buffer width, buffer height)'.\n     *\n     * This function can lock both single-planar and multi-planar formats. The caller\n     * should use get() to get information about the buffer they are locking.\n     * get() can be used to get information about the planes, offsets, stride,\n     * etc.\n     *\n     * This function must also work on buffers with\n     * `AHARDWAREBUFFER_FORMAT_Y8Cb8Cr8_*` if supported by the device, as well\n     * as with any other formats requested by multimedia codecs when they are\n     * configured with a flexible-YUV-compatible color format.\n     *\n     * On success, @p data must be filled with a pointer to the locked buffer\n     * memory. This address will represent the top-left corner of the entire\n     * buffer, even if @p accessRegion does not begin at the top-left corner.\n     *\n     * The locked buffer must adhere to the format requested at allocation time\n     * in the BufferDescriptorInfo.\n     *\n     * @param buffer Buffer to lock.\n     * @param cpuUsage CPU usage flags to request. See BufferUsage.aidl for possible values.\n     * @param accessRegion Portion of the buffer that the client intends to\n     *     access.\n     * @param acquireFence Handle containing a file descriptor referring to a\n     *     sync fence object, which will be signaled when it is safe for the\n     *     mapper to lock the buffer. @p acquireFence may be an empty fence (-1) if\n     *     it is already safe to lock. Ownership is passed to the callee and it is the\n     *     implementations responsibility to ensure it is closed even when an error\n     *     occurs.\n     * @param outData CPU-accessible pointer to the buffer data.\n     * @return error Error status of the call, which may be\n     *     - `NONE` upon success.\n     *     - `BAD_BUFFER` if the buffer is invalid or is incompatible with this\n     *       function.\n     *     - `BAD_VALUE` if @p cpuUsage is 0, contains non-CPU usage flags, or\n     *       is incompatible with the buffer. Also if the @p accessRegion is\n     *       outside the bounds of the buffer or the accessRegion is invalid.\n     *     - `NO_RESOURCES` if the buffer cannot be locked at this time. Note\n     *       that locking may succeed at a later time.\n     * @return data CPU-accessible pointer to the buffer data.\n     */\n    AIMapper_Error (*_Nonnull lock)(buffer_handle_t _Nonnull buffer, uint64_t cpuUsage,\n                                    ARect accessRegion, int acquireFence,\n                                    void* _Nullable* _Nonnull outData);\n\n    /**\n     * Unlocks a buffer to indicate all CPU accesses to the buffer have\n     * completed.\n     *\n     * @param buffer Buffer to unlock.\n     * @param releaseFence Handle containing a file descriptor referring to a\n     *     sync fence object. The sync fence object will be signaled when the\n     *     mapper has completed any pending work. @p releaseFence may be an\n     *     empty fence (-1).\n     * @return error Error status of the call, which may be\n     *     - `NONE` upon success.\n     *     - `BAD_BUFFER` if the buffer is invalid or not locked.\n     */\n    AIMapper_Error (*_Nonnull unlock)(buffer_handle_t _Nonnull buffer, int* _Nonnull releaseFence);\n\n    /**\n     * Flushes the contents of a locked buffer.\n     *\n     * This function flushes the CPUs caches for the range of all the buffer's\n     * planes and metadata. This should behave similarly to unlock() except the\n     * buffer should remain mapped to the CPU.\n     *\n     * The client is still responsible for calling unlock() when it is done\n     * with all CPU accesses to the buffer.\n     *\n     * If non-CPU blocks are simultaneously writing the buffer, the locked\n     * copy should still be flushed but what happens is undefined except that\n     * it should not cause any crashes.\n     *\n     * @param buffer Buffer to flush.\n     * @return error Error status of the call, which may be\n     *     - `NONE` upon success.\n     *     - `BAD_BUFFER` if the buffer is invalid or not locked.\n     */\n    AIMapper_Error (*_Nonnull flushLockedBuffer)(buffer_handle_t _Nonnull buffer);\n\n    /**\n     * Rereads the contents of a locked buffer.\n     *\n     * This should fetch the most recent copy of the locked buffer.\n     *\n     * It may reread locked copies of the buffer in other processes.\n     *\n     * The client is still responsible for calling unlock() when it is done\n     * with all CPU accesses to the buffer.\n     *\n     * @param buffer Buffer to reread.\n     * @return error Error status of the call, which may be\n     *     - `NONE` upon success.\n     *     - `BAD_BUFFER` if the buffer is invalid or not locked.\n     *     - `NO_RESOURCES` if the buffer cannot be reread at this time. Note\n     *       that rereading may succeed at a later time.\n     */\n    AIMapper_Error (*_Nonnull rereadLockedBuffer)(buffer_handle_t _Nonnull buffer);\n\n    /**\n     * Description for get(...), set(...) and getFromBufferDescriptorInfo(...)\n     *\n     * ------------ Overview -----------------------------------\n     * Gralloc 4 adds support for getting and setting buffer metadata on a buffer.\n     *\n     * To get buffer metadata, the client passes in a buffer handle and a token that\n     * represents the type of buffer metadata they would like to get. IMapper returns\n     * a byte stream that contains the buffer metadata. To set the buffer metadata, the\n     * client passes in a buffer handle and a token that represents the type of buffer\n     * metadata they would like to set and a byte stream that contains the buffer metadata\n     * they are setting.\n     *\n     * Buffer metadata is global for a buffer. When the metadata is set on the buffer\n     * in a process, the updated metadata should be available to all other processes.\n     * Please see \"Storing and Propagating Metadata\" below for more details.\n     *\n     * The getter and setter functions have been optimized for easy vendor extension.\n     * They do not require a formal extension to add support for getting and setting\n     * vendor defined buffer metadata. See \"Buffer Metadata Token\" and\n     * \"Buffer Metadata Stream\" below for more details.\n     *\n     * ------------ Storing and Propagating Metadata -----------\n     * Buffer metadata must be global. Any changes to the metadata must be propagated\n     * to all other processes immediately. Vendors may chose how they would like support\n     * this functionality.\n     *\n     * We recommend supporting this functionality by allocating an extra page of shared\n     * memory and storing it in the buffer's native_handle_t. The buffer metadata can\n     * be stored in the extra page of shared memory. Set operations are automatically\n     * propagated to all other processes.\n     *\n     * ------------ Buffer Metadata Synchronization ------------\n     * There are no explicit buffer metadata synchronization primitives. Many devices\n     * before gralloc 4 already support getting and setting of global buffer metadata\n     * with no explicit synchronization primitives. Adding synchronization primitives\n     * would just add unnecessary complexity.\n     *\n     * The general rule is if a process has permission to write to a buffer, they\n     * have permission to write to the buffer's writable metadata. If a process has permission\n     * to read from a buffer, they have permission to read the buffer's metadata.\n     *\n     * There is one exception to this rule. Fences CANNOT be used to protect a buffer's\n     * metadata. A process should finish writing to a buffer's metadata before\n     * sending the buffer to another process that will read or write to the buffer.\n     * This exception is needed because sometimes userspace needs to read the\n     * buffer's metadata before the buffer's contents are ready.\n     *\n     * As a simple example: an app renders to a buffer and then displays the buffer.\n     * In this example when the app renders to the buffer, both the buffer and its\n     * metadata need to be updated. The app's process queues up its work on the GPU\n     * and gets back an acquire fence. The app's process must update the buffer's\n     * metadata before enqueuing the buffer to SurfaceFlinger. The app process CANNOT\n     * update the buffer's metadata after enqueuing the buffer. When HardwareComposer\n     * receives the buffer, it is immediately safe to read the buffer's metadata\n     * and use it to program the display driver. To read the buffer's contents,\n     * display driver must still wait on the acquire fence.\n     *\n     * ------------ Buffer Metadata Token ----------------------\n     * In order to allow arbitrary vendor defined metadata, the token used to access\n     * metadata is defined defined as a struct that has a string representing\n     * the enum type and an int that represents the enum value. The string protects\n     * different enum values from colliding.\n     *\n     * The token struct (MetadataType) is defined as a C struct since it\n     * is passed into a C function. The standard buffer metadata types are NOT\n     * defined as a C enum but instead as an AIDL enum to allow for broader usage across\n     * other HALs and libraries. By putting the enum in the\n     * stable AIDL (hardware/interfaces/graphics/common/aidl/android/hardware/\n     * graphics/common/StandardMetadataType.aidl), vendors will be able to optionally\n     * choose to support future standard buffer metadata types without upgrading\n     * IMapper versions. For more information see the description of \"struct MetadataType\".\n     *\n     * ------------ Buffer Metadata Stream ---------------------\n     * The buffer metadata is get and set as a void* buffer. By getting\n     * and setting buffer metadata as a generic buffer, vendors can use the standard\n     * getters and setter functions defined here. Vendors do NOT need to add their own\n     * getters and setter functions for each new type of buffer metadata.\n     *\n     * Converting buffer metadata into a byte stream can be non-trivial. For the standard\n     * buffer metadata types defined in StandardMetadataType.aidl, there are also\n     * support functions that will encode the buffer metadata into a byte stream\n     * and decode the buffer metadata from a byte stream. We STRONGLY recommend using\n     * these support functions. The framework will use them when getting and setting\n     * metadata. The support functions are defined in\n     * frameworks/native/libs/gralloc/types/include/gralloctypes/Gralloc4.h.\n     */\n\n    /**\n     * Gets the buffer metadata for a given MetadataType.\n     *\n     * Buffer metadata can be changed after allocation so clients should avoid \"caching\"\n     * the buffer metadata. For example, if the video resolution changes and the buffers\n     * are not reallocated, several buffer metadata values may change without warning.\n     * Clients should not expect the values to be constant. They should requery them every\n     * frame. The only exception is buffer metadata that is determined at allocation\n     * time. For StandardMetadataType values, only BUFFER_ID, NAME, WIDTH,\n     * HEIGHT, LAYER_COUNT, PIXEL_FORMAT_REQUESTED and USAGE are safe to cache because\n     * they are determined at allocation time.\n     *\n     * @param buffer Buffer containing desired metadata\n     * @param metadataType MetadataType for the metadata value being queried\n     * @param destBuffer Pointer to a buffer in which to store the result of the get() call; if\n     * null, the computed output size or error must still be returned.\n     * @param destBufferSize How large the destBuffer buffer is. If destBuffer is null this must be\n     * 0.\n     * @return The number of bytes written to `destBuffer` or which would have been written\n     *         if `destBufferSize` was large enough.\n     *         A negative value indicates an error, which may be\n     *         - `BAD_BUFFER` if the raw handle is invalid.\n     *         - `UNSUPPORTED` when metadataType is unknown/unsupported.\n     *            IMapper must support getting all StandardMetadataType.aidl values defined\n     *            at the time the device first launches.\n     */\n    int32_t (*_Nonnull getMetadata)(buffer_handle_t _Nonnull buffer,\n                                    AIMapper_MetadataType metadataType, void* _Nullable destBuffer,\n                                    size_t destBufferSize);\n\n    /**\n     * Gets the buffer metadata for a StandardMetadataType.\n     *\n     * This is equivalent to `getMetadata` when passed an AIMapper_MetadataType with name\n     * set to \"android.hardware.graphics.common.StandardMetadataType\"\n     *\n     * Buffer metadata can be changed after allocation so clients should avoid \"caching\"\n     * the buffer metadata. For example, if the video resolution changes and the buffers\n     * are not reallocated, several buffer metadata values may change without warning.\n     * Clients should not expect the values to be constant. They should requery them every\n     * frame. The only exception is buffer metadata that is determined at allocation\n     * time. For StandardMetadataType values, only BUFFER_ID, NAME, WIDTH,\n     * HEIGHT, LAYER_COUNT, PIXEL_FORMAT_REQUESTED and USAGE are safe to cache because\n     * they are determined at allocation time.\n     *\n     * @param buffer Buffer containing desired metadata\n     * @param standardMetadataType StandardMetadataType for the metadata value being queried\n     * @param destBuffer Pointer to a buffer in which to store the result of the get() call; if\n     * null, the computed output size or error must still be returned.\n     * @param destBufferSize How large the destBuffer buffer is. If destBuffer is null this must be\n     * 0.\n     * @return The number of bytes written to `destBuffer` or which would have been written\n     *         if `destBufferSize` was large enough.\n     *         A negative value indicates an error, which may be\n     *         - `BAD_BUFFER` if the raw handle is invalid.\n     *         - `UNSUPPORTED` when metadataType is unknown/unsupported.\n     *            IMapper must support getting all StandardMetadataType.aidl values defined\n     *            at the time the device first launches.\n     */\n    int32_t (*_Nonnull getStandardMetadata)(buffer_handle_t _Nonnull buffer,\n                                            int64_t standardMetadataType,\n                                            void* _Nullable destBuffer, size_t destBufferSize);\n\n    /**\n     * Sets the global value for a given MetadataType.\n     *\n     * Metadata fields are not required to be settable. This function can\n     * return Error::UNSUPPORTED whenever it doesn't support setting a\n     * particular Metadata field.\n     *\n     * The framework will attempt to set the following StandardMetadataType\n     * values: DATASPACE, SMPTE2086, CTA861_3, and BLEND_MODE.\n     * We require everyone to support setting those fields. Framework will also attempt to set\n     * SMPTE2094_40 and SMPTE2094_10 if available, and it is required to support setting those\n     * if it is possible to get them. If a device's Composer implementation supports a field,\n     * it should be supported here. Over time these metadata fields will be moved out of\n     * Composer/BufferQueue/etc. and into the buffer's Metadata fields.\n     *\n     * @param buffer Buffer receiving desired metadata\n     * @param metadataType MetadataType for the metadata value being set\n     * @param metadata Pointer to a buffer of bytes representing the value associated with\n     * @param metadataSize The size of the metadata buffer\n     * @return error Error status of the call, which may be\n     *     - `NONE` upon success.\n     *     - `BAD_BUFFER` if the raw handle is invalid.\n     *     - `BAD_VALUE` when the field is constant and can never be set (such as\n     *       BUFFER_ID, NAME, WIDTH, HEIGHT, LAYER_COUNT, PIXEL_FORMAT_REQUESTED and\n     *       USAGE)\n     *     - `NO_RESOURCES` if the set cannot be fulfilled due to unavailability of\n     *        resources.\n     *     - `UNSUPPORTED` when metadataType is unknown/unsupported or setting\n     *       it is unsupported. Unsupported should also be returned if the metadata\n     *       is malformed.\n     */\n    AIMapper_Error (*_Nonnull setMetadata)(buffer_handle_t _Nonnull buffer,\n                                           AIMapper_MetadataType metadataType,\n                                           const void* _Nonnull metadata, size_t metadataSize);\n\n    /**\n     * Sets the global value for a given MetadataType.\n     *\n     * This is equivalent to `setMetadata` when passed an AIMapper_MetadataType with name\n     * set to \"android.hardware.graphics.common.StandardMetadataType\"\n     *\n     * Metadata fields are not required to be settable. This function can\n     * return Error::UNSUPPORTED whenever it doesn't support setting a\n     * particular Metadata field.\n     *\n     * The framework will attempt to set the following StandardMetadataType\n     * values: DATASPACE, SMPTE2086, CTA861_3, and BLEND_MODE.\n     * We require everyone to support setting those fields. Framework will also attempt to set\n     * SMPTE2094_40 and SMPTE2094_10 if available, and it is required to support setting those\n     * if it is possible to get them. If a device's Composer implementation supports a field,\n     * it should be supported here. Over time these metadata fields will be moved out of\n     * Composer/BufferQueue/etc. and into the buffer's Metadata fields.\n     *\n     * @param buffer Buffer receiving desired metadata\n     * @param standardMetadataType StandardMetadataType for the metadata value being set\n     * @param metadata Pointer to a buffer of bytes representing the value associated with\n     * @param metadataSize The size of the metadata buffer\n     * @return error Error status of the call, which may be\n     *     - `NONE` upon success.\n     *     - `BAD_BUFFER` if the raw handle is invalid.\n     *     - `BAD_VALUE` when the field is constant and can never be set (such as\n     *       BUFFER_ID, NAME, WIDTH, HEIGHT, LAYER_COUNT, PIXEL_FORMAT_REQUESTED and\n     *       USAGE)\n     *     - `NO_RESOURCES` if the set cannot be fulfilled due to unavailability of\n     *        resources.\n     *     - `UNSUPPORTED` when metadataType is unknown/unsupported or setting\n     *       it is unsupported. Unsupported should also be returned if the metadata\n     *       is malformed.\n     */\n    AIMapper_Error (*_Nonnull setStandardMetadata)(buffer_handle_t _Nonnull buffer,\n                                                   int64_t standardMetadataType,\n                                                   const void* _Nonnull metadata,\n                                                   size_t metadataSize);\n\n    /**\n     * Lists all the MetadataTypes supported by IMapper as well as a description\n     * of each supported MetadataType. For StandardMetadataTypes, the description\n     * string can be left empty.\n     *\n     * This list is expected to be static & thus the returned array must be valid for the\n     * lifetime of the process.\n     *\n     * @param outDescriptionList The list of descriptions\n     * @param outNumberOfDescriptions How many descriptions are in `outDescriptionList`\n     * @return error Error status of the call, which may be\n     *     - `NONE` upon success.\n     *     - `UNSUPPORTED` if there's any error\n     */\n    AIMapper_Error (*_Nonnull listSupportedMetadataTypes)(\n            const AIMapper_MetadataTypeDescription* _Nullable* _Nonnull outDescriptionList,\n            size_t* _Nonnull outNumberOfDescriptions);\n\n    /**\n     * Dumps a buffer's metadata.\n     *\n     * @param buffer The buffer to dump the metadata for\n     * @param dumpBufferCallback Callback that will be invoked for each of the metadata fields\n     * @param context A caller-provided context to be passed to the dumpBufferCallback\n     * @return error Error status of the call, which may be\n     *     - `NONE` upon success.\n     *     - `BAD_BUFFER` if the raw handle is invalid.\n     *     - `NO_RESOURCES` if the get cannot be fulfilled due to unavailability of\n     *       resources.\n     */\n    AIMapper_Error (*_Nonnull dumpBuffer)(buffer_handle_t _Nonnull buffer,\n                                          AIMapper_DumpBufferCallback _Nonnull dumpBufferCallback,\n                                          void* _Null_unspecified context);\n\n    /**\n     * Dump the metadata for all imported buffers in the current process\n     *\n     * The HAL implementation should invoke beginDumpCallback before dumping a buffer's metadata,\n     * followed by N calls to dumpBufferCallback for that buffer's metadata fields. The call\n     * sequence should follow this pseudocode:\n     *\n     * for (auto buffer : gListOfImportedBuffers) {\n     *    beginDumpCallback(context);\n     *    for (auto metadata : buffer->allMetadata()) {\n     *        dumpBufferCallback(context, metadata...);\n     *    }\n     * }\n     *\n     * @param beginDumpCallback Signals that a buffer is about to be dumped\n     * @param dumpBufferCallback Callback that will be invoked for each of the metadata fields\n     * @param context A caller-provided context to be passed to beginDumpCallback and\n     *                dumpBufferCallback\n     * @return error Error status of the call, which may be\n     *     - `NONE` upon success.\n     *     - `BAD_BUFFER` if the raw handle is invalid.\n     *     - `NO_RESOURCES` if the get cannot be fulfilled due to unavailability of\n     *       resources.\n     */\n    AIMapper_Error (*_Nonnull dumpAllBuffers)(\n            AIMapper_BeginDumpBufferCallback _Nonnull beginDumpCallback,\n            AIMapper_DumpBufferCallback _Nonnull dumpBufferCallback,\n            void* _Null_unspecified context);\n\n    /**\n     * Returns the region of shared memory associated with the buffer that is\n     * reserved for client use.\n     *\n     * The shared memory may be allocated from any shared memory allocator.\n     * The shared memory must be CPU-accessible and virtually contiguous. The\n     * starting address must be word-aligned.\n     *\n     * This function may only be called after importBuffer() has been called by the\n     * client. The reserved region must remain accessible until freeBuffer() has\n     * been called. After freeBuffer() has been called, the client must not access\n     * the reserved region.\n     *\n     * This reserved memory may be used in future versions of Android to\n     * help clients implement backwards compatible features without requiring\n     * IAllocator/IMapper updates.\n     *\n     * @param buffer Imported buffer handle.\n     * @param outReservedRegion CPU-accessible pointer to the reserved region\n     * @param outReservedSize the size of the reservedRegion that was requested\n     *    in the BufferDescriptorInfo.\n     * @return error Error status of the call, which may be\n     *     - `NONE` upon success.\n     *     - `BAD_BUFFER` if the buffer is invalid.\n     */\n    AIMapper_Error (*_Nonnull getReservedRegion)(buffer_handle_t _Nonnull buffer,\n                                                 void* _Nullable* _Nonnull outReservedRegion,\n                                                 uint64_t* _Nonnull outReservedSize);\n\n} AIMapperV5;\n\n/**\n * Return value for AIMapper_loadIMapper\n *\n * Note: This struct's size is not fixed and callers must never store it by-value as a result.\n *       Only fields up to those covered by `version` are allowed to be accessed.\n */\ntypedef struct AIMapper {\n    alignas(alignof(max_align_t)) AIMapper_Version version;\n    AIMapperV5 v5;\n} AIMapper;\n\n/**\n * Loads the vendor-provided implementation of AIMapper\n * @return Error status of the call.\n *          - `NONE` upon success\n *          - `UNSUPPORTED` if no implementation is available\n */\nAIMapper_Error AIMapper_loadIMapper(AIMapper* _Nullable* _Nonnull outImplementation);\n\n__END_DECLS",
        "lookback": " * Copyright (C) 2022 The Android Open Source Project",
        "lookahead": "",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 0,
        "end_line": 1383,
        "merge_gen_region": " CopyrightC 2 The Open Project * Licensed the License, 2. ( \"\"); you not this except in with the. * may a of License * may a of License * *://.///LICENSE20 * Unless by law agreed in, * under License distributed anAS\" BASIS * WITHOUT OR OF KIND either or. See License the specific governing and limitations the License */ * *MappertableC HAL * This represents sph interface lii the I HAL. A implementation this interface retrieved looking the imapper implementation via I A interface * This is intended general. # onceincludesysc.>includec>includec>includec>includec>includec>includetypetraits #includeandroidrecth # <utilsnativehandleh ___ /**BEGINDECLS *IMpering * I versions- are pretrle I versions- areL Cstyle Aapflags starts 5 enumIMperVersion uint_ {MAP___ =, /** InvalidDescriptor */MAP_____ =, * * Buffer. AIPER____ =, * buffer /** Invalid handle */MAP____ =, * bufferDescriptor */MAP____ =, * bufferDescriptor */MAP____ =, * * bufferDescriptor",
        "confidence": 0.9121622443199158,
        "hesitated": false,
        "resolved": false
    }
]