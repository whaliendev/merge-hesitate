[
    {
        "a_contents": "/*\n * Copyright 2022 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#undef LOG_TAG\n#define LOG_TAG \"VtsHalGraphicsMapperStableC_TargetTest\"\n\n#include <aidl/Vintf.h>\n#include <aidl/android/hardware/graphics/allocator/AllocationError.h>\n#include <aidl/android/hardware/graphics/allocator/AllocationResult.h>\n#include <aidl/android/hardware/graphics/allocator/IAllocator.h>\n#include <aidl/android/hardware/graphics/common/BufferUsage.h>\n#include <aidl/android/hardware/graphics/common/PixelFormat.h>\n#include <aidlcommonsupport/NativeHandle.h>\n#include <android/binder_enums.h>\n#include <android/binder_manager.h>\n#include <android/dlext.h>\n#include <android/hardware/graphics/mapper/IMapper.h>\n#include <android/hardware/graphics/mapper/utils/IMapperMetadataTypes.h>\n#include <gralloctypes/Gralloc4.h>\n#include <hidl/GtestPrinter.h>\n#include <system/graphics.h>\n\n#include <dlfcn.h>\n#include <drm/drm_fourcc.h>\n#include <gtest/gtest.h>\n#include <vndksupport/linker.h>\n#include <initializer_list>\n#include <optional>\n#include <string>\n#include <tuple>\n#include <vector>\n\nusing namespace aidl::android::hardware::graphics::allocator;\nusing namespace aidl::android::hardware::graphics::common;\nusing namespace android;\nusing namespace android::hardware;\nusing namespace ::android::hardware::graphics::mapper;\n\ntypedef AIMapper_Error (*AIMapper_loadIMapperFn)(AIMapper* _Nullable* _Nonnull outImplementation);\n\ninline constexpr BufferUsage operator|(BufferUsage lhs, BufferUsage rhs) {\n    using T = std::underlying_type_t<BufferUsage>;\n    return static_cast<BufferUsage>(static_cast<T>(lhs) | static_cast<T>(rhs));\n}\n\ninline BufferUsage& operator|=(BufferUsage& lhs, BufferUsage rhs) {\n    lhs = lhs | rhs;\n    return lhs;\n}\n\nstruct YCbCr {\n    android_ycbcr yCbCr;\n    int64_t horizontalSubSampling;\n    int64_t verticalSubSampling;\n};\n\nconstexpr const char* STANDARD_METADATA_NAME =\n        \"android.hardware.graphics.common.StandardMetadataType\";\n\nstatic bool isStandardMetadata(AIMapper_MetadataType metadataType) {\n    return strcmp(STANDARD_METADATA_NAME, metadataType.name) == 0;\n}\n\nstatic std::string toString(const std::vector<StandardMetadataType> types) {\n    std::stringstream buf;\n    buf << \"[\";\n    for (auto type : types) {\n        buf << toString(type) << \", \";\n    }\n    buf.seekp(-2, buf.cur);\n    buf << \"]\";\n    return buf.str();\n}\n\nclass BufferHandle {\n    AIMapper* mIMapper;\n    buffer_handle_t mHandle = nullptr;\n\n  public:\n    explicit BufferHandle(AIMapper* mapper, native_handle_t* rawHandle) : mIMapper(mapper) {\n        EXPECT_EQ(AIMAPPER_ERROR_NONE, mIMapper->v5.importBuffer(rawHandle, &mHandle));\n    }\n\n    explicit BufferHandle(BufferHandle&& other) { *this = std::move(other); }\n\n    BufferHandle& operator=(BufferHandle&& other) noexcept {\n        reset();\n        mIMapper = other.mIMapper;\n        mHandle = other.mHandle;\n        other.mHandle = nullptr;\n        return *this;\n    }\n\n    ~BufferHandle() { reset(); }\n\n    constexpr explicit operator bool() const noexcept { return mHandle != nullptr; }\n\n    buffer_handle_t operator*() const noexcept { return mHandle; }\n\n    void reset() {\n        if (mHandle != nullptr) {\n            EXPECT_EQ(AIMAPPER_ERROR_NONE, mIMapper->v5.freeBuffer(mHandle));\n            mHandle = nullptr;\n        }\n    }\n};\n\nclass BufferAllocation {\n    AIMapper* mIMapper;\n    native_handle_t* mRawHandle;\n    uint32_t mStride;\n    const BufferDescriptorInfo mInfo;\n\n  public:\n    BufferAllocation(const BufferAllocation&) = delete;\n    void operator=(const BufferAllocation&) = delete;\n\n    BufferAllocation(AIMapper* mapper, native_handle_t* handle, uint32_t stride,\n                     const BufferDescriptorInfo& info)\n        : mIMapper(mapper), mRawHandle(handle), mStride(stride), mInfo(info) {}\n\n    ~BufferAllocation() {\n        if (mRawHandle == nullptr) return;\n\n        native_handle_close(mRawHandle);\n        native_handle_delete(mRawHandle);\n    }\n\n    uint32_t stride() const { return mStride; }\n    const BufferDescriptorInfo& info() const { return mInfo; }\n\n    BufferHandle import() { return BufferHandle{mIMapper, mRawHandle}; }\n\n    const native_handle_t* rawHandle() const { return mRawHandle; }\n};\n\nclass GraphicsTestsBase {\n  private:\n    friend class BufferAllocation;\n    int32_t mIAllocatorVersion = 1;\n    std::shared_ptr<IAllocator> mAllocator;\n    AIMapper* mIMapper = nullptr;\n    AIMapper_loadIMapperFn mIMapperLoader;\n\n  protected:\n    void Initialize(std::shared_ptr<IAllocator> allocator) {\n        mAllocator = allocator;\n        ASSERT_NE(nullptr, mAllocator.get()) << \"failed to get allocator service\";\n        ASSERT_TRUE(mAllocator->getInterfaceVersion(&mIAllocatorVersion).isOk());\n        ASSERT_GE(mIAllocatorVersion, 2);\n        std::string mapperSuffix;\n        auto status = mAllocator->getIMapperLibrarySuffix(&mapperSuffix);\n        ASSERT_TRUE(status.isOk()) << \"Failed to get IMapper library suffix\";\n        std::string lib_name = \"mapper.\" + mapperSuffix + \".so\";\n        void* so = android_load_sphal_library(lib_name.c_str(), RTLD_LOCAL | RTLD_NOW);\n        ASSERT_NE(nullptr, so) << \"Failed to load \" << lib_name;\n        mIMapperLoader = (AIMapper_loadIMapperFn)dlsym(so, \"AIMapper_loadIMapper\");\n        ASSERT_NE(nullptr, mIMapperLoader) << \"AIMapper_locaIMapper missing from \" << lib_name;\n        ASSERT_EQ(AIMAPPER_ERROR_NONE, mIMapperLoader(&mIMapper));\n        ASSERT_NE(mIMapper, nullptr);\n    }\n\n  public:\n    AIMapper_loadIMapperFn getIMapperLoader() const { return mIMapperLoader; }\n\n    std::unique_ptr<BufferAllocation> allocate(const BufferDescriptorInfo& descriptorInfo) {\n        AllocationResult result;\n        ::ndk::ScopedAStatus status = mAllocator->allocate2(descriptorInfo, 1, &result);\n        if (!status.isOk()) {\n            status_t error = status.getExceptionCode();\n            if (error == EX_SERVICE_SPECIFIC) {\n                error = status.getServiceSpecificError();\n                EXPECT_NE(OK, error) << \"Failed to set error properly\";\n            } else {\n                EXPECT_EQ(OK, error) << \"Allocation transport failure\";\n            }\n            return nullptr;\n        } else {\n            return std::make_unique<BufferAllocation>(mIMapper, dupFromAidl(result.buffers[0]),\n                                                      result.stride, descriptorInfo);\n        }\n    }\n\n    std::unique_ptr<BufferAllocation> allocateGeneric() {\n        return allocate({\n                .name = {\"VTS_TEMP\"},\n                .width = 64,\n                .height = 64,\n                .layerCount = 1,\n                .format = PixelFormat::RGBA_8888,\n                .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n                .reservedSize = 0,\n        });\n    }\n\n    bool isSupported(const BufferDescriptorInfo& descriptorInfo) {\n        bool ret = false;\n        EXPECT_TRUE(mAllocator->isSupported(descriptorInfo, &ret).isOk());\n        return ret;\n    }\n\n    AIMapper* mapper() const { return mIMapper; }\n\n    template <StandardMetadataType T>\n    auto getStandardMetadata(buffer_handle_t bufferHandle)\n            -> decltype(StandardMetadata<T>::value::decode(nullptr, 0)) {\n        using Value = typename StandardMetadata<T>::value;\n        std::vector<uint8_t> buffer;\n        // Initial guess\n        buffer.resize(512);\n        int32_t sizeRequired = mapper()->v5.getStandardMetadata(\n                bufferHandle, static_cast<int64_t>(T), buffer.data(), buffer.size());\n        if (sizeRequired < 0) {\n            EXPECT_EQ(-AIMAPPER_ERROR_UNSUPPORTED, sizeRequired)\n                    << \"Received something other than UNSUPPORTED from valid getStandardMetadata \"\n                       \"call\";\n            return std::nullopt;\n        }\n        if (sizeRequired > buffer.size()) {\n            buffer.resize(sizeRequired);\n            sizeRequired = mapper()->v5.getStandardMetadata(bufferHandle, static_cast<int64_t>(T),\n                                                            buffer.data(), buffer.size());\n        }\n        if (sizeRequired < 0 || sizeRequired >= buffer.size()) {\n            ADD_FAILURE() << \"getStandardMetadata failed, received \" << sizeRequired\n                          << \" with buffer size \" << buffer.size();\n            // Generate a fail type\n            return std::nullopt;\n        }\n        return Value::decode(buffer.data(), sizeRequired);\n    }\n\n    template <StandardMetadataType T>\n    AIMapper_Error setStandardMetadata(buffer_handle_t bufferHandle,\n                                       const typename StandardMetadata<T>::value_type& value) {\n        using Value = typename StandardMetadata<T>::value;\n        int32_t sizeRequired = Value::encode(value, nullptr, 0);\n        if (sizeRequired < 0) {\n            EXPECT_GE(sizeRequired, 0) << \"Failed to calculate required size\";\n            return static_cast<AIMapper_Error>(-sizeRequired);\n        }\n        std::vector<uint8_t> buffer;\n        buffer.resize(sizeRequired);\n        sizeRequired = Value::encode(value, buffer.data(), buffer.size());\n        if (sizeRequired < 0 || sizeRequired > buffer.size()) {\n            ADD_FAILURE() << \"Failed to encode with calculated size \" << sizeRequired\n                          << \"; buffer size\" << buffer.size();\n            return static_cast<AIMapper_Error>(-sizeRequired);\n        }\n        return mapper()->v5.setStandardMetadata(bufferHandle, static_cast<int64_t>(T),\n                                                buffer.data(), sizeRequired);\n    }\n\n    void verifyRGBA8888PlaneLayouts(const std::vector<PlaneLayout>& planeLayouts) {\n        ASSERT_EQ(1, planeLayouts.size());\n\n        const auto& planeLayout = planeLayouts.front();\n\n        ASSERT_EQ(4, planeLayout.components.size());\n\n        int64_t offsetInBitsR = -1;\n        int64_t offsetInBitsG = -1;\n        int64_t offsetInBitsB = -1;\n        int64_t offsetInBitsA = -1;\n\n        for (const auto& component : planeLayout.components) {\n            if (!gralloc4::isStandardPlaneLayoutComponentType(component.type)) {\n                continue;\n            }\n            EXPECT_EQ(8, component.sizeInBits);\n            if (component.type.value == gralloc4::PlaneLayoutComponentType_R.value) {\n                offsetInBitsR = component.offsetInBits;\n            }\n            if (component.type.value == gralloc4::PlaneLayoutComponentType_G.value) {\n                offsetInBitsG = component.offsetInBits;\n            }\n            if (component.type.value == gralloc4::PlaneLayoutComponentType_B.value) {\n                offsetInBitsB = component.offsetInBits;\n            }\n            if (component.type.value == gralloc4::PlaneLayoutComponentType_A.value) {\n                offsetInBitsA = component.offsetInBits;\n            }\n        }\n\n        EXPECT_EQ(0, offsetInBitsR);\n        EXPECT_EQ(8, offsetInBitsG);\n        EXPECT_EQ(16, offsetInBitsB);\n        EXPECT_EQ(24, offsetInBitsA);\n\n        EXPECT_EQ(0, planeLayout.offsetInBytes);\n        EXPECT_EQ(32, planeLayout.sampleIncrementInBits);\n        // Skip testing stride because any stride is valid\n        EXPECT_LE(planeLayout.widthInSamples * planeLayout.heightInSamples * 4,\n                  planeLayout.totalSizeInBytes);\n        EXPECT_EQ(1, planeLayout.horizontalSubsampling);\n        EXPECT_EQ(1, planeLayout.verticalSubsampling);\n    }\n\n    void fillRGBA8888(uint8_t* data, uint32_t height, size_t strideInBytes, size_t widthInBytes) {\n        for (uint32_t y = 0; y < height; y++) {\n            memset(data, y, widthInBytes);\n            data += strideInBytes;\n        }\n    }\n\n    void verifyRGBA8888(const buffer_handle_t bufferHandle, const uint8_t* data, uint32_t height,\n                        size_t strideInBytes, size_t widthInBytes) {\n        auto decodeResult = getStandardMetadata<StandardMetadataType::PLANE_LAYOUTS>(bufferHandle);\n        ASSERT_TRUE(decodeResult.has_value());\n        const auto& planeLayouts = *decodeResult;\n        ASSERT_TRUE(planeLayouts.size() > 0);\n\n        verifyRGBA8888PlaneLayouts(planeLayouts);\n\n        for (uint32_t y = 0; y < height; y++) {\n            for (size_t i = 0; i < widthInBytes; i++) {\n                EXPECT_EQ(static_cast<uint8_t>(y), data[i]);\n            }\n            data += strideInBytes;\n        }\n    }\n\n    void traverseYCbCrData(const android_ycbcr& yCbCr, int32_t width, int32_t height,\n                           int64_t hSubsampling, int64_t vSubsampling,\n                           std::function<void(uint8_t*, uint8_t)> traverseFuncion) {\n        auto yData = static_cast<uint8_t*>(yCbCr.y);\n        auto cbData = static_cast<uint8_t*>(yCbCr.cb);\n        auto crData = static_cast<uint8_t*>(yCbCr.cr);\n        auto yStride = yCbCr.ystride;\n        auto cStride = yCbCr.cstride;\n        auto chromaStep = yCbCr.chroma_step;\n\n        for (uint32_t y = 0; y < height; y++) {\n            for (uint32_t x = 0; x < width; x++) {\n                auto val = static_cast<uint8_t>(height * y + x);\n\n                traverseFuncion(yData + yStride * y + x, val);\n\n                if (y % vSubsampling == 0 && x % hSubsampling == 0) {\n                    uint32_t subSampleX = x / hSubsampling;\n                    uint32_t subSampleY = y / vSubsampling;\n                    const auto subSampleOffset = cStride * subSampleY + chromaStep * subSampleX;\n                    const auto subSampleVal =\n                            static_cast<uint8_t>(height * subSampleY + subSampleX);\n\n                    traverseFuncion(cbData + subSampleOffset, subSampleVal);\n                    traverseFuncion(crData + subSampleOffset, subSampleVal + 1);\n                }\n            }\n        }\n    }\n\n    void fillYCbCrData(const android_ycbcr& yCbCr, int32_t width, int32_t height,\n                       int64_t hSubsampling, int64_t vSubsampling) {\n        traverseYCbCrData(yCbCr, width, height, hSubsampling, vSubsampling,\n                          [](auto address, auto fillingData) { *address = fillingData; });\n    }\n\n    void verifyYCbCrData(const android_ycbcr& yCbCr, int32_t width, int32_t height,\n                         int64_t hSubsampling, int64_t vSubsampling) {\n        traverseYCbCrData(\n                yCbCr, width, height, hSubsampling, vSubsampling,\n                [](auto address, auto expectedData) { EXPECT_EQ(*address, expectedData); });\n    }\n\n    constexpr uint64_t bitsToBytes(int64_t bits) { return bits / 8; }\n    constexpr uint64_t bytesToBits(int64_t bytes) { return bytes * 8; }\n\n    void getAndroidYCbCr(buffer_handle_t bufferHandle, uint8_t* data, android_ycbcr* outYCbCr,\n                         int64_t* hSubsampling, int64_t* vSubsampling) {\n        auto decodeResult = getStandardMetadata<StandardMetadataType::PLANE_LAYOUTS>(bufferHandle);\n        ASSERT_TRUE(decodeResult.has_value());\n        const auto& planeLayouts = *decodeResult;\n        ASSERT_TRUE(planeLayouts.size() > 0);\n\n        outYCbCr->y = nullptr;\n        outYCbCr->cb = nullptr;\n        outYCbCr->cr = nullptr;\n        outYCbCr->ystride = 0;\n        outYCbCr->cstride = 0;\n        outYCbCr->chroma_step = 0;\n\n        for (const auto& planeLayout : planeLayouts) {\n            for (const auto& planeLayoutComponent : planeLayout.components) {\n                if (!gralloc4::isStandardPlaneLayoutComponentType(planeLayoutComponent.type)) {\n                    continue;\n                }\n                ASSERT_EQ(0, planeLayoutComponent.offsetInBits % 8);\n\n                uint8_t* tmpData = data + planeLayout.offsetInBytes +\n                                   bitsToBytes(planeLayoutComponent.offsetInBits);\n                uint64_t sampleIncrementInBytes;\n\n                auto type = static_cast<PlaneLayoutComponentType>(planeLayoutComponent.type.value);\n                switch (type) {\n                    case PlaneLayoutComponentType::Y:\n                        ASSERT_EQ(nullptr, outYCbCr->y);\n                        ASSERT_EQ(8, planeLayoutComponent.sizeInBits);\n                        ASSERT_EQ(8, planeLayout.sampleIncrementInBits);\n                        outYCbCr->y = tmpData;\n                        outYCbCr->ystride = planeLayout.strideInBytes;\n                        break;\n\n                    case PlaneLayoutComponentType::CB:\n                    case PlaneLayoutComponentType::CR:\n                        ASSERT_EQ(0, planeLayout.sampleIncrementInBits % 8);\n\n                        sampleIncrementInBytes = planeLayout.sampleIncrementInBits / 8;\n                        ASSERT_TRUE(sampleIncrementInBytes == 1 || sampleIncrementInBytes == 2);\n\n                        if (outYCbCr->cstride == 0 && outYCbCr->chroma_step == 0) {\n                            outYCbCr->cstride = planeLayout.strideInBytes;\n                            outYCbCr->chroma_step = sampleIncrementInBytes;\n                        } else {\n                            ASSERT_EQ(outYCbCr->cstride, planeLayout.strideInBytes);\n                            ASSERT_EQ(outYCbCr->chroma_step, sampleIncrementInBytes);\n                        }\n\n                        if (*hSubsampling == 0 && *vSubsampling == 0) {\n                            *hSubsampling = planeLayout.horizontalSubsampling;\n                            *vSubsampling = planeLayout.verticalSubsampling;\n                        } else {\n                            ASSERT_EQ(*hSubsampling, planeLayout.horizontalSubsampling);\n                            ASSERT_EQ(*vSubsampling, planeLayout.verticalSubsampling);\n                        }\n\n                        if (type == PlaneLayoutComponentType::CB) {\n                            ASSERT_EQ(nullptr, outYCbCr->cb);\n                            outYCbCr->cb = tmpData;\n                        } else {\n                            ASSERT_EQ(nullptr, outYCbCr->cr);\n                            outYCbCr->cr = tmpData;\n                        }\n                        break;\n                    default:\n                        break;\n                };\n            }\n        }\n\n        ASSERT_NE(nullptr, outYCbCr->y);\n        ASSERT_NE(nullptr, outYCbCr->cb);\n        ASSERT_NE(nullptr, outYCbCr->cr);\n    }\n\n    YCbCr getAndroidYCbCr_P010(const native_handle_t* bufferHandle, uint8_t* data) {\n        YCbCr yCbCr_P010;\n        auto decodeResult = getStandardMetadata<StandardMetadataType::PLANE_LAYOUTS>(bufferHandle);\n        if (!decodeResult.has_value()) {\n            ADD_FAILURE() << \"failed to get plane layout\";\n            return YCbCr{};\n        }\n        const auto& planeLayouts = *decodeResult;\n        EXPECT_EQ(2, planeLayouts.size());\n        EXPECT_EQ(1, planeLayouts[0].components.size());\n        EXPECT_EQ(2, planeLayouts[1].components.size());\n\n        yCbCr_P010.yCbCr.y = nullptr;\n        yCbCr_P010.yCbCr.cb = nullptr;\n        yCbCr_P010.yCbCr.cr = nullptr;\n        yCbCr_P010.yCbCr.ystride = 0;\n        yCbCr_P010.yCbCr.cstride = 0;\n        yCbCr_P010.yCbCr.chroma_step = 0;\n        int64_t cb_offset = 0;\n        int64_t cr_offset = 0;\n\n        for (const auto& planeLayout : planeLayouts) {\n            for (const auto& planeLayoutComponent : planeLayout.components) {\n                if (!gralloc4::isStandardPlaneLayoutComponentType(planeLayoutComponent.type)) {\n                    continue;\n                }\n\n                uint8_t* tmpData = data + planeLayout.offsetInBytes +\n                                   bitsToBytes(planeLayoutComponent.offsetInBits);\n                uint64_t sampleIncrementInBytes = 0;\n                auto type = static_cast<PlaneLayoutComponentType>(planeLayoutComponent.type.value);\n                switch (type) {\n                    case PlaneLayoutComponentType::Y:\n                        // For specs refer:\n                        // https://docs.microsoft.com/en-us/windows/win32/medfound/10-bit-and-16-bit-yuv-video-formats\n                        EXPECT_EQ(6, planeLayoutComponent.offsetInBits);\n                        EXPECT_EQ(nullptr, yCbCr_P010.yCbCr.y);\n                        EXPECT_EQ(10, planeLayoutComponent.sizeInBits);\n                        EXPECT_EQ(16, planeLayout.sampleIncrementInBits);\n\n                        yCbCr_P010.yCbCr.y = tmpData;\n                        yCbCr_P010.yCbCr.ystride = planeLayout.strideInBytes;\n                        break;\n\n                    case PlaneLayoutComponentType::CB:\n                    case PlaneLayoutComponentType::CR:\n                        sampleIncrementInBytes = bitsToBytes(planeLayout.sampleIncrementInBits);\n                        EXPECT_EQ(4, sampleIncrementInBytes);\n\n                        if (yCbCr_P010.yCbCr.cstride == 0 && yCbCr_P010.yCbCr.chroma_step == 0) {\n                            yCbCr_P010.yCbCr.cstride = planeLayout.strideInBytes;\n                            yCbCr_P010.yCbCr.chroma_step = sampleIncrementInBytes;\n                        } else {\n                            EXPECT_EQ(yCbCr_P010.yCbCr.cstride, planeLayout.strideInBytes);\n                            EXPECT_EQ(yCbCr_P010.yCbCr.chroma_step, sampleIncrementInBytes);\n                        }\n\n                        if (yCbCr_P010.horizontalSubSampling == 0 &&\n                            yCbCr_P010.verticalSubSampling == 0) {\n                            yCbCr_P010.horizontalSubSampling = planeLayout.horizontalSubsampling;\n                            yCbCr_P010.verticalSubSampling = planeLayout.verticalSubsampling;\n                        } else {\n                            EXPECT_EQ(yCbCr_P010.horizontalSubSampling,\n                                      planeLayout.horizontalSubsampling);\n                            EXPECT_EQ(yCbCr_P010.verticalSubSampling,\n                                      planeLayout.verticalSubsampling);\n                        }\n\n                        if (type == PlaneLayoutComponentType::CB) {\n                            EXPECT_EQ(nullptr, yCbCr_P010.yCbCr.cb);\n                            yCbCr_P010.yCbCr.cb = tmpData;\n                            cb_offset = planeLayoutComponent.offsetInBits;\n                        } else {\n                            EXPECT_EQ(nullptr, yCbCr_P010.yCbCr.cr);\n                            yCbCr_P010.yCbCr.cr = tmpData;\n                            cr_offset = planeLayoutComponent.offsetInBits;\n                        }\n                        break;\n                    default:\n                        break;\n                };\n            }\n        }\n\n        EXPECT_EQ(cb_offset + bytesToBits(2), cr_offset);\n        EXPECT_NE(nullptr, yCbCr_P010.yCbCr.y);\n        EXPECT_NE(nullptr, yCbCr_P010.yCbCr.cb);\n        EXPECT_NE(nullptr, yCbCr_P010.yCbCr.cr);\n        return yCbCr_P010;\n    }\n};\n\nclass GraphicsMapperStableCTests\n    : public GraphicsTestsBase,\n      public ::testing::TestWithParam<std::tuple<std::string, std::shared_ptr<IAllocator>>> {\n  public:\n    void SetUp() override { Initialize(std::get<1>(GetParam())); }\n\n    void TearDown() override {}\n};\n\nTEST_P(GraphicsMapperStableCTests, AllV5CallbacksDefined) {\n    ASSERT_GE(mapper()->version, AIMAPPER_VERSION_5);\n\n    EXPECT_TRUE(mapper()->v5.importBuffer);\n    EXPECT_TRUE(mapper()->v5.freeBuffer);\n    EXPECT_TRUE(mapper()->v5.getTransportSize);\n    EXPECT_TRUE(mapper()->v5.lock);\n    EXPECT_TRUE(mapper()->v5.unlock);\n    EXPECT_TRUE(mapper()->v5.flushLockedBuffer);\n    EXPECT_TRUE(mapper()->v5.rereadLockedBuffer);\n    EXPECT_TRUE(mapper()->v5.getMetadata);\n    EXPECT_TRUE(mapper()->v5.getStandardMetadata);\n    EXPECT_TRUE(mapper()->v5.setMetadata);\n    EXPECT_TRUE(mapper()->v5.setStandardMetadata);\n    EXPECT_TRUE(mapper()->v5.listSupportedMetadataTypes);\n    EXPECT_TRUE(mapper()->v5.dumpBuffer);\n    EXPECT_TRUE(mapper()->v5.getReservedRegion);\n}\n\nTEST_P(GraphicsMapperStableCTests, DualLoadIsIdentical) {\n    ASSERT_GE(mapper()->version, AIMAPPER_VERSION_5);\n    AIMapper* secondMapper;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, getIMapperLoader()(&secondMapper));\n\n    EXPECT_EQ(secondMapper->v5.importBuffer, mapper()->v5.importBuffer);\n    EXPECT_EQ(secondMapper->v5.freeBuffer, mapper()->v5.freeBuffer);\n    EXPECT_EQ(secondMapper->v5.getTransportSize, mapper()->v5.getTransportSize);\n    EXPECT_EQ(secondMapper->v5.lock, mapper()->v5.lock);\n    EXPECT_EQ(secondMapper->v5.unlock, mapper()->v5.unlock);\n    EXPECT_EQ(secondMapper->v5.flushLockedBuffer, mapper()->v5.flushLockedBuffer);\n    EXPECT_EQ(secondMapper->v5.rereadLockedBuffer, mapper()->v5.rereadLockedBuffer);\n    EXPECT_EQ(secondMapper->v5.getMetadata, mapper()->v5.getMetadata);\n    EXPECT_EQ(secondMapper->v5.getStandardMetadata, mapper()->v5.getStandardMetadata);\n    EXPECT_EQ(secondMapper->v5.setMetadata, mapper()->v5.setMetadata);\n    EXPECT_EQ(secondMapper->v5.setStandardMetadata, mapper()->v5.setStandardMetadata);\n    EXPECT_EQ(secondMapper->v5.listSupportedMetadataTypes, mapper()->v5.listSupportedMetadataTypes);\n    EXPECT_EQ(secondMapper->v5.dumpBuffer, mapper()->v5.dumpBuffer);\n    EXPECT_EQ(secondMapper->v5.getReservedRegion, mapper()->v5.getReservedRegion);\n}\n\nTEST_P(GraphicsMapperStableCTests, CanAllocate) {\n    auto buffer = allocate({\n            .name = {\"VTS_TEMP\"},\n            .width = 64,\n            .height = 64,\n            .layerCount = 1,\n            .format = PixelFormat::RGBA_8888,\n            .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n            .reservedSize = 0,\n    });\n    ASSERT_NE(nullptr, buffer.get());\n    EXPECT_GE(buffer->stride(), 64);\n}\n\nTEST_P(GraphicsMapperStableCTests, ImportFreeBuffer) {\n    auto buffer = allocate({\n            .name = {\"VTS_TEMP\"},\n            .width = 64,\n            .height = 64,\n            .layerCount = 1,\n            .format = PixelFormat::RGBA_8888,\n            .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n            .reservedSize = 0,\n    });\n    ASSERT_NE(nullptr, buffer.get());\n    EXPECT_GE(buffer->stride(), 64);\n\n    {\n        auto import1 = buffer->import();\n        auto import2 = buffer->import();\n        EXPECT_TRUE(import1);\n        EXPECT_TRUE(import2);\n        EXPECT_NE(*import1, *import2);\n    }\n}\n\n/**\n * Test IMapper::importBuffer and IMapper::freeBuffer cross mapper instances.\n */\nTEST_P(GraphicsMapperStableCTests, ImportFreeBufferSingleton) {\n    auto buffer = allocate({\n            .name = {\"VTS_TEMP\"},\n            .width = 64,\n            .height = 64,\n            .layerCount = 1,\n            .format = PixelFormat::RGBA_8888,\n            .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n            .reservedSize = 0,\n    });\n    ASSERT_NE(nullptr, buffer.get());\n    EXPECT_GE(buffer->stride(), 64);\n\n    buffer_handle_t bufferHandle = nullptr;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.importBuffer(buffer->rawHandle(), &bufferHandle));\n    ASSERT_NE(nullptr, bufferHandle);\n\n    AIMapper* secondMapper;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, getIMapperLoader()(&secondMapper));\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, secondMapper->v5.freeBuffer(bufferHandle));\n}\n\n/**\n * Test IMapper::importBuffer with invalid buffers.\n */\nTEST_P(GraphicsMapperStableCTests, ImportBufferNegative) {\n    native_handle_t* invalidHandle = nullptr;\n    buffer_handle_t bufferHandle = nullptr;\n    EXPECT_EQ(AIMAPPER_ERROR_BAD_BUFFER, mapper()->v5.importBuffer(invalidHandle, &bufferHandle))\n            << \"importBuffer with nullptr did not fail with BAD_BUFFER\";\n\n    invalidHandle = native_handle_create(0, 0);\n    EXPECT_EQ(AIMAPPER_ERROR_BAD_BUFFER, mapper()->v5.importBuffer(invalidHandle, &bufferHandle))\n            << \"importBuffer with invalid handle did not fail with BAD_BUFFER\";\n    native_handle_delete(invalidHandle);\n}\n\n/**\n * Test IMapper::freeBuffer with invalid buffers.\n */\nTEST_P(GraphicsMapperStableCTests, FreeBufferNegative) {\n    native_handle_t* bufferHandle = nullptr;\n    EXPECT_EQ(AIMAPPER_ERROR_BAD_BUFFER, mapper()->v5.freeBuffer(bufferHandle))\n            << \"freeBuffer with nullptr did not fail with BAD_BUFFER\";\n\n    bufferHandle = native_handle_create(0, 0);\n    EXPECT_EQ(AIMAPPER_ERROR_BAD_BUFFER, mapper()->v5.freeBuffer(bufferHandle))\n            << \"freeBuffer with invalid handle did not fail with BAD_BUFFER\";\n    native_handle_delete(bufferHandle);\n\n    auto buffer = allocateGeneric();\n    EXPECT_EQ(AIMAPPER_ERROR_BAD_BUFFER, mapper()->v5.freeBuffer(buffer->rawHandle()))\n            << \"freeBuffer with un-imported handle did not fail with BAD_BUFFER\";\n}\n\n/**\n * Test IMapper::lock and IMapper::unlock.\n */\nTEST_P(GraphicsMapperStableCTests, LockUnlockBasic) {\n    constexpr auto usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN;\n    auto buffer = allocate({\n            .name = {\"VTS_TEMP\"},\n            .width = 64,\n            .height = 64,\n            .layerCount = 1,\n            .format = PixelFormat::RGBA_8888,\n            .usage = usage,\n            .reservedSize = 0,\n    });\n    ASSERT_NE(nullptr, buffer.get());\n\n    // lock buffer for writing\n    const auto& info = buffer->info();\n    const auto stride = buffer->stride();\n    const ARect region{0, 0, info.width, info.height};\n    auto handle = buffer->import();\n    uint8_t* data = nullptr;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE,\n              mapper()->v5.lock(*handle, static_cast<int64_t>(usage), region, -1, (void**)&data));\n\n    // RGBA_8888\n    fillRGBA8888(data, info.height, stride * 4, info.width * 4);\n\n    int releaseFence = -1;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence));\n\n    // lock again for reading\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.lock(*handle, static_cast<int64_t>(usage), region,\n                                                     releaseFence, (void**)&data));\n    releaseFence = -1;\n\n    ASSERT_NO_FATAL_FAILURE(verifyRGBA8888(*handle, data, info.height, stride * 4, info.width * 4));\n\n    releaseFence = -1;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence));\n    if (releaseFence != -1) {\n        close(releaseFence);\n    }\n}\n\n/**\n *  Test multiple operations associated with different color formats\n */\nTEST_P(GraphicsMapperStableCTests, Lock_YCRCB_420_SP) {\n    BufferDescriptorInfo info{\n            .name = {\"VTS_TEMP\"},\n            .width = 64,\n            .height = 64,\n            .layerCount = 1,\n            .format = PixelFormat::YCRCB_420_SP,\n            .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n            .reservedSize = 0,\n    };\n    auto buffer = allocate(info);\n    if (!buffer) {\n        ASSERT_FALSE(isSupported(info));\n        GTEST_SUCCEED() << \"YCRCB_420_SP format is unsupported\";\n        return;\n    }\n\n    // lock buffer for writing\n    const ARect region{0, 0, info.width, info.height};\n    auto handle = buffer->import();\n    uint8_t* data = nullptr;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.lock(*handle, static_cast<int64_t>(info.usage),\n                                                     region, -1, (void**)&data));\n\n    android_ycbcr yCbCr;\n    int64_t hSubsampling = 0;\n    int64_t vSubsampling = 0;\n    ASSERT_NO_FATAL_FAILURE(getAndroidYCbCr(*handle, data, &yCbCr, &hSubsampling, &vSubsampling));\n\n    constexpr uint32_t kCbCrSubSampleFactor = 2;\n    ASSERT_EQ(kCbCrSubSampleFactor, hSubsampling);\n    ASSERT_EQ(kCbCrSubSampleFactor, vSubsampling);\n\n    auto cbData = static_cast<uint8_t*>(yCbCr.cb);\n    auto crData = static_cast<uint8_t*>(yCbCr.cr);\n    ASSERT_EQ(crData + 1, cbData);\n    ASSERT_EQ(2, yCbCr.chroma_step);\n\n    fillYCbCrData(yCbCr, info.width, info.height, hSubsampling, vSubsampling);\n\n    int releaseFence = -1;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence));\n\n    // lock again for reading\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.lock(*handle, static_cast<int64_t>(info.usage),\n                                                     region, releaseFence, (void**)&data));\n    releaseFence = -1;\n\n    ASSERT_NO_FATAL_FAILURE(getAndroidYCbCr(*handle, data, &yCbCr, &hSubsampling, &vSubsampling));\n\n    verifyYCbCrData(yCbCr, info.width, info.height, hSubsampling, vSubsampling);\n\n    releaseFence = -1;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence));\n    if (releaseFence != -1) {\n        close(releaseFence);\n    }\n}\n\nTEST_P(GraphicsMapperStableCTests, YV12SubsampleMetadata) {\n    BufferDescriptorInfo info{\n            .name = {\"VTS_TEMP\"},\n            .width = 64,\n            .height = 64,\n            .layerCount = 1,\n            .format = PixelFormat::YV12,\n            .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n            .reservedSize = 0,\n    };\n    auto buffer = allocate(info);\n    ASSERT_NE(nullptr, buffer.get());\n\n    // lock buffer for writing\n    const ARect region{0, 0, info.width, info.height};\n    auto handle = buffer->import();\n    uint8_t* data = nullptr;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.lock(*handle, static_cast<int64_t>(info.usage),\n                                                     region, -1, (void**)&data));\n\n    auto decodeResult = getStandardMetadata<StandardMetadataType::PLANE_LAYOUTS>(*handle);\n    ASSERT_TRUE(decodeResult.has_value());\n    const auto& planeLayouts = *decodeResult;\n\n    ASSERT_EQ(3, planeLayouts.size());\n\n    auto yPlane = planeLayouts[0];\n    auto crPlane = planeLayouts[1];\n    auto cbPlane = planeLayouts[2];\n\n    constexpr uint32_t kCbCrSubSampleFactor = 2;\n    EXPECT_EQ(kCbCrSubSampleFactor, crPlane.horizontalSubsampling);\n    EXPECT_EQ(kCbCrSubSampleFactor, crPlane.verticalSubsampling);\n\n    EXPECT_EQ(kCbCrSubSampleFactor, cbPlane.horizontalSubsampling);\n    EXPECT_EQ(kCbCrSubSampleFactor, cbPlane.verticalSubsampling);\n\n    const long chromaSampleWidth = info.width / kCbCrSubSampleFactor;\n    const long chromaSampleHeight = info.height / kCbCrSubSampleFactor;\n\n    EXPECT_EQ(info.width, yPlane.widthInSamples);\n    EXPECT_EQ(info.height, yPlane.heightInSamples);\n\n    EXPECT_EQ(chromaSampleWidth, crPlane.widthInSamples);\n    EXPECT_EQ(chromaSampleHeight, crPlane.heightInSamples);\n\n    EXPECT_EQ(chromaSampleWidth, cbPlane.widthInSamples);\n    EXPECT_EQ(chromaSampleHeight, cbPlane.heightInSamples);\n\n    EXPECT_LE(crPlane.widthInSamples, crPlane.strideInBytes);\n    EXPECT_LE(cbPlane.widthInSamples, cbPlane.strideInBytes);\n\n    int releaseFence = -1;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence));\n    if (releaseFence != -1) {\n        close(releaseFence);\n    }\n}\n\nTEST_P(GraphicsMapperStableCTests, Lock_YV12) {\n    BufferDescriptorInfo info{\n            .name = {\"VTS_TEMP\"},\n            .width = 64,\n            .height = 64,\n            .layerCount = 1,\n            .format = PixelFormat::YV12,\n            .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n            .reservedSize = 0,\n    };\n    auto buffer = allocate(info);\n    ASSERT_NE(nullptr, buffer.get());\n\n    // lock buffer for writing\n    const ARect region{0, 0, info.width, info.height};\n    auto handle = buffer->import();\n    uint8_t* data = nullptr;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.lock(*handle, static_cast<int64_t>(info.usage),\n                                                     region, -1, (void**)&data));\n\n    android_ycbcr yCbCr;\n    int64_t hSubsampling = 0;\n    int64_t vSubsampling = 0;\n    ASSERT_NO_FATAL_FAILURE(getAndroidYCbCr(*handle, data, &yCbCr, &hSubsampling, &vSubsampling));\n\n    constexpr uint32_t kCbCrSubSampleFactor = 2;\n    ASSERT_EQ(kCbCrSubSampleFactor, hSubsampling);\n    ASSERT_EQ(kCbCrSubSampleFactor, vSubsampling);\n\n    auto cbData = static_cast<uint8_t*>(yCbCr.cb);\n    auto crData = static_cast<uint8_t*>(yCbCr.cr);\n    ASSERT_EQ(crData + yCbCr.cstride * info.height / vSubsampling, cbData);\n    ASSERT_EQ(1, yCbCr.chroma_step);\n\n    fillYCbCrData(yCbCr, info.width, info.height, hSubsampling, vSubsampling);\n\n    int releaseFence = -1;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence));\n\n    // lock again for reading\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.lock(*handle, static_cast<int64_t>(info.usage),\n                                                     region, releaseFence, (void**)&data));\n    releaseFence = -1;\n\n    ASSERT_NO_FATAL_FAILURE(getAndroidYCbCr(*handle, data, &yCbCr, &hSubsampling, &vSubsampling));\n\n    verifyYCbCrData(yCbCr, info.width, info.height, hSubsampling, vSubsampling);\n\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence));\n    if (releaseFence != -1) {\n        close(releaseFence);\n    }\n}\n\nTEST_P(GraphicsMapperStableCTests, Lock_YCBCR_420_888) {\n    BufferDescriptorInfo info{\n            .name = {\"VTS_TEMP\"},\n            .width = 64,\n            .height = 64,\n            .layerCount = 1,\n            .format = PixelFormat::YCBCR_420_888,\n            .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n            .reservedSize = 0,\n    };\n    auto buffer = allocate(info);\n    ASSERT_NE(nullptr, buffer.get());\n\n    // lock buffer for writing\n    const ARect region{0, 0, info.width, info.height};\n    auto handle = buffer->import();\n    uint8_t* data = nullptr;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.lock(*handle, static_cast<int64_t>(info.usage),\n                                                     region, -1, (void**)&data));\n\n    android_ycbcr yCbCr;\n    int64_t hSubsampling = 0;\n    int64_t vSubsampling = 0;\n    ASSERT_NO_FATAL_FAILURE(getAndroidYCbCr(*handle, data, &yCbCr, &hSubsampling, &vSubsampling));\n\n    constexpr uint32_t kCbCrSubSampleFactor = 2;\n    ASSERT_EQ(kCbCrSubSampleFactor, hSubsampling);\n    ASSERT_EQ(kCbCrSubSampleFactor, vSubsampling);\n\n    fillYCbCrData(yCbCr, info.width, info.height, hSubsampling, vSubsampling);\n\n    int releaseFence = -1;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence));\n\n    // lock again for reading\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.lock(*handle, static_cast<int64_t>(info.usage),\n                                                     region, releaseFence, (void**)&data));\n    releaseFence = -1;\n\n    ASSERT_NO_FATAL_FAILURE(getAndroidYCbCr(*handle, data, &yCbCr, &hSubsampling, &vSubsampling));\n\n    verifyYCbCrData(yCbCr, info.width, info.height, hSubsampling, vSubsampling);\n\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence));\n    if (releaseFence != -1) {\n        close(releaseFence);\n    }\n}\n\nTEST_P(GraphicsMapperStableCTests, Lock_RAW10) {\n    BufferDescriptorInfo info{\n            .name = {\"VTS_TEMP\"},\n            .width = 64,\n            .height = 64,\n            .layerCount = 1,\n            .format = PixelFormat::RAW10,\n            .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n            .reservedSize = 0,\n    };\n    auto buffer = allocate(info);\n    if (!buffer) {\n        ASSERT_FALSE(isSupported(info));\n        GTEST_SUCCEED() << \"RAW10 format is unsupported\";\n        return;\n    }\n\n    // lock buffer for writing\n    const ARect region{0, 0, info.width, info.height};\n    auto handle = buffer->import();\n    uint8_t* data = nullptr;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.lock(*handle, static_cast<int64_t>(info.usage),\n                                                     region, -1, (void**)&data));\n\n    auto decodeResult = getStandardMetadata<StandardMetadataType::PLANE_LAYOUTS>(*handle);\n    ASSERT_TRUE(decodeResult.has_value());\n    const auto& planeLayouts = *decodeResult;\n\n    ASSERT_EQ(1, planeLayouts.size());\n    auto planeLayout = planeLayouts[0];\n\n    EXPECT_EQ(0, planeLayout.sampleIncrementInBits);\n    EXPECT_EQ(1, planeLayout.horizontalSubsampling);\n    EXPECT_EQ(1, planeLayout.verticalSubsampling);\n\n    ASSERT_EQ(1, planeLayout.components.size());\n    auto planeLayoutComponent = planeLayout.components[0];\n\n    EXPECT_EQ(PlaneLayoutComponentType::RAW,\n              static_cast<PlaneLayoutComponentType>(planeLayoutComponent.type.value));\n    EXPECT_EQ(0, planeLayoutComponent.offsetInBits % 8);\n    EXPECT_EQ(-1, planeLayoutComponent.sizeInBits);\n\n    int releaseFence = -1;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence));\n    if (releaseFence != -1) {\n        close(releaseFence);\n    }\n}\n\nTEST_P(GraphicsMapperStableCTests, Lock_RAW12) {\n    BufferDescriptorInfo info{\n            .name = {\"VTS_TEMP\"},\n            .width = 64,\n            .height = 64,\n            .layerCount = 1,\n            .format = PixelFormat::RAW12,\n            .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n            .reservedSize = 0,\n    };\n    auto buffer = allocate(info);\n    if (!buffer) {\n        ASSERT_FALSE(isSupported(info));\n        GTEST_SUCCEED() << \"RAW12 format is unsupported\";\n        return;\n    }\n\n    // lock buffer for writing\n    const ARect region{0, 0, info.width, info.height};\n    auto handle = buffer->import();\n    uint8_t* data = nullptr;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.lock(*handle, static_cast<int64_t>(info.usage),\n                                                     region, -1, (void**)&data));\n\n    auto decodeResult = getStandardMetadata<StandardMetadataType::PLANE_LAYOUTS>(*handle);\n    ASSERT_TRUE(decodeResult.has_value());\n    const auto& planeLayouts = *decodeResult;\n\n    ASSERT_EQ(1, planeLayouts.size());\n    auto planeLayout = planeLayouts[0];\n\n    EXPECT_EQ(0, planeLayout.sampleIncrementInBits);\n    EXPECT_EQ(1, planeLayout.horizontalSubsampling);\n    EXPECT_EQ(1, planeLayout.verticalSubsampling);\n\n    ASSERT_EQ(1, planeLayout.components.size());\n    auto planeLayoutComponent = planeLayout.components[0];\n\n    EXPECT_EQ(PlaneLayoutComponentType::RAW,\n              static_cast<PlaneLayoutComponentType>(planeLayoutComponent.type.value));\n    EXPECT_EQ(0, planeLayoutComponent.offsetInBits % 8);\n    EXPECT_EQ(-1, planeLayoutComponent.sizeInBits);\n\n    int releaseFence = -1;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence));\n    if (releaseFence != -1) {\n        close(releaseFence);\n    }\n}\n\nTEST_P(GraphicsMapperStableCTests, Lock_YCBCR_P010) {\n    BufferDescriptorInfo info{\n            .name = {\"VTS_TEMP\"},\n            .width = 64,\n            .height = 64,\n            .layerCount = 1,\n            .format = PixelFormat::YCBCR_P010,\n            .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n            .reservedSize = 0,\n    };\n    auto buffer = allocate(info);\n    if (!buffer) {\n        ASSERT_FALSE(isSupported(info));\n        GTEST_SUCCEED() << \"YCBCR_P010 format is unsupported\";\n        return;\n    }\n\n    // lock buffer for writing\n    const ARect region{0, 0, info.width, info.height};\n    auto handle = buffer->import();\n    uint8_t* data = nullptr;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.lock(*handle, static_cast<int64_t>(info.usage),\n                                                     region, -1, (void**)&data));\n\n    YCbCr yCbCr;\n    ASSERT_NO_FATAL_FAILURE(yCbCr = getAndroidYCbCr_P010(*handle, data));\n\n    constexpr uint32_t kCbCrSubSampleFactor = 2;\n    ASSERT_EQ(kCbCrSubSampleFactor, yCbCr.horizontalSubSampling);\n    ASSERT_EQ(kCbCrSubSampleFactor, yCbCr.verticalSubSampling);\n\n    ASSERT_EQ(0, info.height % 2);\n\n    // fill the data\n    fillYCbCrData(yCbCr.yCbCr, info.width, info.height, yCbCr.horizontalSubSampling,\n                  yCbCr.verticalSubSampling);\n    // verify the YCbCr data\n    verifyYCbCrData(yCbCr.yCbCr, info.width, info.height, yCbCr.horizontalSubSampling,\n                    yCbCr.verticalSubSampling);\n\n    int releaseFence = -1;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence));\n    if (releaseFence != -1) {\n        close(releaseFence);\n    }\n}\n\nTEST_P(GraphicsMapperStableCTests, LockBadAccessRegion) {\n    auto buffer = allocateGeneric();\n    ASSERT_NE(nullptr, buffer);\n    const auto& info = buffer->info();\n\n    // lock buffer for writing\n    const ARect region{0, 0, info.width * 2, info.height * 2};\n    auto handle = buffer->import();\n    uint8_t* data = nullptr;\n    EXPECT_EQ(AIMAPPER_ERROR_BAD_VALUE, mapper()->v5.lock(*handle, static_cast<int64_t>(info.usage),\n                                                          region, -1, (void**)&data));\n}\n\nTEST_P(GraphicsMapperStableCTests, UnlockNegative) {\n    native_handle_t* invalidHandle = nullptr;\n    int releaseFence = -1;\n    EXPECT_EQ(AIMAPPER_ERROR_BAD_BUFFER, mapper()->v5.unlock(invalidHandle, &releaseFence))\n            << \"unlock with nullptr did not fail with BAD_BUFFER\";\n\n    invalidHandle = native_handle_create(0, 0);\n    EXPECT_EQ(AIMAPPER_ERROR_BAD_BUFFER, mapper()->v5.unlock(invalidHandle, &releaseFence))\n            << \"unlock with invalid handle did not fail with BAD_BUFFER\";\n    native_handle_delete(invalidHandle);\n\n    auto buffer = allocateGeneric();\n    EXPECT_EQ(AIMAPPER_ERROR_BAD_BUFFER, mapper()->v5.unlock(buffer->rawHandle(), &releaseFence))\n            << \"unlock with un-imported handle did not fail with BAD_BUFFER\";\n}\n\nTEST_P(GraphicsMapperStableCTests, UnlockNotImported) {\n    int releaseFence = -1;\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    EXPECT_EQ(AIMAPPER_ERROR_BAD_BUFFER, mapper()->v5.unlock(buffer->rawHandle(), &releaseFence))\n            << \"unlock with un-imported handle did not fail with BAD_BUFFER\";\n}\n\nTEST_P(GraphicsMapperStableCTests, UnlockNotLocked) {\n    int releaseFence = -1;\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    EXPECT_EQ(AIMAPPER_ERROR_BAD_BUFFER, mapper()->v5.unlock(*bufferHandle, &releaseFence))\n            << \"unlock with unlocked handle did not fail with BAD_BUFFER\";\n}\n\nTEST_P(GraphicsMapperStableCTests, LockUnlockNested) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    const ARect region{0, 0, buffer->info().width, buffer->info().height};\n    auto usage = static_cast<int64_t>(buffer->info().usage);\n    auto handle = buffer->import();\n    uint8_t* data = nullptr;\n    EXPECT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.lock(*handle, usage, region, -1, (void**)&data));\n    EXPECT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.lock(*handle, usage, region, -1, (void**)&data))\n            << \"Second lock failed\";\n    int releaseFence = -1;\n    EXPECT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence));\n    if (releaseFence != -1) {\n        close(releaseFence);\n        releaseFence = -1;\n    }\n    EXPECT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence))\n            << \"Second unlock failed\";\n    if (releaseFence != -1) {\n        close(releaseFence);\n        releaseFence = -1;\n    }\n    EXPECT_EQ(AIMAPPER_ERROR_BAD_BUFFER, mapper()->v5.unlock(*handle, &releaseFence))\n            << \"Third, unmatched, unlock should have failed with BAD_BUFFER\";\n}\n\nTEST_P(GraphicsMapperStableCTests, FlushRereadBasic) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    const auto& info = buffer->info();\n    const auto stride = buffer->stride();\n    const ARect region{0, 0, buffer->info().width, buffer->info().height};\n\n    auto writeHandle = buffer->import();\n    auto readHandle = buffer->import();\n    ASSERT_TRUE(writeHandle && readHandle);\n\n    // lock buffer for writing\n\n    uint8_t* writeData;\n    EXPECT_EQ(AIMAPPER_ERROR_NONE,\n              mapper()->v5.lock(*writeHandle, static_cast<uint64_t>(BufferUsage::CPU_WRITE_OFTEN),\n                                region, -1, (void**)&writeData));\n\n    uint8_t* readData;\n    EXPECT_EQ(AIMAPPER_ERROR_NONE,\n              mapper()->v5.lock(*readHandle, static_cast<uint64_t>(BufferUsage::CPU_READ_OFTEN),\n                                region, -1, (void**)&readData));\n\n    fillRGBA8888(writeData, info.height, stride * 4, info.width * 4);\n\n    EXPECT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.flushLockedBuffer(*writeHandle));\n    EXPECT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.rereadLockedBuffer(*readHandle));\n\n    ASSERT_NO_FATAL_FAILURE(\n            verifyRGBA8888(*readHandle, readData, info.height, stride * 4, info.width * 4));\n\n    int releaseFence = -1;\n\n    EXPECT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*readHandle, &releaseFence));\n    if (releaseFence != -1) {\n        close(releaseFence);\n        releaseFence = -1;\n    }\n\n    EXPECT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*writeHandle, &releaseFence));\n    if (releaseFence != -1) {\n        close(releaseFence);\n        releaseFence = -1;\n    }\n}\n\nTEST_P(GraphicsMapperStableCTests, FlushLockedBufferBadBuffer) {\n    // Amazingly this is enough to make the compiler happy even though flushLockedBuffer\n    // is _Nonnull :shrug:\n    buffer_handle_t badBuffer = nullptr;\n    EXPECT_EQ(AIMAPPER_ERROR_BAD_BUFFER, mapper()->v5.flushLockedBuffer(badBuffer));\n}\n\nTEST_P(GraphicsMapperStableCTests, RereadLockedBufferBadBuffer) {\n    buffer_handle_t badBuffer = nullptr;\n    EXPECT_EQ(AIMAPPER_ERROR_BAD_BUFFER, mapper()->v5.rereadLockedBuffer(badBuffer));\n}\n\nTEST_P(GraphicsMapperStableCTests, GetBufferId) {\n    auto buffer = allocateGeneric();\n    auto bufferHandle = buffer->import();\n    auto bufferId = getStandardMetadata<StandardMetadataType::BUFFER_ID>(*bufferHandle);\n    ASSERT_TRUE(bufferId.has_value());\n\n    auto buffer2 = allocateGeneric();\n    auto bufferHandle2 = buffer2->import();\n    auto bufferId2 = getStandardMetadata<StandardMetadataType::BUFFER_ID>(*bufferHandle2);\n    ASSERT_TRUE(bufferId2.has_value());\n\n    EXPECT_NE(*bufferId, *bufferId2);\n}\n\nTEST_P(GraphicsMapperStableCTests, GetName) {\n    auto buffer = allocate({\n            .name = {\"Hello, World!\"},\n            .width = 64,\n            .height = 64,\n            .layerCount = 1,\n            .format = PixelFormat::RGBA_8888,\n            .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n            .reservedSize = 0,\n    });\n    auto bufferHandle = buffer->import();\n    auto name = getStandardMetadata<StandardMetadataType::NAME>(*bufferHandle);\n    ASSERT_TRUE(name.has_value());\n    EXPECT_EQ(*name, \"Hello, World!\");\n}\n\nTEST_P(GraphicsMapperStableCTests, GetWidthHeight) {\n    auto buffer = allocate({\n            .name = {\"Hello, World!\"},\n            .width = 64,\n            .height = 128,\n            .layerCount = 1,\n            .format = PixelFormat::RGBA_8888,\n            .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n            .reservedSize = 0,\n    });\n    auto bufferHandle = buffer->import();\n    auto value = getStandardMetadata<StandardMetadataType::WIDTH>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_EQ(*value, 64);\n    value = getStandardMetadata<StandardMetadataType::HEIGHT>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_EQ(*value, 128);\n}\n\nTEST_P(GraphicsMapperStableCTests, GetLayerCount) {\n    auto buffer = allocateGeneric();\n    auto bufferHandle = buffer->import();\n    auto value = getStandardMetadata<StandardMetadataType::LAYER_COUNT>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_EQ(*value, buffer->info().layerCount);\n}\n\nTEST_P(GraphicsMapperStableCTests, GetPixelFormatRequested) {\n    auto buffer = allocateGeneric();\n    auto bufferHandle = buffer->import();\n    auto value = getStandardMetadata<StandardMetadataType::PIXEL_FORMAT_REQUESTED>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_EQ(*value, buffer->info().format);\n}\n\nTEST_P(GraphicsMapperStableCTests, GetPixelFormatFourCC) {\n    auto buffer = allocate({\n            .name = {\"Hello, World!\"},\n            .width = 64,\n            .height = 128,\n            .layerCount = 1,\n            .format = PixelFormat::RGBA_8888,\n            .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n            .reservedSize = 0,\n    });\n    {\n        auto bufferHandle = buffer->import();\n        auto value = getStandardMetadata<StandardMetadataType::PIXEL_FORMAT_FOURCC>(*bufferHandle);\n        ASSERT_TRUE(value.has_value());\n        EXPECT_EQ(*value, DRM_FORMAT_ABGR8888);\n    }\n\n    buffer = allocate({\n            .name = {\"yv12\"},\n            .width = 64,\n            .height = 128,\n            .layerCount = 1,\n            .format = PixelFormat::YV12,\n            .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n            .reservedSize = 0,\n    });\n    {\n        auto bufferHandle = buffer->import();\n        auto value = getStandardMetadata<StandardMetadataType::PIXEL_FORMAT_FOURCC>(*bufferHandle);\n        ASSERT_TRUE(value.has_value());\n        EXPECT_EQ(*value, DRM_FORMAT_YVU420);\n    }\n}\n\nTEST_P(GraphicsMapperStableCTests, GetPixelFormatModifier) {\n    auto buffer = allocateGeneric();\n    auto bufferHandle = buffer->import();\n    auto value = getStandardMetadata<StandardMetadataType::PIXEL_FORMAT_MODIFIER>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    // Only the upper 8-bits are defined and is just the vendor ID, the lower 56 bits are\n    // then vendor specific. So there's not anything useful to assert here beyond just that\n    // we successfully queried a value\n}\n\nTEST_P(GraphicsMapperStableCTests, GetUsage) {\n    auto buffer = allocateGeneric();\n    auto bufferHandle = buffer->import();\n    auto value = getStandardMetadata<StandardMetadataType::USAGE>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_EQ(buffer->info().usage, *value);\n}\n\nTEST_P(GraphicsMapperStableCTests, GetAllocationSize) {\n    auto buffer = allocateGeneric();\n    auto bufferHandle = buffer->import();\n    auto value = getStandardMetadata<StandardMetadataType::ALLOCATION_SIZE>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    const auto estimatedSize = buffer->stride() * buffer->info().height * 4;\n    // This buffer has CPU usage, so we expect at least stride * height * 4 since it should be\n    // generally linear uncompressed.\n    EXPECT_GE(*value, estimatedSize)\n            << \"Expected allocation size to be at least stride * height * 4bpp\";\n    // Might need refining, but hopefully this a generous-enough upper-bound?\n    EXPECT_LT(*value, estimatedSize * 2)\n            << \"Expected allocation size to less than double stride * height * 4bpp\";\n}\n\nTEST_P(GraphicsMapperStableCTests, GetProtectedContent) {\n    const BufferDescriptorInfo info{\n            .name = {\"prot8888\"},\n            .width = 64,\n            .height = 64,\n            .layerCount = 1,\n            .format = PixelFormat::RGBA_8888,\n            .usage = BufferUsage::PROTECTED | BufferUsage::COMPOSER_OVERLAY,\n            .reservedSize = 0,\n    };\n    auto buffer = allocate(info);\n    if (!buffer) {\n        ASSERT_FALSE(isSupported(info))\n                << \"Allocation of trivial sized buffer failed, so isSupported() must be false\";\n        GTEST_SUCCEED() << \"PROTECTED RGBA_8888 is unsupported\";\n        return;\n    }\n    auto bufferHandle = buffer->import();\n    auto value = getStandardMetadata<StandardMetadataType::PROTECTED_CONTENT>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_EQ(*value, 1);\n}\n\nTEST_P(GraphicsMapperStableCTests, GetCompression) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    auto value = getStandardMetadata<StandardMetadataType::COMPRESSION>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_EQ(gralloc4::Compression_None.name, value->name);\n    EXPECT_EQ(gralloc4::Compression_None.value, value->value);\n}\n\nTEST_P(GraphicsMapperStableCTests, GetInterlaced) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    auto value = getStandardMetadata<StandardMetadataType::INTERLACED>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_EQ(gralloc4::Interlaced_None.name, value->name);\n    EXPECT_EQ(gralloc4::Interlaced_None.value, value->value);\n}\n\nTEST_P(GraphicsMapperStableCTests, GetChromaSiting) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    auto value = getStandardMetadata<StandardMetadataType::CHROMA_SITING>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_EQ(gralloc4::ChromaSiting_None.name, value->name);\n    EXPECT_EQ(gralloc4::ChromaSiting_None.value, value->value);\n}\n\nTEST_P(GraphicsMapperStableCTests, GetPlaneLayouts) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    auto value = getStandardMetadata<StandardMetadataType::PLANE_LAYOUTS>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    ASSERT_NO_FATAL_FAILURE(verifyRGBA8888PlaneLayouts(*value));\n}\n\nTEST_P(GraphicsMapperStableCTests, GetCrop) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    auto value = getStandardMetadata<StandardMetadataType::CROP>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_EQ(1, value->size());\n    const Rect expected{0, 0, buffer->info().width, buffer->info().height};\n    EXPECT_EQ(expected, value->at(0));\n}\n\nTEST_P(GraphicsMapperStableCTests, GetSetDataspace) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    auto value = getStandardMetadata<StandardMetadataType::DATASPACE>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_EQ(Dataspace::UNKNOWN, *value);\n    EXPECT_EQ(AIMAPPER_ERROR_NONE, setStandardMetadata<StandardMetadataType::DATASPACE>(\n                                           *bufferHandle, Dataspace::DISPLAY_P3));\n    value = getStandardMetadata<StandardMetadataType::DATASPACE>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_EQ(Dataspace::DISPLAY_P3, *value);\n}\n\nTEST_P(GraphicsMapperStableCTests, GetSetBlendMode) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    auto value = getStandardMetadata<StandardMetadataType::BLEND_MODE>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_EQ(BlendMode::INVALID, *value);\n    EXPECT_EQ(AIMAPPER_ERROR_NONE, setStandardMetadata<StandardMetadataType::BLEND_MODE>(\n                                           *bufferHandle, BlendMode::COVERAGE));\n    value = getStandardMetadata<StandardMetadataType::BLEND_MODE>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_EQ(BlendMode::COVERAGE, *value);\n}\n\nTEST_P(GraphicsMapperStableCTests, GetSetSmpte2086) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    auto value = getStandardMetadata<StandardMetadataType::SMPTE2086>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_FALSE(value->has_value());\n\n    // TODO: Maybe use something resembling real values, but validation isn't supposed to happen\n    // here anyway so :shrug:\n    const Smpte2086 awesomeHdr{\n            XyColor{1.f, 1.f},      XyColor{2.f, 2.f}, XyColor{3.f, 3.f},\n            XyColor{400.f, 1000.f}, 100000.0f,         0.0001f,\n    };\n    EXPECT_EQ(AIMAPPER_ERROR_NONE,\n              setStandardMetadata<StandardMetadataType::SMPTE2086>(*bufferHandle, awesomeHdr));\n    value = getStandardMetadata<StandardMetadataType::SMPTE2086>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    ASSERT_TRUE(value->has_value());\n    EXPECT_EQ(awesomeHdr, *value);\n\n    EXPECT_EQ(AIMAPPER_ERROR_NONE,\n              setStandardMetadata<StandardMetadataType::SMPTE2086>(*bufferHandle, std::nullopt));\n    value = getStandardMetadata<StandardMetadataType::SMPTE2086>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_FALSE(value->has_value());\n}\n\nTEST_P(GraphicsMapperStableCTests, GetCta861_3) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    auto value = getStandardMetadata<StandardMetadataType::CTA861_3>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_FALSE(value->has_value());\n\n    const Cta861_3 genericHlgish{1000.f, 140.f};\n    EXPECT_EQ(AIMAPPER_ERROR_NONE,\n              setStandardMetadata<StandardMetadataType::CTA861_3>(*bufferHandle, genericHlgish));\n    value = getStandardMetadata<StandardMetadataType::CTA861_3>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    ASSERT_TRUE(value->has_value());\n    EXPECT_EQ(genericHlgish, *value);\n\n    EXPECT_EQ(AIMAPPER_ERROR_NONE,\n              setStandardMetadata<StandardMetadataType::CTA861_3>(*bufferHandle, std::nullopt));\n    value = getStandardMetadata<StandardMetadataType::CTA861_3>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_FALSE(value->has_value());\n}\n\nTEST_P(GraphicsMapperStableCTests, GetSmpte2094_10) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    auto value = getStandardMetadata<StandardMetadataType::SMPTE2094_10>(*bufferHandle);\n    if (value.has_value()) {\n        EXPECT_FALSE(value->has_value());\n    }\n}\n\nTEST_P(GraphicsMapperStableCTests, GetSmpte2094_40) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    auto value = getStandardMetadata<StandardMetadataType::SMPTE2094_40>(*bufferHandle);\n    if (value.has_value()) {\n        EXPECT_FALSE(value->has_value());\n    }\n}\n\nTEST_P(GraphicsMapperStableCTests, SupportsRequiredGettersSetters) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    const AIMapper_MetadataTypeDescription* descriptions = nullptr;\n    size_t descriptionCount = 0;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE,\n              mapper()->v5.listSupportedMetadataTypes(&descriptions, &descriptionCount));\n    std::vector<StandardMetadataType> requiredGetters = {\n            StandardMetadataType::BUFFER_ID,\n            StandardMetadataType::NAME,\n            StandardMetadataType::WIDTH,\n            StandardMetadataType::HEIGHT,\n            StandardMetadataType::LAYER_COUNT,\n            StandardMetadataType::PIXEL_FORMAT_REQUESTED,\n            StandardMetadataType::PIXEL_FORMAT_FOURCC,\n            StandardMetadataType::PIXEL_FORMAT_MODIFIER,\n            StandardMetadataType::USAGE,\n            StandardMetadataType::ALLOCATION_SIZE,\n            StandardMetadataType::PROTECTED_CONTENT,\n            StandardMetadataType::COMPRESSION,\n            StandardMetadataType::INTERLACED,\n            StandardMetadataType::CHROMA_SITING,\n            StandardMetadataType::PLANE_LAYOUTS,\n            StandardMetadataType::CROP,\n            StandardMetadataType::DATASPACE,\n            StandardMetadataType::BLEND_MODE,\n            StandardMetadataType::SMPTE2086,\n            StandardMetadataType::CTA861_3,\n    };\n\n    std::vector<StandardMetadataType> requiredSetters = {\n            StandardMetadataType::DATASPACE,\n            StandardMetadataType::BLEND_MODE,\n            StandardMetadataType::SMPTE2086,\n            StandardMetadataType::CTA861_3,\n    };\n\n    for (int i = 0; i < descriptionCount; i++) {\n        const auto& it = descriptions[i];\n        if (isStandardMetadata(it.metadataType)) {\n            EXPECT_GT(it.metadataType.value, static_cast<int64_t>(StandardMetadataType::INVALID));\n            EXPECT_LT(it.metadataType.value,\n                      ndk::internal::enum_values<StandardMetadataType>.size());\n\n            if (it.isGettable) {\n                std::erase(requiredGetters,\n                           static_cast<StandardMetadataType>(it.metadataType.value));\n            }\n            if (it.isSettable) {\n                std::erase(requiredSetters,\n                           static_cast<StandardMetadataType>(it.metadataType.value));\n            }\n        } else {\n            EXPECT_NE(nullptr, it.description) << \"Non-standard metadata must have a description\";\n            int len = strlen(it.description);\n            EXPECT_GE(len, 0) << \"Non-standard metadata must have a description\";\n        }\n    }\n\n    EXPECT_EQ(0, requiredGetters.size()) << \"Missing required getters\" << toString(requiredGetters);\n    EXPECT_EQ(0, requiredSetters.size()) << \"Missing required setters\" << toString(requiredSetters);\n}\n\n/*\n * Test that verifies that if the optional StandardMetadataTypes have getters, they have\n * the required setters as well\n */\nTEST_P(GraphicsMapperStableCTests, CheckRequiredSettersIfHasGetters) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    const AIMapper_MetadataTypeDescription* descriptions = nullptr;\n    size_t descriptionCount = 0;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE,\n              mapper()->v5.listSupportedMetadataTypes(&descriptions, &descriptionCount));\n\n    for (int i = 0; i < descriptionCount; i++) {\n        const auto& it = descriptions[i];\n        if (isStandardMetadata(it.metadataType)) {\n            const auto type = static_cast<StandardMetadataType>(it.metadataType.value);\n            switch (type) {\n                case StandardMetadataType::SMPTE2094_10:\n                case StandardMetadataType::SMPTE2094_40:\n                    if (it.isGettable) {\n                        EXPECT_TRUE(it.isSettable)\n                                << \"Type \" << toString(type) << \" must be settable if gettable\";\n                    }\n                    break;\n                default:\n                    break;\n            }\n        }\n    }\n}\n\nTEST_P(GraphicsMapperStableCTests, ListSupportedWorks) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    const AIMapper_MetadataTypeDescription* descriptions = nullptr;\n    size_t descriptionCount = 0;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE,\n              mapper()->v5.listSupportedMetadataTypes(&descriptions, &descriptionCount));\n\n    std::vector<uint8_t> metadataBuffer;\n    auto get = [&](AIMapper_MetadataType metadataType) -> int32_t {\n        int32_t size = mapper()->v5.getMetadata(*bufferHandle, metadataType, nullptr, 0);\n        if (size >= 0) {\n            metadataBuffer.resize(size);\n            size = mapper()->v5.getMetadata(*bufferHandle, metadataType, metadataBuffer.data(),\n                                            metadataBuffer.size());\n            EXPECT_EQ(size, metadataBuffer.size());\n        }\n        return size;\n    };\n\n    for (int i = 0; i < descriptionCount; i++) {\n        const auto& it = descriptions[i];\n        if (!isStandardMetadata(it.metadataType)) {\n            continue;\n        }\n        if (!it.isGettable) {\n            EXPECT_FALSE(it.isSettable)\n                    << \"StandardMetadata that isn't gettable must not be settable\";\n            continue;\n        }\n        EXPECT_GE(get(it.metadataType), 0)\n                << \"Get failed for claimed supported getter of \"\n                << toString(static_cast<StandardMetadataType>(it.metadataType.value));\n        if (it.isSettable) {\n            EXPECT_EQ(AIMAPPER_ERROR_NONE,\n                      mapper()->v5.setMetadata(*bufferHandle, it.metadataType,\n                                               metadataBuffer.data(), metadataBuffer.size()))\n                    << \"Failed to set metadata for \"\n                    << toString(static_cast<StandardMetadataType>(it.metadataType.value));\n        }\n    }\n}\n\nTEST_P(GraphicsMapperStableCTests, GetMetadataBadValue) {\n    auto get = [this](StandardMetadataType type) -> AIMapper_Error {\n        // This is a _Nonnull parameter, but this is enough obfuscation to fool the linter\n        buffer_handle_t buffer = nullptr;\n        int32_t ret =\n                mapper()->v5.getStandardMetadata(buffer, static_cast<int64_t>(type), nullptr, 0);\n        return (ret < 0) ? (AIMapper_Error)-ret : AIMAPPER_ERROR_NONE;\n    };\n\n    for (auto type : ndk::enum_range<StandardMetadataType>()) {\n        if (type == StandardMetadataType::INVALID) {\n            continue;\n        }\n        EXPECT_EQ(AIMAPPER_ERROR_BAD_BUFFER, get(type)) << \"Wrong error for \" << toString(type);\n    }\n}\n\nTEST_P(GraphicsMapperStableCTests, GetUnsupportedMetadata) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n\n    int result = mapper()->v5.getMetadata(*bufferHandle, {\"Fake\", 1}, nullptr, 0);\n    EXPECT_EQ(AIMAPPER_ERROR_UNSUPPORTED, -result);\n\n    result = mapper()->v5.getStandardMetadata(\n            *bufferHandle, static_cast<int64_t>(StandardMetadataType::INVALID), nullptr, 0);\n    EXPECT_EQ(AIMAPPER_ERROR_UNSUPPORTED, -result);\n\n    constexpr int64_t unknownStandardType = ndk::internal::enum_values<StandardMetadataType>.size();\n    result = mapper()->v5.getStandardMetadata(*bufferHandle, unknownStandardType, nullptr, 0);\n    EXPECT_EQ(AIMAPPER_ERROR_UNSUPPORTED, -result);\n}\n\nstd::vector<std::tuple<std::string, std::shared_ptr<IAllocator>>> getIAllocatorsAtLeastVersion(\n        int32_t minVersion) {\n    auto instanceNames = getAidlHalInstanceNames(IAllocator::descriptor);\n    std::vector<std::tuple<std::string, std::shared_ptr<IAllocator>>> filteredInstances;\n    filteredInstances.reserve(instanceNames.size());\n    for (const auto& name : instanceNames) {\n        auto allocator =\n                IAllocator::fromBinder(ndk::SpAIBinder(AServiceManager_checkService(name.c_str())));\n        int32_t version = 0;\n        if (allocator->getInterfaceVersion(&version).isOk()) {\n            if (version >= minVersion) {\n                filteredInstances.emplace_back(name, std::move(allocator));\n            }\n        }\n    }\n    return filteredInstances;\n}\n\nGTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(GraphicsMapperStableCTests);\nINSTANTIATE_TEST_CASE_P(PerInstance, GraphicsMapperStableCTests,\n                        testing::ValuesIn(getIAllocatorsAtLeastVersion(2)),\n                        [](auto info) -> std::string {\n                            std::string name =\n                                    std::to_string(info.index) + \"/\" + std::get<0>(info.param);\n                            return Sanitize(name);\n                        });",
        "b_contents": "/*\n * Copyright 2022 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#undef LOG_TAG\n#define LOG_TAG \"VtsHalGraphicsMapperStableC_TargetTest\"\n\n#include <aidl/Vintf.h>\n#include <aidl/android/hardware/graphics/allocator/AllocationError.h>\n#include <aidl/android/hardware/graphics/allocator/AllocationResult.h>\n#include <aidl/android/hardware/graphics/allocator/IAllocator.h>\n#include <aidl/android/hardware/graphics/common/BufferUsage.h>\n#include <aidl/android/hardware/graphics/common/PixelFormat.h>\n#include <aidlcommonsupport/NativeHandle.h>\n#include <android/binder_manager.h>\n#include <android/dlext.h>\n#include <android/hardware/graphics/mapper/IMapper.h>\n#include <android/hardware/graphics/mapper/utils/IMapperMetadataTypes.h>\n#include <gralloctypes/Gralloc4.h>\n#include <hidl/GtestPrinter.h>\n#include <system/graphics.h>\n\n#include <dlfcn.h>\n#include <drm/drm_fourcc.h>\n#include <gtest/gtest.h>\n#include <vndksupport/linker.h>\n#include <initializer_list>\n#include <optional>\n#include <string>\n#include <tuple>\n#include <vector>\n\nusing namespace aidl::android::hardware::graphics::allocator;\nusing namespace aidl::android::hardware::graphics::common;\nusing namespace android;\nusing namespace android::hardware;\nusing namespace ::android::hardware::graphics::mapper;\n\ntypedef AIMapper_Error (*AIMapper_loadIMapperFn)(AIMapper* _Nullable* _Nonnull outImplementation);\n\ninline constexpr BufferUsage operator|(BufferUsage lhs, BufferUsage rhs) {\n    using T = std::underlying_type_t<BufferUsage>;\n    return static_cast<BufferUsage>(static_cast<T>(lhs) | static_cast<T>(rhs));\n}\n\ninline BufferUsage& operator|=(BufferUsage& lhs, BufferUsage rhs) {\n    lhs = lhs | rhs;\n    return lhs;\n}\n\nstruct YCbCr {\n    android_ycbcr yCbCr;\n    int64_t horizontalSubSampling;\n    int64_t verticalSubSampling;\n};\n\nclass BufferHandle {\n    AIMapper* mIMapper;\n    buffer_handle_t mHandle = nullptr;\n\n  public:\n    explicit BufferHandle(AIMapper* mapper, native_handle_t* rawHandle) : mIMapper(mapper) {\n        EXPECT_EQ(AIMAPPER_ERROR_NONE, mIMapper->v5.importBuffer(rawHandle, &mHandle));\n    }\n\n    explicit BufferHandle(BufferHandle&& other) { *this = std::move(other); }\n\n    BufferHandle& operator=(BufferHandle&& other) noexcept {\n        reset();\n        mIMapper = other.mIMapper;\n        mHandle = other.mHandle;\n        other.mHandle = nullptr;\n        return *this;\n    }\n\n    ~BufferHandle() { reset(); }\n\n    constexpr explicit operator bool() const noexcept { return mHandle != nullptr; }\n\n    buffer_handle_t operator*() const noexcept { return mHandle; }\n\n    void reset() {\n        if (mHandle != nullptr) {\n            EXPECT_EQ(AIMAPPER_ERROR_NONE, mIMapper->v5.freeBuffer(mHandle));\n            mHandle = nullptr;\n        }\n    }\n};\n\nclass BufferAllocation {\n    AIMapper* mIMapper;\n    native_handle_t* mRawHandle;\n    uint32_t mStride;\n    const BufferDescriptorInfo mInfo;\n\n  public:\n    BufferAllocation(const BufferAllocation&) = delete;\n    void operator=(const BufferAllocation&) = delete;\n\n    BufferAllocation(AIMapper* mapper, native_handle_t* handle, uint32_t stride,\n                     const BufferDescriptorInfo& info)\n        : mIMapper(mapper), mRawHandle(handle), mStride(stride), mInfo(info) {}\n\n    ~BufferAllocation() {\n        if (mRawHandle == nullptr) return;\n\n        native_handle_close(mRawHandle);\n        native_handle_delete(mRawHandle);\n    }\n\n    uint32_t stride() const { return mStride; }\n    const BufferDescriptorInfo& info() const { return mInfo; }\n\n    BufferHandle import() { return BufferHandle{mIMapper, mRawHandle}; }\n\n    const native_handle_t* rawHandle() const { return mRawHandle; }\n};\n\nclass GraphicsTestsBase {\n  private:\n    friend class BufferAllocation;\n    int32_t mIAllocatorVersion = 1;\n    std::shared_ptr<IAllocator> mAllocator;\n    AIMapper* mIMapper = nullptr;\n    AIMapper_loadIMapperFn mIMapperLoader;\n\n  protected:\n    void Initialize(std::shared_ptr<IAllocator> allocator) {\n        mAllocator = allocator;\n        ASSERT_NE(nullptr, mAllocator.get()) << \"failed to get allocator service\";\n        ASSERT_TRUE(mAllocator->getInterfaceVersion(&mIAllocatorVersion).isOk());\n        ASSERT_GE(mIAllocatorVersion, 2);\n        std::string mapperSuffix;\n        auto status = mAllocator->getIMapperLibrarySuffix(&mapperSuffix);\n        ASSERT_TRUE(status.isOk()) << \"Failed to get IMapper library suffix\";\n        std::string lib_name = \"mapper.\" + mapperSuffix + \".so\";\n        void* so = android_load_sphal_library(lib_name.c_str(), RTLD_LOCAL | RTLD_NOW);\n        ASSERT_NE(nullptr, so) << \"Failed to load \" << lib_name;\n        mIMapperLoader = (AIMapper_loadIMapperFn)dlsym(so, \"AIMapper_loadIMapper\");\n        ASSERT_NE(nullptr, mIMapperLoader) << \"AIMapper_locaIMapper missing from \" << lib_name;\n        ASSERT_EQ(AIMAPPER_ERROR_NONE, mIMapperLoader(&mIMapper));\n        ASSERT_NE(mIMapper, nullptr);\n    }\n\n  public:\n    AIMapper_loadIMapperFn getIMapperLoader() const { return mIMapperLoader; }\n\n    std::unique_ptr<BufferAllocation> allocate(const BufferDescriptorInfo& descriptorInfo) {\n        AllocationResult result;\n        ::ndk::ScopedAStatus status = mAllocator->allocate2(descriptorInfo, 1, &result);\n        if (!status.isOk()) {\n            status_t error = status.getExceptionCode();\n            if (error == EX_SERVICE_SPECIFIC) {\n                error = status.getServiceSpecificError();\n                EXPECT_NE(OK, error) << \"Failed to set error properly\";\n            } else {\n                EXPECT_EQ(OK, error) << \"Allocation transport failure\";\n            }\n            return nullptr;\n        } else {\n            return std::make_unique<BufferAllocation>(mIMapper, dupFromAidl(result.buffers[0]),\n                                                      result.stride, descriptorInfo);\n        }\n    }\n\n    std::unique_ptr<BufferAllocation> allocateGeneric() {\n        return allocate({\n                .name = {\"VTS_TEMP\"},\n                .width = 64,\n                .height = 64,\n                .layerCount = 1,\n                .format = PixelFormat::RGBA_8888,\n                .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n                .reservedSize = 0,\n        });\n    }\n\n    bool isSupported(const BufferDescriptorInfo& descriptorInfo) {\n        bool ret = false;\n        EXPECT_TRUE(mAllocator->isSupported(descriptorInfo, &ret).isOk());\n        return ret;\n    }\n\n    AIMapper* mapper() const { return mIMapper; }\n\n    template <StandardMetadataType T>\n    auto getStandardMetadata(buffer_handle_t bufferHandle)\n            -> decltype(StandardMetadata<T>::value::decode(nullptr, 0)) {\n        using Value = typename StandardMetadata<T>::value;\n        std::vector<uint8_t> buffer;\n        // Initial guess\n        buffer.resize(512);\n        int32_t sizeRequired = mapper()->v5.getStandardMetadata(\n                bufferHandle, static_cast<int64_t>(T), buffer.data(), buffer.size());\n        if (sizeRequired < 0) {\n            EXPECT_EQ(-AIMAPPER_ERROR_UNSUPPORTED, sizeRequired)\n                    << \"Received something other than UNSUPPORTED from valid getStandardMetadata \"\n                       \"call\";\n            return std::nullopt;\n        }\n        if (sizeRequired > buffer.size()) {\n            buffer.resize(sizeRequired);\n            sizeRequired = mapper()->v5.getStandardMetadata(bufferHandle, static_cast<int64_t>(T),\n                                                            buffer.data(), buffer.size());\n        }\n        if (sizeRequired < 0 || sizeRequired >= buffer.size()) {\n            ADD_FAILURE() << \"getStandardMetadata failed, received \" << sizeRequired\n                          << \" with buffer size \" << buffer.size();\n            // Generate a fail type\n            return std::nullopt;\n        }\n        return Value::decode(buffer.data(), sizeRequired);\n    }\n\n    template <StandardMetadataType T>\n    AIMapper_Error setStandardMetadata(buffer_handle_t bufferHandle,\n                                       const typename StandardMetadata<T>::value_type& value) {\n        using Value = typename StandardMetadata<T>::value;\n        int32_t sizeRequired = Value::encode(value, nullptr, 0);\n        if (sizeRequired < 0) {\n            EXPECT_GE(sizeRequired, 0) << \"Failed to calculate required size\";\n            return static_cast<AIMapper_Error>(-sizeRequired);\n        }\n        std::vector<uint8_t> buffer;\n        buffer.resize(sizeRequired);\n        sizeRequired = Value::encode(value, buffer.data(), buffer.size());\n        if (sizeRequired < 0 || sizeRequired > buffer.size()) {\n            ADD_FAILURE() << \"Failed to encode with calculated size \" << sizeRequired\n                          << \"; buffer size\" << buffer.size();\n            return static_cast<AIMapper_Error>(-sizeRequired);\n        }\n        return mapper()->v5.setStandardMetadata(bufferHandle, static_cast<int64_t>(T),\n                                                buffer.data(), sizeRequired);\n    }\n\n    void verifyRGBA8888PlaneLayouts(const std::vector<PlaneLayout>& planeLayouts) {\n        ASSERT_EQ(1, planeLayouts.size());\n\n        const auto& planeLayout = planeLayouts.front();\n\n        ASSERT_EQ(4, planeLayout.components.size());\n\n        int64_t offsetInBitsR = -1;\n        int64_t offsetInBitsG = -1;\n        int64_t offsetInBitsB = -1;\n        int64_t offsetInBitsA = -1;\n\n        for (const auto& component : planeLayout.components) {\n            if (!gralloc4::isStandardPlaneLayoutComponentType(component.type)) {\n                continue;\n            }\n            EXPECT_EQ(8, component.sizeInBits);\n            if (component.type.value == gralloc4::PlaneLayoutComponentType_R.value) {\n                offsetInBitsR = component.offsetInBits;\n            }\n            if (component.type.value == gralloc4::PlaneLayoutComponentType_G.value) {\n                offsetInBitsG = component.offsetInBits;\n            }\n            if (component.type.value == gralloc4::PlaneLayoutComponentType_B.value) {\n                offsetInBitsB = component.offsetInBits;\n            }\n            if (component.type.value == gralloc4::PlaneLayoutComponentType_A.value) {\n                offsetInBitsA = component.offsetInBits;\n            }\n        }\n\n        EXPECT_EQ(0, offsetInBitsR);\n        EXPECT_EQ(8, offsetInBitsG);\n        EXPECT_EQ(16, offsetInBitsB);\n        EXPECT_EQ(24, offsetInBitsA);\n\n        EXPECT_EQ(0, planeLayout.offsetInBytes);\n        EXPECT_EQ(32, planeLayout.sampleIncrementInBits);\n        // Skip testing stride because any stride is valid\n        EXPECT_LE(planeLayout.widthInSamples * planeLayout.heightInSamples * 4,\n                  planeLayout.totalSizeInBytes);\n        EXPECT_EQ(1, planeLayout.horizontalSubsampling);\n        EXPECT_EQ(1, planeLayout.verticalSubsampling);\n    }\n\n    void fillRGBA8888(uint8_t* data, uint32_t height, size_t strideInBytes, size_t widthInBytes) {\n        for (uint32_t y = 0; y < height; y++) {\n            memset(data, y, widthInBytes);\n            data += strideInBytes;\n        }\n    }\n\n    void verifyRGBA8888(const buffer_handle_t bufferHandle, const uint8_t* data, uint32_t height,\n                        size_t strideInBytes, size_t widthInBytes) {\n        auto decodeResult = getStandardMetadata<StandardMetadataType::PLANE_LAYOUTS>(bufferHandle);\n        ASSERT_TRUE(decodeResult.has_value());\n        const auto& planeLayouts = *decodeResult;\n        ASSERT_TRUE(planeLayouts.size() > 0);\n\n        verifyRGBA8888PlaneLayouts(planeLayouts);\n\n        for (uint32_t y = 0; y < height; y++) {\n            for (size_t i = 0; i < widthInBytes; i++) {\n                EXPECT_EQ(static_cast<uint8_t>(y), data[i]);\n            }\n            data += strideInBytes;\n        }\n    }\n\n    void traverseYCbCrData(const android_ycbcr& yCbCr, int32_t width, int32_t height,\n                           int64_t hSubsampling, int64_t vSubsampling,\n                           std::function<void(uint8_t*, uint8_t)> traverseFuncion) {\n        auto yData = static_cast<uint8_t*>(yCbCr.y);\n        auto cbData = static_cast<uint8_t*>(yCbCr.cb);\n        auto crData = static_cast<uint8_t*>(yCbCr.cr);\n        auto yStride = yCbCr.ystride;\n        auto cStride = yCbCr.cstride;\n        auto chromaStep = yCbCr.chroma_step;\n\n        for (uint32_t y = 0; y < height; y++) {\n            for (uint32_t x = 0; x < width; x++) {\n                auto val = static_cast<uint8_t>(height * y + x);\n\n                traverseFuncion(yData + yStride * y + x, val);\n\n                if (y % vSubsampling == 0 && x % hSubsampling == 0) {\n                    uint32_t subSampleX = x / hSubsampling;\n                    uint32_t subSampleY = y / vSubsampling;\n                    const auto subSampleOffset = cStride * subSampleY + chromaStep * subSampleX;\n                    const auto subSampleVal =\n                            static_cast<uint8_t>(height * subSampleY + subSampleX);\n\n                    traverseFuncion(cbData + subSampleOffset, subSampleVal);\n                    traverseFuncion(crData + subSampleOffset, subSampleVal + 1);\n                }\n            }\n        }\n    }\n\n    void fillYCbCrData(const android_ycbcr& yCbCr, int32_t width, int32_t height,\n                       int64_t hSubsampling, int64_t vSubsampling) {\n        traverseYCbCrData(yCbCr, width, height, hSubsampling, vSubsampling,\n                          [](auto address, auto fillingData) { *address = fillingData; });\n    }\n\n    void verifyYCbCrData(const android_ycbcr& yCbCr, int32_t width, int32_t height,\n                         int64_t hSubsampling, int64_t vSubsampling) {\n        traverseYCbCrData(\n                yCbCr, width, height, hSubsampling, vSubsampling,\n                [](auto address, auto expectedData) { EXPECT_EQ(*address, expectedData); });\n    }\n\n    constexpr uint64_t bitsToBytes(int64_t bits) { return bits / 8; }\n    constexpr uint64_t bytesToBits(int64_t bytes) { return bytes * 8; }\n\n    void getAndroidYCbCr(buffer_handle_t bufferHandle, uint8_t* data, android_ycbcr* outYCbCr,\n                         int64_t* hSubsampling, int64_t* vSubsampling) {\n        auto decodeResult = getStandardMetadata<StandardMetadataType::PLANE_LAYOUTS>(bufferHandle);\n        ASSERT_TRUE(decodeResult.has_value());\n        const auto& planeLayouts = *decodeResult;\n        ASSERT_TRUE(planeLayouts.size() > 0);\n\n        outYCbCr->y = nullptr;\n        outYCbCr->cb = nullptr;\n        outYCbCr->cr = nullptr;\n        outYCbCr->ystride = 0;\n        outYCbCr->cstride = 0;\n        outYCbCr->chroma_step = 0;\n\n        for (const auto& planeLayout : planeLayouts) {\n            for (const auto& planeLayoutComponent : planeLayout.components) {\n                if (!gralloc4::isStandardPlaneLayoutComponentType(planeLayoutComponent.type)) {\n                    continue;\n                }\n                ASSERT_EQ(0, planeLayoutComponent.offsetInBits % 8);\n\n                uint8_t* tmpData = data + planeLayout.offsetInBytes +\n                                   bitsToBytes(planeLayoutComponent.offsetInBits);\n                uint64_t sampleIncrementInBytes;\n\n                auto type = static_cast<PlaneLayoutComponentType>(planeLayoutComponent.type.value);\n                switch (type) {\n                    case PlaneLayoutComponentType::Y:\n                        ASSERT_EQ(nullptr, outYCbCr->y);\n                        ASSERT_EQ(8, planeLayoutComponent.sizeInBits);\n                        ASSERT_EQ(8, planeLayout.sampleIncrementInBits);\n                        outYCbCr->y = tmpData;\n                        outYCbCr->ystride = planeLayout.strideInBytes;\n                        break;\n\n                    case PlaneLayoutComponentType::CB:\n                    case PlaneLayoutComponentType::CR:\n                        ASSERT_EQ(0, planeLayout.sampleIncrementInBits % 8);\n\n                        sampleIncrementInBytes = planeLayout.sampleIncrementInBits / 8;\n                        ASSERT_TRUE(sampleIncrementInBytes == 1 || sampleIncrementInBytes == 2);\n\n                        if (outYCbCr->cstride == 0 && outYCbCr->chroma_step == 0) {\n                            outYCbCr->cstride = planeLayout.strideInBytes;\n                            outYCbCr->chroma_step = sampleIncrementInBytes;\n                        } else {\n                            ASSERT_EQ(outYCbCr->cstride, planeLayout.strideInBytes);\n                            ASSERT_EQ(outYCbCr->chroma_step, sampleIncrementInBytes);\n                        }\n\n                        if (*hSubsampling == 0 && *vSubsampling == 0) {\n                            *hSubsampling = planeLayout.horizontalSubsampling;\n                            *vSubsampling = planeLayout.verticalSubsampling;\n                        } else {\n                            ASSERT_EQ(*hSubsampling, planeLayout.horizontalSubsampling);\n                            ASSERT_EQ(*vSubsampling, planeLayout.verticalSubsampling);\n                        }\n\n                        if (type == PlaneLayoutComponentType::CB) {\n                            ASSERT_EQ(nullptr, outYCbCr->cb);\n                            outYCbCr->cb = tmpData;\n                        } else {\n                            ASSERT_EQ(nullptr, outYCbCr->cr);\n                            outYCbCr->cr = tmpData;\n                        }\n                        break;\n                    default:\n                        break;\n                };\n            }\n        }\n\n        ASSERT_NE(nullptr, outYCbCr->y);\n        ASSERT_NE(nullptr, outYCbCr->cb);\n        ASSERT_NE(nullptr, outYCbCr->cr);\n    }\n\n    YCbCr getAndroidYCbCr_P010(const native_handle_t* bufferHandle, uint8_t* data) {\n        YCbCr yCbCr_P010;\n        auto decodeResult = getStandardMetadata<StandardMetadataType::PLANE_LAYOUTS>(bufferHandle);\n        if (!decodeResult.has_value()) {\n            ADD_FAILURE() << \"failed to get plane layout\";\n            return YCbCr{};\n        }\n        const auto& planeLayouts = *decodeResult;\n        EXPECT_EQ(2, planeLayouts.size());\n        EXPECT_EQ(1, planeLayouts[0].components.size());\n        EXPECT_EQ(2, planeLayouts[1].components.size());\n\n        yCbCr_P010.yCbCr.y = nullptr;\n        yCbCr_P010.yCbCr.cb = nullptr;\n        yCbCr_P010.yCbCr.cr = nullptr;\n        yCbCr_P010.yCbCr.ystride = 0;\n        yCbCr_P010.yCbCr.cstride = 0;\n        yCbCr_P010.yCbCr.chroma_step = 0;\n        int64_t cb_offset = 0;\n        int64_t cr_offset = 0;\n\n        for (const auto& planeLayout : planeLayouts) {\n            for (const auto& planeLayoutComponent : planeLayout.components) {\n                if (!gralloc4::isStandardPlaneLayoutComponentType(planeLayoutComponent.type)) {\n                    continue;\n                }\n\n                uint8_t* tmpData = data + planeLayout.offsetInBytes +\n                                   bitsToBytes(planeLayoutComponent.offsetInBits);\n                uint64_t sampleIncrementInBytes = 0;\n                auto type = static_cast<PlaneLayoutComponentType>(planeLayoutComponent.type.value);\n                switch (type) {\n                    case PlaneLayoutComponentType::Y:\n                        // For specs refer:\n                        // https://docs.microsoft.com/en-us/windows/win32/medfound/10-bit-and-16-bit-yuv-video-formats\n                        EXPECT_EQ(6, planeLayoutComponent.offsetInBits);\n                        EXPECT_EQ(nullptr, yCbCr_P010.yCbCr.y);\n                        EXPECT_EQ(10, planeLayoutComponent.sizeInBits);\n                        EXPECT_EQ(16, planeLayout.sampleIncrementInBits);\n\n                        yCbCr_P010.yCbCr.y = tmpData;\n                        yCbCr_P010.yCbCr.ystride = planeLayout.strideInBytes;\n                        break;\n\n                    case PlaneLayoutComponentType::CB:\n                    case PlaneLayoutComponentType::CR:\n                        sampleIncrementInBytes = bitsToBytes(planeLayout.sampleIncrementInBits);\n                        EXPECT_EQ(4, sampleIncrementInBytes);\n\n                        if (yCbCr_P010.yCbCr.cstride == 0 && yCbCr_P010.yCbCr.chroma_step == 0) {\n                            yCbCr_P010.yCbCr.cstride = planeLayout.strideInBytes;\n                            yCbCr_P010.yCbCr.chroma_step = sampleIncrementInBytes;\n                        } else {\n                            EXPECT_EQ(yCbCr_P010.yCbCr.cstride, planeLayout.strideInBytes);\n                            EXPECT_EQ(yCbCr_P010.yCbCr.chroma_step, sampleIncrementInBytes);\n                        }\n\n                        if (yCbCr_P010.horizontalSubSampling == 0 &&\n                            yCbCr_P010.verticalSubSampling == 0) {\n                            yCbCr_P010.horizontalSubSampling = planeLayout.horizontalSubsampling;\n                            yCbCr_P010.verticalSubSampling = planeLayout.verticalSubsampling;\n                        } else {\n                            EXPECT_EQ(yCbCr_P010.horizontalSubSampling,\n                                      planeLayout.horizontalSubsampling);\n                            EXPECT_EQ(yCbCr_P010.verticalSubSampling,\n                                      planeLayout.verticalSubsampling);\n                        }\n\n                        if (type == PlaneLayoutComponentType::CB) {\n                            EXPECT_EQ(nullptr, yCbCr_P010.yCbCr.cb);\n                            yCbCr_P010.yCbCr.cb = tmpData;\n                            cb_offset = planeLayoutComponent.offsetInBits;\n                        } else {\n                            EXPECT_EQ(nullptr, yCbCr_P010.yCbCr.cr);\n                            yCbCr_P010.yCbCr.cr = tmpData;\n                            cr_offset = planeLayoutComponent.offsetInBits;\n                        }\n                        break;\n                    default:\n                        break;\n                };\n            }\n        }\n\n        EXPECT_EQ(cb_offset + bytesToBits(2), cr_offset);\n        EXPECT_NE(nullptr, yCbCr_P010.yCbCr.y);\n        EXPECT_NE(nullptr, yCbCr_P010.yCbCr.cb);\n        EXPECT_NE(nullptr, yCbCr_P010.yCbCr.cr);\n        return yCbCr_P010;\n    }\n};\n\nclass GraphicsMapperStableCTests\n    : public GraphicsTestsBase,\n      public ::testing::TestWithParam<std::tuple<std::string, std::shared_ptr<IAllocator>>> {\n  public:\n    void SetUp() override { Initialize(std::get<1>(GetParam())); }\n\n    void TearDown() override {}\n};\n\nTEST_P(GraphicsMapperStableCTests, AllV5CallbacksDefined) {\n    ASSERT_GE(mapper()->version, AIMAPPER_VERSION_5);\n\n    EXPECT_TRUE(mapper()->v5.importBuffer);\n    EXPECT_TRUE(mapper()->v5.freeBuffer);\n    EXPECT_TRUE(mapper()->v5.getTransportSize);\n    EXPECT_TRUE(mapper()->v5.lock);\n    EXPECT_TRUE(mapper()->v5.unlock);\n    EXPECT_TRUE(mapper()->v5.flushLockedBuffer);\n    EXPECT_TRUE(mapper()->v5.rereadLockedBuffer);\n    EXPECT_TRUE(mapper()->v5.getMetadata);\n    EXPECT_TRUE(mapper()->v5.getStandardMetadata);\n    EXPECT_TRUE(mapper()->v5.setMetadata);\n    EXPECT_TRUE(mapper()->v5.setStandardMetadata);\n    EXPECT_TRUE(mapper()->v5.listSupportedMetadataTypes);\n    EXPECT_TRUE(mapper()->v5.dumpBuffer);\n    EXPECT_TRUE(mapper()->v5.getReservedRegion);\n}\n\nTEST_P(GraphicsMapperStableCTests, DualLoadIsIdentical) {\n    ASSERT_GE(mapper()->version, AIMAPPER_VERSION_5);\n    AIMapper* secondMapper;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, getIMapperLoader()(&secondMapper));\n\n    EXPECT_EQ(secondMapper->v5.importBuffer, mapper()->v5.importBuffer);\n    EXPECT_EQ(secondMapper->v5.freeBuffer, mapper()->v5.freeBuffer);\n    EXPECT_EQ(secondMapper->v5.getTransportSize, mapper()->v5.getTransportSize);\n    EXPECT_EQ(secondMapper->v5.lock, mapper()->v5.lock);\n    EXPECT_EQ(secondMapper->v5.unlock, mapper()->v5.unlock);\n    EXPECT_EQ(secondMapper->v5.flushLockedBuffer, mapper()->v5.flushLockedBuffer);\n    EXPECT_EQ(secondMapper->v5.rereadLockedBuffer, mapper()->v5.rereadLockedBuffer);\n    EXPECT_EQ(secondMapper->v5.getMetadata, mapper()->v5.getMetadata);\n    EXPECT_EQ(secondMapper->v5.getStandardMetadata, mapper()->v5.getStandardMetadata);\n    EXPECT_EQ(secondMapper->v5.setMetadata, mapper()->v5.setMetadata);\n    EXPECT_EQ(secondMapper->v5.setStandardMetadata, mapper()->v5.setStandardMetadata);\n    EXPECT_EQ(secondMapper->v5.listSupportedMetadataTypes, mapper()->v5.listSupportedMetadataTypes);\n    EXPECT_EQ(secondMapper->v5.dumpBuffer, mapper()->v5.dumpBuffer);\n    EXPECT_EQ(secondMapper->v5.getReservedRegion, mapper()->v5.getReservedRegion);\n}\n\nTEST_P(GraphicsMapperStableCTests, CanAllocate) {\n    auto buffer = allocate({\n            .name = {\"VTS_TEMP\"},\n            .width = 64,\n            .height = 64,\n            .layerCount = 1,\n            .format = PixelFormat::RGBA_8888,\n            .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n            .reservedSize = 0,\n    });\n    ASSERT_NE(nullptr, buffer.get());\n    EXPECT_GE(buffer->stride(), 64);\n}\n\nTEST_P(GraphicsMapperStableCTests, ImportFreeBuffer) {\n    auto buffer = allocate({\n            .name = {\"VTS_TEMP\"},\n            .width = 64,\n            .height = 64,\n            .layerCount = 1,\n            .format = PixelFormat::RGBA_8888,\n            .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n            .reservedSize = 0,\n    });\n    ASSERT_NE(nullptr, buffer.get());\n    EXPECT_GE(buffer->stride(), 64);\n\n    {\n        auto import1 = buffer->import();\n        auto import2 = buffer->import();\n        EXPECT_TRUE(import1);\n        EXPECT_TRUE(import2);\n        EXPECT_NE(*import1, *import2);\n    }\n}\n\n/**\n * Test IMapper::importBuffer and IMapper::freeBuffer cross mapper instances.\n */\nTEST_P(GraphicsMapperStableCTests, ImportFreeBufferSingleton) {\n    auto buffer = allocate({\n            .name = {\"VTS_TEMP\"},\n            .width = 64,\n            .height = 64,\n            .layerCount = 1,\n            .format = PixelFormat::RGBA_8888,\n            .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n            .reservedSize = 0,\n    });\n    ASSERT_NE(nullptr, buffer.get());\n    EXPECT_GE(buffer->stride(), 64);\n\n    buffer_handle_t bufferHandle = nullptr;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.importBuffer(buffer->rawHandle(), &bufferHandle));\n    ASSERT_NE(nullptr, bufferHandle);\n\n    AIMapper* secondMapper;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, getIMapperLoader()(&secondMapper));\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, secondMapper->v5.freeBuffer(bufferHandle));\n}\n\n/**\n * Test IMapper::importBuffer with invalid buffers.\n */\nTEST_P(GraphicsMapperStableCTests, ImportBufferNegative) {\n    native_handle_t* invalidHandle = nullptr;\n    buffer_handle_t bufferHandle = nullptr;\n    EXPECT_EQ(AIMAPPER_ERROR_BAD_BUFFER, mapper()->v5.importBuffer(invalidHandle, &bufferHandle))\n            << \"importBuffer with nullptr did not fail with BAD_BUFFER\";\n\n    invalidHandle = native_handle_create(0, 0);\n    EXPECT_EQ(AIMAPPER_ERROR_BAD_BUFFER, mapper()->v5.importBuffer(invalidHandle, &bufferHandle))\n            << \"importBuffer with invalid handle did not fail with BAD_BUFFER\";\n    native_handle_delete(invalidHandle);\n}\n\n/**\n * Test IMapper::freeBuffer with invalid buffers.\n */\nTEST_P(GraphicsMapperStableCTests, FreeBufferNegative) {\n    native_handle_t* bufferHandle = nullptr;\n    EXPECT_EQ(AIMAPPER_ERROR_BAD_BUFFER, mapper()->v5.freeBuffer(bufferHandle))\n            << \"freeBuffer with nullptr did not fail with BAD_BUFFER\";\n\n    bufferHandle = native_handle_create(0, 0);\n    EXPECT_EQ(AIMAPPER_ERROR_BAD_BUFFER, mapper()->v5.freeBuffer(bufferHandle))\n            << \"freeBuffer with invalid handle did not fail with BAD_BUFFER\";\n    native_handle_delete(bufferHandle);\n\n    auto buffer = allocateGeneric();\n    EXPECT_EQ(AIMAPPER_ERROR_BAD_BUFFER, mapper()->v5.freeBuffer(buffer->rawHandle()))\n            << \"freeBuffer with un-imported handle did not fail with BAD_BUFFER\";\n}\n\n/**\n * Test IMapper::lock and IMapper::unlock.\n */\nTEST_P(GraphicsMapperStableCTests, LockUnlockBasic) {\n    constexpr auto usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN;\n    auto buffer = allocate({\n            .name = {\"VTS_TEMP\"},\n            .width = 64,\n            .height = 64,\n            .layerCount = 1,\n            .format = PixelFormat::RGBA_8888,\n            .usage = usage,\n            .reservedSize = 0,\n    });\n    ASSERT_NE(nullptr, buffer.get());\n\n    // lock buffer for writing\n    const auto& info = buffer->info();\n    const auto stride = buffer->stride();\n    const ARect region{0, 0, info.width, info.height};\n    auto handle = buffer->import();\n    uint8_t* data = nullptr;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE,\n              mapper()->v5.lock(*handle, static_cast<int64_t>(usage), region, -1, (void**)&data));\n\n    // RGBA_8888\n    fillRGBA8888(data, info.height, stride * 4, info.width * 4);\n\n    int releaseFence = -1;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence));\n\n    // lock again for reading\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.lock(*handle, static_cast<int64_t>(usage), region,\n                                                     releaseFence, (void**)&data));\n    releaseFence = -1;\n\n    ASSERT_NO_FATAL_FAILURE(verifyRGBA8888(*handle, data, info.height, stride * 4, info.width * 4));\n\n    releaseFence = -1;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence));\n    if (releaseFence != -1) {\n        close(releaseFence);\n    }\n}\n\n/**\n *  Test multiple operations associated with different color formats\n */\nTEST_P(GraphicsMapperStableCTests, Lock_YCRCB_420_SP) {\n    BufferDescriptorInfo info{\n            .name = {\"VTS_TEMP\"},\n            .width = 64,\n            .height = 64,\n            .layerCount = 1,\n            .format = PixelFormat::YCRCB_420_SP,\n            .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n            .reservedSize = 0,\n    };\n    auto buffer = allocate(info);\n    if (!buffer) {\n        ASSERT_FALSE(isSupported(info));\n        GTEST_SUCCEED() << \"YCRCB_420_SP format is unsupported\";\n        return;\n    }\n\n    // lock buffer for writing\n    const ARect region{0, 0, info.width, info.height};\n    auto handle = buffer->import();\n    uint8_t* data = nullptr;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.lock(*handle, static_cast<int64_t>(info.usage),\n                                                     region, -1, (void**)&data));\n\n    android_ycbcr yCbCr;\n    int64_t hSubsampling = 0;\n    int64_t vSubsampling = 0;\n    ASSERT_NO_FATAL_FAILURE(getAndroidYCbCr(*handle, data, &yCbCr, &hSubsampling, &vSubsampling));\n\n    constexpr uint32_t kCbCrSubSampleFactor = 2;\n    ASSERT_EQ(kCbCrSubSampleFactor, hSubsampling);\n    ASSERT_EQ(kCbCrSubSampleFactor, vSubsampling);\n\n    auto cbData = static_cast<uint8_t*>(yCbCr.cb);\n    auto crData = static_cast<uint8_t*>(yCbCr.cr);\n    ASSERT_EQ(crData + 1, cbData);\n    ASSERT_EQ(2, yCbCr.chroma_step);\n\n    fillYCbCrData(yCbCr, info.width, info.height, hSubsampling, vSubsampling);\n\n    int releaseFence = -1;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence));\n\n    // lock again for reading\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.lock(*handle, static_cast<int64_t>(info.usage),\n                                                     region, releaseFence, (void**)&data));\n    releaseFence = -1;\n\n    ASSERT_NO_FATAL_FAILURE(getAndroidYCbCr(*handle, data, &yCbCr, &hSubsampling, &vSubsampling));\n\n    verifyYCbCrData(yCbCr, info.width, info.height, hSubsampling, vSubsampling);\n\n    releaseFence = -1;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence));\n    if (releaseFence != -1) {\n        close(releaseFence);\n    }\n}\n\nTEST_P(GraphicsMapperStableCTests, YV12SubsampleMetadata) {\n    BufferDescriptorInfo info{\n            .name = {\"VTS_TEMP\"},\n            .width = 64,\n            .height = 64,\n            .layerCount = 1,\n            .format = PixelFormat::YV12,\n            .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n            .reservedSize = 0,\n    };\n    auto buffer = allocate(info);\n    ASSERT_NE(nullptr, buffer.get());\n\n    // lock buffer for writing\n    const ARect region{0, 0, info.width, info.height};\n    auto handle = buffer->import();\n    uint8_t* data = nullptr;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.lock(*handle, static_cast<int64_t>(info.usage),\n                                                     region, -1, (void**)&data));\n\n    auto decodeResult = getStandardMetadata<StandardMetadataType::PLANE_LAYOUTS>(*handle);\n    ASSERT_TRUE(decodeResult.has_value());\n    const auto& planeLayouts = *decodeResult;\n\n    ASSERT_EQ(3, planeLayouts.size());\n\n    auto yPlane = planeLayouts[0];\n    auto crPlane = planeLayouts[1];\n    auto cbPlane = planeLayouts[2];\n\n    constexpr uint32_t kCbCrSubSampleFactor = 2;\n    EXPECT_EQ(kCbCrSubSampleFactor, crPlane.horizontalSubsampling);\n    EXPECT_EQ(kCbCrSubSampleFactor, crPlane.verticalSubsampling);\n\n    EXPECT_EQ(kCbCrSubSampleFactor, cbPlane.horizontalSubsampling);\n    EXPECT_EQ(kCbCrSubSampleFactor, cbPlane.verticalSubsampling);\n\n    const long chromaSampleWidth = info.width / kCbCrSubSampleFactor;\n    const long chromaSampleHeight = info.height / kCbCrSubSampleFactor;\n\n    EXPECT_EQ(info.width, yPlane.widthInSamples);\n    EXPECT_EQ(info.height, yPlane.heightInSamples);\n\n    EXPECT_EQ(chromaSampleWidth, crPlane.widthInSamples);\n    EXPECT_EQ(chromaSampleHeight, crPlane.heightInSamples);\n\n    EXPECT_EQ(chromaSampleWidth, cbPlane.widthInSamples);\n    EXPECT_EQ(chromaSampleHeight, cbPlane.heightInSamples);\n\n    EXPECT_LE(crPlane.widthInSamples, crPlane.strideInBytes);\n    EXPECT_LE(cbPlane.widthInSamples, cbPlane.strideInBytes);\n\n    int releaseFence = -1;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence));\n    if (releaseFence != -1) {\n        close(releaseFence);\n    }\n}\n\nTEST_P(GraphicsMapperStableCTests, Lock_YV12) {\n    BufferDescriptorInfo info{\n            .name = {\"VTS_TEMP\"},\n            .width = 64,\n            .height = 64,\n            .layerCount = 1,\n            .format = PixelFormat::YV12,\n            .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n            .reservedSize = 0,\n    };\n    auto buffer = allocate(info);\n    ASSERT_NE(nullptr, buffer.get());\n\n    // lock buffer for writing\n    const ARect region{0, 0, info.width, info.height};\n    auto handle = buffer->import();\n    uint8_t* data = nullptr;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.lock(*handle, static_cast<int64_t>(info.usage),\n                                                     region, -1, (void**)&data));\n\n    android_ycbcr yCbCr;\n    int64_t hSubsampling = 0;\n    int64_t vSubsampling = 0;\n    ASSERT_NO_FATAL_FAILURE(getAndroidYCbCr(*handle, data, &yCbCr, &hSubsampling, &vSubsampling));\n\n    constexpr uint32_t kCbCrSubSampleFactor = 2;\n    ASSERT_EQ(kCbCrSubSampleFactor, hSubsampling);\n    ASSERT_EQ(kCbCrSubSampleFactor, vSubsampling);\n\n    auto cbData = static_cast<uint8_t*>(yCbCr.cb);\n    auto crData = static_cast<uint8_t*>(yCbCr.cr);\n    ASSERT_EQ(crData + yCbCr.cstride * info.height / vSubsampling, cbData);\n    ASSERT_EQ(1, yCbCr.chroma_step);\n\n    fillYCbCrData(yCbCr, info.width, info.height, hSubsampling, vSubsampling);\n\n    int releaseFence = -1;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence));\n\n    // lock again for reading\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.lock(*handle, static_cast<int64_t>(info.usage),\n                                                     region, releaseFence, (void**)&data));\n    releaseFence = -1;\n\n    ASSERT_NO_FATAL_FAILURE(getAndroidYCbCr(*handle, data, &yCbCr, &hSubsampling, &vSubsampling));\n\n    verifyYCbCrData(yCbCr, info.width, info.height, hSubsampling, vSubsampling);\n\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence));\n    if (releaseFence != -1) {\n        close(releaseFence);\n    }\n}\n\nTEST_P(GraphicsMapperStableCTests, Lock_YCBCR_420_888) {\n    BufferDescriptorInfo info{\n            .name = {\"VTS_TEMP\"},\n            .width = 64,\n            .height = 64,\n            .layerCount = 1,\n            .format = PixelFormat::YCBCR_420_888,\n            .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n            .reservedSize = 0,\n    };\n    auto buffer = allocate(info);\n    ASSERT_NE(nullptr, buffer.get());\n\n    // lock buffer for writing\n    const ARect region{0, 0, info.width, info.height};\n    auto handle = buffer->import();\n    uint8_t* data = nullptr;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.lock(*handle, static_cast<int64_t>(info.usage),\n                                                     region, -1, (void**)&data));\n\n    android_ycbcr yCbCr;\n    int64_t hSubsampling = 0;\n    int64_t vSubsampling = 0;\n    ASSERT_NO_FATAL_FAILURE(getAndroidYCbCr(*handle, data, &yCbCr, &hSubsampling, &vSubsampling));\n\n    constexpr uint32_t kCbCrSubSampleFactor = 2;\n    ASSERT_EQ(kCbCrSubSampleFactor, hSubsampling);\n    ASSERT_EQ(kCbCrSubSampleFactor, vSubsampling);\n\n    fillYCbCrData(yCbCr, info.width, info.height, hSubsampling, vSubsampling);\n\n    int releaseFence = -1;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence));\n\n    // lock again for reading\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.lock(*handle, static_cast<int64_t>(info.usage),\n                                                     region, releaseFence, (void**)&data));\n    releaseFence = -1;\n\n    ASSERT_NO_FATAL_FAILURE(getAndroidYCbCr(*handle, data, &yCbCr, &hSubsampling, &vSubsampling));\n\n    verifyYCbCrData(yCbCr, info.width, info.height, hSubsampling, vSubsampling);\n\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence));\n    if (releaseFence != -1) {\n        close(releaseFence);\n    }\n}\n\nTEST_P(GraphicsMapperStableCTests, Lock_RAW10) {\n    BufferDescriptorInfo info{\n            .name = {\"VTS_TEMP\"},\n            .width = 64,\n            .height = 64,\n            .layerCount = 1,\n            .format = PixelFormat::RAW10,\n            .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n            .reservedSize = 0,\n    };\n    auto buffer = allocate(info);\n    if (!buffer) {\n        ASSERT_FALSE(isSupported(info));\n        GTEST_SUCCEED() << \"RAW10 format is unsupported\";\n        return;\n    }\n\n    // lock buffer for writing\n    const ARect region{0, 0, info.width, info.height};\n    auto handle = buffer->import();\n    uint8_t* data = nullptr;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.lock(*handle, static_cast<int64_t>(info.usage),\n                                                     region, -1, (void**)&data));\n\n    auto decodeResult = getStandardMetadata<StandardMetadataType::PLANE_LAYOUTS>(*handle);\n    ASSERT_TRUE(decodeResult.has_value());\n    const auto& planeLayouts = *decodeResult;\n\n    ASSERT_EQ(1, planeLayouts.size());\n    auto planeLayout = planeLayouts[0];\n\n    EXPECT_EQ(0, planeLayout.sampleIncrementInBits);\n    EXPECT_EQ(1, planeLayout.horizontalSubsampling);\n    EXPECT_EQ(1, planeLayout.verticalSubsampling);\n\n    ASSERT_EQ(1, planeLayout.components.size());\n    auto planeLayoutComponent = planeLayout.components[0];\n\n    EXPECT_EQ(PlaneLayoutComponentType::RAW,\n              static_cast<PlaneLayoutComponentType>(planeLayoutComponent.type.value));\n    EXPECT_EQ(0, planeLayoutComponent.offsetInBits % 8);\n    EXPECT_EQ(-1, planeLayoutComponent.sizeInBits);\n\n    int releaseFence = -1;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence));\n    if (releaseFence != -1) {\n        close(releaseFence);\n    }\n}\n\nTEST_P(GraphicsMapperStableCTests, Lock_RAW12) {\n    BufferDescriptorInfo info{\n            .name = {\"VTS_TEMP\"},\n            .width = 64,\n            .height = 64,\n            .layerCount = 1,\n            .format = PixelFormat::RAW12,\n            .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n            .reservedSize = 0,\n    };\n    auto buffer = allocate(info);\n    if (!buffer) {\n        ASSERT_FALSE(isSupported(info));\n        GTEST_SUCCEED() << \"RAW12 format is unsupported\";\n        return;\n    }\n\n    // lock buffer for writing\n    const ARect region{0, 0, info.width, info.height};\n    auto handle = buffer->import();\n    uint8_t* data = nullptr;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.lock(*handle, static_cast<int64_t>(info.usage),\n                                                     region, -1, (void**)&data));\n\n    auto decodeResult = getStandardMetadata<StandardMetadataType::PLANE_LAYOUTS>(*handle);\n    ASSERT_TRUE(decodeResult.has_value());\n    const auto& planeLayouts = *decodeResult;\n\n    ASSERT_EQ(1, planeLayouts.size());\n    auto planeLayout = planeLayouts[0];\n\n    EXPECT_EQ(0, planeLayout.sampleIncrementInBits);\n    EXPECT_EQ(1, planeLayout.horizontalSubsampling);\n    EXPECT_EQ(1, planeLayout.verticalSubsampling);\n\n    ASSERT_EQ(1, planeLayout.components.size());\n    auto planeLayoutComponent = planeLayout.components[0];\n\n    EXPECT_EQ(PlaneLayoutComponentType::RAW,\n              static_cast<PlaneLayoutComponentType>(planeLayoutComponent.type.value));\n    EXPECT_EQ(0, planeLayoutComponent.offsetInBits % 8);\n    EXPECT_EQ(-1, planeLayoutComponent.sizeInBits);\n\n    int releaseFence = -1;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence));\n    if (releaseFence != -1) {\n        close(releaseFence);\n    }\n}\n\nTEST_P(GraphicsMapperStableCTests, Lock_YCBCR_P010) {\n    BufferDescriptorInfo info{\n            .name = {\"VTS_TEMP\"},\n            .width = 64,\n            .height = 64,\n            .layerCount = 1,\n            .format = PixelFormat::YCBCR_P010,\n            .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n            .reservedSize = 0,\n    };\n    auto buffer = allocate(info);\n    if (!buffer) {\n        ASSERT_FALSE(isSupported(info));\n        GTEST_SUCCEED() << \"YCBCR_P010 format is unsupported\";\n        return;\n    }\n\n    // lock buffer for writing\n    const ARect region{0, 0, info.width, info.height};\n    auto handle = buffer->import();\n    uint8_t* data = nullptr;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.lock(*handle, static_cast<int64_t>(info.usage),\n                                                     region, -1, (void**)&data));\n\n    YCbCr yCbCr;\n    ASSERT_NO_FATAL_FAILURE(yCbCr = getAndroidYCbCr_P010(*handle, data));\n\n    constexpr uint32_t kCbCrSubSampleFactor = 2;\n    ASSERT_EQ(kCbCrSubSampleFactor, yCbCr.horizontalSubSampling);\n    ASSERT_EQ(kCbCrSubSampleFactor, yCbCr.verticalSubSampling);\n\n    ASSERT_EQ(0, info.height % 2);\n\n    // fill the data\n    fillYCbCrData(yCbCr.yCbCr, info.width, info.height, yCbCr.horizontalSubSampling,\n                  yCbCr.verticalSubSampling);\n    // verify the YCbCr data\n    verifyYCbCrData(yCbCr.yCbCr, info.width, info.height, yCbCr.horizontalSubSampling,\n                    yCbCr.verticalSubSampling);\n\n    int releaseFence = -1;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence));\n    if (releaseFence != -1) {\n        close(releaseFence);\n    }\n}\n\nTEST_P(GraphicsMapperStableCTests, LockBadAccessRegion) {\n    auto buffer = allocateGeneric();\n    ASSERT_NE(nullptr, buffer);\n    const auto& info = buffer->info();\n\n    // lock buffer for writing\n    const ARect region{0, 0, info.width * 2, info.height * 2};\n    auto handle = buffer->import();\n    uint8_t* data = nullptr;\n    EXPECT_EQ(AIMAPPER_ERROR_BAD_VALUE, mapper()->v5.lock(*handle, static_cast<int64_t>(info.usage),\n                                                          region, -1, (void**)&data));\n}\n\nTEST_P(GraphicsMapperStableCTests, UnlockNegative) {\n    native_handle_t* invalidHandle = nullptr;\n    int releaseFence = -1;\n    EXPECT_EQ(AIMAPPER_ERROR_BAD_BUFFER, mapper()->v5.unlock(invalidHandle, &releaseFence))\n            << \"unlock with nullptr did not fail with BAD_BUFFER\";\n\n    invalidHandle = native_handle_create(0, 0);\n    EXPECT_EQ(AIMAPPER_ERROR_BAD_BUFFER, mapper()->v5.unlock(invalidHandle, &releaseFence))\n            << \"unlock with invalid handle did not fail with BAD_BUFFER\";\n    native_handle_delete(invalidHandle);\n\n    auto buffer = allocateGeneric();\n    EXPECT_EQ(AIMAPPER_ERROR_BAD_BUFFER, mapper()->v5.unlock(buffer->rawHandle(), &releaseFence))\n            << \"unlock with un-imported handle did not fail with BAD_BUFFER\";\n}\n\nTEST_P(GraphicsMapperStableCTests, UnlockNotImported) {\n    int releaseFence = -1;\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    EXPECT_EQ(AIMAPPER_ERROR_BAD_BUFFER, mapper()->v5.unlock(buffer->rawHandle(), &releaseFence))\n            << \"unlock with un-imported handle did not fail with BAD_BUFFER\";\n}\n\nTEST_P(GraphicsMapperStableCTests, UnlockNotLocked) {\n    int releaseFence = -1;\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    EXPECT_EQ(AIMAPPER_ERROR_BAD_BUFFER, mapper()->v5.unlock(*bufferHandle, &releaseFence))\n            << \"unlock with unlocked handle did not fail with BAD_BUFFER\";\n}\n\nTEST_P(GraphicsMapperStableCTests, LockUnlockNested) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    const ARect region{0, 0, buffer->info().width, buffer->info().height};\n    auto usage = static_cast<int64_t>(buffer->info().usage);\n    auto handle = buffer->import();\n    uint8_t* data = nullptr;\n    EXPECT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.lock(*handle, usage, region, -1, (void**)&data));\n    EXPECT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.lock(*handle, usage, region, -1, (void**)&data))\n            << \"Second lock failed\";\n    int releaseFence = -1;\n    EXPECT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence));\n    if (releaseFence != -1) {\n        close(releaseFence);\n        releaseFence = -1;\n    }\n    EXPECT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence))\n            << \"Second unlock failed\";\n    if (releaseFence != -1) {\n        close(releaseFence);\n        releaseFence = -1;\n    }\n    EXPECT_EQ(AIMAPPER_ERROR_BAD_BUFFER, mapper()->v5.unlock(*handle, &releaseFence))\n            << \"Third, unmatched, unlock should have failed with BAD_BUFFER\";\n}\n\nTEST_P(GraphicsMapperStableCTests, FlushRereadBasic) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    const auto& info = buffer->info();\n    const auto stride = buffer->stride();\n    const ARect region{0, 0, buffer->info().width, buffer->info().height};\n\n    auto writeHandle = buffer->import();\n    auto readHandle = buffer->import();\n    ASSERT_TRUE(writeHandle && readHandle);\n\n    // lock buffer for writing\n\n    uint8_t* writeData;\n    EXPECT_EQ(AIMAPPER_ERROR_NONE,\n              mapper()->v5.lock(*writeHandle, static_cast<uint64_t>(BufferUsage::CPU_WRITE_OFTEN),\n                                region, -1, (void**)&writeData));\n\n    uint8_t* readData;\n    EXPECT_EQ(AIMAPPER_ERROR_NONE,\n              mapper()->v5.lock(*readHandle, static_cast<uint64_t>(BufferUsage::CPU_READ_OFTEN),\n                                region, -1, (void**)&readData));\n\n    fillRGBA8888(writeData, info.height, stride * 4, info.width * 4);\n\n    EXPECT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.flushLockedBuffer(*writeHandle));\n    EXPECT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.rereadLockedBuffer(*readHandle));\n\n    ASSERT_NO_FATAL_FAILURE(\n            verifyRGBA8888(*readHandle, readData, info.height, stride * 4, info.width * 4));\n\n    int releaseFence = -1;\n\n    EXPECT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*readHandle, &releaseFence));\n    if (releaseFence != -1) {\n        close(releaseFence);\n        releaseFence = -1;\n    }\n\n    EXPECT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*writeHandle, &releaseFence));\n    if (releaseFence != -1) {\n        close(releaseFence);\n        releaseFence = -1;\n    }\n}\n\nTEST_P(GraphicsMapperStableCTests, FlushLockedBufferBadBuffer) {\n    // Amazingly this is enough to make the compiler happy even though flushLockedBuffer\n    // is _Nonnull :shrug:\n    buffer_handle_t badBuffer = nullptr;\n    EXPECT_EQ(AIMAPPER_ERROR_BAD_BUFFER, mapper()->v5.flushLockedBuffer(badBuffer));\n}\n\nTEST_P(GraphicsMapperStableCTests, RereadLockedBufferBadBuffer) {\n    buffer_handle_t badBuffer = nullptr;\n    EXPECT_EQ(AIMAPPER_ERROR_BAD_BUFFER, mapper()->v5.rereadLockedBuffer(badBuffer));\n}\n\nTEST_P(GraphicsMapperStableCTests, GetBufferId) {\n    auto buffer = allocateGeneric();\n    auto bufferHandle = buffer->import();\n    auto bufferId = getStandardMetadata<StandardMetadataType::BUFFER_ID>(*bufferHandle);\n    ASSERT_TRUE(bufferId.has_value());\n\n    auto buffer2 = allocateGeneric();\n    auto bufferHandle2 = buffer2->import();\n    auto bufferId2 = getStandardMetadata<StandardMetadataType::BUFFER_ID>(*bufferHandle2);\n    ASSERT_TRUE(bufferId2.has_value());\n\n    EXPECT_NE(*bufferId, *bufferId2);\n}\n\nTEST_P(GraphicsMapperStableCTests, GetName) {\n    auto buffer = allocate({\n            .name = {\"Hello, World!\"},\n            .width = 64,\n            .height = 64,\n            .layerCount = 1,\n            .format = PixelFormat::RGBA_8888,\n            .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n            .reservedSize = 0,\n    });\n    auto bufferHandle = buffer->import();\n    auto name = getStandardMetadata<StandardMetadataType::NAME>(*bufferHandle);\n    ASSERT_TRUE(name.has_value());\n    EXPECT_EQ(*name, \"Hello, World!\");\n}\n\nTEST_P(GraphicsMapperStableCTests, GetWidthHeight) {\n    auto buffer = allocate({\n            .name = {\"Hello, World!\"},\n            .width = 64,\n            .height = 128,\n            .layerCount = 1,\n            .format = PixelFormat::RGBA_8888,\n            .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n            .reservedSize = 0,\n    });\n    auto bufferHandle = buffer->import();\n    auto value = getStandardMetadata<StandardMetadataType::WIDTH>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_EQ(*value, 64);\n    value = getStandardMetadata<StandardMetadataType::HEIGHT>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_EQ(*value, 128);\n}\n\nTEST_P(GraphicsMapperStableCTests, GetLayerCount) {\n    auto buffer = allocateGeneric();\n    auto bufferHandle = buffer->import();\n    auto value = getStandardMetadata<StandardMetadataType::LAYER_COUNT>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_EQ(*value, buffer->info().layerCount);\n}\n\nTEST_P(GraphicsMapperStableCTests, GetPixelFormatRequested) {\n    auto buffer = allocateGeneric();\n    auto bufferHandle = buffer->import();\n    auto value = getStandardMetadata<StandardMetadataType::PIXEL_FORMAT_REQUESTED>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_EQ(*value, buffer->info().format);\n}\n\nTEST_P(GraphicsMapperStableCTests, GetPixelFormatFourCC) {\n    auto buffer = allocate({\n            .name = {\"Hello, World!\"},\n            .width = 64,\n            .height = 128,\n            .layerCount = 1,\n            .format = PixelFormat::RGBA_8888,\n            .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n            .reservedSize = 0,\n    });\n    {\n        auto bufferHandle = buffer->import();\n        auto value = getStandardMetadata<StandardMetadataType::PIXEL_FORMAT_FOURCC>(*bufferHandle);\n        ASSERT_TRUE(value.has_value());\n        EXPECT_EQ(*value, DRM_FORMAT_ABGR8888);\n    }\n\n    buffer = allocate({\n            .name = {\"yv12\"},\n            .width = 64,\n            .height = 128,\n            .layerCount = 1,\n            .format = PixelFormat::YV12,\n            .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n            .reservedSize = 0,\n    });\n    {\n        auto bufferHandle = buffer->import();\n        auto value = getStandardMetadata<StandardMetadataType::PIXEL_FORMAT_FOURCC>(*bufferHandle);\n        ASSERT_TRUE(value.has_value());\n        EXPECT_EQ(*value, DRM_FORMAT_YVU420);\n    }\n}\n\nTEST_P(GraphicsMapperStableCTests, GetPixelFormatModifier) {\n    auto buffer = allocateGeneric();\n    auto bufferHandle = buffer->import();\n    auto value = getStandardMetadata<StandardMetadataType::PIXEL_FORMAT_MODIFIER>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    // Only the upper 8-bits are defined and is just the vendor ID, the lower 56 bits are\n    // then vendor specific. So there's not anything useful to assert here beyond just that\n    // we successfully queried a value\n}\n\nTEST_P(GraphicsMapperStableCTests, GetUsage) {\n    auto buffer = allocateGeneric();\n    auto bufferHandle = buffer->import();\n    auto value = getStandardMetadata<StandardMetadataType::USAGE>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_EQ(buffer->info().usage, *value);\n}\n\nTEST_P(GraphicsMapperStableCTests, GetAllocationSize) {\n    auto buffer = allocateGeneric();\n    auto bufferHandle = buffer->import();\n    auto value = getStandardMetadata<StandardMetadataType::ALLOCATION_SIZE>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    const auto estimatedSize = buffer->stride() * buffer->info().height * 4;\n    // This buffer has CPU usage, so we expect at least stride * height * 4 since it should be\n    // generally linear uncompressed.\n    EXPECT_GE(*value, estimatedSize)\n            << \"Expected allocation size to be at least stride * height * 4bpp\";\n    // Might need refining, but hopefully this a generous-enough upper-bound?\n    EXPECT_LT(*value, estimatedSize * 2)\n            << \"Expected allocation size to less than double stride * height * 4bpp\";\n}\n\nTEST_P(GraphicsMapperStableCTests, GetProtectedContent) {\n    const BufferDescriptorInfo info{\n            .name = {\"prot8888\"},\n            .width = 64,\n            .height = 64,\n            .layerCount = 1,\n            .format = PixelFormat::RGBA_8888,\n            .usage = BufferUsage::PROTECTED | BufferUsage::COMPOSER_OVERLAY,\n            .reservedSize = 0,\n    };\n    auto buffer = allocate(info);\n    if (!buffer) {\n        ASSERT_FALSE(isSupported(info))\n                << \"Allocation of trivial sized buffer failed, so isSupported() must be false\";\n        GTEST_SUCCEED() << \"PROTECTED RGBA_8888 is unsupported\";\n        return;\n    }\n    auto bufferHandle = buffer->import();\n    auto value = getStandardMetadata<StandardMetadataType::PROTECTED_CONTENT>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_EQ(*value, 1);\n}\n\nTEST_P(GraphicsMapperStableCTests, GetCompression) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    auto value = getStandardMetadata<StandardMetadataType::COMPRESSION>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_EQ(gralloc4::Compression_None.name, value->name);\n    EXPECT_EQ(gralloc4::Compression_None.value, value->value);\n}\n\nTEST_P(GraphicsMapperStableCTests, GetInterlaced) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    auto value = getStandardMetadata<StandardMetadataType::INTERLACED>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_EQ(gralloc4::Interlaced_None.name, value->name);\n    EXPECT_EQ(gralloc4::Interlaced_None.value, value->value);\n}\n\nTEST_P(GraphicsMapperStableCTests, GetChromaSiting) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    auto value = getStandardMetadata<StandardMetadataType::CHROMA_SITING>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_EQ(gralloc4::ChromaSiting_None.name, value->name);\n    EXPECT_EQ(gralloc4::ChromaSiting_None.value, value->value);\n}\n\nTEST_P(GraphicsMapperStableCTests, GetPlaneLayouts) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    auto value = getStandardMetadata<StandardMetadataType::PLANE_LAYOUTS>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    ASSERT_NO_FATAL_FAILURE(verifyRGBA8888PlaneLayouts(*value));\n}\n\nTEST_P(GraphicsMapperStableCTests, GetCrop) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    auto value = getStandardMetadata<StandardMetadataType::CROP>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_EQ(1, value->size());\n    const Rect expected{0, 0, buffer->info().width, buffer->info().height};\n    EXPECT_EQ(expected, value->at(0));\n}\n\nTEST_P(GraphicsMapperStableCTests, GetSetDataspace) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    auto value = getStandardMetadata<StandardMetadataType::DATASPACE>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_EQ(Dataspace::UNKNOWN, *value);\n    EXPECT_EQ(AIMAPPER_ERROR_NONE, setStandardMetadata<StandardMetadataType::DATASPACE>(\n                                           *bufferHandle, Dataspace::DISPLAY_P3));\n    value = getStandardMetadata<StandardMetadataType::DATASPACE>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_EQ(Dataspace::DISPLAY_P3, *value);\n}\n\nTEST_P(GraphicsMapperStableCTests, GetSetBlendMode) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    auto value = getStandardMetadata<StandardMetadataType::BLEND_MODE>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_EQ(BlendMode::INVALID, *value);\n    EXPECT_EQ(AIMAPPER_ERROR_NONE, setStandardMetadata<StandardMetadataType::BLEND_MODE>(\n                                           *bufferHandle, BlendMode::COVERAGE));\n    value = getStandardMetadata<StandardMetadataType::BLEND_MODE>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_EQ(BlendMode::COVERAGE, *value);\n}\n\nTEST_P(GraphicsMapperStableCTests, GetSetSmpte2086) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    auto value = getStandardMetadata<StandardMetadataType::SMPTE2086>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_FALSE(value->has_value());\n\n    // TODO: Maybe use something resembling real values, but validation isn't supposed to happen\n    // here anyway so :shrug:\n    const Smpte2086 awesomeHdr{\n            XyColor{1.f, 1.f},      XyColor{2.f, 2.f}, XyColor{3.f, 3.f},\n            XyColor{400.f, 1000.f}, 100000.0f,         0.0001f,\n    };\n    EXPECT_EQ(AIMAPPER_ERROR_NONE,\n              setStandardMetadata<StandardMetadataType::SMPTE2086>(*bufferHandle, awesomeHdr));\n    value = getStandardMetadata<StandardMetadataType::SMPTE2086>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    ASSERT_TRUE(value->has_value());\n    EXPECT_EQ(awesomeHdr, *value);\n\n    EXPECT_EQ(AIMAPPER_ERROR_NONE,\n              setStandardMetadata<StandardMetadataType::SMPTE2086>(*bufferHandle, std::nullopt));\n    value = getStandardMetadata<StandardMetadataType::SMPTE2086>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_FALSE(value->has_value());\n}\n\nTEST_P(GraphicsMapperStableCTests, GetCta861_3) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    auto value = getStandardMetadata<StandardMetadataType::CTA861_3>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_FALSE(value->has_value());\n\n    const Cta861_3 genericHlgish{1000.f, 140.f};\n    EXPECT_EQ(AIMAPPER_ERROR_NONE,\n              setStandardMetadata<StandardMetadataType::CTA861_3>(*bufferHandle, genericHlgish));\n    value = getStandardMetadata<StandardMetadataType::CTA861_3>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    ASSERT_TRUE(value->has_value());\n    EXPECT_EQ(genericHlgish, *value);\n\n    EXPECT_EQ(AIMAPPER_ERROR_NONE,\n              setStandardMetadata<StandardMetadataType::CTA861_3>(*bufferHandle, std::nullopt));\n    value = getStandardMetadata<StandardMetadataType::CTA861_3>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_FALSE(value->has_value());\n}\n\nTEST_P(GraphicsMapperStableCTests, GetSmpte2094_10) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    auto value = getStandardMetadata<StandardMetadataType::SMPTE2094_10>(*bufferHandle);\n    if (value.has_value()) {\n        EXPECT_FALSE(value->has_value());\n    }\n}\n\nTEST_P(GraphicsMapperStableCTests, GetSmpte2094_40) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    auto value = getStandardMetadata<StandardMetadataType::SMPTE2094_40>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_FALSE(value->has_value());\n}\n\nstd::vector<std::tuple<std::string, std::shared_ptr<IAllocator>>> getIAllocatorsAtLeastVersion(\n        int32_t minVersion) {\n    auto instanceNames = getAidlHalInstanceNames(IAllocator::descriptor);\n    std::vector<std::tuple<std::string, std::shared_ptr<IAllocator>>> filteredInstances;\n    filteredInstances.reserve(instanceNames.size());\n    for (const auto& name : instanceNames) {\n        auto allocator =\n                IAllocator::fromBinder(ndk::SpAIBinder(AServiceManager_checkService(name.c_str())));\n        int32_t version = 0;\n        if (allocator->getInterfaceVersion(&version).isOk()) {\n            if (version >= minVersion) {\n                filteredInstances.emplace_back(name, std::move(allocator));\n            }\n        }\n    }\n    return filteredInstances;\n}\n\nGTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(GraphicsMapperStableCTests);\nINSTANTIATE_TEST_CASE_P(PerInstance, GraphicsMapperStableCTests,\n                        testing::ValuesIn(getIAllocatorsAtLeastVersion(2)),\n                        [](auto info) -> std::string {\n                            std::string name =\n                                    std::to_string(info.index) + \"/\" + std::get<0>(info.param);\n                            return Sanitize(name);\n                        });",
        "base_contents": "",
        "res_region": "/*\n * Copyright 2022 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#undef LOG_TAG\n#define LOG_TAG \"VtsHalGraphicsMapperStableC_TargetTest\"\n\n#include <aidl/Vintf.h>\n#include <aidl/android/hardware/graphics/allocator/AllocationError.h>\n#include <aidl/android/hardware/graphics/allocator/AllocationResult.h>\n#include <aidl/android/hardware/graphics/allocator/IAllocator.h>\n#include <aidl/android/hardware/graphics/common/BufferUsage.h>\n#include <aidl/android/hardware/graphics/common/PixelFormat.h>\n#include <aidlcommonsupport/NativeHandle.h>\n#include <android/binder_enums.h>\n#include <android/binder_manager.h>\n#include <android/dlext.h>\n#include <android/hardware/graphics/mapper/IMapper.h>\n#include <android/hardware/graphics/mapper/utils/IMapperMetadataTypes.h>\n#include <gralloctypes/Gralloc4.h>\n#include <hidl/GtestPrinter.h>\n#include <system/graphics.h>\n\n#include <dlfcn.h>\n#include <drm/drm_fourcc.h>\n#include <gtest/gtest.h>\n#include <vndksupport/linker.h>\n#include <initializer_list>\n#include <optional>\n#include <string>\n#include <tuple>\n#include <vector>\n\nusing namespace aidl::android::hardware::graphics::allocator;\nusing namespace aidl::android::hardware::graphics::common;\nusing namespace android;\nusing namespace android::hardware;\nusing namespace ::android::hardware::graphics::mapper;\n\ntypedef AIMapper_Error (*AIMapper_loadIMapperFn)(AIMapper* _Nullable* _Nonnull outImplementation);\n\ninline constexpr BufferUsage operator|(BufferUsage lhs, BufferUsage rhs) {\n    using T = std::underlying_type_t<BufferUsage>;\n    return static_cast<BufferUsage>(static_cast<T>(lhs) | static_cast<T>(rhs));\n}\n\ninline BufferUsage& operator|=(BufferUsage& lhs, BufferUsage rhs) {\n    lhs = lhs | rhs;\n    return lhs;\n}\n\nstruct YCbCr {\n    android_ycbcr yCbCr;\n    int64_t horizontalSubSampling;\n    int64_t verticalSubSampling;\n};\n\nconstexpr const char* STANDARD_METADATA_NAME =\n        \"android.hardware.graphics.common.StandardMetadataType\";\n\nstatic bool isStandardMetadata(AIMapper_MetadataType metadataType) {\n    return strcmp(STANDARD_METADATA_NAME, metadataType.name) == 0;\n}\n\nstatic std::string toString(const std::vector<StandardMetadataType> types) {\n    std::stringstream buf;\n    buf << \"[\";\n    for (auto type : types) {\n        buf << toString(type) << \", \";\n    }\n    buf.seekp(-2, buf.cur);\n    buf << \"]\";\n    return buf.str();\n}\n\nclass BufferHandle {\n    AIMapper* mIMapper;\n    buffer_handle_t mHandle = nullptr;\n\n  public:\n    explicit BufferHandle(AIMapper* mapper, native_handle_t* rawHandle) : mIMapper(mapper) {\n        EXPECT_EQ(AIMAPPER_ERROR_NONE, mIMapper->v5.importBuffer(rawHandle, &mHandle));\n    }\n\n    explicit BufferHandle(BufferHandle&& other) { *this = std::move(other); }\n\n    BufferHandle& operator=(BufferHandle&& other) noexcept {\n        reset();\n        mIMapper = other.mIMapper;\n        mHandle = other.mHandle;\n        other.mHandle = nullptr;\n        return *this;\n    }\n\n    ~BufferHandle() { reset(); }\n\n    constexpr explicit operator bool() const noexcept { return mHandle != nullptr; }\n\n    buffer_handle_t operator*() const noexcept { return mHandle; }\n\n    void reset() {\n        if (mHandle != nullptr) {\n            EXPECT_EQ(AIMAPPER_ERROR_NONE, mIMapper->v5.freeBuffer(mHandle));\n            mHandle = nullptr;\n        }\n    }\n};\n\nclass BufferAllocation {\n    AIMapper* mIMapper;\n    native_handle_t* mRawHandle;\n    uint32_t mStride;\n    const BufferDescriptorInfo mInfo;\n\n  public:\n    BufferAllocation(const BufferAllocation&) = delete;\n    void operator=(const BufferAllocation&) = delete;\n\n    BufferAllocation(AIMapper* mapper, native_handle_t* handle, uint32_t stride,\n                     const BufferDescriptorInfo& info)\n        : mIMapper(mapper), mRawHandle(handle), mStride(stride), mInfo(info) {}\n\n    ~BufferAllocation() {\n        if (mRawHandle == nullptr) return;\n\n        native_handle_close(mRawHandle);\n        native_handle_delete(mRawHandle);\n    }\n\n    uint32_t stride() const { return mStride; }\n    const BufferDescriptorInfo& info() const { return mInfo; }\n\n    BufferHandle import() { return BufferHandle{mIMapper, mRawHandle}; }\n\n    const native_handle_t* rawHandle() const { return mRawHandle; }\n};\n\nclass GraphicsTestsBase {\n  private:\n    friend class BufferAllocation;\n    int32_t mIAllocatorVersion = 1;\n    std::shared_ptr<IAllocator> mAllocator;\n    AIMapper* mIMapper = nullptr;\n    AIMapper_loadIMapperFn mIMapperLoader;\n\n  protected:\n    void Initialize(std::shared_ptr<IAllocator> allocator) {\n        mAllocator = allocator;\n        ASSERT_NE(nullptr, mAllocator.get()) << \"failed to get allocator service\";\n        ASSERT_TRUE(mAllocator->getInterfaceVersion(&mIAllocatorVersion).isOk());\n        ASSERT_GE(mIAllocatorVersion, 2);\n        std::string mapperSuffix;\n        auto status = mAllocator->getIMapperLibrarySuffix(&mapperSuffix);\n        ASSERT_TRUE(status.isOk()) << \"Failed to get IMapper library suffix\";\n        std::string lib_name = \"mapper.\" + mapperSuffix + \".so\";\n        void* so = android_load_sphal_library(lib_name.c_str(), RTLD_LOCAL | RTLD_NOW);\n        ASSERT_NE(nullptr, so) << \"Failed to load \" << lib_name;\n        mIMapperLoader = (AIMapper_loadIMapperFn)dlsym(so, \"AIMapper_loadIMapper\");\n        ASSERT_NE(nullptr, mIMapperLoader) << \"AIMapper_locaIMapper missing from \" << lib_name;\n        ASSERT_EQ(AIMAPPER_ERROR_NONE, mIMapperLoader(&mIMapper));\n        ASSERT_NE(mIMapper, nullptr);\n    }\n\n  public:\n    AIMapper_loadIMapperFn getIMapperLoader() const { return mIMapperLoader; }\n\n    std::unique_ptr<BufferAllocation> allocate(const BufferDescriptorInfo& descriptorInfo) {\n        AllocationResult result;\n        ::ndk::ScopedAStatus status = mAllocator->allocate2(descriptorInfo, 1, &result);\n        if (!status.isOk()) {\n            status_t error = status.getExceptionCode();\n            if (error == EX_SERVICE_SPECIFIC) {\n                error = status.getServiceSpecificError();\n                EXPECT_NE(OK, error) << \"Failed to set error properly\";\n            } else {\n                EXPECT_EQ(OK, error) << \"Allocation transport failure\";\n            }\n            return nullptr;\n        } else {\n            return std::make_unique<BufferAllocation>(mIMapper, dupFromAidl(result.buffers[0]),\n                                                      result.stride, descriptorInfo);\n        }\n    }\n\n    std::unique_ptr<BufferAllocation> allocateGeneric() {\n        return allocate({\n                .name = {\"VTS_TEMP\"},\n                .width = 64,\n                .height = 64,\n                .layerCount = 1,\n                .format = PixelFormat::RGBA_8888,\n                .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n                .reservedSize = 0,\n        });\n    }\n\n    bool isSupported(const BufferDescriptorInfo& descriptorInfo) {\n        bool ret = false;\n        EXPECT_TRUE(mAllocator->isSupported(descriptorInfo, &ret).isOk());\n        return ret;\n    }\n\n    AIMapper* mapper() const { return mIMapper; }\n\n    template <StandardMetadataType T>\n    auto getStandardMetadata(buffer_handle_t bufferHandle)\n            -> decltype(StandardMetadata<T>::value::decode(nullptr, 0)) {\n        using Value = typename StandardMetadata<T>::value;\n        std::vector<uint8_t> buffer;\n        // Initial guess\n        buffer.resize(512);\n        int32_t sizeRequired = mapper()->v5.getStandardMetadata(\n                bufferHandle, static_cast<int64_t>(T), buffer.data(), buffer.size());\n        if (sizeRequired < 0) {\n            EXPECT_EQ(-AIMAPPER_ERROR_UNSUPPORTED, sizeRequired)\n                    << \"Received something other than UNSUPPORTED from valid getStandardMetadata \"\n                       \"call\";\n            return std::nullopt;\n        }\n        if (sizeRequired > buffer.size()) {\n            buffer.resize(sizeRequired);\n            sizeRequired = mapper()->v5.getStandardMetadata(bufferHandle, static_cast<int64_t>(T),\n                                                            buffer.data(), buffer.size());\n        }\n        if (sizeRequired < 0 || sizeRequired >= buffer.size()) {\n            ADD_FAILURE() << \"getStandardMetadata failed, received \" << sizeRequired\n                          << \" with buffer size \" << buffer.size();\n            // Generate a fail type\n            return std::nullopt;\n        }\n        return Value::decode(buffer.data(), sizeRequired);\n    }\n\n    template <StandardMetadataType T>\n    AIMapper_Error setStandardMetadata(buffer_handle_t bufferHandle,\n                                       const typename StandardMetadata<T>::value_type& value) {\n        using Value = typename StandardMetadata<T>::value;\n        int32_t sizeRequired = Value::encode(value, nullptr, 0);\n        if (sizeRequired < 0) {\n            EXPECT_GE(sizeRequired, 0) << \"Failed to calculate required size\";\n            return static_cast<AIMapper_Error>(-sizeRequired);\n        }\n        std::vector<uint8_t> buffer;\n        buffer.resize(sizeRequired);\n        sizeRequired = Value::encode(value, buffer.data(), buffer.size());\n        if (sizeRequired < 0 || sizeRequired > buffer.size()) {\n            ADD_FAILURE() << \"Failed to encode with calculated size \" << sizeRequired\n                          << \"; buffer size\" << buffer.size();\n            return static_cast<AIMapper_Error>(-sizeRequired);\n        }\n        return mapper()->v5.setStandardMetadata(bufferHandle, static_cast<int64_t>(T),\n                                                buffer.data(), sizeRequired);\n    }\n\n    void verifyRGBA8888PlaneLayouts(const std::vector<PlaneLayout>& planeLayouts) {\n        ASSERT_EQ(1, planeLayouts.size());\n\n        const auto& planeLayout = planeLayouts.front();\n\n        ASSERT_EQ(4, planeLayout.components.size());\n\n        int64_t offsetInBitsR = -1;\n        int64_t offsetInBitsG = -1;\n        int64_t offsetInBitsB = -1;\n        int64_t offsetInBitsA = -1;\n\n        for (const auto& component : planeLayout.components) {\n            if (!gralloc4::isStandardPlaneLayoutComponentType(component.type)) {\n                continue;\n            }\n            EXPECT_EQ(8, component.sizeInBits);\n            if (component.type.value == gralloc4::PlaneLayoutComponentType_R.value) {\n                offsetInBitsR = component.offsetInBits;\n            }\n            if (component.type.value == gralloc4::PlaneLayoutComponentType_G.value) {\n                offsetInBitsG = component.offsetInBits;\n            }\n            if (component.type.value == gralloc4::PlaneLayoutComponentType_B.value) {\n                offsetInBitsB = component.offsetInBits;\n            }\n            if (component.type.value == gralloc4::PlaneLayoutComponentType_A.value) {\n                offsetInBitsA = component.offsetInBits;\n            }\n        }\n\n        EXPECT_EQ(0, offsetInBitsR);\n        EXPECT_EQ(8, offsetInBitsG);\n        EXPECT_EQ(16, offsetInBitsB);\n        EXPECT_EQ(24, offsetInBitsA);\n\n        EXPECT_EQ(0, planeLayout.offsetInBytes);\n        EXPECT_EQ(32, planeLayout.sampleIncrementInBits);\n        // Skip testing stride because any stride is valid\n        EXPECT_LE(planeLayout.widthInSamples * planeLayout.heightInSamples * 4,\n                  planeLayout.totalSizeInBytes);\n        EXPECT_EQ(1, planeLayout.horizontalSubsampling);\n        EXPECT_EQ(1, planeLayout.verticalSubsampling);\n    }\n\n    void fillRGBA8888(uint8_t* data, uint32_t height, size_t strideInBytes, size_t widthInBytes) {\n        for (uint32_t y = 0; y < height; y++) {\n            memset(data, y, widthInBytes);\n            data += strideInBytes;\n        }\n    }\n\n    void verifyRGBA8888(const buffer_handle_t bufferHandle, const uint8_t* data, uint32_t height,\n                        size_t strideInBytes, size_t widthInBytes) {\n        auto decodeResult = getStandardMetadata<StandardMetadataType::PLANE_LAYOUTS>(bufferHandle);\n        ASSERT_TRUE(decodeResult.has_value());\n        const auto& planeLayouts = *decodeResult;\n        ASSERT_TRUE(planeLayouts.size() > 0);\n\n        verifyRGBA8888PlaneLayouts(planeLayouts);\n\n        for (uint32_t y = 0; y < height; y++) {\n            for (size_t i = 0; i < widthInBytes; i++) {\n                EXPECT_EQ(static_cast<uint8_t>(y), data[i]);\n            }\n            data += strideInBytes;\n        }\n    }\n\n    void traverseYCbCrData(const android_ycbcr& yCbCr, int32_t width, int32_t height,\n                           int64_t hSubsampling, int64_t vSubsampling,\n                           std::function<void(uint8_t*, uint8_t)> traverseFuncion) {\n        auto yData = static_cast<uint8_t*>(yCbCr.y);\n        auto cbData = static_cast<uint8_t*>(yCbCr.cb);\n        auto crData = static_cast<uint8_t*>(yCbCr.cr);\n        auto yStride = yCbCr.ystride;\n        auto cStride = yCbCr.cstride;\n        auto chromaStep = yCbCr.chroma_step;\n\n        for (uint32_t y = 0; y < height; y++) {\n            for (uint32_t x = 0; x < width; x++) {\n                auto val = static_cast<uint8_t>(height * y + x);\n\n                traverseFuncion(yData + yStride * y + x, val);\n\n                if (y % vSubsampling == 0 && x % hSubsampling == 0) {\n                    uint32_t subSampleX = x / hSubsampling;\n                    uint32_t subSampleY = y / vSubsampling;\n                    const auto subSampleOffset = cStride * subSampleY + chromaStep * subSampleX;\n                    const auto subSampleVal =\n                            static_cast<uint8_t>(height * subSampleY + subSampleX);\n\n                    traverseFuncion(cbData + subSampleOffset, subSampleVal);\n                    traverseFuncion(crData + subSampleOffset, subSampleVal + 1);\n                }\n            }\n        }\n    }\n\n    void fillYCbCrData(const android_ycbcr& yCbCr, int32_t width, int32_t height,\n                       int64_t hSubsampling, int64_t vSubsampling) {\n        traverseYCbCrData(yCbCr, width, height, hSubsampling, vSubsampling,\n                          [](auto address, auto fillingData) { *address = fillingData; });\n    }\n\n    void verifyYCbCrData(const android_ycbcr& yCbCr, int32_t width, int32_t height,\n                         int64_t hSubsampling, int64_t vSubsampling) {\n        traverseYCbCrData(\n                yCbCr, width, height, hSubsampling, vSubsampling,\n                [](auto address, auto expectedData) { EXPECT_EQ(*address, expectedData); });\n    }\n\n    constexpr uint64_t bitsToBytes(int64_t bits) { return bits / 8; }\n    constexpr uint64_t bytesToBits(int64_t bytes) { return bytes * 8; }\n\n    void getAndroidYCbCr(buffer_handle_t bufferHandle, uint8_t* data, android_ycbcr* outYCbCr,\n                         int64_t* hSubsampling, int64_t* vSubsampling) {\n        auto decodeResult = getStandardMetadata<StandardMetadataType::PLANE_LAYOUTS>(bufferHandle);\n        ASSERT_TRUE(decodeResult.has_value());\n        const auto& planeLayouts = *decodeResult;\n        ASSERT_TRUE(planeLayouts.size() > 0);\n\n        outYCbCr->y = nullptr;\n        outYCbCr->cb = nullptr;\n        outYCbCr->cr = nullptr;\n        outYCbCr->ystride = 0;\n        outYCbCr->cstride = 0;\n        outYCbCr->chroma_step = 0;\n\n        for (const auto& planeLayout : planeLayouts) {\n            for (const auto& planeLayoutComponent : planeLayout.components) {\n                if (!gralloc4::isStandardPlaneLayoutComponentType(planeLayoutComponent.type)) {\n                    continue;\n                }\n                ASSERT_EQ(0, planeLayoutComponent.offsetInBits % 8);\n\n                uint8_t* tmpData = data + planeLayout.offsetInBytes +\n                                   bitsToBytes(planeLayoutComponent.offsetInBits);\n                uint64_t sampleIncrementInBytes;\n\n                auto type = static_cast<PlaneLayoutComponentType>(planeLayoutComponent.type.value);\n                switch (type) {\n                    case PlaneLayoutComponentType::Y:\n                        ASSERT_EQ(nullptr, outYCbCr->y);\n                        ASSERT_EQ(8, planeLayoutComponent.sizeInBits);\n                        ASSERT_EQ(8, planeLayout.sampleIncrementInBits);\n                        outYCbCr->y = tmpData;\n                        outYCbCr->ystride = planeLayout.strideInBytes;\n                        break;\n\n                    case PlaneLayoutComponentType::CB:\n                    case PlaneLayoutComponentType::CR:\n                        ASSERT_EQ(0, planeLayout.sampleIncrementInBits % 8);\n\n                        sampleIncrementInBytes = planeLayout.sampleIncrementInBits / 8;\n                        ASSERT_TRUE(sampleIncrementInBytes == 1 || sampleIncrementInBytes == 2);\n\n                        if (outYCbCr->cstride == 0 && outYCbCr->chroma_step == 0) {\n                            outYCbCr->cstride = planeLayout.strideInBytes;\n                            outYCbCr->chroma_step = sampleIncrementInBytes;\n                        } else {\n                            ASSERT_EQ(outYCbCr->cstride, planeLayout.strideInBytes);\n                            ASSERT_EQ(outYCbCr->chroma_step, sampleIncrementInBytes);\n                        }\n\n                        if (*hSubsampling == 0 && *vSubsampling == 0) {\n                            *hSubsampling = planeLayout.horizontalSubsampling;\n                            *vSubsampling = planeLayout.verticalSubsampling;\n                        } else {\n                            ASSERT_EQ(*hSubsampling, planeLayout.horizontalSubsampling);\n                            ASSERT_EQ(*vSubsampling, planeLayout.verticalSubsampling);\n                        }\n\n                        if (type == PlaneLayoutComponentType::CB) {\n                            ASSERT_EQ(nullptr, outYCbCr->cb);\n                            outYCbCr->cb = tmpData;\n                        } else {\n                            ASSERT_EQ(nullptr, outYCbCr->cr);\n                            outYCbCr->cr = tmpData;\n                        }\n                        break;\n                    default:\n                        break;\n                };\n            }\n        }\n\n        ASSERT_NE(nullptr, outYCbCr->y);\n        ASSERT_NE(nullptr, outYCbCr->cb);\n        ASSERT_NE(nullptr, outYCbCr->cr);\n    }\n\n    YCbCr getAndroidYCbCr_P010(const native_handle_t* bufferHandle, uint8_t* data) {\n        YCbCr yCbCr_P010;\n        auto decodeResult = getStandardMetadata<StandardMetadataType::PLANE_LAYOUTS>(bufferHandle);\n        if (!decodeResult.has_value()) {\n            ADD_FAILURE() << \"failed to get plane layout\";\n            return YCbCr{};\n        }\n        const auto& planeLayouts = *decodeResult;\n        EXPECT_EQ(2, planeLayouts.size());\n        EXPECT_EQ(1, planeLayouts[0].components.size());\n        EXPECT_EQ(2, planeLayouts[1].components.size());\n\n        yCbCr_P010.yCbCr.y = nullptr;\n        yCbCr_P010.yCbCr.cb = nullptr;\n        yCbCr_P010.yCbCr.cr = nullptr;\n        yCbCr_P010.yCbCr.ystride = 0;\n        yCbCr_P010.yCbCr.cstride = 0;\n        yCbCr_P010.yCbCr.chroma_step = 0;\n        int64_t cb_offset = 0;\n        int64_t cr_offset = 0;\n\n        for (const auto& planeLayout : planeLayouts) {\n            for (const auto& planeLayoutComponent : planeLayout.components) {\n                if (!gralloc4::isStandardPlaneLayoutComponentType(planeLayoutComponent.type)) {\n                    continue;\n                }\n\n                uint8_t* tmpData = data + planeLayout.offsetInBytes +\n                                   bitsToBytes(planeLayoutComponent.offsetInBits);\n                uint64_t sampleIncrementInBytes = 0;\n                auto type = static_cast<PlaneLayoutComponentType>(planeLayoutComponent.type.value);\n                switch (type) {\n                    case PlaneLayoutComponentType::Y:\n                        // For specs refer:\n                        // https://docs.microsoft.com/en-us/windows/win32/medfound/10-bit-and-16-bit-yuv-video-formats\n                        EXPECT_EQ(6, planeLayoutComponent.offsetInBits);\n                        EXPECT_EQ(nullptr, yCbCr_P010.yCbCr.y);\n                        EXPECT_EQ(10, planeLayoutComponent.sizeInBits);\n                        EXPECT_EQ(16, planeLayout.sampleIncrementInBits);\n\n                        yCbCr_P010.yCbCr.y = tmpData;\n                        yCbCr_P010.yCbCr.ystride = planeLayout.strideInBytes;\n                        break;\n\n                    case PlaneLayoutComponentType::CB:\n                    case PlaneLayoutComponentType::CR:\n                        sampleIncrementInBytes = bitsToBytes(planeLayout.sampleIncrementInBits);\n                        EXPECT_EQ(4, sampleIncrementInBytes);\n\n                        if (yCbCr_P010.yCbCr.cstride == 0 && yCbCr_P010.yCbCr.chroma_step == 0) {\n                            yCbCr_P010.yCbCr.cstride = planeLayout.strideInBytes;\n                            yCbCr_P010.yCbCr.chroma_step = sampleIncrementInBytes;\n                        } else {\n                            EXPECT_EQ(yCbCr_P010.yCbCr.cstride, planeLayout.strideInBytes);\n                            EXPECT_EQ(yCbCr_P010.yCbCr.chroma_step, sampleIncrementInBytes);\n                        }\n\n                        if (yCbCr_P010.horizontalSubSampling == 0 &&\n                            yCbCr_P010.verticalSubSampling == 0) {\n                            yCbCr_P010.horizontalSubSampling = planeLayout.horizontalSubsampling;\n                            yCbCr_P010.verticalSubSampling = planeLayout.verticalSubsampling;\n                        } else {\n                            EXPECT_EQ(yCbCr_P010.horizontalSubSampling,\n                                      planeLayout.horizontalSubsampling);\n                            EXPECT_EQ(yCbCr_P010.verticalSubSampling,\n                                      planeLayout.verticalSubsampling);\n                        }\n\n                        if (type == PlaneLayoutComponentType::CB) {\n                            EXPECT_EQ(nullptr, yCbCr_P010.yCbCr.cb);\n                            yCbCr_P010.yCbCr.cb = tmpData;\n                            cb_offset = planeLayoutComponent.offsetInBits;\n                        } else {\n                            EXPECT_EQ(nullptr, yCbCr_P010.yCbCr.cr);\n                            yCbCr_P010.yCbCr.cr = tmpData;\n                            cr_offset = planeLayoutComponent.offsetInBits;\n                        }\n                        break;\n                    default:\n                        break;\n                };\n            }\n        }\n\n        EXPECT_EQ(cb_offset + bytesToBits(2), cr_offset);\n        EXPECT_NE(nullptr, yCbCr_P010.yCbCr.y);\n        EXPECT_NE(nullptr, yCbCr_P010.yCbCr.cb);\n        EXPECT_NE(nullptr, yCbCr_P010.yCbCr.cr);\n        return yCbCr_P010;\n    }\n};\n\nclass GraphicsMapperStableCTests\n    : public GraphicsTestsBase,\n      public ::testing::TestWithParam<std::tuple<std::string, std::shared_ptr<IAllocator>>> {\n  public:\n    void SetUp() override { Initialize(std::get<1>(GetParam())); }\n\n    void TearDown() override {}\n};\n\nTEST_P(GraphicsMapperStableCTests, AllV5CallbacksDefined) {\n    ASSERT_GE(mapper()->version, AIMAPPER_VERSION_5);\n\n    EXPECT_TRUE(mapper()->v5.importBuffer);\n    EXPECT_TRUE(mapper()->v5.freeBuffer);\n    EXPECT_TRUE(mapper()->v5.getTransportSize);\n    EXPECT_TRUE(mapper()->v5.lock);\n    EXPECT_TRUE(mapper()->v5.unlock);\n    EXPECT_TRUE(mapper()->v5.flushLockedBuffer);\n    EXPECT_TRUE(mapper()->v5.rereadLockedBuffer);\n    EXPECT_TRUE(mapper()->v5.getMetadata);\n    EXPECT_TRUE(mapper()->v5.getStandardMetadata);\n    EXPECT_TRUE(mapper()->v5.setMetadata);\n    EXPECT_TRUE(mapper()->v5.setStandardMetadata);\n    EXPECT_TRUE(mapper()->v5.listSupportedMetadataTypes);\n    EXPECT_TRUE(mapper()->v5.dumpBuffer);\n    EXPECT_TRUE(mapper()->v5.getReservedRegion);\n}\n\nTEST_P(GraphicsMapperStableCTests, DualLoadIsIdentical) {\n    ASSERT_GE(mapper()->version, AIMAPPER_VERSION_5);\n    AIMapper* secondMapper;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, getIMapperLoader()(&secondMapper));\n\n    EXPECT_EQ(secondMapper->v5.importBuffer, mapper()->v5.importBuffer);\n    EXPECT_EQ(secondMapper->v5.freeBuffer, mapper()->v5.freeBuffer);\n    EXPECT_EQ(secondMapper->v5.getTransportSize, mapper()->v5.getTransportSize);\n    EXPECT_EQ(secondMapper->v5.lock, mapper()->v5.lock);\n    EXPECT_EQ(secondMapper->v5.unlock, mapper()->v5.unlock);\n    EXPECT_EQ(secondMapper->v5.flushLockedBuffer, mapper()->v5.flushLockedBuffer);\n    EXPECT_EQ(secondMapper->v5.rereadLockedBuffer, mapper()->v5.rereadLockedBuffer);\n    EXPECT_EQ(secondMapper->v5.getMetadata, mapper()->v5.getMetadata);\n    EXPECT_EQ(secondMapper->v5.getStandardMetadata, mapper()->v5.getStandardMetadata);\n    EXPECT_EQ(secondMapper->v5.setMetadata, mapper()->v5.setMetadata);\n    EXPECT_EQ(secondMapper->v5.setStandardMetadata, mapper()->v5.setStandardMetadata);\n    EXPECT_EQ(secondMapper->v5.listSupportedMetadataTypes, mapper()->v5.listSupportedMetadataTypes);\n    EXPECT_EQ(secondMapper->v5.dumpBuffer, mapper()->v5.dumpBuffer);\n    EXPECT_EQ(secondMapper->v5.getReservedRegion, mapper()->v5.getReservedRegion);\n}\n\nTEST_P(GraphicsMapperStableCTests, CanAllocate) {\n    auto buffer = allocate({\n            .name = {\"VTS_TEMP\"},\n            .width = 64,\n            .height = 64,\n            .layerCount = 1,\n            .format = PixelFormat::RGBA_8888,\n            .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n            .reservedSize = 0,\n    });\n    ASSERT_NE(nullptr, buffer.get());\n    EXPECT_GE(buffer->stride(), 64);\n}\n\nTEST_P(GraphicsMapperStableCTests, ImportFreeBuffer) {\n    auto buffer = allocate({\n            .name = {\"VTS_TEMP\"},\n            .width = 64,\n            .height = 64,\n            .layerCount = 1,\n            .format = PixelFormat::RGBA_8888,\n            .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n            .reservedSize = 0,\n    });\n    ASSERT_NE(nullptr, buffer.get());\n    EXPECT_GE(buffer->stride(), 64);\n\n    {\n        auto import1 = buffer->import();\n        auto import2 = buffer->import();\n        EXPECT_TRUE(import1);\n        EXPECT_TRUE(import2);\n        EXPECT_NE(*import1, *import2);\n    }\n}\n\n/**\n * Test IMapper::importBuffer and IMapper::freeBuffer cross mapper instances.\n */\nTEST_P(GraphicsMapperStableCTests, ImportFreeBufferSingleton) {\n    auto buffer = allocate({\n            .name = {\"VTS_TEMP\"},\n            .width = 64,\n            .height = 64,\n            .layerCount = 1,\n            .format = PixelFormat::RGBA_8888,\n            .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n            .reservedSize = 0,\n    });\n    ASSERT_NE(nullptr, buffer.get());\n    EXPECT_GE(buffer->stride(), 64);\n\n    buffer_handle_t bufferHandle = nullptr;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.importBuffer(buffer->rawHandle(), &bufferHandle));\n    ASSERT_NE(nullptr, bufferHandle);\n\n    AIMapper* secondMapper;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, getIMapperLoader()(&secondMapper));\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, secondMapper->v5.freeBuffer(bufferHandle));\n}\n\n/**\n * Test IMapper::importBuffer with invalid buffers.\n */\nTEST_P(GraphicsMapperStableCTests, ImportBufferNegative) {\n    native_handle_t* invalidHandle = nullptr;\n    buffer_handle_t bufferHandle = nullptr;\n    EXPECT_EQ(AIMAPPER_ERROR_BAD_BUFFER, mapper()->v5.importBuffer(invalidHandle, &bufferHandle))\n            << \"importBuffer with nullptr did not fail with BAD_BUFFER\";\n\n    invalidHandle = native_handle_create(0, 0);\n    EXPECT_EQ(AIMAPPER_ERROR_BAD_BUFFER, mapper()->v5.importBuffer(invalidHandle, &bufferHandle))\n            << \"importBuffer with invalid handle did not fail with BAD_BUFFER\";\n    native_handle_delete(invalidHandle);\n}\n\n/**\n * Test IMapper::freeBuffer with invalid buffers.\n */\nTEST_P(GraphicsMapperStableCTests, FreeBufferNegative) {\n    native_handle_t* bufferHandle = nullptr;\n    EXPECT_EQ(AIMAPPER_ERROR_BAD_BUFFER, mapper()->v5.freeBuffer(bufferHandle))\n            << \"freeBuffer with nullptr did not fail with BAD_BUFFER\";\n\n    bufferHandle = native_handle_create(0, 0);\n    EXPECT_EQ(AIMAPPER_ERROR_BAD_BUFFER, mapper()->v5.freeBuffer(bufferHandle))\n            << \"freeBuffer with invalid handle did not fail with BAD_BUFFER\";\n    native_handle_delete(bufferHandle);\n\n    auto buffer = allocateGeneric();\n    EXPECT_EQ(AIMAPPER_ERROR_BAD_BUFFER, mapper()->v5.freeBuffer(buffer->rawHandle()))\n            << \"freeBuffer with un-imported handle did not fail with BAD_BUFFER\";\n}\n\n/**\n * Test IMapper::lock and IMapper::unlock.\n */\nTEST_P(GraphicsMapperStableCTests, LockUnlockBasic) {\n    constexpr auto usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN;\n    auto buffer = allocate({\n            .name = {\"VTS_TEMP\"},\n            .width = 64,\n            .height = 64,\n            .layerCount = 1,\n            .format = PixelFormat::RGBA_8888,\n            .usage = usage,\n            .reservedSize = 0,\n    });\n    ASSERT_NE(nullptr, buffer.get());\n\n    // lock buffer for writing\n    const auto& info = buffer->info();\n    const auto stride = buffer->stride();\n    const ARect region{0, 0, info.width, info.height};\n    auto handle = buffer->import();\n    uint8_t* data = nullptr;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE,\n              mapper()->v5.lock(*handle, static_cast<int64_t>(usage), region, -1, (void**)&data));\n\n    // RGBA_8888\n    fillRGBA8888(data, info.height, stride * 4, info.width * 4);\n\n    int releaseFence = -1;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence));\n\n    // lock again for reading\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.lock(*handle, static_cast<int64_t>(usage), region,\n                                                     releaseFence, (void**)&data));\n    releaseFence = -1;\n\n    ASSERT_NO_FATAL_FAILURE(verifyRGBA8888(*handle, data, info.height, stride * 4, info.width * 4));\n\n    releaseFence = -1;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence));\n    if (releaseFence != -1) {\n        close(releaseFence);\n    }\n}\n\n/**\n *  Test multiple operations associated with different color formats\n */\nTEST_P(GraphicsMapperStableCTests, Lock_YCRCB_420_SP) {\n    BufferDescriptorInfo info{\n            .name = {\"VTS_TEMP\"},\n            .width = 64,\n            .height = 64,\n            .layerCount = 1,\n            .format = PixelFormat::YCRCB_420_SP,\n            .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n            .reservedSize = 0,\n    };\n    auto buffer = allocate(info);\n    if (!buffer) {\n        ASSERT_FALSE(isSupported(info));\n        GTEST_SUCCEED() << \"YCRCB_420_SP format is unsupported\";\n        return;\n    }\n\n    // lock buffer for writing\n    const ARect region{0, 0, info.width, info.height};\n    auto handle = buffer->import();\n    uint8_t* data = nullptr;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.lock(*handle, static_cast<int64_t>(info.usage),\n                                                     region, -1, (void**)&data));\n\n    android_ycbcr yCbCr;\n    int64_t hSubsampling = 0;\n    int64_t vSubsampling = 0;\n    ASSERT_NO_FATAL_FAILURE(getAndroidYCbCr(*handle, data, &yCbCr, &hSubsampling, &vSubsampling));\n\n    constexpr uint32_t kCbCrSubSampleFactor = 2;\n    ASSERT_EQ(kCbCrSubSampleFactor, hSubsampling);\n    ASSERT_EQ(kCbCrSubSampleFactor, vSubsampling);\n\n    auto cbData = static_cast<uint8_t*>(yCbCr.cb);\n    auto crData = static_cast<uint8_t*>(yCbCr.cr);\n    ASSERT_EQ(crData + 1, cbData);\n    ASSERT_EQ(2, yCbCr.chroma_step);\n\n    fillYCbCrData(yCbCr, info.width, info.height, hSubsampling, vSubsampling);\n\n    int releaseFence = -1;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence));\n\n    // lock again for reading\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.lock(*handle, static_cast<int64_t>(info.usage),\n                                                     region, releaseFence, (void**)&data));\n    releaseFence = -1;\n\n    ASSERT_NO_FATAL_FAILURE(getAndroidYCbCr(*handle, data, &yCbCr, &hSubsampling, &vSubsampling));\n\n    verifyYCbCrData(yCbCr, info.width, info.height, hSubsampling, vSubsampling);\n\n    releaseFence = -1;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence));\n    if (releaseFence != -1) {\n        close(releaseFence);\n    }\n}\n\nTEST_P(GraphicsMapperStableCTests, YV12SubsampleMetadata) {\n    BufferDescriptorInfo info{\n            .name = {\"VTS_TEMP\"},\n            .width = 64,\n            .height = 64,\n            .layerCount = 1,\n            .format = PixelFormat::YV12,\n            .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n            .reservedSize = 0,\n    };\n    auto buffer = allocate(info);\n    ASSERT_NE(nullptr, buffer.get());\n\n    // lock buffer for writing\n    const ARect region{0, 0, info.width, info.height};\n    auto handle = buffer->import();\n    uint8_t* data = nullptr;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.lock(*handle, static_cast<int64_t>(info.usage),\n                                                     region, -1, (void**)&data));\n\n    auto decodeResult = getStandardMetadata<StandardMetadataType::PLANE_LAYOUTS>(*handle);\n    ASSERT_TRUE(decodeResult.has_value());\n    const auto& planeLayouts = *decodeResult;\n\n    ASSERT_EQ(3, planeLayouts.size());\n\n    auto yPlane = planeLayouts[0];\n    auto crPlane = planeLayouts[1];\n    auto cbPlane = planeLayouts[2];\n\n    constexpr uint32_t kCbCrSubSampleFactor = 2;\n    EXPECT_EQ(kCbCrSubSampleFactor, crPlane.horizontalSubsampling);\n    EXPECT_EQ(kCbCrSubSampleFactor, crPlane.verticalSubsampling);\n\n    EXPECT_EQ(kCbCrSubSampleFactor, cbPlane.horizontalSubsampling);\n    EXPECT_EQ(kCbCrSubSampleFactor, cbPlane.verticalSubsampling);\n\n    const long chromaSampleWidth = info.width / kCbCrSubSampleFactor;\n    const long chromaSampleHeight = info.height / kCbCrSubSampleFactor;\n\n    EXPECT_EQ(info.width, yPlane.widthInSamples);\n    EXPECT_EQ(info.height, yPlane.heightInSamples);\n\n    EXPECT_EQ(chromaSampleWidth, crPlane.widthInSamples);\n    EXPECT_EQ(chromaSampleHeight, crPlane.heightInSamples);\n\n    EXPECT_EQ(chromaSampleWidth, cbPlane.widthInSamples);\n    EXPECT_EQ(chromaSampleHeight, cbPlane.heightInSamples);\n\n    EXPECT_LE(crPlane.widthInSamples, crPlane.strideInBytes);\n    EXPECT_LE(cbPlane.widthInSamples, cbPlane.strideInBytes);\n\n    int releaseFence = -1;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence));\n    if (releaseFence != -1) {\n        close(releaseFence);\n    }\n}\n\nTEST_P(GraphicsMapperStableCTests, Lock_YV12) {\n    BufferDescriptorInfo info{\n            .name = {\"VTS_TEMP\"},\n            .width = 64,\n            .height = 64,\n            .layerCount = 1,\n            .format = PixelFormat::YV12,\n            .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n            .reservedSize = 0,\n    };\n    auto buffer = allocate(info);\n    ASSERT_NE(nullptr, buffer.get());\n\n    // lock buffer for writing\n    const ARect region{0, 0, info.width, info.height};\n    auto handle = buffer->import();\n    uint8_t* data = nullptr;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.lock(*handle, static_cast<int64_t>(info.usage),\n                                                     region, -1, (void**)&data));\n\n    android_ycbcr yCbCr;\n    int64_t hSubsampling = 0;\n    int64_t vSubsampling = 0;\n    ASSERT_NO_FATAL_FAILURE(getAndroidYCbCr(*handle, data, &yCbCr, &hSubsampling, &vSubsampling));\n\n    constexpr uint32_t kCbCrSubSampleFactor = 2;\n    ASSERT_EQ(kCbCrSubSampleFactor, hSubsampling);\n    ASSERT_EQ(kCbCrSubSampleFactor, vSubsampling);\n\n    auto cbData = static_cast<uint8_t*>(yCbCr.cb);\n    auto crData = static_cast<uint8_t*>(yCbCr.cr);\n    ASSERT_EQ(crData + yCbCr.cstride * info.height / vSubsampling, cbData);\n    ASSERT_EQ(1, yCbCr.chroma_step);\n\n    fillYCbCrData(yCbCr, info.width, info.height, hSubsampling, vSubsampling);\n\n    int releaseFence = -1;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence));\n\n    // lock again for reading\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.lock(*handle, static_cast<int64_t>(info.usage),\n                                                     region, releaseFence, (void**)&data));\n    releaseFence = -1;\n\n    ASSERT_NO_FATAL_FAILURE(getAndroidYCbCr(*handle, data, &yCbCr, &hSubsampling, &vSubsampling));\n\n    verifyYCbCrData(yCbCr, info.width, info.height, hSubsampling, vSubsampling);\n\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence));\n    if (releaseFence != -1) {\n        close(releaseFence);\n    }\n}\n\nTEST_P(GraphicsMapperStableCTests, Lock_YCBCR_420_888) {\n    BufferDescriptorInfo info{\n            .name = {\"VTS_TEMP\"},\n            .width = 64,\n            .height = 64,\n            .layerCount = 1,\n            .format = PixelFormat::YCBCR_420_888,\n            .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n            .reservedSize = 0,\n    };\n    auto buffer = allocate(info);\n    ASSERT_NE(nullptr, buffer.get());\n\n    // lock buffer for writing\n    const ARect region{0, 0, info.width, info.height};\n    auto handle = buffer->import();\n    uint8_t* data = nullptr;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.lock(*handle, static_cast<int64_t>(info.usage),\n                                                     region, -1, (void**)&data));\n\n    android_ycbcr yCbCr;\n    int64_t hSubsampling = 0;\n    int64_t vSubsampling = 0;\n    ASSERT_NO_FATAL_FAILURE(getAndroidYCbCr(*handle, data, &yCbCr, &hSubsampling, &vSubsampling));\n\n    constexpr uint32_t kCbCrSubSampleFactor = 2;\n    ASSERT_EQ(kCbCrSubSampleFactor, hSubsampling);\n    ASSERT_EQ(kCbCrSubSampleFactor, vSubsampling);\n\n    fillYCbCrData(yCbCr, info.width, info.height, hSubsampling, vSubsampling);\n\n    int releaseFence = -1;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence));\n\n    // lock again for reading\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.lock(*handle, static_cast<int64_t>(info.usage),\n                                                     region, releaseFence, (void**)&data));\n    releaseFence = -1;\n\n    ASSERT_NO_FATAL_FAILURE(getAndroidYCbCr(*handle, data, &yCbCr, &hSubsampling, &vSubsampling));\n\n    verifyYCbCrData(yCbCr, info.width, info.height, hSubsampling, vSubsampling);\n\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence));\n    if (releaseFence != -1) {\n        close(releaseFence);\n    }\n}\n\nTEST_P(GraphicsMapperStableCTests, Lock_RAW10) {\n    BufferDescriptorInfo info{\n            .name = {\"VTS_TEMP\"},\n            .width = 64,\n            .height = 64,\n            .layerCount = 1,\n            .format = PixelFormat::RAW10,\n            .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n            .reservedSize = 0,\n    };\n    auto buffer = allocate(info);\n    if (!buffer) {\n        ASSERT_FALSE(isSupported(info));\n        GTEST_SUCCEED() << \"RAW10 format is unsupported\";\n        return;\n    }\n\n    // lock buffer for writing\n    const ARect region{0, 0, info.width, info.height};\n    auto handle = buffer->import();\n    uint8_t* data = nullptr;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.lock(*handle, static_cast<int64_t>(info.usage),\n                                                     region, -1, (void**)&data));\n\n    auto decodeResult = getStandardMetadata<StandardMetadataType::PLANE_LAYOUTS>(*handle);\n    ASSERT_TRUE(decodeResult.has_value());\n    const auto& planeLayouts = *decodeResult;\n\n    ASSERT_EQ(1, planeLayouts.size());\n    auto planeLayout = planeLayouts[0];\n\n    EXPECT_EQ(0, planeLayout.sampleIncrementInBits);\n    EXPECT_EQ(1, planeLayout.horizontalSubsampling);\n    EXPECT_EQ(1, planeLayout.verticalSubsampling);\n\n    ASSERT_EQ(1, planeLayout.components.size());\n    auto planeLayoutComponent = planeLayout.components[0];\n\n    EXPECT_EQ(PlaneLayoutComponentType::RAW,\n              static_cast<PlaneLayoutComponentType>(planeLayoutComponent.type.value));\n    EXPECT_EQ(0, planeLayoutComponent.offsetInBits % 8);\n    EXPECT_EQ(-1, planeLayoutComponent.sizeInBits);\n\n    int releaseFence = -1;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence));\n    if (releaseFence != -1) {\n        close(releaseFence);\n    }\n}\n\nTEST_P(GraphicsMapperStableCTests, Lock_RAW12) {\n    BufferDescriptorInfo info{\n            .name = {\"VTS_TEMP\"},\n            .width = 64,\n            .height = 64,\n            .layerCount = 1,\n            .format = PixelFormat::RAW12,\n            .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n            .reservedSize = 0,\n    };\n    auto buffer = allocate(info);\n    if (!buffer) {\n        ASSERT_FALSE(isSupported(info));\n        GTEST_SUCCEED() << \"RAW12 format is unsupported\";\n        return;\n    }\n\n    // lock buffer for writing\n    const ARect region{0, 0, info.width, info.height};\n    auto handle = buffer->import();\n    uint8_t* data = nullptr;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.lock(*handle, static_cast<int64_t>(info.usage),\n                                                     region, -1, (void**)&data));\n\n    auto decodeResult = getStandardMetadata<StandardMetadataType::PLANE_LAYOUTS>(*handle);\n    ASSERT_TRUE(decodeResult.has_value());\n    const auto& planeLayouts = *decodeResult;\n\n    ASSERT_EQ(1, planeLayouts.size());\n    auto planeLayout = planeLayouts[0];\n\n    EXPECT_EQ(0, planeLayout.sampleIncrementInBits);\n    EXPECT_EQ(1, planeLayout.horizontalSubsampling);\n    EXPECT_EQ(1, planeLayout.verticalSubsampling);\n\n    ASSERT_EQ(1, planeLayout.components.size());\n    auto planeLayoutComponent = planeLayout.components[0];\n\n    EXPECT_EQ(PlaneLayoutComponentType::RAW,\n              static_cast<PlaneLayoutComponentType>(planeLayoutComponent.type.value));\n    EXPECT_EQ(0, planeLayoutComponent.offsetInBits % 8);\n    EXPECT_EQ(-1, planeLayoutComponent.sizeInBits);\n\n    int releaseFence = -1;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence));\n    if (releaseFence != -1) {\n        close(releaseFence);\n    }\n}\n\nTEST_P(GraphicsMapperStableCTests, Lock_YCBCR_P010) {\n    BufferDescriptorInfo info{\n            .name = {\"VTS_TEMP\"},\n            .width = 64,\n            .height = 64,\n            .layerCount = 1,\n            .format = PixelFormat::YCBCR_P010,\n            .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n            .reservedSize = 0,\n    };\n    auto buffer = allocate(info);\n    if (!buffer) {\n        ASSERT_FALSE(isSupported(info));\n        GTEST_SUCCEED() << \"YCBCR_P010 format is unsupported\";\n        return;\n    }\n\n    // lock buffer for writing\n    const ARect region{0, 0, info.width, info.height};\n    auto handle = buffer->import();\n    uint8_t* data = nullptr;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.lock(*handle, static_cast<int64_t>(info.usage),\n                                                     region, -1, (void**)&data));\n\n    YCbCr yCbCr;\n    ASSERT_NO_FATAL_FAILURE(yCbCr = getAndroidYCbCr_P010(*handle, data));\n\n    constexpr uint32_t kCbCrSubSampleFactor = 2;\n    ASSERT_EQ(kCbCrSubSampleFactor, yCbCr.horizontalSubSampling);\n    ASSERT_EQ(kCbCrSubSampleFactor, yCbCr.verticalSubSampling);\n\n    ASSERT_EQ(0, info.height % 2);\n\n    // fill the data\n    fillYCbCrData(yCbCr.yCbCr, info.width, info.height, yCbCr.horizontalSubSampling,\n                  yCbCr.verticalSubSampling);\n    // verify the YCbCr data\n    verifyYCbCrData(yCbCr.yCbCr, info.width, info.height, yCbCr.horizontalSubSampling,\n                    yCbCr.verticalSubSampling);\n\n    int releaseFence = -1;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence));\n    if (releaseFence != -1) {\n        close(releaseFence);\n    }\n}\n\nTEST_P(GraphicsMapperStableCTests, LockBadAccessRegion) {\n    auto buffer = allocateGeneric();\n    ASSERT_NE(nullptr, buffer);\n    const auto& info = buffer->info();\n\n    // lock buffer for writing\n    const ARect region{0, 0, info.width * 2, info.height * 2};\n    auto handle = buffer->import();\n    uint8_t* data = nullptr;\n    EXPECT_EQ(AIMAPPER_ERROR_BAD_VALUE, mapper()->v5.lock(*handle, static_cast<int64_t>(info.usage),\n                                                          region, -1, (void**)&data));\n}\n\nTEST_P(GraphicsMapperStableCTests, UnlockNegative) {\n    native_handle_t* invalidHandle = nullptr;\n    int releaseFence = -1;\n    EXPECT_EQ(AIMAPPER_ERROR_BAD_BUFFER, mapper()->v5.unlock(invalidHandle, &releaseFence))\n            << \"unlock with nullptr did not fail with BAD_BUFFER\";\n\n    invalidHandle = native_handle_create(0, 0);\n    EXPECT_EQ(AIMAPPER_ERROR_BAD_BUFFER, mapper()->v5.unlock(invalidHandle, &releaseFence))\n            << \"unlock with invalid handle did not fail with BAD_BUFFER\";\n    native_handle_delete(invalidHandle);\n\n    auto buffer = allocateGeneric();\n    EXPECT_EQ(AIMAPPER_ERROR_BAD_BUFFER, mapper()->v5.unlock(buffer->rawHandle(), &releaseFence))\n            << \"unlock with un-imported handle did not fail with BAD_BUFFER\";\n}\n\nTEST_P(GraphicsMapperStableCTests, UnlockNotImported) {\n    int releaseFence = -1;\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    EXPECT_EQ(AIMAPPER_ERROR_BAD_BUFFER, mapper()->v5.unlock(buffer->rawHandle(), &releaseFence))\n            << \"unlock with un-imported handle did not fail with BAD_BUFFER\";\n}\n\nTEST_P(GraphicsMapperStableCTests, UnlockNotLocked) {\n    int releaseFence = -1;\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    EXPECT_EQ(AIMAPPER_ERROR_BAD_BUFFER, mapper()->v5.unlock(*bufferHandle, &releaseFence))\n            << \"unlock with unlocked handle did not fail with BAD_BUFFER\";\n}\n\nTEST_P(GraphicsMapperStableCTests, LockUnlockNested) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    const ARect region{0, 0, buffer->info().width, buffer->info().height};\n    auto usage = static_cast<int64_t>(buffer->info().usage);\n    auto handle = buffer->import();\n    uint8_t* data = nullptr;\n    EXPECT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.lock(*handle, usage, region, -1, (void**)&data));\n    EXPECT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.lock(*handle, usage, region, -1, (void**)&data))\n            << \"Second lock failed\";\n    int releaseFence = -1;\n    EXPECT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence));\n    if (releaseFence != -1) {\n        close(releaseFence);\n        releaseFence = -1;\n    }\n    EXPECT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*handle, &releaseFence))\n            << \"Second unlock failed\";\n    if (releaseFence != -1) {\n        close(releaseFence);\n        releaseFence = -1;\n    }\n    EXPECT_EQ(AIMAPPER_ERROR_BAD_BUFFER, mapper()->v5.unlock(*handle, &releaseFence))\n            << \"Third, unmatched, unlock should have failed with BAD_BUFFER\";\n}\n\nTEST_P(GraphicsMapperStableCTests, FlushRereadBasic) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    const auto& info = buffer->info();\n    const auto stride = buffer->stride();\n    const ARect region{0, 0, buffer->info().width, buffer->info().height};\n\n    auto writeHandle = buffer->import();\n    auto readHandle = buffer->import();\n    ASSERT_TRUE(writeHandle && readHandle);\n\n    // lock buffer for writing\n\n    uint8_t* writeData;\n    EXPECT_EQ(AIMAPPER_ERROR_NONE,\n              mapper()->v5.lock(*writeHandle, static_cast<uint64_t>(BufferUsage::CPU_WRITE_OFTEN),\n                                region, -1, (void**)&writeData));\n\n    uint8_t* readData;\n    EXPECT_EQ(AIMAPPER_ERROR_NONE,\n              mapper()->v5.lock(*readHandle, static_cast<uint64_t>(BufferUsage::CPU_READ_OFTEN),\n                                region, -1, (void**)&readData));\n\n    fillRGBA8888(writeData, info.height, stride * 4, info.width * 4);\n\n    EXPECT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.flushLockedBuffer(*writeHandle));\n    EXPECT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.rereadLockedBuffer(*readHandle));\n\n    ASSERT_NO_FATAL_FAILURE(\n            verifyRGBA8888(*readHandle, readData, info.height, stride * 4, info.width * 4));\n\n    int releaseFence = -1;\n\n    EXPECT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*readHandle, &releaseFence));\n    if (releaseFence != -1) {\n        close(releaseFence);\n        releaseFence = -1;\n    }\n\n    EXPECT_EQ(AIMAPPER_ERROR_NONE, mapper()->v5.unlock(*writeHandle, &releaseFence));\n    if (releaseFence != -1) {\n        close(releaseFence);\n        releaseFence = -1;\n    }\n}\n\nTEST_P(GraphicsMapperStableCTests, FlushLockedBufferBadBuffer) {\n    // Amazingly this is enough to make the compiler happy even though flushLockedBuffer\n    // is _Nonnull :shrug:\n    buffer_handle_t badBuffer = nullptr;\n    EXPECT_EQ(AIMAPPER_ERROR_BAD_BUFFER, mapper()->v5.flushLockedBuffer(badBuffer));\n}\n\nTEST_P(GraphicsMapperStableCTests, RereadLockedBufferBadBuffer) {\n    buffer_handle_t badBuffer = nullptr;\n    EXPECT_EQ(AIMAPPER_ERROR_BAD_BUFFER, mapper()->v5.rereadLockedBuffer(badBuffer));\n}\n\nTEST_P(GraphicsMapperStableCTests, GetBufferId) {\n    auto buffer = allocateGeneric();\n    auto bufferHandle = buffer->import();\n    auto bufferId = getStandardMetadata<StandardMetadataType::BUFFER_ID>(*bufferHandle);\n    ASSERT_TRUE(bufferId.has_value());\n\n    auto buffer2 = allocateGeneric();\n    auto bufferHandle2 = buffer2->import();\n    auto bufferId2 = getStandardMetadata<StandardMetadataType::BUFFER_ID>(*bufferHandle2);\n    ASSERT_TRUE(bufferId2.has_value());\n\n    EXPECT_NE(*bufferId, *bufferId2);\n}\n\nTEST_P(GraphicsMapperStableCTests, GetName) {\n    auto buffer = allocate({\n            .name = {\"Hello, World!\"},\n            .width = 64,\n            .height = 64,\n            .layerCount = 1,\n            .format = PixelFormat::RGBA_8888,\n            .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n            .reservedSize = 0,\n    });\n    auto bufferHandle = buffer->import();\n    auto name = getStandardMetadata<StandardMetadataType::NAME>(*bufferHandle);\n    ASSERT_TRUE(name.has_value());\n    EXPECT_EQ(*name, \"Hello, World!\");\n}\n\nTEST_P(GraphicsMapperStableCTests, GetWidthHeight) {\n    auto buffer = allocate({\n            .name = {\"Hello, World!\"},\n            .width = 64,\n            .height = 128,\n            .layerCount = 1,\n            .format = PixelFormat::RGBA_8888,\n            .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n            .reservedSize = 0,\n    });\n    auto bufferHandle = buffer->import();\n    auto value = getStandardMetadata<StandardMetadataType::WIDTH>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_EQ(*value, 64);\n    value = getStandardMetadata<StandardMetadataType::HEIGHT>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_EQ(*value, 128);\n}\n\nTEST_P(GraphicsMapperStableCTests, GetLayerCount) {\n    auto buffer = allocateGeneric();\n    auto bufferHandle = buffer->import();\n    auto value = getStandardMetadata<StandardMetadataType::LAYER_COUNT>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_EQ(*value, buffer->info().layerCount);\n}\n\nTEST_P(GraphicsMapperStableCTests, GetPixelFormatRequested) {\n    auto buffer = allocateGeneric();\n    auto bufferHandle = buffer->import();\n    auto value = getStandardMetadata<StandardMetadataType::PIXEL_FORMAT_REQUESTED>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_EQ(*value, buffer->info().format);\n}\n\nTEST_P(GraphicsMapperStableCTests, GetPixelFormatFourCC) {\n    auto buffer = allocate({\n            .name = {\"Hello, World!\"},\n            .width = 64,\n            .height = 128,\n            .layerCount = 1,\n            .format = PixelFormat::RGBA_8888,\n            .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n            .reservedSize = 0,\n    });\n    {\n        auto bufferHandle = buffer->import();\n        auto value = getStandardMetadata<StandardMetadataType::PIXEL_FORMAT_FOURCC>(*bufferHandle);\n        ASSERT_TRUE(value.has_value());\n        EXPECT_EQ(*value, DRM_FORMAT_ABGR8888);\n    }\n\n    buffer = allocate({\n            .name = {\"yv12\"},\n            .width = 64,\n            .height = 128,\n            .layerCount = 1,\n            .format = PixelFormat::YV12,\n            .usage = BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN,\n            .reservedSize = 0,\n    });\n    {\n        auto bufferHandle = buffer->import();\n        auto value = getStandardMetadata<StandardMetadataType::PIXEL_FORMAT_FOURCC>(*bufferHandle);\n        ASSERT_TRUE(value.has_value());\n        EXPECT_EQ(*value, DRM_FORMAT_YVU420);\n    }\n}\n\nTEST_P(GraphicsMapperStableCTests, GetPixelFormatModifier) {\n    auto buffer = allocateGeneric();\n    auto bufferHandle = buffer->import();\n    auto value = getStandardMetadata<StandardMetadataType::PIXEL_FORMAT_MODIFIER>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    // Only the upper 8-bits are defined and is just the vendor ID, the lower 56 bits are\n    // then vendor specific. So there's not anything useful to assert here beyond just that\n    // we successfully queried a value\n}\n\nTEST_P(GraphicsMapperStableCTests, GetUsage) {\n    auto buffer = allocateGeneric();\n    auto bufferHandle = buffer->import();\n    auto value = getStandardMetadata<StandardMetadataType::USAGE>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_EQ(buffer->info().usage, *value);\n}\n\nTEST_P(GraphicsMapperStableCTests, GetAllocationSize) {\n    auto buffer = allocateGeneric();\n    auto bufferHandle = buffer->import();\n    auto value = getStandardMetadata<StandardMetadataType::ALLOCATION_SIZE>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    const auto estimatedSize = buffer->stride() * buffer->info().height * 4;\n    // This buffer has CPU usage, so we expect at least stride * height * 4 since it should be\n    // generally linear uncompressed.\n    EXPECT_GE(*value, estimatedSize)\n            << \"Expected allocation size to be at least stride * height * 4bpp\";\n    // Might need refining, but hopefully this a generous-enough upper-bound?\n    EXPECT_LT(*value, estimatedSize * 2)\n            << \"Expected allocation size to less than double stride * height * 4bpp\";\n}\n\nTEST_P(GraphicsMapperStableCTests, GetProtectedContent) {\n    const BufferDescriptorInfo info{\n            .name = {\"prot8888\"},\n            .width = 64,\n            .height = 64,\n            .layerCount = 1,\n            .format = PixelFormat::RGBA_8888,\n            .usage = BufferUsage::PROTECTED | BufferUsage::COMPOSER_OVERLAY,\n            .reservedSize = 0,\n    };\n    auto buffer = allocate(info);\n    if (!buffer) {\n        ASSERT_FALSE(isSupported(info))\n                << \"Allocation of trivial sized buffer failed, so isSupported() must be false\";\n        GTEST_SUCCEED() << \"PROTECTED RGBA_8888 is unsupported\";\n        return;\n    }\n    auto bufferHandle = buffer->import();\n    auto value = getStandardMetadata<StandardMetadataType::PROTECTED_CONTENT>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_EQ(*value, 1);\n}\n\nTEST_P(GraphicsMapperStableCTests, GetCompression) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    auto value = getStandardMetadata<StandardMetadataType::COMPRESSION>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_EQ(gralloc4::Compression_None.name, value->name);\n    EXPECT_EQ(gralloc4::Compression_None.value, value->value);\n}\n\nTEST_P(GraphicsMapperStableCTests, GetInterlaced) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    auto value = getStandardMetadata<StandardMetadataType::INTERLACED>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_EQ(gralloc4::Interlaced_None.name, value->name);\n    EXPECT_EQ(gralloc4::Interlaced_None.value, value->value);\n}\n\nTEST_P(GraphicsMapperStableCTests, GetChromaSiting) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    auto value = getStandardMetadata<StandardMetadataType::CHROMA_SITING>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_EQ(gralloc4::ChromaSiting_None.name, value->name);\n    EXPECT_EQ(gralloc4::ChromaSiting_None.value, value->value);\n}\n\nTEST_P(GraphicsMapperStableCTests, GetPlaneLayouts) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    auto value = getStandardMetadata<StandardMetadataType::PLANE_LAYOUTS>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    ASSERT_NO_FATAL_FAILURE(verifyRGBA8888PlaneLayouts(*value));\n}\n\nTEST_P(GraphicsMapperStableCTests, GetCrop) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    auto value = getStandardMetadata<StandardMetadataType::CROP>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_EQ(1, value->size());\n    const Rect expected{0, 0, buffer->info().width, buffer->info().height};\n    EXPECT_EQ(expected, value->at(0));\n}\n\nTEST_P(GraphicsMapperStableCTests, GetSetDataspace) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    auto value = getStandardMetadata<StandardMetadataType::DATASPACE>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_EQ(Dataspace::UNKNOWN, *value);\n    EXPECT_EQ(AIMAPPER_ERROR_NONE, setStandardMetadata<StandardMetadataType::DATASPACE>(\n                                           *bufferHandle, Dataspace::DISPLAY_P3));\n    value = getStandardMetadata<StandardMetadataType::DATASPACE>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_EQ(Dataspace::DISPLAY_P3, *value);\n}\n\nTEST_P(GraphicsMapperStableCTests, GetSetBlendMode) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    auto value = getStandardMetadata<StandardMetadataType::BLEND_MODE>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_EQ(BlendMode::INVALID, *value);\n    EXPECT_EQ(AIMAPPER_ERROR_NONE, setStandardMetadata<StandardMetadataType::BLEND_MODE>(\n                                           *bufferHandle, BlendMode::COVERAGE));\n    value = getStandardMetadata<StandardMetadataType::BLEND_MODE>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_EQ(BlendMode::COVERAGE, *value);\n}\n\nTEST_P(GraphicsMapperStableCTests, GetSetSmpte2086) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    auto value = getStandardMetadata<StandardMetadataType::SMPTE2086>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_FALSE(value->has_value());\n\n    // TODO: Maybe use something resembling real values, but validation isn't supposed to happen\n    // here anyway so :shrug:\n    const Smpte2086 awesomeHdr{\n            XyColor{1.f, 1.f},      XyColor{2.f, 2.f}, XyColor{3.f, 3.f},\n            XyColor{400.f, 1000.f}, 100000.0f,         0.0001f,\n    };\n    EXPECT_EQ(AIMAPPER_ERROR_NONE,\n              setStandardMetadata<StandardMetadataType::SMPTE2086>(*bufferHandle, awesomeHdr));\n    value = getStandardMetadata<StandardMetadataType::SMPTE2086>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    ASSERT_TRUE(value->has_value());\n    EXPECT_EQ(awesomeHdr, *value);\n\n    EXPECT_EQ(AIMAPPER_ERROR_NONE,\n              setStandardMetadata<StandardMetadataType::SMPTE2086>(*bufferHandle, std::nullopt));\n    value = getStandardMetadata<StandardMetadataType::SMPTE2086>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_FALSE(value->has_value());\n}\n\nTEST_P(GraphicsMapperStableCTests, GetCta861_3) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    auto value = getStandardMetadata<StandardMetadataType::CTA861_3>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_FALSE(value->has_value());\n\n    const Cta861_3 genericHlgish{1000.f, 140.f};\n    EXPECT_EQ(AIMAPPER_ERROR_NONE,\n              setStandardMetadata<StandardMetadataType::CTA861_3>(*bufferHandle, genericHlgish));\n    value = getStandardMetadata<StandardMetadataType::CTA861_3>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    ASSERT_TRUE(value->has_value());\n    EXPECT_EQ(genericHlgish, *value);\n\n    EXPECT_EQ(AIMAPPER_ERROR_NONE,\n              setStandardMetadata<StandardMetadataType::CTA861_3>(*bufferHandle, std::nullopt));\n    value = getStandardMetadata<StandardMetadataType::CTA861_3>(*bufferHandle);\n    ASSERT_TRUE(value.has_value());\n    EXPECT_FALSE(value->has_value());\n}\n\nTEST_P(GraphicsMapperStableCTests, GetSmpte2094_10) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    auto value = getStandardMetadata<StandardMetadataType::SMPTE2094_10>(*bufferHandle);\n    if (value.has_value()) {\n        EXPECT_FALSE(value->has_value());\n    }\n}\n\nTEST_P(GraphicsMapperStableCTests, GetSmpte2094_40) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    auto value = getStandardMetadata<StandardMetadataType::SMPTE2094_40>(*bufferHandle);\n    if (value.has_value()) {\n        EXPECT_FALSE(value->has_value());\n    }\n}\n\nTEST_P(GraphicsMapperStableCTests, SupportsRequiredGettersSetters) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    const AIMapper_MetadataTypeDescription* descriptions = nullptr;\n    size_t descriptionCount = 0;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE,\n              mapper()->v5.listSupportedMetadataTypes(&descriptions, &descriptionCount));\n    std::vector<StandardMetadataType> requiredGetters = {\n            StandardMetadataType::BUFFER_ID,\n            StandardMetadataType::NAME,\n            StandardMetadataType::WIDTH,\n            StandardMetadataType::HEIGHT,\n            StandardMetadataType::LAYER_COUNT,\n            StandardMetadataType::PIXEL_FORMAT_REQUESTED,\n            StandardMetadataType::PIXEL_FORMAT_FOURCC,\n            StandardMetadataType::PIXEL_FORMAT_MODIFIER,\n            StandardMetadataType::USAGE,\n            StandardMetadataType::ALLOCATION_SIZE,\n            StandardMetadataType::PROTECTED_CONTENT,\n            StandardMetadataType::COMPRESSION,\n            StandardMetadataType::INTERLACED,\n            StandardMetadataType::CHROMA_SITING,\n            StandardMetadataType::PLANE_LAYOUTS,\n            StandardMetadataType::CROP,\n            StandardMetadataType::DATASPACE,\n            StandardMetadataType::BLEND_MODE,\n            StandardMetadataType::SMPTE2086,\n            StandardMetadataType::CTA861_3,\n    };\n\n    std::vector<StandardMetadataType> requiredSetters = {\n            StandardMetadataType::DATASPACE,\n            StandardMetadataType::BLEND_MODE,\n            StandardMetadataType::SMPTE2086,\n            StandardMetadataType::CTA861_3,\n    };\n\n    for (int i = 0; i < descriptionCount; i++) {\n        const auto& it = descriptions[i];\n        if (isStandardMetadata(it.metadataType)) {\n            EXPECT_GT(it.metadataType.value, static_cast<int64_t>(StandardMetadataType::INVALID));\n            EXPECT_LT(it.metadataType.value,\n                      ndk::internal::enum_values<StandardMetadataType>.size());\n\n            if (it.isGettable) {\n                std::erase(requiredGetters,\n                           static_cast<StandardMetadataType>(it.metadataType.value));\n            }\n            if (it.isSettable) {\n                std::erase(requiredSetters,\n                           static_cast<StandardMetadataType>(it.metadataType.value));\n            }\n        } else {\n            EXPECT_NE(nullptr, it.description) << \"Non-standard metadata must have a description\";\n            int len = strlen(it.description);\n            EXPECT_GE(len, 0) << \"Non-standard metadata must have a description\";\n        }\n    }\n\n    EXPECT_EQ(0, requiredGetters.size()) << \"Missing required getters\" << toString(requiredGetters);\n    EXPECT_EQ(0, requiredSetters.size()) << \"Missing required setters\" << toString(requiredSetters);\n}\n\n/*\n * Test that verifies that if the optional StandardMetadataTypes have getters, they have\n * the required setters as well\n */\nTEST_P(GraphicsMapperStableCTests, CheckRequiredSettersIfHasGetters) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    const AIMapper_MetadataTypeDescription* descriptions = nullptr;\n    size_t descriptionCount = 0;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE,\n              mapper()->v5.listSupportedMetadataTypes(&descriptions, &descriptionCount));\n\n    for (int i = 0; i < descriptionCount; i++) {\n        const auto& it = descriptions[i];\n        if (isStandardMetadata(it.metadataType)) {\n            const auto type = static_cast<StandardMetadataType>(it.metadataType.value);\n            switch (type) {\n                case StandardMetadataType::SMPTE2094_10:\n                case StandardMetadataType::SMPTE2094_40:\n                    if (it.isGettable) {\n                        EXPECT_TRUE(it.isSettable)\n                                << \"Type \" << toString(type) << \" must be settable if gettable\";\n                    }\n                    break;\n                default:\n                    break;\n            }\n        }\n    }\n}\n\nTEST_P(GraphicsMapperStableCTests, ListSupportedWorks) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n    const AIMapper_MetadataTypeDescription* descriptions = nullptr;\n    size_t descriptionCount = 0;\n    ASSERT_EQ(AIMAPPER_ERROR_NONE,\n              mapper()->v5.listSupportedMetadataTypes(&descriptions, &descriptionCount));\n\n    std::vector<uint8_t> metadataBuffer;\n    auto get = [&](AIMapper_MetadataType metadataType) -> int32_t {\n        int32_t size = mapper()->v5.getMetadata(*bufferHandle, metadataType, nullptr, 0);\n        if (size >= 0) {\n            metadataBuffer.resize(size);\n            size = mapper()->v5.getMetadata(*bufferHandle, metadataType, metadataBuffer.data(),\n                                            metadataBuffer.size());\n            EXPECT_EQ(size, metadataBuffer.size());\n        }\n        return size;\n    };\n\n    for (int i = 0; i < descriptionCount; i++) {\n        const auto& it = descriptions[i];\n        if (!isStandardMetadata(it.metadataType)) {\n            continue;\n        }\n        if (!it.isGettable) {\n            EXPECT_FALSE(it.isSettable)\n                    << \"StandardMetadata that isn't gettable must not be settable\";\n            continue;\n        }\n        EXPECT_GE(get(it.metadataType), 0)\n                << \"Get failed for claimed supported getter of \"\n                << toString(static_cast<StandardMetadataType>(it.metadataType.value));\n        if (it.isSettable) {\n            EXPECT_EQ(AIMAPPER_ERROR_NONE,\n                      mapper()->v5.setMetadata(*bufferHandle, it.metadataType,\n                                               metadataBuffer.data(), metadataBuffer.size()))\n                    << \"Failed to set metadata for \"\n                    << toString(static_cast<StandardMetadataType>(it.metadataType.value));\n        }\n    }\n}\n\nTEST_P(GraphicsMapperStableCTests, GetMetadataBadValue) {\n    auto get = [this](StandardMetadataType type) -> AIMapper_Error {\n        // This is a _Nonnull parameter, but this is enough obfuscation to fool the linter\n        buffer_handle_t buffer = nullptr;\n        int32_t ret =\n                mapper()->v5.getStandardMetadata(buffer, static_cast<int64_t>(type), nullptr, 0);\n        return (ret < 0) ? (AIMapper_Error)-ret : AIMAPPER_ERROR_NONE;\n    };\n\n    for (auto type : ndk::enum_range<StandardMetadataType>()) {\n        if (type == StandardMetadataType::INVALID) {\n            continue;\n        }\n        EXPECT_EQ(AIMAPPER_ERROR_BAD_BUFFER, get(type)) << \"Wrong error for \" << toString(type);\n    }\n}\n\nTEST_P(GraphicsMapperStableCTests, GetUnsupportedMetadata) {\n    auto buffer = allocateGeneric();\n    ASSERT_TRUE(buffer);\n    auto bufferHandle = buffer->import();\n    ASSERT_TRUE(bufferHandle);\n\n    int result = mapper()->v5.getMetadata(*bufferHandle, {\"Fake\", 1}, nullptr, 0);\n    EXPECT_EQ(AIMAPPER_ERROR_UNSUPPORTED, -result);\n\n    result = mapper()->v5.getStandardMetadata(\n            *bufferHandle, static_cast<int64_t>(StandardMetadataType::INVALID), nullptr, 0);\n    EXPECT_EQ(AIMAPPER_ERROR_UNSUPPORTED, -result);\n\n    constexpr int64_t unknownStandardType = ndk::internal::enum_values<StandardMetadataType>.size();\n    result = mapper()->v5.getStandardMetadata(*bufferHandle, unknownStandardType, nullptr, 0);\n    EXPECT_EQ(AIMAPPER_ERROR_UNSUPPORTED, -result);\n}\n\nstd::vector<std::tuple<std::string, std::shared_ptr<IAllocator>>> getIAllocatorsAtLeastVersion(\n        int32_t minVersion) {\n    auto instanceNames = getAidlHalInstanceNames(IAllocator::descriptor);\n    std::vector<std::tuple<std::string, std::shared_ptr<IAllocator>>> filteredInstances;\n    filteredInstances.reserve(instanceNames.size());\n    for (const auto& name : instanceNames) {\n        auto allocator =\n                IAllocator::fromBinder(ndk::SpAIBinder(AServiceManager_checkService(name.c_str())));\n        int32_t version = 0;\n        if (allocator->getInterfaceVersion(&version).isOk()) {\n            if (version >= minVersion) {\n                filteredInstances.emplace_back(name, std::move(allocator));\n            }\n        }\n    }\n    return filteredInstances;\n}\n\nGTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(GraphicsMapperStableCTests);\nINSTANTIATE_TEST_CASE_P(PerInstance, GraphicsMapperStableCTests,\n                        testing::ValuesIn(getIAllocatorsAtLeastVersion(2)),\n                        [](auto info) -> std::string {\n                            std::string name =\n                                    std::to_string(info.index) + \"/\" + std::get<0>(info.param);\n                            return Sanitize(name);\n                        });",
        "lookback": " * Copyright 2022 The Android Open Source Project",
        "lookahead": "",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 0,
        "end_line": 3331,
        "merge_gen_region": " Copyright022 Android Source/* Copyright022 Android Source * Licensed the Apache, 2. ( \"\"); you not this except in with the. * may a of License * may a of License * *://..///LICENSE20 * Unless by law agreed in,, * under License distributed anAS\" BASIS * WITHOUT OR OF KIND either or.. See License for specific governing and limitations the License */undef_ # LOGTAGdefine_ \"tsGraphicsStCTarget\"includeaid//intfh # <aid//Error.>includeaid/androidhardwaregraphicsallocatorAllocation.>includeaid////Resulth # <landroidhardwaregraphicsallocatorI.>includeaid//////Usageh # <landroidhardwaregraphicscommonPixelFormath # <lsupportNative.>includeandroidbinderenum.>includeandroidbindermanagerh # <androiddle.>includeandroidhardwaregraphicscommonIMperh # <androidhardwaregraphicsmapperutilsIMperMetadata.>includegrloypesGr4h # <hid/GPrinterh # <systemgraphicsh # <dcn.>includedrmdrmfourcch # <gtestgtesthh # <ndk/linkerh # <__>includeoptional # <string",
        "confidence": 0.9356739521026611,
        "hesitated": false,
        "resolved": false
    }
]