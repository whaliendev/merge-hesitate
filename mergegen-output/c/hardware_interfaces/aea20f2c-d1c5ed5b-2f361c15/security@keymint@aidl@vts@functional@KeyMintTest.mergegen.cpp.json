[
    {
        "a_contents": " * NewKeyGenerationTest.EcdsaAttestationIdTags\n *\n * Verifies that creation of an attested ECDSA key includes various ID tags in the\n * attestation extension.\n */\nTEST_P(NewKeyGenerationTest, EcdsaAttestationIdTags) {\n    auto challenge = \"hello\";\n    auto app_id = \"foo\";\n    auto subject = \"cert subj 2\";\n    vector<uint8_t> subject_der(make_name_from_str(subject));\n    uint64_t serial_int = 0x1010;\n    vector<uint8_t> serial_blob(build_serial_blob(serial_int));\n    const AuthorizationSetBuilder base_builder =\n            AuthorizationSetBuilder()\n                    .Authorization(TAG_NO_AUTH_REQUIRED)\n                    .EcdsaSigningKey(EcCurve::P_256)\n                    .Digest(Digest::NONE)\n                    .AttestationChallenge(challenge)\n                    .AttestationApplicationId(app_id)\n                    .Authorization(TAG_CERTIFICATE_SERIAL, serial_blob)\n                    .Authorization(TAG_CERTIFICATE_SUBJECT, subject_der)\n                    .SetDefaultValidity();\n\n    // Various ATTESTATION_ID_* tags that map to fields in the attestation extension ASN.1 schema.\n    auto extra_tags = AuthorizationSetBuilder();\n    add_tag_from_prop(&extra_tags, TAG_ATTESTATION_ID_BRAND, \"ro.product.brand\");\n    add_tag_from_prop(&extra_tags, TAG_ATTESTATION_ID_DEVICE, \"ro.product.device\");\n    add_tag_from_prop(&extra_tags, TAG_ATTESTATION_ID_PRODUCT, \"ro.product.name\");\n    add_tag_from_prop(&extra_tags, TAG_ATTESTATION_ID_SERIAL, \"ro.serial\");\n    add_tag_from_prop(&extra_tags, TAG_ATTESTATION_ID_MANUFACTURER, \"ro.product.manufacturer\");\n    add_tag_from_prop(&extra_tags, TAG_ATTESTATION_ID_MODEL, \"ro.product.model\");\n\n    for (const KeyParameter& tag : extra_tags) {\n        SCOPED_TRACE(testing::Message() << \"tag-\" << tag);\n        vector<uint8_t> key_blob;\n        vector<KeyCharacteristics> key_characteristics;\n        AuthorizationSetBuilder builder = base_builder;\n        builder.push_back(tag);\n        auto result = GenerateKey(builder, &key_blob, &key_characteristics);\n        if (result == ErrorCode::CANNOT_ATTEST_IDS) {\n            // Device ID attestation is optional; KeyMint may not support it at all.\n            continue;\n        }\n        ASSERT_EQ(result, ErrorCode::OK);\n        ASSERT_GT(key_blob.size(), 0U);\n\n        EXPECT_TRUE(ChainSignaturesAreValid(cert_chain_));\n        ASSERT_GT(cert_chain_.size(), 0);\n        verify_subject_and_serial(cert_chain_[0], serial_int, subject, /* self_signed = */ false);\n\n        AuthorizationSet hw_enforced = HwEnforcedAuthorizations(key_characteristics);\n        AuthorizationSet sw_enforced = SwEnforcedAuthorizations(key_characteristics);\n\n        // The attested key characteristics will not contain APPLICATION_ID_* fields (their\n        // spec definitions all have \"Must never appear in KeyCharacteristics\"), but the\n        // attestation extension should contain them, so make sure the extra tag is added.\n        hw_enforced.push_back(tag);\n\n        // Verifying the attestation record will check for the specific tag because\n        // it's included in the authorizations.\n        EXPECT_TRUE(verify_attestation_record(challenge, app_id, sw_enforced, hw_enforced,\n                                              SecLevel(), cert_chain_[0].encodedCertificate));\n\n        CheckedDeleteKey(&key_blob);\n    }\n}\n\n/*\n * NewKeyGenerationTest.EcdsaAttestationUniqueId\n *\n * Verifies that creation of an attested ECDSA key with a UNIQUE_ID included.\n */\nTEST_P(NewKeyGenerationTest, EcdsaAttestationUniqueId) {\n    auto get_unique_id = [this](const std::string& app_id, uint64_t datetime,\n                                vector<uint8_t>* unique_id, bool reset = false) {\n        auto challenge = \"hello\";\n        auto subject = \"cert subj 2\";\n        vector<uint8_t> subject_der(make_name_from_str(subject));\n        uint64_t serial_int = 0x1010;\n        vector<uint8_t> serial_blob(build_serial_blob(serial_int));\n        AuthorizationSetBuilder builder =\n                AuthorizationSetBuilder()\n                        .Authorization(TAG_NO_AUTH_REQUIRED)\n                        .Authorization(TAG_INCLUDE_UNIQUE_ID)\n                        .EcdsaSigningKey(EcCurve::P_256)\n                        .Digest(Digest::NONE)\n                        .AttestationChallenge(challenge)\n                        .Authorization(TAG_CERTIFICATE_SERIAL, serial_blob)\n                        .Authorization(TAG_CERTIFICATE_SUBJECT, subject_der)\n                        .AttestationApplicationId(app_id)\n                        .Authorization(TAG_CREATION_DATETIME, datetime)\n                        .SetDefaultValidity();\n        if (reset) {\n            builder.Authorization(TAG_RESET_SINCE_ID_ROTATION);\n        }\n\n        ASSERT_EQ(ErrorCode::OK, GenerateKey(builder));\n        ASSERT_GT(key_blob_.size(), 0U);\n\n        EXPECT_TRUE(ChainSignaturesAreValid(cert_chain_));\n        ASSERT_GT(cert_chain_.size(), 0);\n        verify_subject_and_serial(cert_chain_[0], serial_int, subject, /* self_signed = */ false);\n\n        AuthorizationSet hw_enforced = HwEnforcedAuthorizations(key_characteristics_);\n        AuthorizationSet sw_enforced = SwEnforcedAuthorizations(key_characteristics_);\n\n        // Check that the unique ID field in the extension is non-empty.\n        EXPECT_TRUE(verify_attestation_record(challenge, app_id, sw_enforced, hw_enforced,\n                                              SecLevel(), cert_chain_[0].encodedCertificate,\n                                              unique_id));\n        EXPECT_GT(unique_id->size(), 0);\n        CheckedDeleteKey();\n    };\n\n    // Generate unique ID\n    auto app_id = \"foo\";\n    uint64_t cert_date = 1619621648000;  // Wed Apr 28 14:54:08 2021 in ms since epoch\n    vector<uint8_t> unique_id;\n    get_unique_id(app_id, cert_date, &unique_id);\n\n    // Generating a new key with the same parameters should give the same unique ID.\n    vector<uint8_t> unique_id2;\n    get_unique_id(app_id, cert_date, &unique_id2);\n    EXPECT_EQ(unique_id, unique_id2);\n\n    // Generating a new key with a slightly different date should give the same unique ID.\n    uint64_t rounded_date = cert_date / 2592000000LLU;\n    uint64_t min_date = rounded_date * 2592000000LLU;\n    uint64_t max_date = ((rounded_date + 1) * 2592000000LLU) - 1;\n\n    vector<uint8_t> unique_id3;\n    get_unique_id(app_id, min_date, &unique_id3);\n    EXPECT_EQ(unique_id, unique_id3);\n\n    vector<uint8_t> unique_id4;\n    get_unique_id(app_id, max_date, &unique_id4);\n    EXPECT_EQ(unique_id, unique_id4);\n\n    // A different attestation application ID should yield a different unique ID.\n    auto app_id2 = \"different_foo\";\n    vector<uint8_t> unique_id5;\n    get_unique_id(app_id2, cert_date, &unique_id5);\n    EXPECT_NE(unique_id, unique_id5);\n\n    // A radically different date should yield a different unique ID.\n    vector<uint8_t> unique_id6;\n    get_unique_id(app_id, 1611621648000, &unique_id6);\n    EXPECT_NE(unique_id, unique_id6);\n\n    vector<uint8_t> unique_id7;\n    get_unique_id(app_id, max_date + 1, &unique_id7);\n    EXPECT_NE(unique_id, unique_id7);\n\n    vector<uint8_t> unique_id8;\n    get_unique_id(app_id, min_date - 1, &unique_id8);\n    EXPECT_NE(unique_id, unique_id8);\n\n    // Marking RESET_SINCE_ID_ROTATION should give a different unique ID.\n    vector<uint8_t> unique_id9;\n    get_unique_id(app_id, cert_date, &unique_id9, /* reset_id = */ true);\n    EXPECT_NE(unique_id, unique_id9);\n}\n\n/*",
        "b_contents": " * NewKeyGenerationTest.EcdsaAttestationUniqueId\n *\n * Verifies that creation of an attested ECDSA key with a UNIQUE_ID included.\n */\nTEST_P(NewKeyGenerationTest, EcdsaAttestationUniqueId) {\n    auto get_unique_id = [this](const std::string& app_id, uint64_t datetime,\n                                vector<uint8_t>* unique_id) {\n        auto challenge = \"hello\";\n        auto subject = \"cert subj 2\";\n        vector<uint8_t> subject_der(make_name_from_str(subject));\n        uint64_t serial_int = 0x1010;\n        vector<uint8_t> serial_blob(build_serial_blob(serial_int));\n        const AuthorizationSetBuilder builder =\n                AuthorizationSetBuilder()\n                        .Authorization(TAG_NO_AUTH_REQUIRED)\n                        .Authorization(TAG_INCLUDE_UNIQUE_ID)\n                        .EcdsaSigningKey(EcCurve::P_256)\n                        .Digest(Digest::NONE)\n                        .AttestationChallenge(challenge)\n                        .Authorization(TAG_CERTIFICATE_SERIAL, serial_blob)\n                        .Authorization(TAG_CERTIFICATE_SUBJECT, subject_der)\n                        .AttestationApplicationId(app_id)\n                        .Authorization(TAG_CREATION_DATETIME, datetime)\n                        .SetDefaultValidity();\n\n        ASSERT_EQ(ErrorCode::OK, GenerateKey(builder));\n        ASSERT_GT(key_blob_.size(), 0U);\n\n        EXPECT_TRUE(ChainSignaturesAreValid(cert_chain_));\n        ASSERT_GT(cert_chain_.size(), 0);\n        verify_subject_and_serial(cert_chain_[0], serial_int, subject, /* self_signed = */ false);\n\n        AuthorizationSet hw_enforced = HwEnforcedAuthorizations(key_characteristics_);\n        AuthorizationSet sw_enforced = SwEnforcedAuthorizations(key_characteristics_);\n\n        // Check that the unique ID field in the extension is non-empty.\n        EXPECT_TRUE(verify_attestation_record(challenge, app_id, sw_enforced, hw_enforced,\n                                              SecLevel(), cert_chain_[0].encodedCertificate,\n                                              unique_id));\n        EXPECT_GT(unique_id->size(), 0);\n        CheckedDeleteKey();\n    };\n\n    // Generate unique ID\n    auto app_id = \"foo\";\n    uint64_t cert_date = 1619621648000;  // Wed Apr 28 14:54:08 2021 in ms since epoch\n    vector<uint8_t> unique_id;\n    get_unique_id(app_id, cert_date, &unique_id);\n\n    // Generating a new key with the same parameters should give the same unique ID.\n    vector<uint8_t> unique_id2;\n    get_unique_id(app_id, cert_date, &unique_id2);\n    EXPECT_EQ(unique_id, unique_id2);\n\n    // Generating a new key with a slightly different date should give the same unique ID.\n    uint64_t rounded_date = cert_date / 2592000000LLU;\n    uint64_t min_date = rounded_date * 2592000000LLU;\n    uint64_t max_date = ((rounded_date + 1) * 2592000000LLU) - 1;\n\n    vector<uint8_t> unique_id3;\n    get_unique_id(app_id, min_date, &unique_id3);\n    EXPECT_EQ(unique_id, unique_id3);\n\n    vector<uint8_t> unique_id4;\n    get_unique_id(app_id, max_date, &unique_id4);\n    EXPECT_EQ(unique_id, unique_id4);\n\n    // A different attestation application ID should yield a different unique ID.\n    auto app_id2 = \"different_foo\";\n    vector<uint8_t> unique_id5;\n    get_unique_id(app_id2, cert_date, &unique_id5);\n    EXPECT_NE(unique_id, unique_id5);\n\n    // A radically different date should yield a different unique ID.\n    vector<uint8_t> unique_id6;\n    get_unique_id(app_id, 1611621648000, &unique_id6);\n    EXPECT_NE(unique_id, unique_id6);\n\n    vector<uint8_t> unique_id7;\n    get_unique_id(app_id, max_date + 1, &unique_id7);\n    EXPECT_NE(unique_id, unique_id7);\n\n    vector<uint8_t> unique_id8;\n    get_unique_id(app_id, min_date - 1, &unique_id8);\n    EXPECT_NE(unique_id, unique_id8);\n}\n\n/*",
        "base_contents": "",
        "res_region": " * NewKeyGenerationTest.EcdsaAttestationIdTags\n *\n * Verifies that creation of an attested ECDSA key includes various ID tags in the\n * attestation extension.\n */\nTEST_P(NewKeyGenerationTest, EcdsaAttestationIdTags) {\n    auto challenge = \"hello\";\n    auto app_id = \"foo\";\n    auto subject = \"cert subj 2\";\n    vector<uint8_t> subject_der(make_name_from_str(subject));\n    uint64_t serial_int = 0x1010;\n    vector<uint8_t> serial_blob(build_serial_blob(serial_int));\n    const AuthorizationSetBuilder base_builder =\n            AuthorizationSetBuilder()\n                    .Authorization(TAG_NO_AUTH_REQUIRED)\n                    .EcdsaSigningKey(EcCurve::P_256)\n                    .Digest(Digest::NONE)\n                    .AttestationChallenge(challenge)\n                    .AttestationApplicationId(app_id)\n                    .Authorization(TAG_CERTIFICATE_SERIAL, serial_blob)\n                    .Authorization(TAG_CERTIFICATE_SUBJECT, subject_der)\n                    .SetDefaultValidity();\n\n    // Various ATTESTATION_ID_* tags that map to fields in the attestation extension ASN.1 schema.\n    auto extra_tags = AuthorizationSetBuilder();\n    add_tag_from_prop(&extra_tags, TAG_ATTESTATION_ID_BRAND, \"ro.product.brand\");\n    add_tag_from_prop(&extra_tags, TAG_ATTESTATION_ID_DEVICE, \"ro.product.device\");\n    add_tag_from_prop(&extra_tags, TAG_ATTESTATION_ID_PRODUCT, \"ro.product.name\");\n    add_tag_from_prop(&extra_tags, TAG_ATTESTATION_ID_SERIAL, \"ro.serial\");\n    add_tag_from_prop(&extra_tags, TAG_ATTESTATION_ID_MANUFACTURER, \"ro.product.manufacturer\");\n    add_tag_from_prop(&extra_tags, TAG_ATTESTATION_ID_MODEL, \"ro.product.model\");\n\n    for (const KeyParameter& tag : extra_tags) {\n        SCOPED_TRACE(testing::Message() << \"tag-\" << tag);\n        vector<uint8_t> key_blob;\n        vector<KeyCharacteristics> key_characteristics;\n        AuthorizationSetBuilder builder = base_builder;\n        builder.push_back(tag);\n        auto result = GenerateKey(builder, &key_blob, &key_characteristics);\n        if (result == ErrorCode::CANNOT_ATTEST_IDS) {\n            // Device ID attestation is optional; KeyMint may not support it at all.\n            continue;\n        }\n        ASSERT_EQ(result, ErrorCode::OK);\n        ASSERT_GT(key_blob.size(), 0U);\n\n        EXPECT_TRUE(ChainSignaturesAreValid(cert_chain_));\n        ASSERT_GT(cert_chain_.size(), 0);\n        verify_subject_and_serial(cert_chain_[0], serial_int, subject, /* self_signed = */ false);\n\n        AuthorizationSet hw_enforced = HwEnforcedAuthorizations(key_characteristics);\n        AuthorizationSet sw_enforced = SwEnforcedAuthorizations(key_characteristics);\n\n        // The attested key characteristics will not contain APPLICATION_ID_* fields (their\n        // spec definitions all have \"Must never appear in KeyCharacteristics\"), but the\n        // attestation extension should contain them, so make sure the extra tag is added.\n        hw_enforced.push_back(tag);\n\n        // Verifying the attestation record will check for the specific tag because\n        // it's included in the authorizations.\n        EXPECT_TRUE(verify_attestation_record(challenge, app_id, sw_enforced, hw_enforced,\n                                              SecLevel(), cert_chain_[0].encodedCertificate));\n\n        CheckedDeleteKey(&key_blob);\n    }\n}\n\n/*\n * NewKeyGenerationTest.EcdsaAttestationUniqueId\n *\n * Verifies that creation of an attested ECDSA key with a UNIQUE_ID included.\n */\nTEST_P(NewKeyGenerationTest, EcdsaAttestationUniqueId) {\n    auto get_unique_id = [this](const std::string& app_id, uint64_t datetime,\n                                vector<uint8_t>* unique_id, bool reset = false) {\n        auto challenge = \"hello\";\n        auto subject = \"cert subj 2\";\n        vector<uint8_t> subject_der(make_name_from_str(subject));\n        uint64_t serial_int = 0x1010;\n        vector<uint8_t> serial_blob(build_serial_blob(serial_int));\n        AuthorizationSetBuilder builder =\n                AuthorizationSetBuilder()\n                        .Authorization(TAG_NO_AUTH_REQUIRED)\n                        .Authorization(TAG_INCLUDE_UNIQUE_ID)\n                        .EcdsaSigningKey(EcCurve::P_256)\n                        .Digest(Digest::NONE)\n                        .AttestationChallenge(challenge)\n                        .Authorization(TAG_CERTIFICATE_SERIAL, serial_blob)\n                        .Authorization(TAG_CERTIFICATE_SUBJECT, subject_der)\n                        .AttestationApplicationId(app_id)\n                        .Authorization(TAG_CREATION_DATETIME, datetime)\n                        .SetDefaultValidity();\n        if (reset) {\n            builder.Authorization(TAG_RESET_SINCE_ID_ROTATION);\n        }\n\n        ASSERT_EQ(ErrorCode::OK, GenerateKey(builder));\n        ASSERT_GT(key_blob_.size(), 0U);\n\n        EXPECT_TRUE(ChainSignaturesAreValid(cert_chain_));\n        ASSERT_GT(cert_chain_.size(), 0);\n        verify_subject_and_serial(cert_chain_[0], serial_int, subject, /* self_signed = */ false);\n\n        AuthorizationSet hw_enforced = HwEnforcedAuthorizations(key_characteristics_);\n        AuthorizationSet sw_enforced = SwEnforcedAuthorizations(key_characteristics_);\n\n        // Check that the unique ID field in the extension is non-empty.\n        EXPECT_TRUE(verify_attestation_record(challenge, app_id, sw_enforced, hw_enforced,\n                                              SecLevel(), cert_chain_[0].encodedCertificate,\n                                              unique_id));\n        EXPECT_GT(unique_id->size(), 0);\n        CheckedDeleteKey();\n    };\n\n    // Generate unique ID\n    auto app_id = \"foo\";\n    uint64_t cert_date = 1619621648000;  // Wed Apr 28 14:54:08 2021 in ms since epoch\n    vector<uint8_t> unique_id;\n    get_unique_id(app_id, cert_date, &unique_id);\n\n    // Generating a new key with the same parameters should give the same unique ID.\n    vector<uint8_t> unique_id2;\n    get_unique_id(app_id, cert_date, &unique_id2);\n    EXPECT_EQ(unique_id, unique_id2);\n\n    // Generating a new key with a slightly different date should give the same unique ID.\n    uint64_t rounded_date = cert_date / 2592000000LLU;\n    uint64_t min_date = rounded_date * 2592000000LLU;\n    uint64_t max_date = ((rounded_date + 1) * 2592000000LLU) - 1;\n\n    vector<uint8_t> unique_id3;\n    get_unique_id(app_id, min_date, &unique_id3);\n    EXPECT_EQ(unique_id, unique_id3);\n\n    vector<uint8_t> unique_id4;\n    get_unique_id(app_id, max_date, &unique_id4);\n    EXPECT_EQ(unique_id, unique_id4);\n\n    // A different attestation application ID should yield a different unique ID.\n    auto app_id2 = \"different_foo\";\n    vector<uint8_t> unique_id5;\n    get_unique_id(app_id2, cert_date, &unique_id5);\n    EXPECT_NE(unique_id, unique_id5);\n\n    // A radically different date should yield a different unique ID.\n    vector<uint8_t> unique_id6;\n    get_unique_id(app_id, 1611621648000, &unique_id6);\n    EXPECT_NE(unique_id, unique_id6);\n\n    vector<uint8_t> unique_id7;\n    get_unique_id(app_id, max_date + 1, &unique_id7);\n    EXPECT_NE(unique_id, unique_id7);\n\n    vector<uint8_t> unique_id8;\n    get_unique_id(app_id, min_date - 1, &unique_id8);\n    EXPECT_NE(unique_id, unique_id8);\n\n    // Marking RESET_SINCE_ID_ROTATION should give a different unique ID.\n    vector<uint8_t> unique_id9;\n    get_unique_id(app_id, cert_date, &unique_id9, /* reset_id = */ true);\n    EXPECT_NE(unique_id, unique_id9);\n}\n\n/*",
        "lookback": " *",
        "lookahead": " * NewKeyGenerationTest.EcdsaAttestationTagNoApplicationId",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 1555,
        "end_line": 1810,
        "merge_gen_region": " NewGeneration.cdAtstationTags * Ver that of ated ESA includes ID tags the atstation. TESTPNewGeneration,cdAtstationstationTags { challenge \"hello auto_ = \"\"; appid \"\"; subject \" sub 2\";<8t subjectdermakenamefromstrsubject uint_ serialint 0x;<8t subjectdermakenamefromstrsubject uint_ serialint 01010 vectoruint_>__(__()); AuthorSet basebuilder AuthorSetBuilder .izationTAGNOAUTHREQUIRED .EsacyKeyECurveP256 .(::)Atstation()Atstation()AtstationIdappid .izationTAGCER__, serialblob .izationTAGCER_JECT subjectder .Valid(); Var ATSTATIONID tags map fields in atstation extension. schema auto_ =izationBuilder addtagfrompropextratags TAGATSTATIONIDBR,roproductbr\");____(&_,_TE___,roproductdevice addtagfrompropextratags TAGATSTATIONIDDEVICE \"...\");_____(&_,_TE__,roproductname addtagfrompropextratags TAGATSTATIONIDSERIAL \".\");____(&",
        "confidence": 0.9055463075637817,
        "hesitated": false,
        "resolved": false
    }
]