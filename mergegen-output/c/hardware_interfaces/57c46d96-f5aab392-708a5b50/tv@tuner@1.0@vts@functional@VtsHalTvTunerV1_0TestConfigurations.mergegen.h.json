[
    {
        "a_contents": "",
        "b_contents": "const uint32_t FMQ_SIZE_512K = 0x80000;\nconst uint32_t FMQ_SIZE_1M = 0x100000;",
        "base_contents": "const uint32_t FMQ_SIZE_1M = 0x100000;",
        "res_region": "",
        "lookback": "const uint32_t FMQ_SIZE_16M = 0x1000000;",
        "lookahead": "const uint32_t FMQ_SIZE_4M = 0x400000;",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 38,
        "end_line": 44,
        "merge_gen_region": null,
        "confidence": 0.43073025345802307,
        "hesitated": true
    },
    {
        "a_contents": "const string configFilePath = \"/vendor/etc/tuner_vts_config_1_0.xml\";\n\n#define FILTER_MAIN_TYPE_BIT_COUNT 5\n\n// Hardware configs\nstatic map<string, FrontendConfig> frontendMap;\nstatic map<string, FilterConfig> filterMap;\nstatic map<string, DvrConfig> dvrMap;\nstatic map<string, LnbConfig> lnbMap;\nstatic map<string, TimeFilterConfig> timeFilterMap;\nstatic map<string, vector<uint8_t>> diseqcMsgMap;\nstatic map<string, DescramblerConfig> descramblerMap;\n\n// Hardware and test cases connections\nstatic LiveBroadcastHardwareConnections live;\nstatic ScanHardwareConnections scan;\nstatic DvrPlaybackHardwareConnections playback;\nstatic DvrRecordHardwareConnections record;\nstatic DescramblingHardwareConnections descrambling;\nstatic LnbLiveHardwareConnections lnbLive;\nstatic LnbRecordHardwareConnections lnbRecord;\nstatic TimeFilterHardwareConnections timeFilter;\n\n/** Config all the frontends that would be used in the tests */",
        "b_contents": "#define CLEAR_KEY_SYSTEM_ID 0xF6D8\n#define FILTER_MAIN_TYPE_BIT_COUNT 32\n#define PROVISION_STR                                      \\\n    \"{                                                   \" \\\n    \"  \\\"id\\\": 21140844,                                 \" \\\n    \"  \\\"name\\\": \\\"Test Title\\\",                         \" \\\n    \"  \\\"lowercase_organization_name\\\": \\\"Android\\\",     \" \\\n    \"  \\\"asset_key\\\": {                                  \" \\\n    \"  \\\"encryption_key\\\": \\\"nezAr3CHFrmBR9R8Tedotw==\\\"  \" \\\n    \"  },                                                \" \\\n    \"  \\\"cas_type\\\": 1,                                  \" \\\n    \"  \\\"track_types\\\": [ ]                              \" \\\n    \"}                                                   \"\n\ntypedef enum {\n    TS_VIDEO0,\n    TS_VIDEO1,\n    TS_AUDIO0,\n    TS_PES0,\n    TS_PCR0,\n    TS_SECTION0,\n    TS_TS0,\n    TS_RECORD0,\n    FILTER_MAX,\n} Filter;\n\ntypedef enum {\n    TIMER0,\n    TIMER_MAX,\n} TimeFilter;\n\ntypedef enum {\n    SOURCE,\n    SINK,\n    LINKAGE_DIR,\n} Linkage;\n\ntypedef enum {\n    DVBT,\n    DVBS,\n    FRONTEND_MAX,\n} Frontend;\n\ntypedef enum {\n    LNB0,\n    LNB_EXTERNAL,\n    LNB_MAX,\n} Lnb;\n\ntypedef enum {\n    DISEQC_POWER_ON,\n    DISEQC_MAX,\n} Diseqc;\n\ntypedef enum {\n    SCAN_DVBT,\n    SCAN_MAX,\n} FrontendScan;\n\ntypedef enum {\n    DVR_RECORD0,\n    DVR_PLAYBACK0,\n    DVR_SOFTWARE_FE,\n    DVR_MAX,\n} Dvr;\n\ntypedef enum {\n    DESC_0,\n    DESC_MAX,\n} Descrambler;\n\nstruct FilterConfig {\n    uint32_t bufferSize;\n    DemuxFilterType type;\n    DemuxFilterSettings settings;\n    bool getMqDesc;\n\n    bool operator<(const FilterConfig& /*c*/) const { return false; }\n};\n\nstruct TimeFilterConfig {\n    uint64_t timeStamp;\n};\n\nstruct FrontendConfig {\n    bool enable;\n    bool isSoftwareFe;\n    FrontendType type;\n    FrontendSettings settings;\n    vector<FrontendStatusType> tuneStatusTypes;\n    vector<FrontendStatus> expectTuneStatuses;\n};\n\nstruct LnbConfig {\n    string name;\n    LnbVoltage voltage;\n    LnbTone tone;\n    LnbPosition position;\n};\n\nstruct ChannelConfig {\n    int32_t frontendId;\n    int32_t channelId;\n    std::string channelName;\n    DemuxTpid videoPid;\n    DemuxTpid audioPid;\n};\n\nstruct DvrConfig {\n    DvrType type;\n    uint32_t bufferSize;\n    DvrSettings settings;\n    string playbackInputFile;\n};\n\nstruct DescramblerConfig {\n    uint32_t casSystemId;\n    string provisionStr;\n    vector<uint8_t> hidlPvtData;\n};\n\nstatic FrontendConfig frontendArray[FILTER_MAX];\nstatic FrontendConfig frontendScanArray[SCAN_MAX];\nstatic LnbConfig lnbArray[LNB_MAX];\nstatic vector<uint8_t> diseqcMsgArray[DISEQC_MAX];\nstatic ChannelConfig channelArray[FRONTEND_MAX];\nstatic FilterConfig filterArray[FILTER_MAX];\nstatic TimeFilterConfig timeFilterArray[TIMER_MAX];\nstatic DemuxFilterType filterLinkageTypes[LINKAGE_DIR][FILTER_MAIN_TYPE_BIT_COUNT];\nstatic DvrConfig dvrArray[DVR_MAX];\nstatic DescramblerConfig descramblerArray[DESC_MAX];\nstatic vector<string> goldenOutputFiles;\nstatic int defaultFrontend = DVBT;\nstatic int defaultScanFrontend = SCAN_DVBT;\n\n/** Configuration array for the frontend tune test */",
        "base_contents": "#define CLEAR_KEY_SYSTEM_ID 0xF6D8\n#define FILTER_MAIN_TYPE_BIT_COUNT 32\n#define PROVISION_STR                                      \\\n    \"{                                                   \" \\\n    \"  \\\"id\\\": 21140844,                                 \" \\\n    \"  \\\"name\\\": \\\"Test Title\\\",                         \" \\\n    \"  \\\"lowercase_organization_name\\\": \\\"Android\\\",     \" \\\n    \"  \\\"asset_key\\\": {                                  \" \\\n    \"  \\\"encryption_key\\\": \\\"nezAr3CHFrmBR9R8Tedotw==\\\"  \" \\\n    \"  },                                                \" \\\n    \"  \\\"cas_type\\\": 1,                                  \" \\\n    \"  \\\"track_types\\\": [ ]                              \" \\\n    \"}                                                   \"\n\ntypedef enum {\n    TS_VIDEO0,\n    TS_VIDEO1,\n    TS_AUDIO0,\n    TS_PES0,\n    TS_PCR0,\n    TS_SECTION0,\n    TS_TS0,\n    TS_RECORD0,\n    FILTER_MAX,\n} Filter;\n\ntypedef enum {\n    TIMER0,\n    TIMER_MAX,\n} TimeFilter;\n\ntypedef enum {\n    SOURCE,\n    SINK,\n    LINKAGE_DIR,\n} Linkage;\n\ntypedef enum {\n    DVBT,\n    DVBS,\n    FRONTEND_MAX,\n} Frontend;\n\ntypedef enum {\n    LNB0,\n    LNB_EXTERNAL,\n    LNB_MAX,\n} Lnb;\n\ntypedef enum {\n    DISEQC_POWER_ON,\n    DISEQC_MAX,\n} Diseqc;\n\ntypedef enum {\n    SCAN_DVBT,\n    SCAN_MAX,\n} FrontendScan;\n\ntypedef enum {\n    DVR_RECORD0,\n    DVR_PLAYBACK0,\n    DVR_SOFTWARE_FE,\n    DVR_MAX,\n} Dvr;\n\ntypedef enum {\n    DESC_0,\n    DESC_MAX,\n} Descrambler;\n\nstruct FilterConfig {\n    uint32_t bufferSize;\n    DemuxFilterType type;\n    DemuxFilterSettings settings;\n\n    bool operator<(const FilterConfig& /*c*/) const { return false; }\n};\n\nstruct TimeFilterConfig {\n    bool supportTimeFilter;\n    uint64_t timeStamp;\n};\n\nstruct FrontendConfig {\n    bool isSoftwareFe;\n    FrontendType type;\n    FrontendSettings settings;\n    vector<FrontendStatusType> tuneStatusTypes;\n    vector<FrontendStatus> expectTuneStatuses;\n};\n\nstruct LnbConfig {\n    bool usingLnb;\n    string name;\n    LnbVoltage voltage;\n    LnbTone tone;\n    LnbPosition position;\n};\n\nstruct ChannelConfig {\n    int32_t frontendId;\n    int32_t channelId;\n    std::string channelName;\n    DemuxTpid videoPid;\n    DemuxTpid audioPid;\n};\n\nstruct DvrConfig {\n    DvrType type;\n    uint32_t bufferSize;\n    DvrSettings settings;\n    string playbackInputFile;\n};\n\nstruct DescramblerConfig {\n    uint32_t casSystemId;\n    string provisionStr;\n    vector<uint8_t> hidlPvtData;\n};\n\nstatic FrontendConfig frontendArray[FILTER_MAX];\nstatic FrontendConfig frontendScanArray[SCAN_MAX];\nstatic LnbConfig lnbArray[LNB_MAX];\nstatic vector<uint8_t> diseqcMsgArray[DISEQC_MAX];\nstatic ChannelConfig channelArray[FRONTEND_MAX];\nstatic FilterConfig filterArray[FILTER_MAX];\nstatic TimeFilterConfig timeFilterArray[TIMER_MAX];\nstatic DemuxFilterType filterLinkageTypes[LINKAGE_DIR][FILTER_MAIN_TYPE_BIT_COUNT];\nstatic DvrConfig dvrArray[DVR_MAX];\nstatic DescramblerConfig descramblerArray[DESC_MAX];\nstatic vector<string> goldenOutputFiles;\n\n/** Configuration array for the frontend tune test */",
        "res_region": "const string configFilePath = \"/vendor/etc/tuner_vts_config_1_0.xml\";\n\n#define FILTER_MAIN_TYPE_BIT_COUNT 5\n\n// Hardware configs\nstatic map<string, FrontendConfig> frontendMap;\nstatic map<string, FilterConfig> filterMap;\nstatic map<string, DvrConfig> dvrMap;\nstatic map<string, LnbConfig> lnbMap;\nstatic map<string, TimeFilterConfig> timeFilterMap;\nstatic map<string, vector<uint8_t>> diseqcMsgMap;\nstatic map<string, DescramblerConfig> descramblerMap;\n\n// Hardware and test cases connections\nstatic LiveBroadcastHardwareConnections live;\nstatic ScanHardwareConnections scan;\nstatic DvrPlaybackHardwareConnections playback;\nstatic DvrRecordHardwareConnections record;\nstatic DescramblingHardwareConnections descrambling;\nstatic LnbLiveHardwareConnections lnbLive;\nstatic LnbRecordHardwareConnections lnbRecord;\nstatic TimeFilterHardwareConnections timeFilter;\n\n/** Config all the frontends that would be used in the tests */",
        "lookback": "",
        "lookahead": "inline void initFrontendConfig() {",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 48,
        "end_line": 345,
        "merge_gen_region": "define______ 5 Hardwares map<,end>Map static<,Config; mapstring DConfig dMap static<,nbConfig lMap static<,FilterConfig lMap static<,FilterConfig timeMap static<,<<ConfigMap static<vr; mapstring DConfig dMap static<,nbConfig lMap static>nb; mapstring TimeConfig timeMap static<,<<<8ler; Hardware test connections LiveHardware live staticHardware scan staticvrHardware playback staticvrHardware record staticcrambHardware descb; LLiveConnectionsnbHardware lLive static LRecordConnections lRecord staticFilterConnectionsnb; TimeHardware timeFilter static default = DV; int defaultFrontend SCANDV; Config the front that be in testsinline initConfig",
        "confidence": 0.891897976398468,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "    frontendMap[defaultFeId].tuneStatusTypes = types;\n    frontendMap[defaultFeId].expectTuneStatuses = statuses;\n    frontendMap[defaultFeId].isSoftwareFe = true;",
        "b_contents": "    frontendArray[DVBT].tuneStatusTypes = types;\n    frontendArray[DVBT].expectTuneStatuses = statuses;\n    frontendArray[DVBT].isSoftwareFe = true;\n    frontendArray[DVBT].enable = true;\n    frontendArray[DVBS].type = FrontendType::DVBS;\n    frontendArray[DVBS].enable = false;\n    frontendArray[DVBS].isSoftwareFe = true;\n};",
        "base_contents": "    frontendArray[DVBT].tuneStatusTypes = types;\n    frontendArray[DVBT].expectTuneStatuses = statuses;\n    frontendArray[DVBT].isSoftwareFe = true;\n    frontendArray[DVBS].type = FrontendType::DVBS;\n    frontendArray[DVBS].isSoftwareFe = true;\n};",
        "res_region": "    frontendMap[defaultFeId].tuneStatusTypes = types;\n    frontendMap[defaultFeId].expectTuneStatuses = statuses;\n    frontendMap[defaultFeId].isSoftwareFe = true;",
        "lookback": "    frontendMap[defaultFeId].expectTuneStatuses = statuses;",
        "lookahead": "",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 365,
        "end_line": 385,
        "merge_gen_region": null,
        "confidence": 0.6907738447189331,
        "hesitated": true
    },
    {
        "a_contents": "inline void initFilterConfig() {\n    // The test will use the internal default filter when default filter is connected to any\n    // data flow without overriding in the xml config.\n    string defaultAudioFilterId = \"FILTER_AUDIO_DEFAULT\";\n    string defaultVideoFilterId = \"FILTER_VIDEO_DEFAULT\";\n\n    filterMap[defaultVideoFilterId].type.mainType = DemuxFilterMainType::TS;\n    filterMap[defaultVideoFilterId].type.subType.tsFilterType(DemuxTsFilterType::VIDEO);\n    filterMap[defaultVideoFilterId].bufferSize = FMQ_SIZE_16M;\n    filterMap[defaultVideoFilterId].settings.ts().tpid = 256;\n    filterMap[defaultVideoFilterId].settings.ts().filterSettings.av({.isPassthrough = false});\n\n    filterMap[defaultAudioFilterId].type.mainType = DemuxFilterMainType::TS;\n    filterMap[defaultAudioFilterId].type.subType.tsFilterType(DemuxTsFilterType::AUDIO);\n    filterMap[defaultAudioFilterId].bufferSize = FMQ_SIZE_16M;\n    filterMap[defaultAudioFilterId].settings.ts().tpid = 256;\n    filterMap[defaultAudioFilterId].settings.ts().filterSettings.av({.isPassthrough = false});\n\n    // Read customized config\n    TunerTestingConfigReader1_0::readFilterConfig1_0(filterMap);",
        "b_contents": "/** Configuration array for the Lnb test */\ninline void initLnbConfig() {\n    lnbArray[LNB0].voltage = LnbVoltage::VOLTAGE_12V;\n    lnbArray[LNB0].tone = LnbTone::NONE;\n    lnbArray[LNB0].position = LnbPosition::UNDEFINED;\n    lnbArray[LNB_EXTERNAL].name = \"default_lnb_external\";\n    lnbArray[LNB_EXTERNAL].voltage = LnbVoltage::VOLTAGE_5V;\n    lnbArray[LNB_EXTERNAL].tone = LnbTone::NONE;\n    lnbArray[LNB_EXTERNAL].position = LnbPosition::UNDEFINED;",
        "base_contents": "/** Configuration array for the Lnb test */\ninline void initLnbConfig() {\n    lnbArray[LNB0].usingLnb = true;\n    lnbArray[LNB0].voltage = LnbVoltage::VOLTAGE_12V;\n    lnbArray[LNB0].tone = LnbTone::NONE;\n    lnbArray[LNB0].position = LnbPosition::UNDEFINED;\n    lnbArray[LNB_EXTERNAL].usingLnb = true;\n    lnbArray[LNB_EXTERNAL].name = \"default_lnb_external\";\n    lnbArray[LNB_EXTERNAL].voltage = LnbVoltage::VOLTAGE_5V;\n    lnbArray[LNB_EXTERNAL].tone = LnbTone::NONE;\n    lnbArray[LNB_EXTERNAL].position = LnbPosition::UNDEFINED;",
        "res_region": "inline void initFilterConfig() {\n    // The test will use the internal default filter when default filter is connected to any\n    // data flow without overriding in the xml config.\n    string defaultAudioFilterId = \"FILTER_AUDIO_DEFAULT\";\n    string defaultVideoFilterId = \"FILTER_VIDEO_DEFAULT\";\n\n    filterMap[defaultVideoFilterId].type.mainType = DemuxFilterMainType::TS;\n    filterMap[defaultVideoFilterId].type.subType.tsFilterType(DemuxTsFilterType::VIDEO);\n    filterMap[defaultVideoFilterId].bufferSize = FMQ_SIZE_16M;\n    filterMap[defaultVideoFilterId].settings.ts().tpid = 256;\n    filterMap[defaultVideoFilterId].settings.ts().filterSettings.av({.isPassthrough = false});\n\n    filterMap[defaultAudioFilterId].type.mainType = DemuxFilterMainType::TS;\n    filterMap[defaultAudioFilterId].type.subType.tsFilterType(DemuxTsFilterType::AUDIO);\n    filterMap[defaultAudioFilterId].bufferSize = FMQ_SIZE_16M;\n    filterMap[defaultAudioFilterId].settings.ts().tpid = 256;\n    filterMap[defaultAudioFilterId].settings.ts().filterSettings.av({.isPassthrough = false});\n\n    // Read customized config\n    TunerTestingConfigReader1_0::readFilterConfig1_0(filterMap);",
        "lookback": "    // The test will use the internal default filter when default filter is connected to any",
        "lookahead": "};",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 391,
        "end_line": 434,
        "merge_gen_region": null,
        "confidence": 0.8632853031158447,
        "hesitated": true
    },
    {
        "a_contents": "/** Config all the lnbs that would be used in the tests */\ninline void initLnbConfig() {\n    // Read customized config\n    TunerTestingConfigReader1_0::readLnbConfig1_0(lnbMap);\n    TunerTestingConfigReader1_0::readDiseqcMessages(diseqcMsgMap);",
        "b_contents": "/** Configuration array for the filter test */\ninline void initFilterConfig() {\n    // TS VIDEO filter setting for default implementation testing\n    filterArray[TS_VIDEO0].type.mainType = DemuxFilterMainType::TS;\n    filterArray[TS_VIDEO0].type.subType.tsFilterType(DemuxTsFilterType::VIDEO);\n    filterArray[TS_VIDEO0].bufferSize = FMQ_SIZE_16M;\n    filterArray[TS_VIDEO0].settings.ts().tpid = 256;\n    filterArray[TS_VIDEO0].settings.ts().filterSettings.av({.isPassthrough = false});\n    filterArray[TS_VIDEO1].type.mainType = DemuxFilterMainType::TS;\n    filterArray[TS_VIDEO1].type.subType.tsFilterType(DemuxTsFilterType::VIDEO);\n    filterArray[TS_VIDEO1].bufferSize = FMQ_SIZE_16M;\n    filterArray[TS_VIDEO1].settings.ts().tpid = 256;\n    filterArray[TS_VIDEO1].settings.ts().filterSettings.av({.isPassthrough = false});\n    // TS AUDIO filter setting\n    filterArray[TS_AUDIO0].type.mainType = DemuxFilterMainType::TS;\n    filterArray[TS_AUDIO0].type.subType.tsFilterType(DemuxTsFilterType::AUDIO);\n    filterArray[TS_AUDIO0].bufferSize = FMQ_SIZE_16M;\n    filterArray[TS_AUDIO0].settings.ts().tpid = 256;\n    filterArray[TS_AUDIO0].settings.ts().filterSettings.av({.isPassthrough = false});\n    // TS PES filter setting\n    filterArray[TS_PES0].type.mainType = DemuxFilterMainType::TS;\n    filterArray[TS_PES0].type.subType.tsFilterType(DemuxTsFilterType::PES);\n    filterArray[TS_PES0].bufferSize = FMQ_SIZE_16M;\n    filterArray[TS_PES0].settings.ts().tpid = 256;\n    filterArray[TS_PES0].settings.ts().filterSettings.pesData({\n            .isRaw = false,\n            .streamId = 0xbd,\n    });\n    filterArray[TS_PES0].getMqDesc = true;\n    // TS PCR filter setting\n    filterArray[TS_PCR0].type.mainType = DemuxFilterMainType::TS;\n    filterArray[TS_PCR0].type.subType.tsFilterType(DemuxTsFilterType::PCR);\n    filterArray[TS_PCR0].bufferSize = FMQ_SIZE_16M;\n    filterArray[TS_PCR0].settings.ts().tpid = 256;\n    filterArray[TS_PCR0].settings.ts().filterSettings.noinit();\n    // TS filter setting\n    filterArray[TS_TS0].type.mainType = DemuxFilterMainType::TS;\n    filterArray[TS_TS0].type.subType.tsFilterType(DemuxTsFilterType::TS);\n    filterArray[TS_TS0].bufferSize = FMQ_SIZE_16M;\n    filterArray[TS_TS0].settings.ts().tpid = 256;\n    filterArray[TS_TS0].settings.ts().filterSettings.noinit();\n    // TS SECTION filter setting\n    filterArray[TS_SECTION0].type.mainType = DemuxFilterMainType::TS;\n    filterArray[TS_SECTION0].type.subType.tsFilterType(DemuxTsFilterType::SECTION);\n    filterArray[TS_SECTION0].bufferSize = FMQ_SIZE_16M;\n    filterArray[TS_SECTION0].settings.ts().tpid = 256;\n    filterArray[TS_SECTION0].settings.ts().filterSettings.section({\n            .isRaw = false,\n    });\n    filterArray[TS_SECTION0].getMqDesc = true;\n    // TS RECORD filter setting\n    filterArray[TS_RECORD0].type.mainType = DemuxFilterMainType::TS;\n    filterArray[TS_RECORD0].type.subType.tsFilterType(DemuxTsFilterType::RECORD);\n    filterArray[TS_RECORD0].settings.ts().tpid = 81;\n    filterArray[TS_RECORD0].settings.ts().filterSettings.record({\n            .scIndexType = DemuxRecordScIndexType::NONE,\n    });\n\n    // TS Linkage filter setting\n    filterLinkageTypes[SOURCE][0].mainType = DemuxFilterMainType::TS;\n    filterLinkageTypes[SOURCE][0].subType.tsFilterType(DemuxTsFilterType::TS);\n    filterLinkageTypes[SINK][0] = filterLinkageTypes[SOURCE][0];\n    // MMTP Linkage filter setting\n    filterLinkageTypes[SOURCE][1].mainType = DemuxFilterMainType::MMTP;\n    filterLinkageTypes[SOURCE][1].subType.mmtpFilterType(DemuxMmtpFilterType::AUDIO);\n    filterLinkageTypes[SINK][1] = filterLinkageTypes[SOURCE][1];\n    // IP Linkage filter setting\n    filterLinkageTypes[SOURCE][2].mainType = DemuxFilterMainType::IP;\n    filterLinkageTypes[SOURCE][2].subType.ipFilterType(DemuxIpFilterType::IP);\n    filterLinkageTypes[SINK][2] = filterLinkageTypes[SOURCE][2];\n    // TLV Linkage filter setting\n    filterLinkageTypes[SOURCE][3].mainType = DemuxFilterMainType::TLV;\n    filterLinkageTypes[SOURCE][3].subType.tlvFilterType(DemuxTlvFilterType::TLV);\n    filterLinkageTypes[SINK][3] = filterLinkageTypes[SOURCE][3];\n    // ALP Linkage PTP filter setting\n    filterLinkageTypes[SOURCE][4].mainType = DemuxFilterMainType::ALP;\n    filterLinkageTypes[SOURCE][4].subType.alpFilterType(DemuxAlpFilterType::PTP);\n    filterLinkageTypes[SINK][4] = filterLinkageTypes[SOURCE][4];",
        "base_contents": "/** Configuration array for the filter test */\ninline void initFilterConfig() {\n    // TS VIDEO filter setting for default implementation testing\n    filterArray[TS_VIDEO0].type.mainType = DemuxFilterMainType::TS;\n    filterArray[TS_VIDEO0].type.subType.tsFilterType(DemuxTsFilterType::VIDEO);\n    filterArray[TS_VIDEO0].bufferSize = FMQ_SIZE_16M;\n    filterArray[TS_VIDEO0].settings.ts().tpid = 256;\n    filterArray[TS_VIDEO0].settings.ts().filterSettings.av({.isPassthrough = false});\n    filterArray[TS_VIDEO1].type.mainType = DemuxFilterMainType::TS;\n    filterArray[TS_VIDEO1].type.subType.tsFilterType(DemuxTsFilterType::VIDEO);\n    filterArray[TS_VIDEO1].bufferSize = FMQ_SIZE_16M;\n    filterArray[TS_VIDEO1].settings.ts().tpid = 256;\n    filterArray[TS_VIDEO1].settings.ts().filterSettings.av({.isPassthrough = false});\n    // TS AUDIO filter setting\n    filterArray[TS_AUDIO0].type.mainType = DemuxFilterMainType::TS;\n    filterArray[TS_AUDIO0].type.subType.tsFilterType(DemuxTsFilterType::AUDIO);\n    filterArray[TS_AUDIO0].bufferSize = FMQ_SIZE_16M;\n    filterArray[TS_AUDIO0].settings.ts().tpid = 256;\n    filterArray[TS_AUDIO0].settings.ts().filterSettings.av({.isPassthrough = false});\n    // TS PES filter setting\n    filterArray[TS_PES0].type.mainType = DemuxFilterMainType::TS;\n    filterArray[TS_PES0].type.subType.tsFilterType(DemuxTsFilterType::PES);\n    filterArray[TS_PES0].bufferSize = FMQ_SIZE_16M;\n    filterArray[TS_PES0].settings.ts().tpid = 256;\n    filterArray[TS_PES0].settings.ts().filterSettings.pesData({\n            .isRaw = false,\n            .streamId = 0xbd,\n    });\n    // TS PCR filter setting\n    filterArray[TS_PCR0].type.mainType = DemuxFilterMainType::TS;\n    filterArray[TS_PCR0].type.subType.tsFilterType(DemuxTsFilterType::PCR);\n    filterArray[TS_PCR0].bufferSize = FMQ_SIZE_16M;\n    filterArray[TS_PCR0].settings.ts().tpid = 256;\n    filterArray[TS_PCR0].settings.ts().filterSettings.noinit();\n    // TS filter setting\n    filterArray[TS_TS0].type.mainType = DemuxFilterMainType::TS;\n    filterArray[TS_TS0].type.subType.tsFilterType(DemuxTsFilterType::TS);\n    filterArray[TS_TS0].bufferSize = FMQ_SIZE_16M;\n    filterArray[TS_TS0].settings.ts().tpid = 256;\n    filterArray[TS_TS0].settings.ts().filterSettings.noinit();\n    // TS SECTION filter setting\n    filterArray[TS_SECTION0].type.mainType = DemuxFilterMainType::TS;\n    filterArray[TS_SECTION0].type.subType.tsFilterType(DemuxTsFilterType::SECTION);\n    filterArray[TS_SECTION0].bufferSize = FMQ_SIZE_16M;\n    filterArray[TS_SECTION0].settings.ts().tpid = 256;\n    filterArray[TS_SECTION0].settings.ts().filterSettings.section({\n            .isRaw = false,\n    });\n    // TS RECORD filter setting\n    filterArray[TS_RECORD0].type.mainType = DemuxFilterMainType::TS;\n    filterArray[TS_RECORD0].type.subType.tsFilterType(DemuxTsFilterType::RECORD);\n    filterArray[TS_RECORD0].settings.ts().tpid = 81;\n    filterArray[TS_RECORD0].settings.ts().filterSettings.record({\n            .scIndexType = DemuxRecordScIndexType::NONE,\n    });\n\n    // TS Linkage filter setting\n    filterLinkageTypes[SOURCE][0].mainType = DemuxFilterMainType::TS;\n    filterLinkageTypes[SOURCE][0].subType.tsFilterType(DemuxTsFilterType::TS);\n    filterLinkageTypes[SINK][0] = filterLinkageTypes[SOURCE][0];\n    // MMTP Linkage filter setting\n    filterLinkageTypes[SOURCE][1].mainType = DemuxFilterMainType::MMTP;\n    filterLinkageTypes[SOURCE][1].subType.mmtpFilterType(DemuxMmtpFilterType::AUDIO);\n    filterLinkageTypes[SINK][1] = filterLinkageTypes[SOURCE][1];\n    // IP Linkage filter setting\n    filterLinkageTypes[SOURCE][2].mainType = DemuxFilterMainType::IP;\n    filterLinkageTypes[SOURCE][2].subType.ipFilterType(DemuxIpFilterType::IP);\n    filterLinkageTypes[SINK][2] = filterLinkageTypes[SOURCE][2];\n    // TLV Linkage filter setting\n    filterLinkageTypes[SOURCE][3].mainType = DemuxFilterMainType::TLV;\n    filterLinkageTypes[SOURCE][3].subType.tlvFilterType(DemuxTlvFilterType::TLV);\n    filterLinkageTypes[SINK][3] = filterLinkageTypes[SOURCE][3];\n    // ALP Linkage PTP filter setting\n    filterLinkageTypes[SOURCE][4].mainType = DemuxFilterMainType::ALP;\n    filterLinkageTypes[SOURCE][4].subType.alpFilterType(DemuxAlpFilterType::PTP);\n    filterLinkageTypes[SINK][4] = filterLinkageTypes[SOURCE][4];",
        "res_region": "/** Config all the lnbs that would be used in the tests */\ninline void initLnbConfig() {\n    // Read customized config\n    TunerTestingConfigReader1_0::readLnbConfig1_0(lnbMap);\n    TunerTestingConfigReader1_0::readDiseqcMessages(diseqcMsgMap);",
        "lookback": "inline void initLnbConfig() {",
        "lookahead": "};",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 443,
        "end_line": 605,
        "merge_gen_region": null,
        "confidence": 0.7212152481079102,
        "hesitated": true
    },
    {
        "a_contents": "    // Read customized config\n    TunerTestingConfigReader1_0::readTimeFilterConfig1_0(timeFilterMap);",
        "b_contents": "    timeFilterArray[TIMER0].timeStamp = 1;\n}\n\n/** Configuration array for the dvr test */\ninline void initDvrConfig() {\n    RecordSettings recordSettings{\n            .statusMask = 0xf,\n            .lowThreshold = 0x1000,\n            .highThreshold = 0x07fff,\n            .dataFormat = DataFormat::TS,\n            .packetSize = 188,\n    };\n    dvrArray[DVR_RECORD0].type = DvrType::RECORD;\n    dvrArray[DVR_RECORD0].bufferSize = FMQ_SIZE_4M;\n    dvrArray[DVR_RECORD0].settings.record(recordSettings);\n    PlaybackSettings playbackSettings{\n            .statusMask = 0xf,\n            .lowThreshold = 0x1000,\n            .highThreshold = 0x07fff,\n            .dataFormat = DataFormat::TS,\n            .packetSize = 188,\n    };\n    dvrArray[DVR_PLAYBACK0].type = DvrType::PLAYBACK;\n    dvrArray[DVR_PLAYBACK0].playbackInputFile = \"/data/local/tmp/segment000000.ts\";\n    dvrArray[DVR_PLAYBACK0].bufferSize = FMQ_SIZE_4M;\n    dvrArray[DVR_PLAYBACK0].settings.playback(playbackSettings);\n    PlaybackSettings softwareFePlaybackSettings{\n            .statusMask = 0xf,\n            .lowThreshold = 0x1000,\n            .highThreshold = 0x07fff,\n            .dataFormat = DataFormat::TS,\n            .packetSize = 188,\n    };\n    dvrArray[DVR_SOFTWARE_FE].type = DvrType::PLAYBACK;\n    dvrArray[DVR_SOFTWARE_FE].playbackInputFile = \"/data/local/tmp/segment000000.ts\";\n    dvrArray[DVR_SOFTWARE_FE].bufferSize = FMQ_SIZE_4M;\n    dvrArray[DVR_SOFTWARE_FE].settings.playback(softwareFePlaybackSettings);",
        "base_contents": "    timeFilterArray[TIMER0].supportTimeFilter = true;\n    timeFilterArray[TIMER0].timeStamp = 1;\n}\n\n/** Configuration array for the dvr test */\ninline void initDvrConfig() {\n    RecordSettings recordSettings{\n            .statusMask = 0xf,\n            .lowThreshold = 0x1000,\n            .highThreshold = 0x07fff,\n            .dataFormat = DataFormat::TS,\n            .packetSize = 188,\n    };\n    dvrArray[DVR_RECORD0].type = DvrType::RECORD;\n    dvrArray[DVR_RECORD0].bufferSize = FMQ_SIZE_4M;\n    dvrArray[DVR_RECORD0].settings.record(recordSettings);\n    PlaybackSettings playbackSettings{\n            .statusMask = 0xf,\n            .lowThreshold = 0x1000,\n            .highThreshold = 0x07fff,\n            .dataFormat = DataFormat::TS,\n            .packetSize = 188,\n    };\n    dvrArray[DVR_PLAYBACK0].type = DvrType::PLAYBACK;\n    dvrArray[DVR_PLAYBACK0].playbackInputFile = \"/data/local/tmp/segment000000.ts\";\n    dvrArray[DVR_PLAYBACK0].bufferSize = FMQ_SIZE_4M;\n    dvrArray[DVR_PLAYBACK0].settings.playback(playbackSettings);\n    PlaybackSettings softwareFePlaybackSettings{\n            .statusMask = 0xf,\n            .lowThreshold = 0x1000,\n            .highThreshold = 0x07fff,\n            .dataFormat = DataFormat::TS,\n            .packetSize = 188,\n    };\n    dvrArray[DVR_SOFTWARE_FE].type = DvrType::PLAYBACK;\n    dvrArray[DVR_SOFTWARE_FE].playbackInputFile = \"/data/local/tmp/segment000000.ts\";\n    dvrArray[DVR_SOFTWARE_FE].bufferSize = FMQ_SIZE_4M;\n    dvrArray[DVR_SOFTWARE_FE].settings.playback(softwareFePlaybackSettings);",
        "res_region": "    // Read customized config\n    TunerTestingConfigReader1_0::readTimeFilterConfig1_0(timeFilterMap);",
        "lookback": "    TunerTestingConfigReader1_0::readTimeFilterConfig1_0(timeFilterMap);",
        "lookahead": "};",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 610,
        "end_line": 690,
        "merge_gen_region": null,
        "confidence": 0.5825492143630981,
        "hesitated": true
    }
]