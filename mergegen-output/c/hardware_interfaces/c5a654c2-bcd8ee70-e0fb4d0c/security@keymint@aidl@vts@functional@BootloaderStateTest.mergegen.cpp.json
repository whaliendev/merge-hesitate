[
    {
        "a_contents": "/*\n * Copyright (C) 2023 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#define LOG_TAG \"keymint_1_bootloader_test\"\n\n#include <memory>\n#include <optional>\n#include <string>\n#include <vector>\n\n#include <android-base/properties.h>\n#include <android/binder_manager.h>\n#include <fstab/fstab.h>\n#include <libavb/libavb.h>\n#include <libavb_user/avb_ops_user.h>\n#include <remote_prov/remote_prov_utils.h>\n\n#include \"KeyMintAidlTestBase.h\"\n\nnamespace aidl::android::hardware::security::keymint::test {\n\nusing ::android::getAidlHalInstanceNames;\nusing ::std::string;\nusing ::std::vector;\n\n// Since this test needs to talk to KeyMint HAL, it can only run as root. Thus,\n// bootloader can not be locked.\nclass BootloaderStateTest : public KeyMintAidlTestBase {\n  public:\n    virtual void SetUp() override {\n        KeyMintAidlTestBase::SetUp();\n\n        // Generate a key with attestation.\n        vector<uint8_t> key_blob;\n        vector<KeyCharacteristics> key_characteristics;\n        AuthorizationSet keyDesc = AuthorizationSetBuilder()\n                                           .Authorization(TAG_NO_AUTH_REQUIRED)\n                                           .EcdsaSigningKey(EcCurve::P_256)\n                                           .AttestationChallenge(\"foo\")\n                                           .AttestationApplicationId(\"bar\")\n                                           .Digest(Digest::NONE)\n                                           .SetDefaultValidity();\n        auto result = GenerateKey(keyDesc, &key_blob, &key_characteristics);\n        // If factory provisioned attestation key is not supported by Strongbox,\n        // then create a key with self-signed attestation and use it as the\n        // attestation key instead.\n        if (SecLevel() == SecurityLevel::STRONGBOX &&\n            result == ErrorCode::ATTESTATION_KEYS_NOT_PROVISIONED) {\n            result = GenerateKeyWithSelfSignedAttestKey(\n                    AuthorizationSetBuilder()\n                            .EcdsaKey(EcCurve::P_256)\n                            .AttestKey()\n                            .SetDefaultValidity(), /* attest key params */\n                    keyDesc, &key_blob, &key_characteristics);\n        }\n        ASSERT_EQ(ErrorCode::OK, result);\n\n        // Parse attested AVB values.\n        X509_Ptr cert(parse_cert_blob(cert_chain_[0].encodedCertificate));\n        ASSERT_TRUE(cert.get());\n\n        ASN1_OCTET_STRING* attest_rec = get_attestation_record(cert.get());\n        ASSERT_TRUE(attest_rec);\n\n        auto error = parse_root_of_trust(attest_rec->data, attest_rec->length, &attestedVbKey_,\n                                         &attestedVbState_, &attestedBootloaderState_,\n                                         &attestedVbmetaDigest_);\n        ASSERT_EQ(error, ErrorCode::OK);\n    }\n\n    vector<uint8_t> attestedVbKey_;\n    VerifiedBoot attestedVbState_;\n    bool attestedBootloaderState_;\n    vector<uint8_t> attestedVbmetaDigest_;\n};\n\n// Check that attested bootloader state is set to unlocked.\nTEST_P(BootloaderStateTest, BootloaderIsUnlocked) {\n    ASSERT_FALSE(attestedBootloaderState_)\n            << \"This test runs as root. Bootloader must be unlocked.\";\n}\n\n// Check that verified boot state is set to \"unverified\", i.e. \"orange\".\nTEST_P(BootloaderStateTest, VbStateIsUnverified) {\n    // Unlocked bootloader implies that verified boot state must be \"unverified\".\n    ASSERT_EQ(attestedVbState_, VerifiedBoot::UNVERIFIED)\n            << \"Verified boot state must be \\\"UNVERIFIED\\\" aka \\\"orange\\\".\";\n\n    // AVB spec stipulates that bootloader must set \"androidboot.verifiedbootstate\" parameter\n    // on the kernel command-line. This parameter is exposed to userspace as\n    // \"ro.boot.verifiedbootstate\" property.\n    auto vbStateProp = ::android::base::GetProperty(\"ro.boot.verifiedbootstate\", \"\");\n    ASSERT_EQ(vbStateProp, \"orange\")\n            << \"Verified boot state must be \\\"UNVERIFIED\\\" aka \\\"orange\\\".\";\n}\n\n// Following error codes from avb_slot_data() mean that slot data was loaded\n// (even if verification failed).\nstatic inline bool avb_slot_data_loaded(AvbSlotVerifyResult result) {\n    switch (result) {\n        case AVB_SLOT_VERIFY_RESULT_OK:\n        case AVB_SLOT_VERIFY_RESULT_ERROR_VERIFICATION:\n        case AVB_SLOT_VERIFY_RESULT_ERROR_ROLLBACK_INDEX:\n        case AVB_SLOT_VERIFY_RESULT_ERROR_PUBLIC_KEY_REJECTED:\n            return true;\n        default:\n            return false;\n    }\n}\n\n// Check that attested vbmeta digest is correct.\nTEST_P(BootloaderStateTest, VbmetaDigest) {\n    AvbSlotVerifyData* avbSlotData;\n    auto suffix = fs_mgr_get_slot_suffix();\n    const char* partitions[] = {nullptr};\n    auto avbOps = avb_ops_user_new();\n\n    // For VTS, devices run with vendor_boot-debug.img, which is not release key\n    // signed. Use AVB_SLOT_VERIFY_FLAGS_ALLOW_VERIFICATION_ERROR to bypass avb\n    // verification errors. This is OK since we only care about the digest for\n    // this test case.\n    auto result = avb_slot_verify(avbOps, partitions, suffix.c_str(),\n                                  AVB_SLOT_VERIFY_FLAGS_ALLOW_VERIFICATION_ERROR,\n                                  AVB_HASHTREE_ERROR_MODE_EIO, &avbSlotData);\n    ASSERT_TRUE(avb_slot_data_loaded(result)) << \"Failed to load avb slot data\";\n\n    // Unfortunately, bootloader is not required to report the algorithm used\n    // to calculate the digest. There are only two supported options though,\n    // SHA256 and SHA512. Attested VBMeta digest must match one of these.\n    vector<uint8_t> digest256(AVB_SHA256_DIGEST_SIZE);\n    vector<uint8_t> digest512(AVB_SHA512_DIGEST_SIZE);\n\n    avb_slot_verify_data_calculate_vbmeta_digest(avbSlotData, AVB_DIGEST_TYPE_SHA256,\n                                                 digest256.data());\n    avb_slot_verify_data_calculate_vbmeta_digest(avbSlotData, AVB_DIGEST_TYPE_SHA512,\n                                                 digest512.data());\n\n    ASSERT_TRUE((attestedVbmetaDigest_ == digest256) || (attestedVbmetaDigest_ == digest512))\n            << \"Attested digest does not match computed digest.\";\n}\n\nINSTANTIATE_KEYMINT_AIDL_TEST(BootloaderStateTest);\n\n}  // namespace aidl::android::hardware::security::keymint::test",
        "b_contents": "/*\n * Copyright (C) 2023 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#define LOG_TAG \"keymint_1_bootloader_test\"\n\n#include <memory>\n#include <optional>\n#include <string>\n#include <vector>\n\n#include <android-base/properties.h>\n#include <android/binder_manager.h>\n#include <fstab/fstab.h>\n#include <libavb/libavb.h>\n#include <libavb_user/avb_ops_user.h>\n#include <remote_prov/remote_prov_utils.h>\n\n#include \"KeyMintAidlTestBase.h\"\n\nnamespace aidl::android::hardware::security::keymint::test {\n\nusing ::android::getAidlHalInstanceNames;\nusing ::std::string;\nusing ::std::vector;\n\n// Since this test needs to talk to KeyMint HAL, it can only run as root. Thus,\n// bootloader can not be locked.\n// @CddTest = 9.10/C-0-2\nclass BootloaderStateTest : public KeyMintAidlTestBase {\n  public:\n    virtual void SetUp() override {\n        KeyMintAidlTestBase::SetUp();\n\n        // Generate a key with attestation.\n        vector<uint8_t> key_blob;\n        vector<KeyCharacteristics> key_characteristics;\n        AuthorizationSet keyDesc = AuthorizationSetBuilder()\n                                           .Authorization(TAG_NO_AUTH_REQUIRED)\n                                           .EcdsaSigningKey(EcCurve::P_256)\n                                           .AttestationChallenge(\"foo\")\n                                           .AttestationApplicationId(\"bar\")\n                                           .Digest(Digest::NONE)\n                                           .SetDefaultValidity();\n        auto result = GenerateKey(keyDesc, &key_blob, &key_characteristics);\n        // If factory provisioned attestation key is not supported by Strongbox,\n        // then create a key with self-signed attestation and use it as the\n        // attestation key instead.\n        if (SecLevel() == SecurityLevel::STRONGBOX &&\n            result == ErrorCode::ATTESTATION_KEYS_NOT_PROVISIONED) {\n            result = GenerateKeyWithSelfSignedAttestKey(\n                    AuthorizationSetBuilder()\n                            .EcdsaKey(EcCurve::P_256)\n                            .AttestKey()\n                            .SetDefaultValidity(), /* attest key params */\n                    keyDesc, &key_blob, &key_characteristics);\n        }\n        ASSERT_EQ(ErrorCode::OK, result);\n\n        // Parse attested AVB values.\n        X509_Ptr cert(parse_cert_blob(cert_chain_[0].encodedCertificate));\n        ASSERT_TRUE(cert.get());\n\n        ASN1_OCTET_STRING* attest_rec = get_attestation_record(cert.get());\n        ASSERT_TRUE(attest_rec);\n\n        auto error = parse_root_of_trust(attest_rec->data, attest_rec->length, &attestedVbKey_,\n                                         &attestedVbState_, &attestedBootloaderState_,\n                                         &attestedVbmetaDigest_);\n        ASSERT_EQ(error, ErrorCode::OK);\n    }\n\n    vector<uint8_t> attestedVbKey_;\n    VerifiedBoot attestedVbState_;\n    bool attestedBootloaderState_;\n    vector<uint8_t> attestedVbmetaDigest_;\n};\n\n// Check that attested bootloader state is set to unlocked.\nTEST_P(BootloaderStateTest, BootloaderIsUnlocked) {\n    ASSERT_FALSE(attestedBootloaderState_)\n            << \"This test runs as root. Bootloader must be unlocked.\";\n}\n\n// Check that verified boot state is set to \"unverified\", i.e. \"orange\".\nTEST_P(BootloaderStateTest, VbStateIsUnverified) {\n    // Unlocked bootloader implies that verified boot state must be \"unverified\".\n    ASSERT_EQ(attestedVbState_, VerifiedBoot::UNVERIFIED)\n            << \"Verified boot state must be \\\"UNVERIFIED\\\" aka \\\"orange\\\".\";\n\n    // AVB spec stipulates that bootloader must set \"androidboot.verifiedbootstate\" parameter\n    // on the kernel command-line. This parameter is exposed to userspace as\n    // \"ro.boot.verifiedbootstate\" property.\n    auto vbStateProp = ::android::base::GetProperty(\"ro.boot.verifiedbootstate\", \"\");\n    ASSERT_EQ(vbStateProp, \"orange\")\n            << \"Verified boot state must be \\\"UNVERIFIED\\\" aka \\\"orange\\\".\";\n}\n\n// Following error codes from avb_slot_data() mean that slot data was loaded\n// (even if verification failed).\nstatic inline bool avb_slot_data_loaded(AvbSlotVerifyResult result) {\n    switch (result) {\n        case AVB_SLOT_VERIFY_RESULT_OK:\n        case AVB_SLOT_VERIFY_RESULT_ERROR_VERIFICATION:\n        case AVB_SLOT_VERIFY_RESULT_ERROR_ROLLBACK_INDEX:\n        case AVB_SLOT_VERIFY_RESULT_ERROR_PUBLIC_KEY_REJECTED:\n            return true;\n        default:\n            return false;\n    }\n}\n\n// Check that attested vbmeta digest is correct.\nTEST_P(BootloaderStateTest, VbmetaDigest) {\n    AvbSlotVerifyData* avbSlotData;\n    auto suffix = fs_mgr_get_slot_suffix();\n    const char* partitions[] = {nullptr};\n    auto avbOps = avb_ops_user_new();\n\n    // For VTS, devices run with vendor_boot-debug.img, which is not release key\n    // signed. Use AVB_SLOT_VERIFY_FLAGS_ALLOW_VERIFICATION_ERROR to bypass avb\n    // verification errors. This is OK since we only care about the digest for\n    // this test case.\n    auto result = avb_slot_verify(avbOps, partitions, suffix.c_str(),\n                                  AVB_SLOT_VERIFY_FLAGS_ALLOW_VERIFICATION_ERROR,\n                                  AVB_HASHTREE_ERROR_MODE_EIO, &avbSlotData);\n    ASSERT_TRUE(avb_slot_data_loaded(result)) << \"Failed to load avb slot data\";\n\n    // Unfortunately, bootloader is not required to report the algorithm used\n    // to calculate the digest. There are only two supported options though,\n    // SHA256 and SHA512. Attested VBMeta digest must match one of these.\n    vector<uint8_t> digest256(AVB_SHA256_DIGEST_SIZE);\n    vector<uint8_t> digest512(AVB_SHA512_DIGEST_SIZE);\n\n    avb_slot_verify_data_calculate_vbmeta_digest(avbSlotData, AVB_DIGEST_TYPE_SHA256,\n                                                 digest256.data());\n    avb_slot_verify_data_calculate_vbmeta_digest(avbSlotData, AVB_DIGEST_TYPE_SHA512,\n                                                 digest512.data());\n\n    ASSERT_TRUE((attestedVbmetaDigest_ == digest256) || (attestedVbmetaDigest_ == digest512))\n            << \"Attested digest does not match computed digest.\";\n}\n\nINSTANTIATE_KEYMINT_AIDL_TEST(BootloaderStateTest);\n\n}  // namespace aidl::android::hardware::security::keymint::test",
        "base_contents": "",
        "res_region": "/*\n * Copyright (C) 2023 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#define LOG_TAG \"keymint_1_bootloader_test\"\n\n#include <memory>\n#include <optional>\n#include <string>\n#include <vector>\n\n#include <android-base/properties.h>\n#include <android/binder_manager.h>\n#include <fstab/fstab.h>\n#include <libavb/libavb.h>\n#include <libavb_user/avb_ops_user.h>\n#include <remote_prov/remote_prov_utils.h>\n\n#include \"KeyMintAidlTestBase.h\"\n\nnamespace aidl::android::hardware::security::keymint::test {\n\nusing ::android::getAidlHalInstanceNames;\nusing ::std::string;\nusing ::std::vector;\n\n// Since this test needs to talk to KeyMint HAL, it can only run as root. Thus,\n// bootloader can not be locked.\nclass BootloaderStateTest : public KeyMintAidlTestBase {\n  public:\n    virtual void SetUp() override {\n        KeyMintAidlTestBase::SetUp();\n\n        // Generate a key with attestation.\n        vector<uint8_t> key_blob;\n        vector<KeyCharacteristics> key_characteristics;\n        AuthorizationSet keyDesc = AuthorizationSetBuilder()\n                                           .Authorization(TAG_NO_AUTH_REQUIRED)\n                                           .EcdsaSigningKey(EcCurve::P_256)\n                                           .AttestationChallenge(\"foo\")\n                                           .AttestationApplicationId(\"bar\")\n                                           .Digest(Digest::NONE)\n                                           .SetDefaultValidity();\n        auto result = GenerateKey(keyDesc, &key_blob, &key_characteristics);\n        // If factory provisioned attestation key is not supported by Strongbox,\n        // then create a key with self-signed attestation and use it as the\n        // attestation key instead.\n        if (SecLevel() == SecurityLevel::STRONGBOX &&\n            result == ErrorCode::ATTESTATION_KEYS_NOT_PROVISIONED) {\n            result = GenerateKeyWithSelfSignedAttestKey(\n                    AuthorizationSetBuilder()\n                            .EcdsaKey(EcCurve::P_256)\n                            .AttestKey()\n                            .SetDefaultValidity(), /* attest key params */\n                    keyDesc, &key_blob, &key_characteristics);\n        }\n        ASSERT_EQ(ErrorCode::OK, result);\n\n        // Parse attested AVB values.\n        X509_Ptr cert(parse_cert_blob(cert_chain_[0].encodedCertificate));\n        ASSERT_TRUE(cert.get());\n\n        ASN1_OCTET_STRING* attest_rec = get_attestation_record(cert.get());\n        ASSERT_TRUE(attest_rec);\n\n        auto error = parse_root_of_trust(attest_rec->data, attest_rec->length, &attestedVbKey_,\n                                         &attestedVbState_, &attestedBootloaderState_,\n                                         &attestedVbmetaDigest_);\n        ASSERT_EQ(error, ErrorCode::OK);\n    }\n\n    vector<uint8_t> attestedVbKey_;\n    VerifiedBoot attestedVbState_;\n    bool attestedBootloaderState_;\n    vector<uint8_t> attestedVbmetaDigest_;\n};\n\n// Check that attested bootloader state is set to unlocked.\nTEST_P(BootloaderStateTest, BootloaderIsUnlocked) {\n    ASSERT_FALSE(attestedBootloaderState_)\n            << \"This test runs as root. Bootloader must be unlocked.\";\n}\n\n// Check that verified boot state is set to \"unverified\", i.e. \"orange\".\nTEST_P(BootloaderStateTest, VbStateIsUnverified) {\n    // Unlocked bootloader implies that verified boot state must be \"unverified\".\n    ASSERT_EQ(attestedVbState_, VerifiedBoot::UNVERIFIED)\n            << \"Verified boot state must be \\\"UNVERIFIED\\\" aka \\\"orange\\\".\";\n\n    // AVB spec stipulates that bootloader must set \"androidboot.verifiedbootstate\" parameter\n    // on the kernel command-line. This parameter is exposed to userspace as\n    // \"ro.boot.verifiedbootstate\" property.\n    auto vbStateProp = ::android::base::GetProperty(\"ro.boot.verifiedbootstate\", \"\");\n    ASSERT_EQ(vbStateProp, \"orange\")\n            << \"Verified boot state must be \\\"UNVERIFIED\\\" aka \\\"orange\\\".\";\n}\n\n// Following error codes from avb_slot_data() mean that slot data was loaded\n// (even if verification failed).\nstatic inline bool avb_slot_data_loaded(AvbSlotVerifyResult result) {\n    switch (result) {\n        case AVB_SLOT_VERIFY_RESULT_OK:\n        case AVB_SLOT_VERIFY_RESULT_ERROR_VERIFICATION:\n        case AVB_SLOT_VERIFY_RESULT_ERROR_ROLLBACK_INDEX:\n        case AVB_SLOT_VERIFY_RESULT_ERROR_PUBLIC_KEY_REJECTED:\n            return true;\n        default:\n            return false;\n    }\n}\n\n// Check that attested vbmeta digest is correct.\nTEST_P(BootloaderStateTest, VbmetaDigest) {\n    AvbSlotVerifyData* avbSlotData;\n    auto suffix = fs_mgr_get_slot_suffix();\n    const char* partitions[] = {nullptr};\n    auto avbOps = avb_ops_user_new();\n\n    // For VTS, devices run with vendor_boot-debug.img, which is not release key\n    // signed. Use AVB_SLOT_VERIFY_FLAGS_ALLOW_VERIFICATION_ERROR to bypass avb\n    // verification errors. This is OK since we only care about the digest for\n    // this test case.\n    auto result = avb_slot_verify(avbOps, partitions, suffix.c_str(),\n                                  AVB_SLOT_VERIFY_FLAGS_ALLOW_VERIFICATION_ERROR,\n                                  AVB_HASHTREE_ERROR_MODE_EIO, &avbSlotData);\n    ASSERT_TRUE(avb_slot_data_loaded(result)) << \"Failed to load avb slot data\";\n\n    // Unfortunately, bootloader is not required to report the algorithm used\n    // to calculate the digest. There are only two supported options though,\n    // SHA256 and SHA512. Attested VBMeta digest must match one of these.\n    vector<uint8_t> digest256(AVB_SHA256_DIGEST_SIZE);\n    vector<uint8_t> digest512(AVB_SHA512_DIGEST_SIZE);\n\n    avb_slot_verify_data_calculate_vbmeta_digest(avbSlotData, AVB_DIGEST_TYPE_SHA256,\n                                                 digest256.data());\n    avb_slot_verify_data_calculate_vbmeta_digest(avbSlotData, AVB_DIGEST_TYPE_SHA512,\n                                                 digest512.data());\n\n    ASSERT_TRUE((attestedVbmetaDigest_ == digest256) || (attestedVbmetaDigest_ == digest512))\n            << \"Attested digest does not match computed digest.\";\n}\n\nINSTANTIATE_KEYMINT_AIDL_TEST(BootloaderStateTest);\n\n}  // namespace aidl::android::hardware::security::keymint::test",
        "lookback": " * Copyright (C) 2023 The Android Open Source Project",
        "lookahead": "",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 0,
        "end_line": 318,
        "merge_gen_region": " CopyrightC 2 The Open Project * Licensed the Apache, 2. ( \"\"); you not this except in with License * may obtain copy the License * *://..///LICENSE20 * Unless by applicable or to writing software distributed the is on \" IS BASIS * WARRANTIES CONDITIONS ANY, express implied * the the for specific governing and limitations the License */define_ \"m____loadertest # <>includememory # <optional # <string # <vector # <androidbasepropertiesh # <androidbindermanagerh # <fst/fst.>includelibav/libav.>includelibav_//.>includelibav_buserav___.>includeremoteprovremoteprovutilsh # \"MAidlBase.\" a::::::::::::::::m:: { usingandroidgetidlHalNames usingstdstring usingstdvector // this needs talk Keyint HAL it only as., boot can be., BootState : KeyMAidlBase public virtual void() {MAidlBaseSetUp // a withte..<<<8 classloaderTest public KeyintATest { public virtual SetUp override KeyintATest::Up // a withte..<<8t key",
        "confidence": 0.9383471608161926,
        "hesitated": false,
        "resolved": false
    }
]