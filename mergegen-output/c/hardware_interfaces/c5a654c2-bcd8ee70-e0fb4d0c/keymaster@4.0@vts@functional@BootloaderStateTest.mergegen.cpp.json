[
    {
        "a_contents": "/*\n * Copyright (C) 2023 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <memory>\n#include <optional>\n#include <string>\n#include <vector>\n\n#include <android-base/properties.h>\n#include <fstab/fstab.h>\n#include <libavb/libavb.h>\n#include <libavb_user/avb_ops_user.h>\n\n#include \"KeymasterHidlTest.h\"\n\nnamespace android::hardware::keymaster::V4_0::test {\n\nusing ::std::string;\nusing ::std::vector;\n\n// Since this test needs to talk to Keymaster HAL, it can only run as root. Thus,\n// bootloader can not be locked.\nclass BootloaderStateTest : public KeymasterHidlTest {\n  public:\n    virtual void SetUp() override {\n        KeymasterHidlTest::SetUp();\n\n        // Generate a key.\n        auto ec = GenerateKey(AuthorizationSetBuilder()\n                                      .Authorization(TAG_NO_AUTH_REQUIRED)\n                                      .EcdsaSigningKey(EcCurve::P_256)\n                                      .Digest(Digest::SHA_2_256));\n        ASSERT_EQ(ec, ErrorCode::OK) << \"Failed to generate key.\";\n\n        // Generate attestation.\n        hidl_vec<hidl_vec<uint8_t>> cert_chain;\n        ec = AttestKey(AuthorizationSetBuilder()\n                               .Authorization(TAG_ATTESTATION_CHALLENGE, HidlBuf(\"challenge\"))\n                               .Authorization(TAG_ATTESTATION_APPLICATION_ID, HidlBuf(\"foo\")),\n                       &cert_chain);\n        ASSERT_EQ(ec, ErrorCode::OK) << \"Failed to generate attestation.\";\n\n        X509_Ptr cert(parse_cert_blob(cert_chain[0]));\n        ASSERT_TRUE(cert.get()) << \"Failed to parse certificate blob.\";\n\n        ASN1_OCTET_STRING* attest_rec = get_attestation_record(cert.get());\n        ASSERT_TRUE(attest_rec) << \"Failed to get attestation record.\";\n\n        // Parse root of trust.\n        auto result = parse_root_of_trust(attest_rec->data, attest_rec->length, &attestedVbKey_,\n                                          &attestedVbState_, &attestedBootloaderState_,\n                                          &attestedVbmetaDigest_);\n        ASSERT_EQ(result, ErrorCode::OK) << \"Failed to parse root of trust.\";\n    }\n\n    hidl_vec<uint8_t> attestedVbKey_;\n    keymaster_verified_boot_t attestedVbState_;\n    bool attestedBootloaderState_;\n    hidl_vec<uint8_t> attestedVbmetaDigest_;\n};\n\n// Check that attested bootloader state is set to unlocked.\nTEST_P(BootloaderStateTest, BootloaderIsUnlocked) {\n    ASSERT_FALSE(attestedBootloaderState_)\n            << \"This test runs as root. Bootloader must be unlocked.\";\n}\n\n// Check that verified boot state is set to \"unverified\", i.e. \"orange\".\nTEST_P(BootloaderStateTest, VbStateIsUnverified) {\n    // Unlocked bootloader implies that verified boot state must be \"unverified\".\n    ASSERT_EQ(attestedVbState_, KM_VERIFIED_BOOT_UNVERIFIED)\n            << \"Verified boot state must be \\\"UNVERIFIED\\\" aka \\\"orange\\\".\";\n\n    // AVB spec stipulates that bootloader must set \"androidboot.verifiedbootstate\" parameter\n    // on the kernel command-line. This parameter is exposed to userspace as\n    // \"ro.boot.verifiedbootstate\" property.\n    auto vbStateProp = ::android::base::GetProperty(\"ro.boot.verifiedbootstate\", \"\");\n    ASSERT_EQ(vbStateProp, \"orange\")\n            << \"Verified boot state must be \\\"UNVERIFIED\\\" aka \\\"orange\\\".\";\n}\n\n// Following error codes from avb_slot_data() mean that slot data was loaded\n// (even if verification failed).\nstatic inline bool avb_slot_data_loaded(AvbSlotVerifyResult result) {\n    switch (result) {\n        case AVB_SLOT_VERIFY_RESULT_OK:\n        case AVB_SLOT_VERIFY_RESULT_ERROR_VERIFICATION:\n        case AVB_SLOT_VERIFY_RESULT_ERROR_ROLLBACK_INDEX:\n        case AVB_SLOT_VERIFY_RESULT_ERROR_PUBLIC_KEY_REJECTED:\n            return true;\n        default:\n            return false;\n    }\n}\n\n// Check that attested vbmeta digest is correct.\nTEST_P(BootloaderStateTest, VbmetaDigest) {\n    AvbSlotVerifyData* avbSlotData;\n    auto suffix = fs_mgr_get_slot_suffix();\n    const char* partitions[] = {nullptr};\n    auto avbOps = avb_ops_user_new();\n\n    // For VTS, devices run with vendor_boot-debug.img, which is not release key\n    // signed. Use AVB_SLOT_VERIFY_FLAGS_ALLOW_VERIFICATION_ERROR to bypass avb\n    // verification errors. This is OK since we only care about the digest for\n    // this test case.\n    auto result = avb_slot_verify(avbOps, partitions, suffix.c_str(),\n                                  AVB_SLOT_VERIFY_FLAGS_ALLOW_VERIFICATION_ERROR,\n                                  AVB_HASHTREE_ERROR_MODE_EIO, &avbSlotData);\n    ASSERT_TRUE(avb_slot_data_loaded(result)) << \"Failed to load avb slot data\";\n\n    // Unfortunately, bootloader is not required to report the algorithm used\n    // to calculate the digest. There are only two supported options though,\n    // SHA256 and SHA512. Attested VBMeta digest must match one of these.\n    vector<uint8_t> digest256(AVB_SHA256_DIGEST_SIZE);\n    vector<uint8_t> digest512(AVB_SHA512_DIGEST_SIZE);\n\n    avb_slot_verify_data_calculate_vbmeta_digest(avbSlotData, AVB_DIGEST_TYPE_SHA256,\n                                                 digest256.data());\n    avb_slot_verify_data_calculate_vbmeta_digest(avbSlotData, AVB_DIGEST_TYPE_SHA512,\n                                                 digest512.data());\n\n    ASSERT_TRUE((attestedVbmetaDigest_ == digest256) || (attestedVbmetaDigest_ == digest512))\n            << \"Attested digest does not match computed digest.\";\n}\n\nINSTANTIATE_KEYMASTER_HIDL_TEST(BootloaderStateTest);\n\n}  // namespace android::hardware::keymaster::V4_0::test",
        "b_contents": "/*\n * Copyright (C) 2023 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <memory>\n#include <optional>\n#include <string>\n#include <vector>\n\n#include <android-base/properties.h>\n#include <fstab/fstab.h>\n#include <libavb/libavb.h>\n#include <libavb_user/avb_ops_user.h>\n\n#include \"KeymasterHidlTest.h\"\n\nnamespace android::hardware::keymaster::V4_0::test {\n\nusing ::std::string;\nusing ::std::vector;\n\n// Since this test needs to talk to Keymaster HAL, it can only run as root. Thus,\n// bootloader can not be locked.\n// @CddTest = 9.10/C-0-2\nclass BootloaderStateTest : public KeymasterHidlTest {\n  public:\n    virtual void SetUp() override {\n        KeymasterHidlTest::SetUp();\n\n        // Generate a key.\n        auto ec = GenerateKey(AuthorizationSetBuilder()\n                                      .Authorization(TAG_NO_AUTH_REQUIRED)\n                                      .EcdsaSigningKey(EcCurve::P_256)\n                                      .Digest(Digest::SHA_2_256));\n        ASSERT_EQ(ec, ErrorCode::OK) << \"Failed to generate key.\";\n\n        // Generate attestation.\n        hidl_vec<hidl_vec<uint8_t>> cert_chain;\n        ec = AttestKey(AuthorizationSetBuilder()\n                               .Authorization(TAG_ATTESTATION_CHALLENGE, HidlBuf(\"challenge\"))\n                               .Authorization(TAG_ATTESTATION_APPLICATION_ID, HidlBuf(\"foo\")),\n                       &cert_chain);\n        ASSERT_EQ(ec, ErrorCode::OK) << \"Failed to generate attestation.\";\n\n        X509_Ptr cert(parse_cert_blob(cert_chain[0]));\n        ASSERT_TRUE(cert.get()) << \"Failed to parse certificate blob.\";\n\n        ASN1_OCTET_STRING* attest_rec = get_attestation_record(cert.get());\n        ASSERT_TRUE(attest_rec) << \"Failed to get attestation record.\";\n\n        // Parse root of trust.\n        auto result = parse_root_of_trust(attest_rec->data, attest_rec->length, &attestedVbKey_,\n                                          &attestedVbState_, &attestedBootloaderState_,\n                                          &attestedVbmetaDigest_);\n        ASSERT_EQ(result, ErrorCode::OK) << \"Failed to parse root of trust.\";\n    }\n\n    hidl_vec<uint8_t> attestedVbKey_;\n    keymaster_verified_boot_t attestedVbState_;\n    bool attestedBootloaderState_;\n    hidl_vec<uint8_t> attestedVbmetaDigest_;\n};\n\n// Check that attested bootloader state is set to unlocked.\nTEST_P(BootloaderStateTest, BootloaderIsUnlocked) {\n    ASSERT_FALSE(attestedBootloaderState_)\n            << \"This test runs as root. Bootloader must be unlocked.\";\n}\n\n// Check that verified boot state is set to \"unverified\", i.e. \"orange\".\nTEST_P(BootloaderStateTest, VbStateIsUnverified) {\n    // Unlocked bootloader implies that verified boot state must be \"unverified\".\n    ASSERT_EQ(attestedVbState_, KM_VERIFIED_BOOT_UNVERIFIED)\n            << \"Verified boot state must be \\\"UNVERIFIED\\\" aka \\\"orange\\\".\";\n\n    // AVB spec stipulates that bootloader must set \"androidboot.verifiedbootstate\" parameter\n    // on the kernel command-line. This parameter is exposed to userspace as\n    // \"ro.boot.verifiedbootstate\" property.\n    auto vbStateProp = ::android::base::GetProperty(\"ro.boot.verifiedbootstate\", \"\");\n    ASSERT_EQ(vbStateProp, \"orange\")\n            << \"Verified boot state must be \\\"UNVERIFIED\\\" aka \\\"orange\\\".\";\n}\n\n// Following error codes from avb_slot_data() mean that slot data was loaded\n// (even if verification failed).\nstatic inline bool avb_slot_data_loaded(AvbSlotVerifyResult result) {\n    switch (result) {\n        case AVB_SLOT_VERIFY_RESULT_OK:\n        case AVB_SLOT_VERIFY_RESULT_ERROR_VERIFICATION:\n        case AVB_SLOT_VERIFY_RESULT_ERROR_ROLLBACK_INDEX:\n        case AVB_SLOT_VERIFY_RESULT_ERROR_PUBLIC_KEY_REJECTED:\n            return true;\n        default:\n            return false;\n    }\n}\n\n// Check that attested vbmeta digest is correct.\nTEST_P(BootloaderStateTest, VbmetaDigest) {\n    AvbSlotVerifyData* avbSlotData;\n    auto suffix = fs_mgr_get_slot_suffix();\n    const char* partitions[] = {nullptr};\n    auto avbOps = avb_ops_user_new();\n\n    // For VTS, devices run with vendor_boot-debug.img, which is not release key\n    // signed. Use AVB_SLOT_VERIFY_FLAGS_ALLOW_VERIFICATION_ERROR to bypass avb\n    // verification errors. This is OK since we only care about the digest for\n    // this test case.\n    auto result = avb_slot_verify(avbOps, partitions, suffix.c_str(),\n                                  AVB_SLOT_VERIFY_FLAGS_ALLOW_VERIFICATION_ERROR,\n                                  AVB_HASHTREE_ERROR_MODE_EIO, &avbSlotData);\n    ASSERT_TRUE(avb_slot_data_loaded(result)) << \"Failed to load avb slot data\";\n\n    // Unfortunately, bootloader is not required to report the algorithm used\n    // to calculate the digest. There are only two supported options though,\n    // SHA256 and SHA512. Attested VBMeta digest must match one of these.\n    vector<uint8_t> digest256(AVB_SHA256_DIGEST_SIZE);\n    vector<uint8_t> digest512(AVB_SHA512_DIGEST_SIZE);\n\n    avb_slot_verify_data_calculate_vbmeta_digest(avbSlotData, AVB_DIGEST_TYPE_SHA256,\n                                                 digest256.data());\n    avb_slot_verify_data_calculate_vbmeta_digest(avbSlotData, AVB_DIGEST_TYPE_SHA512,\n                                                 digest512.data());\n\n    ASSERT_TRUE((attestedVbmetaDigest_ == digest256) || (attestedVbmetaDigest_ == digest512))\n            << \"Attested digest does not match computed digest.\";\n}\n\nINSTANTIATE_KEYMASTER_HIDL_TEST(BootloaderStateTest);\n\n}  // namespace android::hardware::keymaster::V4_0::test",
        "base_contents": "",
        "res_region": "/*\n * Copyright (C) 2023 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <memory>\n#include <optional>\n#include <string>\n#include <vector>\n\n#include <android-base/properties.h>\n#include <fstab/fstab.h>\n#include <libavb/libavb.h>\n#include <libavb_user/avb_ops_user.h>\n\n#include \"KeymasterHidlTest.h\"\n\nnamespace android::hardware::keymaster::V4_0::test {\n\nusing ::std::string;\nusing ::std::vector;\n\n// Since this test needs to talk to Keymaster HAL, it can only run as root. Thus,\n// bootloader can not be locked.\nclass BootloaderStateTest : public KeymasterHidlTest {\n  public:\n    virtual void SetUp() override {\n        KeymasterHidlTest::SetUp();\n\n        // Generate a key.\n        auto ec = GenerateKey(AuthorizationSetBuilder()\n                                      .Authorization(TAG_NO_AUTH_REQUIRED)\n                                      .EcdsaSigningKey(EcCurve::P_256)\n                                      .Digest(Digest::SHA_2_256));\n        ASSERT_EQ(ec, ErrorCode::OK) << \"Failed to generate key.\";\n\n        // Generate attestation.\n        hidl_vec<hidl_vec<uint8_t>> cert_chain;\n        ec = AttestKey(AuthorizationSetBuilder()\n                               .Authorization(TAG_ATTESTATION_CHALLENGE, HidlBuf(\"challenge\"))\n                               .Authorization(TAG_ATTESTATION_APPLICATION_ID, HidlBuf(\"foo\")),\n                       &cert_chain);\n        ASSERT_EQ(ec, ErrorCode::OK) << \"Failed to generate attestation.\";\n\n        X509_Ptr cert(parse_cert_blob(cert_chain[0]));\n        ASSERT_TRUE(cert.get()) << \"Failed to parse certificate blob.\";\n\n        ASN1_OCTET_STRING* attest_rec = get_attestation_record(cert.get());\n        ASSERT_TRUE(attest_rec) << \"Failed to get attestation record.\";\n\n        // Parse root of trust.\n        auto result = parse_root_of_trust(attest_rec->data, attest_rec->length, &attestedVbKey_,\n                                          &attestedVbState_, &attestedBootloaderState_,\n                                          &attestedVbmetaDigest_);\n        ASSERT_EQ(result, ErrorCode::OK) << \"Failed to parse root of trust.\";\n    }\n\n    hidl_vec<uint8_t> attestedVbKey_;\n    keymaster_verified_boot_t attestedVbState_;\n    bool attestedBootloaderState_;\n    hidl_vec<uint8_t> attestedVbmetaDigest_;\n};\n\n// Check that attested bootloader state is set to unlocked.\nTEST_P(BootloaderStateTest, BootloaderIsUnlocked) {\n    ASSERT_FALSE(attestedBootloaderState_)\n            << \"This test runs as root. Bootloader must be unlocked.\";\n}\n\n// Check that verified boot state is set to \"unverified\", i.e. \"orange\".\nTEST_P(BootloaderStateTest, VbStateIsUnverified) {\n    // Unlocked bootloader implies that verified boot state must be \"unverified\".\n    ASSERT_EQ(attestedVbState_, KM_VERIFIED_BOOT_UNVERIFIED)\n            << \"Verified boot state must be \\\"UNVERIFIED\\\" aka \\\"orange\\\".\";\n\n    // AVB spec stipulates that bootloader must set \"androidboot.verifiedbootstate\" parameter\n    // on the kernel command-line. This parameter is exposed to userspace as\n    // \"ro.boot.verifiedbootstate\" property.\n    auto vbStateProp = ::android::base::GetProperty(\"ro.boot.verifiedbootstate\", \"\");\n    ASSERT_EQ(vbStateProp, \"orange\")\n            << \"Verified boot state must be \\\"UNVERIFIED\\\" aka \\\"orange\\\".\";\n}\n\n// Following error codes from avb_slot_data() mean that slot data was loaded\n// (even if verification failed).\nstatic inline bool avb_slot_data_loaded(AvbSlotVerifyResult result) {\n    switch (result) {\n        case AVB_SLOT_VERIFY_RESULT_OK:\n        case AVB_SLOT_VERIFY_RESULT_ERROR_VERIFICATION:\n        case AVB_SLOT_VERIFY_RESULT_ERROR_ROLLBACK_INDEX:\n        case AVB_SLOT_VERIFY_RESULT_ERROR_PUBLIC_KEY_REJECTED:\n            return true;\n        default:\n            return false;\n    }\n}\n\n// Check that attested vbmeta digest is correct.\nTEST_P(BootloaderStateTest, VbmetaDigest) {\n    AvbSlotVerifyData* avbSlotData;\n    auto suffix = fs_mgr_get_slot_suffix();\n    const char* partitions[] = {nullptr};\n    auto avbOps = avb_ops_user_new();\n\n    // For VTS, devices run with vendor_boot-debug.img, which is not release key\n    // signed. Use AVB_SLOT_VERIFY_FLAGS_ALLOW_VERIFICATION_ERROR to bypass avb\n    // verification errors. This is OK since we only care about the digest for\n    // this test case.\n    auto result = avb_slot_verify(avbOps, partitions, suffix.c_str(),\n                                  AVB_SLOT_VERIFY_FLAGS_ALLOW_VERIFICATION_ERROR,\n                                  AVB_HASHTREE_ERROR_MODE_EIO, &avbSlotData);\n    ASSERT_TRUE(avb_slot_data_loaded(result)) << \"Failed to load avb slot data\";\n\n    // Unfortunately, bootloader is not required to report the algorithm used\n    // to calculate the digest. There are only two supported options though,\n    // SHA256 and SHA512. Attested VBMeta digest must match one of these.\n    vector<uint8_t> digest256(AVB_SHA256_DIGEST_SIZE);\n    vector<uint8_t> digest512(AVB_SHA512_DIGEST_SIZE);\n\n    avb_slot_verify_data_calculate_vbmeta_digest(avbSlotData, AVB_DIGEST_TYPE_SHA256,\n                                                 digest256.data());\n    avb_slot_verify_data_calculate_vbmeta_digest(avbSlotData, AVB_DIGEST_TYPE_SHA512,\n                                                 digest512.data());\n\n    ASSERT_TRUE((attestedVbmetaDigest_ == digest256) || (attestedVbmetaDigest_ == digest512))\n            << \"Attested digest does not match computed digest.\";\n}\n\nINSTANTIATE_KEYMASTER_HIDL_TEST(BootloaderStateTest);\n\n}  // namespace android::hardware::keymaster::V4_0::test",
        "lookback": " * Copyright (C) 2023 The Android Open Source Project",
        "lookahead": "",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 0,
        "end_line": 288,
        "merge_gen_region": " CopyrightC 2 The Open Project * Licensed the Apache, 2. ( \"\"); you not this except in with License * may obtain copy the License * *://..///LICENSE20 * Unless by applicable or to writing software distributed the is on \" IS BASIS * WARRANTIES CONDITIONS ANY, express implied * the the for specific governing and limitations the License */includememory # <>includeoptional # <string # <vector # <androidbasepropertiesh # <fst/fst.>includelibav/libav.>includelibav_/av____.>includeKeyHidl.\" androidhardwarekey::masterV_masterV_::::40test usingstdstring usingstdvector // this needs talk Key HAL, can it only as., boot can be. classloaderState : Keymasteridl {: void() {masteridl::Set(); Generate key key auto =KeyAuthorSet()Author(izationBuilder .izationTAGNOAUTHREQUIRED .Esaning(cCurveP256 .((::___));__(,CodeOK <<Failed generate.\"; Generatetestation hid_<lvechid_<8t certchain ec AtKeyAuthorSetBuilder .izationTAGATSTATIONCHEN,idl(\"\"))",
        "confidence": 0.9434366226196289,
        "hesitated": false,
        "resolved": false
    }
]