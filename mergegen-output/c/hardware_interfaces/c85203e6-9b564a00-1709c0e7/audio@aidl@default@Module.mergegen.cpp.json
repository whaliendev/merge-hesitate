[
    {
        "a_contents": "void Module::updateStreamsConnectedState(const AudioPatch& oldPatch, const AudioPatch& newPatch) {\n    // Streams from the old patch need to be disconnected, streams from the new\n    // patch need to be connected. If the stream belongs to both patches, no need\n    // to update it.\n    std::set<int32_t> idsToDisconnect, idsToConnect;\n    idsToDisconnect.insert(oldPatch.sourcePortConfigIds.begin(),\n                           oldPatch.sourcePortConfigIds.end());\n    idsToDisconnect.insert(oldPatch.sinkPortConfigIds.begin(), oldPatch.sinkPortConfigIds.end());\n    idsToConnect.insert(newPatch.sourcePortConfigIds.begin(), newPatch.sourcePortConfigIds.end());\n    idsToConnect.insert(newPatch.sinkPortConfigIds.begin(), newPatch.sinkPortConfigIds.end());\n    std::for_each(idsToDisconnect.begin(), idsToDisconnect.end(), [&](const auto& portConfigId) {\n        if (idsToConnect.count(portConfigId) == 0) {\n            mStreams.setStreamIsConnected(portConfigId, false);\n        }\n    });\n    std::for_each(idsToConnect.begin(), idsToConnect.end(), [&](const auto& portConfigId) {\n        if (idsToDisconnect.count(portConfigId) == 0) {\n            mStreams.setStreamIsConnected(portConfigId, true);\n        }\n    });\n}\n\nndk::ScopedAStatus Module::setModuleDebug(\n        const ::aidl::android::hardware::audio::core::ModuleDebug& in_debug) {\n    LOG(DEBUG) << __func__ << \": old flags:\" << mDebug.toString()\n               << \", new flags: \" << in_debug.toString();\n    if (mDebug.simulateDeviceConnections != in_debug.simulateDeviceConnections &&\n        !mConnectedDevicePorts.empty()) {\n        LOG(ERROR) << __func__ << \": attempting to change device connections simulation \"\n                   << \"while having external devices connected\";\n        return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_STATE);\n    }\n    mDebug = in_debug;\n    return ndk::ScopedAStatus::ok();\n}\n\nndk::ScopedAStatus Module::connectExternalDevice(const AudioPort& in_templateIdAndAdditionalData,\n                                                 AudioPort* _aidl_return) {\n    const int32_t templateId = in_templateIdAndAdditionalData.id;\n    auto& ports = getConfig().ports;\n    AudioPort connectedPort;\n    {  // Scope the template port so that we don't accidentally modify it.\n        auto templateIt = findById<AudioPort>(ports, templateId);\n        if (templateIt == ports.end()) {\n            LOG(ERROR) << __func__ << \": port id \" << templateId << \" not found\";\n            return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);\n        }\n        if (templateIt->ext.getTag() != AudioPortExt::Tag::device) {\n            LOG(ERROR) << __func__ << \": port id \" << templateId << \" is not a device port\";\n            return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);\n        }\n        if (!templateIt->profiles.empty()) {\n            LOG(ERROR) << __func__ << \": port id \" << templateId\n                       << \" does not have dynamic profiles\";\n            return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);\n        }\n        auto& templateDevicePort = templateIt->ext.get<AudioPortExt::Tag::device>();\n        if (templateDevicePort.device.type.connection.empty()) {\n            LOG(ERROR) << __func__ << \": port id \" << templateId << \" is permanently attached\";\n            return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);\n        }\n        // Postpone id allocation until we ensure that there are no client errors.\n        connectedPort = *templateIt;\n        connectedPort.extraAudioDescriptors = in_templateIdAndAdditionalData.extraAudioDescriptors;\n        const auto& inputDevicePort =\n                in_templateIdAndAdditionalData.ext.get<AudioPortExt::Tag::device>();\n        auto& connectedDevicePort = connectedPort.ext.get<AudioPortExt::Tag::device>();\n        connectedDevicePort.device.address = inputDevicePort.device.address;\n        LOG(DEBUG) << __func__ << \": device port \" << connectedPort.id << \" device set to \"\n                   << connectedDevicePort.device.toString();\n        // Check if there is already a connected port with for the same external device.\n        for (auto connectedPortId : mConnectedDevicePorts) {\n            auto connectedPortIt = findById<AudioPort>(ports, connectedPortId);\n            if (connectedPortIt->ext.get<AudioPortExt::Tag::device>().device ==\n                connectedDevicePort.device) {\n                LOG(ERROR) << __func__ << \": device \" << connectedDevicePort.device.toString()\n                           << \" is already connected at the device port id \" << connectedPortId;\n                return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_STATE);\n            }\n        }\n    }\n\n    if (!mDebug.simulateDeviceConnections) {\n        // In a real HAL here we would attempt querying the profiles from the device.\n        LOG(ERROR) << __func__ << \": failed to query supported device profiles\";\n        return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_STATE);\n    }\n\n    connectedPort.id = ++getConfig().nextPortId;\n    mConnectedDevicePorts.insert(connectedPort.id);\n    LOG(DEBUG) << __func__ << \": template port \" << templateId << \" external device connected, \"\n               << \"connected port ID \" << connectedPort.id;\n    auto& connectedProfiles = getConfig().connectedProfiles;\n    if (auto connectedProfilesIt = connectedProfiles.find(templateId);\n        connectedProfilesIt != connectedProfiles.end()) {\n        connectedPort.profiles = connectedProfilesIt->second;\n    }\n    ports.push_back(connectedPort);\n    *_aidl_return = std::move(connectedPort);\n\n    std::vector<AudioRoute> newRoutes;\n    auto& routes = getConfig().routes;\n    for (auto& r : routes) {\n        if (r.sinkPortId == templateId) {\n            AudioRoute newRoute;\n            newRoute.sourcePortIds = r.sourcePortIds;\n            newRoute.sinkPortId = connectedPort.id;\n            newRoute.isExclusive = r.isExclusive;\n            newRoutes.push_back(std::move(newRoute));\n        } else {\n            auto& srcs = r.sourcePortIds;\n            if (std::find(srcs.begin(), srcs.end(), templateId) != srcs.end()) {\n                srcs.push_back(connectedPort.id);\n            }\n        }\n    }\n    routes.insert(routes.end(), newRoutes.begin(), newRoutes.end());\n\n    return ndk::ScopedAStatus::ok();\n}\n\nndk::ScopedAStatus Module::disconnectExternalDevice(int32_t in_portId) {\n    auto& ports = getConfig().ports;\n    auto portIt = findById<AudioPort>(ports, in_portId);\n    if (portIt == ports.end()) {\n        LOG(ERROR) << __func__ << \": port id \" << in_portId << \" not found\";\n        return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);\n    }\n    if (portIt->ext.getTag() != AudioPortExt::Tag::device) {\n        LOG(ERROR) << __func__ << \": port id \" << in_portId << \" is not a device port\";\n        return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);\n    }\n    if (mConnectedDevicePorts.count(in_portId) == 0) {\n        LOG(ERROR) << __func__ << \": port id \" << in_portId << \" is not a connected device port\";\n        return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);\n    }\n    auto& configs = getConfig().portConfigs;\n    auto& initials = getConfig().initialConfigs;\n    auto configIt = std::find_if(configs.begin(), configs.end(), [&](const auto& config) {\n        if (config.portId == in_portId) {\n            // Check if the configuration was provided by the client.\n            const auto& initialIt = findById<AudioPortConfig>(initials, config.id);\n            return initialIt == initials.end() || config != *initialIt;\n        }\n        return false;\n    });\n    if (configIt != configs.end()) {\n        LOG(ERROR) << __func__ << \": port id \" << in_portId << \" has a non-default config with id \"\n                   << configIt->id;\n        return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_STATE);\n    }\n    ports.erase(portIt);\n    mConnectedDevicePorts.erase(in_portId);\n    LOG(DEBUG) << __func__ << \": connected device port \" << in_portId << \" released\";\n\n    auto& routes = getConfig().routes;\n    for (auto routesIt = routes.begin(); routesIt != routes.end();) {\n        if (routesIt->sinkPortId == in_portId) {\n            routesIt = routes.erase(routesIt);\n        } else {\n            // Note: the list of sourcePortIds can't become empty because there must\n            // be the id of the template port in the route.\n            erase_if(routesIt->sourcePortIds, [in_portId](auto src) { return src == in_portId; });\n            ++routesIt;\n        }\n    }\n\n    return ndk::ScopedAStatus::ok();\n}\n",
        "b_contents": "ndk::ScopedAStatus Module::setModuleDebug(\n        const ::aidl::android::hardware::audio::core::ModuleDebug& in_debug) {\n    LOG(DEBUG) << __func__ << \": old flags:\" << mDebug.toString()\n               << \", new flags: \" << in_debug.toString();\n    if (mDebug.simulateDeviceConnections != in_debug.simulateDeviceConnections &&\n        !mConnectedDevicePorts.empty()) {\n        LOG(ERROR) << __func__ << \": attempting to change device connections simulation \"\n                   << \"while having external devices connected\";\n        return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_STATE);\n    }\n    mDebug = in_debug;\n    return ndk::ScopedAStatus::ok();\n}\n\nndk::ScopedAStatus Module::connectExternalDevice(const AudioPort& in_templateIdAndAdditionalData,\n                                                 AudioPort* _aidl_return) {\n    const int32_t templateId = in_templateIdAndAdditionalData.id;\n    auto& ports = getConfig().ports;\n    AudioPort connectedPort;\n    {  // Scope the template port so that we don't accidentally modify it.\n        auto templateIt = findById<AudioPort>(ports, templateId);\n        if (templateIt == ports.end()) {\n            LOG(ERROR) << __func__ << \": port id \" << templateId << \" not found\";\n            return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);\n        }\n        if (templateIt->ext.getTag() != AudioPortExt::Tag::device) {\n            LOG(ERROR) << __func__ << \": port id \" << templateId << \" is not a device port\";\n            return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);\n        }\n        if (!templateIt->profiles.empty()) {\n            LOG(ERROR) << __func__ << \": port id \" << templateId\n                       << \" does not have dynamic profiles\";\n            return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);\n        }\n        auto& templateDevicePort = templateIt->ext.get<AudioPortExt::Tag::device>();\n        if (templateDevicePort.device.type.connection.empty()) {\n            LOG(ERROR) << __func__ << \": port id \" << templateId << \" is permanently attached\";\n            return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);\n        }\n        // Postpone id allocation until we ensure that there are no client errors.\n        connectedPort = *templateIt;\n        connectedPort.extraAudioDescriptors = in_templateIdAndAdditionalData.extraAudioDescriptors;\n        const auto& inputDevicePort =\n                in_templateIdAndAdditionalData.ext.get<AudioPortExt::Tag::device>();\n        auto& connectedDevicePort = connectedPort.ext.get<AudioPortExt::Tag::device>();\n        connectedDevicePort.device.address = inputDevicePort.device.address;\n        LOG(DEBUG) << __func__ << \": device port \" << connectedPort.id << \" device set to \"\n                   << connectedDevicePort.device.toString();\n        // Check if there is already a connected port with for the same external device.\n        for (auto connectedPortId : mConnectedDevicePorts) {\n            auto connectedPortIt = findById<AudioPort>(ports, connectedPortId);\n            if (connectedPortIt->ext.get<AudioPortExt::Tag::device>().device ==\n                connectedDevicePort.device) {\n                LOG(ERROR) << __func__ << \": device \" << connectedDevicePort.device.toString()\n                           << \" is already connected at the device port id \" << connectedPortId;\n                return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_STATE);\n            }\n        }\n    }\n\n    if (!mDebug.simulateDeviceConnections) {\n        // In a real HAL here we would attempt querying the profiles from the device.\n        LOG(ERROR) << __func__ << \": failed to query supported device profiles\";\n        return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_STATE);\n    }\n\n    connectedPort.id = ++getConfig().nextPortId;\n    mConnectedDevicePorts.insert(connectedPort.id);\n    LOG(DEBUG) << __func__ << \": template port \" << templateId << \" external device connected, \"\n               << \"connected port ID \" << connectedPort.id;\n    auto& connectedProfiles = getConfig().connectedProfiles;\n    if (auto connectedProfilesIt = connectedProfiles.find(templateId);\n        connectedProfilesIt != connectedProfiles.end()) {\n        connectedPort.profiles = connectedProfilesIt->second;\n    }\n    ports.push_back(connectedPort);\n    *_aidl_return = std::move(connectedPort);\n\n    std::vector<AudioRoute> newRoutes;\n    auto& routes = getConfig().routes;\n    for (auto& r : routes) {\n        if (r.sinkPortId == templateId) {\n            AudioRoute newRoute;\n            newRoute.sourcePortIds = r.sourcePortIds;\n            newRoute.sinkPortId = connectedPort.id;\n            newRoute.isExclusive = r.isExclusive;\n            newRoutes.push_back(std::move(newRoute));\n        } else {\n            auto& srcs = r.sourcePortIds;\n            if (std::find(srcs.begin(), srcs.end(), templateId) != srcs.end()) {\n                srcs.push_back(connectedPort.id);\n            }\n        }\n    }\n    routes.insert(routes.end(), newRoutes.begin(), newRoutes.end());\n\n    return ndk::ScopedAStatus::ok();\n}\n\nndk::ScopedAStatus Module::disconnectExternalDevice(int32_t in_portId) {\n    auto& ports = getConfig().ports;\n    auto portIt = findById<AudioPort>(ports, in_portId);\n    if (portIt == ports.end()) {\n        LOG(ERROR) << __func__ << \": port id \" << in_portId << \" not found\";\n        return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);\n    }\n    if (portIt->ext.getTag() != AudioPortExt::Tag::device) {\n        LOG(ERROR) << __func__ << \": port id \" << in_portId << \" is not a device port\";\n        return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);\n    }\n    if (mConnectedDevicePorts.count(in_portId) == 0) {\n        LOG(ERROR) << __func__ << \": port id \" << in_portId << \" is not a connected device port\";\n        return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);\n    }\n    auto& configs = getConfig().portConfigs;\n    auto& initials = getConfig().initialConfigs;\n    auto configIt = std::find_if(configs.begin(), configs.end(), [&](const auto& config) {\n        if (config.portId == in_portId) {\n            // Check if the configuration was provided by the client.\n            const auto& initialIt = findById<AudioPortConfig>(initials, config.id);\n            return initialIt == initials.end() || config != *initialIt;\n        }\n        return false;\n    });\n    if (configIt != configs.end()) {\n        LOG(ERROR) << __func__ << \": port id \" << in_portId << \" has a non-default config with id \"\n                   << configIt->id;\n        return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_STATE);\n    }\n    ports.erase(portIt);\n    mConnectedDevicePorts.erase(in_portId);\n    LOG(DEBUG) << __func__ << \": connected device port \" << in_portId << \" released\";\n\n    auto& routes = getConfig().routes;\n    for (auto routesIt = routes.begin(); routesIt != routes.end();) {\n        if (routesIt->sinkPortId == in_portId) {\n            routesIt = routes.erase(routesIt);\n        } else {\n            // Note: the list of sourcePortIds can't become empty because there must\n            // be the id of the template port in the route.\n            erase_if(routesIt->sourcePortIds, [in_portId](auto src) { return src == in_portId; });\n            ++routesIt;\n        }\n    }\n\n    return ndk::ScopedAStatus::ok();\n}\n",
        "base_contents": "",
        "res_region": "void Module::updateStreamsConnectedState(const AudioPatch& oldPatch, const AudioPatch& newPatch) {\n    // Streams from the old patch need to be disconnected, streams from the new\n    // patch need to be connected. If the stream belongs to both patches, no need\n    // to update it.\n    std::set<int32_t> idsToDisconnect, idsToConnect;\n    idsToDisconnect.insert(oldPatch.sourcePortConfigIds.begin(),\n                           oldPatch.sourcePortConfigIds.end());\n    idsToDisconnect.insert(oldPatch.sinkPortConfigIds.begin(), oldPatch.sinkPortConfigIds.end());\n    idsToConnect.insert(newPatch.sourcePortConfigIds.begin(), newPatch.sourcePortConfigIds.end());\n    idsToConnect.insert(newPatch.sinkPortConfigIds.begin(), newPatch.sinkPortConfigIds.end());\n    std::for_each(idsToDisconnect.begin(), idsToDisconnect.end(), [&](const auto& portConfigId) {\n        if (idsToConnect.count(portConfigId) == 0) {\n            mStreams.setStreamIsConnected(portConfigId, false);\n        }\n    });\n    std::for_each(idsToConnect.begin(), idsToConnect.end(), [&](const auto& portConfigId) {\n        if (idsToDisconnect.count(portConfigId) == 0) {\n            mStreams.setStreamIsConnected(portConfigId, true);\n        }\n    });\n}\n\nndk::ScopedAStatus Module::setModuleDebug(\n        const ::aidl::android::hardware::audio::core::ModuleDebug& in_debug) {\n    LOG(DEBUG) << __func__ << \": old flags:\" << mDebug.toString()\n               << \", new flags: \" << in_debug.toString();\n    if (mDebug.simulateDeviceConnections != in_debug.simulateDeviceConnections &&\n        !mConnectedDevicePorts.empty()) {\n        LOG(ERROR) << __func__ << \": attempting to change device connections simulation \"\n                   << \"while having external devices connected\";\n        return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_STATE);\n    }\n    mDebug = in_debug;\n    return ndk::ScopedAStatus::ok();\n}\n\nndk::ScopedAStatus Module::connectExternalDevice(const AudioPort& in_templateIdAndAdditionalData,\n                                                 AudioPort* _aidl_return) {\n    const int32_t templateId = in_templateIdAndAdditionalData.id;\n    auto& ports = getConfig().ports;\n    AudioPort connectedPort;\n    {  // Scope the template port so that we don't accidentally modify it.\n        auto templateIt = findById<AudioPort>(ports, templateId);\n        if (templateIt == ports.end()) {\n            LOG(ERROR) << __func__ << \": port id \" << templateId << \" not found\";\n            return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);\n        }\n        if (templateIt->ext.getTag() != AudioPortExt::Tag::device) {\n            LOG(ERROR) << __func__ << \": port id \" << templateId << \" is not a device port\";\n            return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);\n        }\n        if (!templateIt->profiles.empty()) {\n            LOG(ERROR) << __func__ << \": port id \" << templateId\n                       << \" does not have dynamic profiles\";\n            return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);\n        }\n        auto& templateDevicePort = templateIt->ext.get<AudioPortExt::Tag::device>();\n        if (templateDevicePort.device.type.connection.empty()) {\n            LOG(ERROR) << __func__ << \": port id \" << templateId << \" is permanently attached\";\n            return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);\n        }\n        // Postpone id allocation until we ensure that there are no client errors.\n        connectedPort = *templateIt;\n        connectedPort.extraAudioDescriptors = in_templateIdAndAdditionalData.extraAudioDescriptors;\n        const auto& inputDevicePort =\n                in_templateIdAndAdditionalData.ext.get<AudioPortExt::Tag::device>();\n        auto& connectedDevicePort = connectedPort.ext.get<AudioPortExt::Tag::device>();\n        connectedDevicePort.device.address = inputDevicePort.device.address;\n        LOG(DEBUG) << __func__ << \": device port \" << connectedPort.id << \" device set to \"\n                   << connectedDevicePort.device.toString();\n        // Check if there is already a connected port with for the same external device.\n        for (auto connectedPortId : mConnectedDevicePorts) {\n            auto connectedPortIt = findById<AudioPort>(ports, connectedPortId);\n            if (connectedPortIt->ext.get<AudioPortExt::Tag::device>().device ==\n                connectedDevicePort.device) {\n                LOG(ERROR) << __func__ << \": device \" << connectedDevicePort.device.toString()\n                           << \" is already connected at the device port id \" << connectedPortId;\n                return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_STATE);\n            }\n        }\n    }\n\n    if (!mDebug.simulateDeviceConnections) {\n        // In a real HAL here we would attempt querying the profiles from the device.\n        LOG(ERROR) << __func__ << \": failed to query supported device profiles\";\n        return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_STATE);\n    }\n\n    connectedPort.id = ++getConfig().nextPortId;\n    mConnectedDevicePorts.insert(connectedPort.id);\n    LOG(DEBUG) << __func__ << \": template port \" << templateId << \" external device connected, \"\n               << \"connected port ID \" << connectedPort.id;\n    auto& connectedProfiles = getConfig().connectedProfiles;\n    if (auto connectedProfilesIt = connectedProfiles.find(templateId);\n        connectedProfilesIt != connectedProfiles.end()) {\n        connectedPort.profiles = connectedProfilesIt->second;\n    }\n    ports.push_back(connectedPort);\n    *_aidl_return = std::move(connectedPort);\n\n    std::vector<AudioRoute> newRoutes;\n    auto& routes = getConfig().routes;\n    for (auto& r : routes) {\n        if (r.sinkPortId == templateId) {\n            AudioRoute newRoute;\n            newRoute.sourcePortIds = r.sourcePortIds;\n            newRoute.sinkPortId = connectedPort.id;\n            newRoute.isExclusive = r.isExclusive;\n            newRoutes.push_back(std::move(newRoute));\n        } else {\n            auto& srcs = r.sourcePortIds;\n            if (std::find(srcs.begin(), srcs.end(), templateId) != srcs.end()) {\n                srcs.push_back(connectedPort.id);\n            }\n        }\n    }\n    routes.insert(routes.end(), newRoutes.begin(), newRoutes.end());\n\n    return ndk::ScopedAStatus::ok();\n}\n\nndk::ScopedAStatus Module::disconnectExternalDevice(int32_t in_portId) {\n    auto& ports = getConfig().ports;\n    auto portIt = findById<AudioPort>(ports, in_portId);\n    if (portIt == ports.end()) {\n        LOG(ERROR) << __func__ << \": port id \" << in_portId << \" not found\";\n        return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);\n    }\n    if (portIt->ext.getTag() != AudioPortExt::Tag::device) {\n        LOG(ERROR) << __func__ << \": port id \" << in_portId << \" is not a device port\";\n        return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);\n    }\n    if (mConnectedDevicePorts.count(in_portId) == 0) {\n        LOG(ERROR) << __func__ << \": port id \" << in_portId << \" is not a connected device port\";\n        return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);\n    }\n    auto& configs = getConfig().portConfigs;\n    auto& initials = getConfig().initialConfigs;\n    auto configIt = std::find_if(configs.begin(), configs.end(), [&](const auto& config) {\n        if (config.portId == in_portId) {\n            // Check if the configuration was provided by the client.\n            const auto& initialIt = findById<AudioPortConfig>(initials, config.id);\n            return initialIt == initials.end() || config != *initialIt;\n        }\n        return false;\n    });\n    if (configIt != configs.end()) {\n        LOG(ERROR) << __func__ << \": port id \" << in_portId << \" has a non-default config with id \"\n                   << configIt->id;\n        return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_STATE);\n    }\n    ports.erase(portIt);\n    mConnectedDevicePorts.erase(in_portId);\n    LOG(DEBUG) << __func__ << \": connected device port \" << in_portId << \" released\";\n\n    auto& routes = getConfig().routes;\n    for (auto routesIt = routes.begin(); routesIt != routes.end();) {\n        if (routesIt->sinkPortId == in_portId) {\n            routesIt = routes.erase(routesIt);\n        } else {\n            // Note: the list of sourcePortIds can't become empty because there must\n            // be the id of the template port in the route.\n            erase_if(routesIt->sourcePortIds, [in_portId](auto src) { return src == in_portId; });\n            ++routesIt;\n        }\n    }\n\n    return ndk::ScopedAStatus::ok();\n}\n",
        "lookback": "    // Streams from the old patch need to be disconnected, streams from the new",
        "lookahead": "ndk::ScopedAStatus Module::getAudioPatches(std::vector<AudioPatch>* _aidl_return) {",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 210,
        "end_line": 531,
        "merge_gen_region": " Stream from old need be disconnected streams the new Module::StreamsStateconstPatch old, Audio&Patch { Stream from old need be disconnected streams the new patch to connected If stream to pat, no // to it stdsetint_> idsDisconnect idsConnectConnect idsDisconnectinsertold.PortConfig.(),PatchsourceConfig.PatchsourceConfig.()); idsDisconnectinsertold.PortConfig.(),PatchsourceConfig.()); idsConnectinsertnew.PortConfig.(),PatchsourceConfig.()); idsConnectinsertnewPatchsinkConfig..(), new.PortConfig.()); idsConnectinsertnewPatchsinkConfig..(), new.sinkConfig.()); stdforeachidsDisconnectbegin idsDisconnectbegin idsDisconnectend [&]( auto portId { ifidsConnectcountportId ==) m.StreamConnectedportId false } stdforeachidsConnectbegin idsConnectConnectConnectend [&]( auto portId { (idsDisconnectcountportId ==) mStreamssetIs(portId true } } }dkScopedStatus::Module( ::landroidhardwareaudiocoreModule&_debug {() ____ \": old:\" m.() << new: <<_..(); (DebugsimDevice !=_.ulateConnections !ConnectedPortsempty {() <<func << attempting change connections",
        "confidence": 0.9333804249763489,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "ndk::ScopedAStatus Module::getAudioRoutesForAudioPort(int32_t in_portId,\n                                                      std::vector<AudioRoute>* _aidl_return) {",
        "b_contents": "ndk::ScopedAStatus Module::getAudioRoutesForAudioPort(int32_t in_portId,\n                                                      std::vector<AudioRoute>* _aidl_return) {\n    auto& ports = getConfig().ports;\n    if (auto portIt = findById<AudioPort>(ports, in_portId); portIt == ports.end()) {\n        LOG(ERROR) << __func__ << \": port id \" << in_portId << \" not found\";\n        return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);\n    }\n    auto& routes = getConfig().routes;\n    std::copy_if(routes.begin(), routes.end(), std::back_inserter(*_aidl_return),\n                 [&](const auto& r) {\n                     const auto& srcs = r.sourcePortIds;\n                     return r.sinkPortId == in_portId ||\n                            std::find(srcs.begin(), srcs.end(), in_portId) != srcs.end();\n                 });\n    return ndk::ScopedAStatus::ok();\n}\n\nndk::ScopedAStatus Module::openInputStream(int32_t in_portConfigId,\n                                           const SinkMetadata& in_sinkMetadata,\n                                           std::shared_ptr<IStreamIn>* _aidl_return) {\n    auto& configs = getConfig().portConfigs;\n    auto portConfigIt = findById<AudioPortConfig>(configs, in_portConfigId);\n    if (portConfigIt == configs.end()) {\n        LOG(ERROR) << __func__ << \": existing port config id \" << in_portConfigId << \" not found\";\n        return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);\n    }\n    const int32_t portId = portConfigIt->portId;\n    // In our implementation, configs of mix ports always have unique IDs.\n    CHECK(portId != in_portConfigId);",
        "base_contents": "ndk::ScopedAStatus Module::openInputStream(int32_t in_portConfigId,\n                                           const SinkMetadata& in_sinkMetadata,\n                                           std::shared_ptr<IStreamIn>* _aidl_return) {\n    auto& configs = getConfig().portConfigs;\n    auto portConfigIt = findById<AudioPortConfig>(configs, in_portConfigId);\n    if (portConfigIt == configs.end()) {\n        LOG(ERROR) << __func__ << \": existing port config id \" << in_portConfigId << \" not found\";\n        return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);\n    }\n    const int32_t portId = portConfigIt->portId;\n    // In our implementation, configs of mix ports always have unique IDs.\n    CHECK(portId != in_portConfigId);",
        "res_region": "ndk::ScopedAStatus Module::getAudioRoutesForAudioPort(int32_t in_portId,\n                                                      std::vector<AudioRoute>* _aidl_return) {",
        "lookback": "                                                      std::vector<AudioRoute>* _aidl_return) {",
        "lookahead": "    auto& ports = getConfig().ports;",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 568,
        "end_line": 614,
        "merge_gen_region": "kScopedA ModulegetRoutoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutput % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %",
        "confidence": 0.9176480174064636,
        "hesitated": false,
        "resolved": false
    }
]