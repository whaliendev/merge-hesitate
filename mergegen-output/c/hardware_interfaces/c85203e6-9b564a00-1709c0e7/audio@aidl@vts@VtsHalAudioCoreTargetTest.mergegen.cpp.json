[
    {
        "a_contents": "#define LOG_TAG \"VtsHalAudioCore\"\n#include <android-base/logging.h>\n\n#include <StreamWorker.h>",
        "b_contents": "#define LOG_TAG \"VtsHalAudioCore\"\n#include <android-base/logging.h>\n",
        "base_contents": "",
        "res_region": "#define LOG_TAG \"VtsHalAudioCore\"\n#include <android-base/logging.h>\n\n#include <StreamWorker.h>",
        "lookback": "#include <android-base/logging.h>",
        "lookahead": "#include <aidl/Gtest.h>",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 24,
        "end_line": 34,
        "merge_gen_region": "####",
        "confidence": 0.9159210920333862,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "using aidl::android::hardware::audio::common::PlaybackTrackMetadata;\nusing aidl::android::hardware::audio::common::RecordTrackMetadata;\nusing aidl::android::hardware::audio::common::SinkMetadata;\nusing aidl::android::hardware::audio::common::SourceMetadata;\nusing aidl::android::hardware::audio::core::AudioPatch;\nusing aidl::android::hardware::audio::core::AudioRoute;\nusing aidl::android::hardware::audio::core::IModule;\nusing aidl::android::hardware::audio::core::IStreamIn;\nusing aidl::android::hardware::audio::core::IStreamOut;\nusing aidl::android::hardware::audio::core::ModuleDebug;\nusing aidl::android::hardware::audio::core::StreamDescriptor;\nusing aidl::android::hardware::common::fmq::SynchronizedReadWrite;\nusing aidl::android::media::audio::common::AudioContentType;\nusing aidl::android::media::audio::common::AudioDevice;\nusing aidl::android::media::audio::common::AudioDeviceAddress;\nusing aidl::android::media::audio::common::AudioDeviceType;\nusing aidl::android::media::audio::common::AudioFormatType;\nusing aidl::android::media::audio::common::AudioIoFlags;\nusing aidl::android::media::audio::common::AudioOutputFlags;\nusing aidl::android::media::audio::common::AudioPort;\nusing aidl::android::media::audio::common::AudioPortConfig;\nusing aidl::android::media::audio::common::AudioPortDeviceExt;\nusing aidl::android::media::audio::common::AudioPortExt;\nusing aidl::android::media::audio::common::AudioSource;\nusing aidl::android::media::audio::common::AudioUsage;\nusing android::hardware::audio::common::StreamLogic;\nusing android::hardware::audio::common::StreamWorker;\nusing ndk::ScopedAStatus;\n\nnamespace ndk {\nstd::ostream& operator<<(std::ostream& str, const ScopedAStatus& status) {\n    str << status.getDescription();\n    return str;\n}\n}  // namespace ndk",
        "b_contents": "using android::binder::Status;\nusing android::hardware::audio::common::PlaybackTrackMetadata;\nusing android::hardware::audio::common::RecordTrackMetadata;\nusing android::hardware::audio::common::SinkMetadata;\nusing android::hardware::audio::common::SourceMetadata;\nusing android::hardware::audio::core::AudioPatch;\nusing android::hardware::audio::core::AudioRoute;\nusing android::hardware::audio::core::IModule;\nusing android::hardware::audio::core::IStreamIn;\nusing android::hardware::audio::core::IStreamOut;\nusing android::hardware::audio::core::ModuleDebug;\nusing android::media::audio::common::AudioContentType;\nusing android::media::audio::common::AudioDevice;\nusing android::media::audio::common::AudioDeviceAddress;\nusing android::media::audio::common::AudioDeviceType;\nusing android::media::audio::common::AudioFormatType;\nusing android::media::audio::common::AudioIoFlags;\nusing android::media::audio::common::AudioOutputFlags;\nusing android::media::audio::common::AudioPort;\nusing android::media::audio::common::AudioPortConfig;\nusing android::media::audio::common::AudioPortDeviceExt;\nusing android::media::audio::common::AudioPortExt;\nusing android::media::audio::common::AudioSource;\nusing android::media::audio::common::AudioUsage;",
        "base_contents": "using android::binder::Status;\nusing android::hardware::audio::common::PlaybackTrackMetadata;\nusing android::hardware::audio::common::RecordTrackMetadata;\nusing android::hardware::audio::common::SinkMetadata;\nusing android::hardware::audio::common::SourceMetadata;\nusing android::hardware::audio::core::AudioPatch;\nusing android::hardware::audio::core::AudioRoute;\nusing android::hardware::audio::core::IModule;\nusing android::hardware::audio::core::IStreamIn;\nusing android::hardware::audio::core::IStreamOut;\nusing android::media::audio::common::AudioContentType;\nusing android::media::audio::common::AudioDevice;\nusing android::media::audio::common::AudioDeviceType;\nusing android::media::audio::common::AudioIoFlags;\nusing android::media::audio::common::AudioOutputFlags;\nusing android::media::audio::common::AudioPort;\nusing android::media::audio::common::AudioPortConfig;\nusing android::media::audio::common::AudioPortDeviceExt;\nusing android::media::audio::common::AudioPortExt;\nusing android::media::audio::common::AudioSource;\nusing android::media::audio::common::AudioUsage;",
        "res_region": "using aidl::android::hardware::audio::common::PlaybackTrackMetadata;\nusing aidl::android::hardware::audio::common::RecordTrackMetadata;\nusing aidl::android::hardware::audio::common::SinkMetadata;\nusing aidl::android::hardware::audio::common::SourceMetadata;\nusing aidl::android::hardware::audio::core::AudioPatch;\nusing aidl::android::hardware::audio::core::AudioRoute;\nusing aidl::android::hardware::audio::core::IModule;\nusing aidl::android::hardware::audio::core::IStreamIn;\nusing aidl::android::hardware::audio::core::IStreamOut;\nusing aidl::android::hardware::audio::core::ModuleDebug;\nusing aidl::android::hardware::audio::core::StreamDescriptor;\nusing aidl::android::hardware::common::fmq::SynchronizedReadWrite;\nusing aidl::android::media::audio::common::AudioContentType;\nusing aidl::android::media::audio::common::AudioDevice;\nusing aidl::android::media::audio::common::AudioDeviceAddress;\nusing aidl::android::media::audio::common::AudioDeviceType;\nusing aidl::android::media::audio::common::AudioFormatType;\nusing aidl::android::media::audio::common::AudioIoFlags;\nusing aidl::android::media::audio::common::AudioOutputFlags;\nusing aidl::android::media::audio::common::AudioPort;\nusing aidl::android::media::audio::common::AudioPortConfig;\nusing aidl::android::media::audio::common::AudioPortDeviceExt;\nusing aidl::android::media::audio::common::AudioPortExt;\nusing aidl::android::media::audio::common::AudioSource;\nusing aidl::android::media::audio::common::AudioUsage;\nusing android::hardware::audio::common::StreamLogic;\nusing android::hardware::audio::common::StreamWorker;\nusing ndk::ScopedAStatus;\n\nnamespace ndk {\nstd::ostream& operator<<(std::ostream& str, const ScopedAStatus& status) {\n    str << status.getDescription();\n    return str;\n}\n}  // namespace ndk",
        "lookback": "using aidl::android::hardware::audio::common::RecordTrackMetadata;",
        "lookahead": "",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 48,
        "end_line": 131,
        "merge_gen_region": " a::::::::::Metadatausing a::::::::::::Track;usingidlandroidhardwareaudiocommonPlaybackMetadata usingidlandroidhardwareaudiocommonRecordMetadata usingidlandroidhardwareaudiocommon::Metadata usingidlandroidhardwareaudiocommonSink; a::::::hardwareaudiocommonSource; a::::::::::::::::Patch usingidlandroidhardwareaudiocoreAudio;Route usingidlandroidhardwareaudiocoreIMule usingidlandroidhardwareaudiocoreISIn usingidlandroidhardwareaudiocoreISOut usingidlandroidhardwareaudiocoreModule; a::::::::::::::::::odule usingidlandroidhardwareaudiocoreISIn usingidlandroidhardwareaudiocoreISOut usingidlandroidhardwareaudiocoreModule; a::::::::::::::::::::::::::::::::::::::::::Debug usingidlandroidhardwareaudiocoreStream; a::::::::qSynized; aidlandroidhardwareaudiocoreModule; androidmediaaudiocommonAudio; a::::::::::::::::::Address usingidlandroidmediaaudiocommonAudioDevice; androidmediaaudiocommonAudioDevice; a::::::::::Address using::::::::DeviceType usingidlandroidmediaaudiocommonAudioType usingidlandroidmediaaudiocommonAudioType using::",
        "confidence": 0.8956750631332397,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "AudioDeviceAddress GenerateUniqueDeviceAddress() {\n    static int nextId = 1;\n    // TODO: Use connection-specific ID.\n    return AudioDeviceAddress::make<AudioDeviceAddress::Tag::id>(std::to_string(++nextId));\n}",
        "b_contents": "AudioDeviceAddress GenerateUniqueDeviceAddress() {\n    static int nextId = 1;\n    // TODO: Use connection-specific ID.\n    return AudioDeviceAddress::make<AudioDeviceAddress::Tag::id>(std::to_string(++nextId));\n}\n\nstruct AidlDeathRecipient : IBinder::DeathRecipient {\n    std::mutex mutex;\n    std::condition_variable condition;\n    bool fired = false;\n    wp<IBinder> who;\n\n    void binderDied(const wp<IBinder>& who) override {\n        std::unique_lock<std::mutex> lock(mutex);\n        fired = true;\n        this->who = who;\n        condition.notify_one();\n    };\n\n    bool waitForFired(int timeoutMs) {\n        std::unique_lock<std::mutex> lock(mutex);\n        condition.wait_for(lock, std::chrono::milliseconds(timeoutMs), [this]() { return fired; });\n        return fired;\n    }\n};",
        "base_contents": "struct AidlDeathRecipient : IBinder::DeathRecipient {\n    std::mutex mutex;\n    std::condition_variable condition;\n    bool fired = false;\n    wp<IBinder> who;\n\n    void binderDied(const wp<IBinder>& who) override {\n        std::unique_lock<std::mutex> lock(mutex);\n        fired = true;\n        this->who = who;\n        condition.notify_one();\n    };\n\n    bool waitForFired(int timeoutMs) {\n        std::unique_lock<std::mutex> lock(mutex);\n        condition.wait_for(lock, std::chrono::milliseconds(timeoutMs), [this]() { return fired; });\n        return fired;\n    }\n};",
        "res_region": "AudioDeviceAddress GenerateUniqueDeviceAddress() {\n    static int nextId = 1;\n    // TODO: Use connection-specific ID.\n    return AudioDeviceAddress::make<AudioDeviceAddress::Tag::id>(std::to_string(++nextId));\n}",
        "lookback": "    static int nextId = 1;",
        "lookahead": "",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 149,
        "end_line": 201,
        "merge_gen_region": null,
        "confidence": 0.8294345140457153,
        "hesitated": true
    },
    {
        "a_contents": "// All 'With*' classes are move-only because they are associated with some\n// resource or state of a HAL module.\nclass WithDebugFlags {\n  public:\n    static WithDebugFlags createNested(const WithDebugFlags& parent) {\n        return WithDebugFlags(parent.mFlags);\n    }\n\n    WithDebugFlags() {}\n    explicit WithDebugFlags(const ModuleDebug& initial) : mInitial(initial), mFlags(initial) {}\n    WithDebugFlags(const WithDebugFlags&) = delete;\n    WithDebugFlags& operator=(const WithDebugFlags&) = delete;\n    ~WithDebugFlags() {\n        if (mModule != nullptr) {\n            ScopedAStatus status = mModule->setModuleDebug(mInitial);\n            EXPECT_EQ(EX_NONE, status.getExceptionCode()) << status;\n        }\n    }\n    void SetUp(IModule* module) {\n        ScopedAStatus status = module->setModuleDebug(mFlags);\n        ASSERT_EQ(EX_NONE, status.getExceptionCode()) << status;\n    }\n    ModuleDebug& flags() { return mFlags; }\n\n  private:\n    ModuleDebug mInitial;\n    ModuleDebug mFlags;\n    IModule* mModule = nullptr;\n};\n\n// For consistency, WithAudioPortConfig can start both with a non-existent\n// port config, and with an existing one. Existence is determined by the\n// id of the provided config. If it's not 0, then WithAudioPortConfig is\n// essentially a no-op wrapper.\nclass WithAudioPortConfig {\n  public:\n    WithAudioPortConfig() {}\n    explicit WithAudioPortConfig(const AudioPortConfig& config) : mInitialConfig(config) {}\n    WithAudioPortConfig(const WithAudioPortConfig&) = delete;\n    WithAudioPortConfig& operator=(const WithAudioPortConfig&) = delete;\n    ~WithAudioPortConfig() {\n        if (mModule != nullptr) {\n            ScopedAStatus status = mModule->resetAudioPortConfig(getId());\n            EXPECT_EQ(EX_NONE, status.getExceptionCode())\n                    << status << \"; port config id \" << getId();\n        }\n    }\n    void SetUp(IModule* module) {\n        ASSERT_NE(AudioPortExt::Tag::unspecified, mInitialConfig.ext.getTag())\n                << \"config: \" << mInitialConfig.toString();\n        // Negotiation is allowed for device ports because the HAL module is\n        // allowed to provide an empty profiles list for attached devices.\n        ASSERT_NO_FATAL_FAILURE(\n                SetUpImpl(module, mInitialConfig.ext.getTag() == AudioPortExt::Tag::device));\n    }\n    int32_t getId() const { return mConfig.id; }\n    const AudioPortConfig& get() const { return mConfig; }\n\n  private:\n    void SetUpImpl(IModule* module, bool negotiate) {\n        if (mInitialConfig.id == 0) {\n            AudioPortConfig suggested;\n            bool applied = false;\n            ScopedAStatus status = module->setAudioPortConfig(mInitialConfig, &suggested, &applied);\n            ASSERT_EQ(EX_NONE, status.getExceptionCode())\n                    << status << \"; Config: \" << mInitialConfig.toString();\n            if (!applied && negotiate) {\n                mInitialConfig = suggested;\n                ASSERT_NO_FATAL_FAILURE(SetUpImpl(module, false))\n                        << \" while applying suggested config: \" << suggested.toString();\n            } else {\n                ASSERT_TRUE(applied) << \"Suggested: \" << suggested.toString();\n                mConfig = suggested;\n                mModule = module;\n            }\n        } else {\n            mConfig = mInitialConfig;\n        }\n    }\n\n    AudioPortConfig mInitialConfig;\n    IModule* mModule = nullptr;\n    AudioPortConfig mConfig;\n};\n",
        "b_contents": "class WithDebugFlags {\n  public:\n    WithDebugFlags() {}\n    explicit WithDebugFlags(const ModuleDebug& initial) : mInitial(initial), mFlags(initial) {}\n    explicit WithDebugFlags(const WithDebugFlags& initial)\n        : mInitial(initial.mFlags), mFlags(initial.mFlags) {}\n    ~WithDebugFlags() {\n        if (mModule != nullptr) {\n            Status status = mModule->setModuleDebug(mInitial);\n            EXPECT_EQ(Status::EX_NONE, status.exceptionCode()) << status;\n        }\n    }\n    void SetUp(IModule* module) {\n        Status status = module->setModuleDebug(mFlags);\n        ASSERT_EQ(Status::EX_NONE, status.exceptionCode()) << status;\n    }\n    ModuleDebug& flags() { return mFlags; }\n\n  private:\n    ModuleDebug mInitial;\n    ModuleDebug mFlags;\n    IModule* mModule = nullptr;\n};\n\n// For consistency, WithAudioPortConfig can start both with a non-existent\n// port config, and with an existing one. Existence is determined by the\n// id of the provided config. If it's not 0, then WithAudioPortConfig is\n// essentially a no-op wrapper.\nclass WithAudioPortConfig {\n  public:\n    WithAudioPortConfig() {}\n    explicit WithAudioPortConfig(const AudioPortConfig& config) : mInitialConfig(config) {}\n    ~WithAudioPortConfig() {\n        if (mModule != nullptr) {\n            Status status = mModule->resetAudioPortConfig(getId());\n            EXPECT_EQ(Status::EX_NONE, status.exceptionCode())\n                    << status << \"; port config id \" << getId();\n        }\n    }\n    void SetUp(IModule* module) {\n        ASSERT_NE(AudioPortExt::Tag::unspecified, mInitialConfig.ext.getTag())\n                << \"config: \" << mInitialConfig.toString();\n        // Negotiation is allowed for device ports because the HAL module is\n        // allowed to provide an empty profiles list for attached devices.\n        ASSERT_NO_FATAL_FAILURE(\n                SetUpImpl(module, mInitialConfig.ext.getTag() == AudioPortExt::Tag::device));\n    }\n    int32_t getId() const { return mConfig.id; }\n    const AudioPortConfig& get() const { return mConfig; }\n\n  private:\n    void SetUpImpl(IModule* module, bool negotiate) {\n        if (mInitialConfig.id == 0) {\n            AudioPortConfig suggested;\n            bool applied = false;\n            Status status = module->setAudioPortConfig(mInitialConfig, &suggested, &applied);\n            ASSERT_EQ(Status::EX_NONE, status.exceptionCode())\n                    << status << \"; Config: \" << mInitialConfig.toString();\n            if (!applied && negotiate) {\n                mInitialConfig = suggested;\n                ASSERT_NO_FATAL_FAILURE(SetUpImpl(module, false))\n                        << \" while applying suggested config: \" << suggested.toString();\n            } else {\n                ASSERT_TRUE(applied) << \"Suggested: \" << suggested.toString();\n                mConfig = suggested;\n                mModule = module;\n            }\n        } else {\n            mConfig = mInitialConfig;\n        }\n    }\n\n    AudioPortConfig mInitialConfig;\n    IModule* mModule = nullptr;\n    AudioPortConfig mConfig;\n};\n",
        "base_contents": "",
        "res_region": "// All 'With*' classes are move-only because they are associated with some\n// resource or state of a HAL module.\nclass WithDebugFlags {\n  public:\n    static WithDebugFlags createNested(const WithDebugFlags& parent) {\n        return WithDebugFlags(parent.mFlags);\n    }\n\n    WithDebugFlags() {}\n    explicit WithDebugFlags(const ModuleDebug& initial) : mInitial(initial), mFlags(initial) {}\n    WithDebugFlags(const WithDebugFlags&) = delete;\n    WithDebugFlags& operator=(const WithDebugFlags&) = delete;\n    ~WithDebugFlags() {\n        if (mModule != nullptr) {\n            ScopedAStatus status = mModule->setModuleDebug(mInitial);\n            EXPECT_EQ(EX_NONE, status.getExceptionCode()) << status;\n        }\n    }\n    void SetUp(IModule* module) {\n        ScopedAStatus status = module->setModuleDebug(mFlags);\n        ASSERT_EQ(EX_NONE, status.getExceptionCode()) << status;\n    }\n    ModuleDebug& flags() { return mFlags; }\n\n  private:\n    ModuleDebug mInitial;\n    ModuleDebug mFlags;\n    IModule* mModule = nullptr;\n};\n\n// For consistency, WithAudioPortConfig can start both with a non-existent\n// port config, and with an existing one. Existence is determined by the\n// id of the provided config. If it's not 0, then WithAudioPortConfig is\n// essentially a no-op wrapper.\nclass WithAudioPortConfig {\n  public:\n    WithAudioPortConfig() {}\n    explicit WithAudioPortConfig(const AudioPortConfig& config) : mInitialConfig(config) {}\n    WithAudioPortConfig(const WithAudioPortConfig&) = delete;\n    WithAudioPortConfig& operator=(const WithAudioPortConfig&) = delete;\n    ~WithAudioPortConfig() {\n        if (mModule != nullptr) {\n            ScopedAStatus status = mModule->resetAudioPortConfig(getId());\n            EXPECT_EQ(EX_NONE, status.getExceptionCode())\n                    << status << \"; port config id \" << getId();\n        }\n    }\n    void SetUp(IModule* module) {\n        ASSERT_NE(AudioPortExt::Tag::unspecified, mInitialConfig.ext.getTag())\n                << \"config: \" << mInitialConfig.toString();\n        // Negotiation is allowed for device ports because the HAL module is\n        // allowed to provide an empty profiles list for attached devices.\n        ASSERT_NO_FATAL_FAILURE(\n                SetUpImpl(module, mInitialConfig.ext.getTag() == AudioPortExt::Tag::device));\n    }\n    int32_t getId() const { return mConfig.id; }\n    const AudioPortConfig& get() const { return mConfig; }\n\n  private:\n    void SetUpImpl(IModule* module, bool negotiate) {\n        if (mInitialConfig.id == 0) {\n            AudioPortConfig suggested;\n            bool applied = false;\n            ScopedAStatus status = module->setAudioPortConfig(mInitialConfig, &suggested, &applied);\n            ASSERT_EQ(EX_NONE, status.getExceptionCode())\n                    << status << \"; Config: \" << mInitialConfig.toString();\n            if (!applied && negotiate) {\n                mInitialConfig = suggested;\n                ASSERT_NO_FATAL_FAILURE(SetUpImpl(module, false))\n                        << \" while applying suggested config: \" << suggested.toString();\n            } else {\n                ASSERT_TRUE(applied) << \"Suggested: \" << suggested.toString();\n                mConfig = suggested;\n                mModule = module;\n            }\n        } else {\n            mConfig = mInitialConfig;\n        }\n    }\n\n    AudioPortConfig mInitialConfig;\n    IModule* mModule = nullptr;\n    AudioPortConfig mConfig;\n};\n",
        "lookback": "// resource or state of a HAL module.",
        "lookahead": "class AudioCoreModule : public testing::TestWithParam<std::string> {",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 217,
        "end_line": 382,
        "merge_gen_region": " AllWith' classes moveonly they associated some resource state a HAL. WithFlags public staticDebug create( WithFlags parent { WithFlagsparentm); WithFlags {} WithFlagsconstDebug&) m(), m() WithFlagsconstDebugFlags =; WithFlags operatorconstDebugFlags =; ~DebugFlags { (m !=) ScopedStatus =Module->ModuleDebugm);__(__,.Exception()) <<; } void(od*) ScopedStatus =ModulesetDebugm);__(_NONE statusgetCode()) status } } SetUpIMule module {A status =->ModuleDebugm);_EQEXNONE statusgetCode <<; } void(odule module { ScopedStatus =->ModuleDebugm);__(_,.Exception()) <<; } void(odule module {A status =->Module(Flags ASSERTEQEXNONE statusgetCode <<; Module&() return m; }: Module m; I*Module =; }; For,AudioConfig start with nonexistent port,, with existing.ist is by // of provided. it not, WithPort is esially noop. WithPort { public WithPort() explicitAudioConfigconstPort&) mConfigconfig {}AudioConfigconstAudio",
        "confidence": 0.9228430986404419,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "    // The default buffer size is used mostly for negative tests.\n    static constexpr int kDefaultBufferSizeFrames = 256;\n\n    void SetUp() override {\n        ASSERT_NO_FATAL_FAILURE(ConnectToService());\n        debug.flags().simulateDeviceConnections = true;\n        ASSERT_NO_FATAL_FAILURE(debug.SetUp(module.get()));\n    }\n\n    void TearDown() override {\n        if (module != nullptr) {\n            ScopedAStatus status = module->setModuleDebug(ModuleDebug{});\n            EXPECT_EQ(EX_NONE, status.getExceptionCode())\n                    << status << \" returned when resetting debug flags\";\n        }\n    }",
        "b_contents": "    void SetUp() override {\n        ASSERT_NO_FATAL_FAILURE(ConnectToService());\n        debug.flags().simulateDeviceConnections = true;\n        ASSERT_NO_FATAL_FAILURE(debug.SetUp(module.get()));\n    }\n\n    void TearDown() override {\n        if (module != nullptr) {\n            Status status = module->setModuleDebug(ModuleDebug{});\n            EXPECT_EQ(Status::EX_NONE, status.exceptionCode())\n                    << status << \" returned when resetting debug flags\";\n        }\n    }",
        "base_contents": "    void SetUp() override { ASSERT_NO_FATAL_FAILURE(ConnectToService()); }",
        "res_region": "    // The default buffer size is used mostly for negative tests.\n    static constexpr int kDefaultBufferSizeFrames = 256;\n\n    void SetUp() override {\n        ASSERT_NO_FATAL_FAILURE(ConnectToService());\n        debug.flags().simulateDeviceConnections = true;\n        ASSERT_NO_FATAL_FAILURE(debug.SetUp(module.get()));\n    }\n\n    void TearDown() override {\n        if (module != nullptr) {\n            ScopedAStatus status = module->setModuleDebug(ModuleDebug{});\n            EXPECT_EQ(EX_NONE, status.getExceptionCode())\n                    << status << \" returned when resetting debug flags\";\n        }\n    }",
        "lookback": "    static constexpr int kDefaultBufferSizeFrames = 256;",
        "lookahead": "",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 385,
        "end_line": 418,
        "merge_gen_region": ".().ulateulateTypeTypeType&&&TypeTypeType::::&&TypeType::::&&TypeType::::&&TypeType::::&&TypeType::::&&TypeType::::&&TypeType::::&&TypeType::::&&TypeType::::&&&TypeType::::&&Type::TypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeType::TypeTypeType::TypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeType",
        "confidence": 0.9149076342582703,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "    AudioHalBinderServiceUtil binderUtil;\n    WithDebugFlags debug;",
        "b_contents": "    WithDebugFlags debug;",
        "base_contents": "",
        "res_region": "    AudioHalBinderServiceUtil binderUtil;\n    WithDebugFlags debug;",
        "lookback": "    WithDebugFlags debug;",
        "lookahead": "};",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 527,
        "end_line": 533,
        "merge_gen_region": null,
        "confidence": 0.7388918995857239,
        "hesitated": true
    },
    {
        "a_contents": "    explicit WithDevicePortConnectedState(const AudioPort& idAndData) : mIdAndData(idAndData) {}\n    WithDevicePortConnectedState(const AudioPort& id, const AudioDeviceAddress& address)\n        : mIdAndData(setAudioPortAddress(id, address)) {}\n    WithDevicePortConnectedState(const WithDevicePortConnectedState&) = delete;\n    WithDevicePortConnectedState& operator=(const WithDevicePortConnectedState&) = delete;\n    ~WithDevicePortConnectedState() {",
        "b_contents": "    explicit WithDevicePortConnectedState(const AudioPort& idAndData) : mIdAndData(idAndData) {}\n    WithDevicePortConnectedState(const AudioPort& id, const AudioDeviceAddress& address)\n        : mIdAndData(setAudioPortAddress(id, address)) {}\n    ~WithDevicePortConnectedState() {",
        "base_contents": "    WithAudioPortConfig() {}\n    explicit WithAudioPortConfig(const AudioPortConfig& config) : mInitialConfig(config) {}\n    ~WithAudioPortConfig() {",
        "res_region": "    explicit WithDevicePortConnectedState(const AudioPort& idAndData) : mIdAndData(idAndData) {}\n    WithDevicePortConnectedState(const AudioPort& id, const AudioDeviceAddress& address)\n        : mIdAndData(setAudioPortAddress(id, address)) {}\n    WithDevicePortConnectedState(const WithDevicePortConnectedState&) = delete;\n    WithDevicePortConnectedState& operator=(const WithDevicePortConnectedState&) = delete;\n    ~WithDevicePortConnectedState() {",
        "lookback": "    WithDevicePortConnectedState(const AudioPort& id, const AudioDeviceAddress& address)",
        "lookahead": "        if (mModule != nullptr) {",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 538,
        "end_line": 554,
        "merge_gen_region": null,
        "confidence": 0.8730096220970154,
        "hesitated": true
    },
    {
        "a_contents": "            ScopedAStatus status = mModule->disconnectExternalDevice(getId());\n            EXPECT_EQ(EX_NONE, status.getExceptionCode())\n                    << status << \" returned when disconnecting device port ID \" << getId();",
        "b_contents": "            Status status = mModule->disconnectExternalDevice(getId());\n            EXPECT_EQ(Status::EX_NONE, status.exceptionCode())\n                    << status << \" returned when disconnecting device port ID \" << getId();",
        "base_contents": "            Status status = mModule->resetAudioPortConfig(getId());\n            EXPECT_EQ(Status::EX_NONE, status.exceptionCode())\n                    << status << \"; port config id \" << getId();",
        "res_region": "            ScopedAStatus status = mModule->disconnectExternalDevice(getId());\n            EXPECT_EQ(EX_NONE, status.getExceptionCode())\n                    << status << \" returned when disconnecting device port ID \" << getId();",
        "lookback": "            EXPECT_EQ(EX_NONE, status.getExceptionCode())",
        "lookahead": "        }",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 556,
        "end_line": 568,
        "merge_gen_region": "_(EXNONE statusgetCodeCode::______(,__,,__,,__,,__,,__,,__,,__,,_,,__,,_,,__,,_,,__,,_,,__,,_,,__,,_,,__,,_,,__,,_,,_,,_,,_,,_,,_,,_,,_,,_,,__,,_,,_,,_,,_,,_,,_,,_,,_,,_,,_,,_,,_,,_,,_,,_,,_,,_,,_,,_,,_,,_,,_,,_,,_,,_,,_,,,_,,_,,_,,_,,_,,,_,,_,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,",
        "confidence": 0.9248173832893372,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "        ScopedAStatus status = module->connectExternalDevice(mIdAndData, &mConnectedPort);\n        ASSERT_EQ(EX_NONE, status.getExceptionCode())\n                << status << \" returned when connecting device port ID & data \"\n                << mIdAndData.toString();\n        ASSERT_NE(mIdAndData.id, getId())\n                << \"ID of the connected port must not be the same as the ID of the template port\";\n        mModule = module;",
        "b_contents": "        Status status = module->connectExternalDevice(mIdAndData, &mConnectedPort);\n        ASSERT_EQ(Status::EX_NONE, status.exceptionCode())\n                << status << \" returned when connecting device port ID & data \"\n                << mIdAndData.toString();\n        ASSERT_NE(mIdAndData.id, getId())\n                << \"ID of the connected port must not be the same as the ID of the template port\";\n        mModule = module;",
        "base_contents": "        ASSERT_NE(AudioPortExt::Tag::unspecified, mInitialConfig.ext.getTag())\n                << \"config: \" << mInitialConfig.toString();\n        // Negotiation is allowed for device ports because the HAL module is\n        // allowed to provide an empty profiles list for attached devices.\n        ASSERT_NO_FATAL_FAILURE(\n                SetUpImpl(module, mInitialConfig.ext.getTag() == AudioPortExt::Tag::device));",
        "res_region": "        ScopedAStatus status = module->connectExternalDevice(mIdAndData, &mConnectedPort);\n        ASSERT_EQ(EX_NONE, status.getExceptionCode())\n                << status << \" returned when connecting device port ID & data \"\n                << mIdAndData.toString();\n        ASSERT_NE(mIdAndData.id, getId())\n                << \"ID of the connected port must not be the same as the ID of the template port\";\n        mModule = module;",
        "lookback": "        ASSERT_EQ(EX_NONE, status.getExceptionCode())",
        "lookahead": "    }",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 572,
        "end_line": 595,
        "merge_gen_region": ".Exception())A status moduleconnectDevicemAnd, &Connected);_( portNONE statusgetCode()) status << sp when device ID data <<Id ASSERTNEmAnd.,Id()) \" of connected must be same the of template\";Module =;",
        "confidence": 0.9128842353820801,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "    AudioPort mConnectedPort;\n};\n\nclass StreamContext {\n  public:\n    typedef AidlMessageQueue<StreamDescriptor::Command, SynchronizedReadWrite> CommandMQ;\n    typedef AidlMessageQueue<StreamDescriptor::Reply, SynchronizedReadWrite> ReplyMQ;\n    typedef AidlMessageQueue<int8_t, SynchronizedReadWrite> DataMQ;\n\n    explicit StreamContext(const StreamDescriptor& descriptor)\n        : mFrameSizeBytes(descriptor.frameSizeBytes),\n          mCommandMQ(new CommandMQ(descriptor.command)),\n          mReplyMQ(new ReplyMQ(descriptor.reply)),\n          mBufferSizeFrames(descriptor.bufferSizeFrames),\n          mDataMQ(maybeCreateDataMQ(descriptor)) {}\n    void checkIsValid() const {\n        EXPECT_NE(0UL, mFrameSizeBytes);\n        ASSERT_NE(nullptr, mCommandMQ);\n        EXPECT_TRUE(mCommandMQ->isValid());\n        ASSERT_NE(nullptr, mReplyMQ);\n        EXPECT_TRUE(mReplyMQ->isValid());\n        if (mDataMQ != nullptr) {\n            EXPECT_TRUE(mDataMQ->isValid());\n            EXPECT_GE(mDataMQ->getQuantumCount() * mDataMQ->getQuantumSize(),\n                      mFrameSizeBytes * mBufferSizeFrames)\n                    << \"Data MQ actual buffer size is \"\n                       \"less than the buffer size as specified by the descriptor\";\n        }\n    }\n    size_t getBufferSizeBytes() const { return mFrameSizeBytes * mBufferSizeFrames; }\n    size_t getBufferSizeFrames() const { return mBufferSizeFrames; }\n    CommandMQ* getCommandMQ() const { return mCommandMQ.get(); }\n    DataMQ* getDataMQ() const { return mDataMQ.get(); }\n    ReplyMQ* getReplyMQ() const { return mReplyMQ.get(); }\n\n  private:\n    static std::unique_ptr<DataMQ> maybeCreateDataMQ(const StreamDescriptor& descriptor) {\n        using Tag = StreamDescriptor::AudioBuffer::Tag;\n        if (descriptor.audio.getTag() == Tag::fmq) {\n            return std::make_unique<DataMQ>(descriptor.audio.get<Tag::fmq>());\n        }\n        return nullptr;\n    }\n\n    const size_t mFrameSizeBytes;\n    std::unique_ptr<CommandMQ> mCommandMQ;\n    std::unique_ptr<ReplyMQ> mReplyMQ;\n    const size_t mBufferSizeFrames;\n    std::unique_ptr<DataMQ> mDataMQ;\n};\n\nclass StreamCommonLogic : public StreamLogic {\n  public:\n    StreamDescriptor::Position getLastObservablePosition() {\n        std::lock_guard<std::mutex> lock(mLock);\n        return mLastReply.observable;\n    }\n\n  protected:\n    explicit StreamCommonLogic(const StreamContext& context)\n        : mCommandMQ(context.getCommandMQ()),\n          mReplyMQ(context.getReplyMQ()),\n          mDataMQ(context.getDataMQ()),\n          mData(context.getBufferSizeBytes()) {}\n    StreamContext::CommandMQ* getCommandMQ() const { return mCommandMQ; }\n    StreamContext::ReplyMQ* getReplyMQ() const { return mReplyMQ; }\n\n    std::string init() override { return \"\"; }\n\n    StreamContext::CommandMQ* mCommandMQ;\n    StreamContext::ReplyMQ* mReplyMQ;\n    StreamContext::DataMQ* mDataMQ;\n    std::vector<int8_t> mData;\n    std::mutex mLock;\n    StreamDescriptor::Reply mLastReply GUARDED_BY(mLock);\n};\n\nclass StreamReaderLogic : public StreamCommonLogic {\n  public:\n    explicit StreamReaderLogic(const StreamContext& context) : StreamCommonLogic(context) {}\n\n  protected:\n    Status cycle() override {\n        StreamDescriptor::Command command{};\n        command.code = StreamDescriptor::COMMAND_BURST;\n        command.fmqByteCount = mData.size();\n        if (!mCommandMQ->writeBlocking(&command, 1)) {\n            LOG(ERROR) << __func__ << \": writing of command into MQ failed\";\n            return Status::ABORT;\n        }\n        StreamDescriptor::Reply reply{};\n        if (!mReplyMQ->readBlocking(&reply, 1)) {\n            LOG(ERROR) << __func__ << \": reading of reply from MQ failed\";\n            return Status::ABORT;\n        }\n        if (reply.status != STATUS_OK) {\n            LOG(ERROR) << __func__ << \": received error status: \" << statusToString(reply.status);\n            return Status::ABORT;\n        }\n        if (reply.fmqByteCount < 0 || reply.fmqByteCount > command.fmqByteCount) {\n            LOG(ERROR) << __func__\n                       << \": received invalid byte count in the reply: \" << reply.fmqByteCount;\n            return Status::ABORT;\n        }\n        {\n            std::lock_guard<std::mutex> lock(mLock);\n            mLastReply = reply;\n        }\n        const size_t readCount = std::min({mDataMQ->availableToRead(),\n                                           static_cast<size_t>(reply.fmqByteCount), mData.size()});\n        if (readCount == 0 || mDataMQ->read(mData.data(), readCount)) {\n            return Status::CONTINUE;\n        }\n        LOG(ERROR) << __func__ << \": reading of \" << readCount << \" data bytes from MQ failed\";\n        return Status::ABORT;\n    }\n};\nusing StreamReader = StreamWorker<StreamReaderLogic>;\n\nclass StreamWriterLogic : public StreamCommonLogic {\n  public:\n    explicit StreamWriterLogic(const StreamContext& context) : StreamCommonLogic(context) {}\n\n  protected:\n    Status cycle() override {\n        if (!mDataMQ->write(mData.data(), mData.size())) {\n            LOG(ERROR) << __func__ << \": writing of \" << mData.size() << \" bytes to MQ failed\";\n            return Status::ABORT;\n        }\n        StreamDescriptor::Command command{};\n        command.code = StreamDescriptor::COMMAND_BURST;\n        command.fmqByteCount = mData.size();\n        if (!mCommandMQ->writeBlocking(&command, 1)) {\n            LOG(ERROR) << __func__ << \": writing of command into MQ failed\";\n            return Status::ABORT;\n        }\n        StreamDescriptor::Reply reply{};\n        if (!mReplyMQ->readBlocking(&reply, 1)) {\n            LOG(ERROR) << __func__ << \": reading of reply from MQ failed\";\n            return Status::ABORT;\n        }\n        if (reply.status != STATUS_OK) {\n            LOG(ERROR) << __func__ << \": received error status: \" << statusToString(reply.status);\n            return Status::ABORT;\n        }\n        if (reply.fmqByteCount < 0 || reply.fmqByteCount > command.fmqByteCount) {\n            LOG(ERROR) << __func__\n                       << \": received invalid byte count in the reply: \" << reply.fmqByteCount;\n            return Status::ABORT;\n        }\n        {\n            std::lock_guard<std::mutex> lock(mLock);\n            mLastReply = reply;\n        }\n        return Status::CONTINUE;\n    }\n};\nusing StreamWriter = StreamWorker<StreamWriterLogic>;\n\ntemplate <typename T>\nstruct IOTraits {\n    static constexpr bool is_input = std::is_same_v<T, IStreamIn>;\n    using Worker = std::conditional_t<is_input, StreamReader, StreamWriter>;\n};\n\n// A dedicated version to test replies to invalid commands.\nclass StreamInvalidCommandLogic : public StreamCommonLogic {\n  public:\n    StreamInvalidCommandLogic(const StreamContext& context,\n                              const std::vector<StreamDescriptor::Command>& commands)\n        : StreamCommonLogic(context), mCommands(commands) {}\n\n    std::vector<std::string> getUnexpectedStatuses() {\n        std::lock_guard<std::mutex> lock(mLock);\n        return mUnexpectedStatuses;\n    }\n\n  protected:\n    Status cycle() override {\n        // Send all commands in one cycle to simplify testing.\n        // Extra logging helps to sort out issues with unexpected HAL behavior.\n        for (const auto& command : mCommands) {\n            LOG(INFO) << __func__ << \": writing command \" << command.toString() << \" into MQ...\";\n            if (!getCommandMQ()->writeBlocking(&command, 1)) {\n                LOG(ERROR) << __func__ << \": writing of command into MQ failed\";\n                return Status::ABORT;\n            }\n            StreamDescriptor::Reply reply{};\n            LOG(INFO) << __func__ << \": reading reply for command \" << command.toString() << \"...\";\n            if (!getReplyMQ()->readBlocking(&reply, 1)) {\n                LOG(ERROR) << __func__ << \": reading of reply from MQ failed\";\n                return Status::ABORT;\n            }\n            LOG(INFO) << __func__ << \": received status \" << statusToString(reply.status)\n                      << \" for command \" << command.toString();\n            if (reply.status != STATUS_BAD_VALUE) {\n                std::string s = command.toString();\n                s.append(\", \").append(statusToString(reply.status));\n                std::lock_guard<std::mutex> lock(mLock);\n                mUnexpectedStatuses.push_back(std::move(s));\n            }\n        };\n        return Status::EXIT;\n    }\n\n  private:\n    const std::vector<StreamDescriptor::Command> mCommands;\n    std::mutex mLock;\n    std::vector<std::string> mUnexpectedStatuses GUARDED_BY(mLock);",
        "b_contents": "    AudioPort mConnectedPort;",
        "base_contents": "    AudioPortConfig mConfig;",
        "res_region": "    AudioPort mConnectedPort;\n};\n\nclass StreamContext {\n  public:\n    typedef AidlMessageQueue<StreamDescriptor::Command, SynchronizedReadWrite> CommandMQ;\n    typedef AidlMessageQueue<StreamDescriptor::Reply, SynchronizedReadWrite> ReplyMQ;\n    typedef AidlMessageQueue<int8_t, SynchronizedReadWrite> DataMQ;\n\n    explicit StreamContext(const StreamDescriptor& descriptor)\n        : mFrameSizeBytes(descriptor.frameSizeBytes),\n          mCommandMQ(new CommandMQ(descriptor.command)),\n          mReplyMQ(new ReplyMQ(descriptor.reply)),\n          mBufferSizeFrames(descriptor.bufferSizeFrames),\n          mDataMQ(maybeCreateDataMQ(descriptor)) {}\n    void checkIsValid() const {\n        EXPECT_NE(0UL, mFrameSizeBytes);\n        ASSERT_NE(nullptr, mCommandMQ);\n        EXPECT_TRUE(mCommandMQ->isValid());\n        ASSERT_NE(nullptr, mReplyMQ);\n        EXPECT_TRUE(mReplyMQ->isValid());\n        if (mDataMQ != nullptr) {\n            EXPECT_TRUE(mDataMQ->isValid());\n            EXPECT_GE(mDataMQ->getQuantumCount() * mDataMQ->getQuantumSize(),\n                      mFrameSizeBytes * mBufferSizeFrames)\n                    << \"Data MQ actual buffer size is \"\n                       \"less than the buffer size as specified by the descriptor\";\n        }\n    }\n    size_t getBufferSizeBytes() const { return mFrameSizeBytes * mBufferSizeFrames; }\n    size_t getBufferSizeFrames() const { return mBufferSizeFrames; }\n    CommandMQ* getCommandMQ() const { return mCommandMQ.get(); }\n    DataMQ* getDataMQ() const { return mDataMQ.get(); }\n    ReplyMQ* getReplyMQ() const { return mReplyMQ.get(); }\n\n  private:\n    static std::unique_ptr<DataMQ> maybeCreateDataMQ(const StreamDescriptor& descriptor) {\n        using Tag = StreamDescriptor::AudioBuffer::Tag;\n        if (descriptor.audio.getTag() == Tag::fmq) {\n            return std::make_unique<DataMQ>(descriptor.audio.get<Tag::fmq>());\n        }\n        return nullptr;\n    }\n\n    const size_t mFrameSizeBytes;\n    std::unique_ptr<CommandMQ> mCommandMQ;\n    std::unique_ptr<ReplyMQ> mReplyMQ;\n    const size_t mBufferSizeFrames;\n    std::unique_ptr<DataMQ> mDataMQ;\n};\n\nclass StreamCommonLogic : public StreamLogic {\n  public:\n    StreamDescriptor::Position getLastObservablePosition() {\n        std::lock_guard<std::mutex> lock(mLock);\n        return mLastReply.observable;\n    }\n\n  protected:\n    explicit StreamCommonLogic(const StreamContext& context)\n        : mCommandMQ(context.getCommandMQ()),\n          mReplyMQ(context.getReplyMQ()),\n          mDataMQ(context.getDataMQ()),\n          mData(context.getBufferSizeBytes()) {}\n    StreamContext::CommandMQ* getCommandMQ() const { return mCommandMQ; }\n    StreamContext::ReplyMQ* getReplyMQ() const { return mReplyMQ; }\n\n    std::string init() override { return \"\"; }\n\n    StreamContext::CommandMQ* mCommandMQ;\n    StreamContext::ReplyMQ* mReplyMQ;\n    StreamContext::DataMQ* mDataMQ;\n    std::vector<int8_t> mData;\n    std::mutex mLock;\n    StreamDescriptor::Reply mLastReply GUARDED_BY(mLock);\n};\n\nclass StreamReaderLogic : public StreamCommonLogic {\n  public:\n    explicit StreamReaderLogic(const StreamContext& context) : StreamCommonLogic(context) {}\n\n  protected:\n    Status cycle() override {\n        StreamDescriptor::Command command{};\n        command.code = StreamDescriptor::COMMAND_BURST;\n        command.fmqByteCount = mData.size();\n        if (!mCommandMQ->writeBlocking(&command, 1)) {\n            LOG(ERROR) << __func__ << \": writing of command into MQ failed\";\n            return Status::ABORT;\n        }\n        StreamDescriptor::Reply reply{};\n        if (!mReplyMQ->readBlocking(&reply, 1)) {\n            LOG(ERROR) << __func__ << \": reading of reply from MQ failed\";\n            return Status::ABORT;\n        }\n        if (reply.status != STATUS_OK) {\n            LOG(ERROR) << __func__ << \": received error status: \" << statusToString(reply.status);\n            return Status::ABORT;\n        }\n        if (reply.fmqByteCount < 0 || reply.fmqByteCount > command.fmqByteCount) {\n            LOG(ERROR) << __func__\n                       << \": received invalid byte count in the reply: \" << reply.fmqByteCount;\n            return Status::ABORT;\n        }\n        {\n            std::lock_guard<std::mutex> lock(mLock);\n            mLastReply = reply;\n        }\n        const size_t readCount = std::min({mDataMQ->availableToRead(),\n                                           static_cast<size_t>(reply.fmqByteCount), mData.size()});\n        if (readCount == 0 || mDataMQ->read(mData.data(), readCount)) {\n            return Status::CONTINUE;\n        }\n        LOG(ERROR) << __func__ << \": reading of \" << readCount << \" data bytes from MQ failed\";\n        return Status::ABORT;\n    }\n};\nusing StreamReader = StreamWorker<StreamReaderLogic>;\n\nclass StreamWriterLogic : public StreamCommonLogic {\n  public:\n    explicit StreamWriterLogic(const StreamContext& context) : StreamCommonLogic(context) {}\n\n  protected:\n    Status cycle() override {\n        if (!mDataMQ->write(mData.data(), mData.size())) {\n            LOG(ERROR) << __func__ << \": writing of \" << mData.size() << \" bytes to MQ failed\";\n            return Status::ABORT;\n        }\n        StreamDescriptor::Command command{};\n        command.code = StreamDescriptor::COMMAND_BURST;\n        command.fmqByteCount = mData.size();\n        if (!mCommandMQ->writeBlocking(&command, 1)) {\n            LOG(ERROR) << __func__ << \": writing of command into MQ failed\";\n            return Status::ABORT;\n        }\n        StreamDescriptor::Reply reply{};\n        if (!mReplyMQ->readBlocking(&reply, 1)) {\n            LOG(ERROR) << __func__ << \": reading of reply from MQ failed\";\n            return Status::ABORT;\n        }\n        if (reply.status != STATUS_OK) {\n            LOG(ERROR) << __func__ << \": received error status: \" << statusToString(reply.status);\n            return Status::ABORT;\n        }\n        if (reply.fmqByteCount < 0 || reply.fmqByteCount > command.fmqByteCount) {\n            LOG(ERROR) << __func__\n                       << \": received invalid byte count in the reply: \" << reply.fmqByteCount;\n            return Status::ABORT;\n        }\n        {\n            std::lock_guard<std::mutex> lock(mLock);\n            mLastReply = reply;\n        }\n        return Status::CONTINUE;\n    }\n};\nusing StreamWriter = StreamWorker<StreamWriterLogic>;\n\ntemplate <typename T>\nstruct IOTraits {\n    static constexpr bool is_input = std::is_same_v<T, IStreamIn>;\n    using Worker = std::conditional_t<is_input, StreamReader, StreamWriter>;\n};\n\n// A dedicated version to test replies to invalid commands.\nclass StreamInvalidCommandLogic : public StreamCommonLogic {\n  public:\n    StreamInvalidCommandLogic(const StreamContext& context,\n                              const std::vector<StreamDescriptor::Command>& commands)\n        : StreamCommonLogic(context), mCommands(commands) {}\n\n    std::vector<std::string> getUnexpectedStatuses() {\n        std::lock_guard<std::mutex> lock(mLock);\n        return mUnexpectedStatuses;\n    }\n\n  protected:\n    Status cycle() override {\n        // Send all commands in one cycle to simplify testing.\n        // Extra logging helps to sort out issues with unexpected HAL behavior.\n        for (const auto& command : mCommands) {\n            LOG(INFO) << __func__ << \": writing command \" << command.toString() << \" into MQ...\";\n            if (!getCommandMQ()->writeBlocking(&command, 1)) {\n                LOG(ERROR) << __func__ << \": writing of command into MQ failed\";\n                return Status::ABORT;\n            }\n            StreamDescriptor::Reply reply{};\n            LOG(INFO) << __func__ << \": reading reply for command \" << command.toString() << \"...\";\n            if (!getReplyMQ()->readBlocking(&reply, 1)) {\n                LOG(ERROR) << __func__ << \": reading of reply from MQ failed\";\n                return Status::ABORT;\n            }\n            LOG(INFO) << __func__ << \": received status \" << statusToString(reply.status)\n                      << \" for command \" << command.toString();\n            if (reply.status != STATUS_BAD_VALUE) {\n                std::string s = command.toString();\n                s.append(\", \").append(statusToString(reply.status));\n                std::lock_guard<std::mutex> lock(mLock);\n                mUnexpectedStatuses.push_back(std::move(s));\n            }\n        };\n        return Status::EXIT;\n    }\n\n  private:\n    const std::vector<StreamDescriptor::Command> mCommands;\n    std::mutex mLock;\n    std::vector<std::string> mUnexpectedStatuses GUARDED_BY(mLock);",
        "lookback": "};",
        "lookahead": "};",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 609,
        "end_line": 823,
        "merge_gen_region": null,
        "confidence": 0.40323495864868164,
        "hesitated": true
    },
    {
        "a_contents": "TEST_P(AudioCoreModule, SetUpModuleConfig) {\n    ASSERT_NO_FATAL_FAILURE(SetUpModuleConfig());\n    // Send the module config to logcat to facilitate failures investigation.\n    LOG(INFO) << \"SetUpModuleConfig: \" << moduleConfig->toString();\n}\n\n// Verify that HAL module reports for a connected device port at least one non-dynamic profile,\n// that is, a profile with actual supported configuration.\n// Note: This test relies on simulation of external device connections by the HAL module.\nTEST_P(AudioCoreModule, GetAudioPortWithExternalDevices) {\n    ASSERT_NO_FATAL_FAILURE(SetUpModuleConfig());\n    std::vector<AudioPort> ports = moduleConfig->getExternalDevicePorts();\n    if (ports.empty()) {\n        GTEST_SKIP() << \"No external devices in the module.\";\n    }\n    for (const auto& port : ports) {\n        AudioPort portWithData = port;\n        portWithData.ext.get<AudioPortExt::Tag::device>().device.address =\n                GenerateUniqueDeviceAddress();\n        WithDevicePortConnectedState portConnected(portWithData);\n        ASSERT_NO_FATAL_FAILURE(portConnected.SetUp(module.get()));\n        const int32_t connectedPortId = portConnected.getId();\n        ASSERT_NE(portWithData.id, connectedPortId);\n        ASSERT_EQ(portWithData.ext.getTag(), portConnected.get().ext.getTag());\n        EXPECT_EQ(portWithData.ext.get<AudioPortExt::Tag::device>().device,\n                  portConnected.get().ext.get<AudioPortExt::Tag::device>().device);\n        // Verify that 'getAudioPort' and 'getAudioPorts' return the same connected port.\n        AudioPort connectedPort;\n        ScopedAStatus status = module->getAudioPort(connectedPortId, &connectedPort);\n        EXPECT_EQ(EX_NONE, status.getExceptionCode())\n                << status << \" returned for getAudioPort port ID \" << connectedPortId;\n        EXPECT_EQ(portConnected.get(), connectedPort);\n        const auto& portProfiles = connectedPort.profiles;\n        EXPECT_NE(0UL, portProfiles.size())\n                << \"Connected port has no profiles: \" << connectedPort.toString();\n        const auto dynamicProfileIt =\n                std::find_if(portProfiles.begin(), portProfiles.end(), [](const auto& profile) {\n                    return profile.format.type == AudioFormatType::DEFAULT;\n                });\n        EXPECT_EQ(portProfiles.end(), dynamicProfileIt) << \"Connected port contains dynamic \"\n                                                        << \"profiles: \" << connectedPort.toString();\n\n        std::vector<AudioPort> allPorts;\n        {\n            ScopedAStatus status = module->getAudioPorts(&allPorts);\n            ASSERT_EQ(EX_NONE, status.getExceptionCode()) << status;\n        }\n        const auto allPortsIt = findById(allPorts, connectedPortId);\n        EXPECT_NE(allPorts.end(), allPortsIt);\n        if (allPortsIt != allPorts.end()) {\n            EXPECT_EQ(portConnected.get(), *allPortsIt);\n        }\n    }\n}\n",
        "b_contents": "// Verify that HAL module reports for a connected device port at least one non-dynamic profile,\n// that is, a profile with actual supported configuration.\n// Note: This test relies on simulation of external device connections by the HAL module.\nTEST_P(AudioCoreModule, GetAudioPortWithExternalDevices) {\n    ASSERT_NO_FATAL_FAILURE(SetUpModuleConfig());\n    std::vector<AudioPort> ports = moduleConfig->getExternalDevicePorts();\n    if (ports.empty()) {\n        GTEST_SKIP() << \"No external devices in the module.\";\n    }\n    for (const auto& port : ports) {\n        AudioPort portWithData = port;\n        portWithData.ext.get<AudioPortExt::Tag::device>().device.address =\n                GenerateUniqueDeviceAddress();\n        WithDevicePortConnectedState portConnected(portWithData);\n        ASSERT_NO_FATAL_FAILURE(portConnected.SetUp(module.get()));\n        const int32_t connectedPortId = portConnected.getId();\n        ASSERT_NE(portWithData.id, connectedPortId);\n        ASSERT_EQ(portWithData.ext.getTag(), portConnected.get().ext.getTag());\n        EXPECT_EQ(portWithData.ext.get<AudioPortExt::Tag::device>().device,\n                  portConnected.get().ext.get<AudioPortExt::Tag::device>().device);\n        // Verify that 'getAudioPort' and 'getAudioPorts' return the same connected port.\n        AudioPort connectedPort;\n        Status status = module->getAudioPort(connectedPortId, &connectedPort);\n        EXPECT_EQ(Status::EX_NONE, status.exceptionCode())\n                << status << \" returned for getAudioPort port ID \" << connectedPortId;\n        EXPECT_EQ(portConnected.get(), connectedPort);\n        const auto& portProfiles = connectedPort.profiles;\n        EXPECT_NE(0, portProfiles.size())\n                << \"Connected port has no profiles: \" << connectedPort.toString();\n        const auto dynamicProfileIt =\n                std::find_if(portProfiles.begin(), portProfiles.end(), [](const auto& profile) {\n                    return profile.format.type == AudioFormatType::DEFAULT;\n                });\n        EXPECT_EQ(portProfiles.end(), dynamicProfileIt) << \"Connected port contains dynamic \"\n                                                        << \"profiles: \" << connectedPort.toString();\n\n        std::vector<AudioPort> allPorts;\n        {\n            Status status = module->getAudioPorts(&allPorts);\n            ASSERT_EQ(Status::EX_NONE, status.exceptionCode()) << status;\n        }\n        const auto allPortsIt = findById(allPorts, connectedPortId);\n        EXPECT_NE(allPorts.end(), allPortsIt);\n        if (allPortsIt != allPorts.end()) {\n            EXPECT_EQ(portConnected.get(), *allPortsIt);\n        }\n    }\n}\n",
        "base_contents": "",
        "res_region": "TEST_P(AudioCoreModule, SetUpModuleConfig) {\n    ASSERT_NO_FATAL_FAILURE(SetUpModuleConfig());\n    // Send the module config to logcat to facilitate failures investigation.\n    LOG(INFO) << \"SetUpModuleConfig: \" << moduleConfig->toString();\n}\n\n// Verify that HAL module reports for a connected device port at least one non-dynamic profile,\n// that is, a profile with actual supported configuration.\n// Note: This test relies on simulation of external device connections by the HAL module.\nTEST_P(AudioCoreModule, GetAudioPortWithExternalDevices) {\n    ASSERT_NO_FATAL_FAILURE(SetUpModuleConfig());\n    std::vector<AudioPort> ports = moduleConfig->getExternalDevicePorts();\n    if (ports.empty()) {\n        GTEST_SKIP() << \"No external devices in the module.\";\n    }\n    for (const auto& port : ports) {\n        AudioPort portWithData = port;\n        portWithData.ext.get<AudioPortExt::Tag::device>().device.address =\n                GenerateUniqueDeviceAddress();\n        WithDevicePortConnectedState portConnected(portWithData);\n        ASSERT_NO_FATAL_FAILURE(portConnected.SetUp(module.get()));\n        const int32_t connectedPortId = portConnected.getId();\n        ASSERT_NE(portWithData.id, connectedPortId);\n        ASSERT_EQ(portWithData.ext.getTag(), portConnected.get().ext.getTag());\n        EXPECT_EQ(portWithData.ext.get<AudioPortExt::Tag::device>().device,\n                  portConnected.get().ext.get<AudioPortExt::Tag::device>().device);\n        // Verify that 'getAudioPort' and 'getAudioPorts' return the same connected port.\n        AudioPort connectedPort;\n        ScopedAStatus status = module->getAudioPort(connectedPortId, &connectedPort);\n        EXPECT_EQ(EX_NONE, status.getExceptionCode())\n                << status << \" returned for getAudioPort port ID \" << connectedPortId;\n        EXPECT_EQ(portConnected.get(), connectedPort);\n        const auto& portProfiles = connectedPort.profiles;\n        EXPECT_NE(0UL, portProfiles.size())\n                << \"Connected port has no profiles: \" << connectedPort.toString();\n        const auto dynamicProfileIt =\n                std::find_if(portProfiles.begin(), portProfiles.end(), [](const auto& profile) {\n                    return profile.format.type == AudioFormatType::DEFAULT;\n                });\n        EXPECT_EQ(portProfiles.end(), dynamicProfileIt) << \"Connected port contains dynamic \"\n                                                        << \"profiles: \" << connectedPort.toString();\n\n        std::vector<AudioPort> allPorts;\n        {\n            ScopedAStatus status = module->getAudioPorts(&allPorts);\n            ASSERT_EQ(EX_NONE, status.getExceptionCode()) << status;\n        }\n        const auto allPortsIt = findById(allPorts, connectedPortId);\n        EXPECT_NE(allPorts.end(), allPortsIt);\n        if (allPortsIt != allPorts.end()) {\n            EXPECT_EQ(portConnected.get(), *allPortsIt);\n        }\n    }\n}\n",
        "lookback": "    ASSERT_NO_FATAL_FAILURE(SetUpModuleConfig());",
        "lookahead": "TEST_P(AudioCoreModule, OpenStreamInvalidPortConfigId) {",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 1207,
        "end_line": 1314,
        "merge_gen_region": " Verify HAL reports a device port least non- profile // is a with supported. Note This re on of device by HAL._(PAudioModule GetPortExternal) ASSERTNOFATALFAILURESetModule());::<Port ports module->ExternalDevice(); (.()) GTESTSKIP <<No devices the module } ( auto port ports {PortWith =;With....<Port::::>().. =UniqueAddress WithPortStateConnectedportData ASSERTNOFATALFAILUREport.Upmoduleget const32tPort =ConnectedgetId ASSERTNEportDataid connectedId ASSERT ASSERTEQportDataextget(),Connectedgetextget());_EQportWith......(..(. const32tPort =ConnectedgetId ASSERTNEportDataid connectedId ASSERT ASSERTEQportDataextget(), port.().extget()); EXPECTEQportWith.With...<Port::::>().,Connectedgetext.<Port::::>().); Verify 'Audio' andgetPorts return same port Audio connected; status modulegetPortconnectedId &Port EXPECTEQStatusEXNONE statusexception()) status \" forAudio port \" <<Port;_(Connectedget connected); auto&Profiles connected.(),;__(Connectedget connected); auto&Profiles",
        "confidence": 0.9377074241638184,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "    for (const auto portConfigId : GetNonExistentIds(portConfigIds)) {\n        ScopedAStatus status = module->resetAudioPortConfig(portConfigId);\n        EXPECT_EQ(EX_ILLEGAL_ARGUMENT, status.getExceptionCode())",
        "b_contents": "    for (const auto portConfigId : GetNonExistentIds(portConfigIds)) {\n        Status status = module->resetAudioPortConfig(portConfigId);\n        EXPECT_EQ(Status::EX_ILLEGAL_ARGUMENT, status.exceptionCode())",
        "base_contents": "    for (const auto portConfigId : getNonExistentIds(portConfigIds)) {\n        Status status = module->resetAudioPortConfig(portConfigId);\n        EXPECT_EQ(Status::EX_ILLEGAL_ARGUMENT, status.exceptionCode())",
        "res_region": "    for (const auto portConfigId : GetNonExistentIds(portConfigIds)) {\n        ScopedAStatus status = module->resetAudioPortConfig(portConfigId);\n        EXPECT_EQ(EX_ILLEGAL_ARGUMENT, status.getExceptionCode())",
        "lookback": "        ScopedAStatus status = module->resetAudioPortConfig(portConfigId);",
        "lookahead": "                << status << \" returned for port config ID \" << portConfigId;",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 1364,
        "end_line": 1376,
        "merge_gen_region": "A status moduleresetPortConfigportId forconst portId :Nonent(Config))",
        "confidence": 0.883209228515625,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "TEST_P(AudioCoreModule, TryConnectMissingDevice) {\n    ASSERT_NO_FATAL_FAILURE(SetUpModuleConfig());\n    std::vector<AudioPort> ports = moduleConfig->getExternalDevicePorts();\n    if (ports.empty()) {\n        GTEST_SKIP() << \"No external devices in the module.\";\n    }\n    AudioPort ignored;\n    WithDebugFlags doNotSimulateConnections = WithDebugFlags::createNested(debug);\n    doNotSimulateConnections.flags().simulateDeviceConnections = false;\n    ASSERT_NO_FATAL_FAILURE(doNotSimulateConnections.SetUp(module.get()));\n    for (const auto& port : ports) {\n        AudioPort portWithData = port;\n        portWithData.ext.get<AudioPortExt::Tag::device>().device.address =\n                GenerateUniqueDeviceAddress();\n        ScopedAStatus status = module->connectExternalDevice(portWithData, &ignored);\n        EXPECT_EQ(EX_ILLEGAL_STATE, status.getExceptionCode())\n                << status << \" returned for static port \" << portWithData.toString();\n    }\n}\n\nTEST_P(AudioCoreModule, TryChangingConnectionSimulationMidway) {\n    ASSERT_NO_FATAL_FAILURE(SetUpModuleConfig());\n    std::vector<AudioPort> ports = moduleConfig->getExternalDevicePorts();\n    if (ports.empty()) {\n        GTEST_SKIP() << \"No external devices in the module.\";\n    }\n    WithDevicePortConnectedState portConnected(*ports.begin(), GenerateUniqueDeviceAddress());\n    ASSERT_NO_FATAL_FAILURE(portConnected.SetUp(module.get()));\n    ModuleDebug midwayDebugChange = debug.flags();\n    midwayDebugChange.simulateDeviceConnections = false;\n    ScopedAStatus status = module->setModuleDebug(midwayDebugChange);\n    EXPECT_EQ(EX_ILLEGAL_STATE, status.getExceptionCode())\n            << status << \" returned when trying to disable connections simulation \"\n            << \"while having a connected device\";\n}\n\nTEST_P(AudioCoreModule, ConnectDisconnectExternalDeviceInvalidPorts) {\n    AudioPort ignored;\n    std::set<int32_t> portIds;\n    ASSERT_NO_FATAL_FAILURE(GetAllPortIds(&portIds));\n    for (const auto portId : GetNonExistentIds(portIds)) {\n        AudioPort invalidPort;\n        invalidPort.id = portId;\n        ScopedAStatus status = module->connectExternalDevice(invalidPort, &ignored);\n        EXPECT_EQ(EX_ILLEGAL_ARGUMENT, status.getExceptionCode())\n                << status << \" returned for port ID \" << portId << \" when setting CONNECTED state\";\n        status = module->disconnectExternalDevice(portId);\n        EXPECT_EQ(EX_ILLEGAL_ARGUMENT, status.getExceptionCode())\n                << status << \" returned for port ID \" << portId\n                << \" when setting DISCONNECTED state\";\n    }\n\n    std::vector<AudioPort> ports;\n    {\n        ScopedAStatus status = module->getAudioPorts(&ports);\n        ASSERT_EQ(EX_NONE, status.getExceptionCode()) << status;\n    }\n    for (const auto& port : ports) {\n        if (port.ext.getTag() != AudioPortExt::Tag::device) {\n            ScopedAStatus status = module->connectExternalDevice(port, &ignored);\n            EXPECT_EQ(EX_ILLEGAL_ARGUMENT, status.getExceptionCode())\n                    << status << \" returned for non-device port ID \" << port.id\n                    << \" when setting CONNECTED state\";\n            status = module->disconnectExternalDevice(port.id);\n            EXPECT_EQ(EX_ILLEGAL_ARGUMENT, status.getExceptionCode())\n                    << status << \" returned for non-device port ID \" << port.id\n                    << \" when setting DISCONNECTED state\";\n        } else {\n            const auto& devicePort = port.ext.get<AudioPortExt::Tag::device>();\n            if (devicePort.device.type.connection.empty()) {\n                ScopedAStatus status = module->connectExternalDevice(port, &ignored);\n                EXPECT_EQ(EX_ILLEGAL_ARGUMENT, status.getExceptionCode())\n                        << status << \" returned for permanently attached device port ID \" << port.id\n                        << \" when setting CONNECTED state\";\n                status = module->disconnectExternalDevice(port.id);\n                EXPECT_EQ(EX_ILLEGAL_ARGUMENT, status.getExceptionCode())\n                        << status << \" returned for permanently attached device port ID \" << port.id\n                        << \" when setting DISCONNECTED state\";\n            }\n        }\n    }\n}\n\n// Note: This test relies on simulation of external device connections by the HAL module.\nTEST_P(AudioCoreModule, ConnectDisconnectExternalDeviceTwice) {\n    ASSERT_NO_FATAL_FAILURE(SetUpModuleConfig());\n    AudioPort ignored;\n    std::vector<AudioPort> ports = moduleConfig->getExternalDevicePorts();\n    if (ports.empty()) {\n        GTEST_SKIP() << \"No external devices in the module.\";\n    }\n    for (const auto& port : ports) {\n        ScopedAStatus status = module->disconnectExternalDevice(port.id);\n        EXPECT_EQ(EX_ILLEGAL_ARGUMENT, status.getExceptionCode())\n                << status << \" returned when disconnecting already disconnected device port ID \"\n                << port.id;\n        AudioPort portWithData = port;\n        portWithData.ext.get<AudioPortExt::Tag::device>().device.address =\n                GenerateUniqueDeviceAddress();\n        WithDevicePortConnectedState portConnected(portWithData);\n        ASSERT_NO_FATAL_FAILURE(portConnected.SetUp(module.get()));\n        status = module->connectExternalDevice(portConnected.get(), &ignored);\n        EXPECT_EQ(EX_ILLEGAL_ARGUMENT, status.getExceptionCode())\n                << status << \" returned when trying to connect a connected device port \"\n                << portConnected.get().toString();\n        status = module->connectExternalDevice(portWithData, &ignored);\n        EXPECT_EQ(EX_ILLEGAL_STATE, status.getExceptionCode())\n                << status << \" returned when connecting again the external device \"\n                << portWithData.ext.get<AudioPortExt::Tag::device>().device.toString();\n        if (status.getExceptionCode() == EX_NONE) {\n            ADD_FAILURE() << \"Returned connected port \" << ignored.toString() << \" for template \"\n                          << portWithData.toString();\n        }\n    }\n}\n\n// Note: This test relies on simulation of external device connections by the HAL module.\nTEST_P(AudioCoreModule, DisconnectExternalDeviceNonResetPortConfig) {\n    ASSERT_NO_FATAL_FAILURE(SetUpModuleConfig());\n    std::vector<AudioPort> ports = moduleConfig->getExternalDevicePorts();\n    if (ports.empty()) {\n        GTEST_SKIP() << \"No external devices in the module.\";\n    }\n    for (const auto& port : ports) {\n        WithDevicePortConnectedState portConnected(port, GenerateUniqueDeviceAddress());\n        ASSERT_NO_FATAL_FAILURE(portConnected.SetUp(module.get()));\n        const auto portConfig = moduleConfig->getSingleConfigForDevicePort(portConnected.get());\n        {\n            WithAudioPortConfig config(portConfig);\n            // Note: if SetUp fails, check the status of 'GetAudioPortWithExternalDevices' test.\n            // Our test assumes that 'getAudioPort' returns at least one profile, and it\n            // is not a dynamic profile.\n            ASSERT_NO_FATAL_FAILURE(config.SetUp(module.get()));\n            ScopedAStatus status = module->disconnectExternalDevice(portConnected.getId());\n            EXPECT_EQ(EX_ILLEGAL_STATE, status.getExceptionCode())\n                    << status << \" returned when trying to disconnect device port ID \" << port.id\n                    << \" with active configuration \" << config.getId();\n        }\n    }\n}\n\nTEST_P(AudioCoreModule, ExternalDevicePortRoutes) {\n    ASSERT_NO_FATAL_FAILURE(SetUpModuleConfig());\n    std::vector<AudioPort> ports = moduleConfig->getExternalDevicePorts();\n    if (ports.empty()) {\n        GTEST_SKIP() << \"No external devices in the module.\";\n    }\n    for (const auto& port : ports) {\n        std::vector<AudioRoute> routesBefore;\n        {\n            ScopedAStatus status = module->getAudioRoutes(&routesBefore);\n            ASSERT_EQ(EX_NONE, status.getExceptionCode()) << status;\n        }\n\n        int32_t connectedPortId;\n        {\n            WithDevicePortConnectedState portConnected(port, GenerateUniqueDeviceAddress());\n            ASSERT_NO_FATAL_FAILURE(portConnected.SetUp(module.get()));\n            connectedPortId = portConnected.getId();\n            std::vector<AudioRoute> connectedPortRoutes;\n            {\n                ScopedAStatus status =\n                        module->getAudioRoutesForAudioPort(connectedPortId, &connectedPortRoutes);\n                ASSERT_EQ(EX_NONE, status.getExceptionCode())\n                        << status << \" returned when retrieving routes for connected port id \"\n                        << connectedPortId;\n            }\n            // There must be routes for the port to be useful.\n            if (connectedPortRoutes.empty()) {\n                std::vector<AudioRoute> allRoutes;\n                ScopedAStatus status = module->getAudioRoutes(&allRoutes);\n                ASSERT_EQ(EX_NONE, status.getExceptionCode()) << status;\n                ADD_FAILURE() << \" no routes returned for the connected port \"\n                              << portConnected.get().toString()\n                              << \"; all routes: \" << android::internal::ToString(allRoutes);\n            }\n        }\n        std::vector<AudioRoute> ignored;\n        ScopedAStatus status = module->getAudioRoutesForAudioPort(connectedPortId, &ignored);\n        ASSERT_EQ(EX_ILLEGAL_ARGUMENT, status.getExceptionCode())\n                << status << \" returned when retrieving routes for released connected port id \"\n                << connectedPortId;\n\n        std::vector<AudioRoute> routesAfter;\n        {\n            ScopedAStatus status = module->getAudioRoutes(&routesAfter);\n            ASSERT_EQ(EX_NONE, status.getExceptionCode()) << status;\n        }\n        ASSERT_EQ(routesBefore.size(), routesAfter.size())\n                << \"Sizes of audio route arrays do not match after creating and \"\n                << \"releasing a connected port\";\n        std::sort(routesBefore.begin(), routesBefore.end());\n        std::sort(routesAfter.begin(), routesAfter.end());\n        EXPECT_EQ(routesBefore, routesAfter);\n    }\n}\n",
        "b_contents": "TEST_P(AudioCoreModule, TryConnectMissingDevice) {\n    ASSERT_NO_FATAL_FAILURE(SetUpModuleConfig());\n    std::vector<AudioPort> ports = moduleConfig->getExternalDevicePorts();\n    if (ports.empty()) {\n        GTEST_SKIP() << \"No external devices in the module.\";\n    }\n    AudioPort ignored;\n    WithDebugFlags doNotSimulateConnections(debug);\n    doNotSimulateConnections.flags().simulateDeviceConnections = false;\n    ASSERT_NO_FATAL_FAILURE(doNotSimulateConnections.SetUp(module.get()));\n    for (const auto& port : ports) {\n        AudioPort portWithData = port;\n        portWithData.ext.get<AudioPortExt::Tag::device>().device.address =\n                GenerateUniqueDeviceAddress();\n        Status status = module->connectExternalDevice(portWithData, &ignored);\n        EXPECT_EQ(Status::EX_ILLEGAL_STATE, status.exceptionCode())\n                << status << \" returned for static port \" << portWithData.toString();\n    }\n}\n\nTEST_P(AudioCoreModule, TryChangingConnectionSimulationMidway) {\n    ASSERT_NO_FATAL_FAILURE(SetUpModuleConfig());\n    std::vector<AudioPort> ports = moduleConfig->getExternalDevicePorts();\n    if (ports.empty()) {\n        GTEST_SKIP() << \"No external devices in the module.\";\n    }\n    WithDevicePortConnectedState portConnected(*ports.begin(), GenerateUniqueDeviceAddress());\n    ASSERT_NO_FATAL_FAILURE(portConnected.SetUp(module.get()));\n    ModuleDebug midwayDebugChange = debug.flags();\n    midwayDebugChange.simulateDeviceConnections = false;\n    Status status = module->setModuleDebug(midwayDebugChange);\n    EXPECT_EQ(Status::EX_ILLEGAL_STATE, status.exceptionCode())\n            << status << \" returned when trying to disable connections simulation \"\n            << \"while having a connected device\";\n}\n\nTEST_P(AudioCoreModule, ConnectDisconnectExternalDeviceInvalidPorts) {\n    AudioPort ignored;\n    std::set<int32_t> portIds;\n    ASSERT_NO_FATAL_FAILURE(GetAllPortIds(&portIds));\n    for (const auto portId : GetNonExistentIds(portIds)) {\n        AudioPort invalidPort;\n        invalidPort.id = portId;\n        Status status = module->connectExternalDevice(invalidPort, &ignored);\n        EXPECT_EQ(Status::EX_ILLEGAL_ARGUMENT, status.exceptionCode())\n                << status << \" returned for port ID \" << portId << \" when setting CONNECTED state\";\n        status = module->disconnectExternalDevice(portId);\n        EXPECT_EQ(Status::EX_ILLEGAL_ARGUMENT, status.exceptionCode())\n                << status << \" returned for port ID \" << portId\n                << \" when setting DISCONNECTED state\";\n    }\n\n    std::vector<AudioPort> ports;\n    {\n        Status status = module->getAudioPorts(&ports);\n        ASSERT_EQ(Status::EX_NONE, status.exceptionCode()) << status;\n    }\n    for (const auto& port : ports) {\n        if (port.ext.getTag() != AudioPortExt::Tag::device) {\n            Status status = module->connectExternalDevice(port, &ignored);\n            EXPECT_EQ(Status::EX_ILLEGAL_ARGUMENT, status.exceptionCode())\n                    << status << \" returned for non-device port ID \" << port.id\n                    << \" when setting CONNECTED state\";\n            status = module->disconnectExternalDevice(port.id);\n            EXPECT_EQ(Status::EX_ILLEGAL_ARGUMENT, status.exceptionCode())\n                    << status << \" returned for non-device port ID \" << port.id\n                    << \" when setting DISCONNECTED state\";\n        } else {\n            const auto& devicePort = port.ext.get<AudioPortExt::Tag::device>();\n            if (devicePort.device.type.connection.empty()) {\n                Status status = module->connectExternalDevice(port, &ignored);\n                EXPECT_EQ(Status::EX_ILLEGAL_ARGUMENT, status.exceptionCode())\n                        << status << \" returned for permanently attached device port ID \" << port.id\n                        << \" when setting CONNECTED state\";\n                status = module->disconnectExternalDevice(port.id);\n                EXPECT_EQ(Status::EX_ILLEGAL_ARGUMENT, status.exceptionCode())\n                        << status << \" returned for permanently attached device port ID \" << port.id\n                        << \" when setting DISCONNECTED state\";\n            }\n        }\n    }\n}\n\n// Note: This test relies on simulation of external device connections by the HAL module.\nTEST_P(AudioCoreModule, ConnectDisconnectExternalDeviceTwice) {\n    ASSERT_NO_FATAL_FAILURE(SetUpModuleConfig());\n    AudioPort ignored;\n    std::vector<AudioPort> ports = moduleConfig->getExternalDevicePorts();\n    if (ports.empty()) {\n        GTEST_SKIP() << \"No external devices in the module.\";\n    }\n    for (const auto& port : ports) {\n        Status status = module->disconnectExternalDevice(port.id);\n        EXPECT_EQ(Status::EX_ILLEGAL_ARGUMENT, status.exceptionCode())\n                << status << \" returned when disconnecting already disconnected device port ID \"\n                << port.id;\n        AudioPort portWithData = port;\n        portWithData.ext.get<AudioPortExt::Tag::device>().device.address =\n                GenerateUniqueDeviceAddress();\n        WithDevicePortConnectedState portConnected(portWithData);\n        ASSERT_NO_FATAL_FAILURE(portConnected.SetUp(module.get()));\n        status = module->connectExternalDevice(portConnected.get(), &ignored);\n        EXPECT_EQ(Status::EX_ILLEGAL_ARGUMENT, status.exceptionCode())\n                << status << \" returned when trying to connect a connected device port \"\n                << portConnected.get().toString();\n        status = module->connectExternalDevice(portWithData, &ignored);\n        EXPECT_EQ(Status::EX_ILLEGAL_STATE, status.exceptionCode())\n                << status << \" returned when connecting again the external device \"\n                << portWithData.ext.get<AudioPortExt::Tag::device>().device.toString();\n        if (status.exceptionCode() == Status::EX_NONE) {\n            ADD_FAILURE() << \"Returned connected port \" << ignored.toString() << \" for template \"\n                          << portWithData.toString();\n        }\n    }\n}\n\n// Note: This test relies on simulation of external device connections by the HAL module.\nTEST_P(AudioCoreModule, DisconnectExternalDeviceNonResetPortConfig) {\n    ASSERT_NO_FATAL_FAILURE(SetUpModuleConfig());\n    std::vector<AudioPort> ports = moduleConfig->getExternalDevicePorts();\n    if (ports.empty()) {\n        GTEST_SKIP() << \"No external devices in the module.\";\n    }\n    for (const auto& port : ports) {\n        WithDevicePortConnectedState portConnected(port, GenerateUniqueDeviceAddress());\n        ASSERT_NO_FATAL_FAILURE(portConnected.SetUp(module.get()));\n        const auto portConfig = moduleConfig->getSingleConfigForDevicePort(portConnected.get());\n        {\n            WithAudioPortConfig config(portConfig);\n            // Note: if SetUp fails, check the status of 'GetAudioPortWithExternalDevices' test.\n            // Our test assumes that 'getAudioPort' returns at least one profile, and it\n            // is not a dynamic profile.\n            ASSERT_NO_FATAL_FAILURE(config.SetUp(module.get()));\n            Status status = module->disconnectExternalDevice(portConnected.getId());\n            EXPECT_EQ(Status::EX_ILLEGAL_STATE, status.exceptionCode())\n                    << status << \" returned when trying to disconnect device port ID \" << port.id\n                    << \" with active configuration \" << config.getId();\n        }\n    }\n}\n\nTEST_P(AudioCoreModule, ExternalDevicePortRoutes) {\n    ASSERT_NO_FATAL_FAILURE(SetUpModuleConfig());\n    std::vector<AudioPort> ports = moduleConfig->getExternalDevicePorts();\n    if (ports.empty()) {\n        GTEST_SKIP() << \"No external devices in the module.\";\n    }\n    for (const auto& port : ports) {\n        std::vector<AudioRoute> routesBefore;\n        {\n            Status status = module->getAudioRoutes(&routesBefore);\n            ASSERT_EQ(Status::EX_NONE, status.exceptionCode()) << status;\n        }\n\n        int32_t connectedPortId;\n        {\n            WithDevicePortConnectedState portConnected(port, GenerateUniqueDeviceAddress());\n            ASSERT_NO_FATAL_FAILURE(portConnected.SetUp(module.get()));\n            connectedPortId = portConnected.getId();\n            std::vector<AudioRoute> connectedPortRoutes;\n            {\n                Status status =\n                        module->getAudioRoutesForAudioPort(connectedPortId, &connectedPortRoutes);\n                ASSERT_EQ(Status::EX_NONE, status.exceptionCode())\n                        << status << \" returned when retrieving routes for connected port id \"\n                        << connectedPortId;\n            }\n            // There must be routes for the port to be useful.\n            if (connectedPortRoutes.empty()) {\n                std::vector<AudioRoute> allRoutes;\n                Status status = module->getAudioRoutes(&allRoutes);\n                ASSERT_EQ(Status::EX_NONE, status.exceptionCode()) << status;\n                ADD_FAILURE() << \" no routes returned for the connected port \"\n                              << portConnected.get().toString()\n                              << \"; all routes: \" << android::internal::ToString(allRoutes);\n            }\n        }\n        std::vector<AudioRoute> ignored;\n        Status status = module->getAudioRoutesForAudioPort(connectedPortId, &ignored);\n        ASSERT_EQ(Status::EX_ILLEGAL_ARGUMENT, status.exceptionCode())\n                << status << \" returned when retrieving routes for released connected port id \"\n                << connectedPortId;\n\n        std::vector<AudioRoute> routesAfter;\n        {\n            Status status = module->getAudioRoutes(&routesAfter);\n            ASSERT_EQ(Status::EX_NONE, status.exceptionCode()) << status;\n        }\n        ASSERT_EQ(routesBefore.size(), routesAfter.size())\n                << \"Sizes of audio route arrays do not match after creating and \"\n                << \"releasing a connected port\";\n        std::sort(routesBefore.begin(), routesBefore.end());\n        std::sort(routesAfter.begin(), routesAfter.end());\n        EXPECT_EQ(routesBefore, routesAfter);\n    }\n}\n",
        "base_contents": "",
        "res_region": "TEST_P(AudioCoreModule, TryConnectMissingDevice) {\n    ASSERT_NO_FATAL_FAILURE(SetUpModuleConfig());\n    std::vector<AudioPort> ports = moduleConfig->getExternalDevicePorts();\n    if (ports.empty()) {\n        GTEST_SKIP() << \"No external devices in the module.\";\n    }\n    AudioPort ignored;\n    WithDebugFlags doNotSimulateConnections = WithDebugFlags::createNested(debug);\n    doNotSimulateConnections.flags().simulateDeviceConnections = false;\n    ASSERT_NO_FATAL_FAILURE(doNotSimulateConnections.SetUp(module.get()));\n    for (const auto& port : ports) {\n        AudioPort portWithData = port;\n        portWithData.ext.get<AudioPortExt::Tag::device>().device.address =\n                GenerateUniqueDeviceAddress();\n        ScopedAStatus status = module->connectExternalDevice(portWithData, &ignored);\n        EXPECT_EQ(EX_ILLEGAL_STATE, status.getExceptionCode())\n                << status << \" returned for static port \" << portWithData.toString();\n    }\n}\n\nTEST_P(AudioCoreModule, TryChangingConnectionSimulationMidway) {\n    ASSERT_NO_FATAL_FAILURE(SetUpModuleConfig());\n    std::vector<AudioPort> ports = moduleConfig->getExternalDevicePorts();\n    if (ports.empty()) {\n        GTEST_SKIP() << \"No external devices in the module.\";\n    }\n    WithDevicePortConnectedState portConnected(*ports.begin(), GenerateUniqueDeviceAddress());\n    ASSERT_NO_FATAL_FAILURE(portConnected.SetUp(module.get()));\n    ModuleDebug midwayDebugChange = debug.flags();\n    midwayDebugChange.simulateDeviceConnections = false;\n    ScopedAStatus status = module->setModuleDebug(midwayDebugChange);\n    EXPECT_EQ(EX_ILLEGAL_STATE, status.getExceptionCode())\n            << status << \" returned when trying to disable connections simulation \"\n            << \"while having a connected device\";\n}\n\nTEST_P(AudioCoreModule, ConnectDisconnectExternalDeviceInvalidPorts) {\n    AudioPort ignored;\n    std::set<int32_t> portIds;\n    ASSERT_NO_FATAL_FAILURE(GetAllPortIds(&portIds));\n    for (const auto portId : GetNonExistentIds(portIds)) {\n        AudioPort invalidPort;\n        invalidPort.id = portId;\n        ScopedAStatus status = module->connectExternalDevice(invalidPort, &ignored);\n        EXPECT_EQ(EX_ILLEGAL_ARGUMENT, status.getExceptionCode())\n                << status << \" returned for port ID \" << portId << \" when setting CONNECTED state\";\n        status = module->disconnectExternalDevice(portId);\n        EXPECT_EQ(EX_ILLEGAL_ARGUMENT, status.getExceptionCode())\n                << status << \" returned for port ID \" << portId\n                << \" when setting DISCONNECTED state\";\n    }\n\n    std::vector<AudioPort> ports;\n    {\n        ScopedAStatus status = module->getAudioPorts(&ports);\n        ASSERT_EQ(EX_NONE, status.getExceptionCode()) << status;\n    }\n    for (const auto& port : ports) {\n        if (port.ext.getTag() != AudioPortExt::Tag::device) {\n            ScopedAStatus status = module->connectExternalDevice(port, &ignored);\n            EXPECT_EQ(EX_ILLEGAL_ARGUMENT, status.getExceptionCode())\n                    << status << \" returned for non-device port ID \" << port.id\n                    << \" when setting CONNECTED state\";\n            status = module->disconnectExternalDevice(port.id);\n            EXPECT_EQ(EX_ILLEGAL_ARGUMENT, status.getExceptionCode())\n                    << status << \" returned for non-device port ID \" << port.id\n                    << \" when setting DISCONNECTED state\";\n        } else {\n            const auto& devicePort = port.ext.get<AudioPortExt::Tag::device>();\n            if (devicePort.device.type.connection.empty()) {\n                ScopedAStatus status = module->connectExternalDevice(port, &ignored);\n                EXPECT_EQ(EX_ILLEGAL_ARGUMENT, status.getExceptionCode())\n                        << status << \" returned for permanently attached device port ID \" << port.id\n                        << \" when setting CONNECTED state\";\n                status = module->disconnectExternalDevice(port.id);\n                EXPECT_EQ(EX_ILLEGAL_ARGUMENT, status.getExceptionCode())\n                        << status << \" returned for permanently attached device port ID \" << port.id\n                        << \" when setting DISCONNECTED state\";\n            }\n        }\n    }\n}\n\n// Note: This test relies on simulation of external device connections by the HAL module.\nTEST_P(AudioCoreModule, ConnectDisconnectExternalDeviceTwice) {\n    ASSERT_NO_FATAL_FAILURE(SetUpModuleConfig());\n    AudioPort ignored;\n    std::vector<AudioPort> ports = moduleConfig->getExternalDevicePorts();\n    if (ports.empty()) {\n        GTEST_SKIP() << \"No external devices in the module.\";\n    }\n    for (const auto& port : ports) {\n        ScopedAStatus status = module->disconnectExternalDevice(port.id);\n        EXPECT_EQ(EX_ILLEGAL_ARGUMENT, status.getExceptionCode())\n                << status << \" returned when disconnecting already disconnected device port ID \"\n                << port.id;\n        AudioPort portWithData = port;\n        portWithData.ext.get<AudioPortExt::Tag::device>().device.address =\n                GenerateUniqueDeviceAddress();\n        WithDevicePortConnectedState portConnected(portWithData);\n        ASSERT_NO_FATAL_FAILURE(portConnected.SetUp(module.get()));\n        status = module->connectExternalDevice(portConnected.get(), &ignored);\n        EXPECT_EQ(EX_ILLEGAL_ARGUMENT, status.getExceptionCode())\n                << status << \" returned when trying to connect a connected device port \"\n                << portConnected.get().toString();\n        status = module->connectExternalDevice(portWithData, &ignored);\n        EXPECT_EQ(EX_ILLEGAL_STATE, status.getExceptionCode())\n                << status << \" returned when connecting again the external device \"\n                << portWithData.ext.get<AudioPortExt::Tag::device>().device.toString();\n        if (status.getExceptionCode() == EX_NONE) {\n            ADD_FAILURE() << \"Returned connected port \" << ignored.toString() << \" for template \"\n                          << portWithData.toString();\n        }\n    }\n}\n\n// Note: This test relies on simulation of external device connections by the HAL module.\nTEST_P(AudioCoreModule, DisconnectExternalDeviceNonResetPortConfig) {\n    ASSERT_NO_FATAL_FAILURE(SetUpModuleConfig());\n    std::vector<AudioPort> ports = moduleConfig->getExternalDevicePorts();\n    if (ports.empty()) {\n        GTEST_SKIP() << \"No external devices in the module.\";\n    }\n    for (const auto& port : ports) {\n        WithDevicePortConnectedState portConnected(port, GenerateUniqueDeviceAddress());\n        ASSERT_NO_FATAL_FAILURE(portConnected.SetUp(module.get()));\n        const auto portConfig = moduleConfig->getSingleConfigForDevicePort(portConnected.get());\n        {\n            WithAudioPortConfig config(portConfig);\n            // Note: if SetUp fails, check the status of 'GetAudioPortWithExternalDevices' test.\n            // Our test assumes that 'getAudioPort' returns at least one profile, and it\n            // is not a dynamic profile.\n            ASSERT_NO_FATAL_FAILURE(config.SetUp(module.get()));\n            ScopedAStatus status = module->disconnectExternalDevice(portConnected.getId());\n            EXPECT_EQ(EX_ILLEGAL_STATE, status.getExceptionCode())\n                    << status << \" returned when trying to disconnect device port ID \" << port.id\n                    << \" with active configuration \" << config.getId();\n        }\n    }\n}\n\nTEST_P(AudioCoreModule, ExternalDevicePortRoutes) {\n    ASSERT_NO_FATAL_FAILURE(SetUpModuleConfig());\n    std::vector<AudioPort> ports = moduleConfig->getExternalDevicePorts();\n    if (ports.empty()) {\n        GTEST_SKIP() << \"No external devices in the module.\";\n    }\n    for (const auto& port : ports) {\n        std::vector<AudioRoute> routesBefore;\n        {\n            ScopedAStatus status = module->getAudioRoutes(&routesBefore);\n            ASSERT_EQ(EX_NONE, status.getExceptionCode()) << status;\n        }\n\n        int32_t connectedPortId;\n        {\n            WithDevicePortConnectedState portConnected(port, GenerateUniqueDeviceAddress());\n            ASSERT_NO_FATAL_FAILURE(portConnected.SetUp(module.get()));\n            connectedPortId = portConnected.getId();\n            std::vector<AudioRoute> connectedPortRoutes;\n            {\n                ScopedAStatus status =\n                        module->getAudioRoutesForAudioPort(connectedPortId, &connectedPortRoutes);\n                ASSERT_EQ(EX_NONE, status.getExceptionCode())\n                        << status << \" returned when retrieving routes for connected port id \"\n                        << connectedPortId;\n            }\n            // There must be routes for the port to be useful.\n            if (connectedPortRoutes.empty()) {\n                std::vector<AudioRoute> allRoutes;\n                ScopedAStatus status = module->getAudioRoutes(&allRoutes);\n                ASSERT_EQ(EX_NONE, status.getExceptionCode()) << status;\n                ADD_FAILURE() << \" no routes returned for the connected port \"\n                              << portConnected.get().toString()\n                              << \"; all routes: \" << android::internal::ToString(allRoutes);\n            }\n        }\n        std::vector<AudioRoute> ignored;\n        ScopedAStatus status = module->getAudioRoutesForAudioPort(connectedPortId, &ignored);\n        ASSERT_EQ(EX_ILLEGAL_ARGUMENT, status.getExceptionCode())\n                << status << \" returned when retrieving routes for released connected port id \"\n                << connectedPortId;\n\n        std::vector<AudioRoute> routesAfter;\n        {\n            ScopedAStatus status = module->getAudioRoutes(&routesAfter);\n            ASSERT_EQ(EX_NONE, status.getExceptionCode()) << status;\n        }\n        ASSERT_EQ(routesBefore.size(), routesAfter.size())\n                << \"Sizes of audio route arrays do not match after creating and \"\n                << \"releasing a connected port\";\n        std::sort(routesBefore.begin(), routesBefore.end());\n        std::sort(routesAfter.begin(), routesAfter.end());\n        EXPECT_EQ(routesBefore, routesAfter);\n    }\n}\n",
        "lookback": "    ASSERT_NO_FATAL_FAILURE(SetUpModuleConfig());",
        "lookahead": "template <typename Stream>",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 1502,
        "end_line": 1899,
        "merge_gen_region": "_(AudioModule TryMissing) ASSERTNOFATALFAILURESetUpConfig stdvectorAudio> = =());::<Port ports module->ExternalPorts ifportsempty {_() <<No devices the.\"; Audio ignored WithFlagsNotulate = WithFlagscreate();NotSimConnectionsflagssimDevice =;___(Notulate.Upmoduleget forconst& :) AudioPortWith =;___(Notulate.Upmoduleget forconst auto port :) AudioPortWith = port port portDataextgetAudioExtTagdevicedeviceaddress GenerateDevice();A status module->External(With,ignored EXPECTEQEXILLEGALSTATE statusgetCode << << \" for port \" portDatatoString } TESTPAudioCore,ChConnectionMid) ASSERTNOFATALFAILURESetModule());::<Port ports module->ExternalPorts ifportsempty {_() <<No devices the.\"; WithPortStateConnectedportsbegin GenerateDevice());____(Connected.Upmoduleget Module midwayChange debugflags midDebugChangesimDevice =;();way modulesetModule(waymidDebug);__(______ConnectedSet(Connected Module midDebugDebug =.();wayDebug.ulateConnections false ScopedStatus =->Module(wayChangesimDevice",
        "confidence": 0.9368985295295715,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "        for (const auto portConfigId : GetNonExistentIds(portConfigIds)) {\n            EXPECT_NO_FATAL_FAILURE(SetInvalidPatchHelper(EX_ILLEGAL_ARGUMENT, {portConfigId},\n                                                          {sinkPortConfig.getId()}));\n            EXPECT_NO_FATAL_FAILURE(SetInvalidPatchHelper(EX_ILLEGAL_ARGUMENT,",
        "b_contents": "        for (const auto portConfigId : GetNonExistentIds(portConfigIds)) {\n            EXPECT_NO_FATAL_FAILURE(SetInvalidPatchHelper(\n                    Status::EX_ILLEGAL_ARGUMENT, {portConfigId}, {sinkPortConfig.getId()}));\n            EXPECT_NO_FATAL_FAILURE(SetInvalidPatchHelper(Status::EX_ILLEGAL_ARGUMENT,",
        "base_contents": "        for (const auto portConfigId : getNonExistentIds(portConfigIds)) {\n            EXPECT_NO_FATAL_FAILURE(SetInvalidPatchHelper(\n                    Status::EX_ILLEGAL_ARGUMENT, {portConfigId}, {sinkPortConfig.getId()}));\n            EXPECT_NO_FATAL_FAILURE(SetInvalidPatchHelper(Status::EX_ILLEGAL_ARGUMENT,",
        "res_region": "        for (const auto portConfigId : GetNonExistentIds(portConfigIds)) {\n            EXPECT_NO_FATAL_FAILURE(SetInvalidPatchHelper(EX_ILLEGAL_ARGUMENT, {portConfigId},\n                                                          {sinkPortConfig.getId()}));\n            EXPECT_NO_FATAL_FAILURE(SetInvalidPatchHelper(EX_ILLEGAL_ARGUMENT,",
        "lookback": "            EXPECT_NO_FATAL_FAILURE(SetInvalidPatchHelper(EX_ILLEGAL_ARGUMENT, {portConfigId},",
        "lookahead": "                                                          {srcPortConfig.getId()}, {portConfigId}));",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 2303,
        "end_line": 2318,
        "merge_gen_region": "______((StringString>(IdId forconstningConfig :NonentIdsportIds {_____(,__&&&&&&&&&&&&&IdId forconstString&{&&&&&&outputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutput",
        "confidence": 0.8905466794967651,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "    for (const auto patchId : GetNonExistentIds(patchIds)) {\n        ScopedAStatus status = module->resetAudioPatch(patchId);\n        EXPECT_EQ(EX_ILLEGAL_ARGUMENT, status.getExceptionCode())",
        "b_contents": "    for (const auto patchId : GetNonExistentIds(patchIds)) {\n        Status status = module->resetAudioPatch(patchId);\n        EXPECT_EQ(Status::EX_ILLEGAL_ARGUMENT, status.exceptionCode())",
        "base_contents": "    for (const auto patchId : getNonExistentIds(patchIds)) {\n        Status status = module->resetAudioPatch(patchId);\n        EXPECT_EQ(Status::EX_ILLEGAL_ARGUMENT, status.exceptionCode())",
        "res_region": "    for (const auto patchId : GetNonExistentIds(patchIds)) {\n        ScopedAStatus status = module->resetAudioPatch(patchId);\n        EXPECT_EQ(EX_ILLEGAL_ARGUMENT, status.getExceptionCode())",
        "lookback": "        ScopedAStatus status = module->resetAudioPatch(patchId);",
        "lookahead": "                << status << \" returned for patch ID \" << patchId;",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 2413,
        "end_line": 2425,
        "merge_gen_region": null,
        "confidence": 0.8758585453033447,
        "hesitated": true
    }
]