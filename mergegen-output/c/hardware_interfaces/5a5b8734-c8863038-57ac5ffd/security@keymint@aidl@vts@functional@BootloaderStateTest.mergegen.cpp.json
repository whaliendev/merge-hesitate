[
    {
        "a_contents": "class BootloaderStateTest : public KeyMintAidlTestBase {\n  public:\n    virtual void SetUp() override {\n        KeyMintAidlTestBase::SetUp();\n\n        // Generate a key with attestation.\n        vector<uint8_t> key_blob;\n        vector<KeyCharacteristics> key_characteristics;\n        AuthorizationSet keyDesc = AuthorizationSetBuilder()\n                                           .Authorization(TAG_NO_AUTH_REQUIRED)\n                                           .EcdsaSigningKey(EcCurve::P_256)\n                                           .AttestationChallenge(\"foo\")\n                                           .AttestationApplicationId(\"bar\")\n                                           .Digest(Digest::NONE)\n                                           .SetDefaultValidity();\n        auto result = GenerateKey(keyDesc, &key_blob, &key_characteristics);\n        // If factory provisioned attestation key is not supported by Strongbox,\n        // then create a key with self-signed attestation and use it as the\n        // attestation key instead.\n        if (SecLevel() == SecurityLevel::STRONGBOX &&\n            result == ErrorCode::ATTESTATION_KEYS_NOT_PROVISIONED) {\n            result = GenerateKeyWithSelfSignedAttestKey(\n                    AuthorizationSetBuilder()\n                            .EcdsaKey(EcCurve::P_256)\n                            .AttestKey()\n                            .SetDefaultValidity(), /* attest key params */\n                    keyDesc, &key_blob, &key_characteristics);\n        }\n        ASSERT_EQ(ErrorCode::OK, result);\n\n        // Parse attested AVB values.\n        X509_Ptr cert(parse_cert_blob(cert_chain_[0].encodedCertificate));\n        ASSERT_TRUE(cert.get());\n\n        ASN1_OCTET_STRING* attest_rec = get_attestation_record(cert.get());\n        ASSERT_TRUE(attest_rec);\n\n        auto error = parse_root_of_trust(attest_rec->data, attest_rec->length, &attestedVbKey_,\n                                         &attestedVbState_, &attestedBootloaderState_,\n                                         &attestedVbmetaDigest_);\n        ASSERT_EQ(error, ErrorCode::OK);\n    }\n\n    vector<uint8_t> attestedVbKey_;\n    VerifiedBoot attestedVbState_;\n    bool attestedBootloaderState_;\n    vector<uint8_t> attestedVbmetaDigest_;\n};",
        "b_contents": "class BootloaderStateTest : public KeyMintAidlTestBase {};",
        "base_contents": "class BootloaderStateTest : public testing::TestWithParam<std::string> {\n  public:\n    virtual void SetUp() override {\n        ::ndk::SpAIBinder binder(AServiceManager_waitForService(GetParam().c_str()));\n        keyMint_ = IKeyMintDevice::fromBinder(binder);\n        ASSERT_TRUE(keyMint_) << \"Failed to get KM device\";\n    }\n\n    std::shared_ptr<IKeyMintDevice> keyMint_;\n};",
        "res_region": "class BootloaderStateTest : public KeyMintAidlTestBase {\n  public:\n    virtual void SetUp() override {\n        KeyMintAidlTestBase::SetUp();\n\n        // Generate a key with attestation.\n        vector<uint8_t> key_blob;\n        vector<KeyCharacteristics> key_characteristics;\n        AuthorizationSet keyDesc = AuthorizationSetBuilder()\n                                           .Authorization(TAG_NO_AUTH_REQUIRED)\n                                           .EcdsaSigningKey(EcCurve::P_256)\n                                           .AttestationChallenge(\"foo\")\n                                           .AttestationApplicationId(\"bar\")\n                                           .Digest(Digest::NONE)\n                                           .SetDefaultValidity();\n        auto result = GenerateKey(keyDesc, &key_blob, &key_characteristics);\n        // If factory provisioned attestation key is not supported by Strongbox,\n        // then create a key with self-signed attestation and use it as the\n        // attestation key instead.\n        if (SecLevel() == SecurityLevel::STRONGBOX &&\n            result == ErrorCode::ATTESTATION_KEYS_NOT_PROVISIONED) {\n            result = GenerateKeyWithSelfSignedAttestKey(\n                    AuthorizationSetBuilder()\n                            .EcdsaKey(EcCurve::P_256)\n                            .AttestKey()\n                            .SetDefaultValidity(), /* attest key params */\n                    keyDesc, &key_blob, &key_characteristics);\n        }\n        ASSERT_EQ(ErrorCode::OK, result);\n\n        // Parse attested AVB values.\n        X509_Ptr cert(parse_cert_blob(cert_chain_[0].encodedCertificate));\n        ASSERT_TRUE(cert.get());\n\n        ASN1_OCTET_STRING* attest_rec = get_attestation_record(cert.get());\n        ASSERT_TRUE(attest_rec);\n\n        auto error = parse_root_of_trust(attest_rec->data, attest_rec->length, &attestedVbKey_,\n                                         &attestedVbState_, &attestedBootloaderState_,\n                                         &attestedVbmetaDigest_);\n        ASSERT_EQ(error, ErrorCode::OK);\n    }\n\n    vector<uint8_t> attestedVbKey_;\n    VerifiedBoot attestedVbState_;\n    bool attestedBootloaderState_;\n    vector<uint8_t> attestedVbmetaDigest_;\n};",
        "lookback": "  public:",
        "lookahead": "",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 40,
        "end_line": 102,
        "merge_gen_region": " BootState : KeyintATest {: void() {MATest::Up // a withte.<<8_> keyblob vectorKeyistics keycharacter;ization key =izationBuilder .izationTAGNOAUTHREQUIRED .EsacyKeyECurveP256 .teteChallengefoo .testationAtstationIdbar .(::)SetDefaultity auto =Keykey,keyblob &_,keycharacter); If proedte key is supported Strbox // create key selfsignedte and it the atstation instead ifSec() Security::BOX result ==CodeATSTATIONKEYSNOTPROED { =KeySelfSignedtestKey AuthorSetBuilder .cdKeyECurveP256 .AtKey .Valid(), attest params key */Desc &_,keyblob &_istics }_(::,); ASSERTEQErrorCodeOK result // ated AV values X_ certparsecertblobcert_(__[0encoded));_(.());1OCTETSTRING at_ =______(testrecdata at_->length &testedbKey &testVState &testedbDigest ASSERTEQerror Error::); vectoruint_>testVState &testVmeta_);_(,CodeOK }<8t at",
        "confidence": 0.9526144862174988,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "TEST_P(BootloaderStateTest, BootloaderIsUnlocked) {\n    ASSERT_FALSE(attestedBootloaderState_)\n            << \"This test runs as root. Bootloader must be unlocked.\";\n}\n\n// Check that verified boot state is set to \"unverified\", i.e. \"orange\".\nTEST_P(BootloaderStateTest, VbStateIsUnverified) {\n    // Unlocked bootloader implies that verified boot state must be \"unverified\".\n    ASSERT_EQ(attestedVbState_, VerifiedBoot::UNVERIFIED)\n            << \"Verified boot state must be \\\"UNVERIFIED\\\" aka \\\"orange\\\".\";\n\n    // AVB spec stipulates that bootloader must set \"androidboot.verifiedbootstate\" parameter\n    // on the kernel command-line. This parameter is exposed to userspace as\n    // \"ro.boot.verifiedbootstate\" property.\n    auto vbStateProp = ::android::base::GetProperty(\"ro.boot.verifiedbootstate\", \"\");\n    ASSERT_EQ(vbStateProp, \"orange\")\n            << \"Verified boot state must be \\\"UNVERIFIED\\\" aka \\\"orange\\\".\";\n}\n\n// Following error codes from avb_slot_data() mean that slot data was loaded\n// (even if verification failed).\nstatic inline bool avb_slot_data_loaded(AvbSlotVerifyResult result) {\n    switch (result) {\n        case AVB_SLOT_VERIFY_RESULT_OK:\n        case AVB_SLOT_VERIFY_RESULT_ERROR_VERIFICATION:\n        case AVB_SLOT_VERIFY_RESULT_ERROR_ROLLBACK_INDEX:\n        case AVB_SLOT_VERIFY_RESULT_ERROR_PUBLIC_KEY_REJECTED:\n            return true;\n        default:\n            return false;\n    }\n}\n\n// Check that attested vbmeta digest is correct.\nTEST_P(BootloaderStateTest, VbmetaDigest) {\n    AvbSlotVerifyData* avbSlotData;\n    auto suffix = fs_mgr_get_slot_suffix();\n    const char* partitions[] = {nullptr};\n    auto avbOps = avb_ops_user_new();\n\n    // For VTS, devices run with vendor_boot-debug.img, which is not release key\n    // signed. Use AVB_SLOT_VERIFY_FLAGS_ALLOW_VERIFICATION_ERROR to bypass avb\n    // verification errors. This is OK since we only care about the digest for\n    // this test case.\n    auto result = avb_slot_verify(avbOps, partitions, suffix.c_str(),\n                                  AVB_SLOT_VERIFY_FLAGS_ALLOW_VERIFICATION_ERROR,\n                                  AVB_HASHTREE_ERROR_MODE_EIO, &avbSlotData);\n    ASSERT_TRUE(avb_slot_data_loaded(result)) << \"Failed to load avb slot data\";\n\n    // Unfortunately, bootloader is not required to report the algorithm used\n    // to calculate the digest. There are only two supported options though,\n    // SHA256 and SHA512. Attested VBMeta digest must match one of these.\n    vector<uint8_t> digest256(AVB_SHA256_DIGEST_SIZE);\n    vector<uint8_t> digest512(AVB_SHA512_DIGEST_SIZE);\n\n    avb_slot_verify_data_calculate_vbmeta_digest(avbSlotData, AVB_DIGEST_TYPE_SHA256,\n                                                 digest256.data());\n    avb_slot_verify_data_calculate_vbmeta_digest(avbSlotData, AVB_DIGEST_TYPE_SHA512,\n                                                 digest512.data());\n\n    ASSERT_TRUE((attestedVbmetaDigest_ == digest256) || (attestedVbmetaDigest_ == digest512))\n            << \"Attested digest does not match computed digest.\";",
        "b_contents": "TEST_P(BootloaderStateTest, IsUnlocked) {\n    // Generate a key with attestation.\n    vector<uint8_t> key_blob;\n    vector<KeyCharacteristics> key_characteristics;\n    AuthorizationSet keyDesc = AuthorizationSetBuilder()\n                                       .Authorization(TAG_NO_AUTH_REQUIRED)\n                                       .EcdsaSigningKey(EcCurve::P_256)\n                                       .AttestationChallenge(\"foo\")\n                                       .AttestationApplicationId(\"bar\")\n                                       .Digest(Digest::NONE)\n                                       .SetDefaultValidity();\n    auto result = GenerateKey(keyDesc, &key_blob, &key_characteristics);\n    // If factory provisioned attestation key is not supported by Strongbox,\n    // then create a key with self-signed attestation and use it as the\n    // attestation key instead.\n    if (SecLevel() == SecurityLevel::STRONGBOX &&\n        result == ErrorCode::ATTESTATION_KEYS_NOT_PROVISIONED) {\n        result = GenerateKeyWithSelfSignedAttestKey(\n                AuthorizationSetBuilder()\n                        .EcdsaKey(EcCurve::P_256)\n                        .AttestKey()\n                        .SetDefaultValidity(), /* attest key params */\n                keyDesc, &key_blob, &key_characteristics);\n    }\n    ASSERT_EQ(ErrorCode::OK, result);\n\n    // Parse attested AVB values.\n    X509_Ptr cert(parse_cert_blob(cert_chain_[0].encodedCertificate));\n    ASSERT_TRUE(cert.get());\n\n    ASN1_OCTET_STRING* attest_rec = get_attestation_record(cert.get());\n    ASSERT_TRUE(attest_rec);\n\n    vector<uint8_t> key;\n    VerifiedBoot attestedVbState;\n    bool attestedBootloaderState;\n    vector<uint8_t> attestedVbmetaDigest;\n    auto error = parse_root_of_trust(attest_rec->data, attest_rec->length, &key, &attestedVbState,\n                                     &attestedBootloaderState, &attestedVbmetaDigest);\n    ASSERT_EQ(error, ErrorCode::OK);\n    ASSERT_FALSE(attestedBootloaderState) << \"This test runs as root. Bootloader must be unlocked.\";",
        "base_contents": "TEST_P(BootloaderStateTest, IsUnlocked) {\n    // Generate a key with attestation.\n    AuthorizationSet keyDesc = AuthorizationSetBuilder()\n                                       .Authorization(TAG_NO_AUTH_REQUIRED)\n                                       .EcdsaSigningKey(EcCurve::P_256)\n                                       .AttestationChallenge(\"foo\")\n                                       .AttestationApplicationId(\"bar\")\n                                       .Digest(Digest::NONE)\n                                       .SetDefaultValidity();\n    KeyCreationResult creationResult;\n    auto kmStatus = keyMint_->generateKey(keyDesc.vector_data(), std::nullopt, &creationResult);\n    ASSERT_TRUE(kmStatus.isOk());\n\n    vector<Certificate> key_cert_chain = std::move(creationResult.certificateChain);\n\n    // Parse attested AVB values.\n    const auto& attestation_cert = key_cert_chain[0].encodedCertificate;\n    X509_Ptr cert(parse_cert_blob(attestation_cert));\n    ASSERT_TRUE(cert.get());\n\n    ASN1_OCTET_STRING* attest_rec = get_attestation_record(cert.get());\n    ASSERT_TRUE(attest_rec);\n\n    vector<uint8_t> key;\n    VerifiedBoot attestedVbState;\n    bool attestedBootloaderState;\n    vector<uint8_t> attestedVbmetaDigest;\n    auto error = parse_root_of_trust(attest_rec->data, attest_rec->length, &key, &attestedVbState,\n                                     &attestedBootloaderState, &attestedVbmetaDigest);\n    ASSERT_EQ(error, ErrorCode::OK);\n    ASSERT_FALSE(attestedBootloaderState) << \"This test runs as root. Bootloader must be unlocked.\";",
        "res_region": "TEST_P(BootloaderStateTest, BootloaderIsUnlocked) {\n    ASSERT_FALSE(attestedBootloaderState_)\n            << \"This test runs as root. Bootloader must be unlocked.\";\n}\n\n// Check that verified boot state is set to \"unverified\", i.e. \"orange\".\nTEST_P(BootloaderStateTest, VbStateIsUnverified) {\n    // Unlocked bootloader implies that verified boot state must be \"unverified\".\n    ASSERT_EQ(attestedVbState_, VerifiedBoot::UNVERIFIED)\n            << \"Verified boot state must be \\\"UNVERIFIED\\\" aka \\\"orange\\\".\";\n\n    // AVB spec stipulates that bootloader must set \"androidboot.verifiedbootstate\" parameter\n    // on the kernel command-line. This parameter is exposed to userspace as\n    // \"ro.boot.verifiedbootstate\" property.\n    auto vbStateProp = ::android::base::GetProperty(\"ro.boot.verifiedbootstate\", \"\");\n    ASSERT_EQ(vbStateProp, \"orange\")\n            << \"Verified boot state must be \\\"UNVERIFIED\\\" aka \\\"orange\\\".\";\n}\n\n// Following error codes from avb_slot_data() mean that slot data was loaded\n// (even if verification failed).\nstatic inline bool avb_slot_data_loaded(AvbSlotVerifyResult result) {\n    switch (result) {\n        case AVB_SLOT_VERIFY_RESULT_OK:\n        case AVB_SLOT_VERIFY_RESULT_ERROR_VERIFICATION:\n        case AVB_SLOT_VERIFY_RESULT_ERROR_ROLLBACK_INDEX:\n        case AVB_SLOT_VERIFY_RESULT_ERROR_PUBLIC_KEY_REJECTED:\n            return true;\n        default:\n            return false;\n    }\n}\n\n// Check that attested vbmeta digest is correct.\nTEST_P(BootloaderStateTest, VbmetaDigest) {\n    AvbSlotVerifyData* avbSlotData;\n    auto suffix = fs_mgr_get_slot_suffix();\n    const char* partitions[] = {nullptr};\n    auto avbOps = avb_ops_user_new();\n\n    // For VTS, devices run with vendor_boot-debug.img, which is not release key\n    // signed. Use AVB_SLOT_VERIFY_FLAGS_ALLOW_VERIFICATION_ERROR to bypass avb\n    // verification errors. This is OK since we only care about the digest for\n    // this test case.\n    auto result = avb_slot_verify(avbOps, partitions, suffix.c_str(),\n                                  AVB_SLOT_VERIFY_FLAGS_ALLOW_VERIFICATION_ERROR,\n                                  AVB_HASHTREE_ERROR_MODE_EIO, &avbSlotData);\n    ASSERT_TRUE(avb_slot_data_loaded(result)) << \"Failed to load avb slot data\";\n\n    // Unfortunately, bootloader is not required to report the algorithm used\n    // to calculate the digest. There are only two supported options though,\n    // SHA256 and SHA512. Attested VBMeta digest must match one of these.\n    vector<uint8_t> digest256(AVB_SHA256_DIGEST_SIZE);\n    vector<uint8_t> digest512(AVB_SHA512_DIGEST_SIZE);\n\n    avb_slot_verify_data_calculate_vbmeta_digest(avbSlotData, AVB_DIGEST_TYPE_SHA256,\n                                                 digest256.data());\n    avb_slot_verify_data_calculate_vbmeta_digest(avbSlotData, AVB_DIGEST_TYPE_SHA512,\n                                                 digest512.data());\n\n    ASSERT_TRUE((attestedVbmetaDigest_ == digest256) || (attestedVbmetaDigest_ == digest512))\n            << \"Attested digest does not match computed digest.\";",
        "lookback": "    ASSERT_FALSE(attestedBootloaderState_)",
        "lookahead": "}",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 105,
        "end_line": 242,
        "merge_gen_region": "_(testBootStateTESTPBootStateTest BootIslocked {_(testBootState <<This runs root Boot must unlocked } Check verified state set tounver\", ie \"or\"._(loaderTest VStateUnified { Un bootloader that boot must \"unified\"._(testVState VerBootUNI) \"ifiedified state beUNVERFIED a \\\"or\\\" //B stulates bootloader setandroid.ifiedboot\" parameter on kernel commandline This parameter exposed userspace //robootverboot\"..ifiedstate property autoState =androidbaseGetPropertyro...ifiedboot\", ASSERT_(EQvbState,or\") \"ifiedified state beUNVERFIED a \\\"or\\\" } Follow error from av___(State,or\") \"ified state beUNIFIED a \\\"or\\\" } Follow error from",
        "confidence": 0.9118978977203369,
        "hesitated": false,
        "resolved": false
    }
]