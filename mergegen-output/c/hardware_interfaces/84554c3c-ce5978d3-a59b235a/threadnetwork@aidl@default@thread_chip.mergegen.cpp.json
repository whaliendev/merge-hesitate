[
    {
        "a_contents": "/*\n * Copyright (C) 2022 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"thread_chip.hpp\"\n\n#include <android-base/logging.h>\n#include <android/binder_auto_utils.h>\n#include <android/binder_ibinder.h>\n#include <android/binder_manager.h>\n#include <android/binder_process.h>\n#include <utils/Log.h>\n\n#include \"hdlc_interface.hpp\"\n#include \"spi_interface.hpp\"\n\nnamespace aidl {\nnamespace android {\nnamespace hardware {\nnamespace threadnetwork {\n\nThreadChip::ThreadChip(char* url) : mUrl(), mRxFrameBuffer(), mCallback(nullptr) {\n    static const char kHdlcProtocol[] = \"spinel+hdlc\";\n    static const char kSpiProtocol[] = \"spinel+spi\";\n    const char* protocol;\n\n    CHECK_EQ(mUrl.Init(url), 0);\n\n    protocol = mUrl.GetProtocol();\n    CHECK_NE(protocol, nullptr);\n\n    if (memcmp(protocol, kSpiProtocol, strlen(kSpiProtocol)) == 0) {\n        mSpinelInterface = std::make_shared<ot::Posix::SpiInterface>(handleReceivedFrameJump, this,\n                                                                     mRxFrameBuffer);\n    } else if (memcmp(protocol, kHdlcProtocol, strlen(kHdlcProtocol)) == 0) {\n        mSpinelInterface = std::make_shared<ot::Posix::HdlcInterface>(handleReceivedFrameJump, this,\n                                                                      mRxFrameBuffer);\n    } else {\n        ALOGE(\"The protocol \\\"%s\\\" is not supported\", protocol);\n        exit(EXIT_FAILURE);\n    }\n\n    CHECK_NE(mSpinelInterface, nullptr);\n\n    mDeathRecipient = ndk::ScopedAIBinder_DeathRecipient(\n            AIBinder_DeathRecipient_new(ThreadChip::onBinderDiedJump));\n    AIBinder_DeathRecipient_setOnUnlinked(mDeathRecipient.get(), ThreadChip::onBinderUnlinkedJump);\n}\n\nvoid ThreadChip::onBinderDiedJump(void* context) {\n    reinterpret_cast<ThreadChip*>(context)->onBinderDied();\n}\n\nvoid ThreadChip::onBinderDied(void) {\n    ALOGW(\"Thread Network HAL client is dead\");\n}\n\nvoid ThreadChip::onBinderUnlinkedJump(void* context) {\n    reinterpret_cast<ThreadChip*>(context)->onBinderUnlinked();\n}\n\nvoid ThreadChip::onBinderUnlinked(void) {\n    ALOGW(\"ThreadChip binder is unlinked\");\n    deinitChip();\n}\n\nvoid ThreadChip::handleReceivedFrameJump(void* context) {\n    static_cast<ThreadChip*>(context)->handleReceivedFrame();\n}\n\nvoid ThreadChip::handleReceivedFrame(void) {\n    if (mCallback != nullptr) {\n        mCallback->onReceiveSpinelFrame(std::vector<uint8_t>(\n                mRxFrameBuffer.GetFrame(), mRxFrameBuffer.GetFrame() + mRxFrameBuffer.GetLength()));\n    }\n\n    mRxFrameBuffer.DiscardFrame();\n}\n\nndk::ScopedAStatus ThreadChip::open(const std::shared_ptr<IThreadChipCallback>& in_callback) {\n    ndk::ScopedAStatus status = initChip(in_callback);\n\n    if (status.isOk()) {\n        AIBinder_linkToDeath(in_callback->asBinder().get(), mDeathRecipient.get(), this);\n        ALOGI(\"Open IThreadChip successfully\");\n    } else {\n        ALOGW(\"Failed to open IThreadChip: %s\", status.getDescription().c_str());\n    }\n\n    return status;\n}\n\nndk::ScopedAStatus ThreadChip::initChip(const std::shared_ptr<IThreadChipCallback>& in_callback) {\n    if (in_callback == nullptr) {\n        return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);\n    } else if (mCallback == nullptr) {\n        if (mSpinelInterface->Init(mUrl) != OT_ERROR_NONE) {\n            return errorStatus(ERROR_FAILED, \"Failed to initialize the interface\");\n        }\n\n        mCallback = in_callback;\n        ot::Posix::Mainloop::Manager::Get().Add(*this);\n        return ndk::ScopedAStatus::ok();\n    } else {\n        return errorStatus(ERROR_BUSY, \"Interface has been opened\");\n    }\n}\n\nndk::ScopedAStatus ThreadChip::close() {\n    ndk::ScopedAStatus status;\n    std::shared_ptr<IThreadChipCallback> callback = mCallback;\n\n    status = deinitChip();\n    if (status.isOk()) {\n        if (callback != nullptr) {\n            AIBinder_unlinkToDeath(callback->asBinder().get(), mDeathRecipient.get(), this);\n        }\n\n        ALOGI(\"Close IThreadChip successfully\");\n    } else {\n        ALOGW(\"Failed to close IThreadChip: %s\", status.getDescription().c_str());\n    }\n\n    return status;\n}\n\nndk::ScopedAStatus ThreadChip::deinitChip() {\n    if (mCallback != nullptr) {\n        mSpinelInterface->Deinit();\n        ot::Posix::Mainloop::Manager::Get().Remove(*this);\n        mCallback = nullptr;\n        return ndk::ScopedAStatus::ok();\n    }\n\n    return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_STATE);\n}\n\nndk::ScopedAStatus ThreadChip::sendSpinelFrame(const std::vector<uint8_t>& in_frame) {\n    ndk::ScopedAStatus status;\n    otError error;\n\n    if (mCallback == nullptr) {\n        status = errorStatus(ERROR_FAILED, \"The interface is not open\");\n    } else {\n        error = mSpinelInterface->SendFrame(reinterpret_cast<const uint8_t*>(in_frame.data()),\n                                            in_frame.size());\n        if (error == OT_ERROR_NONE) {\n            status = ndk::ScopedAStatus::ok();\n        } else if (error == OT_ERROR_NO_BUFS) {\n            status = errorStatus(ERROR_NO_BUFS, \"Insufficient buffer space to send\");\n        } else if (error == OT_ERROR_BUSY) {\n            status = errorStatus(ERROR_BUSY, \"The interface is busy\");\n        } else {\n            status = errorStatus(ERROR_FAILED, \"Failed to send the spinel frame\");\n        }\n    }\n\n    if (!status.isOk()) {\n        ALOGW(\"Send spinel frame failed, error: %s\", status.getDescription().c_str());\n    }\n\n    return status;\n}\n\nndk::ScopedAStatus ThreadChip::hardwareReset() {\n    if (mSpinelInterface->HardwareReset() == OT_ERROR_NOT_IMPLEMENTED) {\n        return ndk::ScopedAStatus::fromExceptionCode(EX_UNSUPPORTED_OPERATION);\n    }\n\n    ALOGI(\"reset()\");\n    return ndk::ScopedAStatus::ok();\n}\n\nvoid ThreadChip::Update(otSysMainloopContext& context) {\n    if (mCallback != nullptr) {\n        mSpinelInterface->UpdateFdSet(&context);\n    }\n}\n\nvoid ThreadChip::Process(const otSysMainloopContext& context) {\n    if (mCallback != nullptr) {\n        mSpinelInterface->Process(&context);\n    }\n}\n\nndk::ScopedAStatus ThreadChip::errorStatus(int32_t error, const char* message) {\n    return ndk::ScopedAStatus(AStatus_fromServiceSpecificErrorWithMessage(error, message));\n}\n}  // namespace threadnetwork\n}  // namespace hardware\n}  // namespace android\n}  // namespace aidl",
        "b_contents": "/*\n * Copyright (C) 2022 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"thread_chip.hpp\"\n\n#include <android-base/logging.h>\n#include <android/binder_auto_utils.h>\n#include <android/binder_ibinder.h>\n#include <android/binder_manager.h>\n#include <android/binder_process.h>\n#include <utils/Log.h>\n\n#include \"hdlc_interface.hpp\"\n#include \"spi_interface.hpp\"\n\nnamespace aidl {\nnamespace android {\nnamespace hardware {\nnamespace threadnetwork {\n\nThreadChip::ThreadChip(char* url) : mUrl(), mRxFrameBuffer(), mCallback(nullptr) {\n    static const char kHdlcProtocol[] = \"spinel+hdlc\";\n    static const char kSpiProtocol[] = \"spinel+spi\";\n    const char* protocol;\n\n    CHECK_EQ(mUrl.Init(url), 0);\n\n    protocol = mUrl.GetProtocol();\n    CHECK_NE(protocol, nullptr);\n\n    if (memcmp(protocol, kSpiProtocol, strlen(kSpiProtocol)) == 0) {\n        mSpinelInterface = std::make_shared<ot::Posix::SpiInterface>(handleReceivedFrameJump, this,\n                                                                     mRxFrameBuffer);\n    } else if (memcmp(protocol, kHdlcProtocol, strlen(kHdlcProtocol)) == 0) {\n        mSpinelInterface = std::make_shared<ot::Posix::HdlcInterface>(handleReceivedFrameJump, this,\n                                                                      mRxFrameBuffer);\n    } else {\n        ALOGE(\"The protocol \\\"%s\\\" is not supported\", protocol);\n        exit(EXIT_FAILURE);\n    }\n\n    CHECK_NE(mSpinelInterface, nullptr);\n\n    mDeathRecipient = ndk::ScopedAIBinder_DeathRecipient(\n            AIBinder_DeathRecipient_new(ThreadChip::onBinderDiedJump));\n    AIBinder_DeathRecipient_setOnUnlinked(mDeathRecipient.get(), ThreadChip::onBinderUnlinkedJump);\n}\n\nThreadChip::~ThreadChip() {\n    AIBinder_DeathRecipient_delete(mDeathRecipient.get());\n}\n\nvoid ThreadChip::onBinderDiedJump(void* context) {\n    reinterpret_cast<ThreadChip*>(context)->onBinderDied();\n}\n\nvoid ThreadChip::onBinderDied(void) {\n    ALOGW(\"Thread Network HAL client is dead\");\n}\n\nvoid ThreadChip::onBinderUnlinkedJump(void* context) {\n    reinterpret_cast<ThreadChip*>(context)->onBinderUnlinked();\n}\n\nvoid ThreadChip::onBinderUnlinked(void) {\n    ALOGW(\"ThreadChip binder is unlinked\");\n    deinitChip();\n}\n\nvoid ThreadChip::handleReceivedFrameJump(void* context) {\n    static_cast<ThreadChip*>(context)->handleReceivedFrame();\n}\n\nvoid ThreadChip::handleReceivedFrame(void) {\n    if (mCallback != nullptr) {\n        mCallback->onReceiveSpinelFrame(std::vector<uint8_t>(\n                mRxFrameBuffer.GetFrame(), mRxFrameBuffer.GetFrame() + mRxFrameBuffer.GetLength()));\n    }\n\n    mRxFrameBuffer.DiscardFrame();\n}\n\nndk::ScopedAStatus ThreadChip::open(const std::shared_ptr<IThreadChipCallback>& in_callback) {\n    ndk::ScopedAStatus status = initChip(in_callback);\n\n    if (status.isOk()) {\n        AIBinder_linkToDeath(in_callback->asBinder().get(), mDeathRecipient.get(), this);\n        ALOGI(\"Open IThreadChip successfully\");\n    } else {\n        ALOGW(\"Failed to open IThreadChip: %s\", status.getDescription().c_str());\n    }\n\n    return status;\n}\n\nndk::ScopedAStatus ThreadChip::initChip(const std::shared_ptr<IThreadChipCallback>& in_callback) {\n    if (in_callback == nullptr) {\n        return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);\n    } else if (mCallback == nullptr) {\n        if (mSpinelInterface->Init(mUrl) != OT_ERROR_NONE) {\n            return errorStatus(ERROR_FAILED, \"Failed to initialize the interface\");\n        }\n\n        mCallback = in_callback;\n        ot::Posix::Mainloop::Manager::Get().Add(*this);\n        return ndk::ScopedAStatus::ok();\n    } else {\n        return errorStatus(ERROR_BUSY, \"Interface has been opened\");\n    }\n}\n\nndk::ScopedAStatus ThreadChip::close() {\n    ndk::ScopedAStatus status;\n    std::shared_ptr<IThreadChipCallback> callback = mCallback;\n\n    status = deinitChip();\n    if (status.isOk()) {\n        if (callback != nullptr) {\n            AIBinder_unlinkToDeath(callback->asBinder().get(), mDeathRecipient.get(), this);\n        }\n\n        ALOGI(\"Close IThreadChip successfully\");\n    } else {\n        ALOGW(\"Failed to close IThreadChip: %s\", status.getDescription().c_str());\n    }\n\n    return status;\n}\n\nndk::ScopedAStatus ThreadChip::deinitChip() {\n    if (mCallback != nullptr) {\n        mSpinelInterface->Deinit();\n        ot::Posix::Mainloop::Manager::Get().Remove(*this);\n        mCallback = nullptr;\n        return ndk::ScopedAStatus::ok();\n    }\n\n    return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_STATE);\n}\n\nndk::ScopedAStatus ThreadChip::sendSpinelFrame(const std::vector<uint8_t>& in_frame) {\n    ndk::ScopedAStatus status;\n    otError error;\n\n    if (mCallback == nullptr) {\n        status = errorStatus(ERROR_FAILED, \"The interface is not open\");\n    } else {\n        error = mSpinelInterface->SendFrame(reinterpret_cast<const uint8_t*>(in_frame.data()),\n                                            in_frame.size());\n        if (error == OT_ERROR_NONE) {\n            status = ndk::ScopedAStatus::ok();\n        } else if (error == OT_ERROR_NO_BUFS) {\n            status = errorStatus(ERROR_NO_BUFS, \"Insufficient buffer space to send\");\n        } else if (error == OT_ERROR_BUSY) {\n            status = errorStatus(ERROR_BUSY, \"The interface is busy\");\n        } else {\n            status = errorStatus(ERROR_FAILED, \"Failed to send the spinel frame\");\n        }\n    }\n\n    if (!status.isOk()) {\n        ALOGW(\"Send spinel frame failed, error: %s\", status.getDescription().c_str());\n    }\n\n    return status;\n}\n\nndk::ScopedAStatus ThreadChip::hardwareReset() {\n    if (mSpinelInterface->HardwareReset() == OT_ERROR_NOT_IMPLEMENTED) {\n        return ndk::ScopedAStatus::fromExceptionCode(EX_UNSUPPORTED_OPERATION);\n    }\n\n    ALOGI(\"reset()\");\n    return ndk::ScopedAStatus::ok();\n}\n\nvoid ThreadChip::Update(otSysMainloopContext& context) {\n    if (mCallback != nullptr) {\n        mSpinelInterface->UpdateFdSet(&context);\n    }\n}\n\nvoid ThreadChip::Process(const otSysMainloopContext& context) {\n    if (mCallback != nullptr) {\n        mSpinelInterface->Process(&context);\n    }\n}\n\nndk::ScopedAStatus ThreadChip::errorStatus(int32_t error, const char* message) {\n    return ndk::ScopedAStatus(AStatus_fromServiceSpecificErrorWithMessage(error, message));\n}\n}  // namespace threadnetwork\n}  // namespace hardware\n}  // namespace android\n}  // namespace aidl",
        "base_contents": "",
        "res_region": "/*\n * Copyright (C) 2022 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"thread_chip.hpp\"\n\n#include <android-base/logging.h>\n#include <android/binder_auto_utils.h>\n#include <android/binder_ibinder.h>\n#include <android/binder_manager.h>\n#include <android/binder_process.h>\n#include <utils/Log.h>\n\n#include \"hdlc_interface.hpp\"\n#include \"spi_interface.hpp\"\n\nnamespace aidl {\nnamespace android {\nnamespace hardware {\nnamespace threadnetwork {\n\nThreadChip::ThreadChip(char* url) : mUrl(), mRxFrameBuffer(), mCallback(nullptr) {\n    static const char kHdlcProtocol[] = \"spinel+hdlc\";\n    static const char kSpiProtocol[] = \"spinel+spi\";\n    const char* protocol;\n\n    CHECK_EQ(mUrl.Init(url), 0);\n\n    protocol = mUrl.GetProtocol();\n    CHECK_NE(protocol, nullptr);\n\n    if (memcmp(protocol, kSpiProtocol, strlen(kSpiProtocol)) == 0) {\n        mSpinelInterface = std::make_shared<ot::Posix::SpiInterface>(handleReceivedFrameJump, this,\n                                                                     mRxFrameBuffer);\n    } else if (memcmp(protocol, kHdlcProtocol, strlen(kHdlcProtocol)) == 0) {\n        mSpinelInterface = std::make_shared<ot::Posix::HdlcInterface>(handleReceivedFrameJump, this,\n                                                                      mRxFrameBuffer);\n    } else {\n        ALOGE(\"The protocol \\\"%s\\\" is not supported\", protocol);\n        exit(EXIT_FAILURE);\n    }\n\n    CHECK_NE(mSpinelInterface, nullptr);\n\n    mDeathRecipient = ndk::ScopedAIBinder_DeathRecipient(\n            AIBinder_DeathRecipient_new(ThreadChip::onBinderDiedJump));\n    AIBinder_DeathRecipient_setOnUnlinked(mDeathRecipient.get(), ThreadChip::onBinderUnlinkedJump);\n}\n\nvoid ThreadChip::onBinderDiedJump(void* context) {\n    reinterpret_cast<ThreadChip*>(context)->onBinderDied();\n}\n\nvoid ThreadChip::onBinderDied(void) {\n    ALOGW(\"Thread Network HAL client is dead\");\n}\n\nvoid ThreadChip::onBinderUnlinkedJump(void* context) {\n    reinterpret_cast<ThreadChip*>(context)->onBinderUnlinked();\n}\n\nvoid ThreadChip::onBinderUnlinked(void) {\n    ALOGW(\"ThreadChip binder is unlinked\");\n    deinitChip();\n}\n\nvoid ThreadChip::handleReceivedFrameJump(void* context) {\n    static_cast<ThreadChip*>(context)->handleReceivedFrame();\n}\n\nvoid ThreadChip::handleReceivedFrame(void) {\n    if (mCallback != nullptr) {\n        mCallback->onReceiveSpinelFrame(std::vector<uint8_t>(\n                mRxFrameBuffer.GetFrame(), mRxFrameBuffer.GetFrame() + mRxFrameBuffer.GetLength()));\n    }\n\n    mRxFrameBuffer.DiscardFrame();\n}\n\nndk::ScopedAStatus ThreadChip::open(const std::shared_ptr<IThreadChipCallback>& in_callback) {\n    ndk::ScopedAStatus status = initChip(in_callback);\n\n    if (status.isOk()) {\n        AIBinder_linkToDeath(in_callback->asBinder().get(), mDeathRecipient.get(), this);\n        ALOGI(\"Open IThreadChip successfully\");\n    } else {\n        ALOGW(\"Failed to open IThreadChip: %s\", status.getDescription().c_str());\n    }\n\n    return status;\n}\n\nndk::ScopedAStatus ThreadChip::initChip(const std::shared_ptr<IThreadChipCallback>& in_callback) {\n    if (in_callback == nullptr) {\n        return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);\n    } else if (mCallback == nullptr) {\n        if (mSpinelInterface->Init(mUrl) != OT_ERROR_NONE) {\n            return errorStatus(ERROR_FAILED, \"Failed to initialize the interface\");\n        }\n\n        mCallback = in_callback;\n        ot::Posix::Mainloop::Manager::Get().Add(*this);\n        return ndk::ScopedAStatus::ok();\n    } else {\n        return errorStatus(ERROR_BUSY, \"Interface has been opened\");\n    }\n}\n\nndk::ScopedAStatus ThreadChip::close() {\n    ndk::ScopedAStatus status;\n    std::shared_ptr<IThreadChipCallback> callback = mCallback;\n\n    status = deinitChip();\n    if (status.isOk()) {\n        if (callback != nullptr) {\n            AIBinder_unlinkToDeath(callback->asBinder().get(), mDeathRecipient.get(), this);\n        }\n\n        ALOGI(\"Close IThreadChip successfully\");\n    } else {\n        ALOGW(\"Failed to close IThreadChip: %s\", status.getDescription().c_str());\n    }\n\n    return status;\n}\n\nndk::ScopedAStatus ThreadChip::deinitChip() {\n    if (mCallback != nullptr) {\n        mSpinelInterface->Deinit();\n        ot::Posix::Mainloop::Manager::Get().Remove(*this);\n        mCallback = nullptr;\n        return ndk::ScopedAStatus::ok();\n    }\n\n    return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_STATE);\n}\n\nndk::ScopedAStatus ThreadChip::sendSpinelFrame(const std::vector<uint8_t>& in_frame) {\n    ndk::ScopedAStatus status;\n    otError error;\n\n    if (mCallback == nullptr) {\n        status = errorStatus(ERROR_FAILED, \"The interface is not open\");\n    } else {\n        error = mSpinelInterface->SendFrame(reinterpret_cast<const uint8_t*>(in_frame.data()),\n                                            in_frame.size());\n        if (error == OT_ERROR_NONE) {\n            status = ndk::ScopedAStatus::ok();\n        } else if (error == OT_ERROR_NO_BUFS) {\n            status = errorStatus(ERROR_NO_BUFS, \"Insufficient buffer space to send\");\n        } else if (error == OT_ERROR_BUSY) {\n            status = errorStatus(ERROR_BUSY, \"The interface is busy\");\n        } else {\n            status = errorStatus(ERROR_FAILED, \"Failed to send the spinel frame\");\n        }\n    }\n\n    if (!status.isOk()) {\n        ALOGW(\"Send spinel frame failed, error: %s\", status.getDescription().c_str());\n    }\n\n    return status;\n}\n\nndk::ScopedAStatus ThreadChip::hardwareReset() {\n    if (mSpinelInterface->HardwareReset() == OT_ERROR_NOT_IMPLEMENTED) {\n        return ndk::ScopedAStatus::fromExceptionCode(EX_UNSUPPORTED_OPERATION);\n    }\n\n    ALOGI(\"reset()\");\n    return ndk::ScopedAStatus::ok();\n}\n\nvoid ThreadChip::Update(otSysMainloopContext& context) {\n    if (mCallback != nullptr) {\n        mSpinelInterface->UpdateFdSet(&context);\n    }\n}\n\nvoid ThreadChip::Process(const otSysMainloopContext& context) {\n    if (mCallback != nullptr) {\n        mSpinelInterface->Process(&context);\n    }\n}\n\nndk::ScopedAStatus ThreadChip::errorStatus(int32_t error, const char* message) {\n    return ndk::ScopedAStatus(AStatus_fromServiceSpecificErrorWithMessage(error, message));\n}\n}  // namespace threadnetwork\n}  // namespace hardware\n}  // namespace android\n}  // namespace aidl",
        "lookback": " * Copyright (C) 2022 The Android Open Source Project",
        "lookahead": "",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 0,
        "end_line": 415,
        "merge_gen_region": " CopyrightC 2 The Open Project * Licensed the License, 2. ( \"\"); you not this except in with the. * may a of License * may a of License * *://..///LICENSE20 * Unless by law agreed in, * under License distributed anAS\" BASIS * WARRANTIES CONDITIONS ANY, express implied * the the for specific governing and limitations the License */includethreadchiphpp # <androidbaseloggingh # <androidbinderautoutilsh # <androidbinderib.>includeandroidbindermanagerh # <androidbinderprocessh # </.>includeutilsLogh # \"__.\"includehdlcinterfacehpp # \"spiinterfacehpp namespace a { namespace { thread {ChipThread(*) m(),RrameBuffer m() static charHdlc[] \"nelhdlc static charSpi[] \"nelspi const*\"; char protocol char protocol CHECKEQm.((),); =UrlGet();_((,);); =UrlGet();_((,); ifmemcmpprotocol kProtocol,(Spi)) 0) mnelInterface stdmakesharedotPo::Spi>(ReceivedJump this mxFBuffer); else ((,,Protocol strlenkProtocol == 0 { mnelInterface stdmakesharedotPo",
        "confidence": 0.9367273449897766,
        "hesitated": false,
        "resolved": false
    }
]