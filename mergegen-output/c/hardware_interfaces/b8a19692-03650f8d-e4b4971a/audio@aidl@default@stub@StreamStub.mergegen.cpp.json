[
    {
        "a_contents": "",
        "b_contents": "::android::status_t StreamStub::init() {\n    mIsInitialized = true;\n    return ::android::OK;\n}\n\n::android::status_t StreamStub::drain(StreamDescriptor::DrainMode) {\n    if (!mIsInitialized) {\n        LOG(FATAL) << __func__ << \": must not happen for an uninitialized driver\";\n    }\n    if (!mIsInput) {\n        if (!mIsAsynchronous) {\n            static constexpr float kMicrosPerSecond = MICROS_PER_SECOND;\n            const size_t delayUs = static_cast<size_t>(\n                    std::roundf(mBufferSizeFrames * kMicrosPerSecond / mSampleRate));\n            usleep(delayUs);\n        } else {\n            usleep(500);\n        }\n    }\n    return ::android::OK;\n}\n\n::android::status_t StreamStub::flush() {\n    if (!mIsInitialized) {\n        LOG(FATAL) << __func__ << \": must not happen for an uninitialized driver\";\n    }\n    return ::android::OK;\n}\n\n::android::status_t StreamStub::pause() {\n    if (!mIsInitialized) {\n        LOG(FATAL) << __func__ << \": must not happen for an uninitialized driver\";\n    }\n    return ::android::OK;\n}\n\n::android::status_t StreamStub::standby() {\n    if (!mIsInitialized) {\n        LOG(FATAL) << __func__ << \": must not happen for an uninitialized driver\";\n    }\n    mIsStandby = true;\n    return ::android::OK;\n}\n\n::android::status_t StreamStub::start() {\n    if (!mIsInitialized) {\n        LOG(FATAL) << __func__ << \": must not happen for an uninitialized driver\";\n    }\n    mIsStandby = false;\n    mStartTimeNs = ::android::uptimeNanos();\n    mFramesSinceStart = 0;\n    return ::android::OK;\n}\n\n::android::status_t StreamStub::transfer(void* buffer, size_t frameCount, size_t* actualFrameCount,\n                                         int32_t*) {\n    if (!mIsInitialized) {\n        LOG(FATAL) << __func__ << \": must not happen for an uninitialized driver\";\n    }\n    if (mIsStandby) {\n        LOG(FATAL) << __func__ << \": must not happen while in standby\";\n    }\n    *actualFrameCount = frameCount;\n    if (mIsAsynchronous) {\n        usleep(500);\n    } else {\n        mFramesSinceStart += *actualFrameCount;\n        const long bufferDurationUs =\n                (*actualFrameCount) * MICROS_PER_SECOND / mContext.getSampleRate();\n        const auto totalDurationUs =\n                (::android::uptimeNanos() - mStartTimeNs) / NANOS_PER_MICROSECOND;\n        const long totalOffsetUs =\n                mFramesSinceStart * MICROS_PER_SECOND / mContext.getSampleRate() - totalDurationUs;\n        LOG(VERBOSE) << __func__ << \": totalOffsetUs \" << totalOffsetUs;\n        if (totalOffsetUs > 0) {\n            const long sleepTimeUs = std::min(totalOffsetUs, bufferDurationUs);\n            LOG(VERBOSE) << __func__ << \": sleeping for \" << sleepTimeUs << \" us\";\n            usleep(sleepTimeUs);\n        }\n    }\n    if (mIsInput) {\n        uint8_t* byteBuffer = static_cast<uint8_t*>(buffer);\n        for (size_t i = 0; i < frameCount * mFrameSizeBytes; ++i) {\n            byteBuffer[i] = std::rand() % 255;\n        }\n    }\n    return ::android::OK;\n}\n\nvoid StreamStub::shutdown() {\n    mIsInitialized = false;\n}\n",
        "base_contents": "::android::status_t StreamStub::init() {\n    mIsInitialized = true;\n    return ::android::OK;\n}\n\n::android::status_t StreamStub::drain(StreamDescriptor::DrainMode) {\n    if (!mIsInitialized) {\n        LOG(FATAL) << __func__ << \": must not happen for an uninitialized driver\";\n    }\n    if (!mIsInput) {\n        if (!mIsAsynchronous) {\n            static constexpr float kMicrosPerSecond = MICROS_PER_SECOND;\n            const size_t delayUs = static_cast<size_t>(\n                    std::roundf(mBufferSizeFrames * kMicrosPerSecond / mSampleRate));\n            usleep(delayUs);\n        } else {\n            usleep(500);\n        }\n    }\n    return ::android::OK;\n}\n\n::android::status_t StreamStub::flush() {\n    if (!mIsInitialized) {\n        LOG(FATAL) << __func__ << \": must not happen for an uninitialized driver\";\n    }\n    return ::android::OK;\n}\n\n::android::status_t StreamStub::pause() {\n    if (!mIsInitialized) {\n        LOG(FATAL) << __func__ << \": must not happen for an uninitialized driver\";\n    }\n    return ::android::OK;\n}\n\n::android::status_t StreamStub::standby() {\n    if (!mIsInitialized) {\n        LOG(FATAL) << __func__ << \": must not happen for an uninitialized driver\";\n    }\n    usleep(500);\n    mIsStandby = true;\n    return ::android::OK;\n}\n\n::android::status_t StreamStub::start() {\n    if (!mIsInitialized) {\n        LOG(FATAL) << __func__ << \": must not happen for an uninitialized driver\";\n    }\n    usleep(500);\n    mIsStandby = false;\n    return ::android::OK;\n}\n\n::android::status_t StreamStub::transfer(void* buffer, size_t frameCount, size_t* actualFrameCount,\n                                         int32_t*) {\n    if (!mIsInitialized) {\n        LOG(FATAL) << __func__ << \": must not happen for an uninitialized driver\";\n    }\n    if (mIsStandby) {\n        LOG(FATAL) << __func__ << \": must not happen while in standby\";\n    }\n    static constexpr float kMicrosPerSecond = MICROS_PER_SECOND;\n    static constexpr float kScaleFactor = .8f;\n    if (mIsAsynchronous) {\n        usleep(500);\n    } else {\n        const size_t delayUs = static_cast<size_t>(\n                std::roundf(kScaleFactor * frameCount * kMicrosPerSecond / mSampleRate));\n        usleep(delayUs);\n    }\n    if (mIsInput) {\n        uint8_t* byteBuffer = static_cast<uint8_t*>(buffer);\n        for (size_t i = 0; i < frameCount * mFrameSizeBytes; ++i) {\n            byteBuffer[i] = std::rand() % 255;\n        }\n    }\n    *actualFrameCount = frameCount;\n    return ::android::OK;\n}\n\nvoid StreamStub::shutdown() {\n    mIsInitialized = false;\n}\n",
        "res_region": "",
        "lookback": "                           const std::vector<MicrophoneInfo>& microphones)",
        "lookahead": "StreamInStub::StreamInStub(StreamContext&& context, const SinkMetadata& sinkMetadata,",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 40,
        "end_line": 221,
        "merge_gen_region": null,
        "confidence": 0.7312005758285522,
        "hesitated": true
    }
]