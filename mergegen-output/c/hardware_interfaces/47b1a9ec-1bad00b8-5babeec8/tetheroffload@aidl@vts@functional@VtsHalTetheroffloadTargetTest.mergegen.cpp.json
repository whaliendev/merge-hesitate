[
    {
        "a_contents": "/*\n * Copyright (C) 2022 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#define LOG_TAG \"tetheroffload_aidl_hal_test\"\n\n#include <aidl/Gtest.h>\n#include <aidl/Vintf.h>\n#include <aidl/android/hardware/tetheroffload/BnOffload.h>\n#include <aidl/android/hardware/tetheroffload/BnTetheringOffloadCallback.h>\n#include <android-base/logging.h>\n#include <android-base/unique_fd.h>\n#include <android/binder_manager.h>\n#include <android/binder_process.h>\n#include <gmock/gmock.h>\n#include <gtest/gtest.h>\n#include <linux/netfilter/nfnetlink.h>\n#include <linux/netlink.h>\n#include <linux/rtnetlink.h>\n#include <log/log.h>\n#include <net/if.h>\n#include <sys/socket.h>\n\nnamespace aidl::android::hardware::tetheroffload {\n\nnamespace {\n\nusing ::android::base::unique_fd;\nusing android::hardware::tetheroffload::ForwardedStats;\nusing android::hardware::tetheroffload::IOffload;\nusing android::hardware::tetheroffload::NatTimeoutUpdate;\nusing android::hardware::tetheroffload::OffloadCallbackEvent;\nusing ::testing::AnyOf;\nusing ::testing::Eq;\n\nconst std::string TEST_IFACE = \"rmnet_data0\";\nconst unsigned kFd1Groups = NF_NETLINK_CONNTRACK_NEW | NF_NETLINK_CONNTRACK_DESTROY;\nconst unsigned kFd2Groups = NF_NETLINK_CONNTRACK_UPDATE | NF_NETLINK_CONNTRACK_DESTROY;\n\nenum class ExpectBoolean {\n    Ignored = -1,\n    False = 0,\n    True = 1,\n};\n\ninline const sockaddr* asSockaddr(const sockaddr_nl* nladdr) {\n    return reinterpret_cast<const sockaddr*>(nladdr);\n}\n\nint netlinkSocket(int protocol, unsigned groups) {\n    unique_fd s(socket(AF_NETLINK, SOCK_DGRAM, protocol));\n    if (s.get() < 0) {\n        return -errno;\n    }\n\n    const struct sockaddr_nl bind_addr = {\n            .nl_family = AF_NETLINK,\n            .nl_pad = 0,\n            .nl_pid = 0,\n            .nl_groups = groups,\n    };\n    if (bind(s.get(), asSockaddr(&bind_addr), sizeof(bind_addr)) != 0) {\n        return -errno;\n    }\n\n    const struct sockaddr_nl kernel_addr = {\n            .nl_family = AF_NETLINK,\n            .nl_pad = 0,\n            .nl_pid = 0,\n            .nl_groups = groups,\n    };\n    if (connect(s.get(), asSockaddr(&kernel_addr), sizeof(kernel_addr)) != 0) {\n        return -errno;\n    }\n\n    return s.release();\n}\n\nint netlinkSocket(unsigned groups) {\n    return netlinkSocket(NETLINK_NETFILTER, groups);\n}\n\n// Check whether the specified interface is up.\nbool interfaceIsUp(const std::string name) {\n    struct ifreq ifr = {};\n    strlcpy(ifr.ifr_name, name.c_str(), sizeof(ifr.ifr_name));\n    int sock = socket(AF_INET6, SOCK_DGRAM, 0);\n    if (sock == -1) return false;\n    int ret = ioctl(sock, SIOCGIFFLAGS, &ifr, sizeof(ifr));\n    close(sock);\n    return (ret == 0) && (ifr.ifr_flags & IFF_UP);\n}\n\n// Callback class for both events and NAT timeout updates.\nclass TetheringOffloadCallback : public BnTetheringOffloadCallback {\n  public:\n    ndk::ScopedAStatus onEvent(OffloadCallbackEvent in_event) override {\n        auto lock = std::lock_guard{mMutex};\n        mOnEventInvoked = true;\n        mLastEvent = in_event;\n        mNotifyCv.notify_all();\n        return ndk::ScopedAStatus::ok();\n    }\n\n    ndk::ScopedAStatus updateTimeout(const NatTimeoutUpdate& in_params) override {\n        auto lock = std::lock_guard{mMutex};\n        mOnUpdateTimeoutInvoked = true;\n        mNatTimeout = in_params;\n        mNotifyCv.notify_all();\n        return ndk::ScopedAStatus::ok();\n    }\n\n  private:\n    std::mutex mMutex;\n    std::condition_variable mNotifyCv;\n    OffloadCallbackEvent mLastEvent;\n    NatTimeoutUpdate mNatTimeout;\n    bool mOnEventInvoked = false;\n    bool mOnUpdateTimeoutInvoked = false;\n};\n\n// The common base class for tetheroffload AIDL HAL tests.\nclass TetheroffloadAidlTestBase : public testing::TestWithParam<std::string> {\n  public:\n    virtual void SetUp() override { getService(); }\n    virtual void TearDown() override {\n        // For good measure, the teardown should try stopOffload() once more, since\n        // different HAL call test cycles might enter this function. Also the\n        // return code cannot be actually expected for all cases, hence ignore it.\n        stopOffload(ExpectBoolean::Ignored);\n    };\n\n  protected:\n    void getService() {\n        AIBinder* binder = AServiceManager_waitForService(GetParam().c_str());\n        ASSERT_NE(binder, nullptr);\n        mOffload = IOffload::fromBinder(ndk::SpAIBinder(binder));\n    }\n\n    void initOffload(const bool expectedResult) {\n        unique_fd ufd1(netlinkSocket(kFd1Groups));\n        if (ufd1.get() < 0) {\n            FAIL() << \"Unable to create conntrack sockets: \" << strerror(errno);\n        }\n        ndk::ScopedFileDescriptor fd1 = ndk::ScopedFileDescriptor(ufd1.release());\n\n        unique_fd ufd2(netlinkSocket(kFd2Groups));\n        if (ufd2.get() < 0) {\n            FAIL() << \"Unable to create conntrack sockets: \" << strerror(errno);\n        }\n        ndk::ScopedFileDescriptor fd2 = ndk::ScopedFileDescriptor(ufd2.release());\n\n        mTetheringOffloadCallback = ndk::SharedRefBase::make<TetheringOffloadCallback>();\n        ASSERT_NE(mTetheringOffloadCallback, nullptr) << \"Could not get offload callback\";\n\n        ASSERT_EQ(mOffload->initOffload(fd1, fd2, mTetheringOffloadCallback).getExceptionCode(),\n                  expectedResult ? EX_NONE : EX_ILLEGAL_STATE);\n    }\n\n    void stopOffload(const ExpectBoolean expectedResult) {\n        ndk::ScopedAStatus status = mOffload->stopOffload();\n        if (expectedResult == ExpectBoolean::Ignored) return;\n        ASSERT_EQ(status.getExceptionCode(),\n                  expectedResult == ExpectBoolean::True ? EX_NONE : EX_ILLEGAL_STATE);\n    }\n\n    std::shared_ptr<IOffload> mOffload;\n    std::shared_ptr<TetheringOffloadCallback> mTetheringOffloadCallback;\n};\n\n// The test class for tetheroffload before initialization.\nclass TetheroffloadAidlPreInitTest : public TetheroffloadAidlTestBase {\n  public:\n    virtual void SetUp() override { getService(); }\n};\n\n// The main test class for tetheroffload AIDL HAL.\nclass TetheroffloadAidlGeneralTest : public TetheroffloadAidlTestBase {\n  public:\n    virtual void SetUp() override {\n        getService();\n        initOffload(true);\n    }\n};\n\n// Passing invalid file descriptor to initOffload() should return an error.\n// Check that this occurs when both FDs are empty.\nTEST_P(TetheroffloadAidlPreInitTest, TestInitOffloadInvalidFdsReturnsError) {\n    ndk::ScopedFileDescriptor fd1 = ndk::ScopedFileDescriptor(-1);\n    ndk::ScopedFileDescriptor fd2 = ndk::ScopedFileDescriptor(-1);\n    mTetheringOffloadCallback = ndk::SharedRefBase::make<TetheringOffloadCallback>();\n    ASSERT_NE(mTetheringOffloadCallback, nullptr) << \"Could not get offload callback\";\n    EXPECT_THAT(mOffload->initOffload(fd1, fd2, mTetheringOffloadCallback).getExceptionCode(),\n                AnyOf(Eq(EX_ILLEGAL_ARGUMENT), Eq(EX_TRANSACTION_FAILED)));\n}\n\n// Passing invalid file descriptor to initOffload() should return an error.\n// Check that this occurs when FD1 is empty.\nTEST_P(TetheroffloadAidlPreInitTest, TestInitOffloadInvalidFd1ReturnsError) {\n    ndk::ScopedFileDescriptor fd1 = ndk::ScopedFileDescriptor(-1);\n    unique_fd ufd2(netlinkSocket(kFd2Groups));\n    if (ufd2.get() < 0) {\n        FAIL() << \"Unable to create conntrack sockets: \" << strerror(errno);\n    }\n    ndk::ScopedFileDescriptor fd2 = ndk::ScopedFileDescriptor(ufd2.release());\n    mTetheringOffloadCallback = ndk::SharedRefBase::make<TetheringOffloadCallback>();\n    ASSERT_NE(mTetheringOffloadCallback, nullptr) << \"Could not get offload callback\";\n    EXPECT_THAT(mOffload->initOffload(fd1, fd2, mTetheringOffloadCallback).getExceptionCode(),\n                AnyOf(Eq(EX_ILLEGAL_ARGUMENT), Eq(EX_TRANSACTION_FAILED)));\n}\n\n// Passing invalid file descriptor to initOffload() should return an error.\n// Check that this occurs when FD2 is empty.\nTEST_P(TetheroffloadAidlPreInitTest, TestInitOffloadInvalidFd2ReturnsError) {\n    unique_fd ufd1(netlinkSocket(kFd1Groups));\n    if (ufd1.get() < 0) {\n        FAIL() << \"Unable to create conntrack sockets: \" << strerror(errno);\n    }\n    ndk::ScopedFileDescriptor fd1 = ndk::ScopedFileDescriptor(ufd1.release());\n    ndk::ScopedFileDescriptor fd2 = ndk::ScopedFileDescriptor(-1);\n    mTetheringOffloadCallback = ndk::SharedRefBase::make<TetheringOffloadCallback>();\n    ASSERT_NE(mTetheringOffloadCallback, nullptr) << \"Could not get offload callback\";\n    EXPECT_THAT(mOffload->initOffload(fd1, fd2, mTetheringOffloadCallback).getExceptionCode(),\n                AnyOf(Eq(EX_ILLEGAL_ARGUMENT), Eq(EX_TRANSACTION_FAILED)));\n}\n\n// Call initOffload() multiple times. Check that non-first initOffload() calls return error.\nTEST_P(TetheroffloadAidlPreInitTest, AdditionalInitsWithoutStopReturnError) {\n    initOffload(true);\n    initOffload(false);\n    initOffload(false);\n    initOffload(false);\n}\n\n// Check that calling stopOffload() without first having called initOffload() returns error.\nTEST_P(TetheroffloadAidlPreInitTest, MultipleStopsWithoutInitReturnError) {\n    stopOffload(ExpectBoolean::False);\n    stopOffload(ExpectBoolean::False);\n    stopOffload(ExpectBoolean::False);\n}\n\n// Check that calling stopOffload() after a complete init/stop cycle returns error.\nTEST_P(TetheroffloadAidlPreInitTest, AdditionalStopsWithInitReturnError) {\n    initOffload(true);\n    // Call setUpstreamParameters() so that \"offload\" can be reasonably said\n    // to be both requested and operational.\n    const std::string iface(TEST_IFACE);\n    const std::string v4Addr(\"192.0.0.2\");\n    const std::string v4Gw(\"192.0.0.1\");\n    const std::vector<std::string> v6Gws{std::string(\"fe80::db8:1\"), std::string(\"fe80::db8:2\")};\n    auto ret = mOffload->setUpstreamParameters(iface, v4Addr, v4Gw, v6Gws);\n    EXPECT_TRUE(ret.isOk()) << ret;\n    if (!interfaceIsUp(TEST_IFACE)) {\n        return;\n    }\n    SCOPED_TRACE(\"Expecting stopOffload to succeed\");\n    stopOffload(ExpectBoolean::True);  // balance out initOffload(true)\n    SCOPED_TRACE(\"Expecting stopOffload to fail the first time\");\n    stopOffload(ExpectBoolean::False);\n    SCOPED_TRACE(\"Expecting stopOffload to fail the second time\");\n    stopOffload(ExpectBoolean::False);\n}\n\n// Check that calling setLocalPrefixes() without first having called initOffload() returns error.\nTEST_P(TetheroffloadAidlPreInitTest, SetLocalPrefixesWithoutInitReturnsError) {\n    const std::vector<std::string> prefixes{std::string(\"2001:db8::/64\")};\n    EXPECT_EQ(EX_ILLEGAL_STATE, mOffload->setLocalPrefixes(prefixes).getExceptionCode());\n}\n\n// Check that calling getForwardedStats() without first having called initOffload()\n// returns zero bytes statistics.\nTEST_P(TetheroffloadAidlPreInitTest, GetForwardedStatsWithoutInitReturnsZeroValues) {\n    const std::string upstream(TEST_IFACE);\n    ForwardedStats stats;\n    auto ret = mOffload->getForwardedStats(upstream, &stats);\n    EXPECT_TRUE(ret.isOk()) << ret;\n    EXPECT_EQ(0ULL, stats.rxBytes);\n    EXPECT_EQ(0ULL, stats.txBytes);\n}\n\n// Check that calling setDataWarningAndLimit() without first having called initOffload() returns\n// error.\nTEST_P(TetheroffloadAidlPreInitTest, SetDataWarningAndLimitWithoutInitReturnsError) {\n    const std::string upstream(TEST_IFACE);\n    const int64_t warning = 5000LL;\n    const int64_t limit = 5000LL;\n    EXPECT_EQ(EX_ILLEGAL_STATE,\n              mOffload->setDataWarningAndLimit(upstream, warning, limit).getExceptionCode());\n}\n\n// Check that calling setUpstreamParameters() without first having called initOffload()\n// returns error.\nTEST_P(TetheroffloadAidlPreInitTest, SetUpstreamParametersWithoutInitReturnsError) {\n    const std::string iface(TEST_IFACE);\n    const std::string v4Addr(\"192.0.2.0/24\");\n    const std::string v4Gw(\"192.0.2.1\");\n    const std::vector<std::string> v6Gws{std::string(\"fe80::db8:1\")};\n    EXPECT_EQ(EX_ILLEGAL_STATE,\n              mOffload->setUpstreamParameters(iface, v4Addr, v4Gw, v6Gws).getExceptionCode());\n}\n\n// Check that calling addDownstream() with an IPv4 prefix without first having called\n// initOffload() returns error.\nTEST_P(TetheroffloadAidlPreInitTest, AddIPv4DownstreamWithoutInitReturnsError) {\n    const std::string iface(TEST_IFACE);\n    const std::string prefix(\"192.0.2.0/24\");\n    EXPECT_EQ(EX_ILLEGAL_STATE, mOffload->addDownstream(iface, prefix).getExceptionCode());\n}\n\n// Check that calling addDownstream() with an IPv6 prefix without first having called\n// initOffload() returns error.\nTEST_P(TetheroffloadAidlPreInitTest, AddIPv6DownstreamWithoutInitReturnsError) {\n    const std::string iface(TEST_IFACE);\n    const std::string prefix(\"2001:db8::/64\");\n    EXPECT_EQ(EX_ILLEGAL_STATE, mOffload->addDownstream(iface, prefix).getExceptionCode());\n}\n\n// Check that calling removeDownstream() with an IPv4 prefix without first having called\n// initOffload() returns error.\nTEST_P(TetheroffloadAidlPreInitTest, RemoveIPv4DownstreamWithoutInitReturnsError) {\n    const std::string iface(TEST_IFACE);\n    const std::string prefix(\"192.0.2.0/24\");\n    EXPECT_EQ(EX_ILLEGAL_STATE, mOffload->removeDownstream(iface, prefix).getExceptionCode());\n}\n\n// Check that calling removeDownstream() with an IPv6 prefix without first having called\n// initOffload() returns error.\nTEST_P(TetheroffloadAidlPreInitTest, RemoveIPv6DownstreamWithoutInitReturnsError) {\n    const std::string iface(TEST_IFACE);\n    const std::string prefix(\"2001:db8::/64\");\n    EXPECT_EQ(EX_ILLEGAL_STATE, mOffload->removeDownstream(iface, prefix).getExceptionCode());\n}\n\n/*\n * Tests for IOffload::setLocalPrefixes().\n */\n\n// Test setLocalPrefixes() rejects an IPv4 address.\nTEST_P(TetheroffloadAidlGeneralTest, SetLocalPrefixesIPv4AddressFails) {\n    const std::vector<std::string> prefixes{std::string(\"192.0.2.1\")};\n    EXPECT_EQ(EX_ILLEGAL_ARGUMENT, mOffload->setLocalPrefixes(prefixes).getExceptionCode());\n}\n\n// Test setLocalPrefixes() rejects an IPv6 address.\nTEST_P(TetheroffloadAidlGeneralTest, SetLocalPrefixesIPv6AddressFails) {\n    const std::vector<std::string> prefixes{std::string(\"fe80::1\")};\n    EXPECT_EQ(EX_ILLEGAL_ARGUMENT, mOffload->setLocalPrefixes(prefixes).getExceptionCode());\n}\n\n// Test setLocalPrefixes() accepts both IPv4 and IPv6 prefixes.\nTEST_P(TetheroffloadAidlGeneralTest, SetLocalPrefixesIPv4v6PrefixesOk) {\n    const std::vector<std::string> prefixes{std::string(\"192.0.2.0/24\"), std::string(\"fe80::/64\")};\n    auto ret = mOffload->setLocalPrefixes(prefixes);\n    EXPECT_TRUE(ret.isOk()) << ret;\n}\n\n// Test that setLocalPrefixes() fails given empty input. There is always\n// a non-empty set of local prefixes; when all networking interfaces are down\n// we still apply {127.0.0.0/8, ::1/128, fe80::/64} here.\nTEST_P(TetheroffloadAidlGeneralTest, SetLocalPrefixesEmptyFails) {\n    const std::vector<std::string> prefixes{};\n    EXPECT_EQ(EX_ILLEGAL_ARGUMENT, mOffload->setLocalPrefixes(prefixes).getExceptionCode());\n}\n\n// Test setLocalPrefixes() fails on incorrectly formed input strings.\nTEST_P(TetheroffloadAidlGeneralTest, SetLocalPrefixesInvalidFails) {\n    const std::vector<std::string> prefixes{std::string(\"192.0.2.0/24\"), std::string(\"invalid\")};\n    EXPECT_EQ(EX_ILLEGAL_ARGUMENT, mOffload->setLocalPrefixes(prefixes).getExceptionCode());\n}\n\n/*\n * Tests for IOffload::getForwardedStats().\n */\n\n// Test that getForwardedStats() for a non-existent upstream yields zero bytes statistics.\nTEST_P(TetheroffloadAidlGeneralTest, GetForwardedStatsInvalidUpstreamIface) {\n    const std::string upstream(\"invalid\");\n    ForwardedStats stats;\n    auto ret = mOffload->getForwardedStats(upstream, &stats);\n    EXPECT_TRUE(ret.isOk()) << ret;\n    EXPECT_EQ(0ULL, stats.rxBytes);\n    EXPECT_EQ(0ULL, stats.txBytes);\n}\n\n// TEST_IFACE is presumed to exist on the device and be up. No packets\n// are ever actually caused to be forwarded.\nTEST_P(TetheroffloadAidlGeneralTest, GetForwardedStatsDummyIface) {\n    const std::string upstream(TEST_IFACE);\n    ForwardedStats stats;\n    auto ret = mOffload->getForwardedStats(upstream, &stats);\n    EXPECT_TRUE(ret.isOk()) << ret;\n    EXPECT_EQ(0ULL, stats.rxBytes);\n    EXPECT_EQ(0ULL, stats.txBytes);\n}\n\n/*\n * Tests for IOffload::setDataWarningAndLimit().\n */\n\n// Test that setDataWarningAndLimit() for an empty interface name fails.\nTEST_P(TetheroffloadAidlGeneralTest, SetDataWarningAndLimitEmptyUpstreamIfaceFails) {\n    const std::string upstream(\"\");\n    const int64_t warning = 12345LL;\n    const int64_t limit = 67890LL;\n    EXPECT_EQ(EX_ILLEGAL_ARGUMENT,\n              mOffload->setDataWarningAndLimit(upstream, warning, limit).getExceptionCode());\n}\n\n// TEST_IFACE is presumed to exist on the device and be up. No packets\n// are ever actually caused to be forwarded.\nTEST_P(TetheroffloadAidlGeneralTest, SetDataWarningAndLimitNonZeroOk) {\n    const std::string upstream(TEST_IFACE);\n    const int64_t warning = 4000LL;\n    const int64_t limit = 5000LL;\n    auto ret = mOffload->setDataWarningAndLimit(upstream, warning, limit);\n    EXPECT_TRUE(ret.isOk()) << ret;\n}\n\n// TEST_IFACE is presumed to exist on the device and be up. No packets\n// are ever actually caused to be forwarded.\nTEST_P(TetheroffloadAidlGeneralTest, SetDataWarningAndLimitZeroOk) {\n    const std::string upstream(TEST_IFACE);\n    const int64_t warning = 0LL;\n    const int64_t limit = 0LL;\n    auto ret = mOffload->setDataWarningAndLimit(upstream, warning, limit);\n    EXPECT_TRUE(ret.isOk()) << ret;\n}\n\n// TEST_IFACE is presumed to exist on the device and be up. No packets\n// are ever actually caused to be forwarded.\nTEST_P(TetheroffloadAidlGeneralTest, SetDataWarningAndLimitUnlimitedWarningOk) {\n    const std::string upstream(TEST_IFACE);\n    const int64_t warning = LLONG_MAX;\n    const int64_t limit = 5000LL;\n    auto ret = mOffload->setDataWarningAndLimit(upstream, warning, limit);\n    EXPECT_TRUE(ret.isOk()) << ret;\n}\n\n// Test that setDataWarningAndLimit() with negative thresholds fails.\nTEST_P(TetheroffloadAidlGeneralTest, SetDataWarningAndLimitNegativeFails) {\n    const std::string upstream(TEST_IFACE);\n    const int64_t warning = -1LL;\n    const int64_t limit = -1LL;\n    EXPECT_EQ(EX_ILLEGAL_ARGUMENT,\n              mOffload->setDataWarningAndLimit(upstream, warning, limit).getExceptionCode());\n}\n\n/*\n * Tests for IOffload::setUpstreamParameters().\n */\n\n// TEST_IFACE is presumed to exist on the device and be up. No packets\n// are ever actually caused to be forwarded.\nTEST_P(TetheroffloadAidlGeneralTest, SetUpstreamParametersIPv6OnlyOk) {\n    const std::string iface(TEST_IFACE);\n    const std::string v4Addr(\"\");\n    const std::string v4Gw(\"\");\n    const std::vector<std::string> v6Gws{std::string(\"fe80::db8:1\"), std::string(\"fe80::db8:2\")};\n    auto ret = mOffload->setUpstreamParameters(iface, v4Addr, v4Gw, v6Gws);\n    EXPECT_TRUE(ret.isOk()) << ret;\n}\n\n// TEST_IFACE is presumed to exist on the device and be up. No packets\n// are ever actually caused to be forwarded.\nTEST_P(TetheroffloadAidlGeneralTest, SetUpstreamParametersAlternateIPv6OnlyOk) {\n    const std::string iface(TEST_IFACE);\n    const std::string v4Addr(\"\");\n    const std::string v4Gw(\"\");\n    const std::vector<std::string> v6Gws{std::string(\"fe80::db8:1\"), std::string(\"fe80::db8:3\")};\n    auto ret = mOffload->setUpstreamParameters(iface, v4Addr, v4Gw, v6Gws);\n    EXPECT_TRUE(ret.isOk()) << ret;\n}\n\n// TEST_IFACE is presumed to exist on the device and be up. No packets\n// are ever actually caused to be forwarded.\nTEST_P(TetheroffloadAidlGeneralTest, SetUpstreamParametersIPv4OnlyOk) {\n    const std::string iface(TEST_IFACE);\n    const std::string v4Addr(\"192.0.2.2\");\n    const std::string v4Gw(\"192.0.2.1\");\n    const std::vector<std::string> v6Gws{};\n    auto ret = mOffload->setUpstreamParameters(iface, v4Addr, v4Gw, v6Gws);\n    EXPECT_TRUE(ret.isOk()) << ret;\n}\n\n// TEST_IFACE is presumed to exist on the device and be up. No packets\n// are ever actually caused to be forwarded.\nTEST_P(TetheroffloadAidlGeneralTest, SetUpstreamParametersIPv4v6Ok) {\n    const std::string iface(TEST_IFACE);\n    const std::string v4Addr(\"192.0.2.2\");\n    const std::string v4Gw(\"192.0.2.1\");\n    const std::vector<std::string> v6Gws{std::string(\"fe80::db8:1\"), std::string(\"fe80::db8:2\")};\n    auto ret = mOffload->setUpstreamParameters(iface, v4Addr, v4Gw, v6Gws);\n    EXPECT_TRUE(ret.isOk()) << ret;\n}\n\n// Test that setUpstreamParameters() fails when all parameters are empty.\nTEST_P(TetheroffloadAidlGeneralTest, SetUpstreamParametersEmptyFails) {\n    const std::string iface(\"\");\n    const std::string v4Addr(\"\");\n    const std::string v4Gw(\"\");\n    const std::vector<std::string> v6Gws{};\n    EXPECT_EQ(EX_ILLEGAL_ARGUMENT,\n              mOffload->setUpstreamParameters(iface, v4Addr, v4Gw, v6Gws).getExceptionCode());\n}\n\n// Test that setUpstreamParameters() fails when given empty or non-existent interface names.\nTEST_P(TetheroffloadAidlGeneralTest, SetUpstreamParametersBogusIfaceFails) {\n    const std::string v4Addr(\"192.0.2.2\");\n    const std::string v4Gw(\"192.0.2.1\");\n    const std::vector<std::string> v6Gws{std::string(\"fe80::db8:1\")};\n    for (const auto& bogus : {\"\", \"invalid\"}) {\n        SCOPED_TRACE(testing::Message() << \"upstream: \" << bogus);\n        const std::string iface(bogus);\n        EXPECT_EQ(EX_ILLEGAL_ARGUMENT,\n                  mOffload->setUpstreamParameters(iface, v4Addr, v4Gw, v6Gws).getExceptionCode());\n    }\n}\n\n// Test that setUpstreamParameters() fails when given unparseable IPv4 addresses.\nTEST_P(TetheroffloadAidlGeneralTest, SetUpstreamParametersInvalidIPv4AddrFails) {\n    const std::string iface(TEST_IFACE);\n    const std::string v4Gw(\"192.0.2.1\");\n    const std::vector<std::string> v6Gws{std::string(\"fe80::db8:1\")};\n    for (const auto& bogus : {\"invalid\", \"192.0.2\"}) {\n        SCOPED_TRACE(testing::Message() << \"v4addr: \" << bogus);\n        const std::string v4Addr(bogus);\n        EXPECT_EQ(EX_ILLEGAL_ARGUMENT,\n                  mOffload->setUpstreamParameters(iface, v4Addr, v4Gw, v6Gws).getExceptionCode());\n    }\n}\n\n// Test that setUpstreamParameters() fails when given unparseable IPv4 gateways.\nTEST_P(TetheroffloadAidlGeneralTest, SetUpstreamParametersInvalidIPv4GatewayFails) {\n    const std::string iface(TEST_IFACE);\n    const std::string v4Addr(\"192.0.2.2\");\n    const std::vector<std::string> v6Gws{std::string(\"fe80::db8:1\")};\n    for (const auto& bogus : {\"invalid\", \"192.0.2\"}) {\n        SCOPED_TRACE(testing::Message() << \"v4gateway: \" << bogus);\n        const std::string v4Gw(bogus);\n        EXPECT_EQ(EX_ILLEGAL_ARGUMENT,\n                  mOffload->setUpstreamParameters(iface, v4Addr, v4Gw, v6Gws).getExceptionCode());\n    }\n}\n\n// Test that setUpstreamParameters() fails when given unparseable IPv6 gateways.\nTEST_P(TetheroffloadAidlGeneralTest, SetUpstreamParametersBadIPv6GatewaysFail) {\n    const std::string iface(TEST_IFACE);\n    const std::string v4Addr(\"192.0.2.2\");\n    const std::string v4Gw(\"192.0.2.1\");\n    for (const auto& bogus : {\"\", \"invalid\", \"fe80::bogus\", \"192.0.2.66\"}) {\n        SCOPED_TRACE(testing::Message() << \"v6gateway: \" << bogus);\n        const std::vector<std::string> v6Gws{std::string(\"fe80::1\"), std::string(bogus)};\n        EXPECT_EQ(EX_ILLEGAL_ARGUMENT,\n                  mOffload->setUpstreamParameters(iface, v4Addr, v4Gw, v6Gws).getExceptionCode());\n    }\n}\n\n/*\n * Tests for IOffload::addDownstream().\n */\n\n// Test addDownstream() works given an IPv4 prefix.\nTEST_P(TetheroffloadAidlGeneralTest, AddDownstreamIPv4) {\n    const std::string iface(\"dummy0\");\n    const std::string prefix(\"192.0.2.0/24\");\n    auto ret = mOffload->addDownstream(iface, prefix);\n    EXPECT_TRUE(ret.isOk()) << ret;\n}\n\n// Test addDownstream() works given an IPv6 prefix.\nTEST_P(TetheroffloadAidlGeneralTest, AddDownstreamIPv6) {\n    const std::string iface(\"dummy0\");\n    const std::string prefix(\"2001:db8::/64\");\n    auto ret = mOffload->addDownstream(iface, prefix);\n    EXPECT_TRUE(ret.isOk()) << ret;\n}\n\n// Test addDownstream() fails given all empty parameters.\nTEST_P(TetheroffloadAidlGeneralTest, AddDownstreamEmptyFails) {\n    const std::string iface(\"\");\n    const std::string prefix(\"\");\n    EXPECT_EQ(EX_ILLEGAL_ARGUMENT, mOffload->addDownstream(iface, prefix).getExceptionCode());\n}\n\n// Test addDownstream() fails given empty or non-existent interface names.\nTEST_P(TetheroffloadAidlGeneralTest, AddDownstreamInvalidIfaceFails) {\n    const std::string prefix(\"192.0.2.0/24\");\n    for (const auto& bogus : {\"\", \"invalid\"}) {\n        SCOPED_TRACE(testing::Message() << \"iface: \" << bogus);\n        const std::string iface(bogus);\n        EXPECT_EQ(EX_ILLEGAL_ARGUMENT, mOffload->addDownstream(iface, prefix).getExceptionCode());\n    }\n}\n\n// Test addDownstream() fails given unparseable prefix arguments.\nTEST_P(TetheroffloadAidlGeneralTest, AddDownstreamBogusPrefixFails) {\n    const std::string iface(\"dummy0\");\n    for (const auto& bogus : {\"\", \"192.0.2/24\", \"2001:db8/64\"}) {\n        SCOPED_TRACE(testing::Message() << \"prefix: \" << bogus);\n        const std::string prefix(bogus);\n        EXPECT_EQ(EX_ILLEGAL_ARGUMENT, mOffload->addDownstream(iface, prefix).getExceptionCode());\n    }\n}\n\n/*\n * Tests for IOffload::removeDownstream().\n */\n\n// Test removeDownstream() works given an IPv4 prefix.\nTEST_P(TetheroffloadAidlGeneralTest, RemoveDownstreamIPv4) {\n    const std::string iface(\"dummy0\");\n    const std::string prefix(\"192.0.2.0/24\");\n    // First add the downstream, otherwise removeDownstream logic can reasonably\n    // return error for downstreams not previously added.\n    auto ret = mOffload->addDownstream(iface, prefix);\n    EXPECT_TRUE(ret.isOk()) << ret;\n    ret = mOffload->removeDownstream(iface, prefix);\n    EXPECT_TRUE(ret.isOk()) << ret;\n}\n\n// Test removeDownstream() works given an IPv6 prefix.\nTEST_P(TetheroffloadAidlGeneralTest, RemoveDownstreamIPv6) {\n    const std::string iface(\"dummy0\");\n    const std::string prefix(\"2001:db8::/64\");\n    // First add the downstream, otherwise removeDownstream logic can reasonably\n    // return error for downstreams not previously added.\n    auto ret = mOffload->addDownstream(iface, prefix);\n    EXPECT_TRUE(ret.isOk()) << ret;\n    ret = mOffload->removeDownstream(iface, prefix);\n    EXPECT_TRUE(ret.isOk()) << ret;\n}\n\n// Test removeDownstream() fails given all empty parameters.\nTEST_P(TetheroffloadAidlGeneralTest, RemoveDownstreamEmptyFails) {\n    const std::string iface(\"\");\n    const std::string prefix(\"\");\n    EXPECT_EQ(EX_ILLEGAL_ARGUMENT, mOffload->removeDownstream(iface, prefix).getExceptionCode());\n}\n\n// Test removeDownstream() fails given empty or non-existent interface names.\nTEST_P(TetheroffloadAidlGeneralTest, RemoveDownstreamBogusIfaceFails) {\n    const std::string prefix(\"192.0.2.0/24\");\n    for (const auto& bogus : {\"\", \"invalid\"}) {\n        SCOPED_TRACE(testing::Message() << \"iface: \" << bogus);\n        const std::string iface(bogus);\n        EXPECT_EQ(EX_ILLEGAL_ARGUMENT,\n                  mOffload->removeDownstream(iface, prefix).getExceptionCode());\n    }\n}\n\n// Test removeDownstream() fails given unparseable prefix arguments.\nTEST_P(TetheroffloadAidlGeneralTest, RemoveDownstreamBogusPrefixFails) {\n    const std::string iface(\"dummy0\");\n    for (const auto& bogus : {\"\", \"192.0.2/24\", \"2001:db8/64\"}) {\n        SCOPED_TRACE(testing::Message() << \"prefix: \" << bogus);\n        const std::string prefix(bogus);\n        EXPECT_EQ(EX_ILLEGAL_ARGUMENT,\n                  mOffload->removeDownstream(iface, prefix).getExceptionCode());\n    }\n}\n\nGTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(TetheroffloadAidlTestBase);\nINSTANTIATE_TEST_SUITE_P(\n        IOffload, TetheroffloadAidlTestBase,\n        testing::ValuesIn(::android::getAidlHalInstanceNames(IOffload::descriptor)),\n        ::android::PrintInstanceNameToString);\n\nGTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(TetheroffloadAidlPreInitTest);\nINSTANTIATE_TEST_SUITE_P(\n        IOffload, TetheroffloadAidlPreInitTest,\n        testing::ValuesIn(::android::getAidlHalInstanceNames(IOffload::descriptor)),\n        ::android::PrintInstanceNameToString);\n\nGTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(TetheroffloadAidlGeneralTest);\nINSTANTIATE_TEST_SUITE_P(\n        IOffload, TetheroffloadAidlGeneralTest,\n        testing::ValuesIn(::android::getAidlHalInstanceNames(IOffload::descriptor)),\n        ::android::PrintInstanceNameToString);\n\n}  // namespace\n}  // namespace aidl::android::hardware::tetheroffload\n\nint main(int argc, char** argv) {\n    ::testing::InitGoogleTest(&argc, argv);\n    ABinderProcess_setThreadPoolMaxThreadCount(1);\n    ABinderProcess_startThreadPool();\n    return RUN_ALL_TESTS();\n}",
        "b_contents": "/*\n * Copyright (C) 2022 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#define LOG_TAG \"tetheroffload_aidl_hal_test\"\n\n#include <aidl/Gtest.h>\n#include <aidl/Vintf.h>\n#include <aidl/android/hardware/tetheroffload/BnOffload.h>\n#include <aidl/android/hardware/tetheroffload/BnTetheringOffloadCallback.h>\n#include <android-base/logging.h>\n#include <android-base/unique_fd.h>\n#include <android/binder_manager.h>\n#include <android/binder_process.h>\n#include <gmock/gmock.h>\n#include <gtest/gtest.h>\n#include <linux/netfilter/nfnetlink.h>\n#include <linux/netlink.h>\n#include <linux/rtnetlink.h>\n#include <log/log.h>\n#include <net/if.h>\n#include <sys/socket.h>\n\nnamespace aidl::android::hardware::tetheroffload {\n\nnamespace {\n\nusing ::android::base::unique_fd;\nusing android::hardware::tetheroffload::ForwardedStats;\nusing android::hardware::tetheroffload::IOffload;\nusing android::hardware::tetheroffload::NatTimeoutUpdate;\nusing android::hardware::tetheroffload::OffloadCallbackEvent;\nusing ::testing::AnyOf;\nusing ::testing::Eq;\n\nconst std::string TEST_IFACE = \"rmnet_data0\";\nconst unsigned kFd1Groups = NF_NETLINK_CONNTRACK_NEW | NF_NETLINK_CONNTRACK_DESTROY;\nconst unsigned kFd2Groups = NF_NETLINK_CONNTRACK_UPDATE | NF_NETLINK_CONNTRACK_DESTROY;\n\nenum class ExpectBoolean {\n    Ignored = -1,\n    False = 0,\n    True = 1,\n};\n\ninline const sockaddr* asSockaddr(const sockaddr_nl* nladdr) {\n    return reinterpret_cast<const sockaddr*>(nladdr);\n}\n\nint netlinkSocket(int protocol, unsigned groups) {\n    unique_fd s(socket(AF_NETLINK, SOCK_DGRAM, protocol));\n    if (s.get() < 0) {\n        return -errno;\n    }\n\n    const struct sockaddr_nl bind_addr = {\n            .nl_family = AF_NETLINK,\n            .nl_pad = 0,\n            .nl_pid = 0,\n            .nl_groups = groups,\n    };\n    if (bind(s.get(), asSockaddr(&bind_addr), sizeof(bind_addr)) != 0) {\n        return -errno;\n    }\n\n    const struct sockaddr_nl kernel_addr = {\n            .nl_family = AF_NETLINK,\n            .nl_pad = 0,\n            .nl_pid = 0,\n            .nl_groups = groups,\n    };\n    if (connect(s.get(), asSockaddr(&kernel_addr), sizeof(kernel_addr)) != 0) {\n        return -errno;\n    }\n\n    return s.release();\n}\n\nint netlinkSocket(unsigned groups) {\n    return netlinkSocket(NETLINK_NETFILTER, groups);\n}\n\n// Check whether the specified interface is up.\nbool interfaceIsUp(const std::string name) {\n    struct ifreq ifr = {};\n    strlcpy(ifr.ifr_name, name.c_str(), sizeof(ifr.ifr_name));\n    int sock = socket(AF_INET6, SOCK_DGRAM, 0);\n    if (sock == -1) return false;\n    int ret = ioctl(sock, SIOCGIFFLAGS, &ifr, sizeof(ifr));\n    close(sock);\n    return (ret == 0) && (ifr.ifr_flags & IFF_UP);\n}\n\n// Callback class for both events and NAT timeout updates.\nclass TetheringOffloadCallback : public BnTetheringOffloadCallback {\n  public:\n    ndk::ScopedAStatus onEvent(OffloadCallbackEvent in_event) override {\n        auto lock = std::lock_guard{mMutex};\n        mOnEventInvoked = true;\n        mLastEvent = in_event;\n        mNotifyCv.notify_all();\n        return ndk::ScopedAStatus::ok();\n    }\n\n    ndk::ScopedAStatus updateTimeout(const NatTimeoutUpdate& in_params) override {\n        auto lock = std::lock_guard{mMutex};\n        mOnUpdateTimeoutInvoked = true;\n        mNatTimeout = in_params;\n        mNotifyCv.notify_all();\n        return ndk::ScopedAStatus::ok();\n    }\n\n  private:\n    std::mutex mMutex;\n    std::condition_variable mNotifyCv;\n    OffloadCallbackEvent mLastEvent;\n    NatTimeoutUpdate mNatTimeout;\n    bool mOnEventInvoked = false;\n    bool mOnUpdateTimeoutInvoked = false;\n};\n\n// The common base class for tetheroffload AIDL HAL tests.\nclass TetheroffloadAidlTestBase : public testing::TestWithParam<std::string> {\n  public:\n    virtual void SetUp() override { getService(); }\n    virtual void TearDown() override {\n        // For good measure, the teardown should try stopOffload() once more, since\n        // different HAL call test cycles might enter this function. Also the\n        // return code cannot be actually expected for all cases, hence ignore it.\n        stopOffload(ExpectBoolean::Ignored);\n    };\n\n  protected:\n    void getService() {\n        AIBinder* binder = AServiceManager_waitForService(GetParam().c_str());\n        ASSERT_NE(binder, nullptr);\n        mOffload = IOffload::fromBinder(ndk::SpAIBinder(binder));\n    }\n\n    void initOffload(const bool expectedResult) {\n        unique_fd ufd1(netlinkSocket(kFd1Groups));\n        if (ufd1.get() < 0) {\n            FAIL() << \"Unable to create conntrack sockets: \" << strerror(errno);\n        }\n        ndk::ScopedFileDescriptor fd1 = ndk::ScopedFileDescriptor(ufd1.release());\n\n        unique_fd ufd2(netlinkSocket(kFd2Groups));\n        if (ufd2.get() < 0) {\n            FAIL() << \"Unable to create conntrack sockets: \" << strerror(errno);\n        }\n        ndk::ScopedFileDescriptor fd2 = ndk::ScopedFileDescriptor(ufd2.release());\n\n        mTetheringOffloadCallback = ndk::SharedRefBase::make<TetheringOffloadCallback>();\n        ASSERT_NE(mTetheringOffloadCallback, nullptr) << \"Could not get offload callback\";\n\n        ASSERT_EQ(mOffload->initOffload(fd1, fd2, mTetheringOffloadCallback).getExceptionCode(),\n                  expectedResult ? EX_NONE : EX_ILLEGAL_STATE);\n    }\n\n    void stopOffload(const ExpectBoolean expectedResult) {\n        ndk::ScopedAStatus status = mOffload->stopOffload();\n        if (expectedResult == ExpectBoolean::Ignored) return;\n        ASSERT_EQ(status.getExceptionCode(),\n                  expectedResult == ExpectBoolean::True ? EX_NONE : EX_ILLEGAL_STATE);\n    }\n\n    std::shared_ptr<IOffload> mOffload;\n    std::shared_ptr<TetheringOffloadCallback> mTetheringOffloadCallback;\n};\n\n// The test class for tetheroffload before initialization.\nclass TetheroffloadAidlPreInitTest : public TetheroffloadAidlTestBase {\n  public:\n    virtual void SetUp() override { getService(); }\n};\n\n// The main test class for tetheroffload AIDL HAL.\nclass TetheroffloadAidlGeneralTest : public TetheroffloadAidlTestBase {\n  public:\n    virtual void SetUp() override {\n        getService();\n        initOffload(true);\n    }\n};\n\n// Passing invalid file descriptor to initOffload() should return an error.\n// Check that this occurs when both FDs are empty.\nTEST_P(TetheroffloadAidlPreInitTest, TestInitOffloadInvalidFdsReturnsError) {\n    ndk::ScopedFileDescriptor fd1 = ndk::ScopedFileDescriptor(-1);\n    ndk::ScopedFileDescriptor fd2 = ndk::ScopedFileDescriptor(-1);\n    mTetheringOffloadCallback = ndk::SharedRefBase::make<TetheringOffloadCallback>();\n    ASSERT_NE(mTetheringOffloadCallback, nullptr) << \"Could not get offload callback\";\n    EXPECT_THAT(mOffload->initOffload(fd1, fd2, mTetheringOffloadCallback).getExceptionCode(),\n                AnyOf(Eq(EX_ILLEGAL_ARGUMENT), Eq(EX_TRANSACTION_FAILED)));\n}\n\n// Passing invalid file descriptor to initOffload() should return an error.\n// Check that this occurs when FD1 is empty.\nTEST_P(TetheroffloadAidlPreInitTest, TestInitOffloadInvalidFd1ReturnsError) {\n    ndk::ScopedFileDescriptor fd1 = ndk::ScopedFileDescriptor(-1);\n    unique_fd ufd2(netlinkSocket(kFd2Groups));\n    if (ufd2.get() < 0) {\n        FAIL() << \"Unable to create conntrack sockets: \" << strerror(errno);\n    }\n    ndk::ScopedFileDescriptor fd2 = ndk::ScopedFileDescriptor(ufd2.release());\n    mTetheringOffloadCallback = ndk::SharedRefBase::make<TetheringOffloadCallback>();\n    ASSERT_NE(mTetheringOffloadCallback, nullptr) << \"Could not get offload callback\";\n    EXPECT_THAT(mOffload->initOffload(fd1, fd2, mTetheringOffloadCallback).getExceptionCode(),\n                AnyOf(Eq(EX_ILLEGAL_ARGUMENT), Eq(EX_TRANSACTION_FAILED)));\n}\n\n// Passing invalid file descriptor to initOffload() should return an error.\n// Check that this occurs when FD2 is empty.\nTEST_P(TetheroffloadAidlPreInitTest, TestInitOffloadInvalidFd2ReturnsError) {\n    unique_fd ufd1(netlinkSocket(kFd1Groups));\n    if (ufd1.get() < 0) {\n        FAIL() << \"Unable to create conntrack sockets: \" << strerror(errno);\n    }\n    ndk::ScopedFileDescriptor fd1 = ndk::ScopedFileDescriptor(ufd1.release());\n    ndk::ScopedFileDescriptor fd2 = ndk::ScopedFileDescriptor(-1);\n    mTetheringOffloadCallback = ndk::SharedRefBase::make<TetheringOffloadCallback>();\n    ASSERT_NE(mTetheringOffloadCallback, nullptr) << \"Could not get offload callback\";\n    EXPECT_THAT(mOffload->initOffload(fd1, fd2, mTetheringOffloadCallback).getExceptionCode(),\n                AnyOf(Eq(EX_ILLEGAL_ARGUMENT), Eq(EX_TRANSACTION_FAILED)));\n}\n\n// Call initOffload() multiple times. Check that non-first initOffload() calls return error.\nTEST_P(TetheroffloadAidlPreInitTest, AdditionalInitsWithoutStopReturnError) {\n    initOffload(true);\n    initOffload(false);\n    initOffload(false);\n    initOffload(false);\n}\n\n// Check that calling stopOffload() without first having called initOffload() returns error.\nTEST_P(TetheroffloadAidlPreInitTest, MultipleStopsWithoutInitReturnError) {\n    stopOffload(ExpectBoolean::False);\n    stopOffload(ExpectBoolean::False);\n    stopOffload(ExpectBoolean::False);\n}\n\n// Check that calling stopOffload() after a complete init/stop cycle returns error.\nTEST_P(TetheroffloadAidlPreInitTest, AdditionalStopsWithInitReturnError) {\n    initOffload(true);\n    // Call setUpstreamParameters() so that \"offload\" can be reasonably said\n    // to be both requested and operational.\n    const std::string iface(TEST_IFACE);\n    const std::string v4Addr(\"192.0.0.2\");\n    const std::string v4Gw(\"192.0.0.1\");\n    const std::vector<std::string> v6Gws{std::string(\"fe80::db8:1\"), std::string(\"fe80::db8:2\")};\n    auto ret = mOffload->setUpstreamParameters(iface, v4Addr, v4Gw, v6Gws);\n    EXPECT_TRUE(ret.isOk()) << ret;\n    if (!interfaceIsUp(TEST_IFACE)) {\n        return;\n    }\n    SCOPED_TRACE(\"Expecting stopOffload to succeed\");\n    stopOffload(ExpectBoolean::True);  // balance out initOffload(true)\n    SCOPED_TRACE(\"Expecting stopOffload to fail the first time\");\n    stopOffload(ExpectBoolean::False);\n    SCOPED_TRACE(\"Expecting stopOffload to fail the second time\");\n    stopOffload(ExpectBoolean::False);\n}\n\n// Check that calling setLocalPrefixes() without first having called initOffload() returns error.\nTEST_P(TetheroffloadAidlPreInitTest, SetLocalPrefixesWithoutInitReturnsError) {\n    const std::vector<std::string> prefixes{std::string(\"2001:db8::/64\")};\n    EXPECT_EQ(EX_ILLEGAL_STATE, mOffload->setLocalPrefixes(prefixes).getExceptionCode());\n}\n\n// Check that calling getForwardedStats() without first having called initOffload()\n// returns zero bytes statistics.\nTEST_P(TetheroffloadAidlPreInitTest, GetForwardedStatsWithoutInitReturnsZeroValues) {\n    const std::string upstream(TEST_IFACE);\n    ForwardedStats stats;\n    auto ret = mOffload->getForwardedStats(upstream, &stats);\n    EXPECT_TRUE(ret.isOk()) << ret;\n    EXPECT_EQ(0ULL, stats.rxBytes);\n    EXPECT_EQ(0ULL, stats.txBytes);\n}\n\n// Check that calling setDataWarningAndLimit() without first having called initOffload() returns\n// error.\nTEST_P(TetheroffloadAidlPreInitTest, SetDataWarningAndLimitWithoutInitReturnsError) {\n    const std::string upstream(TEST_IFACE);\n    const int64_t warning = 5000LL;\n    const int64_t limit = 5000LL;\n    EXPECT_EQ(EX_ILLEGAL_STATE,\n              mOffload->setDataWarningAndLimit(upstream, warning, limit).getExceptionCode());\n}\n\n// Check that calling setUpstreamParameters() without first having called initOffload()\n// returns error.\nTEST_P(TetheroffloadAidlPreInitTest, SetUpstreamParametersWithoutInitReturnsError) {\n    const std::string iface(TEST_IFACE);\n    const std::string v4Addr(\"192.0.2.0/24\");\n    const std::string v4Gw(\"192.0.2.1\");\n    const std::vector<std::string> v6Gws{std::string(\"fe80::db8:1\")};\n    EXPECT_EQ(EX_ILLEGAL_STATE,\n              mOffload->setUpstreamParameters(iface, v4Addr, v4Gw, v6Gws).getExceptionCode());\n}\n\n// Check that calling addDownstream() with an IPv4 prefix without first having called\n// initOffload() returns error.\nTEST_P(TetheroffloadAidlPreInitTest, AddIPv4DownstreamWithoutInitReturnsError) {\n    const std::string iface(TEST_IFACE);\n    const std::string prefix(\"192.0.2.0/24\");\n    EXPECT_EQ(EX_ILLEGAL_STATE, mOffload->addDownstream(iface, prefix).getExceptionCode());\n}\n\n// Check that calling addDownstream() with an IPv6 prefix without first having called\n// initOffload() returns error.\nTEST_P(TetheroffloadAidlPreInitTest, AddIPv6DownstreamWithoutInitReturnsError) {\n    const std::string iface(TEST_IFACE);\n    const std::string prefix(\"2001:db8::/64\");\n    EXPECT_EQ(EX_ILLEGAL_STATE, mOffload->addDownstream(iface, prefix).getExceptionCode());\n}\n\n// Check that calling removeDownstream() with an IPv4 prefix without first having called\n// initOffload() returns error.\nTEST_P(TetheroffloadAidlPreInitTest, RemoveIPv4DownstreamWithoutInitReturnsError) {\n    const std::string iface(TEST_IFACE);\n    const std::string prefix(\"192.0.2.0/24\");\n    EXPECT_EQ(EX_ILLEGAL_STATE, mOffload->removeDownstream(iface, prefix).getExceptionCode());\n}\n\n// Check that calling removeDownstream() with an IPv6 prefix without first having called\n// initOffload() returns error.\nTEST_P(TetheroffloadAidlPreInitTest, RemoveIPv6DownstreamWithoutInitReturnsError) {\n    const std::string iface(TEST_IFACE);\n    const std::string prefix(\"2001:db8::/64\");\n    EXPECT_EQ(EX_ILLEGAL_STATE, mOffload->removeDownstream(iface, prefix).getExceptionCode());\n}\n\n/*\n * Tests for IOffload::setLocalPrefixes().\n */\n\n// Test setLocalPrefixes() rejects an IPv4 address.\nTEST_P(TetheroffloadAidlGeneralTest, SetLocalPrefixesIPv4AddressFails) {\n    const std::vector<std::string> prefixes{std::string(\"192.0.2.1\")};\n    EXPECT_EQ(EX_ILLEGAL_ARGUMENT, mOffload->setLocalPrefixes(prefixes).getExceptionCode());\n}\n\n// Test setLocalPrefixes() rejects an IPv6 address.\nTEST_P(TetheroffloadAidlGeneralTest, SetLocalPrefixesIPv6AddressFails) {\n    const std::vector<std::string> prefixes{std::string(\"fe80::1\")};\n    EXPECT_EQ(EX_ILLEGAL_ARGUMENT, mOffload->setLocalPrefixes(prefixes).getExceptionCode());\n}\n\n// Test setLocalPrefixes() accepts both IPv4 and IPv6 prefixes.\nTEST_P(TetheroffloadAidlGeneralTest, SetLocalPrefixesIPv4v6PrefixesOk) {\n    const std::vector<std::string> prefixes{std::string(\"192.0.2.0/24\"), std::string(\"fe80::/64\")};\n    auto ret = mOffload->setLocalPrefixes(prefixes);\n    EXPECT_TRUE(ret.isOk()) << ret;\n}\n\n// Test that setLocalPrefixes() fails given empty input. There is always\n// a non-empty set of local prefixes; when all networking interfaces are down\n// we still apply {127.0.0.0/8, ::1/128, fe80::/64} here.\nTEST_P(TetheroffloadAidlGeneralTest, SetLocalPrefixesEmptyFails) {\n    const std::vector<std::string> prefixes{};\n    EXPECT_EQ(EX_ILLEGAL_ARGUMENT, mOffload->setLocalPrefixes(prefixes).getExceptionCode());\n}\n\n// Test setLocalPrefixes() fails on incorrectly formed input strings.\nTEST_P(TetheroffloadAidlGeneralTest, SetLocalPrefixesInvalidFails) {\n    const std::vector<std::string> prefixes{std::string(\"192.0.2.0/24\"), std::string(\"invalid\")};\n    EXPECT_EQ(EX_ILLEGAL_ARGUMENT, mOffload->setLocalPrefixes(prefixes).getExceptionCode());\n}\n\n/*\n * Tests for IOffload::getForwardedStats().\n */\n\n// Test that getForwardedStats() for a non-existent upstream yields zero bytes statistics.\nTEST_P(TetheroffloadAidlGeneralTest, GetForwardedStatsInvalidUpstreamIface) {\n    const std::string upstream(\"invalid\");\n    ForwardedStats stats;\n    auto ret = mOffload->getForwardedStats(upstream, &stats);\n    EXPECT_TRUE(ret.isOk()) << ret;\n    EXPECT_EQ(0ULL, stats.rxBytes);\n    EXPECT_EQ(0ULL, stats.txBytes);\n}\n\n// TEST_IFACE is presumed to exist on the device and be up. No packets\n// are ever actually caused to be forwarded.\nTEST_P(TetheroffloadAidlGeneralTest, GetForwardedStatsDummyIface) {\n    const std::string upstream(TEST_IFACE);\n    ForwardedStats stats;\n    auto ret = mOffload->getForwardedStats(upstream, &stats);\n    EXPECT_TRUE(ret.isOk()) << ret;\n    EXPECT_EQ(0ULL, stats.rxBytes);\n    EXPECT_EQ(0ULL, stats.txBytes);\n}\n\n/*\n * Tests for IOffload::setDataWarningAndLimit().\n */\n\n// Test that setDataWarningAndLimit() for an empty interface name fails.\nTEST_P(TetheroffloadAidlGeneralTest, SetDataWarningAndLimitEmptyUpstreamIfaceFails) {\n    const std::string upstream(\"\");\n    const int64_t warning = 12345LL;\n    const int64_t limit = 67890LL;\n    EXPECT_EQ(EX_ILLEGAL_ARGUMENT,\n              mOffload->setDataWarningAndLimit(upstream, warning, limit).getExceptionCode());\n}\n\n// TEST_IFACE is presumed to exist on the device and be up. No packets\n// are ever actually caused to be forwarded.\nTEST_P(TetheroffloadAidlGeneralTest, SetDataWarningAndLimitNonZeroOk) {\n    const std::string upstream(TEST_IFACE);\n    const int64_t warning = 4000LL;\n    const int64_t limit = 5000LL;\n    auto ret = mOffload->setDataWarningAndLimit(upstream, warning, limit);\n    EXPECT_TRUE(ret.isOk()) << ret;\n}\n\n// TEST_IFACE is presumed to exist on the device and be up. No packets\n// are ever actually caused to be forwarded.\nTEST_P(TetheroffloadAidlGeneralTest, SetDataWarningAndLimitZeroOk) {\n    const std::string upstream(TEST_IFACE);\n    const int64_t warning = 0LL;\n    const int64_t limit = 0LL;\n    auto ret = mOffload->setDataWarningAndLimit(upstream, warning, limit);\n    EXPECT_TRUE(ret.isOk()) << ret;\n}\n\n// TEST_IFACE is presumed to exist on the device and be up. No packets\n// are ever actually caused to be forwarded.\nTEST_P(TetheroffloadAidlGeneralTest, SetDataWarningAndLimitUnlimitedWarningOk) {\n    const std::string upstream(TEST_IFACE);\n    const int64_t warning = LLONG_MAX;\n    const int64_t limit = 5000LL;\n    auto ret = mOffload->setDataWarningAndLimit(upstream, warning, limit);\n    EXPECT_TRUE(ret.isOk()) << ret;\n}\n\n// Test that setDataWarningAndLimit() with negative thresholds fails.\nTEST_P(TetheroffloadAidlGeneralTest, SetDataWarningAndLimitNegativeFails) {\n    const std::string upstream(TEST_IFACE);\n    const int64_t warning = -1LL;\n    const int64_t limit = -1LL;\n    EXPECT_EQ(EX_ILLEGAL_ARGUMENT,\n              mOffload->setDataWarningAndLimit(upstream, warning, limit).getExceptionCode());\n}\n\n/*\n * Tests for IOffload::setUpstreamParameters().\n */\n\n// TEST_IFACE is presumed to exist on the device and be up. No packets\n// are ever actually caused to be forwarded.\nTEST_P(TetheroffloadAidlGeneralTest, SetUpstreamParametersIPv6OnlyOk) {\n    const std::string iface(TEST_IFACE);\n    const std::string v4Addr(\"\");\n    const std::string v4Gw(\"\");\n    const std::vector<std::string> v6Gws{std::string(\"fe80::db8:1\"), std::string(\"fe80::db8:2\")};\n    auto ret = mOffload->setUpstreamParameters(iface, v4Addr, v4Gw, v6Gws);\n    EXPECT_TRUE(ret.isOk()) << ret;\n}\n\n// TEST_IFACE is presumed to exist on the device and be up. No packets\n// are ever actually caused to be forwarded.\nTEST_P(TetheroffloadAidlGeneralTest, SetUpstreamParametersAlternateIPv6OnlyOk) {\n    const std::string iface(TEST_IFACE);\n    const std::string v4Addr(\"\");\n    const std::string v4Gw(\"\");\n    const std::vector<std::string> v6Gws{std::string(\"fe80::db8:1\"), std::string(\"fe80::db8:3\")};\n    auto ret = mOffload->setUpstreamParameters(iface, v4Addr, v4Gw, v6Gws);\n    EXPECT_TRUE(ret.isOk()) << ret;\n}\n\n// TEST_IFACE is presumed to exist on the device and be up. No packets\n// are ever actually caused to be forwarded.\nTEST_P(TetheroffloadAidlGeneralTest, SetUpstreamParametersIPv4OnlyOk) {\n    const std::string iface(TEST_IFACE);\n    const std::string v4Addr(\"192.0.2.2\");\n    const std::string v4Gw(\"192.0.2.1\");\n    const std::vector<std::string> v6Gws{};\n    auto ret = mOffload->setUpstreamParameters(iface, v4Addr, v4Gw, v6Gws);\n    EXPECT_TRUE(ret.isOk()) << ret;\n}\n\n// TEST_IFACE is presumed to exist on the device and be up. No packets\n// are ever actually caused to be forwarded.\nTEST_P(TetheroffloadAidlGeneralTest, SetUpstreamParametersIPv4v6Ok) {\n    const std::string iface(TEST_IFACE);\n    const std::string v4Addr(\"192.0.2.2\");\n    const std::string v4Gw(\"192.0.2.1\");\n    const std::vector<std::string> v6Gws{std::string(\"fe80::db8:1\"), std::string(\"fe80::db8:2\")};\n    auto ret = mOffload->setUpstreamParameters(iface, v4Addr, v4Gw, v6Gws);\n    EXPECT_TRUE(ret.isOk()) << ret;\n}\n\n// Test that setUpstreamParameters() fails when all parameters are empty.\nTEST_P(TetheroffloadAidlGeneralTest, SetUpstreamParametersEmptyFails) {\n    const std::string iface(\"\");\n    const std::string v4Addr(\"\");\n    const std::string v4Gw(\"\");\n    const std::vector<std::string> v6Gws{};\n    EXPECT_EQ(EX_ILLEGAL_ARGUMENT,\n              mOffload->setUpstreamParameters(iface, v4Addr, v4Gw, v6Gws).getExceptionCode());\n}\n\n// Test that setUpstreamParameters() fails when given empty or non-existent interface names.\nTEST_P(TetheroffloadAidlGeneralTest, SetUpstreamParametersBogusIfaceFails) {\n    const std::string v4Addr(\"192.0.2.2\");\n    const std::string v4Gw(\"192.0.2.1\");\n    const std::vector<std::string> v6Gws{std::string(\"fe80::db8:1\")};\n    for (const auto& bogus : {\"\", \"invalid\"}) {\n        SCOPED_TRACE(testing::Message() << \"upstream: \" << bogus);\n        const std::string iface(bogus);\n        EXPECT_EQ(EX_ILLEGAL_ARGUMENT,\n                  mOffload->setUpstreamParameters(iface, v4Addr, v4Gw, v6Gws).getExceptionCode());\n    }\n}\n\n// Test that setUpstreamParameters() fails when given unparseable IPv4 addresses.\nTEST_P(TetheroffloadAidlGeneralTest, SetUpstreamParametersInvalidIPv4AddrFails) {\n    const std::string iface(TEST_IFACE);\n    const std::string v4Gw(\"192.0.2.1\");\n    const std::vector<std::string> v6Gws{std::string(\"fe80::db8:1\")};\n    for (const auto& bogus : {\"invalid\", \"192.0.2\"}) {\n        SCOPED_TRACE(testing::Message() << \"v4addr: \" << bogus);\n        const std::string v4Addr(bogus);\n        EXPECT_EQ(EX_ILLEGAL_ARGUMENT,\n                  mOffload->setUpstreamParameters(iface, v4Addr, v4Gw, v6Gws).getExceptionCode());\n    }\n}\n\n// Test that setUpstreamParameters() fails when given unparseable IPv4 gateways.\nTEST_P(TetheroffloadAidlGeneralTest, SetUpstreamParametersInvalidIPv4GatewayFails) {\n    const std::string iface(TEST_IFACE);\n    const std::string v4Addr(\"192.0.2.2\");\n    const std::vector<std::string> v6Gws{std::string(\"fe80::db8:1\")};\n    for (const auto& bogus : {\"invalid\", \"192.0.2\"}) {\n        SCOPED_TRACE(testing::Message() << \"v4gateway: \" << bogus);\n        const std::string v4Gw(bogus);\n        EXPECT_EQ(EX_ILLEGAL_ARGUMENT,\n                  mOffload->setUpstreamParameters(iface, v4Addr, v4Gw, v6Gws).getExceptionCode());\n    }\n}\n\n// Test that setUpstreamParameters() fails when given unparseable IPv6 gateways.\nTEST_P(TetheroffloadAidlGeneralTest, SetUpstreamParametersBadIPv6GatewaysFail) {\n    const std::string iface(TEST_IFACE);\n    const std::string v4Addr(\"192.0.2.2\");\n    const std::string v4Gw(\"192.0.2.1\");\n    for (const auto& bogus : {\"\", \"invalid\", \"fe80::bogus\", \"192.0.2.66\"}) {\n        SCOPED_TRACE(testing::Message() << \"v6gateway: \" << bogus);\n        const std::vector<std::string> v6Gws{std::string(\"fe80::1\"), std::string(bogus)};\n        EXPECT_EQ(EX_ILLEGAL_ARGUMENT,\n                  mOffload->setUpstreamParameters(iface, v4Addr, v4Gw, v6Gws).getExceptionCode());\n    }\n}\n\n/*\n * Tests for IOffload::addDownstream().\n */\n\n// Test addDownstream() works given an IPv4 prefix.\nTEST_P(TetheroffloadAidlGeneralTest, AddDownstreamIPv4) {\n    const std::string iface(\"dummy0\");\n    const std::string prefix(\"192.0.2.0/24\");\n    auto ret = mOffload->addDownstream(iface, prefix);\n    EXPECT_TRUE(ret.isOk()) << ret;\n}\n\n// Test addDownstream() works given an IPv6 prefix.\nTEST_P(TetheroffloadAidlGeneralTest, AddDownstreamIPv6) {\n    const std::string iface(\"dummy0\");\n    const std::string prefix(\"2001:db8::/64\");\n    auto ret = mOffload->addDownstream(iface, prefix);\n    EXPECT_TRUE(ret.isOk()) << ret;\n}\n\n// Test addDownstream() fails given all empty parameters.\nTEST_P(TetheroffloadAidlGeneralTest, AddDownstreamEmptyFails) {\n    const std::string iface(\"\");\n    const std::string prefix(\"\");\n    EXPECT_EQ(EX_ILLEGAL_ARGUMENT, mOffload->addDownstream(iface, prefix).getExceptionCode());\n}\n\n// Test addDownstream() fails given empty or non-existent interface names.\nTEST_P(TetheroffloadAidlGeneralTest, AddDownstreamInvalidIfaceFails) {\n    const std::string prefix(\"192.0.2.0/24\");\n    for (const auto& bogus : {\"\", \"invalid\"}) {\n        SCOPED_TRACE(testing::Message() << \"iface: \" << bogus);\n        const std::string iface(bogus);\n        EXPECT_EQ(EX_ILLEGAL_ARGUMENT, mOffload->addDownstream(iface, prefix).getExceptionCode());\n    }\n}\n\n// Test addDownstream() fails given unparseable prefix arguments.\nTEST_P(TetheroffloadAidlGeneralTest, AddDownstreamBogusPrefixFails) {\n    const std::string iface(\"dummy0\");\n    for (const auto& bogus : {\"\", \"192.0.2/24\", \"2001:db8/64\"}) {\n        SCOPED_TRACE(testing::Message() << \"prefix: \" << bogus);\n        const std::string prefix(bogus);\n        EXPECT_EQ(EX_ILLEGAL_ARGUMENT, mOffload->addDownstream(iface, prefix).getExceptionCode());\n    }\n}\n\n/*\n * Tests for IOffload::removeDownstream().\n */\n\n// Test removeDownstream() works given an IPv4 prefix.\nTEST_P(TetheroffloadAidlGeneralTest, RemoveDownstreamIPv4) {\n    const std::string iface(\"dummy0\");\n    const std::string prefix(\"192.0.2.0/24\");\n    // First add the downstream, otherwise removeDownstream logic can reasonably\n    // return error for downstreams not previously added.\n    auto ret = mOffload->addDownstream(iface, prefix);\n    EXPECT_TRUE(ret.isOk()) << ret;\n    ret = mOffload->removeDownstream(iface, prefix);\n    EXPECT_TRUE(ret.isOk()) << ret;\n}\n\n// Test removeDownstream() works given an IPv6 prefix.\nTEST_P(TetheroffloadAidlGeneralTest, RemoveDownstreamIPv6) {\n    const std::string iface(\"dummy0\");\n    const std::string prefix(\"2001:db8::/64\");\n    // First add the downstream, otherwise removeDownstream logic can reasonably\n    // return error for downstreams not previously added.\n    auto ret = mOffload->addDownstream(iface, prefix);\n    EXPECT_TRUE(ret.isOk()) << ret;\n    ret = mOffload->removeDownstream(iface, prefix);\n    EXPECT_TRUE(ret.isOk()) << ret;\n}\n\n// Test removeDownstream() fails given all empty parameters.\nTEST_P(TetheroffloadAidlGeneralTest, RemoveDownstreamEmptyFails) {\n    const std::string iface(\"\");\n    const std::string prefix(\"\");\n    EXPECT_EQ(EX_ILLEGAL_ARGUMENT, mOffload->removeDownstream(iface, prefix).getExceptionCode());\n}\n\n// Test removeDownstream() fails given empty or non-existent interface names.\nTEST_P(TetheroffloadAidlGeneralTest, RemoveDownstreamBogusIfaceFails) {\n    const std::string prefix(\"192.0.2.0/24\");\n    for (const auto& bogus : {\"\", \"invalid\"}) {\n        SCOPED_TRACE(testing::Message() << \"iface: \" << bogus);\n        const std::string iface(bogus);\n        EXPECT_EQ(EX_ILLEGAL_ARGUMENT,\n                  mOffload->removeDownstream(iface, prefix).getExceptionCode());\n    }\n}\n\n// Test removeDownstream() fails given unparseable prefix arguments.\nTEST_P(TetheroffloadAidlGeneralTest, RemoveDownstreamBogusPrefixFails) {\n    const std::string iface(\"dummy0\");\n    for (const auto& bogus : {\"\", \"192.0.2/24\", \"2001:db8/64\"}) {\n        SCOPED_TRACE(testing::Message() << \"prefix: \" << bogus);\n        const std::string prefix(bogus);\n        EXPECT_EQ(EX_ILLEGAL_ARGUMENT,\n                  mOffload->removeDownstream(iface, prefix).getExceptionCode());\n    }\n}\n\nGTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(TetheroffloadAidlTestBase);\nINSTANTIATE_TEST_SUITE_P(\n        IOffload, TetheroffloadAidlTestBase,\n        testing::ValuesIn(::android::getAidlHalInstanceNames(IOffload::descriptor)),\n        ::android::PrintInstanceNameToString);\n\nGTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(TetheroffloadAidlPreInitTest);\nINSTANTIATE_TEST_SUITE_P(\n        IOffload, TetheroffloadAidlPreInitTest,\n        testing::ValuesIn(::android::getAidlHalInstanceNames(IOffload::descriptor)),\n        ::android::PrintInstanceNameToString);\n\nGTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(TetheroffloadAidlGeneralTest);\nINSTANTIATE_TEST_SUITE_P(\n        IOffload, TetheroffloadAidlGeneralTest,\n        testing::ValuesIn(::android::getAidlHalInstanceNames(IOffload::descriptor)),\n        ::android::PrintInstanceNameToString);\n\n}  // namespace\n\nint main(int argc, char** argv) {\n    ::testing::InitGoogleTest(&argc, argv);\n    ABinderProcess_setThreadPoolMaxThreadCount(1);\n    ABinderProcess_startThreadPool();\n    return RUN_ALL_TESTS();\n}\n\n}  // namespace aidl::android::hardware::tetheroffload",
        "base_contents": "",
        "res_region": "/*\n * Copyright (C) 2022 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#define LOG_TAG \"tetheroffload_aidl_hal_test\"\n\n#include <aidl/Gtest.h>\n#include <aidl/Vintf.h>\n#include <aidl/android/hardware/tetheroffload/BnOffload.h>\n#include <aidl/android/hardware/tetheroffload/BnTetheringOffloadCallback.h>\n#include <android-base/logging.h>\n#include <android-base/unique_fd.h>\n#include <android/binder_manager.h>\n#include <android/binder_process.h>\n#include <gmock/gmock.h>\n#include <gtest/gtest.h>\n#include <linux/netfilter/nfnetlink.h>\n#include <linux/netlink.h>\n#include <linux/rtnetlink.h>\n#include <log/log.h>\n#include <net/if.h>\n#include <sys/socket.h>\n\nnamespace aidl::android::hardware::tetheroffload {\n\nnamespace {\n\nusing ::android::base::unique_fd;\nusing android::hardware::tetheroffload::ForwardedStats;\nusing android::hardware::tetheroffload::IOffload;\nusing android::hardware::tetheroffload::NatTimeoutUpdate;\nusing android::hardware::tetheroffload::OffloadCallbackEvent;\nusing ::testing::AnyOf;\nusing ::testing::Eq;\n\nconst std::string TEST_IFACE = \"rmnet_data0\";\nconst unsigned kFd1Groups = NF_NETLINK_CONNTRACK_NEW | NF_NETLINK_CONNTRACK_DESTROY;\nconst unsigned kFd2Groups = NF_NETLINK_CONNTRACK_UPDATE | NF_NETLINK_CONNTRACK_DESTROY;\n\nenum class ExpectBoolean {\n    Ignored = -1,\n    False = 0,\n    True = 1,\n};\n\ninline const sockaddr* asSockaddr(const sockaddr_nl* nladdr) {\n    return reinterpret_cast<const sockaddr*>(nladdr);\n}\n\nint netlinkSocket(int protocol, unsigned groups) {\n    unique_fd s(socket(AF_NETLINK, SOCK_DGRAM, protocol));\n    if (s.get() < 0) {\n        return -errno;\n    }\n\n    const struct sockaddr_nl bind_addr = {\n            .nl_family = AF_NETLINK,\n            .nl_pad = 0,\n            .nl_pid = 0,\n            .nl_groups = groups,\n    };\n    if (bind(s.get(), asSockaddr(&bind_addr), sizeof(bind_addr)) != 0) {\n        return -errno;\n    }\n\n    const struct sockaddr_nl kernel_addr = {\n            .nl_family = AF_NETLINK,\n            .nl_pad = 0,\n            .nl_pid = 0,\n            .nl_groups = groups,\n    };\n    if (connect(s.get(), asSockaddr(&kernel_addr), sizeof(kernel_addr)) != 0) {\n        return -errno;\n    }\n\n    return s.release();\n}\n\nint netlinkSocket(unsigned groups) {\n    return netlinkSocket(NETLINK_NETFILTER, groups);\n}\n\n// Check whether the specified interface is up.\nbool interfaceIsUp(const std::string name) {\n    struct ifreq ifr = {};\n    strlcpy(ifr.ifr_name, name.c_str(), sizeof(ifr.ifr_name));\n    int sock = socket(AF_INET6, SOCK_DGRAM, 0);\n    if (sock == -1) return false;\n    int ret = ioctl(sock, SIOCGIFFLAGS, &ifr, sizeof(ifr));\n    close(sock);\n    return (ret == 0) && (ifr.ifr_flags & IFF_UP);\n}\n\n// Callback class for both events and NAT timeout updates.\nclass TetheringOffloadCallback : public BnTetheringOffloadCallback {\n  public:\n    ndk::ScopedAStatus onEvent(OffloadCallbackEvent in_event) override {\n        auto lock = std::lock_guard{mMutex};\n        mOnEventInvoked = true;\n        mLastEvent = in_event;\n        mNotifyCv.notify_all();\n        return ndk::ScopedAStatus::ok();\n    }\n\n    ndk::ScopedAStatus updateTimeout(const NatTimeoutUpdate& in_params) override {\n        auto lock = std::lock_guard{mMutex};\n        mOnUpdateTimeoutInvoked = true;\n        mNatTimeout = in_params;\n        mNotifyCv.notify_all();\n        return ndk::ScopedAStatus::ok();\n    }\n\n  private:\n    std::mutex mMutex;\n    std::condition_variable mNotifyCv;\n    OffloadCallbackEvent mLastEvent;\n    NatTimeoutUpdate mNatTimeout;\n    bool mOnEventInvoked = false;\n    bool mOnUpdateTimeoutInvoked = false;\n};\n\n// The common base class for tetheroffload AIDL HAL tests.\nclass TetheroffloadAidlTestBase : public testing::TestWithParam<std::string> {\n  public:\n    virtual void SetUp() override { getService(); }\n    virtual void TearDown() override {\n        // For good measure, the teardown should try stopOffload() once more, since\n        // different HAL call test cycles might enter this function. Also the\n        // return code cannot be actually expected for all cases, hence ignore it.\n        stopOffload(ExpectBoolean::Ignored);\n    };\n\n  protected:\n    void getService() {\n        AIBinder* binder = AServiceManager_waitForService(GetParam().c_str());\n        ASSERT_NE(binder, nullptr);\n        mOffload = IOffload::fromBinder(ndk::SpAIBinder(binder));\n    }\n\n    void initOffload(const bool expectedResult) {\n        unique_fd ufd1(netlinkSocket(kFd1Groups));\n        if (ufd1.get() < 0) {\n            FAIL() << \"Unable to create conntrack sockets: \" << strerror(errno);\n        }\n        ndk::ScopedFileDescriptor fd1 = ndk::ScopedFileDescriptor(ufd1.release());\n\n        unique_fd ufd2(netlinkSocket(kFd2Groups));\n        if (ufd2.get() < 0) {\n            FAIL() << \"Unable to create conntrack sockets: \" << strerror(errno);\n        }\n        ndk::ScopedFileDescriptor fd2 = ndk::ScopedFileDescriptor(ufd2.release());\n\n        mTetheringOffloadCallback = ndk::SharedRefBase::make<TetheringOffloadCallback>();\n        ASSERT_NE(mTetheringOffloadCallback, nullptr) << \"Could not get offload callback\";\n\n        ASSERT_EQ(mOffload->initOffload(fd1, fd2, mTetheringOffloadCallback).getExceptionCode(),\n                  expectedResult ? EX_NONE : EX_ILLEGAL_STATE);\n    }\n\n    void stopOffload(const ExpectBoolean expectedResult) {\n        ndk::ScopedAStatus status = mOffload->stopOffload();\n        if (expectedResult == ExpectBoolean::Ignored) return;\n        ASSERT_EQ(status.getExceptionCode(),\n                  expectedResult == ExpectBoolean::True ? EX_NONE : EX_ILLEGAL_STATE);\n    }\n\n    std::shared_ptr<IOffload> mOffload;\n    std::shared_ptr<TetheringOffloadCallback> mTetheringOffloadCallback;\n};\n\n// The test class for tetheroffload before initialization.\nclass TetheroffloadAidlPreInitTest : public TetheroffloadAidlTestBase {\n  public:\n    virtual void SetUp() override { getService(); }\n};\n\n// The main test class for tetheroffload AIDL HAL.\nclass TetheroffloadAidlGeneralTest : public TetheroffloadAidlTestBase {\n  public:\n    virtual void SetUp() override {\n        getService();\n        initOffload(true);\n    }\n};\n\n// Passing invalid file descriptor to initOffload() should return an error.\n// Check that this occurs when both FDs are empty.\nTEST_P(TetheroffloadAidlPreInitTest, TestInitOffloadInvalidFdsReturnsError) {\n    ndk::ScopedFileDescriptor fd1 = ndk::ScopedFileDescriptor(-1);\n    ndk::ScopedFileDescriptor fd2 = ndk::ScopedFileDescriptor(-1);\n    mTetheringOffloadCallback = ndk::SharedRefBase::make<TetheringOffloadCallback>();\n    ASSERT_NE(mTetheringOffloadCallback, nullptr) << \"Could not get offload callback\";\n    EXPECT_THAT(mOffload->initOffload(fd1, fd2, mTetheringOffloadCallback).getExceptionCode(),\n                AnyOf(Eq(EX_ILLEGAL_ARGUMENT), Eq(EX_TRANSACTION_FAILED)));\n}\n\n// Passing invalid file descriptor to initOffload() should return an error.\n// Check that this occurs when FD1 is empty.\nTEST_P(TetheroffloadAidlPreInitTest, TestInitOffloadInvalidFd1ReturnsError) {\n    ndk::ScopedFileDescriptor fd1 = ndk::ScopedFileDescriptor(-1);\n    unique_fd ufd2(netlinkSocket(kFd2Groups));\n    if (ufd2.get() < 0) {\n        FAIL() << \"Unable to create conntrack sockets: \" << strerror(errno);\n    }\n    ndk::ScopedFileDescriptor fd2 = ndk::ScopedFileDescriptor(ufd2.release());\n    mTetheringOffloadCallback = ndk::SharedRefBase::make<TetheringOffloadCallback>();\n    ASSERT_NE(mTetheringOffloadCallback, nullptr) << \"Could not get offload callback\";\n    EXPECT_THAT(mOffload->initOffload(fd1, fd2, mTetheringOffloadCallback).getExceptionCode(),\n                AnyOf(Eq(EX_ILLEGAL_ARGUMENT), Eq(EX_TRANSACTION_FAILED)));\n}\n\n// Passing invalid file descriptor to initOffload() should return an error.\n// Check that this occurs when FD2 is empty.\nTEST_P(TetheroffloadAidlPreInitTest, TestInitOffloadInvalidFd2ReturnsError) {\n    unique_fd ufd1(netlinkSocket(kFd1Groups));\n    if (ufd1.get() < 0) {\n        FAIL() << \"Unable to create conntrack sockets: \" << strerror(errno);\n    }\n    ndk::ScopedFileDescriptor fd1 = ndk::ScopedFileDescriptor(ufd1.release());\n    ndk::ScopedFileDescriptor fd2 = ndk::ScopedFileDescriptor(-1);\n    mTetheringOffloadCallback = ndk::SharedRefBase::make<TetheringOffloadCallback>();\n    ASSERT_NE(mTetheringOffloadCallback, nullptr) << \"Could not get offload callback\";\n    EXPECT_THAT(mOffload->initOffload(fd1, fd2, mTetheringOffloadCallback).getExceptionCode(),\n                AnyOf(Eq(EX_ILLEGAL_ARGUMENT), Eq(EX_TRANSACTION_FAILED)));\n}\n\n// Call initOffload() multiple times. Check that non-first initOffload() calls return error.\nTEST_P(TetheroffloadAidlPreInitTest, AdditionalInitsWithoutStopReturnError) {\n    initOffload(true);\n    initOffload(false);\n    initOffload(false);\n    initOffload(false);\n}\n\n// Check that calling stopOffload() without first having called initOffload() returns error.\nTEST_P(TetheroffloadAidlPreInitTest, MultipleStopsWithoutInitReturnError) {\n    stopOffload(ExpectBoolean::False);\n    stopOffload(ExpectBoolean::False);\n    stopOffload(ExpectBoolean::False);\n}\n\n// Check that calling stopOffload() after a complete init/stop cycle returns error.\nTEST_P(TetheroffloadAidlPreInitTest, AdditionalStopsWithInitReturnError) {\n    initOffload(true);\n    // Call setUpstreamParameters() so that \"offload\" can be reasonably said\n    // to be both requested and operational.\n    const std::string iface(TEST_IFACE);\n    const std::string v4Addr(\"192.0.0.2\");\n    const std::string v4Gw(\"192.0.0.1\");\n    const std::vector<std::string> v6Gws{std::string(\"fe80::db8:1\"), std::string(\"fe80::db8:2\")};\n    auto ret = mOffload->setUpstreamParameters(iface, v4Addr, v4Gw, v6Gws);\n    EXPECT_TRUE(ret.isOk()) << ret;\n    if (!interfaceIsUp(TEST_IFACE)) {\n        return;\n    }\n    SCOPED_TRACE(\"Expecting stopOffload to succeed\");\n    stopOffload(ExpectBoolean::True);  // balance out initOffload(true)\n    SCOPED_TRACE(\"Expecting stopOffload to fail the first time\");\n    stopOffload(ExpectBoolean::False);\n    SCOPED_TRACE(\"Expecting stopOffload to fail the second time\");\n    stopOffload(ExpectBoolean::False);\n}\n\n// Check that calling setLocalPrefixes() without first having called initOffload() returns error.\nTEST_P(TetheroffloadAidlPreInitTest, SetLocalPrefixesWithoutInitReturnsError) {\n    const std::vector<std::string> prefixes{std::string(\"2001:db8::/64\")};\n    EXPECT_EQ(EX_ILLEGAL_STATE, mOffload->setLocalPrefixes(prefixes).getExceptionCode());\n}\n\n// Check that calling getForwardedStats() without first having called initOffload()\n// returns zero bytes statistics.\nTEST_P(TetheroffloadAidlPreInitTest, GetForwardedStatsWithoutInitReturnsZeroValues) {\n    const std::string upstream(TEST_IFACE);\n    ForwardedStats stats;\n    auto ret = mOffload->getForwardedStats(upstream, &stats);\n    EXPECT_TRUE(ret.isOk()) << ret;\n    EXPECT_EQ(0ULL, stats.rxBytes);\n    EXPECT_EQ(0ULL, stats.txBytes);\n}\n\n// Check that calling setDataWarningAndLimit() without first having called initOffload() returns\n// error.\nTEST_P(TetheroffloadAidlPreInitTest, SetDataWarningAndLimitWithoutInitReturnsError) {\n    const std::string upstream(TEST_IFACE);\n    const int64_t warning = 5000LL;\n    const int64_t limit = 5000LL;\n    EXPECT_EQ(EX_ILLEGAL_STATE,\n              mOffload->setDataWarningAndLimit(upstream, warning, limit).getExceptionCode());\n}\n\n// Check that calling setUpstreamParameters() without first having called initOffload()\n// returns error.\nTEST_P(TetheroffloadAidlPreInitTest, SetUpstreamParametersWithoutInitReturnsError) {\n    const std::string iface(TEST_IFACE);\n    const std::string v4Addr(\"192.0.2.0/24\");\n    const std::string v4Gw(\"192.0.2.1\");\n    const std::vector<std::string> v6Gws{std::string(\"fe80::db8:1\")};\n    EXPECT_EQ(EX_ILLEGAL_STATE,\n              mOffload->setUpstreamParameters(iface, v4Addr, v4Gw, v6Gws).getExceptionCode());\n}\n\n// Check that calling addDownstream() with an IPv4 prefix without first having called\n// initOffload() returns error.\nTEST_P(TetheroffloadAidlPreInitTest, AddIPv4DownstreamWithoutInitReturnsError) {\n    const std::string iface(TEST_IFACE);\n    const std::string prefix(\"192.0.2.0/24\");\n    EXPECT_EQ(EX_ILLEGAL_STATE, mOffload->addDownstream(iface, prefix).getExceptionCode());\n}\n\n// Check that calling addDownstream() with an IPv6 prefix without first having called\n// initOffload() returns error.\nTEST_P(TetheroffloadAidlPreInitTest, AddIPv6DownstreamWithoutInitReturnsError) {\n    const std::string iface(TEST_IFACE);\n    const std::string prefix(\"2001:db8::/64\");\n    EXPECT_EQ(EX_ILLEGAL_STATE, mOffload->addDownstream(iface, prefix).getExceptionCode());\n}\n\n// Check that calling removeDownstream() with an IPv4 prefix without first having called\n// initOffload() returns error.\nTEST_P(TetheroffloadAidlPreInitTest, RemoveIPv4DownstreamWithoutInitReturnsError) {\n    const std::string iface(TEST_IFACE);\n    const std::string prefix(\"192.0.2.0/24\");\n    EXPECT_EQ(EX_ILLEGAL_STATE, mOffload->removeDownstream(iface, prefix).getExceptionCode());\n}\n\n// Check that calling removeDownstream() with an IPv6 prefix without first having called\n// initOffload() returns error.\nTEST_P(TetheroffloadAidlPreInitTest, RemoveIPv6DownstreamWithoutInitReturnsError) {\n    const std::string iface(TEST_IFACE);\n    const std::string prefix(\"2001:db8::/64\");\n    EXPECT_EQ(EX_ILLEGAL_STATE, mOffload->removeDownstream(iface, prefix).getExceptionCode());\n}\n\n/*\n * Tests for IOffload::setLocalPrefixes().\n */\n\n// Test setLocalPrefixes() rejects an IPv4 address.\nTEST_P(TetheroffloadAidlGeneralTest, SetLocalPrefixesIPv4AddressFails) {\n    const std::vector<std::string> prefixes{std::string(\"192.0.2.1\")};\n    EXPECT_EQ(EX_ILLEGAL_ARGUMENT, mOffload->setLocalPrefixes(prefixes).getExceptionCode());\n}\n\n// Test setLocalPrefixes() rejects an IPv6 address.\nTEST_P(TetheroffloadAidlGeneralTest, SetLocalPrefixesIPv6AddressFails) {\n    const std::vector<std::string> prefixes{std::string(\"fe80::1\")};\n    EXPECT_EQ(EX_ILLEGAL_ARGUMENT, mOffload->setLocalPrefixes(prefixes).getExceptionCode());\n}\n\n// Test setLocalPrefixes() accepts both IPv4 and IPv6 prefixes.\nTEST_P(TetheroffloadAidlGeneralTest, SetLocalPrefixesIPv4v6PrefixesOk) {\n    const std::vector<std::string> prefixes{std::string(\"192.0.2.0/24\"), std::string(\"fe80::/64\")};\n    auto ret = mOffload->setLocalPrefixes(prefixes);\n    EXPECT_TRUE(ret.isOk()) << ret;\n}\n\n// Test that setLocalPrefixes() fails given empty input. There is always\n// a non-empty set of local prefixes; when all networking interfaces are down\n// we still apply {127.0.0.0/8, ::1/128, fe80::/64} here.\nTEST_P(TetheroffloadAidlGeneralTest, SetLocalPrefixesEmptyFails) {\n    const std::vector<std::string> prefixes{};\n    EXPECT_EQ(EX_ILLEGAL_ARGUMENT, mOffload->setLocalPrefixes(prefixes).getExceptionCode());\n}\n\n// Test setLocalPrefixes() fails on incorrectly formed input strings.\nTEST_P(TetheroffloadAidlGeneralTest, SetLocalPrefixesInvalidFails) {\n    const std::vector<std::string> prefixes{std::string(\"192.0.2.0/24\"), std::string(\"invalid\")};\n    EXPECT_EQ(EX_ILLEGAL_ARGUMENT, mOffload->setLocalPrefixes(prefixes).getExceptionCode());\n}\n\n/*\n * Tests for IOffload::getForwardedStats().\n */\n\n// Test that getForwardedStats() for a non-existent upstream yields zero bytes statistics.\nTEST_P(TetheroffloadAidlGeneralTest, GetForwardedStatsInvalidUpstreamIface) {\n    const std::string upstream(\"invalid\");\n    ForwardedStats stats;\n    auto ret = mOffload->getForwardedStats(upstream, &stats);\n    EXPECT_TRUE(ret.isOk()) << ret;\n    EXPECT_EQ(0ULL, stats.rxBytes);\n    EXPECT_EQ(0ULL, stats.txBytes);\n}\n\n// TEST_IFACE is presumed to exist on the device and be up. No packets\n// are ever actually caused to be forwarded.\nTEST_P(TetheroffloadAidlGeneralTest, GetForwardedStatsDummyIface) {\n    const std::string upstream(TEST_IFACE);\n    ForwardedStats stats;\n    auto ret = mOffload->getForwardedStats(upstream, &stats);\n    EXPECT_TRUE(ret.isOk()) << ret;\n    EXPECT_EQ(0ULL, stats.rxBytes);\n    EXPECT_EQ(0ULL, stats.txBytes);\n}\n\n/*\n * Tests for IOffload::setDataWarningAndLimit().\n */\n\n// Test that setDataWarningAndLimit() for an empty interface name fails.\nTEST_P(TetheroffloadAidlGeneralTest, SetDataWarningAndLimitEmptyUpstreamIfaceFails) {\n    const std::string upstream(\"\");\n    const int64_t warning = 12345LL;\n    const int64_t limit = 67890LL;\n    EXPECT_EQ(EX_ILLEGAL_ARGUMENT,\n              mOffload->setDataWarningAndLimit(upstream, warning, limit).getExceptionCode());\n}\n\n// TEST_IFACE is presumed to exist on the device and be up. No packets\n// are ever actually caused to be forwarded.\nTEST_P(TetheroffloadAidlGeneralTest, SetDataWarningAndLimitNonZeroOk) {\n    const std::string upstream(TEST_IFACE);\n    const int64_t warning = 4000LL;\n    const int64_t limit = 5000LL;\n    auto ret = mOffload->setDataWarningAndLimit(upstream, warning, limit);\n    EXPECT_TRUE(ret.isOk()) << ret;\n}\n\n// TEST_IFACE is presumed to exist on the device and be up. No packets\n// are ever actually caused to be forwarded.\nTEST_P(TetheroffloadAidlGeneralTest, SetDataWarningAndLimitZeroOk) {\n    const std::string upstream(TEST_IFACE);\n    const int64_t warning = 0LL;\n    const int64_t limit = 0LL;\n    auto ret = mOffload->setDataWarningAndLimit(upstream, warning, limit);\n    EXPECT_TRUE(ret.isOk()) << ret;\n}\n\n// TEST_IFACE is presumed to exist on the device and be up. No packets\n// are ever actually caused to be forwarded.\nTEST_P(TetheroffloadAidlGeneralTest, SetDataWarningAndLimitUnlimitedWarningOk) {\n    const std::string upstream(TEST_IFACE);\n    const int64_t warning = LLONG_MAX;\n    const int64_t limit = 5000LL;\n    auto ret = mOffload->setDataWarningAndLimit(upstream, warning, limit);\n    EXPECT_TRUE(ret.isOk()) << ret;\n}\n\n// Test that setDataWarningAndLimit() with negative thresholds fails.\nTEST_P(TetheroffloadAidlGeneralTest, SetDataWarningAndLimitNegativeFails) {\n    const std::string upstream(TEST_IFACE);\n    const int64_t warning = -1LL;\n    const int64_t limit = -1LL;\n    EXPECT_EQ(EX_ILLEGAL_ARGUMENT,\n              mOffload->setDataWarningAndLimit(upstream, warning, limit).getExceptionCode());\n}\n\n/*\n * Tests for IOffload::setUpstreamParameters().\n */\n\n// TEST_IFACE is presumed to exist on the device and be up. No packets\n// are ever actually caused to be forwarded.\nTEST_P(TetheroffloadAidlGeneralTest, SetUpstreamParametersIPv6OnlyOk) {\n    const std::string iface(TEST_IFACE);\n    const std::string v4Addr(\"\");\n    const std::string v4Gw(\"\");\n    const std::vector<std::string> v6Gws{std::string(\"fe80::db8:1\"), std::string(\"fe80::db8:2\")};\n    auto ret = mOffload->setUpstreamParameters(iface, v4Addr, v4Gw, v6Gws);\n    EXPECT_TRUE(ret.isOk()) << ret;\n}\n\n// TEST_IFACE is presumed to exist on the device and be up. No packets\n// are ever actually caused to be forwarded.\nTEST_P(TetheroffloadAidlGeneralTest, SetUpstreamParametersAlternateIPv6OnlyOk) {\n    const std::string iface(TEST_IFACE);\n    const std::string v4Addr(\"\");\n    const std::string v4Gw(\"\");\n    const std::vector<std::string> v6Gws{std::string(\"fe80::db8:1\"), std::string(\"fe80::db8:3\")};\n    auto ret = mOffload->setUpstreamParameters(iface, v4Addr, v4Gw, v6Gws);\n    EXPECT_TRUE(ret.isOk()) << ret;\n}\n\n// TEST_IFACE is presumed to exist on the device and be up. No packets\n// are ever actually caused to be forwarded.\nTEST_P(TetheroffloadAidlGeneralTest, SetUpstreamParametersIPv4OnlyOk) {\n    const std::string iface(TEST_IFACE);\n    const std::string v4Addr(\"192.0.2.2\");\n    const std::string v4Gw(\"192.0.2.1\");\n    const std::vector<std::string> v6Gws{};\n    auto ret = mOffload->setUpstreamParameters(iface, v4Addr, v4Gw, v6Gws);\n    EXPECT_TRUE(ret.isOk()) << ret;\n}\n\n// TEST_IFACE is presumed to exist on the device and be up. No packets\n// are ever actually caused to be forwarded.\nTEST_P(TetheroffloadAidlGeneralTest, SetUpstreamParametersIPv4v6Ok) {\n    const std::string iface(TEST_IFACE);\n    const std::string v4Addr(\"192.0.2.2\");\n    const std::string v4Gw(\"192.0.2.1\");\n    const std::vector<std::string> v6Gws{std::string(\"fe80::db8:1\"), std::string(\"fe80::db8:2\")};\n    auto ret = mOffload->setUpstreamParameters(iface, v4Addr, v4Gw, v6Gws);\n    EXPECT_TRUE(ret.isOk()) << ret;\n}\n\n// Test that setUpstreamParameters() fails when all parameters are empty.\nTEST_P(TetheroffloadAidlGeneralTest, SetUpstreamParametersEmptyFails) {\n    const std::string iface(\"\");\n    const std::string v4Addr(\"\");\n    const std::string v4Gw(\"\");\n    const std::vector<std::string> v6Gws{};\n    EXPECT_EQ(EX_ILLEGAL_ARGUMENT,\n              mOffload->setUpstreamParameters(iface, v4Addr, v4Gw, v6Gws).getExceptionCode());\n}\n\n// Test that setUpstreamParameters() fails when given empty or non-existent interface names.\nTEST_P(TetheroffloadAidlGeneralTest, SetUpstreamParametersBogusIfaceFails) {\n    const std::string v4Addr(\"192.0.2.2\");\n    const std::string v4Gw(\"192.0.2.1\");\n    const std::vector<std::string> v6Gws{std::string(\"fe80::db8:1\")};\n    for (const auto& bogus : {\"\", \"invalid\"}) {\n        SCOPED_TRACE(testing::Message() << \"upstream: \" << bogus);\n        const std::string iface(bogus);\n        EXPECT_EQ(EX_ILLEGAL_ARGUMENT,\n                  mOffload->setUpstreamParameters(iface, v4Addr, v4Gw, v6Gws).getExceptionCode());\n    }\n}\n\n// Test that setUpstreamParameters() fails when given unparseable IPv4 addresses.\nTEST_P(TetheroffloadAidlGeneralTest, SetUpstreamParametersInvalidIPv4AddrFails) {\n    const std::string iface(TEST_IFACE);\n    const std::string v4Gw(\"192.0.2.1\");\n    const std::vector<std::string> v6Gws{std::string(\"fe80::db8:1\")};\n    for (const auto& bogus : {\"invalid\", \"192.0.2\"}) {\n        SCOPED_TRACE(testing::Message() << \"v4addr: \" << bogus);\n        const std::string v4Addr(bogus);\n        EXPECT_EQ(EX_ILLEGAL_ARGUMENT,\n                  mOffload->setUpstreamParameters(iface, v4Addr, v4Gw, v6Gws).getExceptionCode());\n    }\n}\n\n// Test that setUpstreamParameters() fails when given unparseable IPv4 gateways.\nTEST_P(TetheroffloadAidlGeneralTest, SetUpstreamParametersInvalidIPv4GatewayFails) {\n    const std::string iface(TEST_IFACE);\n    const std::string v4Addr(\"192.0.2.2\");\n    const std::vector<std::string> v6Gws{std::string(\"fe80::db8:1\")};\n    for (const auto& bogus : {\"invalid\", \"192.0.2\"}) {\n        SCOPED_TRACE(testing::Message() << \"v4gateway: \" << bogus);\n        const std::string v4Gw(bogus);\n        EXPECT_EQ(EX_ILLEGAL_ARGUMENT,\n                  mOffload->setUpstreamParameters(iface, v4Addr, v4Gw, v6Gws).getExceptionCode());\n    }\n}\n\n// Test that setUpstreamParameters() fails when given unparseable IPv6 gateways.\nTEST_P(TetheroffloadAidlGeneralTest, SetUpstreamParametersBadIPv6GatewaysFail) {\n    const std::string iface(TEST_IFACE);\n    const std::string v4Addr(\"192.0.2.2\");\n    const std::string v4Gw(\"192.0.2.1\");\n    for (const auto& bogus : {\"\", \"invalid\", \"fe80::bogus\", \"192.0.2.66\"}) {\n        SCOPED_TRACE(testing::Message() << \"v6gateway: \" << bogus);\n        const std::vector<std::string> v6Gws{std::string(\"fe80::1\"), std::string(bogus)};\n        EXPECT_EQ(EX_ILLEGAL_ARGUMENT,\n                  mOffload->setUpstreamParameters(iface, v4Addr, v4Gw, v6Gws).getExceptionCode());\n    }\n}\n\n/*\n * Tests for IOffload::addDownstream().\n */\n\n// Test addDownstream() works given an IPv4 prefix.\nTEST_P(TetheroffloadAidlGeneralTest, AddDownstreamIPv4) {\n    const std::string iface(\"dummy0\");\n    const std::string prefix(\"192.0.2.0/24\");\n    auto ret = mOffload->addDownstream(iface, prefix);\n    EXPECT_TRUE(ret.isOk()) << ret;\n}\n\n// Test addDownstream() works given an IPv6 prefix.\nTEST_P(TetheroffloadAidlGeneralTest, AddDownstreamIPv6) {\n    const std::string iface(\"dummy0\");\n    const std::string prefix(\"2001:db8::/64\");\n    auto ret = mOffload->addDownstream(iface, prefix);\n    EXPECT_TRUE(ret.isOk()) << ret;\n}\n\n// Test addDownstream() fails given all empty parameters.\nTEST_P(TetheroffloadAidlGeneralTest, AddDownstreamEmptyFails) {\n    const std::string iface(\"\");\n    const std::string prefix(\"\");\n    EXPECT_EQ(EX_ILLEGAL_ARGUMENT, mOffload->addDownstream(iface, prefix).getExceptionCode());\n}\n\n// Test addDownstream() fails given empty or non-existent interface names.\nTEST_P(TetheroffloadAidlGeneralTest, AddDownstreamInvalidIfaceFails) {\n    const std::string prefix(\"192.0.2.0/24\");\n    for (const auto& bogus : {\"\", \"invalid\"}) {\n        SCOPED_TRACE(testing::Message() << \"iface: \" << bogus);\n        const std::string iface(bogus);\n        EXPECT_EQ(EX_ILLEGAL_ARGUMENT, mOffload->addDownstream(iface, prefix).getExceptionCode());\n    }\n}\n\n// Test addDownstream() fails given unparseable prefix arguments.\nTEST_P(TetheroffloadAidlGeneralTest, AddDownstreamBogusPrefixFails) {\n    const std::string iface(\"dummy0\");\n    for (const auto& bogus : {\"\", \"192.0.2/24\", \"2001:db8/64\"}) {\n        SCOPED_TRACE(testing::Message() << \"prefix: \" << bogus);\n        const std::string prefix(bogus);\n        EXPECT_EQ(EX_ILLEGAL_ARGUMENT, mOffload->addDownstream(iface, prefix).getExceptionCode());\n    }\n}\n\n/*\n * Tests for IOffload::removeDownstream().\n */\n\n// Test removeDownstream() works given an IPv4 prefix.\nTEST_P(TetheroffloadAidlGeneralTest, RemoveDownstreamIPv4) {\n    const std::string iface(\"dummy0\");\n    const std::string prefix(\"192.0.2.0/24\");\n    // First add the downstream, otherwise removeDownstream logic can reasonably\n    // return error for downstreams not previously added.\n    auto ret = mOffload->addDownstream(iface, prefix);\n    EXPECT_TRUE(ret.isOk()) << ret;\n    ret = mOffload->removeDownstream(iface, prefix);\n    EXPECT_TRUE(ret.isOk()) << ret;\n}\n\n// Test removeDownstream() works given an IPv6 prefix.\nTEST_P(TetheroffloadAidlGeneralTest, RemoveDownstreamIPv6) {\n    const std::string iface(\"dummy0\");\n    const std::string prefix(\"2001:db8::/64\");\n    // First add the downstream, otherwise removeDownstream logic can reasonably\n    // return error for downstreams not previously added.\n    auto ret = mOffload->addDownstream(iface, prefix);\n    EXPECT_TRUE(ret.isOk()) << ret;\n    ret = mOffload->removeDownstream(iface, prefix);\n    EXPECT_TRUE(ret.isOk()) << ret;\n}\n\n// Test removeDownstream() fails given all empty parameters.\nTEST_P(TetheroffloadAidlGeneralTest, RemoveDownstreamEmptyFails) {\n    const std::string iface(\"\");\n    const std::string prefix(\"\");\n    EXPECT_EQ(EX_ILLEGAL_ARGUMENT, mOffload->removeDownstream(iface, prefix).getExceptionCode());\n}\n\n// Test removeDownstream() fails given empty or non-existent interface names.\nTEST_P(TetheroffloadAidlGeneralTest, RemoveDownstreamBogusIfaceFails) {\n    const std::string prefix(\"192.0.2.0/24\");\n    for (const auto& bogus : {\"\", \"invalid\"}) {\n        SCOPED_TRACE(testing::Message() << \"iface: \" << bogus);\n        const std::string iface(bogus);\n        EXPECT_EQ(EX_ILLEGAL_ARGUMENT,\n                  mOffload->removeDownstream(iface, prefix).getExceptionCode());\n    }\n}\n\n// Test removeDownstream() fails given unparseable prefix arguments.\nTEST_P(TetheroffloadAidlGeneralTest, RemoveDownstreamBogusPrefixFails) {\n    const std::string iface(\"dummy0\");\n    for (const auto& bogus : {\"\", \"192.0.2/24\", \"2001:db8/64\"}) {\n        SCOPED_TRACE(testing::Message() << \"prefix: \" << bogus);\n        const std::string prefix(bogus);\n        EXPECT_EQ(EX_ILLEGAL_ARGUMENT,\n                  mOffload->removeDownstream(iface, prefix).getExceptionCode());\n    }\n}\n\nGTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(TetheroffloadAidlTestBase);\nINSTANTIATE_TEST_SUITE_P(\n        IOffload, TetheroffloadAidlTestBase,\n        testing::ValuesIn(::android::getAidlHalInstanceNames(IOffload::descriptor)),\n        ::android::PrintInstanceNameToString);\n\nGTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(TetheroffloadAidlPreInitTest);\nINSTANTIATE_TEST_SUITE_P(\n        IOffload, TetheroffloadAidlPreInitTest,\n        testing::ValuesIn(::android::getAidlHalInstanceNames(IOffload::descriptor)),\n        ::android::PrintInstanceNameToString);\n\nGTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(TetheroffloadAidlGeneralTest);\nINSTANTIATE_TEST_SUITE_P(\n        IOffload, TetheroffloadAidlGeneralTest,\n        testing::ValuesIn(::android::getAidlHalInstanceNames(IOffload::descriptor)),\n        ::android::PrintInstanceNameToString);\n\n}  // namespace\n}  // namespace aidl::android::hardware::tetheroffload\n\nint main(int argc, char** argv) {\n    ::testing::InitGoogleTest(&argc, argv);\n    ABinderProcess_setThreadPoolMaxThreadCount(1);\n    ABinderProcess_startThreadPool();\n    return RUN_ALL_TESTS();\n}",
        "lookback": " * Copyright (C) 2022 The Android Open Source Project",
        "lookahead": "",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 0,
        "end_line": 1404,
        "merge_gen_region": " CopyrightC 2 The Open Project * Licensed the Apache, 2. ( \"\"); you not this except in with the. * may a of License * may a of License * *://..///LICENSE20 * Unless by law agreed in, * under License distributed anAS\" BASIS * WITHOUT OR OF KIND either or. See License the language permissions * under the. # LOGTAGteroloadaid_lhaltest # <lG.>includeaid/V.>includeaid//tethff/BOffloadh # <landroidhardwaretethff/netherOffload.>includeandroidbaseloggingh # <androidbaseuniquefdh # </__.>includeandroidbindermanagerh # <androidbinderprocessh # <gmockgmock.>includegtestgtesth # <linuxnet/nf.>includelinuxnetlinkh # <//.>includelinuxrt.>includeloglogh # </.>includenetifh # </.h namespaceidlandroidhardwareteroload namespace usingandroidbaseuniquefd using::hardwareteroloadForStats; androidhardwareteroloadIOload using androidhardwareteroloadNTimeout; androidhardwareteroloadOffloadEvent usingtestingAny;",
        "confidence": 0.936424195766449,
        "hesitated": false,
        "resolved": false
    }
]