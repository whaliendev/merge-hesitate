[
    {
        "a_contents": "SrsHttpConn::SrsHttpConn(IConnectionManager* cm, srs_netfd_t fd, ISrsHttpServeMux* m, string cip) : SrsConnection(cm, fd, cip)",
        "b_contents": "#endif\n\n#ifdef SRS_AUTO_HTTP_CORE\n\nSrsHttpResponseWriter::SrsHttpResponseWriter(SrsStSocket* io)\n{\n    skt = io;\n    hdr = new SrsHttpHeader();\n    header_wrote = false;\n    status = SRS_CONSTS_HTTP_OK;\n    content_length = -1;\n    written = 0;\n    header_sent = false;\n    nb_iovss_cache = 0;\n    iovss_cache = NULL;\n}\n\nSrsHttpResponseWriter::~SrsHttpResponseWriter()\n{\n    srs_freep(hdr);\n    srs_freepa(iovss_cache);\n}\n\nint SrsHttpResponseWriter::final_request()\n{\n    // write the header data in memory.\n    if (!header_wrote) {\n        write_header(SRS_CONSTS_HTTP_OK);\n    }\n\n    // complete the chunked encoding.\n    if (content_length == -1) {\n        std::stringstream ss;\n        ss << 0 << SRS_HTTP_CRLF << SRS_HTTP_CRLF;\n        std::string ch = ss.str();\n        return skt->write((void*)ch.data(), (int)ch.length(), NULL);\n    }\n    \n    // flush when send with content length\n    return write(NULL, 0);\n}\n\nSrsHttpHeader* SrsHttpResponseWriter::header()\n{\n    return hdr;\n}\n\nint SrsHttpResponseWriter::write(char* data, int size)\n{\n    int ret = ERROR_SUCCESS;\n    \n    // write the header data in memory.\n    if (!header_wrote) {\n        write_header(SRS_CONSTS_HTTP_OK);\n    }\n    \n    // whatever header is wrote, we should try to send header.\n    if ((ret = send_header(data, size)) != ERROR_SUCCESS) {\n        srs_error(\"http: send header failed. ret=%d\", ret);\n        return ret;\n    }\n    \n    // check the bytes send and content length.\n    written += size;\n    if (content_length != -1 && written > content_length) {\n        ret = ERROR_HTTP_CONTENT_LENGTH;\n        srs_error(\"http: exceed content length. ret=%d\", ret);\n        return ret;\n    }\n    \n    // ignore NULL content.\n    if (!data) {\n        return ret;\n    }\n    \n    // directly send with content length\n    if (content_length != -1) {\n        return skt->write((void*)data, size, NULL);\n    }\n    \n    // send in chunked encoding.\n    int nb_size = snprintf(header_cache, SRS_HTTP_HEADER_CACHE_SIZE, \"%x\", size);\n    \n    iovec iovs[4];\n    iovs[0].iov_base = (char*)header_cache;\n    iovs[0].iov_len = (int)nb_size;\n    iovs[1].iov_base = (char*)SRS_HTTP_CRLF;\n    iovs[1].iov_len = 2;\n    iovs[2].iov_base = (char*)data;\n    iovs[2].iov_len = size;\n    iovs[3].iov_base = (char*)SRS_HTTP_CRLF;\n    iovs[3].iov_len = 2;\n    \n    ssize_t nwrite;\n    if ((ret = skt->writev(iovs, 4, &nwrite)) != ERROR_SUCCESS) {\n        return ret;\n    }\n    \n    return ret;\n}\n\nint SrsHttpResponseWriter::writev(iovec* iov, int iovcnt, ssize_t* pnwrite)\n{\n    int ret = ERROR_SUCCESS;\n    \n    // when header not ready, or not chunked, send one by one.\n    if (!header_wrote || content_length != -1) {\n        ssize_t nwrite = 0;\n        for (int i = 0; i < iovcnt; i++) {\n            iovec* piovc = iov + i;\n            nwrite += piovc->iov_len;\n            if ((ret = write((char*)piovc->iov_base, (int)piovc->iov_len)) != ERROR_SUCCESS) {\n                return ret;\n            }\n        }\n        \n        if (pnwrite) {\n            *pnwrite = nwrite;\n        }\n        \n        return ret;\n    }\n    \n    // ignore NULL content.\n    if (iovcnt <= 0) {\n        return ret;\n    }\n    \n    // send in chunked encoding.\n    int nb_iovss = 3 + iovcnt;\n    iovec* iovss = iovss_cache;\n    if (nb_iovss_cache < nb_iovss) {\n        srs_freepa(iovss_cache);\n        nb_iovss_cache = nb_iovss;\n        iovss = iovss_cache = new iovec[nb_iovss];\n    }\n    \n    // send in chunked encoding.\n    \n    // chunk size.\n    int size = 0;\n    for (int i = 0; i < iovcnt; i++) {\n        iovec* data_iov = iov + i;\n        size += data_iov->iov_len;\n    }\n    written += size;\n    \n    // chunk header\n    int nb_size = snprintf(header_cache, SRS_HTTP_HEADER_CACHE_SIZE, \"%x\", size);\n    iovec* iovs = iovss;\n    iovs[0].iov_base = (char*)header_cache;\n    iovs[0].iov_len = (int)nb_size;\n    iovs++;\n    \n    // chunk header eof.\n    iovs[0].iov_base = (char*)SRS_HTTP_CRLF;\n    iovs[0].iov_len = 2;\n    iovs++;\n    \n    // chunk body.\n    for (int i = 0; i < iovcnt; i++) {\n        iovec* data_iov = iov + i;\n        iovs[0].iov_base = (char*)data_iov->iov_base;\n        iovs[0].iov_len = (int)data_iov->iov_len;\n        iovs++;\n    }\n    \n    // chunk body eof.\n    iovs[0].iov_base = (char*)SRS_HTTP_CRLF;\n    iovs[0].iov_len = 2;\n    iovs++;\n    \n    // sendout all ioves.\n    ssize_t nwrite;\n    if ((ret = srs_write_large_iovs(skt, iovss, nb_iovss, &nwrite)) != ERROR_SUCCESS) {\n        return ret;\n    }\n    \n    if (pnwrite) {\n        *pnwrite = nwrite;\n    }\n    \n    return ret;\n}\n\nvoid SrsHttpResponseWriter::write_header(int code)\n{\n    if (header_wrote) {\n        srs_warn(\"http: multiple write_header calls, code=%d\", code);\n        return;\n    }\n    \n    header_wrote = true;\n    status = code;\n    \n    // parse the content length from header.\n    content_length = hdr->content_length();\n}\n\nint SrsHttpResponseWriter::send_header(char* data, int size)\n{\n    int ret = ERROR_SUCCESS;\n    \n    if (header_sent) {\n        return ret;\n    }\n    header_sent = true;\n    \n    std::stringstream ss;\n    \n    // status_line\n    ss << \"HTTP/1.1 \" << status << \" \"\n        << srs_generate_http_status_text(status) << SRS_HTTP_CRLF;\n    \n    // detect content type\n    if (srs_go_http_body_allowd(status)) {\n        if (hdr->content_type().empty()) {\n            hdr->set_content_type(srs_go_http_detect(data, size));\n        }\n    }\n    \n    // set server if not set.\n    if (hdr->get(\"Server\").empty()) {\n        hdr->set(\"Server\", RTMP_SIG_SRS_SERVER);\n    }\n    \n    // chunked encoding\n    if (content_length == -1) {\n        hdr->set(\"Transfer-Encoding\", \"chunked\");\n    }\n    \n    // keep alive to make vlc happy.\n    hdr->set(\"Connection\", \"Keep-Alive\");\n    \n    // write headers\n    hdr->write(ss);\n    \n    // header_eof\n    ss << SRS_HTTP_CRLF;\n    \n    std::string buf = ss.str();\n    return skt->write((void*)buf.c_str(), buf.length(), NULL);\n}\n\nSrsHttpResponseReader::SrsHttpResponseReader(SrsHttpMessage* msg, SrsStSocket* io)\n{\n    skt = io;\n    owner = msg;\n    is_eof = false;\n    nb_total_read = 0;\n    nb_left_chunk = 0;\n    buffer = NULL;\n}\n\nSrsHttpResponseReader::~SrsHttpResponseReader()\n{\n}\n\nint SrsHttpResponseReader::initialize(SrsFastBuffer* body)\n{\n    int ret = ERROR_SUCCESS;\n    \n    nb_chunk = 0;\n    nb_left_chunk = 0;\n    nb_total_read = 0;\n    buffer = body;\n    \n    return ret;\n}\n\nbool SrsHttpResponseReader::eof()\n{\n    return is_eof;\n}\n\nint SrsHttpResponseReader::read(char* data, int nb_data, int* nb_read)\n{\n    int ret = ERROR_SUCCESS;\n    \n    if (is_eof) {\n        ret = ERROR_HTTP_RESPONSE_EOF;\n        srs_error(\"http: response EOF. ret=%d\", ret);\n        return ret;\n    }\n    \n    // chunked encoding.\n    if (owner->is_chunked()) {\n        return read_chunked(data, nb_data, nb_read);\n    }\n    \n    // read by specified content-length\n    if (owner->content_length() != -1) {\n        int max = (int)owner->content_length() - (int)nb_total_read;\n        if (max <= 0) {\n            is_eof = true;\n            return ret;\n        }\n        \n        // change the max to read.\n        nb_data = srs_min(nb_data, max);\n        return read_specified(data, nb_data, nb_read);\n    }\n    \n    // infinite chunked mode, directly read.\n    if (owner->is_infinite_chunked()) {\n        srs_assert(!owner->is_chunked() && owner->content_length() == -1);\n        return read_specified(data, nb_data, nb_read);\n    }\n    \n    // infinite chunked mode, but user not set it,\n    // we think there is no data left.\n    is_eof = true;\n    \n    return ret;\n}\n\nint SrsHttpResponseReader::read_chunked(char* data, int nb_data, int* nb_read)\n{\n    int ret = ERROR_SUCCESS;\n    \n    // when no bytes left in chunk,\n    // parse the chunk length first.\n    if (nb_left_chunk <= 0) {\n        char* at = NULL;\n        int length = 0;\n        while (!at) {\n            // find the CRLF of chunk header end.\n            char* start = buffer->bytes();\n            char* end = start + buffer->size();\n            for (char* p = start; p < end - 1; p++) {\n                if (p[0] == SRS_HTTP_CR && p[1] == SRS_HTTP_LF) {\n                    // invalid chunk, ignore.\n                    if (p == start) {\n                        ret = ERROR_HTTP_INVALID_CHUNK_HEADER;\n                        srs_error(\"chunk header start with CRLF. ret=%d\", ret);\n                        return ret;\n                    }\n                    length = (int)(p - start + 2);\n                    at = buffer->read_slice(length);\n                    break;\n                }\n            }\n            \n            // got at, ok.\n            if (at) {\n                break;\n            }\n            \n            // when empty, only grow 1bytes, but the buffer will cache more.\n            if ((ret = buffer->grow(skt, buffer->size() + 1)) != ERROR_SUCCESS) {\n                if (!srs_is_client_gracefully_close(ret)) {\n                    srs_error(\"read body from server failed. ret=%d\", ret);\n                }\n                return ret;\n            }\n        }\n        srs_assert(length >= 3);\n        \n        // it's ok to set the pos and pos+1 to NULL.\n        at[length - 1] = 0;\n        at[length - 2] = 0;\n        \n        // size is the bytes size, excludes the chunk header and end CRLF.\n        int ilength = (int)::strtol(at, NULL, 16);\n        if (ilength < 0) {\n            ret = ERROR_HTTP_INVALID_CHUNK_HEADER;\n            srs_error(\"chunk header negative, length=%d. ret=%d\", ilength, ret);\n            return ret;\n        }\n        \n        // all bytes in chunk is left now.\n        nb_chunk = nb_left_chunk = ilength;\n    }\n    \n    if (nb_chunk <= 0) {\n        // for the last chunk, eof.\n        is_eof = true;\n    } else {\n        // for not the last chunk, there must always exists bytes.\n        // left bytes in chunk, read some.\n        srs_assert(nb_left_chunk);\n        \n        int nb_bytes = srs_min(nb_left_chunk, nb_data);\n        ret = read_specified(data, nb_bytes, &nb_bytes);\n        \n        // the nb_bytes used for output already read size of bytes.\n        if (nb_read) {\n            *nb_read = nb_bytes;\n        }\n        nb_left_chunk -= nb_bytes;\n        srs_info(\"http: read %d bytes of chunk\", nb_bytes);\n        \n        // error or still left bytes in chunk, ignore and read in future.\n        if (nb_left_chunk > 0 || (ret != ERROR_SUCCESS)) {\n            return ret;\n        }\n        srs_info(\"http: read total chunk %dB\", nb_chunk);\n    }\n    \n    // for both the last or not, the CRLF of chunk payload end.\n    if ((ret = buffer->grow(skt, 2)) != ERROR_SUCCESS) {\n        if (!srs_is_client_gracefully_close(ret)) {\n            srs_error(\"read EOF of chunk from server failed. ret=%d\", ret);\n        }\n        return ret;\n    }\n    buffer->read_slice(2);\n    \n    return ret;\n}\n\nint SrsHttpResponseReader::read_specified(char* data, int nb_data, int* nb_read)\n{\n    int ret = ERROR_SUCCESS;\n    \n    if (buffer->size() <= 0) {\n        // when empty, only grow 1bytes, but the buffer will cache more.\n        if ((ret = buffer->grow(skt, 1)) != ERROR_SUCCESS) {\n            if (!srs_is_client_gracefully_close(ret)) {\n                srs_error(\"read body from server failed. ret=%d\", ret);\n            }\n            return ret;\n        }\n    }\n    \n    int nb_bytes = srs_min(nb_data, buffer->size());\n    \n    // read data to buffer.\n    srs_assert(nb_bytes);\n    char* p = buffer->read_slice(nb_bytes);\n    memcpy(data, p, nb_bytes);\n    if (nb_read) {\n        *nb_read = nb_bytes;\n    }\n    \n    // increase the total read to determine whether EOF.\n    nb_total_read += nb_bytes;\n    \n    // for not chunked and specified content length.\n    if (!owner->is_chunked() && owner->content_length() != -1) {\n        // when read completed, eof.\n        if (nb_total_read >= (int)owner->content_length()) {\n            is_eof = true;\n        }\n    }\n    \n    return ret;\n}\n\nSrsHttpMessage::SrsHttpMessage(SrsStSocket* io, SrsConnection* c) : ISrsHttpMessage()\n{\n    conn = c;\n    chunked = false;\n    infinite_chunked = false;\n    keep_alive = true;\n    _uri = new SrsHttpUri();\n    _body = new SrsHttpResponseReader(this, io);\n    _http_ts_send_buffer = new char[SRS_HTTP_TS_SEND_BUFFER_SIZE];\n    jsonp = false;\n}\n\nSrsHttpMessage::~SrsHttpMessage()\n{\n    srs_freep(_body);\n    srs_freep(_uri);\n    srs_freepa(_http_ts_send_buffer);\n}\n\nint SrsHttpMessage::update(string url, http_parser* header, SrsFastBuffer* body, vector<SrsHttpHeaderField>& headers)\n{\n    int ret = ERROR_SUCCESS;\n    \n    _url = url;\n    _header = *header;\n    _headers = headers;\n    \n    // whether chunked.\n    std::string transfer_encoding = get_request_header(\"Transfer-Encoding\");\n    chunked = (transfer_encoding == \"chunked\");\n    \n    // whether keep alive.\n    keep_alive = http_should_keep_alive(header);\n    \n    // set the buffer.\n    if ((ret = _body->initialize(body)) != ERROR_SUCCESS) {\n        return ret;\n    }\n    \n    // parse uri from url.\n    std::string host = get_request_header(\"Host\");\n    \n    // use server public ip when no host specified.\n    // to make telnet happy.\n    if (host.empty()) {\n        host= srs_get_public_internet_address();\n    }\n    \n    // parse uri to schema/server:port/path?query\n    std::string uri = \"http://\" + host + _url;\n    if ((ret = _uri->initialize(uri)) != ERROR_SUCCESS) {\n        return ret;\n    }\n    \n    // must format as key=value&...&keyN=valueN\n    std::string q = _uri->get_query();\n    size_t pos = string::npos;\n    while (!q.empty()) {\n        std::string k = q;\n        if ((pos = q.find(\"=\")) != string::npos) {\n            k = q.substr(0, pos);\n            q = q.substr(pos + 1);\n        } else {\n            q = \"\";\n        }\n        \n        std::string v = q;\n        if ((pos = q.find(\"&\")) != string::npos) {\n            v = q.substr(0, pos);\n            q = q.substr(pos + 1);\n        } else {\n            q = \"\";\n        }\n        \n        _query[k] = v;\n    }\n    \n    // parse ext.\n    _ext = _uri->get_path();\n    if ((pos = _ext.rfind(\".\")) != string::npos) {\n        _ext = _ext.substr(pos);\n    } else {\n        _ext = \"\";\n    }\n    \n    // parse jsonp request message.\n    if (!query_get(\"callback\").empty()) {\n        jsonp = true;\n    }\n    if (jsonp) {\n        jsonp_method = query_get(\"method\");\n    }\n    \n    return ret;\n}\n\nSrsConnection* SrsHttpMessage::connection()\n{\n    return conn;\n}\n\nu_int8_t SrsHttpMessage::method()\n{\n    if (jsonp && !jsonp_method.empty()) {\n        if (jsonp_method == \"GET\") {\n            return SRS_CONSTS_HTTP_GET;\n        } else if (jsonp_method == \"PUT\") {\n            return SRS_CONSTS_HTTP_PUT;\n        } else if (jsonp_method == \"POST\") {\n            return SRS_CONSTS_HTTP_POST;\n        } else if (jsonp_method == \"DELETE\") {\n            return SRS_CONSTS_HTTP_DELETE;\n        }\n    }\n    \n    return (u_int8_t)_header.method;\n}\n\nu_int16_t SrsHttpMessage::status_code()\n{\n    return (u_int16_t)_header.status_code;\n}\n\nstring SrsHttpMessage::method_str()\n{\n    if (jsonp && !jsonp_method.empty()) {\n        return jsonp_method;\n    }\n    \n    if (is_http_get()) {\n        return \"GET\";\n    }\n    if (is_http_put()) {\n        return \"PUT\";\n    }\n    if (is_http_post()) {\n        return \"POST\";\n    }\n    if (is_http_delete()) {\n        return \"DELETE\";\n    }\n    if (is_http_options()) {\n        return \"OPTIONS\";\n    }\n    \n    return \"OTHER\";\n}\n\nbool SrsHttpMessage::is_http_get()\n{\n    return method() == SRS_CONSTS_HTTP_GET;\n}\n\nbool SrsHttpMessage::is_http_put()\n{\n    return method() == SRS_CONSTS_HTTP_PUT;\n}\n\nbool SrsHttpMessage::is_http_post()\n{\n    return method() == SRS_CONSTS_HTTP_POST;\n}\n\nbool SrsHttpMessage::is_http_delete()\n{\n    return method() == SRS_CONSTS_HTTP_DELETE;\n}\n\nbool SrsHttpMessage::is_http_options()\n{\n    return _header.method == SRS_CONSTS_HTTP_OPTIONS;\n}\n\nbool SrsHttpMessage::is_chunked()\n{\n    return chunked;\n}\n\nbool SrsHttpMessage::is_keep_alive()\n{\n    return keep_alive;\n}\n\nbool SrsHttpMessage::is_infinite_chunked()\n{\n    return infinite_chunked;\n}\n\nstring SrsHttpMessage::uri()\n{\n    std::string uri = _uri->get_schema();\n    if (uri.empty()) {\n        uri += \"http\";\n    }\n    uri += \"://\";\n    \n    uri += host();\n    uri += path();\n    \n    return uri;\n}\n\nstring SrsHttpMessage::url()\n{\n    return _uri->get_url();\n}\n\nstring SrsHttpMessage::host()\n{\n    return _uri->get_host();\n}\n\nstring SrsHttpMessage::path()\n{\n    return _uri->get_path();\n}\n\nstring SrsHttpMessage::query()\n{\n    return _uri->get_query();\n}\n\nstring SrsHttpMessage::ext()\n{\n    return _ext;\n}\n\nint SrsHttpMessage::parse_rest_id(string pattern)\n{\n    string p = _uri->get_path();\n    if (p.length() <= pattern.length()) {\n        return -1;\n    }\n    \n    string id = p.substr((int)pattern.length());\n    if (!id.empty()) {\n        return ::atoi(id.c_str());\n    }\n    \n    return -1;\n}\n\nint SrsHttpMessage::enter_infinite_chunked()\n{\n    int ret = ERROR_SUCCESS;\n    \n    if (infinite_chunked) {\n        return ret;\n    }\n    \n    if (is_chunked() || content_length() != -1) {\n        ret = ERROR_HTTP_DATA_INVALID;\n        srs_error(\"infinite chunkted not supported in specified codec. ret=%d\", ret);\n        return ret;\n    }\n    \n    infinite_chunked = true;\n    \n    return ret;\n}\n\nint SrsHttpMessage::body_read_all(string& body)\n{\n    int ret = ERROR_SUCCESS;\n    \n    // cache to read.\n    char* buf = new char[SRS_HTTP_READ_CACHE_BYTES];\n    SrsAutoFreeA(char, buf);\n    \n    // whatever, read util EOF.\n    while (!_body->eof()) {\n        int nb_read = 0;\n        if ((ret = _body->read(buf, SRS_HTTP_READ_CACHE_BYTES, &nb_read)) != ERROR_SUCCESS) {\n            return ret;\n        }\n        \n        if (nb_read > 0) {\n            body.append(buf, nb_read);\n        }\n    }\n    \n    return ret;\n}\n\nISrsHttpResponseReader* SrsHttpMessage::body_reader()\n{\n    return _body;\n}\n\nint64_t SrsHttpMessage::content_length()\n{\n    return _header.content_length;\n}\n\nstring SrsHttpMessage::query_get(string key)\n{\n    std::string v;\n    \n    if (_query.find(key) != _query.end()) {\n        v = _query[key];\n    }\n    \n    return v;\n}\n\nint SrsHttpMessage::request_header_count()\n{\n    return (int)_headers.size();\n}\n\nstring SrsHttpMessage::request_header_key_at(int index)\n{\n    srs_assert(index < request_header_count());\n    SrsHttpHeaderField item = _headers[index];\n    return item.first;\n}\n\nstring SrsHttpMessage::request_header_value_at(int index)\n{\n    srs_assert(index < request_header_count());\n    SrsHttpHeaderField item = _headers[index];\n    return item.second;\n}\n\nstring SrsHttpMessage::get_request_header(string name)\n{\n    std::vector<SrsHttpHeaderField>::iterator it;\n    \n    for (it = _headers.begin(); it != _headers.end(); ++it) {\n        SrsHttpHeaderField& elem = *it;\n        std::string key = elem.first;\n        std::string value = elem.second;\n        if (key == name) {\n            return value;\n        }\n    }\n    \n    return \"\";\n}\n\nSrsRequest* SrsHttpMessage::to_request(string vhost)\n{\n    SrsRequest* req = new SrsRequest();\n    \n    req->app = _uri->get_path();\n    size_t pos = string::npos;\n    if ((pos = req->app.rfind(\"/\")) != string::npos) {\n        req->stream = req->app.substr(pos + 1);\n        req->app = req->app.substr(0, pos);\n    }\n    if ((pos = req->stream.rfind(\".\")) != string::npos) {\n        req->stream = req->stream.substr(0, pos);\n    }\n    \n    req->tcUrl = \"rtmp://\" + vhost + req->app;\n    req->pageUrl = get_request_header(\"Referer\");\n    req->objectEncoding = 0;\n    \n    srs_discovery_tc_url(req->tcUrl,\n                         req->schema, req->host, req->vhost, req->app, req->stream, req->port,\n                         req->param);\n    req->strip();\n    \n    return req;\n}\n\nbool SrsHttpMessage::is_jsonp()\n{\n    return jsonp;\n}\n\nSrsHttpParser::SrsHttpParser()\n{\n    buffer = new SrsFastBuffer();\n}\n\nSrsHttpParser::~SrsHttpParser()\n{\n    srs_freep(buffer);\n}\n\nint SrsHttpParser::initialize(enum http_parser_type type)\n{\n    int ret = ERROR_SUCCESS;\n    \n    memset(&settings, 0, sizeof(settings));\n    settings.on_message_begin = on_message_begin;\n    settings.on_url = on_url;\n    settings.on_header_field = on_header_field;\n    settings.on_header_value = on_header_value;\n    settings.on_headers_complete = on_headers_complete;\n    settings.on_body = on_body;\n    settings.on_message_complete = on_message_complete;\n    \n    http_parser_init(&parser, type);\n    // callback object ptr.\n    parser.data = (void*)this;\n    \n    return ret;\n}\n\nint SrsHttpParser::parse_message(SrsStSocket* skt, SrsConnection* conn, ISrsHttpMessage** ppmsg)\n{\n    *ppmsg = NULL;\n    \n    int ret = ERROR_SUCCESS;\n    \n    // reset request data.\n    field_name = \"\";\n    field_value = \"\";\n    expect_field_name = true;\n    state = SrsHttpParseStateInit;\n    header = http_parser();\n    url = \"\";\n    headers.clear();\n    header_parsed = 0;\n    \n    // do parse\n    if ((ret = parse_message_imp(skt)) != ERROR_SUCCESS) {\n        if (!srs_is_client_gracefully_close(ret)) {\n            srs_error(\"parse http msg failed. ret=%d\", ret);\n        }\n        return ret;\n    }\n    \n    // create msg\n    SrsHttpMessage* msg = new SrsHttpMessage(skt, conn);\n    \n    // initalize http msg, parse url.\n    if ((ret = msg->update(url, &header, buffer, headers)) != ERROR_SUCCESS) {\n        srs_error(\"initialize http msg failed. ret=%d\", ret);\n        srs_freep(msg);\n        return ret;\n    }\n    \n    // parse ok, return the msg.\n    *ppmsg = msg;\n    \n    return ret;\n}\n\nint SrsHttpParser::parse_message_imp(SrsStSocket* skt)\n{\n    int ret = ERROR_SUCCESS;\n    \n    while (true) {\n        ssize_t nparsed = 0;\n        \n        // when got entire http header, parse it.\n        // @see https://github.com/ossrs/srs/issues/400\n        char* start = buffer->bytes();\n        char* end = start + buffer->size();\n        for (char* p = start; p <= end - 4; p++) {\n            // SRS_HTTP_CRLFCRLF \"\\r\\n\\r\\n\" // 0x0D0A0D0A\n            if (p[0] == SRS_CONSTS_CR && p[1] == SRS_CONSTS_LF && p[2] == SRS_CONSTS_CR && p[3] == SRS_CONSTS_LF) {\n                nparsed = http_parser_execute(&parser, &settings, buffer->bytes(), buffer->size());\n                srs_info(\"buffer=%d, nparsed=%d, header=%d\", buffer->size(), (int)nparsed, header_parsed);\n                break;\n            }\n        }\n        \n        // consume the parsed bytes.\n        if (nparsed && header_parsed) {\n            buffer->read_slice(header_parsed);\n        }\n        \n        // ok atleast header completed,\n        // never wait for body completed, for maybe chunked.\n        if (state == SrsHttpParseStateHeaderComplete || state == SrsHttpParseStateMessageComplete) {\n            break;\n        }\n        \n        // when nothing parsed, read more to parse.\n        if (nparsed == 0) {\n            // when requires more, only grow 1bytes, but the buffer will cache more.\n            if ((ret = buffer->grow(skt, buffer->size() + 1)) != ERROR_SUCCESS) {\n                if (!srs_is_client_gracefully_close(ret)) {\n                    srs_error(\"read body from server failed. ret=%d\", ret);\n                }\n                return ret;\n            }\n        }\n    }\n    \n    // parse last header.\n    if (!field_name.empty() && !field_value.empty()) {\n        headers.push_back(std::make_pair(field_name, field_value));\n    }\n    \n    return ret;\n}\n\nint SrsHttpParser::on_message_begin(http_parser* parser)\n{\n    SrsHttpParser* obj = (SrsHttpParser*)parser->data;\n    srs_assert(obj);\n    \n    obj->state = SrsHttpParseStateStart;\n    \n    srs_info(\"***MESSAGE BEGIN***\");\n    \n    return 0;\n}\n\nint SrsHttpParser::on_headers_complete(http_parser* parser)\n{\n    SrsHttpParser* obj = (SrsHttpParser*)parser->data;\n    srs_assert(obj);\n    \n    obj->header = *parser;\n    // save the parser when header parse completed.\n    obj->state = SrsHttpParseStateHeaderComplete;\n    obj->header_parsed = (int)parser->nread;\n    \n    srs_info(\"***HEADERS COMPLETE***\");\n    \n    // see http_parser.c:1570, return 1 to skip body.\n    return 0;\n}\n\nint SrsHttpParser::on_message_complete(http_parser* parser)\n{\n    SrsHttpParser* obj = (SrsHttpParser*)parser->data;\n    srs_assert(obj);\n    \n    // save the parser when body parse completed.\n    obj->state = SrsHttpParseStateMessageComplete;\n    \n    srs_info(\"***MESSAGE COMPLETE***\\n\");\n    \n    return 0;\n}\n\nint SrsHttpParser::on_url(http_parser* parser, const char* at, size_t length)\n{\n    SrsHttpParser* obj = (SrsHttpParser*)parser->data;\n    srs_assert(obj);\n    \n    if (length > 0) {\n        obj->url.append(at, (int)length);\n    }\n    \n    srs_info(\"Method: %d, Url: %.*s\", parser->method, (int)length, at);\n    \n    return 0;\n}\n\nint SrsHttpParser::on_header_field(http_parser* parser, const char* at, size_t length)\n{\n    SrsHttpParser* obj = (SrsHttpParser*)parser->data;\n    srs_assert(obj);\n    \n    // field value=>name, reap the field.\n    if (!obj->expect_field_name) {\n        obj->headers.push_back(std::make_pair(obj->field_name, obj->field_value));\n        \n        // reset the field name when parsed.\n        obj->field_name = \"\";\n        obj->field_value = \"\";\n    }\n    obj->expect_field_name = true;\n    \n    if (length > 0) {\n        obj->field_name.append(at, (int)length);\n    }\n    \n    srs_info(\"Header field(%d bytes): %.*s\", (int)length, (int)length, at);\n    return 0;\n}\n\nint SrsHttpParser::on_header_value(http_parser* parser, const char* at, size_t length)\n{\n    SrsHttpParser* obj = (SrsHttpParser*)parser->data;\n    srs_assert(obj);\n    \n    if (length > 0) {\n        obj->field_value.append(at, (int)length);\n    }\n    obj->expect_field_name = false;\n    \n    srs_info(\"Header value(%d bytes): %.*s\", (int)length, (int)length, at);\n    return 0;\n}\n\nint SrsHttpParser::on_body(http_parser* parser, const char* at, size_t length)\n{\n    SrsHttpParser* obj = (SrsHttpParser*)parser->data;\n    srs_assert(obj);\n    \n    srs_info(\"Body: %.*s\", (int)length, at);\n    \n    return 0;\n}\n\nSrsHttpUri::SrsHttpUri()\n{\n    port = SRS_DEFAULT_HTTP_PORT;\n}\n\nSrsHttpUri::~SrsHttpUri()\n{\n}\n\nint SrsHttpUri::initialize(string _url)\n{\n    int ret = ERROR_SUCCESS;\n    \n    url = _url;\n    const char* purl = url.c_str();\n    \n    http_parser_url hp_u;\n    if((ret = http_parser_parse_url(purl, url.length(), 0, &hp_u)) != 0){\n        int code = ret;\n        ret = ERROR_HTTP_PARSE_URI;\n        \n        srs_error(\"parse url %s failed, code=%d, ret=%d\", purl, code, ret);\n        return ret;\n    }\n    \n    std::string field = get_uri_field(url, &hp_u, UF_SCHEMA);\n    if(!field.empty()){\n        schema = field;\n    }\n    \n    host = get_uri_field(url, &hp_u, UF_HOST);\n    \n    field = get_uri_field(url, &hp_u, UF_PORT);\n    if(!field.empty()){\n        port = atoi(field.c_str());\n    }\n    \n    path = get_uri_field(url, &hp_u, UF_PATH);\n    srs_info(\"parse url %s success\", purl);\n    \n    query = get_uri_field(url, &hp_u, UF_QUERY);\n    srs_info(\"parse query %s success\", query.c_str());\n    \n    return ret;\n}\n\nconst char* SrsHttpUri::get_url()\n{\n    return url.data();\n}\n\nconst char* SrsHttpUri::get_schema()\n{\n    return schema.data();\n}\n\nconst char* SrsHttpUri::get_host()\n{\n    return host.data();\n}\n\nint SrsHttpUri::get_port()\n{\n    return port;\n}\n\nconst char* SrsHttpUri::get_path()\n{\n    return path.data();\n}\n\nconst char* SrsHttpUri::get_query()\n{\n    return query.data();\n}\n\nstring SrsHttpUri::get_uri_field(string uri, http_parser_url* hp_u, http_parser_url_fields field)\n{\n    if((hp_u->field_set & (1 << field)) == 0){\n        return \"\";\n    }\n    \n    srs_verbose(\"uri field matched, off=%d, len=%d, value=%.*s\",\n                hp_u->field_data[field].off,\n                hp_u->field_data[field].len,\n                hp_u->field_data[field].len,\n                uri.c_str() + hp_u->field_data[field].off);\n    \n    int offset = hp_u->field_data[field].off;\n    int len = hp_u->field_data[field].len;\n    \n    return uri.substr(offset, len);\n}\n\nSrsHttpConn::SrsHttpConn(IConnectionManager* cm, st_netfd_t fd, ISrsHttpServeMux* m)\n    : SrsConnection(cm, fd)",
        "base_contents": "#endif\n\n#ifdef SRS_AUTO_HTTP_CORE\n\nSrsHttpResponseWriter::SrsHttpResponseWriter(SrsStSocket* io)\n{\n    skt = io;\n    hdr = new SrsHttpHeader();\n    header_wrote = false;\n    status = SRS_CONSTS_HTTP_OK;\n    content_length = -1;\n    written = 0;\n    header_sent = false;\n    nb_iovss_cache = 0;\n    iovss_cache = NULL;\n}\n\nSrsHttpResponseWriter::~SrsHttpResponseWriter()\n{\n    srs_freep(hdr);\n    srs_freepa(iovss_cache);\n}\n\nint SrsHttpResponseWriter::final_request()\n{\n    // write the header data in memory.\n    if (!header_wrote) {\n        write_header(SRS_CONSTS_HTTP_OK);\n    }\n\n    // complete the chunked encoding.\n    if (content_length == -1) {\n        std::stringstream ss;\n        ss << 0 << SRS_HTTP_CRLF << SRS_HTTP_CRLF;\n        std::string ch = ss.str();\n        return skt->write((void*)ch.data(), (int)ch.length(), NULL);\n    }\n    \n    // flush when send with content length\n    return write(NULL, 0);\n}\n\nSrsHttpHeader* SrsHttpResponseWriter::header()\n{\n    return hdr;\n}\n\nint SrsHttpResponseWriter::write(char* data, int size)\n{\n    int ret = ERROR_SUCCESS;\n    \n    // write the header data in memory.\n    if (!header_wrote) {\n        write_header(SRS_CONSTS_HTTP_OK);\n    }\n    \n    // whatever header is wrote, we should try to send header.\n    if ((ret = send_header(data, size)) != ERROR_SUCCESS) {\n        srs_error(\"http: send header failed. ret=%d\", ret);\n        return ret;\n    }\n    \n    // check the bytes send and content length.\n    written += size;\n    if (content_length != -1 && written > content_length) {\n        ret = ERROR_HTTP_CONTENT_LENGTH;\n        srs_error(\"http: exceed content length. ret=%d\", ret);\n        return ret;\n    }\n    \n    // ignore NULL content.\n    if (!data) {\n        return ret;\n    }\n    \n    // directly send with content length\n    if (content_length != -1) {\n        return skt->write((void*)data, size, NULL);\n    }\n    \n    // send in chunked encoding.\n    int nb_size = snprintf(header_cache, SRS_HTTP_HEADER_CACHE_SIZE, \"%x\", size);\n    \n    iovec iovs[4];\n    iovs[0].iov_base = (char*)header_cache;\n    iovs[0].iov_len = (int)nb_size;\n    iovs[1].iov_base = (char*)SRS_HTTP_CRLF;\n    iovs[1].iov_len = 2;\n    iovs[2].iov_base = (char*)data;\n    iovs[2].iov_len = size;\n    iovs[3].iov_base = (char*)SRS_HTTP_CRLF;\n    iovs[3].iov_len = 2;\n    \n    ssize_t nwrite;\n    if ((ret = skt->writev(iovs, 4, &nwrite)) != ERROR_SUCCESS) {\n        return ret;\n    }\n    \n    return ret;\n}\n\nint SrsHttpResponseWriter::writev(iovec* iov, int iovcnt, ssize_t* pnwrite)\n{\n    int ret = ERROR_SUCCESS;\n    \n    // when header not ready, or not chunked, send one by one.\n    if (!header_wrote || content_length != -1) {\n        ssize_t nwrite = 0;\n        for (int i = 0; i < iovcnt; i++) {\n            iovec* piovc = iov + i;\n            nwrite += piovc->iov_len;\n            if ((ret = write((char*)piovc->iov_base, (int)piovc->iov_len)) != ERROR_SUCCESS) {\n                return ret;\n            }\n        }\n        \n        if (pnwrite) {\n            *pnwrite = nwrite;\n        }\n        \n        return ret;\n    }\n    \n    // ignore NULL content.\n    if (iovcnt <= 0) {\n        return ret;\n    }\n    \n    // send in chunked encoding.\n    int nb_iovss = 3 + iovcnt;\n    iovec* iovss = iovss_cache;\n    if (nb_iovss_cache < nb_iovss) {\n        srs_freepa(iovss_cache);\n        nb_iovss_cache = nb_iovss;\n        iovss = iovss_cache = new iovec[nb_iovss];\n    }\n    \n    // send in chunked encoding.\n    \n    // chunk size.\n    int size = 0;\n    for (int i = 0; i < iovcnt; i++) {\n        iovec* data_iov = iov + i;\n        size += data_iov->iov_len;\n    }\n    written += size;\n    \n    // chunk header\n    int nb_size = snprintf(header_cache, SRS_HTTP_HEADER_CACHE_SIZE, \"%x\", size);\n    iovec* iovs = iovss;\n    iovs[0].iov_base = (char*)header_cache;\n    iovs[0].iov_len = (int)nb_size;\n    iovs++;\n    \n    // chunk header eof.\n    iovs[0].iov_base = (char*)SRS_HTTP_CRLF;\n    iovs[0].iov_len = 2;\n    iovs++;\n    \n    // chunk body.\n    for (int i = 0; i < iovcnt; i++) {\n        iovec* data_iov = iov + i;\n        iovs[0].iov_base = (char*)data_iov->iov_base;\n        iovs[0].iov_len = (int)data_iov->iov_len;\n        iovs++;\n    }\n    \n    // chunk body eof.\n    iovs[0].iov_base = (char*)SRS_HTTP_CRLF;\n    iovs[0].iov_len = 2;\n    iovs++;\n    \n    // sendout all ioves.\n    ssize_t nwrite;\n    if ((ret = srs_write_large_iovs(skt, iovss, nb_iovss, &nwrite)) != ERROR_SUCCESS) {\n        return ret;\n    }\n    \n    if (pnwrite) {\n        *pnwrite = nwrite;\n    }\n    \n    return ret;\n}\n\nvoid SrsHttpResponseWriter::write_header(int code)\n{\n    if (header_wrote) {\n        srs_warn(\"http: multiple write_header calls, code=%d\", code);\n        return;\n    }\n    \n    header_wrote = true;\n    status = code;\n    \n    // parse the content length from header.\n    content_length = hdr->content_length();\n}\n\nint SrsHttpResponseWriter::send_header(char* data, int size)\n{\n    int ret = ERROR_SUCCESS;\n    \n    if (header_sent) {\n        return ret;\n    }\n    header_sent = true;\n    \n    std::stringstream ss;\n    \n    // status_line\n    ss << \"HTTP/1.1 \" << status << \" \"\n        << srs_generate_http_status_text(status) << SRS_HTTP_CRLF;\n    \n    // detect content type\n    if (srs_go_http_body_allowd(status)) {\n        if (hdr->content_type().empty()) {\n            hdr->set_content_type(srs_go_http_detect(data, size));\n        }\n    }\n    \n    // set server if not set.\n    if (hdr->get(\"Server\").empty()) {\n        hdr->set(\"Server\", RTMP_SIG_SRS_SERVER);\n    }\n    \n    // chunked encoding\n    if (content_length == -1) {\n        hdr->set(\"Transfer-Encoding\", \"chunked\");\n    }\n    \n    // keep alive to make vlc happy.\n    hdr->set(\"Connection\", \"Keep-Alive\");\n    \n    // write headers\n    hdr->write(ss);\n    \n    // header_eof\n    ss << SRS_HTTP_CRLF;\n    \n    std::string buf = ss.str();\n    return skt->write((void*)buf.c_str(), buf.length(), NULL);\n}\n\nSrsHttpResponseReader::SrsHttpResponseReader(SrsHttpMessage* msg, SrsStSocket* io)\n{\n    skt = io;\n    owner = msg;\n    is_eof = false;\n    nb_total_read = 0;\n    nb_left_chunk = 0;\n    buffer = NULL;\n}\n\nSrsHttpResponseReader::~SrsHttpResponseReader()\n{\n}\n\nint SrsHttpResponseReader::initialize(SrsFastBuffer* body)\n{\n    int ret = ERROR_SUCCESS;\n    \n    nb_chunk = 0;\n    nb_left_chunk = 0;\n    nb_total_read = 0;\n    buffer = body;\n    \n    return ret;\n}\n\nbool SrsHttpResponseReader::eof()\n{\n    return is_eof;\n}\n\nint SrsHttpResponseReader::read(char* data, int nb_data, int* nb_read)\n{\n    int ret = ERROR_SUCCESS;\n    \n    if (is_eof) {\n        ret = ERROR_HTTP_RESPONSE_EOF;\n        srs_error(\"http: response EOF. ret=%d\", ret);\n        return ret;\n    }\n    \n    // chunked encoding.\n    if (owner->is_chunked()) {\n        return read_chunked(data, nb_data, nb_read);\n    }\n    \n    // read by specified content-length\n    if (owner->content_length() != -1) {\n        int max = (int)owner->content_length() - (int)nb_total_read;\n        if (max <= 0) {\n            is_eof = true;\n            return ret;\n        }\n        \n        // change the max to read.\n        nb_data = srs_min(nb_data, max);\n        return read_specified(data, nb_data, nb_read);\n    }\n    \n    // infinite chunked mode, directly read.\n    if (owner->is_infinite_chunked()) {\n        srs_assert(!owner->is_chunked() && owner->content_length() == -1);\n        return read_specified(data, nb_data, nb_read);\n    }\n    \n    // infinite chunked mode, but user not set it,\n    // we think there is no data left.\n    is_eof = true;\n    \n    return ret;\n}\n\nint SrsHttpResponseReader::read_chunked(char* data, int nb_data, int* nb_read)\n{\n    int ret = ERROR_SUCCESS;\n    \n    // when no bytes left in chunk,\n    // parse the chunk length first.\n    if (nb_left_chunk <= 0) {\n        char* at = NULL;\n        int length = 0;\n        while (!at) {\n            // find the CRLF of chunk header end.\n            char* start = buffer->bytes();\n            char* end = start + buffer->size();\n            for (char* p = start; p < end - 1; p++) {\n                if (p[0] == SRS_HTTP_CR && p[1] == SRS_HTTP_LF) {\n                    // invalid chunk, ignore.\n                    if (p == start) {\n                        ret = ERROR_HTTP_INVALID_CHUNK_HEADER;\n                        srs_error(\"chunk header start with CRLF. ret=%d\", ret);\n                        return ret;\n                    }\n                    length = (int)(p - start + 2);\n                    at = buffer->read_slice(length);\n                    break;\n                }\n            }\n            \n            // got at, ok.\n            if (at) {\n                break;\n            }\n            \n            // when empty, only grow 1bytes, but the buffer will cache more.\n            if ((ret = buffer->grow(skt, buffer->size() + 1)) != ERROR_SUCCESS) {\n                if (!srs_is_client_gracefully_close(ret)) {\n                    srs_error(\"read body from server failed. ret=%d\", ret);\n                }\n                return ret;\n            }\n        }\n        srs_assert(length >= 3);\n        \n        // it's ok to set the pos and pos+1 to NULL.\n        at[length - 1] = 0;\n        at[length - 2] = 0;\n        \n        // size is the bytes size, excludes the chunk header and end CRLF.\n        int ilength = (int)::strtol(at, NULL, 16);\n        if (ilength < 0) {\n            ret = ERROR_HTTP_INVALID_CHUNK_HEADER;\n            srs_error(\"chunk header negative, length=%d. ret=%d\", ilength, ret);\n            return ret;\n        }\n        \n        // all bytes in chunk is left now.\n        nb_chunk = nb_left_chunk = ilength;\n    }\n    \n    if (nb_chunk <= 0) {\n        // for the last chunk, eof.\n        is_eof = true;\n    } else {\n        // for not the last chunk, there must always exists bytes.\n        // left bytes in chunk, read some.\n        srs_assert(nb_left_chunk);\n        \n        int nb_bytes = srs_min(nb_left_chunk, nb_data);\n        ret = read_specified(data, nb_bytes, &nb_bytes);\n        \n        // the nb_bytes used for output already read size of bytes.\n        if (nb_read) {\n            *nb_read = nb_bytes;\n        }\n        nb_left_chunk -= nb_bytes;\n        srs_info(\"http: read %d bytes of chunk\", nb_bytes);\n        \n        // error or still left bytes in chunk, ignore and read in future.\n        if (nb_left_chunk > 0 || (ret != ERROR_SUCCESS)) {\n            return ret;\n        }\n        srs_info(\"http: read total chunk %dB\", nb_chunk);\n    }\n    \n    // for both the last or not, the CRLF of chunk payload end.\n    if ((ret = buffer->grow(skt, 2)) != ERROR_SUCCESS) {\n        if (!srs_is_client_gracefully_close(ret)) {\n            srs_error(\"read EOF of chunk from server failed. ret=%d\", ret);\n        }\n        return ret;\n    }\n    buffer->read_slice(2);\n    \n    return ret;\n}\n\nint SrsHttpResponseReader::read_specified(char* data, int nb_data, int* nb_read)\n{\n    int ret = ERROR_SUCCESS;\n    \n    if (buffer->size() <= 0) {\n        // when empty, only grow 1bytes, but the buffer will cache more.\n        if ((ret = buffer->grow(skt, 1)) != ERROR_SUCCESS) {\n            if (!srs_is_client_gracefully_close(ret)) {\n                srs_error(\"read body from server failed. ret=%d\", ret);\n            }\n            return ret;\n        }\n    }\n    \n    int nb_bytes = srs_min(nb_data, buffer->size());\n    \n    // read data to buffer.\n    srs_assert(nb_bytes);\n    char* p = buffer->read_slice(nb_bytes);\n    memcpy(data, p, nb_bytes);\n    if (nb_read) {\n        *nb_read = nb_bytes;\n    }\n    \n    // increase the total read to determine whether EOF.\n    nb_total_read += nb_bytes;\n    \n    // for not chunked and specified content length.\n    if (!owner->is_chunked() && owner->content_length() != -1) {\n        // when read completed, eof.\n        if (nb_total_read >= (int)owner->content_length()) {\n            is_eof = true;\n        }\n    }\n    \n    return ret;\n}\n\nSrsHttpMessage::SrsHttpMessage(SrsStSocket* io, SrsConnection* c) : ISrsHttpMessage()\n{\n    conn = c;\n    chunked = false;\n    infinite_chunked = false;\n    keep_alive = true;\n    _uri = new SrsHttpUri();\n    _body = new SrsHttpResponseReader(this, io);\n    _http_ts_send_buffer = new char[SRS_HTTP_TS_SEND_BUFFER_SIZE];\n    jsonp = false;\n}\n\nSrsHttpMessage::~SrsHttpMessage()\n{\n    srs_freep(_body);\n    srs_freep(_uri);\n    srs_freepa(_http_ts_send_buffer);\n}\n\nint SrsHttpMessage::update(string url, http_parser* header, SrsFastBuffer* body, vector<SrsHttpHeaderField>& headers)\n{\n    int ret = ERROR_SUCCESS;\n    \n    _url = url;\n    _header = *header;\n    _headers = headers;\n    \n    // whether chunked.\n    std::string transfer_encoding = get_request_header(\"Transfer-Encoding\");\n    chunked = (transfer_encoding == \"chunked\");\n    \n    // whether keep alive.\n    keep_alive = http_should_keep_alive(header);\n    \n    // set the buffer.\n    if ((ret = _body->initialize(body)) != ERROR_SUCCESS) {\n        return ret;\n    }\n    \n    // parse uri from url.\n    std::string host = get_request_header(\"Host\");\n    \n    // use server public ip when no host specified.\n    // to make telnet happy.\n    if (host.empty()) {\n        host= srs_get_public_internet_address();\n    }\n    \n    // parse uri to schema/server:port/path?query\n    std::string uri = \"http://\" + host + _url;\n    if ((ret = _uri->initialize(uri)) != ERROR_SUCCESS) {\n        return ret;\n    }\n    \n    // must format as key=value&...&keyN=valueN\n    std::string q = _uri->get_query();\n    size_t pos = string::npos;\n    while (!q.empty()) {\n        std::string k = q;\n        if ((pos = q.find(\"=\")) != string::npos) {\n            k = q.substr(0, pos);\n            q = q.substr(pos + 1);\n        } else {\n            q = \"\";\n        }\n        \n        std::string v = q;\n        if ((pos = q.find(\"&\")) != string::npos) {\n            v = q.substr(0, pos);\n            q = q.substr(pos + 1);\n        } else {\n            q = \"\";\n        }\n        \n        _query[k] = v;\n    }\n    \n    // parse ext.\n    _ext = _uri->get_path();\n    if ((pos = _ext.rfind(\".\")) != string::npos) {\n        _ext = _ext.substr(pos);\n    } else {\n        _ext = \"\";\n    }\n    \n    // parse jsonp request message.\n    if (!query_get(\"callback\").empty()) {\n        jsonp = true;\n    }\n    if (jsonp) {\n        jsonp_method = query_get(\"method\");\n    }\n    \n    return ret;\n}\n\nSrsConnection* SrsHttpMessage::connection()\n{\n    return conn;\n}\n\nu_int8_t SrsHttpMessage::method()\n{\n    if (jsonp && !jsonp_method.empty()) {\n        if (jsonp_method == \"GET\") {\n            return SRS_CONSTS_HTTP_GET;\n        } else if (jsonp_method == \"PUT\") {\n            return SRS_CONSTS_HTTP_PUT;\n        } else if (jsonp_method == \"POST\") {\n            return SRS_CONSTS_HTTP_POST;\n        } else if (jsonp_method == \"DELETE\") {\n            return SRS_CONSTS_HTTP_DELETE;\n        }\n    }\n    \n    return (u_int8_t)_header.method;\n}\n\nu_int16_t SrsHttpMessage::status_code()\n{\n    return (u_int16_t)_header.status_code;\n}\n\nstring SrsHttpMessage::method_str()\n{\n    if (jsonp && !jsonp_method.empty()) {\n        return jsonp_method;\n    }\n    \n    if (is_http_get()) {\n        return \"GET\";\n    }\n    if (is_http_put()) {\n        return \"PUT\";\n    }\n    if (is_http_post()) {\n        return \"POST\";\n    }\n    if (is_http_delete()) {\n        return \"DELETE\";\n    }\n    if (is_http_options()) {\n        return \"OPTIONS\";\n    }\n    \n    return \"OTHER\";\n}\n\nbool SrsHttpMessage::is_http_get()\n{\n    return method() == SRS_CONSTS_HTTP_GET;\n}\n\nbool SrsHttpMessage::is_http_put()\n{\n    return method() == SRS_CONSTS_HTTP_PUT;\n}\n\nbool SrsHttpMessage::is_http_post()\n{\n    return method() == SRS_CONSTS_HTTP_POST;\n}\n\nbool SrsHttpMessage::is_http_delete()\n{\n    return method() == SRS_CONSTS_HTTP_DELETE;\n}\n\nbool SrsHttpMessage::is_http_options()\n{\n    return _header.method == SRS_CONSTS_HTTP_OPTIONS;\n}\n\nbool SrsHttpMessage::is_chunked()\n{\n    return chunked;\n}\n\nbool SrsHttpMessage::is_keep_alive()\n{\n    return keep_alive;\n}\n\nbool SrsHttpMessage::is_infinite_chunked()\n{\n    return infinite_chunked;\n}\n\nstring SrsHttpMessage::uri()\n{\n    std::string uri = _uri->get_schema();\n    if (uri.empty()) {\n        uri += \"http\";\n    }\n    uri += \"://\";\n    \n    uri += host();\n    uri += path();\n    \n    return uri;\n}\n\nstring SrsHttpMessage::url()\n{\n    return _uri->get_url();\n}\n\nstring SrsHttpMessage::host()\n{\n    return _uri->get_host();\n}\n\nstring SrsHttpMessage::path()\n{\n    return _uri->get_path();\n}\n\nstring SrsHttpMessage::query()\n{\n    return _uri->get_query();\n}\n\nstring SrsHttpMessage::ext()\n{\n    return _ext;\n}\n\nint SrsHttpMessage::parse_rest_id(string pattern)\n{\n    string p = _uri->get_path();\n    if (p.length() <= pattern.length()) {\n        return -1;\n    }\n    \n    string id = p.substr((int)pattern.length());\n    if (!id.empty()) {\n        return ::atoi(id.c_str());\n    }\n    \n    return -1;\n}\n\nint SrsHttpMessage::enter_infinite_chunked()\n{\n    int ret = ERROR_SUCCESS;\n    \n    if (infinite_chunked) {\n        return ret;\n    }\n    \n    if (is_chunked() || content_length() != -1) {\n        ret = ERROR_HTTP_DATA_INVALID;\n        srs_error(\"infinite chunkted not supported in specified codec. ret=%d\", ret);\n        return ret;\n    }\n    \n    infinite_chunked = true;\n    \n    return ret;\n}\n\nint SrsHttpMessage::body_read_all(string& body)\n{\n    int ret = ERROR_SUCCESS;\n    \n    // cache to read.\n    char* buf = new char[SRS_HTTP_READ_CACHE_BYTES];\n    SrsAutoFreeA(char, buf);\n    \n    // whatever, read util EOF.\n    while (!_body->eof()) {\n        int nb_read = 0;\n        if ((ret = _body->read(buf, SRS_HTTP_READ_CACHE_BYTES, &nb_read)) != ERROR_SUCCESS) {\n            return ret;\n        }\n        \n        if (nb_read > 0) {\n            body.append(buf, nb_read);\n        }\n    }\n    \n    return ret;\n}\n\nISrsHttpResponseReader* SrsHttpMessage::body_reader()\n{\n    return _body;\n}\n\nint64_t SrsHttpMessage::content_length()\n{\n    return _header.content_length;\n}\n\nstring SrsHttpMessage::query_get(string key)\n{\n    std::string v;\n    \n    if (_query.find(key) != _query.end()) {\n        v = _query[key];\n    }\n    \n    return v;\n}\n\nint SrsHttpMessage::request_header_count()\n{\n    return (int)_headers.size();\n}\n\nstring SrsHttpMessage::request_header_key_at(int index)\n{\n    srs_assert(index < request_header_count());\n    SrsHttpHeaderField item = _headers[index];\n    return item.first;\n}\n\nstring SrsHttpMessage::request_header_value_at(int index)\n{\n    srs_assert(index < request_header_count());\n    SrsHttpHeaderField item = _headers[index];\n    return item.second;\n}\n\nstring SrsHttpMessage::get_request_header(string name)\n{\n    std::vector<SrsHttpHeaderField>::iterator it;\n    \n    for (it = _headers.begin(); it != _headers.end(); ++it) {\n        SrsHttpHeaderField& elem = *it;\n        std::string key = elem.first;\n        std::string value = elem.second;\n        if (key == name) {\n            return value;\n        }\n    }\n    \n    return \"\";\n}\n\nSrsRequest* SrsHttpMessage::to_request(string vhost)\n{\n    SrsRequest* req = new SrsRequest();\n    \n    req->app = _uri->get_path();\n    size_t pos = string::npos;\n    if ((pos = req->app.rfind(\"/\")) != string::npos) {\n        req->stream = req->app.substr(pos + 1);\n        req->app = req->app.substr(0, pos);\n    }\n    if ((pos = req->stream.rfind(\".\")) != string::npos) {\n        req->stream = req->stream.substr(0, pos);\n    }\n    \n    req->tcUrl = \"rtmp://\" + vhost + req->app;\n    req->pageUrl = get_request_header(\"Referer\");\n    req->objectEncoding = 0;\n    \n    srs_discovery_tc_url(req->tcUrl,\n                         req->schema, req->host, req->vhost, req->app, req->port,\n                         req->param);\n    req->strip();\n    \n    return req;\n}\n\nbool SrsHttpMessage::is_jsonp()\n{\n    return jsonp;\n}\n\nSrsHttpParser::SrsHttpParser()\n{\n    buffer = new SrsFastBuffer();\n}\n\nSrsHttpParser::~SrsHttpParser()\n{\n    srs_freep(buffer);\n}\n\nint SrsHttpParser::initialize(enum http_parser_type type)\n{\n    int ret = ERROR_SUCCESS;\n    \n    memset(&settings, 0, sizeof(settings));\n    settings.on_message_begin = on_message_begin;\n    settings.on_url = on_url;\n    settings.on_header_field = on_header_field;\n    settings.on_header_value = on_header_value;\n    settings.on_headers_complete = on_headers_complete;\n    settings.on_body = on_body;\n    settings.on_message_complete = on_message_complete;\n    \n    http_parser_init(&parser, type);\n    // callback object ptr.\n    parser.data = (void*)this;\n    \n    return ret;\n}\n\nint SrsHttpParser::parse_message(SrsStSocket* skt, SrsConnection* conn, ISrsHttpMessage** ppmsg)\n{\n    *ppmsg = NULL;\n    \n    int ret = ERROR_SUCCESS;\n    \n    // reset request data.\n    field_name = \"\";\n    field_value = \"\";\n    expect_field_name = true;\n    state = SrsHttpParseStateInit;\n    header = http_parser();\n    url = \"\";\n    headers.clear();\n    header_parsed = 0;\n    \n    // do parse\n    if ((ret = parse_message_imp(skt)) != ERROR_SUCCESS) {\n        if (!srs_is_client_gracefully_close(ret)) {\n            srs_error(\"parse http msg failed. ret=%d\", ret);\n        }\n        return ret;\n    }\n    \n    // create msg\n    SrsHttpMessage* msg = new SrsHttpMessage(skt, conn);\n    \n    // initalize http msg, parse url.\n    if ((ret = msg->update(url, &header, buffer, headers)) != ERROR_SUCCESS) {\n        srs_error(\"initialize http msg failed. ret=%d\", ret);\n        srs_freep(msg);\n        return ret;\n    }\n    \n    // parse ok, return the msg.\n    *ppmsg = msg;\n    \n    return ret;\n}\n\nint SrsHttpParser::parse_message_imp(SrsStSocket* skt)\n{\n    int ret = ERROR_SUCCESS;\n    \n    while (true) {\n        ssize_t nparsed = 0;\n        \n        // when got entire http header, parse it.\n        // @see https://github.com/ossrs/srs/issues/400\n        char* start = buffer->bytes();\n        char* end = start + buffer->size();\n        for (char* p = start; p <= end - 4; p++) {\n            // SRS_HTTP_CRLFCRLF \"\\r\\n\\r\\n\" // 0x0D0A0D0A\n            if (p[0] == SRS_CONSTS_CR && p[1] == SRS_CONSTS_LF && p[2] == SRS_CONSTS_CR && p[3] == SRS_CONSTS_LF) {\n                nparsed = http_parser_execute(&parser, &settings, buffer->bytes(), buffer->size());\n                srs_info(\"buffer=%d, nparsed=%d, header=%d\", buffer->size(), (int)nparsed, header_parsed);\n                break;\n            }\n        }\n        \n        // consume the parsed bytes.\n        if (nparsed && header_parsed) {\n            buffer->read_slice(header_parsed);\n        }\n        \n        // ok atleast header completed,\n        // never wait for body completed, for maybe chunked.\n        if (state == SrsHttpParseStateHeaderComplete || state == SrsHttpParseStateMessageComplete) {\n            break;\n        }\n        \n        // when nothing parsed, read more to parse.\n        if (nparsed == 0) {\n            // when requires more, only grow 1bytes, but the buffer will cache more.\n            if ((ret = buffer->grow(skt, buffer->size() + 1)) != ERROR_SUCCESS) {\n                if (!srs_is_client_gracefully_close(ret)) {\n                    srs_error(\"read body from server failed. ret=%d\", ret);\n                }\n                return ret;\n            }\n        }\n    }\n    \n    // parse last header.\n    if (!field_name.empty() && !field_value.empty()) {\n        headers.push_back(std::make_pair(field_name, field_value));\n    }\n    \n    return ret;\n}\n\nint SrsHttpParser::on_message_begin(http_parser* parser)\n{\n    SrsHttpParser* obj = (SrsHttpParser*)parser->data;\n    srs_assert(obj);\n    \n    obj->state = SrsHttpParseStateStart;\n    \n    srs_info(\"***MESSAGE BEGIN***\");\n    \n    return 0;\n}\n\nint SrsHttpParser::on_headers_complete(http_parser* parser)\n{\n    SrsHttpParser* obj = (SrsHttpParser*)parser->data;\n    srs_assert(obj);\n    \n    obj->header = *parser;\n    // save the parser when header parse completed.\n    obj->state = SrsHttpParseStateHeaderComplete;\n    obj->header_parsed = (int)parser->nread;\n    \n    srs_info(\"***HEADERS COMPLETE***\");\n    \n    // see http_parser.c:1570, return 1 to skip body.\n    return 0;\n}\n\nint SrsHttpParser::on_message_complete(http_parser* parser)\n{\n    SrsHttpParser* obj = (SrsHttpParser*)parser->data;\n    srs_assert(obj);\n    \n    // save the parser when body parse completed.\n    obj->state = SrsHttpParseStateMessageComplete;\n    \n    srs_info(\"***MESSAGE COMPLETE***\\n\");\n    \n    return 0;\n}\n\nint SrsHttpParser::on_url(http_parser* parser, const char* at, size_t length)\n{\n    SrsHttpParser* obj = (SrsHttpParser*)parser->data;\n    srs_assert(obj);\n    \n    if (length > 0) {\n        obj->url.append(at, (int)length);\n    }\n    \n    srs_info(\"Method: %d, Url: %.*s\", parser->method, (int)length, at);\n    \n    return 0;\n}\n\nint SrsHttpParser::on_header_field(http_parser* parser, const char* at, size_t length)\n{\n    SrsHttpParser* obj = (SrsHttpParser*)parser->data;\n    srs_assert(obj);\n    \n    // field value=>name, reap the field.\n    if (!obj->expect_field_name) {\n        obj->headers.push_back(std::make_pair(obj->field_name, obj->field_value));\n        \n        // reset the field name when parsed.\n        obj->field_name = \"\";\n        obj->field_value = \"\";\n    }\n    obj->expect_field_name = true;\n    \n    if (length > 0) {\n        obj->field_name.append(at, (int)length);\n    }\n    \n    srs_info(\"Header field(%d bytes): %.*s\", (int)length, (int)length, at);\n    return 0;\n}\n\nint SrsHttpParser::on_header_value(http_parser* parser, const char* at, size_t length)\n{\n    SrsHttpParser* obj = (SrsHttpParser*)parser->data;\n    srs_assert(obj);\n    \n    if (length > 0) {\n        obj->field_value.append(at, (int)length);\n    }\n    obj->expect_field_name = false;\n    \n    srs_info(\"Header value(%d bytes): %.*s\", (int)length, (int)length, at);\n    return 0;\n}\n\nint SrsHttpParser::on_body(http_parser* parser, const char* at, size_t length)\n{\n    SrsHttpParser* obj = (SrsHttpParser*)parser->data;\n    srs_assert(obj);\n    \n    srs_info(\"Body: %.*s\", (int)length, at);\n    \n    return 0;\n}\n\nSrsHttpUri::SrsHttpUri()\n{\n    port = SRS_DEFAULT_HTTP_PORT;\n}\n\nSrsHttpUri::~SrsHttpUri()\n{\n}\n\nint SrsHttpUri::initialize(string _url)\n{\n    int ret = ERROR_SUCCESS;\n    \n    url = _url;\n    const char* purl = url.c_str();\n    \n    http_parser_url hp_u;\n    if((ret = http_parser_parse_url(purl, url.length(), 0, &hp_u)) != 0){\n        int code = ret;\n        ret = ERROR_HTTP_PARSE_URI;\n        \n        srs_error(\"parse url %s failed, code=%d, ret=%d\", purl, code, ret);\n        return ret;\n    }\n    \n    std::string field = get_uri_field(url, &hp_u, UF_SCHEMA);\n    if(!field.empty()){\n        schema = field;\n    }\n    \n    host = get_uri_field(url, &hp_u, UF_HOST);\n    \n    field = get_uri_field(url, &hp_u, UF_PORT);\n    if(!field.empty()){\n        port = atoi(field.c_str());\n    }\n    \n    path = get_uri_field(url, &hp_u, UF_PATH);\n    srs_info(\"parse url %s success\", purl);\n    \n    query = get_uri_field(url, &hp_u, UF_QUERY);\n    srs_info(\"parse query %s success\", query.c_str());\n    \n    return ret;\n}\n\nconst char* SrsHttpUri::get_url()\n{\n    return url.data();\n}\n\nconst char* SrsHttpUri::get_schema()\n{\n    return schema.data();\n}\n\nconst char* SrsHttpUri::get_host()\n{\n    return host.data();\n}\n\nint SrsHttpUri::get_port()\n{\n    return port;\n}\n\nconst char* SrsHttpUri::get_path()\n{\n    return path.data();\n}\n\nconst char* SrsHttpUri::get_query()\n{\n    return query.data();\n}\n\nstring SrsHttpUri::get_uri_field(string uri, http_parser_url* hp_u, http_parser_url_fields field)\n{\n    if((hp_u->field_set & (1 << field)) == 0){\n        return \"\";\n    }\n    \n    srs_verbose(\"uri field matched, off=%d, len=%d, value=%.*s\",\n                hp_u->field_data[field].off,\n                hp_u->field_data[field].len,\n                hp_u->field_data[field].len,\n                uri.c_str() + hp_u->field_data[field].off);\n    \n    int offset = hp_u->field_data[field].off;\n    int len = hp_u->field_data[field].len;\n    \n    return uri.substr(offset, len);\n}\n\nSrsHttpConn::SrsHttpConn(IConnectionManager* cm, st_netfd_t fd, ISrsHttpServeMux* m)\n    : SrsConnection(cm, fd)",
        "res_region": "SrsHttpConn::SrsHttpConn(IConnectionManager* cm, srs_netfd_t fd, ISrsHttpServeMux* m, string cip) : SrsConnection(cm, fd, cip)",
        "lookback": "{",
        "lookahead": "{",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 61,
        "end_line": 2343,
        "merge_gen_region": null,
        "confidence": 0.19306132197380066,
        "hesitated": true
    }
]