[
    {
        "a_contents": "        if ((err = dec->read_previous_tag_size(pps)) != srs_success) {\n            return srs_error_wrap(err, \"read pts\");\n        }",
        "b_contents": "        srs_discovery_tc_url(req->tcUrl,\n                             req->schema, req->host, req->vhost, req->app, req->stream, req->port,\n                             req->param);\n    }\n    \n    // connect host.\n    if ((ret = srs_socket_connect(req->host, ::atoi(req->port.c_str()), ST_UTIME_NO_TIMEOUT, &stfd)) != ERROR_SUCCESS) {\n        srs_error(\"mpegts: connect server %s:%s failed. ret=%d\", req->host.c_str(), req->port.c_str(), ret);\n        return ret;\n    }\n    io = new SrsStSocket(stfd);\n    client = new SrsRtmpClient(io);\n    \n    client->set_recv_timeout(SRS_CONSTS_RTMP_RECV_TIMEOUT_US);\n    client->set_send_timeout(SRS_CONSTS_RTMP_SEND_TIMEOUT_US);\n    \n    // connect to vhost/app\n    if ((ret = client->handshake()) != ERROR_SUCCESS) {\n        srs_error(\"mpegts: handshake with server failed. ret=%d\", ret);\n        return ret;\n    }\n    if ((ret = connect_app(req->host, req->port)) != ERROR_SUCCESS) {\n        srs_error(\"mpegts: connect with server failed. ret=%d\", ret);\n        return ret;\n    }\n    if ((ret = client->create_stream(stream_id)) != ERROR_SUCCESS) {\n        srs_error(\"mpegts: connect with server failed, stream_id=%d. ret=%d\", stream_id, ret);\n        return ret;\n    }\n    \n    // publish.\n    if ((ret = client->publish(req->stream, stream_id)) != ERROR_SUCCESS) {\n        srs_error(\"mpegts: publish failed, stream=%s, stream_id=%d. ret=%d\",\n                  req->stream.c_str(), stream_id, ret);\n        return ret;\n    }\n    \n    return ret;\n}\n\n// TODO: FIXME: refine the connect_app.\nint SrsDynamicHttpConn::connect_app(string ep_server, string ep_port)\n{\n    int ret = ERROR_SUCCESS;\n    \n    // args of request takes the srs info.\n    if (req->args == NULL) {\n        req->args = SrsAmf0Any::object();\n    }\n    \n    // notify server the edge identity,\n    // @see https://github.com/ossrs/srs/issues/147\n    SrsAmf0Object* data = req->args;\n    data->set(\"srs_sig\", SrsAmf0Any::str(RTMP_SIG_SRS_KEY));\n    data->set(\"srs_server\", SrsAmf0Any::str(RTMP_SIG_SRS_KEY\" \"RTMP_SIG_SRS_VERSION\" (\"RTMP_SIG_SRS_URL_SHORT\")\"));\n    data->set(\"srs_license\", SrsAmf0Any::str(RTMP_SIG_SRS_LICENSE));\n    data->set(\"srs_role\", SrsAmf0Any::str(RTMP_SIG_SRS_ROLE));\n    data->set(\"srs_url\", SrsAmf0Any::str(RTMP_SIG_SRS_URL));\n    data->set(\"srs_version\", SrsAmf0Any::str(RTMP_SIG_SRS_VERSION));\n    data->set(\"srs_site\", SrsAmf0Any::str(RTMP_SIG_SRS_WEB));\n    data->set(\"srs_email\", SrsAmf0Any::str(RTMP_SIG_SRS_EMAIL));\n    data->set(\"srs_copyright\", SrsAmf0Any::str(RTMP_SIG_SRS_COPYRIGHT));\n    data->set(\"srs_primary\", SrsAmf0Any::str(RTMP_SIG_SRS_PRIMARY));\n    data->set(\"srs_authors\", SrsAmf0Any::str(RTMP_SIG_SRS_AUTHROS));\n    // for edge to directly get the id of client.\n    data->set(\"srs_pid\", SrsAmf0Any::number(getpid()));\n    data->set(\"srs_id\", SrsAmf0Any::number(_srs_context->get_id()));\n    \n    // local ip of edge\n    std::vector<std::string> ips = srs_get_local_ipv4_ips();\n    assert(_srs_config->get_stats_network() < (int)ips.size());\n    std::string local_ip = ips[_srs_config->get_stats_network()];\n    data->set(\"srs_server_ip\", SrsAmf0Any::str(local_ip.c_str()));\n    \n    // generate the tcUrl\n    std::string param = \"\";\n    std::string tc_url = srs_generate_tc_url(ep_server, req->vhost, req->app, ep_port, param);\n    \n    // upnode server identity will show in the connect_app of client.\n    // @see https://github.com/ossrs/srs/issues/160\n    // the debug_srs_upnode is config in vhost and default to true.\n    bool debug_srs_upnode = _srs_config->get_debug_srs_upnode(req->vhost);\n    if ((ret = client->connect_app(req->app, tc_url, req, debug_srs_upnode)) != ERROR_SUCCESS) {\n        srs_error(\"mpegts: connect with server failed, tcUrl=%s, dsu=%d. ret=%d\",\n                  tc_url.c_str(), debug_srs_upnode, ret);\n        return ret;",
        "base_contents": "        srs_discovery_tc_url(req->tcUrl,\n                             req->schema, req->host, req->vhost, req->app, req->port,\n                             req->param);\n    }\n    \n    // connect host.\n    if ((ret = srs_socket_connect(req->host, ::atoi(req->port.c_str()), ST_UTIME_NO_TIMEOUT, &stfd)) != ERROR_SUCCESS) {\n        srs_error(\"mpegts: connect server %s:%s failed. ret=%d\", req->host.c_str(), req->port.c_str(), ret);\n        return ret;\n    }\n    io = new SrsStSocket(stfd);\n    client = new SrsRtmpClient(io);\n    \n    client->set_recv_timeout(SRS_CONSTS_RTMP_RECV_TIMEOUT_US);\n    client->set_send_timeout(SRS_CONSTS_RTMP_SEND_TIMEOUT_US);\n    \n    // connect to vhost/app\n    if ((ret = client->handshake()) != ERROR_SUCCESS) {\n        srs_error(\"mpegts: handshake with server failed. ret=%d\", ret);\n        return ret;\n    }\n    if ((ret = connect_app(req->host, req->port)) != ERROR_SUCCESS) {\n        srs_error(\"mpegts: connect with server failed. ret=%d\", ret);\n        return ret;\n    }\n    if ((ret = client->create_stream(stream_id)) != ERROR_SUCCESS) {\n        srs_error(\"mpegts: connect with server failed, stream_id=%d. ret=%d\", stream_id, ret);\n        return ret;\n    }\n    \n    // publish.\n    if ((ret = client->publish(req->stream, stream_id)) != ERROR_SUCCESS) {\n        srs_error(\"mpegts: publish failed, stream=%s, stream_id=%d. ret=%d\",\n                  req->stream.c_str(), stream_id, ret);\n        return ret;\n    }\n    \n    return ret;\n}\n\n// TODO: FIXME: refine the connect_app.\nint SrsDynamicHttpConn::connect_app(string ep_server, string ep_port)\n{\n    int ret = ERROR_SUCCESS;\n    \n    // args of request takes the srs info.\n    if (req->args == NULL) {\n        req->args = SrsAmf0Any::object();\n    }\n    \n    // notify server the edge identity,\n    // @see https://github.com/ossrs/srs/issues/147\n    SrsAmf0Object* data = req->args;\n    data->set(\"srs_sig\", SrsAmf0Any::str(RTMP_SIG_SRS_KEY));\n    data->set(\"srs_server\", SrsAmf0Any::str(RTMP_SIG_SRS_KEY\" \"RTMP_SIG_SRS_VERSION\" (\"RTMP_SIG_SRS_URL_SHORT\")\"));\n    data->set(\"srs_license\", SrsAmf0Any::str(RTMP_SIG_SRS_LICENSE));\n    data->set(\"srs_role\", SrsAmf0Any::str(RTMP_SIG_SRS_ROLE));\n    data->set(\"srs_url\", SrsAmf0Any::str(RTMP_SIG_SRS_URL));\n    data->set(\"srs_version\", SrsAmf0Any::str(RTMP_SIG_SRS_VERSION));\n    data->set(\"srs_site\", SrsAmf0Any::str(RTMP_SIG_SRS_WEB));\n    data->set(\"srs_email\", SrsAmf0Any::str(RTMP_SIG_SRS_EMAIL));\n    data->set(\"srs_copyright\", SrsAmf0Any::str(RTMP_SIG_SRS_COPYRIGHT));\n    data->set(\"srs_primary\", SrsAmf0Any::str(RTMP_SIG_SRS_PRIMARY));\n    data->set(\"srs_authors\", SrsAmf0Any::str(RTMP_SIG_SRS_AUTHROS));\n    // for edge to directly get the id of client.\n    data->set(\"srs_pid\", SrsAmf0Any::number(getpid()));\n    data->set(\"srs_id\", SrsAmf0Any::number(_srs_context->get_id()));\n    \n    // local ip of edge\n    std::vector<std::string> ips = srs_get_local_ipv4_ips();\n    assert(_srs_config->get_stats_network() < (int)ips.size());\n    std::string local_ip = ips[_srs_config->get_stats_network()];\n    data->set(\"srs_server_ip\", SrsAmf0Any::str(local_ip.c_str()));\n    \n    // generate the tcUrl\n    std::string param = \"\";\n    std::string tc_url = srs_generate_tc_url(ep_server, req->vhost, req->app, ep_port, param);\n    \n    // upnode server identity will show in the connect_app of client.\n    // @see https://github.com/ossrs/srs/issues/160\n    // the debug_srs_upnode is config in vhost and default to true.\n    bool debug_srs_upnode = _srs_config->get_debug_srs_upnode(req->vhost);\n    if ((ret = client->connect_app(req->app, tc_url, req, debug_srs_upnode)) != ERROR_SUCCESS) {\n        srs_error(\"mpegts: connect with server failed, tcUrl=%s, dsu=%d. ret=%d\",\n                  tc_url.c_str(), debug_srs_upnode, ret);\n        return ret;",
        "res_region": "        if ((err = dec->read_previous_tag_size(pps)) != srs_success) {\n            return srs_error_wrap(err, \"read pts\");\n        }",
        "lookback": "            return srs_error_wrap(err, \"read pts\");",
        "lookahead": "    }",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 239,
        "end_line": 417,
        "merge_gen_region": " (( =->____()) !=_) return___",
        "confidence": 0.9303421974182129,
        "hesitated": false,
        "resolved": false
    }
]