[
    {
        "a_contents": "",
        "b_contents": "namespace internal {\n    ISrsThreadHandler::ISrsThreadHandler()\n    {\n    }\n    \n    ISrsThreadHandler::~ISrsThreadHandler()\n    {\n    }\n    \n    void ISrsThreadHandler::on_thread_start()\n    {\n    }\n    \n    int ISrsThreadHandler::on_before_cycle()\n    {\n        int ret = ERROR_SUCCESS;\n        return ret;\n    }\n    \n    int ISrsThreadHandler::on_end_cycle()\n    {\n        int ret = ERROR_SUCCESS;\n        return ret;\n    }\n    \n    void ISrsThreadHandler::on_thread_stop()\n    {\n    }\n    \n    SrsThread::SrsThread(const char* name, ISrsThreadHandler* thread_handler, int64_t interval_us, bool joinable)\n    {\n        _name = name;\n        handler = thread_handler;\n        cycle_interval_us = interval_us;\n        \n        tid = NULL;\n        loop = false;\n        really_terminated = true;\n        _cid = -1;\n        _joinable = joinable;\n        disposed = false;\n        \n        // in start(), the thread cycle method maybe stop and remove the thread itself,\n        // and the thread start() is waiting for the _cid, and segment fault then.\n        // @see https://github.com/ossrs/srs/issues/110\n        // thread will set _cid, callback on_thread_start(), then wait for the can_run signal.\n        can_run = false;\n    }\n    \n    SrsThread::~SrsThread()\n    {\n        stop();\n    }\n    \n    int SrsThread::cid()\n    {\n        return _cid;\n    }\n    \n    int SrsThread::start()\n    {\n        int ret = ERROR_SUCCESS;\n        \n        if(tid) {\n            srs_info(\"thread %s already running.\", _name);\n            return ret;\n        }\n        \n        if((tid = st_thread_create(thread_fun, this, (_joinable? 1:0), 0)) == NULL){\n            ret = ERROR_ST_CREATE_CYCLE_THREAD;\n            srs_error(\"st_thread_create failed. ret=%d\", ret);\n            return ret;\n        }\n        \n        disposed = false;\n        // we set to loop to true for thread to run.\n        loop = true;\n        \n        // wait for cid to ready, for parent thread to get the cid.\n        while (_cid < 0) {\n            st_usleep(10 * 1000);\n        }\n        \n        // now, cycle thread can run.\n        can_run = true;\n        \n        return ret;\n    }\n    \n    void SrsThread::stop()\n    {\n        if (!tid) {\n            return;\n        }\n        \n        loop = false;\n        \n        dispose();\n        \n        _cid = -1;\n        can_run = false;\n        tid = NULL;        \n    }\n    \n    bool SrsThread::can_loop()\n    {\n        return loop;\n    }\n    \n    void SrsThread::stop_loop()\n    {\n        loop = false;\n    }\n    \n    void SrsThread::dispose()\n    {\n        if (disposed) {\n            return;\n        }\n        \n        // the interrupt will cause the socket to read/write error,\n        // which will terminate the cycle thread.\n        st_thread_interrupt(tid);\n        \n        // when joinable, wait util quit.\n        if (_joinable) {\n            // wait the thread to exit.\n            int ret = st_thread_join(tid, NULL);\n            if (ret) {\n                srs_warn(\"core: ignore join thread failed.\");\n            }\n        }\n        \n        // wait the thread actually terminated.\n        // sometimes the thread join return -1, for example,\n        // when thread use st_recvfrom, the thread join return -1.\n        // so here, we use a variable to ensure the thread stopped.\n        // @remark even the thread not joinable, we must ensure the thread stopped when stop.\n        while (!really_terminated) {\n            st_usleep(10 * 1000);\n            \n            if (really_terminated) {\n                break;\n            }\n            srs_warn(\"core: wait thread to actually terminated\");\n        }\n        \n        disposed = true;\n    }\n    \n    void SrsThread::thread_cycle()\n    {\n        int ret = ERROR_SUCCESS;\n        \n        _srs_context->generate_id();\n        srs_info(\"thread %s cycle start\", _name);\n        \n        _cid = _srs_context->get_id();\n        \n        srs_assert(handler);\n        handler->on_thread_start();\n        \n        // thread is running now.\n        really_terminated = false;\n        \n        // wait for cid to ready, for parent thread to get the cid.\n        while (!can_run && loop) {\n            st_usleep(10 * 1000);\n        }\n        \n        while (loop) {\n            if ((ret = handler->on_before_cycle()) != ERROR_SUCCESS) {\n                srs_warn(\"thread %s on before cycle failed, ignored and retry, ret=%d\", _name, ret);\n                goto failed;\n            }\n            srs_info(\"thread %s on before cycle success\");\n            \n            if ((ret = handler->cycle()) != ERROR_SUCCESS) {\n                if (!srs_is_client_gracefully_close(ret) && !srs_is_system_control_error(ret)) {\n                    srs_warn(\"thread %s cycle failed, ignored and retry, ret=%d\", _name, ret);\n                }\n                goto failed;\n            }\n            srs_info(\"thread %s cycle success\", _name);\n            \n            if ((ret = handler->on_end_cycle()) != ERROR_SUCCESS) {\n                srs_warn(\"thread %s on end cycle failed, ignored and retry, ret=%d\", _name, ret);\n                goto failed;\n            }\n            srs_info(\"thread %s on end cycle success\", _name);\n            \n        failed:\n            if (!loop) {\n                break;\n            }\n            \n            // to improve performance, donot sleep when interval is zero.\n            // @see: https://github.com/ossrs/srs/issues/237\n            if (cycle_interval_us != 0) {\n                st_usleep(cycle_interval_us);\n            }\n        }\n        \n        // readly terminated now.\n        really_terminated = true;\n        \n        // when thread terminated normally, also disposed.\n        // we must set to disposed before the on_thread_stop, which may free the thread.\n        // @see https://github.com/ossrs/srs/issues/546\n        disposed = true;\n        \n        handler->on_thread_stop();\n        srs_info(\"thread %s cycle finished\", _name);\n    }\n    \n    void* SrsThread::thread_fun(void* arg)\n    {\n        SrsThread* obj = (SrsThread*)arg;\n        srs_assert(obj);\n        \n        obj->thread_cycle();\n        \n        st_thread_exit(NULL);\n        \n        return NULL;\n    }\n}\n",
        "base_contents": "namespace internal {\n    ISrsThreadHandler::ISrsThreadHandler()\n    {\n    }\n    \n    ISrsThreadHandler::~ISrsThreadHandler()\n    {\n    }\n    \n    void ISrsThreadHandler::on_thread_start()\n    {\n    }\n    \n    int ISrsThreadHandler::on_before_cycle()\n    {\n        int ret = ERROR_SUCCESS;\n        return ret;\n    }\n    \n    int ISrsThreadHandler::on_end_cycle()\n    {\n        int ret = ERROR_SUCCESS;\n        return ret;\n    }\n    \n    void ISrsThreadHandler::on_thread_stop()\n    {\n    }\n    \n    SrsThread::SrsThread(const char* name, ISrsThreadHandler* thread_handler, int64_t interval_us, bool joinable)\n    {\n        _name = name;\n        handler = thread_handler;\n        cycle_interval_us = interval_us;\n        \n        tid = NULL;\n        loop = false;\n        really_terminated = true;\n        _cid = -1;\n        _joinable = joinable;\n        disposed = false;\n        \n        // in start(), the thread cycle method maybe stop and remove the thread itself,\n        // and the thread start() is waiting for the _cid, and segment fault then.\n        // @see https://github.com/ossrs/srs/issues/110\n        // thread will set _cid, callback on_thread_start(), then wait for the can_run signal.\n        can_run = false;\n    }\n    \n    SrsThread::~SrsThread()\n    {\n        stop();\n    }\n    \n    int SrsThread::cid()\n    {\n        return _cid;\n    }\n    \n    int SrsThread::start()\n    {\n        int ret = ERROR_SUCCESS;\n        \n        if(tid) {\n            srs_info(\"thread %s already running.\", _name);\n            return ret;\n        }\n        \n        if((tid = st_thread_create(thread_fun, this, (_joinable? 1:0), 0)) == NULL){\n            ret = ERROR_ST_CREATE_CYCLE_THREAD;\n            srs_error(\"st_thread_create failed. ret=%d\", ret);\n            return ret;\n        }\n        \n        disposed = false;\n        // we set to loop to true for thread to run.\n        loop = true;\n        \n        // wait for cid to ready, for parent thread to get the cid.\n        while (_cid < 0) {\n            st_usleep(10 * 1000);\n        }\n        \n        // now, cycle thread can run.\n        can_run = true;\n        \n        return ret;\n    }\n    \n    void SrsThread::stop()\n    {\n        if (!tid) {\n            return;\n        }\n        \n        loop = false;\n        \n        dispose();\n        \n        _cid = -1;\n        can_run = false;\n        tid = NULL;        \n    }\n    \n    bool SrsThread::can_loop()\n    {\n        return loop;\n    }\n    \n    void SrsThread::stop_loop()\n    {\n        loop = false;\n    }\n    \n    void SrsThread::dispose()\n    {\n        if (disposed) {\n            return;\n        }\n        \n        // the interrupt will cause the socket to read/write error,\n        // which will terminate the cycle thread.\n        st_thread_interrupt(tid);\n        \n        // when joinable, wait util quit.\n        if (_joinable) {\n            // wait the thread to exit.\n            int ret = st_thread_join(tid, NULL);\n            if (ret) {\n                srs_warn(\"core: ignore join thread failed.\");\n            }\n        }\n        \n        // wait the thread actually terminated.\n        // sometimes the thread join return -1, for example,\n        // when thread use st_recvfrom, the thread join return -1.\n        // so here, we use a variable to ensure the thread stopped.\n        // @remark even the thread not joinable, we must ensure the thread stopped when stop.\n        while (!really_terminated) {\n            st_usleep(10 * 1000);\n            \n            if (really_terminated) {\n                break;\n            }\n            srs_warn(\"core: wait thread to actually terminated\");\n        }\n        \n        disposed = true;\n    }\n    \n    void SrsThread::thread_cycle()\n    {\n        int ret = ERROR_SUCCESS;\n        \n        _srs_context->generate_id();\n        srs_info(\"thread %s cycle start\", _name);\n        \n        _cid = _srs_context->get_id();\n        \n        srs_assert(handler);\n        handler->on_thread_start();\n        \n        // thread is running now.\n        really_terminated = false;\n        \n        // wait for cid to ready, for parent thread to get the cid.\n        while (!can_run && loop) {\n            st_usleep(10 * 1000);\n        }\n        \n        while (loop) {\n            if ((ret = handler->on_before_cycle()) != ERROR_SUCCESS) {\n                srs_warn(\"thread %s on before cycle failed, ignored and retry, ret=%d\", _name, ret);\n                goto failed;\n            }\n            srs_info(\"thread %s on before cycle success\");\n            \n            if ((ret = handler->cycle()) != ERROR_SUCCESS) {\n                if (!srs_is_client_gracefully_close(ret) && !srs_is_system_control_error(ret)) {\n                    srs_warn(\"thread %s cycle failed, ignored and retry, ret=%d\", _name, ret);\n                }\n                goto failed;\n            }\n            srs_info(\"thread %s cycle success\", _name);\n            \n            if ((ret = handler->on_end_cycle()) != ERROR_SUCCESS) {\n                srs_warn(\"thread %s on end cycle failed, ignored and retry, ret=%d\", _name, ret);\n                goto failed;\n            }\n            srs_info(\"thread %s on end cycle success\", _name);\n            \n        failed:\n            if (!loop) {\n                break;\n            }\n            \n            // to improve performance, donot sleep when interval is zero.\n            // @see: https://github.com/ossrs/srs/issues/237\n            if (cycle_interval_us != 0) {\n                st_usleep(cycle_interval_us);\n            }\n        }\n        \n        // readly terminated now.\n        really_terminated = true;\n        \n        handler->on_thread_stop();\n        srs_info(\"thread %s cycle finished\", _name);\n        \n        // when thread terminated normally, also disposed.\n        disposed = true;\n    }\n    \n    void* SrsThread::thread_fun(void* arg)\n    {\n        SrsThread* obj = (SrsThread*)arg;\n        srs_assert(obj);\n        \n        obj->thread_cycle();\n        \n        st_thread_exit(NULL);\n        \n        return NULL;\n    }\n}\n",
        "res_region": "",
        "lookback": "{",
        "lookahead": "ISrsEndlessThreadHandler::ISrsEndlessThreadHandler()",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 28,
        "end_line": 485,
        "merge_gen_region": null,
        "confidence": 0.8091588616371155,
        "hesitated": true
    }
]