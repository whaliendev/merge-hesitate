[
    {
        "a_contents": "    \n    int srs_av_base64_decode(uint8_t* out, const char* in_str, int out_size)\n    {\n        uint8_t *dst = out;\n        uint8_t *end = out + out_size;\n        // no sign extension\n        const uint8_t *in = (const uint8_t*)in_str;\n        unsigned bits = 0xff;\n        unsigned v = 0;\n        \n        while (end - dst > 3) {\n            BASE64_DEC_STEP(0);\n            BASE64_DEC_STEP(1);\n            BASE64_DEC_STEP(2);\n            BASE64_DEC_STEP(3);\n            // Using AV_WB32 directly confuses compiler\n            v = av_be2ne32(v << 8);\n            AV_WN32(dst, v);\n            dst += 3;\n            in += 4;\n        }\n        if (end - dst) {\n            BASE64_DEC_STEP(0);\n            BASE64_DEC_STEP(1);\n            BASE64_DEC_STEP(2);\n            BASE64_DEC_STEP(3);\n            *dst++ = v >> 16;\n            if (end - dst)\n                *dst++ = v >> 8;\n            if (end - dst)\n                *dst++ = v;\n            in += 4;\n        }\n        while (1) {\n            BASE64_DEC_STEP(0);\n            in++;\n            BASE64_DEC_STEP(0);\n            in++;\n            BASE64_DEC_STEP(0);\n            in++;\n            BASE64_DEC_STEP(0);\n            in++;\n        }\n        \n    out3:\n        *dst++ = v >> 10;\n        v <<= 2;\n    out2:\n        *dst++ = v >> 4;\n    out1:\n    out0:\n        return bits & 1 ? -1 : (int)(dst - out);",
        "b_contents": "\nint srs_av_base64_decode(u_int8_t* out, const char* in_str, int out_size)\n{\n    u_int8_t *dst = out;\n    u_int8_t *end = out + out_size;\n    // no sign extension\n    const u_int8_t *in = (const u_int8_t*)in_str;\n    unsigned bits = 0xff;\n    unsigned v = 0;\n\n    while (end - dst > 3) {\n        BASE64_DEC_STEP(0);\n        BASE64_DEC_STEP(1);\n        BASE64_DEC_STEP(2);\n        BASE64_DEC_STEP(3);\n        // Using AV_WB32 directly confuses compiler\n        v = av_be2ne32(v << 8);\n        AV_WN32(dst, v);\n        dst += 3;\n        in += 4;\n    }\n    if (end - dst) {\n        BASE64_DEC_STEP(0);\n        BASE64_DEC_STEP(1);\n        BASE64_DEC_STEP(2);\n        BASE64_DEC_STEP(3);\n        *dst++ = v >> 16;\n        if (end - dst)\n            *dst++ = v >> 8;\n        if (end - dst)\n            *dst++ = v;\n        in += 4;\n    }\n    while (1) {\n        BASE64_DEC_STEP(0);\n        in++;\n        BASE64_DEC_STEP(0);\n        in++;\n        BASE64_DEC_STEP(0);\n        in++;\n        BASE64_DEC_STEP(0);\n        in++;\n    }\n\nout3:\n    *dst++ = v >> 10;\n    v <<= 2;\nout2:\n    *dst++ = v >> 4;\nout1:\nout0:\n    return bits & 1 ? -1 : dst - out;\n}\n\n/*****************************************************************************\n* b64_encode: Stolen from VLC's http.c.\n* Simplified by Michael.\n* Fixed edge cases and made it work from data (vs. strings) by Ryan.\n*****************************************************************************/\n\nchar* srs_av_base64_encode(char* out, int out_size, const u_int8_t* in, int in_size)\n{\n    static const char b64[] =\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    char *ret, *dst;\n    unsigned i_bits = 0;\n    int i_shift = 0;\n    int bytes_remaining = in_size;\n\n    if (in_size >= (int)(UINT_MAX / 4) ||\n        out_size < SRS_AV_BASE64_SIZE(in_size))\n        return NULL;\n    ret = dst = out;\n    while (bytes_remaining > 3) {\n        i_bits = AV_RB32(in);\n        in += 3; bytes_remaining -= 3;\n        *dst++ = b64[ i_bits>>26        ];\n        *dst++ = b64[(i_bits>>20) & 0x3F];\n        *dst++ = b64[(i_bits>>14) & 0x3F];\n        *dst++ = b64[(i_bits>>8 ) & 0x3F];\n    }\n    i_bits = 0;\n    while (bytes_remaining) {\n        i_bits = (i_bits << 8) + *in++;\n        bytes_remaining--;\n        i_shift += 8;\n    }\n    while (i_shift > 0) {\n        *dst++ = b64[(i_bits << 6 >> i_shift) & 0x3f];\n        i_shift -= 6;\n    }\n    while ((dst - ret) & 3)\n        *dst++ = '=';\n    *dst = '\\0';\n\n    return ret;\n}\n\n#define SPACE_CHARS \" \\t\\r\\n\"\n\nint av_toupper(int c)\n{\n    if (c >= 'a' && c <= 'z') {\n        c ^= 0x20;",
        "base_contents": "\nint srs_av_base64_decode(u_int8_t* out, const char* in_str, int out_size)\n{\n    u_int8_t *dst = out;\n    u_int8_t *end = out + out_size;\n    // no sign extension\n    const u_int8_t *in = (const u_int8_t*)in_str;\n    unsigned bits = 0xff;\n    unsigned v;\n\n    while (end - dst > 3) {\n        BASE64_DEC_STEP(0);\n        BASE64_DEC_STEP(1);\n        BASE64_DEC_STEP(2);\n        BASE64_DEC_STEP(3);\n        // Using AV_WB32 directly confuses compiler\n        v = av_be2ne32(v << 8);\n        AV_WN32(dst, v);\n        dst += 3;\n        in += 4;\n    }\n    if (end - dst) {\n        BASE64_DEC_STEP(0);\n        BASE64_DEC_STEP(1);\n        BASE64_DEC_STEP(2);\n        BASE64_DEC_STEP(3);\n        *dst++ = v >> 16;\n        if (end - dst)\n            *dst++ = v >> 8;\n        if (end - dst)\n            *dst++ = v;\n        in += 4;\n    }\n    while (1) {\n        BASE64_DEC_STEP(0);\n        in++;\n        BASE64_DEC_STEP(0);\n        in++;\n        BASE64_DEC_STEP(0);\n        in++;\n        BASE64_DEC_STEP(0);\n        in++;\n    }\n\nout3:\n    *dst++ = v >> 10;\n    v <<= 2;\nout2:\n    *dst++ = v >> 4;\nout1:\nout0:\n    return bits & 1 ? -1 : dst - out;\n}\n\n/*****************************************************************************\n* b64_encode: Stolen from VLC's http.c.\n* Simplified by Michael.\n* Fixed edge cases and made it work from data (vs. strings) by Ryan.\n*****************************************************************************/\n\nchar* srs_av_base64_encode(char* out, int out_size, const u_int8_t* in, int in_size)\n{\n    static const char b64[] =\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    char *ret, *dst;\n    unsigned i_bits = 0;\n    int i_shift = 0;\n    int bytes_remaining = in_size;\n\n    if (in_size >= (int)(UINT_MAX / 4) ||\n        out_size < SRS_AV_BASE64_SIZE(in_size))\n        return NULL;\n    ret = dst = out;\n    while (bytes_remaining > 3) {\n        i_bits = AV_RB32(in);\n        in += 3; bytes_remaining -= 3;\n        *dst++ = b64[ i_bits>>26        ];\n        *dst++ = b64[(i_bits>>20) & 0x3F];\n        *dst++ = b64[(i_bits>>14) & 0x3F];\n        *dst++ = b64[(i_bits>>8 ) & 0x3F];\n    }\n    i_bits = 0;\n    while (bytes_remaining) {\n        i_bits = (i_bits << 8) + *in++;\n        bytes_remaining--;\n        i_shift += 8;\n    }\n    while (i_shift > 0) {\n        *dst++ = b64[(i_bits << 6 >> i_shift) & 0x3f];\n        i_shift -= 6;\n    }\n    while ((dst - ret) & 3)\n        *dst++ = '=';\n    *dst = '\\0';\n\n    return ret;\n}\n\n#define SPACE_CHARS \" \\t\\r\\n\"\n\nint av_toupper(int c)\n{\n    if (c >= 'a' && c <= 'z') {\n        c ^= 0x20;",
        "res_region": "    \n    int srs_av_base64_decode(uint8_t* out, const char* in_str, int out_size)\n    {\n        uint8_t *dst = out;\n        uint8_t *end = out + out_size;\n        // no sign extension\n        const uint8_t *in = (const uint8_t*)in_str;\n        unsigned bits = 0xff;\n        unsigned v = 0;\n        \n        while (end - dst > 3) {\n            BASE64_DEC_STEP(0);\n            BASE64_DEC_STEP(1);\n            BASE64_DEC_STEP(2);\n            BASE64_DEC_STEP(3);\n            // Using AV_WB32 directly confuses compiler\n            v = av_be2ne32(v << 8);\n            AV_WN32(dst, v);\n            dst += 3;\n            in += 4;\n        }\n        if (end - dst) {\n            BASE64_DEC_STEP(0);\n            BASE64_DEC_STEP(1);\n            BASE64_DEC_STEP(2);\n            BASE64_DEC_STEP(3);\n            *dst++ = v >> 16;\n            if (end - dst)\n                *dst++ = v >> 8;\n            if (end - dst)\n                *dst++ = v;\n            in += 4;\n        }\n        while (1) {\n            BASE64_DEC_STEP(0);\n            in++;\n            BASE64_DEC_STEP(0);\n            in++;\n            BASE64_DEC_STEP(0);\n            in++;\n            BASE64_DEC_STEP(0);\n            in++;\n        }\n        \n    out3:\n        *dst++ = v >> 10;\n        v <<= 2;\n    out2:\n        *dst++ = v >> 4;\n    out1:\n    out0:\n        return bits & 1 ? -1 : (int)(dst - out);",
        "lookback": "    int srs_av_base64_decode(uint8_t* out, const char* in_str, int out_size)",
        "lookahead": "    }",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 945,
        "end_line": 1208,
        "merge_gen_region": " srsavbase_(8t out, char instr int_) srsavbase64decode(8t out const*, char instr int_) uint_ * =;8tend out out out outsize { no extension uint_ *n =; unsigned =xff unsigned =; ( - >) BASE___();64t; =; unsigned =xff unsigned =; ( - >) BASE___();64t; =; <64t; =; <64t; =;base64t; =; <; voidEffect; voidEffect; voidEffect; voidEffect; voidEffect; voidEffect; voidEffect; voidEffect; voidEffectF voidEffectF voidEffectF voidEffectF voidEffectF voidEffectF voidEffectF voidEffectF voidEffectF voidEffectF voidEffectF voidEffectF voidEffectF voidEffectF voidEffectF voidEffectF voidEffectF voidEffectF voidEffectF voidEffectF voidEffectF voidEffectF voidEffectF voidEffectF voidEffectF voidEffectF # voidEffectF # voidEffectF # voidEffectF # voidEffectF # voidEffectF # voidEffectF # voidEffectF # voidEffectF # voidEffectF",
        "confidence": 0.927489697933197,
        "hesitated": false,
        "resolved": false
    }
]