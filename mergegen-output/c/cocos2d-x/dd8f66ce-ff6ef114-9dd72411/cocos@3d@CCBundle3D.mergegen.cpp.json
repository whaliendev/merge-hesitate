[
    {
        "a_contents": "    meshdata->vertexSizeInFloat = 13 * 4;\n    meshdata->vertex.resize(meshdata->vertexSizeInFloat);\n    //dabing's data\n//   float vert[] = {0.f,50.f,0.f,  0.f,0.f,  0.f,0.f,0.f,0.f,   1.f,0.f,0.f,0.f,\n//                   0.f,0.f,50.f,  1.f,1.f,  0.f,0.f,0.f,0.f,   1.f,0.f,0.f,0.f,\n//                   50.f,0.f,0.f,  1.f,1.f,  0.f,0.f,0.f,0.f,   1.f,0.f,0.f,0.f,\n//                  50.f,50.f,0.f,  1.f,1.f,  0.f,0.f,0.f,0.f,   1.f,0.f,0.f,0.f};\n    float vert[] = {0.f,50.f,0.f,  0.f,0.f,  0.f,0.f,0.f,0.f,   1.f,0.f,0.f,0.f,\n        0.f,0.f,50.f,  1.f,1.f,  0.f,0.f,0.f,0.f,   1.f,0.f,0.f,0.f,\n        50.f,0.f,0.f,  1.f,1.f,  0.f,0.f,0.f,0.f,   1.f,0.f,0.f,0.f,\n        -50.f,0.f,0.f,  1.f,1.f,  0.f,0.f,0.f,0.f,   1.f,0.f,0.f,0.f};",
        "b_contents": "    \n    const rapidjson::Value& mash_data_val_array = document[\"mesh_data\"];\n    assert(mash_data_val_array.IsArray());",
        "base_contents": "    meshdata->vertexSizeInFloat = 13 * 4;\n    meshdata->vertex = new float[meshdata->vertexSizeInFloat];\n    //dabing's data\n//   float vert[] = {0.f,50.f,0.f,  0.f,0.f,  0.f,0.f,0.f,0.f,   1.f,0.f,0.f,0.f,\n//                   0.f,0.f,50.f,  1.f,1.f,  0.f,0.f,0.f,0.f,   1.f,0.f,0.f,0.f,\n//                   50.f,0.f,0.f,  1.f,1.f,  0.f,0.f,0.f,0.f,   1.f,0.f,0.f,0.f,\n//                  50.f,50.f,0.f,  1.f,1.f,  0.f,0.f,0.f,0.f,   1.f,0.f,0.f,0.f};\n    float vert[] = {0.f,50.f,0.f,  0.f,0.f,  0.f,0.f,0.f,0.f,   1.f,0.f,0.f,0.f,\n        0.f,0.f,50.f,  1.f,1.f,  0.f,0.f,0.f,0.f,   1.f,0.f,0.f,0.f,\n        50.f,0.f,0.f,  1.f,1.f,  0.f,0.f,0.f,0.f,   1.f,0.f,0.f,0.f,\n        -50.f,0.f,0.f,  1.f,1.f,  0.f,0.f,0.f,0.f,   1.f,0.f,0.f,0.f};",
        "res_region": "\n//    meshdata->vertexSizeInFloat = 13 * 4;\n//    meshdata->vertex.resize(meshdata->vertexSizeInFloat);\n//    float vert[] = {0.f,50.f,0.f,  0.f,0.f,  0.f,0.f,0.f,0.f,   1.f,0.f,0.f,0.f,\n//        0.f,0.f,50.f,  1.f,1.f,  0.f,0.f,0.f,0.f,   1.f,0.f,0.f,0.f,\n//        50.f,0.f,0.f,  1.f,1.f,  0.f,0.f,0.f,0.f,   1.f,0.f,0.f,0.f,\n//        -50.f,0.f,0.f,  1.f,1.f,  0.f,0.f,0.f,0.f,   1.f,0.f,0.f,0.f};\n\n    \n    const rapidjson::Value& mash_data_val_array = document[\"mesh_data\"];\n    assert(mash_data_val_array.IsArray());",
        "lookback": "//    meshdata->vertexSizeInFloat = 13 * 4;",
        "lookahead": "",
        "label": [
            "newcode",
            "complex_conflict"
        ],
        "start_line": 132,
        "end_line": 160,
        "merge_gen_region": null,
        "confidence": 0.670159637928009,
        "hesitated": true
    },
    {
        "a_contents": "    //float vert[] = {0.f,50.f,0.f,  0.f,0.f,50.f, 50.f,0.f,0.f, -50.f,0.f,0.f};\n    memcpy(&meshdata->vertex[0], vert, meshdata->vertexSizeInFloat * sizeof(float));",
        "b_contents": "    assert(mesh_data_body_array.IsArray());\n    const rapidjson::Value& mesh_data_body_val = mesh_data_body_array[(rapidjson::SizeType)0];",
        "base_contents": "    //float vert[] = {0.f,50.f,0.f,  0.f,0.f,50.f, 50.f,0.f,0.f, -50.f,0.f,0.f};\n    memcpy(meshdata->vertex, vert, meshdata->vertexSizeInFloat * sizeof(float));",
        "res_region": "//    memcpy(&meshdata->vertex[0], vert, meshdata->vertexSizeInFloat * sizeof(float));\n//    \n//    meshdata->numIndex = 4 * 3;\n//    //meshdata->numIndex = 3;\n//    meshdata->indices.resize(meshdata->numIndex);\n//    unsigned short index[] = {0,1,2, 0,3,1, 0,2,3, 3,2,1};\n//    //unsigned short index[] = {0,3,2};\n//    //unsigned short index[] = {0,1,2};\n//    memcpy(&meshdata->indices[0], index, meshdata->numIndex * sizeof(unsigned short));\n//    \n//    meshdata->attribCount = 4;\n//    meshdata->attribs.resize(meshdata->attribCount);\n//    meshdata->attribs[0].attribSizeBytes = 3 * sizeof(float);\n//    meshdata->attribs[0].size = 3;\n//    meshdata->attribs[0].type = GL_FLOAT;\n//    meshdata->attribs[0].vertexAttrib = GLProgram::VERTEX_ATTRIB_POSITION;\n//    \n//    meshdata->attribs[1].attribSizeBytes = 2 * sizeof(float);\n//    meshdata->attribs[1].size = 2;\n//    meshdata->attribs[1].type = GL_FLOAT;\n//    meshdata->attribs[1].vertexAttrib = GLProgram::VERTEX_ATTRIB_TEX_COORD;\n//    \n//    meshdata->attribs[2].attribSizeBytes = 4 * sizeof(float);\n//    meshdata->attribs[2].size = 4;\n//    meshdata->attribs[2].type = GL_FLOAT;\n//    meshdata->attribs[2].vertexAttrib = GLProgram::VERTEX_ATTRIB_BLEND_INDEX;\n//    \n//    meshdata->attribs[3].attribSizeBytes = 4 * sizeof(float);\n//    meshdata->attribs[3].size = 4;\n//    meshdata->attribs[3].type = GL_FLOAT;\n//    meshdata->attribs[3].vertexAttrib = GLProgram::VERTEX_ATTRIB_BLEND_WEIGHT;\n    \n    assert(mesh_data_body_array.IsArray());\n    const rapidjson::Value& mesh_data_body_val = mesh_data_body_array[(rapidjson::SizeType)0];",
        "lookback": "//    ",
        "lookahead": "    ",
        "label": [
            "newcode",
            "complex_conflict"
        ],
        "start_line": 168,
        "end_line": 177,
        "merge_gen_region": null,
        "confidence": 0.689013659954071,
        "hesitated": true
    },
    {
        "a_contents": "    meshdata->numIndex = 4 * 3;\n    //meshdata->numIndex = 3;\n    meshdata->indices.resize(meshdata->numIndex);\n    unsigned short index[] = {0,1,2, 0,3,1, 0,2,3, 3,2,1};\n    //unsigned short index[] = {0,3,2};\n    //unsigned short index[] = {0,1,2};\n    memcpy(&meshdata->indices[0], index, meshdata->numIndex * sizeof(unsigned short));\n    \n    meshdata->attribCount = 4;\n    meshdata->attribs.resize(meshdata->attribCount);\n    meshdata->attribs[0].attribSizeBytes = 3 * sizeof(float);\n    meshdata->attribs[0].size = 3;\n    meshdata->attribs[0].type = GL_FLOAT;\n    meshdata->attribs[0].vertexAttrib = GLProgram::VERTEX_ATTRIB_POSITION;\n    \n    meshdata->attribs[1].attribSizeBytes = 2 * sizeof(float);\n    meshdata->attribs[1].size = 2;\n    meshdata->attribs[1].type = GL_FLOAT;\n    meshdata->attribs[1].vertexAttrib = GLProgram::VERTEX_ATTRIB_TEX_COORD;\n    \n    meshdata->attribs[2].attribSizeBytes = 4 * sizeof(float);\n    meshdata->attribs[2].size = 4;\n    meshdata->attribs[2].type = GL_FLOAT;\n    meshdata->attribs[2].vertexAttrib = GLProgram::VERTEX_ATTRIB_BLEND_INDEX;\n    \n    meshdata->attribs[3].attribSizeBytes = 4 * sizeof(float);\n    meshdata->attribs[3].size = 4;\n    meshdata->attribs[3].type = GL_FLOAT;\n    meshdata->attribs[3].vertexAttrib = GLProgram::VERTEX_ATTRIB_BLEND_WEIGHT;\n    ",
        "b_contents": "    // vertex_size\n    assert(mesh_data_body_val.HasMember(\"vertex_size\"));\n    meshdata->vertexSizeInFloat = mesh_data_body_val[\"vertex_size\"].GetInt();\n\n    // vertices\n    meshdata->vertex = new float[meshdata->vertexSizeInFloat];\n    const rapidjson::Value& mesh_data_body_vertex_val = mesh_data_body_val[\"vertices\"];\n    for (rapidjson::SizeType i = 0; i < mesh_data_body_vertex_val.Size(); i++)\n        meshdata->vertex[i] = mesh_data_body_vertex_val[i].GetDouble();\n\n    // index_number\n    meshdata->numIndex = mesh_data_body_val[\"index_number\"].GetUint();\n\n    // indices\n    meshdata->indices = new unsigned short[meshdata->numIndex];\n    const rapidjson::Value& mesh_data_body_indices_val = mesh_data_body_val[\"indices\"];\n    for (rapidjson::SizeType i = 0; i < mesh_data_body_indices_val.Size(); i++)\n        meshdata->indices[i] = (unsigned short)mesh_data_body_indices_val[i].GetUint();\n\n    // mesh_vertex_attribute\n    const rapidjson::Value& mesh_vertex_attribute = mash_data_val[\"mesh_vertex_attribute\"];\n    meshdata->attribCount = mesh_vertex_attribute.Size();\n    meshdata->attribs = new MeshVertexAttrib[meshdata->attribCount];\n    for (rapidjson::SizeType i = 0; i < mesh_vertex_attribute.Size(); i++)\n    {\n        const rapidjson::Value& mesh_vertex_attribute_val = mesh_vertex_attribute[i];\n\n        meshdata->attribs[i].size = mesh_vertex_attribute_val[\"size\"].GetUint();\n        meshdata->attribs[i].attribSizeBytes = meshdata->attribs[i].size * parseGLTypeSize(mesh_vertex_attribute_val[\"type\"].GetString());\n        meshdata->attribs[i].type = parseGLType(mesh_vertex_attribute_val[\"type\"].GetString());\n        //assignGLTypeByString(meshdata->attribs[i].type, mesh_vertex_attribute_val[\"type\"].GetString());\n        meshdata->attribs[i].vertexAttrib = parseGLProgramAttribute(mesh_vertex_attribute_val[\"vertex_attribute\"].GetString());\n    }\n",
        "base_contents": "    meshdata->numIndex = 4 * 3;\n    //meshdata->numIndex = 3;\n    meshdata->indices = new unsigned short[meshdata->numIndex];\n    unsigned short index[] = {0,1,2, 0,3,1, 0,2,3, 3,2,1};\n    //unsigned short index[] = {0,3,2};\n    //unsigned short index[] = {0,1,2};\n    memcpy(meshdata->indices, index, meshdata->numIndex * sizeof(unsigned short));\n    \n    meshdata->attribCount = 4;\n    meshdata->attribs = new MeshVertexAttrib[meshdata->attribCount];\n    meshdata->attribs[0].attribSizeBytes = 3 * sizeof(float);\n    meshdata->attribs[0].size = 3;\n    meshdata->attribs[0].type = GL_FLOAT;\n    meshdata->attribs[0].vertexAttrib = GLProgram::VERTEX_ATTRIB_POSITION;\n    \n    meshdata->attribs[1].attribSizeBytes = 2 * sizeof(float);\n    meshdata->attribs[1].size = 2;\n    meshdata->attribs[1].type = GL_FLOAT;\n    meshdata->attribs[1].vertexAttrib = GLProgram::VERTEX_ATTRIB_TEX_COORD;\n    \n    meshdata->attribs[2].attribSizeBytes = 4 * sizeof(float);\n    meshdata->attribs[2].size = 4;\n    meshdata->attribs[2].type = GL_FLOAT;\n    meshdata->attribs[2].vertexAttrib = GLProgram::VERTEX_ATTRIB_BLEND_INDEX;\n    \n    meshdata->attribs[3].attribSizeBytes = 4 * sizeof(float);\n    meshdata->attribs[3].size = 4;\n    meshdata->attribs[3].type = GL_FLOAT;\n    meshdata->attribs[3].vertexAttrib = GLProgram::VERTEX_ATTRIB_BLEND_WEIGHT;\n    ",
        "res_region": "    // vertex_size\n    assert(mesh_data_body_val.HasMember(\"vertex_size\"));\n    meshdata->vertexSizeInFloat = mesh_data_body_val[\"vertex_size\"].GetInt();\n\n    // vertices\n    meshdata->vertex.resize(meshdata->vertexSizeInFloat);\n    const rapidjson::Value& mesh_data_body_vertex_val = mesh_data_body_val[\"vertices\"];\n    for (rapidjson::SizeType i = 0; i < mesh_data_body_vertex_val.Size(); i++)\n        meshdata->vertex[i] = mesh_data_body_vertex_val[i].GetDouble();\n\n    // index_number\n    meshdata->numIndex = mesh_data_body_val[\"index_number\"].GetUint();\n\n    // indices\n    meshdata->indices.resize(meshdata->numIndex);\n    const rapidjson::Value& mesh_data_body_indices_val = mesh_data_body_val[\"indices\"];\n    for (rapidjson::SizeType i = 0; i < mesh_data_body_indices_val.Size(); i++)\n        meshdata->indices[i] = (unsigned short)mesh_data_body_indices_val[i].GetUint();\n\n    // mesh_vertex_attribute\n    const rapidjson::Value& mesh_vertex_attribute = mash_data_val[\"mesh_vertex_attribute\"];\n    meshdata->attribCount = mesh_vertex_attribute.Size();\n    meshdata->attribs.resize(meshdata->attribCount);\n    for (rapidjson::SizeType i = 0; i < mesh_vertex_attribute.Size(); i++)\n    {\n        const rapidjson::Value& mesh_vertex_attribute_val = mesh_vertex_attribute[i];\n\n        meshdata->attribs[i].size = mesh_vertex_attribute_val[\"size\"].GetUint();\n        meshdata->attribs[i].attribSizeBytes = meshdata->attribs[i].size * parseGLTypeSize(mesh_vertex_attribute_val[\"type\"].GetString());\n        meshdata->attribs[i].type = parseGLType(mesh_vertex_attribute_val[\"type\"].GetString());\n        //assignGLTypeByString(meshdata->attribs[i].type, mesh_vertex_attribute_val[\"type\"].GetString());\n        meshdata->attribs[i].vertexAttrib = parseGLProgramAttribute(mesh_vertex_attribute_val[\"vertex_attribute\"].GetString());\n    }\n",
        "lookback": "    assert(mesh_data_body_val.HasMember(\"vertex_size\"));",
        "lookahead": "    return true;",
        "label": [
            "newcode",
            "complex_conflict"
        ],
        "start_line": 179,
        "end_line": 276,
        "merge_gen_region": null,
        "confidence": 0.6528018116950989,
        "hesitated": true
    },
    {
        "a_contents": "    animationdata->_translationKeys[boneName].push_back(Animation3DData::Vec3Key(keytime1[0], Vec3(0.0f, 0.0f, 0.0f)));\n    animationdata->_translationKeys[boneName].push_back(Animation3DData::Vec3Key(keytime1[1], Vec3(0.0f, 20.0f, 0.0f)));\n    animationdata->_translationKeys[boneName].push_back(Animation3DData::Vec3Key(keytime1[2], Vec3(20.0f, 0.0f, 0.0f)));\n    animationdata->_translationKeys[boneName].push_back(Animation3DData::Vec3Key(keytime1[3], Vec3(0.0f, 0.0f, 20.0f)));",
        "b_contents": "    CCLOG(\"translation:////////////////\");\n    //animationdata->_translationKeys.erase(animationdata->_translationKeys.begin(), animationdata->_translationKeys.end());\n    for (auto itr: animationdata->_translationKeys)\n    {\n        CCLOG(\"%s\", itr.first.c_str());\n        auto& keys = itr.second;\n        \n        if (keys.size())\n        {\n            float maxtime = keys[keys.size() - 1]._time;\n            for (auto it : keys) {\n                it._time /= maxtime;\n            }\n        }\n    }\n    CCLOG(\"rotation:////////////////\");\n    //animationdata->_rotationKeys.erase(animationdata->_rotationKeys.begin(), animationdata->_rotationKeys.end());\n    for (auto itr: animationdata->_rotationKeys)\n    {\n        CCLOG(\"%s\", itr.first.c_str());\n        auto& keys = itr.second;\n        if (keys.size())\n        {\n            float maxtime = keys[keys.size() - 1]._time;\n            for (auto it : keys) {\n                it._time /= maxtime;\n            }\n        }\n    }\n    CCLOG(\"scale:////////////////\");\n    for (auto itr: animationdata->_scaleKeys)\n    {\n        CCLOG(\"%s\", itr.first.c_str());\n        auto& keys = itr.second;\n        if (keys.size())\n        {\n            float maxtime = keys[keys.size() - 1]._time;\n            for (auto it : keys) {\n                it._time /= maxtime;\n            }\n        }\n    }",
        "base_contents": "",
        "res_region": "//    animationdata->_translationKeys[boneName].push_back(Animation3DData::Vec3Key(keytime1[0], Vec3(0.0f, 0.0f, 0.0f)));\n//    animationdata->_translationKeys[boneName].push_back(Animation3DData::Vec3Key(keytime1[1], Vec3(0.0f, 20.0f, 0.0f)));\n//    animationdata->_translationKeys[boneName].push_back(Animation3DData::Vec3Key(keytime1[2], Vec3(20.0f, 0.0f, 0.0f)));\n//    animationdata->_translationKeys[boneName].push_back(Animation3DData::Vec3Key(keytime1[3], Vec3(0.0f, 0.0f, 20.0f)));\n    \n    CCLOG(\"translation:////////////////\");\n    //animationdata->_translationKeys.erase(animationdata->_translationKeys.begin(), animationdata->_translationKeys.end());\n    for (auto itr: animationdata->_translationKeys)\n    {\n        CCLOG(\"%s\", itr.first.c_str());\n        auto& keys = itr.second;\n        \n        if (keys.size())\n        {\n            float maxtime = keys[keys.size() - 1]._time;\n            for (auto it : keys) {\n                it._time /= maxtime;\n            }\n        }\n    }\n    CCLOG(\"rotation:////////////////\");\n    //animationdata->_rotationKeys.erase(animationdata->_rotationKeys.begin(), animationdata->_rotationKeys.end());\n    for (auto itr: animationdata->_rotationKeys)\n    {\n        CCLOG(\"%s\", itr.first.c_str());\n        auto& keys = itr.second;\n        if (keys.size())\n        {\n            float maxtime = keys[keys.size() - 1]._time;\n            for (auto it : keys) {\n                it._time /= maxtime;\n            }\n        }\n    }\n    CCLOG(\"scale:////////////////\");\n    for (auto itr: animationdata->_scaleKeys)\n    {\n        CCLOG(\"%s\", itr.first.c_str());\n        auto& keys = itr.second;\n        if (keys.size())\n        {\n            float maxtime = keys[keys.size() - 1]._time;\n            for (auto it : keys) {\n                it._time /= maxtime;\n            }\n        }\n    }",
        "lookback": "//    animationdata->_translationKeys[boneName].push_back(Animation3DData::Vec3Key(keytime1[1], Vec3(0.0f, 20.0f, 0.0f)));",
        "lookahead": "    ",
        "label": [
            "newcode",
            "one_side_deletion"
        ],
        "start_line": 428,
        "end_line": 477,
        "merge_gen_region": " animation->_Keysbone]._backAnimationD::3(key1[],3(.f 00f 00)));datatranslation[translation[NamepushbackAnimationD::3(key1[],3000,.f 00,.f animation->_translation[NamepushbackAnimationD::3(key1[],3000, 200,.f 00)));datatranslation[NamepushbackAnimationD::3DataVecKeykey1[],300, 200, 00)));datatranslation[NamepushbackAnimationD::3DataVecKeykey1[],300,.f 200,.f animation->_translation[NamepushbackAnimationD::3DataVecKeykey1[],300,.f 200)));datatranslation[NamepushbackAnimationD::3DataVecKeykey1[],3(.f 00f 200)));datatranslation[NamepushbackAnimationD::3DataVecKeykey12 Vec(.f 00,.f 00)));datatranslation[NamepushbackAnimationD::3(.f 00,.f 200))); CC(\"translation////////////////\");animation->_Keysbegin animationdatatranslation.",
        "confidence": 0.9178561568260193,
        "hesitated": false,
        "resolved": false
    }
]