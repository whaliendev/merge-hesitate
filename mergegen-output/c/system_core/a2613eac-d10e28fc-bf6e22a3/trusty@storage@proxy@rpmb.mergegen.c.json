[
    {
        "a_contents": "/**\n * log_buf - Log a byte buffer to the android log.\n * @priority: One of ANDROID_LOG_* priority levels from android_LogPriority in\n *            android/log.h\n * @prefix:   A null-terminated string that identifies this buffer. Must be less\n *            than 128 bytes.\n * @buf:      Buffer to dump.\n * @size:     Length of @buf in bytes.\n */\n#define LOG_BUF_SIZE 256\nstatic int log_buf(int priority, const char* prefix, const uint8_t* buf, size_t size) {\n    int rc;",
        "b_contents": "static void print_buf(FILE* handle, const char* prefix, const uint8_t* buf, size_t size) {",
        "base_contents": "#ifdef RPMB_DEBUG\nstatic void print_buf(FILE* handle, const char* prefix, const uint8_t* buf, size_t size) {",
        "res_region": "/**\n * log_buf - Log a byte buffer to the android log.\n * @priority: One of ANDROID_LOG_* priority levels from android_LogPriority in\n *            android/log.h\n * @prefix:   A null-terminated string that identifies this buffer. Must be less\n *            than 128 bytes.\n * @buf:      Buffer to dump.\n * @size:     Length of @buf in bytes.\n */\n#define LOG_BUF_SIZE 256\nstatic int log_buf(int priority, const char* prefix, const uint8_t* buf, size_t size) {\n    int rc;",
        "lookback": " * log_buf - Log a byte buffer to the android log.",
        "lookahead": "    size_t i;",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 120,
        "end_line": 138,
        "merge_gen_region": "outputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutput",
        "confidence": 0.9473841190338135,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "    return 0;\n\nerr:\n    if (rc < 0) {\n        return rc;\n    } else {\n        ALOGE(\"log_buf prefix was too long\");\n        return -1;\n    }\n}\n",
        "b_contents": "",
        "base_contents": "#endif\n",
        "res_region": "    return 0;\n\nerr:\n    if (rc < 0) {\n        return rc;\n    } else {\n        ALOGE(\"log_buf prefix was too long\");\n        return -1;\n    }\n}\n",
        "lookback": "",
        "lookahead": "static void set_sg_io_hdr(sg_io_hdr_t* io_hdrp, int dxfer_direction, unsigned char cmd_len,",
        "label": [
            "ours",
            "base_empty"
        ],
        "start_line": 173,
        "end_line": 189,
        "merge_gen_region": null,
        "confidence": 0.847945511341095,
        "hesitated": true
    },
    {
        "a_contents": "/**\n * enum scsi_result - Results of checking the SCSI status and sense buffer\n *\n * @SCSI_RES_OK:    SCSI status and sense are good\n * @SCSI_RES_ERR:   SCSI status or sense contain an unhandled error\n * @SCSI_RES_RETRY: SCSI sense buffer contains a status that indicates that the\n *                  command should be retried\n */\nenum scsi_result {\n    SCSI_RES_OK = 0,\n    SCSI_RES_ERR,\n    SCSI_RES_RETRY,\n};\n\nstatic enum scsi_result check_scsi_sense(const uint8_t* sense_buf, size_t len) {\n    uint8_t response_code = 0;\n    uint8_t sense_key = 0;\n    uint8_t additional_sense_code = 0;\n    uint8_t additional_sense_code_qualifier = 0;\n    uint8_t additional_length = 0;\n\n    if (!sense_buf || len == 0) {\n        ALOGE(\"Invalid SCSI sense buffer, length: %zu\\n\", len);\n        return SCSI_RES_ERR;\n    }\n\n    response_code = 0x7f & sense_buf[0];\n\n    if (response_code < 0x70 || response_code > 0x73) {\n        ALOGE(\"Invalid SCSI sense response code: %hhu\\n\", response_code);\n        return SCSI_RES_ERR;\n    }\n\n    if (response_code >= 0x72) {\n        /* descriptor format, SPC-6 4.4.2 */\n        if (len > 1) {\n            sense_key = 0xf & sense_buf[1];\n        }\n        if (len > 2) {\n            additional_sense_code = sense_buf[2];\n        }\n        if (len > 3) {\n            additional_sense_code_qualifier = sense_buf[3];\n        }\n        if (len > 7) {\n            additional_length = sense_buf[7];\n        }\n    } else {\n        /* fixed format, SPC-6 4.4.3 */\n        if (len > 2) {\n            sense_key = 0xf & sense_buf[2];\n        }\n        if (len > 7) {\n            additional_length = sense_buf[7];\n        }\n        if (len > 12) {\n            additional_sense_code = sense_buf[12];\n        }\n        if (len > 13) {\n            additional_sense_code_qualifier = sense_buf[13];\n        }\n    }\n\n    switch (sense_key) {\n        case NO_SENSE:\n        case 0x0f: /* COMPLETED, not present in kernel headers */\n            ALOGD(\"SCSI success with sense data: key=%hhu, asc=%hhu, ascq=%hhu\\n\", sense_key,\n                  additional_sense_code, additional_sense_code_qualifier);\n            return SCSI_RES_OK;\n        case UNIT_ATTENTION:\n            ALOGD(\"UNIT ATTENTION with sense data: key=%hhu, asc=%hhu, ascq=%hhu\\n\", sense_key,\n                  additional_sense_code, additional_sense_code_qualifier);\n            if (additional_sense_code == 0x29) {\n                /* POWER ON or RESET condition */\n                return SCSI_RES_RETRY;\n            }\n\n            /* treat this UNIT ATTENTION as an error if we don't recognize it */\n            break;\n    }\n\n    ALOGE(\"Unexpected SCSI sense data: key=%hhu, asc=%hhu, ascq=%hhu\\n\", sense_key,\n          additional_sense_code, additional_sense_code_qualifier);\n    log_buf(ANDROID_LOG_ERROR, \"sense buffer: \", sense_buf, len);\n    return SCSI_RES_ERR;\n}\n\nstatic enum scsi_result check_sg_io_hdr(const sg_io_hdr_t* io_hdrp) {\n    if (io_hdrp->status == 0 && io_hdrp->host_status == 0 && io_hdrp->driver_status == 0) {\n        return SCSI_RES_OK;\n    }\n\n    if (io_hdrp->status & 0x01) {\n        ALOGE(\"SG_IO received unknown status, LSB is set: %hhu\", io_hdrp->status);\n    }\n\n    if (io_hdrp->masked_status != GOOD && io_hdrp->sb_len_wr > 0) {\n        enum scsi_result scsi_res = check_scsi_sense(io_hdrp->sbp, io_hdrp->sb_len_wr);\n        if (scsi_res == SCSI_RES_RETRY) {\n            return SCSI_RES_RETRY;\n        } else if (scsi_res != SCSI_RES_OK) {\n            ALOGE(\"Unexpected SCSI sense. masked_status: %hhu, host_status: %hu, driver_status: \"\n                  \"%hu\\n\",\n                  io_hdrp->masked_status, io_hdrp->host_status, io_hdrp->driver_status);\n            return scsi_res;\n        }\n    }\n\n    switch (io_hdrp->masked_status) {\n        case GOOD:\n            break;\n        case CHECK_CONDITION:\n            /* handled by check_sg_sense above */\n            break;\n        default:\n            ALOGE(\"SG_IO failed with masked_status: %hhu, host_status: %hu, driver_status: %hu\\n\",\n                  io_hdrp->masked_status, io_hdrp->host_status, io_hdrp->driver_status);\n            return SCSI_RES_ERR;\n    }\n\n    if (io_hdrp->host_status != 0) {\n        ALOGE(\"SG_IO failed with host_status: %hu, driver_status: %hu\\n\", io_hdrp->host_status,\n              io_hdrp->driver_status);\n    }\n\n    if (io_hdrp->resid != 0) {\n        ALOGE(\"SG_IO resid was non-zero: %d\\n\", io_hdrp->resid);\n    }\n    return SCSI_RES_ERR;\n}\n",
        "b_contents": "/* Returns false if the sense data was valid and no errors were present */\nstatic bool check_scsi_sense(const uint8_t* sense_buf, size_t len) {\n    uint8_t response_code = 0;\n    uint8_t sense_key = 0;\n    uint8_t additional_sense_code = 0;\n    uint8_t additional_sense_code_qualifier = 0;\n    uint8_t additional_length = 0;\n\n    if (!sense_buf || len == 0) {\n        ALOGE(\"Invalid SCSI sense buffer, length: %zu\\n\", len);\n        return false;\n    }\n\n    response_code = 0x7f & sense_buf[0];\n\n    if (response_code < 0x70 || response_code > 0x73) {\n        ALOGE(\"Invalid SCSI sense response code: %hhu\\n\", response_code);\n        return false;\n    }\n\n    if (response_code >= 0x72) {\n        /* descriptor format, SPC-6 4.4.2 */\n        if (len > 1) {\n            sense_key = 0xf & sense_buf[1];\n        }\n        if (len > 2) {\n            additional_sense_code = sense_buf[2];\n        }\n        if (len > 3) {\n            additional_sense_code_qualifier = sense_buf[3];\n        }\n        if (len > 7) {\n            additional_length = sense_buf[7];\n        }\n    } else {\n        /* fixed format, SPC-6 4.4.3 */\n        if (len > 2) {\n            sense_key = 0xf & sense_buf[2];\n        }\n        if (len > 7) {\n            additional_length = sense_buf[7];\n        }\n        if (len > 12) {\n            additional_sense_code = sense_buf[12];\n        }\n        if (len > 13) {\n            additional_sense_code_qualifier = sense_buf[13];\n        }\n    }\n\n    switch (sense_key) {\n        case NO_SENSE:\n        case 0x0f: /* COMPLETED, not present in kernel headers */\n            ALOGD(\"SCSI success with sense data: key=%hhu, asc=%hhu, ascq=%hhu\\n\", sense_key,\n                  additional_sense_code, additional_sense_code_qualifier);\n            return true;\n    }\n\n    ALOGE(\"Unexpected SCSI sense data: key=%hhu, asc=%hhu, ascq=%hhu\\n\", sense_key,\n          additional_sense_code, additional_sense_code_qualifier);\n    print_buf(stderr, \"sense buffer: \", sense_buf, len);\n    return false;\n}\n\nstatic void check_sg_io_hdr(const sg_io_hdr_t* io_hdrp) {\n    if (io_hdrp->status == 0 && io_hdrp->host_status == 0 && io_hdrp->driver_status == 0) {\n        return;\n    }\n\n    if (io_hdrp->status & 0x01) {\n        ALOGE(\"SG_IO received unknown status, LSB is set: %hhu\", io_hdrp->status);\n    }\n\n    if (io_hdrp->masked_status != GOOD && io_hdrp->sb_len_wr > 0) {\n        bool sense_error = check_scsi_sense(io_hdrp->sbp, io_hdrp->sb_len_wr);\n        if (sense_error) {\n            ALOGE(\"Unexpected SCSI sense. masked_status: %hhu, host_status: %hu, driver_status: \"\n                  \"%hu\\n\",\n                  io_hdrp->masked_status, io_hdrp->host_status, io_hdrp->driver_status);\n            return;\n        }\n    }\n\n    switch (io_hdrp->masked_status) {\n        case GOOD:\n            break;\n        case CHECK_CONDITION:\n            /* handled by check_sg_sense above */\n            break;\n        default:\n            ALOGE(\"SG_IO failed with masked_status: %hhu, host_status: %hu, driver_status: %hu\\n\",\n                  io_hdrp->masked_status, io_hdrp->host_status, io_hdrp->driver_status);\n            return;\n    }\n\n    if (io_hdrp->host_status != 0) {\n        ALOGE(\"SG_IO failed with host_status: %hu, driver_status: %hu\\n\", io_hdrp->host_status,\n              io_hdrp->driver_status);\n    }\n\n    if (io_hdrp->resid != 0) {\n        ALOGE(\"SG_IO resid was non-zero: %d\\n\", io_hdrp->resid);\n    }\n}\n",
        "base_contents": "",
        "res_region": "/**\n * enum scsi_result - Results of checking the SCSI status and sense buffer\n *\n * @SCSI_RES_OK:    SCSI status and sense are good\n * @SCSI_RES_ERR:   SCSI status or sense contain an unhandled error\n * @SCSI_RES_RETRY: SCSI sense buffer contains a status that indicates that the\n *                  command should be retried\n */\nenum scsi_result {\n    SCSI_RES_OK = 0,\n    SCSI_RES_ERR,\n    SCSI_RES_RETRY,\n};\n\nstatic enum scsi_result check_scsi_sense(const uint8_t* sense_buf, size_t len) {\n    uint8_t response_code = 0;\n    uint8_t sense_key = 0;\n    uint8_t additional_sense_code = 0;\n    uint8_t additional_sense_code_qualifier = 0;\n    uint8_t additional_length = 0;\n\n    if (!sense_buf || len == 0) {\n        ALOGE(\"Invalid SCSI sense buffer, length: %zu\\n\", len);\n        return SCSI_RES_ERR;\n    }\n\n    response_code = 0x7f & sense_buf[0];\n\n    if (response_code < 0x70 || response_code > 0x73) {\n        ALOGE(\"Invalid SCSI sense response code: %hhu\\n\", response_code);\n        return SCSI_RES_ERR;\n    }\n\n    if (response_code >= 0x72) {\n        /* descriptor format, SPC-6 4.4.2 */\n        if (len > 1) {\n            sense_key = 0xf & sense_buf[1];\n        }\n        if (len > 2) {\n            additional_sense_code = sense_buf[2];\n        }\n        if (len > 3) {\n            additional_sense_code_qualifier = sense_buf[3];\n        }\n        if (len > 7) {\n            additional_length = sense_buf[7];\n        }\n    } else {\n        /* fixed format, SPC-6 4.4.3 */\n        if (len > 2) {\n            sense_key = 0xf & sense_buf[2];\n        }\n        if (len > 7) {\n            additional_length = sense_buf[7];\n        }\n        if (len > 12) {\n            additional_sense_code = sense_buf[12];\n        }\n        if (len > 13) {\n            additional_sense_code_qualifier = sense_buf[13];\n        }\n    }\n\n    switch (sense_key) {\n        case NO_SENSE:\n        case 0x0f: /* COMPLETED, not present in kernel headers */\n            ALOGD(\"SCSI success with sense data: key=%hhu, asc=%hhu, ascq=%hhu\\n\", sense_key,\n                  additional_sense_code, additional_sense_code_qualifier);\n            return SCSI_RES_OK;\n        case UNIT_ATTENTION:\n            ALOGD(\"UNIT ATTENTION with sense data: key=%hhu, asc=%hhu, ascq=%hhu\\n\", sense_key,\n                  additional_sense_code, additional_sense_code_qualifier);\n            if (additional_sense_code == 0x29) {\n                /* POWER ON or RESET condition */\n                return SCSI_RES_RETRY;\n            }\n\n            /* treat this UNIT ATTENTION as an error if we don't recognize it */\n            break;\n    }\n\n    ALOGE(\"Unexpected SCSI sense data: key=%hhu, asc=%hhu, ascq=%hhu\\n\", sense_key,\n          additional_sense_code, additional_sense_code_qualifier);\n    log_buf(ANDROID_LOG_ERROR, \"sense buffer: \", sense_buf, len);\n    return SCSI_RES_ERR;\n}\n\nstatic enum scsi_result check_sg_io_hdr(const sg_io_hdr_t* io_hdrp) {\n    if (io_hdrp->status == 0 && io_hdrp->host_status == 0 && io_hdrp->driver_status == 0) {\n        return SCSI_RES_OK;\n    }\n\n    if (io_hdrp->status & 0x01) {\n        ALOGE(\"SG_IO received unknown status, LSB is set: %hhu\", io_hdrp->status);\n    }\n\n    if (io_hdrp->masked_status != GOOD && io_hdrp->sb_len_wr > 0) {\n        enum scsi_result scsi_res = check_scsi_sense(io_hdrp->sbp, io_hdrp->sb_len_wr);\n        if (scsi_res == SCSI_RES_RETRY) {\n            return SCSI_RES_RETRY;\n        } else if (scsi_res != SCSI_RES_OK) {\n            ALOGE(\"Unexpected SCSI sense. masked_status: %hhu, host_status: %hu, driver_status: \"\n                  \"%hu\\n\",\n                  io_hdrp->masked_status, io_hdrp->host_status, io_hdrp->driver_status);\n            return scsi_res;\n        }\n    }\n\n    switch (io_hdrp->masked_status) {\n        case GOOD:\n            break;\n        case CHECK_CONDITION:\n            /* handled by check_sg_sense above */\n            break;\n        default:\n            ALOGE(\"SG_IO failed with masked_status: %hhu, host_status: %hu, driver_status: %hu\\n\",\n                  io_hdrp->masked_status, io_hdrp->host_status, io_hdrp->driver_status);\n            return SCSI_RES_ERR;\n    }\n\n    if (io_hdrp->host_status != 0) {\n        ALOGE(\"SG_IO failed with host_status: %hu, driver_status: %hu\\n\", io_hdrp->host_status,\n              io_hdrp->driver_status);\n    }\n\n    if (io_hdrp->resid != 0) {\n        ALOGE(\"SG_IO resid was non-zero: %d\\n\", io_hdrp->resid);\n    }\n    return SCSI_RES_ERR;\n}\n",
        "lookback": " * enum scsi_result - Results of checking the SCSI status and sense buffer",
        "lookahead": "static int send_mmc_rpmb_req(int mmc_fd, const struct storage_rpmb_send_req* req) {",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 205,
        "end_line": 444,
        "merge_gen_region": " enum_ scsiresult Results checking SCSI and buffer * @__OK SCSI status sense sense good @___: status sense anhandled * @___: status sense contains a that that * command beried enum_ {__ =,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,___,__,__,__,__,___,___,___,___,___,___, static scsiresult_ checkscsisenseconst8t sensebuf sizet) uint_ responsecode 0;8t_ responsecode 0;8t_ responsekey 0;8t___ = 0 uint_ additionalsensecode 0;8t_sensecodequalifier 0;8t_ additionallength 0; (!_ || ==) ALOGEInvalid sense buffer length %\\n len); SCSI__; responsecode 0xf sensebuf0 ifresponsecode <x ||_code 0x) ALOGEInvalid sense response: %un response_);",
        "confidence": 0.9517936110496521,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "        int retry_count = UFS_RPMB_WRITE_RETRY_COUNT;\n        do {\n            out_cdb.length = __builtin_bswap32(req->reliable_write_size);\n            set_sg_io_hdr(&io_hdr, SG_DXFER_TO_DEV, sizeof(out_cdb), sizeof(sense_buffer),\n                          req->reliable_write_size, (void*)write_buf, (unsigned char*)&out_cdb,\n                          sense_buffer);\n            rc = ioctl(sg_fd, SG_IO, &io_hdr);\n            if (rc < 0) {\n                ALOGE(\"%s: ufs ioctl failed: %d, %s\\n\", __func__, rc, strerror(errno));\n                goto err_op;\n            }\n        } while (check_sg_io_hdr(&io_hdr) == SCSI_RES_RETRY && retry_count-- > 0);",
        "b_contents": "        set_sg_io_hdr(&io_hdr, SG_DXFER_TO_DEV, sizeof(out_cdb), sizeof(sense_buffer),\n                      req->reliable_write_size, (void*)write_buf, (unsigned char*)&out_cdb,\n                      sense_buffer);\n        rc = ioctl(sg_fd, SG_IO, &io_hdr);\n        if (rc < 0) {\n            ALOGE(\"%s: ufs ioctl failed: %d, %s\\n\", __func__, rc, strerror(errno));\n            goto err_op;\n        }\n        check_sg_io_hdr(&io_hdr);",
        "base_contents": "        set_sg_io_hdr(&io_hdr, SG_DXFER_TO_DEV, sizeof(out_cdb), sizeof(sense_buffer),\n                      req->reliable_write_size, (void*)write_buf, (unsigned char*)&out_cdb,\n                      sense_buffer);\n        rc = ioctl(sg_fd, SG_IO, &io_hdr);\n        if (rc < 0) {\n            ALOGE(\"%s: ufs ioctl failed: %d, %s\\n\", __func__, rc, strerror(errno));\n            goto err_op;\n        }",
        "res_region": "        int retry_count = UFS_RPMB_WRITE_RETRY_COUNT;\n        do {\n            out_cdb.length = __builtin_bswap32(req->reliable_write_size);\n            set_sg_io_hdr(&io_hdr, SG_DXFER_TO_DEV, sizeof(out_cdb), sizeof(sense_buffer),\n                          req->reliable_write_size, (void*)write_buf, (unsigned char*)&out_cdb,\n                          sense_buffer);\n            rc = ioctl(sg_fd, SG_IO, &io_hdr);\n            if (rc < 0) {\n                ALOGE(\"%s: ufs ioctl failed: %d, %s\\n\", __func__, rc, strerror(errno));\n                goto err_op;\n            }\n        } while (check_sg_io_hdr(&io_hdr) == SCSI_RES_RETRY && retry_count-- > 0);",
        "lookback": "        do {",
        "lookahead": "        write_buf += req->reliable_write_size;",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 528,
        "end_line": 560,
        "merge_gen_region": " {_. =builtinb32reqreli_do",
        "confidence": 0.8930920958518982,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "        /*\n         * We don't retry write response request messages (is_request_write ==\n         * true) because a unit attention condition between the write and\n         * requesting a response means that the device was reset and we can't\n         * get a response to our original write. We can only retry this SG_IO\n         * call when it is the first call in our sequence.\n         */\n        int retry_count = is_request_write ? 0 : UFS_RPMB_READ_RETRY_COUNT;\n        do {\n            out_cdb.length = __builtin_bswap32(req->write_size);\n            set_sg_io_hdr(&io_hdr, SG_DXFER_TO_DEV, sizeof(out_cdb), sizeof(sense_buffer),\n                          req->write_size, (void*)write_buf, (unsigned char*)&out_cdb,\n                          sense_buffer);\n            rc = ioctl(sg_fd, SG_IO, &io_hdr);\n            if (rc < 0) {\n                ALOGE(\"%s: ufs ioctl failed: %d, %s\\n\", __func__, rc, strerror(errno));\n                goto err_op;\n            }\n        } while (check_sg_io_hdr(&io_hdr) == SCSI_RES_RETRY && retry_count-- > 0);",
        "b_contents": "        set_sg_io_hdr(&io_hdr, SG_DXFER_TO_DEV, sizeof(out_cdb), sizeof(sense_buffer),\n                      req->write_size, (void*)write_buf, (unsigned char*)&out_cdb, sense_buffer);\n        rc = ioctl(sg_fd, SG_IO, &io_hdr);\n        if (rc < 0) {\n            ALOGE(\"%s: ufs ioctl failed: %d, %s\\n\", __func__, rc, strerror(errno));\n            goto err_op;\n        }\n        check_sg_io_hdr(&io_hdr);",
        "base_contents": "        set_sg_io_hdr(&io_hdr, SG_DXFER_TO_DEV, sizeof(out_cdb), sizeof(sense_buffer),\n                      req->write_size, (void*)write_buf, (unsigned char*)&out_cdb, sense_buffer);\n        rc = ioctl(sg_fd, SG_IO, &io_hdr);\n        if (rc < 0) {\n            ALOGE(\"%s: ufs ioctl failed: %d, %s\\n\", __func__, rc, strerror(errno));\n            goto err_op;\n        }",
        "res_region": "        /*\n         * We don't retry write response request messages (is_request_write ==\n         * true) because a unit attention condition between the write and\n         * requesting a response means that the device was reset and we can't\n         * get a response to our original write. We can only retry this SG_IO\n         * call when it is the first call in our sequence.\n         */\n        int retry_count = is_request_write ? 0 : UFS_RPMB_READ_RETRY_COUNT;\n        do {\n            out_cdb.length = __builtin_bswap32(req->write_size);\n            set_sg_io_hdr(&io_hdr, SG_DXFER_TO_DEV, sizeof(out_cdb), sizeof(sense_buffer),\n                          req->write_size, (void*)write_buf, (unsigned char*)&out_cdb,\n                          sense_buffer);\n            rc = ioctl(sg_fd, SG_IO, &io_hdr);\n            if (rc < 0) {\n                ALOGE(\"%s: ufs ioctl failed: %d, %s\\n\", __func__, rc, strerror(errno));\n                goto err_op;\n            }\n        } while (check_sg_io_hdr(&io_hdr) == SCSI_RES_RETRY && retry_count-- > 0);",
        "lookback": "         * We don't retry write response request messages (is_request_write ==",
        "lookahead": "        write_buf += req->write_size;",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 567,
        "end_line": 604,
        "merge_gen_region": " We't write request (___ *) a atset,_,,__,,__,,__,,__,,__,,__,,__,,__,,__,,__,,__,,__,,__,,__,,__,,__,,__,,__,,__,,__,,__,,__,,__,,___,,_,,_,,__,,",
        "confidence": 0.9280044436454773,
        "hesitated": false,
        "resolved": false
    }
]