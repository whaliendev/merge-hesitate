[
    {
        "a_contents": "// Test that a transient merge consistency check failure can resume properly.\nTEST_F(SnapshotUpdateTest, ConsistencyCheckResume) {\n    if (!ShouldUseCompression()) {\n        // b/179111359\n        GTEST_SKIP() << \"Skipping Virtual A/B Compression test\";\n    }\n\n    auto old_sys_size = GetSize(sys_);\n    auto old_prd_size = GetSize(prd_);\n\n    // Grow |sys| but shrink |prd|.\n    SetSize(sys_, old_sys_size * 2);\n    sys_->set_estimate_cow_size(8_MiB);\n    SetSize(prd_, old_prd_size / 2);\n    prd_->set_estimate_cow_size(1_MiB);\n\n    AddOperationForPartitions();\n\n    ASSERT_TRUE(sm->BeginUpdate());\n    ASSERT_TRUE(sm->CreateUpdateSnapshots(manifest_));\n    ASSERT_TRUE(WriteSnapshotAndHash(\"sys_b\"));\n    ASSERT_TRUE(WriteSnapshotAndHash(\"vnd_b\"));\n    ASSERT_TRUE(ShiftAllSnapshotBlocks(\"prd_b\", old_prd_size));\n\n    sync();\n\n    // Assert that source partitions aren't affected.\n    for (const auto& name : {\"sys_a\", \"vnd_a\", \"prd_a\"}) {\n        ASSERT_TRUE(IsPartitionUnchanged(name));\n    }\n\n    ASSERT_TRUE(sm->FinishedSnapshotWrites(false));\n\n    // Simulate shutting down the device.\n    ASSERT_TRUE(UnmapAll());\n\n    // After reboot, init does first stage mount.\n    auto init = NewManagerForFirstStageMount(\"_b\");\n    ASSERT_NE(init, nullptr);\n    ASSERT_TRUE(init->NeedSnapshotsInFirstStageMount());\n    ASSERT_TRUE(init->CreateLogicalAndSnapshotPartitions(\"super\", snapshot_timeout_));\n\n    // Check that the target partitions have the same content.\n    for (const auto& name : {\"sys_b\", \"vnd_b\", \"prd_b\"}) {\n        ASSERT_TRUE(IsPartitionUnchanged(name));\n    }\n\n    auto old_checker = init->merge_consistency_checker();\n\n    init->set_merge_consistency_checker(\n            [](const std::string&, const SnapshotStatus&) -> MergeFailureCode {\n                return MergeFailureCode::WrongMergeCountConsistencyCheck;\n            });\n\n    // Initiate the merge and wait for it to be completed.\n    ASSERT_TRUE(init->InitiateMerge());\n    ASSERT_EQ(init->IsSnapuserdRequired(), ShouldUseUserspaceSnapshots());\n    {\n        // Check that the merge phase is FIRST_PHASE until at least one call\n        // to ProcessUpdateState() occurs.\n        ASSERT_TRUE(AcquireLock());\n        auto local_lock = std::move(lock_);\n        auto status = init->ReadSnapshotUpdateStatus(local_lock.get());\n        ASSERT_EQ(status.merge_phase(), MergePhase::FIRST_PHASE);\n    }\n\n    // Merge should have failed.\n    ASSERT_EQ(UpdateState::MergeFailed, init->ProcessUpdateState());\n\n    // Simulate shutting down the device and creating partitions again.\n    ASSERT_TRUE(UnmapAll());\n\n    // Restore the checker.\n    init->set_merge_consistency_checker(std::move(old_checker));\n\n    ASSERT_TRUE(init->CreateLogicalAndSnapshotPartitions(\"super\", snapshot_timeout_));\n\n    // Complete the merge.\n    ASSERT_EQ(UpdateState::MergeCompleted, init->ProcessUpdateState());\n\n    // Check that the target partitions have the same content after the merge.\n    for (const auto& name : {\"sys_b\", \"vnd_b\", \"prd_b\"}) {\n        ASSERT_TRUE(IsPartitionUnchanged(name))\n                << \"Content of \" << name << \" changes after the merge\";\n    }\n}\n",
        "b_contents": "// Test that a transient merge consistency check failure can resume properly.\nTEST_F(SnapshotUpdateTest, ConsistencyCheckResume) {\n    if (!IsCompressionEnabled()) {\n        // b/179111359\n        GTEST_SKIP() << \"Skipping Virtual A/B Compression test\";\n    }\n\n    auto old_sys_size = GetSize(sys_);\n    auto old_prd_size = GetSize(prd_);\n\n    // Grow |sys| but shrink |prd|.\n    SetSize(sys_, old_sys_size * 2);\n    sys_->set_estimate_cow_size(8_MiB);\n    SetSize(prd_, old_prd_size / 2);\n    prd_->set_estimate_cow_size(1_MiB);\n\n    AddOperationForPartitions();\n\n    ASSERT_TRUE(sm->BeginUpdate());\n    ASSERT_TRUE(sm->CreateUpdateSnapshots(manifest_));\n    ASSERT_TRUE(WriteSnapshotAndHash(\"sys_b\"));\n    ASSERT_TRUE(WriteSnapshotAndHash(\"vnd_b\"));\n    ASSERT_TRUE(ShiftAllSnapshotBlocks(\"prd_b\", old_prd_size));\n\n    sync();\n\n    // Assert that source partitions aren't affected.\n    for (const auto& name : {\"sys_a\", \"vnd_a\", \"prd_a\"}) {\n        ASSERT_TRUE(IsPartitionUnchanged(name));\n    }\n\n    ASSERT_TRUE(sm->FinishedSnapshotWrites(false));\n\n    // Simulate shutting down the device.\n    ASSERT_TRUE(UnmapAll());\n\n    // After reboot, init does first stage mount.\n    auto init = NewManagerForFirstStageMount(\"_b\");\n    ASSERT_NE(init, nullptr);\n    ASSERT_TRUE(init->NeedSnapshotsInFirstStageMount());\n    ASSERT_TRUE(init->CreateLogicalAndSnapshotPartitions(\"super\", snapshot_timeout_));\n\n    // Check that the target partitions have the same content.\n    for (const auto& name : {\"sys_b\", \"vnd_b\", \"prd_b\"}) {\n        ASSERT_TRUE(IsPartitionUnchanged(name));\n    }\n\n    auto old_checker = init->merge_consistency_checker();\n\n    init->set_merge_consistency_checker(\n            [](const std::string&, const SnapshotStatus&) -> MergeFailureCode {\n                return MergeFailureCode::WrongMergeCountConsistencyCheck;\n            });\n\n    // Initiate the merge and wait for it to be completed.\n    ASSERT_TRUE(init->InitiateMerge());\n    {\n        // Check that the merge phase is FIRST_PHASE until at least one call\n        // to ProcessUpdateState() occurs.\n        ASSERT_TRUE(AcquireLock());\n        auto local_lock = std::move(lock_);\n        auto status = init->ReadSnapshotUpdateStatus(local_lock.get());\n        ASSERT_EQ(status.merge_phase(), MergePhase::FIRST_PHASE);\n    }\n\n    // Merge should have failed.\n    ASSERT_EQ(UpdateState::MergeFailed, init->ProcessUpdateState());\n\n    // Simulate shutting down the device and creating partitions again.\n    ASSERT_TRUE(UnmapAll());\n\n    // Restore the checker.\n    init->set_merge_consistency_checker(std::move(old_checker));\n\n    ASSERT_TRUE(init->CreateLogicalAndSnapshotPartitions(\"super\", snapshot_timeout_));\n\n    // Complete the merge.\n    ASSERT_EQ(UpdateState::MergeCompleted, init->ProcessUpdateState());\n\n    // Check that the target partitions have the same content after the merge.\n    for (const auto& name : {\"sys_b\", \"vnd_b\", \"prd_b\"}) {\n        ASSERT_TRUE(IsPartitionUnchanged(name))\n                << \"Content of \" << name << \" changes after the merge\";\n    }\n}\n",
        "base_contents": "",
        "res_region": "// Test that a transient merge consistency check failure can resume properly.\nTEST_F(SnapshotUpdateTest, ConsistencyCheckResume) {\n    if (!ShouldUseCompression()) {\n        // b/179111359\n        GTEST_SKIP() << \"Skipping Virtual A/B Compression test\";\n    }\n\n    auto old_sys_size = GetSize(sys_);\n    auto old_prd_size = GetSize(prd_);\n\n    // Grow |sys| but shrink |prd|.\n    SetSize(sys_, old_sys_size * 2);\n    sys_->set_estimate_cow_size(8_MiB);\n    SetSize(prd_, old_prd_size / 2);\n    prd_->set_estimate_cow_size(1_MiB);\n\n    AddOperationForPartitions();\n\n    ASSERT_TRUE(sm->BeginUpdate());\n    ASSERT_TRUE(sm->CreateUpdateSnapshots(manifest_));\n    ASSERT_TRUE(WriteSnapshotAndHash(\"sys_b\"));\n    ASSERT_TRUE(WriteSnapshotAndHash(\"vnd_b\"));\n    ASSERT_TRUE(ShiftAllSnapshotBlocks(\"prd_b\", old_prd_size));\n\n    sync();\n\n    // Assert that source partitions aren't affected.\n    for (const auto& name : {\"sys_a\", \"vnd_a\", \"prd_a\"}) {\n        ASSERT_TRUE(IsPartitionUnchanged(name));\n    }\n\n    ASSERT_TRUE(sm->FinishedSnapshotWrites(false));\n\n    // Simulate shutting down the device.\n    ASSERT_TRUE(UnmapAll());\n\n    // After reboot, init does first stage mount.\n    auto init = NewManagerForFirstStageMount(\"_b\");\n    ASSERT_NE(init, nullptr);\n    ASSERT_TRUE(init->NeedSnapshotsInFirstStageMount());\n    ASSERT_TRUE(init->CreateLogicalAndSnapshotPartitions(\"super\", snapshot_timeout_));\n\n    // Check that the target partitions have the same content.\n    for (const auto& name : {\"sys_b\", \"vnd_b\", \"prd_b\"}) {\n        ASSERT_TRUE(IsPartitionUnchanged(name));\n    }\n\n    auto old_checker = init->merge_consistency_checker();\n\n    init->set_merge_consistency_checker(\n            [](const std::string&, const SnapshotStatus&) -> MergeFailureCode {\n                return MergeFailureCode::WrongMergeCountConsistencyCheck;\n            });\n\n    // Initiate the merge and wait for it to be completed.\n    ASSERT_TRUE(init->InitiateMerge());\n    ASSERT_EQ(init->IsSnapuserdRequired(), ShouldUseUserspaceSnapshots());\n    {\n        // Check that the merge phase is FIRST_PHASE until at least one call\n        // to ProcessUpdateState() occurs.\n        ASSERT_TRUE(AcquireLock());\n        auto local_lock = std::move(lock_);\n        auto status = init->ReadSnapshotUpdateStatus(local_lock.get());\n        ASSERT_EQ(status.merge_phase(), MergePhase::FIRST_PHASE);\n    }\n\n    // Merge should have failed.\n    ASSERT_EQ(UpdateState::MergeFailed, init->ProcessUpdateState());\n\n    // Simulate shutting down the device and creating partitions again.\n    ASSERT_TRUE(UnmapAll());\n\n    // Restore the checker.\n    init->set_merge_consistency_checker(std::move(old_checker));\n\n    ASSERT_TRUE(init->CreateLogicalAndSnapshotPartitions(\"super\", snapshot_timeout_));\n\n    // Complete the merge.\n    ASSERT_EQ(UpdateState::MergeCompleted, init->ProcessUpdateState());\n\n    // Check that the target partitions have the same content after the merge.\n    for (const auto& name : {\"sys_b\", \"vnd_b\", \"prd_b\"}) {\n        ASSERT_TRUE(IsPartitionUnchanged(name))\n                << \"Content of \" << name << \" changes after the merge\";\n    }\n}\n",
        "lookback": "TEST_F(SnapshotUpdateTest, ConsistencyCheckResume) {",
        "lookahead": "// Test that if new system partitions uses empty space in super, that region is not snapshotted.",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 1396,
        "end_line": 1572,
        "merge_gen_region": "_(Update,sistencyResume { Test a merge check can properly._(SnapshotTest ConCheck) { Test a merge check can properly._(Update,sistencyResume { ifShouldCompression { b17913 GTESTSKIP <<Skip Virtual/ Comp test } auto____ =Sizesys auto___ =Sizesys auto___ =Sizeprd //rowsys but |prd Set(_, oldsyssize 2 syssetestimatecowsize8Mi);Sizeprd oldsyssize 2 pr_->_____(_B AddFors ASSERTTRUEsmBegin());_(->Updatesmanifest ASSERTTRUEWriteAnd(\"__\"));_(SnapshotHashv_\"));_(AllSnapshot(\"_\",_\",__ oldprdsize sync // that partitions't. ( auto name {\"_\",v_\",prda}) ASSERTTRUEIsUn(name } ASSERTTRUEsmFinishedWrit(false // shut down device ASSERTTRUEUnAll // reboot init first mount auto =ManagerFirstMountb ASSERTNEinit nullptr ASSERTTRUEinitNeedsFirstStage());_(->LogicalSnapshotPartition(\"super snapshottimeout // that target have same. ( auto name {\"_\",v_\",prdb}) ASSERTTRUEIsUn(name } oldchecker init",
        "confidence": 0.9096418619155884,
        "hesitated": false,
        "resolved": false
    }
]