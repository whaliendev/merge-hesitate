[
    {
        "a_contents": "class ETMThreadTreeWhenRecording : public ETMThreadTree {\n public:\n  ETMThreadTreeWhenRecording(bool dump_maps_from_proc)\n      : dump_maps_from_proc_(dump_maps_from_proc) {}\n\n  ThreadTree& GetThreadTree() { return thread_tree_; }\n  void ExcludePid(pid_t pid) { exclude_pid_ = pid; }\n\n  const ThreadEntry* FindThread(int tid) override {\n    const ThreadEntry* thread = thread_tree_.FindThread(tid);\n    if (thread == nullptr) {\n      if (dump_maps_from_proc_) {\n        thread = FindThreadFromProc(tid);\n      }\n      if (thread == nullptr) {\n        return nullptr;\n      }\n    }\n    if (exclude_pid_ && exclude_pid_ == thread->pid) {\n      return nullptr;\n    }\n\n    if (dump_maps_from_proc_) {\n      DumpMapsFromProc(thread->pid);\n    }\n    return thread;\n  }\n\n  void DisableThreadExitRecords() override { thread_tree_.DisableThreadExitRecords(); }\n  const MapSet& GetKernelMaps() override { return thread_tree_.GetKernelMaps(); }\n\n private:\n  const ThreadEntry* FindThreadFromProc(int tid) {\n    std::string comm;\n    pid_t pid;\n    if (ReadThreadNameAndPid(tid, &comm, &pid)) {\n      thread_tree_.SetThreadName(pid, tid, comm);\n      return thread_tree_.FindThread(tid);\n    }\n    return nullptr;\n  }\n\n  void DumpMapsFromProc(int pid) {\n    if (dumped_processes_.count(pid) == 0) {\n      dumped_processes_.insert(pid);\n      std::vector<ThreadMmap> maps;\n      if (GetThreadMmapsInProcess(pid, &maps)) {\n        for (const auto& map : maps) {\n          thread_tree_.AddThreadMap(pid, pid, map.start_addr, map.len, map.pgoff, map.name);\n        }\n      }\n    }\n  }\n\n  ThreadTree thread_tree_;\n  bool dump_maps_from_proc_;\n  std::unordered_set<int> dumped_processes_;\n  std::optional<pid_t> exclude_pid_;\n};\n\nclass ETMBranchListGeneratorImpl : public ETMBranchListGenerator {\n public:\n  ETMBranchListGeneratorImpl(bool dump_maps_from_proc)\n      : thread_tree_(dump_maps_from_proc), binary_filter_(nullptr) {}\n\n  void SetExcludePid(pid_t pid) override { thread_tree_.ExcludePid(pid); }\n  void SetBinaryFilter(const RegEx* binary_name_regex) override {\n    binary_filter_.SetRegex(binary_name_regex);\n  }\n\n  bool ProcessRecord(const Record& r, bool& consumed) override;\n  BranchListBinaryMap GetBranchListBinaryMap() override;\n\n private:\n  struct AuxRecordData {\n    uint64_t start;\n    uint64_t end;\n    bool formatted;\n    AuxRecordData(uint64_t start, uint64_t end, bool formatted)\n        : start(start), end(end), formatted(formatted) {}\n  };\n\n  struct PerCpuData {\n    std::vector<uint8_t> aux_data;\n    uint64_t data_offset = 0;\n    std::queue<AuxRecordData> aux_records;\n  };\n\n  bool ProcessAuxRecord(const AuxRecord& r);\n  bool ProcessAuxTraceRecord(const AuxTraceRecord& r);\n  void ProcessBranchList(const ETMBranchList& branch_list);\n\n  ETMThreadTreeWhenRecording thread_tree_;\n  uint64_t kernel_map_start_addr_ = 0;\n  BinaryFilter binary_filter_;\n  std::map<uint32_t, PerCpuData> cpu_map_;\n  std::unique_ptr<ETMDecoder> etm_decoder_;\n  std::unordered_map<Dso*, BranchListBinaryInfo> branch_list_binary_map_;\n};\n\nbool ETMBranchListGeneratorImpl::ProcessRecord(const Record& r, bool& consumed) {\n  consumed = true;  // No need to store any records.\n  uint32_t type = r.type();\n  if (type == PERF_RECORD_AUXTRACE_INFO) {\n    etm_decoder_ = ETMDecoder::Create(*static_cast<const AuxTraceInfoRecord*>(&r), thread_tree_);\n    if (!etm_decoder_) {\n      return false;\n    }\n    etm_decoder_->RegisterCallback(\n        [this](const ETMBranchList& branch) { ProcessBranchList(branch); });\n    return true;\n  }\n  if (type == PERF_RECORD_AUX) {\n    return ProcessAuxRecord(*static_cast<const AuxRecord*>(&r));\n  }\n  if (type == PERF_RECORD_AUXTRACE) {\n    return ProcessAuxTraceRecord(*static_cast<const AuxTraceRecord*>(&r));\n  }\n  if (type == PERF_RECORD_MMAP && r.InKernel()) {\n    auto& mmap_r = *static_cast<const MmapRecord*>(&r);\n    if (android::base::StartsWith(mmap_r.filename, DEFAULT_KERNEL_MMAP_NAME)) {\n      kernel_map_start_addr_ = mmap_r.data->addr;\n    }\n  }\n  thread_tree_.GetThreadTree().Update(r);\n  return true;\n}\n\nbool ETMBranchListGeneratorImpl::ProcessAuxRecord(const AuxRecord& r) {\n  OverflowResult result = SafeAdd(r.data->aux_offset, r.data->aux_size);\n  if (result.overflow || r.data->aux_size > SIZE_MAX) {\n    LOG(ERROR) << \"invalid aux record\";\n    return false;\n  }\n  size_t size = r.data->aux_size;\n  uint64_t start = r.data->aux_offset;\n  uint64_t end = result.value;\n  PerCpuData& data = cpu_map_[r.Cpu()];\n  if (start >= data.data_offset && end <= data.data_offset + data.aux_data.size()) {\n    // The ETM data is available. Process it now.\n    uint8_t* p = data.aux_data.data() + (start - data.data_offset);\n    if (!etm_decoder_) {\n      LOG(ERROR) << \"ETMDecoder isn't created\";\n      return false;\n    }\n    return etm_decoder_->ProcessData(p, size, !r.Unformatted(), r.Cpu());\n  }\n  // The ETM data isn't available. Put the aux record into queue.\n  data.aux_records.emplace(start, end, !r.Unformatted());\n  return true;\n}\n\nbool ETMBranchListGeneratorImpl::ProcessAuxTraceRecord(const AuxTraceRecord& r) {\n  OverflowResult result = SafeAdd(r.data->offset, r.data->aux_size);\n  if (result.overflow || r.data->aux_size > SIZE_MAX) {\n    LOG(ERROR) << \"invalid auxtrace record\";\n    return false;\n  }\n  size_t size = r.data->aux_size;\n  uint64_t start = r.data->offset;\n  uint64_t end = result.value;\n  PerCpuData& data = cpu_map_[r.Cpu()];\n  data.data_offset = start;\n  CHECK(r.location.addr != nullptr);\n  data.aux_data.resize(size);\n  memcpy(data.aux_data.data(), r.location.addr, size);\n\n  // Process cached aux records.\n  while (!data.aux_records.empty() && data.aux_records.front().start < end) {\n    const AuxRecordData& aux = data.aux_records.front();\n    if (aux.start >= start && aux.end <= end) {\n      uint8_t* p = data.aux_data.data() + (aux.start - start);\n      if (!etm_decoder_) {\n        LOG(ERROR) << \"ETMDecoder isn't created\";\n        return false;\n      }\n      if (!etm_decoder_->ProcessData(p, aux.end - aux.start, aux.formatted, r.Cpu())) {\n        return false;\n      }\n    }\n    data.aux_records.pop();\n  }\n  return true;\n}\n\nvoid ETMBranchListGeneratorImpl::ProcessBranchList(const ETMBranchList& branch_list) {\n  if (!binary_filter_.Filter(branch_list.dso)) {\n    return;\n  }\n  auto& branch_map = branch_list_binary_map_[branch_list.dso].branch_map;\n  ++branch_map[branch_list.addr][branch_list.branch];\n}\n\nBranchListBinaryMap ETMBranchListGeneratorImpl::GetBranchListBinaryMap() {\n  BranchListBinaryMap binary_map;\n  for (auto& p : branch_list_binary_map_) {\n    Dso* dso = p.first;\n    BranchListBinaryInfo& binary = p.second;\n    binary.dso_type = dso->type();\n    BuildId build_id;\n    GetBuildId(*dso, build_id);\n    BinaryKey key(dso->Path(), build_id);\n    if (binary.dso_type == DSO_KERNEL) {\n      if (kernel_map_start_addr_ == 0) {\n        LOG(WARNING) << \"Can't convert kernel ip addresses without kernel start addr. So remove \"\n                        \"branches for the kernel.\";\n        continue;\n      }\n      key.kernel_start_addr = kernel_map_start_addr_;\n    }\n    binary_map[key] = std::move(binary);\n  }\n  return binary_map;\n}\n\nstd::unique_ptr<ETMBranchListGenerator> ETMBranchListGenerator::Create(bool dump_maps_from_proc) {\n  return std::unique_ptr<ETMBranchListGenerator>(\n      new ETMBranchListGeneratorImpl(dump_maps_from_proc));\n}\n\nETMBranchListGenerator::~ETMBranchListGenerator() {}\n",
        "b_contents": "class ETMThreadTreeWhenRecording : public ETMThreadTree {\n public:\n  ETMThreadTreeWhenRecording(bool dump_maps_from_proc)\n      : dump_maps_from_proc_(dump_maps_from_proc) {}\n\n  ThreadTree& GetThreadTree() { return thread_tree_; }\n\n  const ThreadEntry* FindThread(int tid) override {\n    const ThreadEntry* thread = thread_tree_.FindThread(tid);\n    if (thread == nullptr) {\n      if (dump_maps_from_proc_) {\n        thread = FindThreadFromProc(tid);\n      }\n      if (thread == nullptr) {\n        return nullptr;\n      }\n    }\n\n    if (dump_maps_from_proc_) {\n      DumpMapsFromProc(thread->pid);\n    }\n    return thread;\n  }\n\n  void DisableThreadExitRecords() override { thread_tree_.DisableThreadExitRecords(); }\n  const MapSet& GetKernelMaps() override { return thread_tree_.GetKernelMaps(); }\n\n private:\n  const ThreadEntry* FindThreadFromProc(int tid) {\n    std::string comm;\n    pid_t pid;\n    if (ReadThreadNameAndPid(tid, &comm, &pid)) {\n      thread_tree_.SetThreadName(pid, tid, comm);\n      return thread_tree_.FindThread(tid);\n    }\n    return nullptr;\n  }\n\n  void DumpMapsFromProc(int pid) {\n    if (dumped_processes_.count(pid) == 0) {\n      dumped_processes_.insert(pid);\n      std::vector<ThreadMmap> maps;\n      if (GetThreadMmapsInProcess(pid, &maps)) {\n        for (const auto& map : maps) {\n          thread_tree_.AddThreadMap(pid, pid, map.start_addr, map.len, map.pgoff, map.name);\n        }\n      }\n    }\n  }\n\n  ThreadTree thread_tree_;\n  bool dump_maps_from_proc_;\n  std::unordered_set<int> dumped_processes_;\n};\n\nclass ETMBranchListGeneratorImpl : public ETMBranchListGenerator {\n public:\n  ETMBranchListGeneratorImpl(bool dump_maps_from_proc) : thread_tree_(dump_maps_from_proc) {}\n\n  bool ProcessRecord(const Record& r, bool& consumed) override;\n  BranchListBinaryMap GetBranchListBinaryMap() override;\n\n private:\n  struct AuxRecordData {\n    uint64_t start;\n    uint64_t end;\n    bool formatted;\n    AuxRecordData(uint64_t start, uint64_t end, bool formatted)\n        : start(start), end(end), formatted(formatted) {}\n  };\n\n  struct PerCpuData {\n    std::vector<uint8_t> aux_data;\n    uint64_t data_offset = 0;\n    std::queue<AuxRecordData> aux_records;\n  };\n\n  bool ProcessAuxRecord(const AuxRecord& r);\n  bool ProcessAuxTraceRecord(const AuxTraceRecord& r);\n  void ProcessBranchList(const ETMBranchList& branch_list);\n\n  ETMThreadTreeWhenRecording thread_tree_;\n  uint64_t kernel_map_start_addr_ = 0;\n  std::map<uint32_t, PerCpuData> cpu_map_;\n  std::unique_ptr<ETMDecoder> etm_decoder_;\n  std::unordered_map<Dso*, BranchListBinaryInfo> branch_list_binary_map_;\n};\n\nbool ETMBranchListGeneratorImpl::ProcessRecord(const Record& r, bool& consumed) {\n  consumed = true;  // No need to store any records.\n  uint32_t type = r.type();\n  if (type == PERF_RECORD_AUXTRACE_INFO) {\n    etm_decoder_ = ETMDecoder::Create(*static_cast<const AuxTraceInfoRecord*>(&r), thread_tree_);\n    if (!etm_decoder_) {\n      return false;\n    }\n    etm_decoder_->RegisterCallback(\n        [this](const ETMBranchList& branch) { ProcessBranchList(branch); });\n    return true;\n  }\n  if (type == PERF_RECORD_AUX) {\n    return ProcessAuxRecord(*static_cast<const AuxRecord*>(&r));\n  }\n  if (type == PERF_RECORD_AUXTRACE) {\n    return ProcessAuxTraceRecord(*static_cast<const AuxTraceRecord*>(&r));\n  }\n  if (type == PERF_RECORD_MMAP && r.InKernel()) {\n    auto& mmap_r = *static_cast<const MmapRecord*>(&r);\n    if (android::base::StartsWith(mmap_r.filename, DEFAULT_KERNEL_MMAP_NAME)) {\n      kernel_map_start_addr_ = mmap_r.data->addr;\n    }\n  }\n  thread_tree_.GetThreadTree().Update(r);\n  return true;\n}\n\nbool ETMBranchListGeneratorImpl::ProcessAuxRecord(const AuxRecord& r) {\n  OverflowResult result = SafeAdd(r.data->aux_offset, r.data->aux_size);\n  if (result.overflow || r.data->aux_size > SIZE_MAX) {\n    LOG(ERROR) << \"invalid aux record\";\n    return false;\n  }\n  size_t size = r.data->aux_size;\n  uint64_t start = r.data->aux_offset;\n  uint64_t end = result.value;\n  PerCpuData& data = cpu_map_[r.Cpu()];\n  if (start >= data.data_offset && end <= data.data_offset + data.aux_data.size()) {\n    // The ETM data is available. Process it now.\n    uint8_t* p = data.aux_data.data() + (start - data.data_offset);\n    if (!etm_decoder_) {\n      LOG(ERROR) << \"ETMDecoder isn't created\";\n      return false;\n    }\n    return etm_decoder_->ProcessData(p, size, !r.Unformatted(), r.Cpu());\n  }\n  // The ETM data isn't available. Put the aux record into queue.\n  data.aux_records.emplace(start, end, !r.Unformatted());\n  return true;\n}\n\nbool ETMBranchListGeneratorImpl::ProcessAuxTraceRecord(const AuxTraceRecord& r) {\n  OverflowResult result = SafeAdd(r.data->offset, r.data->aux_size);\n  if (result.overflow || r.data->aux_size > SIZE_MAX) {\n    LOG(ERROR) << \"invalid auxtrace record\";\n    return false;\n  }\n  size_t size = r.data->aux_size;\n  uint64_t start = r.data->offset;\n  uint64_t end = result.value;\n  PerCpuData& data = cpu_map_[r.Cpu()];\n  data.data_offset = start;\n  CHECK(r.location.addr != nullptr);\n  data.aux_data.resize(size);\n  memcpy(data.aux_data.data(), r.location.addr, size);\n\n  // Process cached aux records.\n  while (!data.aux_records.empty() && data.aux_records.front().start < end) {\n    const AuxRecordData& aux = data.aux_records.front();\n    if (aux.start >= start && aux.end <= end) {\n      uint8_t* p = data.aux_data.data() + (aux.start - start);\n      if (!etm_decoder_) {\n        LOG(ERROR) << \"ETMDecoder isn't created\";\n        return false;\n      }\n      if (!etm_decoder_->ProcessData(p, aux.end - aux.start, aux.formatted, r.Cpu())) {\n        return false;\n      }\n    }\n    data.aux_records.pop();\n  }\n  return true;\n}\n\nvoid ETMBranchListGeneratorImpl::ProcessBranchList(const ETMBranchList& branch_list) {\n  auto& branch_map = branch_list_binary_map_[branch_list.dso].branch_map;\n  ++branch_map[branch_list.addr][branch_list.branch];\n}\n\nBranchListBinaryMap ETMBranchListGeneratorImpl::GetBranchListBinaryMap() {\n  BranchListBinaryMap binary_map;\n  for (auto& p : branch_list_binary_map_) {\n    Dso* dso = p.first;\n    BranchListBinaryInfo& binary = p.second;\n    binary.dso_type = dso->type();\n    BuildId build_id;\n    GetBuildId(*dso, build_id);\n    BinaryKey key(dso->Path(), build_id);\n    if (binary.dso_type == DSO_KERNEL) {\n      if (kernel_map_start_addr_ == 0) {\n        LOG(WARNING) << \"Can't convert kernel ip addresses without kernel start addr. So remove \"\n                        \"branches for the kernel.\";\n        continue;\n      }\n      key.kernel_start_addr = kernel_map_start_addr_;\n    }\n    binary_map[key] = std::move(binary);\n  }\n  return binary_map;\n}\n\nstd::unique_ptr<ETMBranchListGenerator> ETMBranchListGenerator::Create(bool dump_maps_from_proc) {\n  return std::unique_ptr<ETMBranchListGenerator>(\n      new ETMBranchListGeneratorImpl(dump_maps_from_proc));\n}\n\nETMBranchListGenerator::~ETMBranchListGenerator() {}\n",
        "base_contents": "",
        "res_region": "class ETMThreadTreeWhenRecording : public ETMThreadTree {\n public:\n  ETMThreadTreeWhenRecording(bool dump_maps_from_proc)\n      : dump_maps_from_proc_(dump_maps_from_proc) {}\n\n  ThreadTree& GetThreadTree() { return thread_tree_; }\n  void ExcludePid(pid_t pid) { exclude_pid_ = pid; }\n\n  const ThreadEntry* FindThread(int tid) override {\n    const ThreadEntry* thread = thread_tree_.FindThread(tid);\n    if (thread == nullptr) {\n      if (dump_maps_from_proc_) {\n        thread = FindThreadFromProc(tid);\n      }\n      if (thread == nullptr) {\n        return nullptr;\n      }\n    }\n    if (exclude_pid_ && exclude_pid_ == thread->pid) {\n      return nullptr;\n    }\n\n    if (dump_maps_from_proc_) {\n      DumpMapsFromProc(thread->pid);\n    }\n    return thread;\n  }\n\n  void DisableThreadExitRecords() override { thread_tree_.DisableThreadExitRecords(); }\n  const MapSet& GetKernelMaps() override { return thread_tree_.GetKernelMaps(); }\n\n private:\n  const ThreadEntry* FindThreadFromProc(int tid) {\n    std::string comm;\n    pid_t pid;\n    if (ReadThreadNameAndPid(tid, &comm, &pid)) {\n      thread_tree_.SetThreadName(pid, tid, comm);\n      return thread_tree_.FindThread(tid);\n    }\n    return nullptr;\n  }\n\n  void DumpMapsFromProc(int pid) {\n    if (dumped_processes_.count(pid) == 0) {\n      dumped_processes_.insert(pid);\n      std::vector<ThreadMmap> maps;\n      if (GetThreadMmapsInProcess(pid, &maps)) {\n        for (const auto& map : maps) {\n          thread_tree_.AddThreadMap(pid, pid, map.start_addr, map.len, map.pgoff, map.name);\n        }\n      }\n    }\n  }\n\n  ThreadTree thread_tree_;\n  bool dump_maps_from_proc_;\n  std::unordered_set<int> dumped_processes_;\n  std::optional<pid_t> exclude_pid_;\n};\n\nclass ETMBranchListGeneratorImpl : public ETMBranchListGenerator {\n public:\n  ETMBranchListGeneratorImpl(bool dump_maps_from_proc)\n      : thread_tree_(dump_maps_from_proc), binary_filter_(nullptr) {}\n\n  void SetExcludePid(pid_t pid) override { thread_tree_.ExcludePid(pid); }\n  void SetBinaryFilter(const RegEx* binary_name_regex) override {\n    binary_filter_.SetRegex(binary_name_regex);\n  }\n\n  bool ProcessRecord(const Record& r, bool& consumed) override;\n  BranchListBinaryMap GetBranchListBinaryMap() override;\n\n private:\n  struct AuxRecordData {\n    uint64_t start;\n    uint64_t end;\n    bool formatted;\n    AuxRecordData(uint64_t start, uint64_t end, bool formatted)\n        : start(start), end(end), formatted(formatted) {}\n  };\n\n  struct PerCpuData {\n    std::vector<uint8_t> aux_data;\n    uint64_t data_offset = 0;\n    std::queue<AuxRecordData> aux_records;\n  };\n\n  bool ProcessAuxRecord(const AuxRecord& r);\n  bool ProcessAuxTraceRecord(const AuxTraceRecord& r);\n  void ProcessBranchList(const ETMBranchList& branch_list);\n\n  ETMThreadTreeWhenRecording thread_tree_;\n  uint64_t kernel_map_start_addr_ = 0;\n  BinaryFilter binary_filter_;\n  std::map<uint32_t, PerCpuData> cpu_map_;\n  std::unique_ptr<ETMDecoder> etm_decoder_;\n  std::unordered_map<Dso*, BranchListBinaryInfo> branch_list_binary_map_;\n};\n\nbool ETMBranchListGeneratorImpl::ProcessRecord(const Record& r, bool& consumed) {\n  consumed = true;  // No need to store any records.\n  uint32_t type = r.type();\n  if (type == PERF_RECORD_AUXTRACE_INFO) {\n    etm_decoder_ = ETMDecoder::Create(*static_cast<const AuxTraceInfoRecord*>(&r), thread_tree_);\n    if (!etm_decoder_) {\n      return false;\n    }\n    etm_decoder_->RegisterCallback(\n        [this](const ETMBranchList& branch) { ProcessBranchList(branch); });\n    return true;\n  }\n  if (type == PERF_RECORD_AUX) {\n    return ProcessAuxRecord(*static_cast<const AuxRecord*>(&r));\n  }\n  if (type == PERF_RECORD_AUXTRACE) {\n    return ProcessAuxTraceRecord(*static_cast<const AuxTraceRecord*>(&r));\n  }\n  if (type == PERF_RECORD_MMAP && r.InKernel()) {\n    auto& mmap_r = *static_cast<const MmapRecord*>(&r);\n    if (android::base::StartsWith(mmap_r.filename, DEFAULT_KERNEL_MMAP_NAME)) {\n      kernel_map_start_addr_ = mmap_r.data->addr;\n    }\n  }\n  thread_tree_.GetThreadTree().Update(r);\n  return true;\n}\n\nbool ETMBranchListGeneratorImpl::ProcessAuxRecord(const AuxRecord& r) {\n  OverflowResult result = SafeAdd(r.data->aux_offset, r.data->aux_size);\n  if (result.overflow || r.data->aux_size > SIZE_MAX) {\n    LOG(ERROR) << \"invalid aux record\";\n    return false;\n  }\n  size_t size = r.data->aux_size;\n  uint64_t start = r.data->aux_offset;\n  uint64_t end = result.value;\n  PerCpuData& data = cpu_map_[r.Cpu()];\n  if (start >= data.data_offset && end <= data.data_offset + data.aux_data.size()) {\n    // The ETM data is available. Process it now.\n    uint8_t* p = data.aux_data.data() + (start - data.data_offset);\n    if (!etm_decoder_) {\n      LOG(ERROR) << \"ETMDecoder isn't created\";\n      return false;\n    }\n    return etm_decoder_->ProcessData(p, size, !r.Unformatted(), r.Cpu());\n  }\n  // The ETM data isn't available. Put the aux record into queue.\n  data.aux_records.emplace(start, end, !r.Unformatted());\n  return true;\n}\n\nbool ETMBranchListGeneratorImpl::ProcessAuxTraceRecord(const AuxTraceRecord& r) {\n  OverflowResult result = SafeAdd(r.data->offset, r.data->aux_size);\n  if (result.overflow || r.data->aux_size > SIZE_MAX) {\n    LOG(ERROR) << \"invalid auxtrace record\";\n    return false;\n  }\n  size_t size = r.data->aux_size;\n  uint64_t start = r.data->offset;\n  uint64_t end = result.value;\n  PerCpuData& data = cpu_map_[r.Cpu()];\n  data.data_offset = start;\n  CHECK(r.location.addr != nullptr);\n  data.aux_data.resize(size);\n  memcpy(data.aux_data.data(), r.location.addr, size);\n\n  // Process cached aux records.\n  while (!data.aux_records.empty() && data.aux_records.front().start < end) {\n    const AuxRecordData& aux = data.aux_records.front();\n    if (aux.start >= start && aux.end <= end) {\n      uint8_t* p = data.aux_data.data() + (aux.start - start);\n      if (!etm_decoder_) {\n        LOG(ERROR) << \"ETMDecoder isn't created\";\n        return false;\n      }\n      if (!etm_decoder_->ProcessData(p, aux.end - aux.start, aux.formatted, r.Cpu())) {\n        return false;\n      }\n    }\n    data.aux_records.pop();\n  }\n  return true;\n}\n\nvoid ETMBranchListGeneratorImpl::ProcessBranchList(const ETMBranchList& branch_list) {\n  if (!binary_filter_.Filter(branch_list.dso)) {\n    return;\n  }\n  auto& branch_map = branch_list_binary_map_[branch_list.dso].branch_map;\n  ++branch_map[branch_list.addr][branch_list.branch];\n}\n\nBranchListBinaryMap ETMBranchListGeneratorImpl::GetBranchListBinaryMap() {\n  BranchListBinaryMap binary_map;\n  for (auto& p : branch_list_binary_map_) {\n    Dso* dso = p.first;\n    BranchListBinaryInfo& binary = p.second;\n    binary.dso_type = dso->type();\n    BuildId build_id;\n    GetBuildId(*dso, build_id);\n    BinaryKey key(dso->Path(), build_id);\n    if (binary.dso_type == DSO_KERNEL) {\n      if (kernel_map_start_addr_ == 0) {\n        LOG(WARNING) << \"Can't convert kernel ip addresses without kernel start addr. So remove \"\n                        \"branches for the kernel.\";\n        continue;\n      }\n      key.kernel_start_addr = kernel_map_start_addr_;\n    }\n    binary_map[key] = std::move(binary);\n  }\n  return binary_map;\n}\n\nstd::unique_ptr<ETMBranchListGenerator> ETMBranchListGenerator::Create(bool dump_maps_from_proc) {\n  return std::unique_ptr<ETMBranchListGenerator>(\n      new ETMBranchListGeneratorImpl(dump_maps_from_proc));\n}\n\nETMBranchListGenerator::~ETMBranchListGenerator() {}\n",
        "lookback": " public:",
        "lookahead": "}  // namespace simpleperf",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 162,
        "end_line": 594,
        "merge_gen_region": " EThreadTreeRecording publicTMTree public EThread {: EThreadTreeRecordingbool____) dumpmapsfromprocdumpmapsfromproc {}Tree GetTree { threadtree } ExPidpidt) excludepid =; constEntry Find( tid override constEntry thread thread threadtreeFind(); ( ==) ifdumpmapsfromproc { =ThreadFrom(); ifthread nullptr) ifdumpmapsfromproc { =ThreadFrom(); ifthread nullptr) return; } ifexcludepid &&__ ==->pid { nullptr } (_____) DumpFrom(->pid } thread; voidThreadExit() override threadtreeDisableExitRecords } Map&Kernel() { thread__.Kernel(); private constEntry FindFrom( tid) stdstring;_ pid ifReadNamePidtid &,pid { threadtreeSetNamepid tid comm return__.Threadtid } return; voidThreadExit() override threadtreeDisableExit(); constSet GetMaps() { thread__.Kernel(); private constEntry FindFrom( tid) stdstring;_ pid ifReadNamePidtid &,pid { threadtreeSetName(,,,,); thread__.Kernel(); private constEntry FindFrom( tid) stdstring;_ pid ifGet",
        "confidence": 0.920844316482544,
        "hesitated": false,
        "resolved": false
    }
]