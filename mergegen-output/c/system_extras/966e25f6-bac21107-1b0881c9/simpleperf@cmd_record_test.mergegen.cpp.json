[
    {
        "a_contents": "}\n\nTEST(record_cmd, record_java_app) {\n#if defined(__ANDROID__)\n  RecordingAppHelper helper;\n  // 1. Install apk.\n  ASSERT_TRUE(helper.InstallApk(GetTestData(\"DisplayBitmaps.apk\"),\n                                \"com.example.android.displayingbitmaps\"));\n  ASSERT_TRUE(helper.InstallApk(GetTestData(\"DisplayBitmapsTest.apk\"),\n                                \"com.example.android.displayingbitmaps.test\"));\n\n  // 2. Start the app.\n  ASSERT_TRUE(\n      helper.StartApp(\"am instrument -w -r -e debug false -e class \"\n                      \"com.example.android.displayingbitmaps.tests.GridViewTest \"\n                      \"com.example.android.displayingbitmaps.test/\"\n                      \"androidx.test.runner.AndroidJUnitRunner\"));\n\n  // 3. Record perf.data.\n  SetRunInAppToolForTesting(true, true);\n  ASSERT_TRUE(helper.RecordData(\n      \"-e cpu-clock --app com.example.android.displayingbitmaps -g --duration 10\"));\n\n  // 4. Check perf.data.\n  auto process_symbol = [&](const char* name) {\n#if !defined(IN_CTS_TEST)\n    const char* expected_name_with_keyguard = \"androidx.test.runner\";  // when screen is locked\n    if (strstr(name, expected_name_with_keyguard) != nullptr) {\n      return true;\n    }\n#endif\n    const char* expected_name = \"androidx.test.espresso\";  // when screen stays awake\n    return strstr(name, expected_name) != nullptr;\n  };\n  ASSERT_TRUE(helper.CheckData(process_symbol));\n#else\n  GTEST_LOG_(INFO) << \"This test tests a function only available on Android.\";\n#endif\n}\n\nTEST(record_cmd, record_native_app) {\n#if defined(__ANDROID__)\n  // In case of non-native ABI guest symbols are never directly executed, thus\n  // don't appear in perf.data. Instead binary translator executes code\n  // translated from guest at runtime.\n  OMIT_TEST_ON_NON_NATIVE_ABIS();\n\n  RecordingAppHelper helper;\n  // 1. Install apk.\n  ASSERT_TRUE(helper.InstallApk(GetTestData(\"EndlessTunnel.apk\"), \"com.google.sample.tunnel\"));\n\n  // 2. Start the app.\n  ASSERT_TRUE(\n      helper.StartApp(\"am start -n com.google.sample.tunnel/android.app.NativeActivity -a \"\n                      \"android.intent.action.MAIN -c android.intent.category.LAUNCHER\"));\n\n  // 3. Record perf.data.\n  SetRunInAppToolForTesting(true, true);\n  ASSERT_TRUE(helper.RecordData(\"-e cpu-clock --app com.google.sample.tunnel -g --duration 10\"));\n\n  // 4. Check perf.data.\n  auto process_symbol = [&](const char* name) {\n    const char* expected_name_with_keyguard = \"NativeActivity\";  // when screen is locked\n    if (strstr(name, expected_name_with_keyguard) != nullptr) {\n      return true;\n    }\n    const char* expected_name = \"PlayScene::DoFrame\";  // when screen is awake\n    return strstr(name, expected_name) != nullptr;\n  };\n  ASSERT_TRUE(helper.CheckData(process_symbol));\n#else\n  GTEST_LOG_(INFO) << \"This test tests a function only available on Android.\";\n#endif\n}\n\nTEST(record_cmd, no_cut_samples_option) {\n  ASSERT_TRUE(RunRecordCmd({\"--no-cut-samples\"}));\n}\n\nTEST(record_cmd, cs_etm_event) {\n  if (!ETMRecorder::GetInstance().CheckEtmSupport()) {\n    GTEST_LOG_(INFO) << \"Omit this test since etm isn't supported on this device\";\n    return;\n  }\n  TemporaryFile tmpfile;\n  ASSERT_TRUE(RunRecordCmd({\"-e\", \"cs-etm\"}, tmpfile.path));\n  std::unique_ptr<RecordFileReader> reader = RecordFileReader::CreateInstance(tmpfile.path);\n  ASSERT_TRUE(reader);\n\n  // cs-etm uses sample period instead of sample freq.\n  ASSERT_EQ(reader->AttrSection().size(), 1u);\n  const perf_event_attr* attr = reader->AttrSection()[0].attr;\n  ASSERT_EQ(attr->freq, 0);\n  ASSERT_EQ(attr->sample_period, 1);\n\n  bool has_auxtrace_info = false;\n  bool has_auxtrace = false;\n  bool has_aux = false;\n  ASSERT_TRUE(reader->ReadDataSection([&](std::unique_ptr<Record> r) {\n    if (r->type() == PERF_RECORD_AUXTRACE_INFO) {\n      has_auxtrace_info = true;\n    } else if (r->type() == PERF_RECORD_AUXTRACE) {\n      has_auxtrace = true;\n    } else if (r->type() == PERF_RECORD_AUX) {\n      has_aux = true;\n    }\n    return true;\n  }));\n  ASSERT_TRUE(has_auxtrace_info);\n  ASSERT_TRUE(has_auxtrace);\n  ASSERT_TRUE(has_aux);\n}\n\nTEST(record_cmd, aux_buffer_size_option) {\n  if (!ETMRecorder::GetInstance().CheckEtmSupport()) {\n    GTEST_LOG_(INFO) << \"Omit this test since etm isn't supported on this device\";\n    return;\n  }\n  ASSERT_TRUE(RunRecordCmd({\"-e\", \"cs-etm\", \"--aux-buffer-size\", \"1m\"}));\n  // not page size aligned\n  ASSERT_FALSE(RunRecordCmd({\"-e\", \"cs-etm\", \"--aux-buffer-size\", \"1024\"}));\n  // not power of two\n  ASSERT_FALSE(RunRecordCmd({\"-e\", \"cs-etm\", \"--aux-buffer-size\", \"12k\"}));\n}\n\nTEST(record_cmd, include_filter_option) {\n  TEST_REQUIRE_HW_COUNTER();\n  if (!ETMRecorder::GetInstance().CheckEtmSupport()) {\n    GTEST_LOG_(INFO) << \"Omit this test since etm isn't supported on this device\";\n    return;\n  }\n  FILE* fp = popen(\"which sleep\", \"r\");\n  ASSERT_TRUE(fp != nullptr);\n  std::string path;\n  ASSERT_TRUE(android::base::ReadFdToString(fileno(fp), &path));\n  pclose(fp);\n  path = android::base::Trim(path);\n  std::string sleep_exec_path;\n  ASSERT_TRUE(android::base::Realpath(path, &sleep_exec_path));\n  // --include-filter doesn't apply to cpu-cycles.\n  ASSERT_FALSE(RunRecordCmd({\"--include-filter\", sleep_exec_path}));\n  TemporaryFile record_file;\n  ASSERT_TRUE(\n      RunRecordCmd({\"-e\", \"cs-etm\", \"--include-filter\", sleep_exec_path}, record_file.path));\n  TemporaryFile inject_file;\n  ASSERT_TRUE(\n      CreateCommandInstance(\"inject\")->Run({\"-i\", record_file.path, \"-o\", inject_file.path}));\n  std::string data;\n  ASSERT_TRUE(android::base::ReadFileToString(inject_file.path, &data));\n  // Only instructions in sleep_exec_path are traced.\n  for (auto& line : android::base::Split(data, \"\\n\")) {\n    if (android::base::StartsWith(line, \"dso \")) {\n      std::string dso = line.substr(strlen(\"dso \"), sleep_exec_path.size());\n      ASSERT_EQ(dso, sleep_exec_path);\n    }\n  }\n}\n\nTEST(record_cmd, pmu_event_option) {\n  TEST_REQUIRE_PMU_COUNTER();\n  TEST_REQUIRE_HW_COUNTER();\n  std::string event_string;\n  if (GetBuildArch() == ARCH_X86_64) {\n    event_string = \"cpu/cpu-cycles/\";\n  } else if (GetBuildArch() == ARCH_ARM64) {\n    event_string = \"armv8_pmuv3/cpu_cycles/\";\n  } else {\n    GTEST_LOG_(INFO) << \"Omit arch \" << GetBuildArch();\n    return;\n  }\n  TEST_IN_ROOT(ASSERT_TRUE(RunRecordCmd({\"-e\", event_string})));\n}\n\nTEST(record_cmd, exclude_perf_option) {\n  ASSERT_TRUE(RunRecordCmd({\"--exclude-perf\"}));\n  if (IsRoot()) {\n    TemporaryFile tmpfile;\n    ASSERT_TRUE(RecordCmd()->Run(\n        {\"-a\", \"--exclude-perf\", \"--duration\", \"1\", \"-e\", GetDefaultEvent(), \"-o\", tmpfile.path}));\n    std::unique_ptr<RecordFileReader> reader = RecordFileReader::CreateInstance(tmpfile.path);\n    ASSERT_TRUE(reader);\n    pid_t perf_pid = getpid();\n    ASSERT_TRUE(reader->ReadDataSection([&](std::unique_ptr<Record> r) {\n      if (r->type() == PERF_RECORD_SAMPLE) {\n        if (static_cast<SampleRecord*>(r.get())->tid_data.pid == perf_pid) {\n          return false;\n        }\n      }\n      return true;\n    }));\n  }\n}",
        "b_contents": "}",
        "base_contents": "}",
        "res_region": "}\n\nTEST(record_cmd, record_java_app) {\n#if defined(__ANDROID__)\n  RecordingAppHelper helper;\n  // 1. Install apk.\n  ASSERT_TRUE(helper.InstallApk(GetTestData(\"DisplayBitmaps.apk\"),\n                                \"com.example.android.displayingbitmaps\"));\n  ASSERT_TRUE(helper.InstallApk(GetTestData(\"DisplayBitmapsTest.apk\"),\n                                \"com.example.android.displayingbitmaps.test\"));\n\n  // 2. Start the app.\n  ASSERT_TRUE(\n      helper.StartApp(\"am instrument -w -r -e debug false -e class \"\n                      \"com.example.android.displayingbitmaps.tests.GridViewTest \"\n                      \"com.example.android.displayingbitmaps.test/\"\n                      \"androidx.test.runner.AndroidJUnitRunner\"));\n\n  // 3. Record perf.data.\n  SetRunInAppToolForTesting(true, true);\n  ASSERT_TRUE(helper.RecordData(\n      \"-e cpu-clock --app com.example.android.displayingbitmaps -g --duration 10\"));\n\n  // 4. Check perf.data.\n  auto process_symbol = [&](const char* name) {\n#if !defined(IN_CTS_TEST)\n    const char* expected_name_with_keyguard = \"androidx.test.runner\";  // when screen is locked\n    if (strstr(name, expected_name_with_keyguard) != nullptr) {\n      return true;\n    }\n#endif\n    const char* expected_name = \"androidx.test.espresso\";  // when screen stays awake\n    return strstr(name, expected_name) != nullptr;\n  };\n  ASSERT_TRUE(helper.CheckData(process_symbol));\n#else\n  GTEST_LOG_(INFO) << \"This test tests a function only available on Android.\";\n#endif\n}\n\nTEST(record_cmd, record_native_app) {\n#if defined(__ANDROID__)\n  // In case of non-native ABI guest symbols are never directly executed, thus\n  // don't appear in perf.data. Instead binary translator executes code\n  // translated from guest at runtime.\n  OMIT_TEST_ON_NON_NATIVE_ABIS();\n\n  RecordingAppHelper helper;\n  // 1. Install apk.\n  ASSERT_TRUE(helper.InstallApk(GetTestData(\"EndlessTunnel.apk\"), \"com.google.sample.tunnel\"));\n\n  // 2. Start the app.\n  ASSERT_TRUE(\n      helper.StartApp(\"am start -n com.google.sample.tunnel/android.app.NativeActivity -a \"\n                      \"android.intent.action.MAIN -c android.intent.category.LAUNCHER\"));\n\n  // 3. Record perf.data.\n  SetRunInAppToolForTesting(true, true);\n  ASSERT_TRUE(helper.RecordData(\"-e cpu-clock --app com.google.sample.tunnel -g --duration 10\"));\n\n  // 4. Check perf.data.\n  auto process_symbol = [&](const char* name) {\n    const char* expected_name_with_keyguard = \"NativeActivity\";  // when screen is locked\n    if (strstr(name, expected_name_with_keyguard) != nullptr) {\n      return true;\n    }\n    const char* expected_name = \"PlayScene::DoFrame\";  // when screen is awake\n    return strstr(name, expected_name) != nullptr;\n  };\n  ASSERT_TRUE(helper.CheckData(process_symbol));\n#else\n  GTEST_LOG_(INFO) << \"This test tests a function only available on Android.\";\n#endif\n}\n\nTEST(record_cmd, no_cut_samples_option) {\n  ASSERT_TRUE(RunRecordCmd({\"--no-cut-samples\"}));\n}\n\nTEST(record_cmd, cs_etm_event) {\n  if (!ETMRecorder::GetInstance().CheckEtmSupport()) {\n    GTEST_LOG_(INFO) << \"Omit this test since etm isn't supported on this device\";\n    return;\n  }\n  TemporaryFile tmpfile;\n  ASSERT_TRUE(RunRecordCmd({\"-e\", \"cs-etm\"}, tmpfile.path));\n  std::unique_ptr<RecordFileReader> reader = RecordFileReader::CreateInstance(tmpfile.path);\n  ASSERT_TRUE(reader);\n\n  // cs-etm uses sample period instead of sample freq.\n  ASSERT_EQ(reader->AttrSection().size(), 1u);\n  const perf_event_attr* attr = reader->AttrSection()[0].attr;\n  ASSERT_EQ(attr->freq, 0);\n  ASSERT_EQ(attr->sample_period, 1);\n\n  bool has_auxtrace_info = false;\n  bool has_auxtrace = false;\n  bool has_aux = false;\n  ASSERT_TRUE(reader->ReadDataSection([&](std::unique_ptr<Record> r) {\n    if (r->type() == PERF_RECORD_AUXTRACE_INFO) {\n      has_auxtrace_info = true;\n    } else if (r->type() == PERF_RECORD_AUXTRACE) {\n      has_auxtrace = true;\n    } else if (r->type() == PERF_RECORD_AUX) {\n      has_aux = true;\n    }\n    return true;\n  }));\n  ASSERT_TRUE(has_auxtrace_info);\n  ASSERT_TRUE(has_auxtrace);\n  ASSERT_TRUE(has_aux);\n}\n\nTEST(record_cmd, aux_buffer_size_option) {\n  if (!ETMRecorder::GetInstance().CheckEtmSupport()) {\n    GTEST_LOG_(INFO) << \"Omit this test since etm isn't supported on this device\";\n    return;\n  }\n  ASSERT_TRUE(RunRecordCmd({\"-e\", \"cs-etm\", \"--aux-buffer-size\", \"1m\"}));\n  // not page size aligned\n  ASSERT_FALSE(RunRecordCmd({\"-e\", \"cs-etm\", \"--aux-buffer-size\", \"1024\"}));\n  // not power of two\n  ASSERT_FALSE(RunRecordCmd({\"-e\", \"cs-etm\", \"--aux-buffer-size\", \"12k\"}));\n}\n\nTEST(record_cmd, include_filter_option) {\n  TEST_REQUIRE_HW_COUNTER();\n  if (!ETMRecorder::GetInstance().CheckEtmSupport()) {\n    GTEST_LOG_(INFO) << \"Omit this test since etm isn't supported on this device\";\n    return;\n  }\n  FILE* fp = popen(\"which sleep\", \"r\");\n  ASSERT_TRUE(fp != nullptr);\n  std::string path;\n  ASSERT_TRUE(android::base::ReadFdToString(fileno(fp), &path));\n  pclose(fp);\n  path = android::base::Trim(path);\n  std::string sleep_exec_path;\n  ASSERT_TRUE(android::base::Realpath(path, &sleep_exec_path));\n  // --include-filter doesn't apply to cpu-cycles.\n  ASSERT_FALSE(RunRecordCmd({\"--include-filter\", sleep_exec_path}));\n  TemporaryFile record_file;\n  ASSERT_TRUE(\n      RunRecordCmd({\"-e\", \"cs-etm\", \"--include-filter\", sleep_exec_path}, record_file.path));\n  TemporaryFile inject_file;\n  ASSERT_TRUE(\n      CreateCommandInstance(\"inject\")->Run({\"-i\", record_file.path, \"-o\", inject_file.path}));\n  std::string data;\n  ASSERT_TRUE(android::base::ReadFileToString(inject_file.path, &data));\n  // Only instructions in sleep_exec_path are traced.\n  for (auto& line : android::base::Split(data, \"\\n\")) {\n    if (android::base::StartsWith(line, \"dso \")) {\n      std::string dso = line.substr(strlen(\"dso \"), sleep_exec_path.size());\n      ASSERT_EQ(dso, sleep_exec_path);\n    }\n  }\n}\n\nTEST(record_cmd, pmu_event_option) {\n  TEST_REQUIRE_PMU_COUNTER();\n  TEST_REQUIRE_HW_COUNTER();\n  std::string event_string;\n  if (GetBuildArch() == ARCH_X86_64) {\n    event_string = \"cpu/cpu-cycles/\";\n  } else if (GetBuildArch() == ARCH_ARM64) {\n    event_string = \"armv8_pmuv3/cpu_cycles/\";\n  } else {\n    GTEST_LOG_(INFO) << \"Omit arch \" << GetBuildArch();\n    return;\n  }\n  TEST_IN_ROOT(ASSERT_TRUE(RunRecordCmd({\"-e\", event_string})));\n}\n\nTEST(record_cmd, exclude_perf_option) {\n  ASSERT_TRUE(RunRecordCmd({\"--exclude-perf\"}));\n  if (IsRoot()) {\n    TemporaryFile tmpfile;\n    ASSERT_TRUE(RecordCmd()->Run(\n        {\"-a\", \"--exclude-perf\", \"--duration\", \"1\", \"-e\", GetDefaultEvent(), \"-o\", tmpfile.path}));\n    std::unique_ptr<RecordFileReader> reader = RecordFileReader::CreateInstance(tmpfile.path);\n    ASSERT_TRUE(reader);\n    pid_t perf_pid = getpid();\n    ASSERT_TRUE(reader->ReadDataSection([&](std::unique_ptr<Record> r) {\n      if (r->type() == PERF_RECORD_SAMPLE) {\n        if (static_cast<SampleRecord*>(r.get())->tid_data.pid == perf_pid) {\n          return false;\n        }\n      }\n      return true;\n    }));\n  }\n}",
        "lookback": "",
        "lookahead": "",
        "label": [
            "ours",
            "base_underutilized"
        ],
        "start_line": 833,
        "end_line": 1030,
        "merge_gen_region": "(__,__)if(____)ingHelper; 1 Installk ASSERTTRUEhelperInstallk ASSERTTRUEhelperInstallk(Test(\"Displays.k\"),comexampleandroiddisplaybitmap\")); ASSERTTRUEhelperInstallk(TestDataDisplaysTestap\"),comexampleandroiddisplaybitmap.\")); 2 Start app ASSERTTRUE helperStart(\" instrumentwre falsee \"....ingdisplay instrumentwre falsee \"....ingdisplaybitmap....View \"comexampleandroiddisplaybitmap./\"andidxtestrunnerAndroidUnit\")); 3 Record.......RunAppForTestingtrue true ASSERTTRUEhelperRecord(e cpuclockapp....ingdisplaybitmap - --duration\")); 4. perfdata auto_ =const*) # !(___) const*____guard \"andidxtestrunner // screen locked ((,______guard !=) return; # const*_ = \"ro....press\"; when st a return(,_) nullptr };_(helperCheck(_));else__() \" test a only on.\";endif TESTrecordcmd recordnativeapp {if(____) In of- ABI symbols never executed thus don",
        "confidence": 0.9625794887542725,
        "hesitated": false,
        "resolved": false
    }
]