[
    {
        "a_contents": "bool EventSelectionSet::EnableETMEvents() {\n  for (auto& group : groups_) {\n    for (auto& sel : group.selections) {\n      if (!sel.event_type_modifier.event_type.IsEtmEvent()) {\n        continue;\n      }\n      for (auto& fd : sel.event_fds) {\n        if (!fd->SetEnableEvent(true)) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\nbool EventSelectionSet::DisableETMEvents() {\n  for (auto& group : groups_) {\n    for (auto& sel : group.selections) {\n      if (!sel.event_type_modifier.event_type.IsEtmEvent()) {\n        continue;\n      }\n      // When using ETR, ETM data is flushed to the aux buffer of the last cpu disabling ETM events.\n      // To avoid overflowing the aux buffer for one cpu, rotate the last cpu disabling ETM events.\n      if (etm_event_cpus_.empty()) {\n        for (const auto& fd : sel.event_fds) {\n          etm_event_cpus_.insert(fd->Cpu());\n        }\n        if (etm_event_cpus_.empty()) {\n          continue;\n        }\n        etm_event_cpus_it_ = etm_event_cpus_.begin();\n      }\n      int last_disabled_cpu = *etm_event_cpus_it_;\n      if (++etm_event_cpus_it_ == etm_event_cpus_.end()) {\n        etm_event_cpus_it_ = etm_event_cpus_.begin();\n      }\n\n      for (auto& fd : sel.event_fds) {\n        if (fd->Cpu() != last_disabled_cpu) {\n          if (!fd->SetEnableEvent(false)) {\n            return false;\n          }\n        }\n      }\n      for (auto& fd : sel.event_fds) {\n        if (fd->Cpu() == last_disabled_cpu) {\n          if (!fd->SetEnableEvent(false)) {\n            return false;\n          }\n        }\n      }\n    }\n  }\n  return true;\n}\n",
        "b_contents": "bool EventSelectionSet::EnableETMEvents() {\n  for (auto& group : groups_) {\n    for (auto& sel : group.selections) {\n      if (!sel.event_type_modifier.event_type.IsEtmEvent()) {\n        continue;\n      }\n      for (auto& fd : sel.event_fds) {\n        if (!fd->SetEnableEvent(true)) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\nbool EventSelectionSet::DisableETMEvents() {\n  for (auto& group : groups_) {\n    for (auto& sel : group.selections) {\n      if (!sel.event_type_modifier.event_type.IsEtmEvent()) {\n        continue;\n      }\n      for (auto& fd : sel.event_fds) {\n        if (!fd->SetEnableEvent(false)) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n",
        "base_contents": "",
        "res_region": "bool EventSelectionSet::EnableETMEvents() {\n  for (auto& group : groups_) {\n    for (auto& sel : group.selections) {\n      if (!sel.event_type_modifier.event_type.IsEtmEvent()) {\n        continue;\n      }\n      for (auto& fd : sel.event_fds) {\n        if (!fd->SetEnableEvent(true)) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\nbool EventSelectionSet::DisableETMEvents() {\n  for (auto& group : groups_) {\n    for (auto& sel : group.selections) {\n      if (!sel.event_type_modifier.event_type.IsEtmEvent()) {\n        continue;\n      }\n      // When using ETR, ETM data is flushed to the aux buffer of the last cpu disabling ETM events.\n      // To avoid overflowing the aux buffer for one cpu, rotate the last cpu disabling ETM events.\n      if (etm_event_cpus_.empty()) {\n        for (const auto& fd : sel.event_fds) {\n          etm_event_cpus_.insert(fd->Cpu());\n        }\n        if (etm_event_cpus_.empty()) {\n          continue;\n        }\n        etm_event_cpus_it_ = etm_event_cpus_.begin();\n      }\n      int last_disabled_cpu = *etm_event_cpus_it_;\n      if (++etm_event_cpus_it_ == etm_event_cpus_.end()) {\n        etm_event_cpus_it_ = etm_event_cpus_.begin();\n      }\n\n      for (auto& fd : sel.event_fds) {\n        if (fd->Cpu() != last_disabled_cpu) {\n          if (!fd->SetEnableEvent(false)) {\n            return false;\n          }\n        }\n      }\n      for (auto& fd : sel.event_fds) {\n        if (fd->Cpu() == last_disabled_cpu) {\n          if (!fd->SetEnableEvent(false)) {\n            return false;\n          }\n        }\n      }\n    }\n  }\n  return true;\n}\n",
        "lookback": "  for (auto& group : groups_) {",
        "lookahead": "}  // namespace simpleperf",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 954,
        "end_line": 1046,
        "merge_gen_region": " (& : groups { EventSetEnableMEs { (& : groups { (& :.s) ifseleventeventtypemodifiereventtypeIstm()) continue } forauto fd seleventfds { (!->Enable()) return; } } } return; boolSelectionSetDisableMEs { (& :_) forauto sel groupselection) ifseleventeventtypemodifiereventtypeIstm()) continue }; // usingTR E,TM is flushed the aux of last disablingTM. To overflow the aux for cpu rotate last disablingTM. (meventcpusempty { ( auto fd seleventfds {meventcpusinsertfdCpu } ifet____.()) continue }meventcpusit =meventcpusbegin } lastdisabledcpu *et_____; (++meventcpusit ==meventcpusend {meventcpusit =meventcpusbegin } forauto fd seleventfds { (->() lastdisabledcpu { (!->Enable()) return; } } } return; }",
        "confidence": 0.9092165231704712,
        "hesitated": false,
        "resolved": false
    }
]