[
    {
        "a_contents": "",
        "b_contents": "#define MAX_STRCAT_DST_SIZE       32\n\nconst int kStringAligns[][4] = {\n  // All zeroes to use the values returned from malloc.\n  { 0, 0, 0, 0 },\n\n  { 1, 0, 1, 0 },\n  { 2, 0, 2, 0 },\n  { 4, 0, 4, 0 },\n  { 8, 0, 8, 0 },\n\n  { 8, 0, 4, 0 },\n  { 4, 0, 8, 0 },\n\n  { 8, 0, 8, 1 },\n  { 8, 0, 8, 2 },\n  { 8, 0, 8, 3 },\n  { 8, 1, 8, 0 },\n  { 8, 2, 8, 0 },\n  { 8, 3, 8, 0 },\n\n  { 4, 0, 4, 1 },\n  { 4, 0, 4, 2 },\n  { 4, 0, 4, 3 },\n  { 4, 1, 4, 0 },\n  { 4, 2, 4, 0 },\n  { 4, 3, 4, 0 },\n};\n\n#define STRING_ALIGN_LEN  (sizeof(kStringAligns)/sizeof(int[4]))\n",
        "base_contents": "#define MAX_STRLEN_TEST_SIZE      1024\n#define MAX_STRLEN_BUFFER_SIZE    (3 * MAX_STRLEN_TEST_SIZE)\n",
        "res_region": "",
        "lookback": "void *getAlignedPtr(void *orig_ptr, int alignment, int or_mask) {",
        "lookahead": "// Return a pointer into the current string with the specified alignment.",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 36,
        "end_line": 73,
        "merge_gen_region": null,
        "confidence": 0.5960334539413452,
        "hesitated": true
    },
    {
        "a_contents": "",
        "b_contents": "bool doStrlenCheck(size_t size, char *string, int align, int or_mask,\n                   size_t (*test_strlen)(const char *), bool verbose) {\n  char *aligned_string = reinterpret_cast<char*>(getAlignedPtr(string, align, or_mask));\n  size_t len;\n  if (verbose) {\n    printf(\"Testing size %d, align=%p[%d,%d]\\n\", size, aligned_string, align, or_mask);\n  }\n\n  aligned_string[size] = '\\0';\n  len = test_strlen(aligned_string);\n  if (len != size) {\n    printf(\"Failed at size %d, length returned %u, align=%p[%d,%d]\\n\",\n           size, len, aligned_string, align, or_mask);\n    return false;\n  }\n\n  if (verbose) {\n    printf(\"Testing size %d with extra zeros after string, align=%p[%d,%d]\\n\",\n           size, aligned_string, align, or_mask);\n  }\n\n  for (size_t j = size+1; j <= size+16; j++) {\n    aligned_string[j] = '\\0';\n  }\n\n  len = test_strlen(aligned_string);\n  if (len != size) {\n    printf(\"Failed at size %d, length returned %u with zeroes after string, align=%p[%d,%d]\\n\",\n           size, len, aligned_string, align, or_mask);\n    return false;\n  }\n\n  for (size_t j = size; j <= size+16; j++) {\n    aligned_string[j] = (char)(32 + (j % 96));\n  }\n  return true;\n}\n\nbool runStrlenTest(size_t (*test_strlen)(const char *),\n                   bool verbose) {\n  char *string = allocateString();\n  if (string == NULL) {\n    perror(\"Unable to allocate memory.\\n\");\n    return false;\n  }\n\n  // Check different string alignments. All zeroes indicates that the\n  // unmodified malloc values should be used.\n  const int aligns[][2] = {\n    // All zeroes to use the values returned from malloc.\n    { 0, 0 },\n\n    { 1, 0 },\n    { 2, 0 },\n    { 4, 0 },\n    { 8, 0 },\n    { 16, 0 },\n    { 32, 0 },\n\n    { 8, 1 },\n    { 8, 2 },\n    { 8, 3 },\n\n    { 4, 1 },\n    { 4, 2 },\n    { 4, 3 },\n  };\n\n  printf(\"  Verifying string lengths at different alignments.\\n\");\n  for (size_t i = 0; i < sizeof(aligns)/sizeof(int[2]); i++) {\n    for (size_t j = 0; j <= MAX_STRING_TEST_SIZE; j++) {\n      if (!doStrlenCheck(j, string, aligns[i][0], aligns[i][1], test_strlen, verbose)) {\n        return false;\n      }\n    }\n  }\n\n  printf(\"  Verifying strlen does not read past end of string.\\n\");\n\n  // In order to verify that strlen is not reading past the end of the\n  // string, create strings that end near unreadable memory.\n  long pagesize = sysconf(_SC_PAGE_SIZE);\n  char *memory = (char*)memalign(pagesize, 2 * pagesize);\n  if (memory == NULL) {\n    perror(\"Unable to allocate memory.\\n\");\n    return false;\n  }\n\n  // Make the second page unreadable and unwritable.\n  if (mprotect(&memory[pagesize], pagesize, PROT_NONE) != 0) {\n    perror(\"Unable to set protection of page.\\n\");\n    return false;\n  }\n\n  size_t max_size = pagesize < MAX_STRING_TEST_SIZE ? pagesize-1 : MAX_STRING_TEST_SIZE;\n  for (long i = 0; i < pagesize; i++) {\n    memory[i] = (char)(32 + (i % 96));\n  }\n\n  size_t len;\n  for (size_t i = 0; i < sizeof(aligns)/sizeof(int[2]); i++) {\n    for (size_t j = 0; j <= max_size; j++) {\n      string = &memory[pagesize-j-1];\n      string[j] = '\\0';\n\n      if (verbose) {\n        printf(\"Testing size %d overread, align=%p[%d,%d]\\n\",\n               j, string, aligns[i][0], aligns[i][1]);\n      }\n      len = test_strlen(string);\n      if (len != j) {\n        printf(\"    Failed at size %u, returned %u, align=%p[%d,%d]\\n\",\n               j, len, string, aligns[i][0], aligns[i][1]);\n        return false;\n      }\n      string[j] = (char)(32 + (j % 96));\n    }\n  }\n\n  printf(\"  All tests pass.\\n\");\n\n  return true;\n}\n\nbool runStrcpyTest(char *(*test_strcpy)(char *, const char *),\n                   bool verbose) {\n  char *src = allocateString();\n  if (src == NULL) {\n    perror(\"Unable to allocate memory.\\n\");\n    return false;\n  }\n  char *dst = allocateString();\n  if (dst == NULL) {\n    perror(\"Unable to allocate memory.\\n\");\n    return false;\n  }\n\n  printf(\"  Verifying string lengths at different alignments.\\n\");\n  char *src_align;\n  char *dst_align;\n  char *dst_ret;\n  for (size_t i = 0; i < STRING_ALIGN_LEN; i++) {\n    for (size_t copy_len = 0; copy_len <= MAX_STRING_TEST_SIZE; copy_len++) {\n      if (kStringAligns[i][0]) {\n        src_align = reinterpret_cast<char*>(getAlignedPtr(src+FENCEPOST_LENGTH, kStringAligns[i][0], kStringAligns[i][1]));\n        dst_align = reinterpret_cast<char*>(getAlignedPtr(dst+FENCEPOST_LENGTH, kStringAligns[i][2], kStringAligns[i][3]));\n      } else {\n        src_align = src;\n        dst_align = dst;\n      }\n      setString(src_align, copy_len);\n      memset(dst_align, 0, copy_len+1);\n\n      if (dst_align != dst) {\n        setFencepost(reinterpret_cast<uint8_t*>(&dst_align[-FENCEPOST_LENGTH]));\n      }\n      setFencepost(reinterpret_cast<uint8_t*>(&dst_align[copy_len+1]));\n\n      if (verbose) {\n        printf(\"Testing copy_len %u, src_align=%p[%d,%d], dst_align=%p[%d,%d]\\n\",\n               copy_len, src_align, kStringAligns[i][0], kStringAligns[i][1],\n               dst_align, kStringAligns[i][2], kStringAligns[i][3]);\n      }\n\n      dst_ret = test_strcpy(dst_align, src_align);\n      if (dst_ret != dst_align) {\n        printf(\"copy_len %u returned incorrect value: expected %p, got %p\\n\",\n               copy_len, dst_align, dst_ret);\n        return false;\n      }\n      if (memcmp(src_align, dst_align, copy_len) != 0) {\n        printf(\"copy_len %u failed to copy properly: src and dst aren't equal\\n\", copy_len);\n        return false;\n      }\n\n      if (dst_align != dst && !verifyFencepost(reinterpret_cast<uint8_t*>(&dst_align[-FENCEPOST_LENGTH]))) {\n        printf(\"copy_len %u fencepost before dst was overwritten\\n\", copy_len);\n        return false;\n      }\n\n      if (!verifyFencepost(reinterpret_cast<uint8_t*>(&dst_align[copy_len+1]))) {\n        printf(\"copy_len %u fencepost at end of dst was overwritten\\n\", copy_len);\n        return false;\n      }\n    }\n  }\n\n  printf(\"  All tests pass.\\n\");\n\n  return true;\n}\n\nbool runStrcatTest(char *(*test_strcat)(char *, const char *),\n                   bool verbose) {\n  char *src = allocateString();\n  if (src == NULL) {\n    perror(\"Unable to allocate memory.\\n\");\n    return false;\n  }\n  char *dst = allocateString();\n  if (dst == NULL) {\n    perror(\"Unable to allocate memory.\\n\");\n    return false;\n  }\n\n  printf(\"  Verifying string lengths at different alignments.\\n\");\n  char *src_align;\n  char *dst_align;\n  char *dst_ret;\n  for (size_t i = 0; i < STRING_ALIGN_LEN; i++) {\n    for (size_t dst_len = 0; dst_len <= MAX_STRCAT_DST_SIZE; dst_len++) {\n      for (size_t copy_len = 0; copy_len <= MAX_STRING_TEST_SIZE; copy_len++) {\n        if (kStringAligns[i][0]) {\n          src_align = reinterpret_cast<char*>(getAlignedPtr(src+FENCEPOST_LENGTH, kStringAligns[i][0], kStringAligns[i][1]));\n          dst_align = reinterpret_cast<char*>(getAlignedPtr(dst+FENCEPOST_LENGTH, kStringAligns[i][2], kStringAligns[i][3]));\n        } else {\n          src_align = src;\n          dst_align = dst;\n        }\n        setString(src_align, copy_len);\n        memset(dst_align, 'd', dst_len);\n        memset(dst_align+dst_len, 0, copy_len+1);\n\n        if (dst_align != dst) {\n          setFencepost(reinterpret_cast<uint8_t*>(&dst_align[-FENCEPOST_LENGTH]));\n        }\n        setFencepost(reinterpret_cast<uint8_t*>(&dst_align[copy_len+dst_len+1]));\n\n        if (verbose) {\n          printf(\"Testing copy_len %u, dst_len %u, src_align=%p[%d,%d], dst_align=%p[%d,%d]\\n\",\n                 copy_len, dst_len, src_align, kStringAligns[i][0], kStringAligns[i][1],\n                 dst_align, kStringAligns[i][2], kStringAligns[i][3]);\n        }\n\n        dst_ret = test_strcat(dst_align, src_align);\n        if (dst_ret != dst_align) {\n          printf(\"dst_len %u, copy_len %u returned incorrect value: expected %p, got %p\\n\",\n                dst_len, copy_len, dst_align, dst_ret);\n          return false;\n        }\n        for (size_t j = 0; j < dst_len; j++) {\n          if (dst_align[j] != 'd') {\n            printf(\"dst_len %u, copy_len %u: strcat overwrote dst string\\n\",\n                   dst_len, copy_len);\n            return false;\n          }\n        }\n        if (memcmp(src_align, dst_align+dst_len, copy_len+1) != 0) {\n          printf(\"dst_len %u, copy_len %u failed to copy properly: src and dst aren't equal\\n\",\n                 dst_len, copy_len);\n          return false;\n        }\n\n        if (dst_align != dst && !verifyFencepost(reinterpret_cast<uint8_t*>(&dst_align[-FENCEPOST_LENGTH]))) {\n          return false;\n        }\n\n        if (!verifyFencepost(reinterpret_cast<uint8_t*>(&dst_align[dst_len+copy_len+1]))) {\n          return false;\n        }\n      }\n    }\n  }\n\n  printf(\"  All tests pass.\\n\");\n\n  return true;\n}\n",
        "base_contents": "bool doStrlenCheck(size_t size, char *string, int align, int or_mask,\n                   size_t (*test_strlen)(const char *), bool verbose) {\n  char *aligned_string = reinterpret_cast<char*>(getAlignedPtr(string, align, or_mask));\n  size_t len;\n  if (verbose) {\n    printf(\"Testing size %d, align=%p[%d,%d]\\n\", size, aligned_string, align, or_mask);\n  }\n\n  aligned_string[size] = '\\0';\n  len = test_strlen(aligned_string);\n  if (len != size) {\n    printf(\"Failed at size %d, length returned %u, align=%p[%d,%d]\\n\",\n           size, len, aligned_string, align, or_mask);\n    return false;\n  }\n\n  if (verbose) {\n    printf(\"Testing size %d with extra zeros after string, align=%p[%d,%d]\\n\",\n           size, aligned_string, align, or_mask);\n  }\n\n  for (size_t j = size+1; j <= size+16; j++) {\n    aligned_string[j] = '\\0';\n  }\n\n  len = test_strlen(aligned_string);\n  if (len != size) {\n    printf(\"Failed at size %d, length returned %u with zeroes after string, align=%p[%d,%d]\\n\",\n           size, len, aligned_string, align, or_mask);\n    return false;\n  }\n\n  for (size_t j = size; j <= size+16; j++) {\n    aligned_string[j] = (char)(32 + (j % 96));\n  }\n  return true;\n}\n\nbool runStrlenTest(size_t (*test_strlen)(const char *),\n                   bool verbose) {\n  // Allocate two large buffers to hold the two strings.\n  char *string = reinterpret_cast<char*>(malloc(MAX_STRLEN_BUFFER_SIZE+1));\n  if (string == NULL) {\n    perror(\"Unable to allocate memory.\\n\");\n    return false;\n  }\n\n  // Initialize the strings to be exactly the same.\n  for (int i = 0; i < MAX_STRLEN_BUFFER_SIZE; i++) {\n    string[i] = (char)(32 + (i % 96));\n  }\n  string[MAX_STRLEN_BUFFER_SIZE] = '\\0';\n\n  // Check different string alignments. All zeroes indicates that the\n  // unmodified malloc values should be used.\n  int aligns[][2] = {\n    // All zeroes to use the values returned from malloc.\n    { 0, 0 },\n\n    { 1, 0 },\n    { 2, 0 },\n    { 4, 0 },\n    { 8, 0 },\n    { 16, 0 },\n    { 32, 0 },\n\n    { 8, 1 },\n    { 8, 2 },\n    { 8, 3 },\n\n    { 4, 1 },\n    { 4, 2 },\n    { 4, 3 },\n  };\n\n  printf(\"  Verifying string lengths at different alignments.\\n\");\n  for (size_t i = 0; i < sizeof(aligns)/sizeof(int[2]); i++) {\n    for (size_t j = 0; j <= MAX_STRLEN_TEST_SIZE; j++) {\n      if (!doStrlenCheck(j, string, aligns[i][0], aligns[i][1], test_strlen, verbose)) {\n        return false;\n      }\n    }\n  }\n\n  printf(\"  Verifying strlen does not read past end of string.\\n\");\n\n  // In order to verify that strlen is not reading past the end of the\n  // string, create strings that end near unreadable memory.\n  long pagesize = sysconf(_SC_PAGE_SIZE);\n  char *memory = (char*)memalign(pagesize, 2 * pagesize);\n  if (memory == NULL) {\n    perror(\"Unable to allocate memory.\\n\");\n    return false;\n  }\n\n  // Make the second page unreadable and unwritable.\n  if (mprotect(&memory[pagesize], pagesize, PROT_NONE) != 0) {\n    perror(\"Unable to set protection of page.\\n\");\n    return false;\n  }\n\n  size_t max_size = pagesize < MAX_STRLEN_TEST_SIZE ? pagesize-1 : MAX_STRLEN_TEST_SIZE;\n  for (long i = 0; i < pagesize; i++) {\n    memory[i] = (char)(32 + (i % 96));\n  }\n\n  size_t len;\n  for (size_t i = 0; i < sizeof(aligns)/sizeof(int[2]); i++) {\n    for (size_t j = 0; j <= max_size; j++) {\n      string = &memory[pagesize-j-1];\n      string[j] = '\\0';\n\n      if (verbose) {\n        printf(\"Testing size %d overread, align=%p[%d,%d]\\n\",\n               j, string, aligns[i][0], aligns[i][1]);\n      }\n      len = test_strlen(string);\n      if (len != j) {\n        printf(\"    Failed at size %u, returned %u, align=%p[%d,%d]\\n\",\n               j, len, string, aligns[i][0], aligns[i][1]);\n        return false;\n      }\n      string[j] = (char)(32 + (j % 96));\n    }\n  }\n\n  printf(\"  All tests pass.\\n\");\n\n  return true;\n}\n",
        "res_region": "",
        "lookback": "                   bool verbose) {",
        "lookahead": "bool runMemcpyTest(void* (*test_memcpy)(void *dst, const void *src, size_t n),",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 367,
        "end_line": 770,
        "merge_gen_region": null,
        "confidence": 0.7141997814178467,
        "hesitated": true
    },
    {
        "a_contents": "",
        "b_contents": "  printf(\"Testing strlen...\\n\");\n  tests_passing = runStrlenTest(strlen, verbose) && tests_passing;\n\n  printf(\"Testing strcpy...\\n\");\n  tests_passing = runStrcpyTest(strcpy, verbose) && tests_passing;\n\n  printf(\"Testing strcat...\\n\");\n  tests_passing = runStrcatTest(strcat, verbose) && tests_passing;\n",
        "base_contents": "  printf(\"Testing strlen...\\n\");\n  tests_passing = runStrlenTest(strlen, verbose) && tests_passing;\n",
        "res_region": "",
        "lookback": "}",
        "lookahead": "  return (tests_passing ? 0 : 1);",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 1018,
        "end_line": 1033,
        "merge_gen_region": "",
        "confidence": 0.9061210751533508,
        "hesitated": false,
        "resolved": true
    }
]