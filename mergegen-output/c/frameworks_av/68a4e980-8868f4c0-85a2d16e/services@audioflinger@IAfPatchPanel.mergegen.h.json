[
    {
        "a_contents": "/*\n * Copyright (C) 2023 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#pragma once\n\n// The following includes are required because we have class definitions below\n// for EndPoint and Patch, which precludes using a forward declaration only.\n#include \"IAfThread.h\"  // IAfThreadBase IAfMmapThread IAfPlaybackThread IAfRecordThread\n#include \"IAfTrack.h\"   // IAfPatchRecord IAfPatchTrack\n\n#include <datapath/AudioHwDevice.h>\n#include <media/DeviceDescriptorBase.h>\n#include <utils/Log.h>      // ALOG used in this file\n#include <utils/RefBase.h>  // avoid transitive dependency\n#include <utils/Thread.h>\n\nnamespace android {\n\nclass IAfPatchPanel;\nclass PatchCommandThread;\n\nclass SoftwarePatch {\npublic:\n    SoftwarePatch(\n            const sp<const IAfPatchPanel>& patchPanel,\n            audio_patch_handle_t patchHandle,\n            audio_io_handle_t playbackThreadHandle,\n            audio_io_handle_t recordThreadHandle)\n        : mPatchPanel(patchPanel),\n          mPatchHandle(patchHandle),\n          mPlaybackThreadHandle(playbackThreadHandle),\n          mRecordThreadHandle(recordThreadHandle) {}\n    SoftwarePatch(const SoftwarePatch&) = default;\n\n    // Must be called under AudioFlinger::mLock\n    status_t getLatencyMs_l(double* latencyMs) const;\n    audio_patch_handle_t getPatchHandle() const { return mPatchHandle; };\n    audio_io_handle_t getPlaybackThreadHandle() const { return mPlaybackThreadHandle; };\n    audio_io_handle_t getRecordThreadHandle() const { return mRecordThreadHandle; };\n\nprivate:\n    const sp<const IAfPatchPanel> mPatchPanel;\n    const audio_patch_handle_t mPatchHandle;\n    const audio_io_handle_t mPlaybackThreadHandle;\n    const audio_io_handle_t mRecordThreadHandle;\n};\n\nclass IAfPatchPanelCallback : public virtual RefBase {\npublic:\n    virtual void closeThreadInternal_l(const sp<IAfPlaybackThread>& thread) = 0;\n    virtual void closeThreadInternal_l(const sp<IAfRecordThread>& thread) = 0;\n    virtual IAfPlaybackThread* primaryPlaybackThread_l() const = 0;\n    virtual IAfPlaybackThread* checkPlaybackThread_l(audio_io_handle_t output) const = 0;\n    virtual IAfRecordThread* checkRecordThread_l(audio_io_handle_t input) const = 0;\n    virtual IAfMmapThread* checkMmapThread_l(audio_io_handle_t io) const = 0;\n    virtual sp<IAfThreadBase> openInput_l(audio_module_handle_t module,\n            audio_io_handle_t* input,\n            audio_config_t* config,\n            audio_devices_t device,\n            const char* address,\n            audio_source_t source,\n            audio_input_flags_t flags,\n            audio_devices_t outputDevice,\n            const String8& outputDeviceAddress) = 0;\n    virtual sp<IAfThreadBase> openOutput_l(audio_module_handle_t module,\n            audio_io_handle_t* output,\n            audio_config_t* halConfig,\n            audio_config_base_t* mixerConfig,\n            audio_devices_t deviceType,\n            const String8& address,\n            audio_output_flags_t flags) = 0;\n    virtual void lock() const = 0;\n    virtual void unlock() const = 0;\n    virtual const DefaultKeyedVector<audio_module_handle_t, AudioHwDevice*>&\n            getAudioHwDevs_l() const = 0;\n    virtual audio_unique_id_t nextUniqueId(audio_unique_id_use_t use) = 0;\n    virtual const sp<PatchCommandThread>& getPatchCommandThread() = 0;\n    virtual void updateDownStreamPatches_l(\n            const struct audio_patch* patch, const std::set<audio_io_handle_t>& streams) = 0;\n    virtual void updateOutDevicesForRecordThreads_l(const DeviceDescriptorBaseVector& devices) = 0;\n};\n\nclass IAfPatchPanel : public virtual RefBase {\npublic:\n    static sp<IAfPatchPanel> create(const sp<IAfPatchPanelCallback>& afPatchPanelCallback);\n\n    // Extraction of inner Endpoint and Patch classes would require interfaces\n    // (in the Endpoint case a templated interface) but that seems\n    // excessive for now.  We keep them as inner classes until extraction\n    // is needed.\n    template <typename ThreadType, typename TrackType>\n    class Endpoint final {\n    public:\n        Endpoint() = default;\n        Endpoint(const Endpoint&) = delete;\n        Endpoint& operator=(const Endpoint& other) noexcept {\n            mThread = other.mThread;\n            mCloseThread = other.mCloseThread;\n            mHandle = other.mHandle;\n            mTrack = other.mTrack;\n            return *this;\n        }\n        Endpoint(Endpoint&& other) noexcept { swap(other); }\n        Endpoint& operator=(Endpoint&& other) noexcept {\n            swap(other);\n            return *this;\n        }\n        ~Endpoint() {\n            ALOGE_IF(\n                    mHandle != AUDIO_PATCH_HANDLE_NONE,\n                    \"A non empty Patch Endpoint leaked, handle %d\", mHandle);\n        }\n\n        status_t checkTrack(TrackType* trackOrNull) const {\n            if (trackOrNull == nullptr) return NO_MEMORY;\n            return trackOrNull->initCheck();\n        }\n        audio_patch_handle_t handle() const { return mHandle; }\n        sp<ThreadType> thread() const { return mThread; }\n        sp<TrackType> track() const { return mTrack; }\n        sp<const ThreadType> const_thread() const { return mThread; }\n        sp<const TrackType> const_track() const { return mTrack; }\n\n        void closeConnections(const sp<IAfPatchPanel>& panel) {\n            if (mHandle != AUDIO_PATCH_HANDLE_NONE) {\n                panel->releaseAudioPatch(mHandle);\n                mHandle = AUDIO_PATCH_HANDLE_NONE;\n            }\n            if (mThread != nullptr) {\n                if (mTrack != nullptr) {\n                    mThread->deletePatchTrack(mTrack);\n                }\n                if (mCloseThread) {\n                    panel->closeThreadInternal_l(mThread);\n                }\n            }\n        }\n        audio_patch_handle_t* handlePtr() { return &mHandle; }\n        void setThread(const sp<ThreadType>& thread, bool closeThread = true) {\n            mThread = thread;\n            mCloseThread = closeThread;\n        }\n        template <typename T>\n        void setTrackAndPeer(const sp<TrackType>& track, const sp<T>& peer, bool holdReference) {\n            mTrack = track;\n            mThread->addPatchTrack(mTrack);\n            mTrack->setPeerProxy(peer, holdReference);\n            mClearPeerProxy = holdReference;\n        }\n        void clearTrackPeer() {\n            if (mClearPeerProxy && mTrack) mTrack->clearPeerProxy();\n        }\n        void stopTrack() {\n            if (mTrack) mTrack->stop();\n        }\n\n        void swap(Endpoint& other) noexcept {\n            using std::swap;\n            swap(mThread, other.mThread);\n            swap(mCloseThread, other.mCloseThread);\n            swap(mClearPeerProxy, other.mClearPeerProxy);\n            swap(mHandle, other.mHandle);\n            swap(mTrack, other.mTrack);\n        }\n\n        friend void swap(Endpoint& a, Endpoint& b) noexcept { a.swap(b); }\n\n    private:\n        sp<ThreadType> mThread;\n        bool mCloseThread = true;\n        bool mClearPeerProxy = true;\n        audio_patch_handle_t mHandle = AUDIO_PATCH_HANDLE_NONE;\n        sp<TrackType> mTrack;\n    };\n\n    class Patch final {\n    public:\n        Patch(const struct audio_patch& patch, bool endpointPatch)\n            : mAudioPatch(patch), mIsEndpointPatch(endpointPatch) {}\n        Patch() = default;\n        ~Patch();\n        Patch(const Patch& other) noexcept {\n            mAudioPatch = other.mAudioPatch;\n            mHalHandle = other.mHalHandle;\n            mPlayback = other.mPlayback;\n            mRecord = other.mRecord;\n            mThread = other.mThread;\n            mIsEndpointPatch = other.mIsEndpointPatch;\n        }\n        Patch(Patch&& other) noexcept { swap(other); }\n        Patch& operator=(Patch&& other) noexcept {\n            swap(other);\n            return *this;\n        }\n\n        void swap(Patch& other) noexcept {\n            using std::swap;\n            swap(mAudioPatch, other.mAudioPatch);\n            swap(mHalHandle, other.mHalHandle);\n            swap(mPlayback, other.mPlayback);\n            swap(mRecord, other.mRecord);\n            swap(mThread, other.mThread);\n            swap(mIsEndpointPatch, other.mIsEndpointPatch);\n        }\n\n        friend void swap(Patch& a, Patch& b) noexcept { a.swap(b); }\n\n        status_t createConnections(const sp<IAfPatchPanel>& panel);\n        void clearConnections(const sp<IAfPatchPanel>& panel);\n        bool isSoftware() const {\n            return mRecord.handle() != AUDIO_PATCH_HANDLE_NONE ||\n                   mPlayback.handle() != AUDIO_PATCH_HANDLE_NONE;\n        }\n\n        void setThread(const sp<IAfThreadBase>& thread) { mThread = thread; }\n        wp<IAfThreadBase> thread() const { return mThread; }\n\n        // returns the latency of the patch (from record to playback).\n        status_t getLatencyMs(double* latencyMs) const;\n\n        String8 dump(audio_patch_handle_t myHandle) const;\n\n        // Note that audio_patch::id is only unique within a HAL module\n        struct audio_patch mAudioPatch;\n        // handle for audio HAL patch handle present only when the audio HAL version is >= 3.0\n        audio_patch_handle_t mHalHandle = AUDIO_PATCH_HANDLE_NONE;\n        // below members are used by a software audio patch connecting a source device from a\n        // given audio HW module to a sink device on an other audio HW module.\n        // the objects are created by createConnections() and released by clearConnections()\n        // playback thread is created if no existing playback thread can be used\n        // connects playback thread output to sink device\n        Endpoint<IAfPlaybackThread, IAfPatchTrack> mPlayback;\n        // connects source device to record thread input\n        Endpoint<IAfRecordThread, IAfPatchRecord> mRecord;\n\n        wp<IAfThreadBase> mThread;\n        bool mIsEndpointPatch;\n    };\n\n    /* List connected audio ports and their attributes */\n    virtual status_t listAudioPorts(unsigned int* num_ports, struct audio_port* ports) = 0;\n\n    /* Get supported attributes for a given audio port */\n    virtual status_t getAudioPort(struct audio_port_v7* port) = 0;\n\n    /* Create a patch between several source and sink ports */\n    virtual status_t createAudioPatch(\n            const struct audio_patch* patch,\n            audio_patch_handle_t* handle,\n            bool endpointPatch = false) = 0;\n\n    /* Release a patch */\n    virtual status_t releaseAudioPatch(audio_patch_handle_t handle) = 0;\n\n    /* List connected audio devices and they attributes */\n    virtual status_t listAudioPatches(unsigned int* num_patches, struct audio_patch* patches) = 0;\n\n    // Retrieves all currently estrablished software patches for a stream\n    // opened on an intermediate module.\n    virtual status_t getDownstreamSoftwarePatches(\n            audio_io_handle_t stream, std::vector<SoftwarePatch>* patches) const = 0;\n\n    // Notifies patch panel about all opened and closed streams.\n    virtual void notifyStreamOpened(\n            AudioHwDevice* audioHwDevice, audio_io_handle_t stream, struct audio_patch* patch) = 0;\n\n    virtual void notifyStreamClosed(audio_io_handle_t stream) = 0;\n\n    virtual void dump(int fd) const = 0;\n\n    // Must be called under AudioFlinger::mLock\n\n    virtual const std::map<audio_patch_handle_t, Patch>& patches_l() const = 0;\n\n    virtual status_t getLatencyMs_l(audio_patch_handle_t patchHandle, double* latencyMs) const = 0;\n\n    virtual void closeThreadInternal_l(const sp<IAfThreadBase>& thread) const = 0;\n};\n\n}  // namespace android",
        "b_contents": "/*\n * Copyright (C) 2023 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#pragma once\n\nnamespace android {\n\nclass IAfPatchPanel;\nclass IAfPatchRecord;\nclass IAfPatchTrack;\nclass IAfPlaybackThread;\nclass IAfRecordThread;\nclass IAfThreadBase;\n\nclass SoftwarePatch {\npublic:\n    SoftwarePatch(\n            const sp<const IAfPatchPanel>& patchPanel,\n            audio_patch_handle_t patchHandle,\n            audio_io_handle_t playbackThreadHandle,\n            audio_io_handle_t recordThreadHandle)\n        : mPatchPanel(patchPanel),\n          mPatchHandle(patchHandle),\n          mPlaybackThreadHandle(playbackThreadHandle),\n          mRecordThreadHandle(recordThreadHandle) {}\n    SoftwarePatch(const SoftwarePatch&) = default;\n\n    // Must be called under AudioFlinger::mLock\n    status_t getLatencyMs_l(double* latencyMs) const;\n    audio_patch_handle_t getPatchHandle() const { return mPatchHandle; };\n    audio_io_handle_t getPlaybackThreadHandle() const { return mPlaybackThreadHandle; };\n    audio_io_handle_t getRecordThreadHandle() const { return mRecordThreadHandle; };\n\nprivate:\n    const sp<const IAfPatchPanel> mPatchPanel;\n    const audio_patch_handle_t mPatchHandle;\n    const audio_io_handle_t mPlaybackThreadHandle;\n    const audio_io_handle_t mRecordThreadHandle;\n};\n\nclass IAfPatchPanel : public virtual RefBase {\npublic:\n    static sp<IAfPatchPanel> create(AudioFlinger* audioFlinger);\n\n    // Extraction of inner Endpoint and Patch classes would require interfaces\n    // (in the Endpoint case a templated interface) but that seems\n    // excessive for now.  We keep them as inner classes until extraction\n    // is needed.\n    template <typename ThreadType, typename TrackType>\n    class Endpoint final {\n    public:\n        Endpoint() = default;\n        Endpoint(const Endpoint&) = delete;\n        Endpoint& operator=(const Endpoint& other) noexcept {\n            mThread = other.mThread;\n            mCloseThread = other.mCloseThread;\n            mHandle = other.mHandle;\n            mTrack = other.mTrack;\n            return *this;\n        }\n        Endpoint(Endpoint&& other) noexcept { swap(other); }\n        Endpoint& operator=(Endpoint&& other) noexcept {\n            swap(other);\n            return *this;\n        }\n        ~Endpoint() {\n            ALOGE_IF(\n                    mHandle != AUDIO_PATCH_HANDLE_NONE,\n                    \"A non empty Patch Endpoint leaked, handle %d\", mHandle);\n        }\n\n        status_t checkTrack(TrackType* trackOrNull) const {\n            if (trackOrNull == nullptr) return NO_MEMORY;\n            return trackOrNull->initCheck();\n        }\n        audio_patch_handle_t handle() const { return mHandle; }\n        sp<ThreadType> thread() const { return mThread; }\n        sp<TrackType> track() const { return mTrack; }\n        sp<const ThreadType> const_thread() const { return mThread; }\n        sp<const TrackType> const_track() const { return mTrack; }\n\n        void closeConnections(const sp<IAfPatchPanel>& panel) {\n            if (mHandle != AUDIO_PATCH_HANDLE_NONE) {\n                panel->releaseAudioPatch(mHandle);\n                mHandle = AUDIO_PATCH_HANDLE_NONE;\n            }\n            if (mThread != nullptr) {\n                if (mTrack != nullptr) {\n                    mThread->deletePatchTrack(mTrack);\n                }\n                if (mCloseThread) {\n                    panel->closeThreadInternal_l(mThread);\n                }\n            }\n        }\n        audio_patch_handle_t* handlePtr() { return &mHandle; }\n        void setThread(const sp<ThreadType>& thread, bool closeThread = true) {\n            mThread = thread;\n            mCloseThread = closeThread;\n        }\n        template <typename T>\n        void setTrackAndPeer(const sp<TrackType>& track, const sp<T>& peer, bool holdReference) {\n            mTrack = track;\n            mThread->addPatchTrack(mTrack);\n            mTrack->setPeerProxy(peer, holdReference);\n            mClearPeerProxy = holdReference;\n        }\n        void clearTrackPeer() {\n            if (mClearPeerProxy && mTrack) mTrack->clearPeerProxy();\n        }\n        void stopTrack() {\n            if (mTrack) mTrack->stop();\n        }\n\n        void swap(Endpoint& other) noexcept {\n            using std::swap;\n            swap(mThread, other.mThread);\n            swap(mCloseThread, other.mCloseThread);\n            swap(mClearPeerProxy, other.mClearPeerProxy);\n            swap(mHandle, other.mHandle);\n            swap(mTrack, other.mTrack);\n        }\n\n        friend void swap(Endpoint& a, Endpoint& b) noexcept { a.swap(b); }\n\n    private:\n        sp<ThreadType> mThread;\n        bool mCloseThread = true;\n        bool mClearPeerProxy = true;\n        audio_patch_handle_t mHandle = AUDIO_PATCH_HANDLE_NONE;\n        sp<TrackType> mTrack;\n    };\n\n    class Patch final {\n    public:\n        Patch(const struct audio_patch& patch, bool endpointPatch)\n            : mAudioPatch(patch), mIsEndpointPatch(endpointPatch) {}\n        Patch() = default;\n        ~Patch();\n        Patch(const Patch& other) noexcept {\n            mAudioPatch = other.mAudioPatch;\n            mHalHandle = other.mHalHandle;\n            mPlayback = other.mPlayback;\n            mRecord = other.mRecord;\n            mThread = other.mThread;\n            mIsEndpointPatch = other.mIsEndpointPatch;\n        }\n        Patch(Patch&& other) noexcept { swap(other); }\n        Patch& operator=(Patch&& other) noexcept {\n            swap(other);\n            return *this;\n        }\n\n        void swap(Patch& other) noexcept {\n            using std::swap;\n            swap(mAudioPatch, other.mAudioPatch);\n            swap(mHalHandle, other.mHalHandle);\n            swap(mPlayback, other.mPlayback);\n            swap(mRecord, other.mRecord);\n            swap(mThread, other.mThread);\n            swap(mIsEndpointPatch, other.mIsEndpointPatch);\n        }\n\n        friend void swap(Patch& a, Patch& b) noexcept { a.swap(b); }\n\n        status_t createConnections(const sp<IAfPatchPanel>& panel);\n        void clearConnections(const sp<IAfPatchPanel>& panel);\n        bool isSoftware() const {\n            return mRecord.handle() != AUDIO_PATCH_HANDLE_NONE ||\n                   mPlayback.handle() != AUDIO_PATCH_HANDLE_NONE;\n        }\n\n        void setThread(const sp<IAfThreadBase>& thread) { mThread = thread; }\n        wp<IAfThreadBase> thread() const { return mThread; }\n\n        // returns the latency of the patch (from record to playback).\n        status_t getLatencyMs(double* latencyMs) const;\n\n        String8 dump(audio_patch_handle_t myHandle) const;\n\n        // Note that audio_patch::id is only unique within a HAL module\n        struct audio_patch mAudioPatch;\n        // handle for audio HAL patch handle present only when the audio HAL version is >= 3.0\n        audio_patch_handle_t mHalHandle = AUDIO_PATCH_HANDLE_NONE;\n        // below members are used by a software audio patch connecting a source device from a\n        // given audio HW module to a sink device on an other audio HW module.\n        // the objects are created by createConnections() and released by clearConnections()\n        // playback thread is created if no existing playback thread can be used\n        // connects playback thread output to sink device\n        Endpoint<IAfPlaybackThread, IAfPatchTrack> mPlayback;\n        // connects source device to record thread input\n        Endpoint<IAfRecordThread, IAfPatchRecord> mRecord;\n\n        wp<IAfThreadBase> mThread;\n        bool mIsEndpointPatch;\n    };\n\n    /* List connected audio ports and their attributes */\n    virtual status_t listAudioPorts(unsigned int* num_ports, struct audio_port* ports) = 0;\n\n    /* Get supported attributes for a given audio port */\n    virtual status_t getAudioPort(struct audio_port_v7* port) = 0;\n\n    /* Create a patch between several source and sink ports */\n    virtual status_t createAudioPatch(\n            const struct audio_patch* patch,\n            audio_patch_handle_t* handle,\n            bool endpointPatch = false) = 0;\n\n    /* Release a patch */\n    virtual status_t releaseAudioPatch(audio_patch_handle_t handle) = 0;\n\n    /* List connected audio devices and they attributes */\n    virtual status_t listAudioPatches(unsigned int* num_patches, struct audio_patch* patches) = 0;\n\n    // Retrieves all currently estrablished software patches for a stream\n    // opened on an intermediate module.\n    virtual status_t getDownstreamSoftwarePatches(\n            audio_io_handle_t stream, std::vector<SoftwarePatch>* patches) const = 0;\n\n    // Notifies patch panel about all opened and closed streams.\n    virtual void notifyStreamOpened(\n            AudioHwDevice* audioHwDevice, audio_io_handle_t stream, struct audio_patch* patch) = 0;\n\n    virtual void notifyStreamClosed(audio_io_handle_t stream) = 0;\n\n    virtual void dump(int fd) const = 0;\n\n    // Must be called under AudioFlinger::mLock\n\n    virtual const std::map<audio_patch_handle_t, Patch>& patches_l() const = 0;\n\n    virtual status_t getLatencyMs_l(audio_patch_handle_t patchHandle, double* latencyMs) const = 0;\n\n    virtual void closeThreadInternal_l(const sp<IAfThreadBase>& thread) const = 0;\n};\n\n}  // namespace android",
        "base_contents": "",
        "res_region": "/*\n * Copyright (C) 2023 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#pragma once\n\n// The following includes are required because we have class definitions below\n// for EndPoint and Patch, which precludes using a forward declaration only.\n#include \"IAfThread.h\"  // IAfThreadBase IAfMmapThread IAfPlaybackThread IAfRecordThread\n#include \"IAfTrack.h\"   // IAfPatchRecord IAfPatchTrack\n\n#include <datapath/AudioHwDevice.h>\n#include <media/DeviceDescriptorBase.h>\n#include <utils/Log.h>      // ALOG used in this file\n#include <utils/RefBase.h>  // avoid transitive dependency\n#include <utils/Thread.h>\n\nnamespace android {\n\nclass IAfPatchPanel;\nclass PatchCommandThread;\n\nclass SoftwarePatch {\npublic:\n    SoftwarePatch(\n            const sp<const IAfPatchPanel>& patchPanel,\n            audio_patch_handle_t patchHandle,\n            audio_io_handle_t playbackThreadHandle,\n            audio_io_handle_t recordThreadHandle)\n        : mPatchPanel(patchPanel),\n          mPatchHandle(patchHandle),\n          mPlaybackThreadHandle(playbackThreadHandle),\n          mRecordThreadHandle(recordThreadHandle) {}\n    SoftwarePatch(const SoftwarePatch&) = default;\n\n    // Must be called under AudioFlinger::mLock\n    status_t getLatencyMs_l(double* latencyMs) const;\n    audio_patch_handle_t getPatchHandle() const { return mPatchHandle; };\n    audio_io_handle_t getPlaybackThreadHandle() const { return mPlaybackThreadHandle; };\n    audio_io_handle_t getRecordThreadHandle() const { return mRecordThreadHandle; };\n\nprivate:\n    const sp<const IAfPatchPanel> mPatchPanel;\n    const audio_patch_handle_t mPatchHandle;\n    const audio_io_handle_t mPlaybackThreadHandle;\n    const audio_io_handle_t mRecordThreadHandle;\n};\n\nclass IAfPatchPanelCallback : public virtual RefBase {\npublic:\n    virtual void closeThreadInternal_l(const sp<IAfPlaybackThread>& thread) = 0;\n    virtual void closeThreadInternal_l(const sp<IAfRecordThread>& thread) = 0;\n    virtual IAfPlaybackThread* primaryPlaybackThread_l() const = 0;\n    virtual IAfPlaybackThread* checkPlaybackThread_l(audio_io_handle_t output) const = 0;\n    virtual IAfRecordThread* checkRecordThread_l(audio_io_handle_t input) const = 0;\n    virtual IAfMmapThread* checkMmapThread_l(audio_io_handle_t io) const = 0;\n    virtual sp<IAfThreadBase> openInput_l(audio_module_handle_t module,\n            audio_io_handle_t* input,\n            audio_config_t* config,\n            audio_devices_t device,\n            const char* address,\n            audio_source_t source,\n            audio_input_flags_t flags,\n            audio_devices_t outputDevice,\n            const String8& outputDeviceAddress) = 0;\n    virtual sp<IAfThreadBase> openOutput_l(audio_module_handle_t module,\n            audio_io_handle_t* output,\n            audio_config_t* halConfig,\n            audio_config_base_t* mixerConfig,\n            audio_devices_t deviceType,\n            const String8& address,\n            audio_output_flags_t flags) = 0;\n    virtual void lock() const = 0;\n    virtual void unlock() const = 0;\n    virtual const DefaultKeyedVector<audio_module_handle_t, AudioHwDevice*>&\n            getAudioHwDevs_l() const = 0;\n    virtual audio_unique_id_t nextUniqueId(audio_unique_id_use_t use) = 0;\n    virtual const sp<PatchCommandThread>& getPatchCommandThread() = 0;\n    virtual void updateDownStreamPatches_l(\n            const struct audio_patch* patch, const std::set<audio_io_handle_t>& streams) = 0;\n    virtual void updateOutDevicesForRecordThreads_l(const DeviceDescriptorBaseVector& devices) = 0;\n};\n\nclass IAfPatchPanel : public virtual RefBase {\npublic:\n    static sp<IAfPatchPanel> create(const sp<IAfPatchPanelCallback>& afPatchPanelCallback);\n\n    // Extraction of inner Endpoint and Patch classes would require interfaces\n    // (in the Endpoint case a templated interface) but that seems\n    // excessive for now.  We keep them as inner classes until extraction\n    // is needed.\n    template <typename ThreadType, typename TrackType>\n    class Endpoint final {\n    public:\n        Endpoint() = default;\n        Endpoint(const Endpoint&) = delete;\n        Endpoint& operator=(const Endpoint& other) noexcept {\n            mThread = other.mThread;\n            mCloseThread = other.mCloseThread;\n            mHandle = other.mHandle;\n            mTrack = other.mTrack;\n            return *this;\n        }\n        Endpoint(Endpoint&& other) noexcept { swap(other); }\n        Endpoint& operator=(Endpoint&& other) noexcept {\n            swap(other);\n            return *this;\n        }\n        ~Endpoint() {\n            ALOGE_IF(\n                    mHandle != AUDIO_PATCH_HANDLE_NONE,\n                    \"A non empty Patch Endpoint leaked, handle %d\", mHandle);\n        }\n\n        status_t checkTrack(TrackType* trackOrNull) const {\n            if (trackOrNull == nullptr) return NO_MEMORY;\n            return trackOrNull->initCheck();\n        }\n        audio_patch_handle_t handle() const { return mHandle; }\n        sp<ThreadType> thread() const { return mThread; }\n        sp<TrackType> track() const { return mTrack; }\n        sp<const ThreadType> const_thread() const { return mThread; }\n        sp<const TrackType> const_track() const { return mTrack; }\n\n        void closeConnections(const sp<IAfPatchPanel>& panel) {\n            if (mHandle != AUDIO_PATCH_HANDLE_NONE) {\n                panel->releaseAudioPatch(mHandle);\n                mHandle = AUDIO_PATCH_HANDLE_NONE;\n            }\n            if (mThread != nullptr) {\n                if (mTrack != nullptr) {\n                    mThread->deletePatchTrack(mTrack);\n                }\n                if (mCloseThread) {\n                    panel->closeThreadInternal_l(mThread);\n                }\n            }\n        }\n        audio_patch_handle_t* handlePtr() { return &mHandle; }\n        void setThread(const sp<ThreadType>& thread, bool closeThread = true) {\n            mThread = thread;\n            mCloseThread = closeThread;\n        }\n        template <typename T>\n        void setTrackAndPeer(const sp<TrackType>& track, const sp<T>& peer, bool holdReference) {\n            mTrack = track;\n            mThread->addPatchTrack(mTrack);\n            mTrack->setPeerProxy(peer, holdReference);\n            mClearPeerProxy = holdReference;\n        }\n        void clearTrackPeer() {\n            if (mClearPeerProxy && mTrack) mTrack->clearPeerProxy();\n        }\n        void stopTrack() {\n            if (mTrack) mTrack->stop();\n        }\n\n        void swap(Endpoint& other) noexcept {\n            using std::swap;\n            swap(mThread, other.mThread);\n            swap(mCloseThread, other.mCloseThread);\n            swap(mClearPeerProxy, other.mClearPeerProxy);\n            swap(mHandle, other.mHandle);\n            swap(mTrack, other.mTrack);\n        }\n\n        friend void swap(Endpoint& a, Endpoint& b) noexcept { a.swap(b); }\n\n    private:\n        sp<ThreadType> mThread;\n        bool mCloseThread = true;\n        bool mClearPeerProxy = true;\n        audio_patch_handle_t mHandle = AUDIO_PATCH_HANDLE_NONE;\n        sp<TrackType> mTrack;\n    };\n\n    class Patch final {\n    public:\n        Patch(const struct audio_patch& patch, bool endpointPatch)\n            : mAudioPatch(patch), mIsEndpointPatch(endpointPatch) {}\n        Patch() = default;\n        ~Patch();\n        Patch(const Patch& other) noexcept {\n            mAudioPatch = other.mAudioPatch;\n            mHalHandle = other.mHalHandle;\n            mPlayback = other.mPlayback;\n            mRecord = other.mRecord;\n            mThread = other.mThread;\n            mIsEndpointPatch = other.mIsEndpointPatch;\n        }\n        Patch(Patch&& other) noexcept { swap(other); }\n        Patch& operator=(Patch&& other) noexcept {\n            swap(other);\n            return *this;\n        }\n\n        void swap(Patch& other) noexcept {\n            using std::swap;\n            swap(mAudioPatch, other.mAudioPatch);\n            swap(mHalHandle, other.mHalHandle);\n            swap(mPlayback, other.mPlayback);\n            swap(mRecord, other.mRecord);\n            swap(mThread, other.mThread);\n            swap(mIsEndpointPatch, other.mIsEndpointPatch);\n        }\n\n        friend void swap(Patch& a, Patch& b) noexcept { a.swap(b); }\n\n        status_t createConnections(const sp<IAfPatchPanel>& panel);\n        void clearConnections(const sp<IAfPatchPanel>& panel);\n        bool isSoftware() const {\n            return mRecord.handle() != AUDIO_PATCH_HANDLE_NONE ||\n                   mPlayback.handle() != AUDIO_PATCH_HANDLE_NONE;\n        }\n\n        void setThread(const sp<IAfThreadBase>& thread) { mThread = thread; }\n        wp<IAfThreadBase> thread() const { return mThread; }\n\n        // returns the latency of the patch (from record to playback).\n        status_t getLatencyMs(double* latencyMs) const;\n\n        String8 dump(audio_patch_handle_t myHandle) const;\n\n        // Note that audio_patch::id is only unique within a HAL module\n        struct audio_patch mAudioPatch;\n        // handle for audio HAL patch handle present only when the audio HAL version is >= 3.0\n        audio_patch_handle_t mHalHandle = AUDIO_PATCH_HANDLE_NONE;\n        // below members are used by a software audio patch connecting a source device from a\n        // given audio HW module to a sink device on an other audio HW module.\n        // the objects are created by createConnections() and released by clearConnections()\n        // playback thread is created if no existing playback thread can be used\n        // connects playback thread output to sink device\n        Endpoint<IAfPlaybackThread, IAfPatchTrack> mPlayback;\n        // connects source device to record thread input\n        Endpoint<IAfRecordThread, IAfPatchRecord> mRecord;\n\n        wp<IAfThreadBase> mThread;\n        bool mIsEndpointPatch;\n    };\n\n    /* List connected audio ports and their attributes */\n    virtual status_t listAudioPorts(unsigned int* num_ports, struct audio_port* ports) = 0;\n\n    /* Get supported attributes for a given audio port */\n    virtual status_t getAudioPort(struct audio_port_v7* port) = 0;\n\n    /* Create a patch between several source and sink ports */\n    virtual status_t createAudioPatch(\n            const struct audio_patch* patch,\n            audio_patch_handle_t* handle,\n            bool endpointPatch = false) = 0;\n\n    /* Release a patch */\n    virtual status_t releaseAudioPatch(audio_patch_handle_t handle) = 0;\n\n    /* List connected audio devices and they attributes */\n    virtual status_t listAudioPatches(unsigned int* num_patches, struct audio_patch* patches) = 0;\n\n    // Retrieves all currently estrablished software patches for a stream\n    // opened on an intermediate module.\n    virtual status_t getDownstreamSoftwarePatches(\n            audio_io_handle_t stream, std::vector<SoftwarePatch>* patches) const = 0;\n\n    // Notifies patch panel about all opened and closed streams.\n    virtual void notifyStreamOpened(\n            AudioHwDevice* audioHwDevice, audio_io_handle_t stream, struct audio_patch* patch) = 0;\n\n    virtual void notifyStreamClosed(audio_io_handle_t stream) = 0;\n\n    virtual void dump(int fd) const = 0;\n\n    // Must be called under AudioFlinger::mLock\n\n    virtual const std::map<audio_patch_handle_t, Patch>& patches_l() const = 0;\n\n    virtual status_t getLatencyMs_l(audio_patch_handle_t patchHandle, double* latencyMs) const = 0;\n\n    virtual void closeThreadInternal_l(const sp<IAfThreadBase>& thread) const = 0;\n};\n\n}  // namespace android",
        "lookback": " * Copyright (C) 2023 The Android Open Source Project",
        "lookahead": "",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 0,
        "end_line": 547,
        "merge_gen_region": " CopyrightC 2 The Open Project * Licensed the Apache, 2. ( \"\"); you not this except in with the. * may a of License * may a of License * *://..///LICENSE20 * Unless by applicable or to writing software distributed the is on \" IS BASIS * WARRANTIES CONDITIONS ANY, either or.. See License for specific governing and limitations the License */pragma // following are because have class below for End and, pres a declaration.includeIAThreadh //fBasefmap IAPlayback IARecord # \"IATrackh //fRecordfTrackincludedata/AudioDeviceh # </DeviceBaseh # </.>includemediaDeviceBaseh # </.>includeutilsLogh // used this # </Ref.> avoiditive # </.> namespace { IAfPanel classfPanel classCommand; Software {:Patch( spconstfPanel patch,___ patch,___ patchHandle audiopatchhandletHandle audioiohandletThreadHandle constPlaybackHandleplaybackHandle mRecordHandlerecordHandle {}PatchconstPatch =; {:Patch( spconstfPanel mPanel const_patchhandletRecordHandle const returnRecordHandle };: spconstfPanel mPanel const",
        "confidence": 0.9190067052841187,
        "hesitated": false,
        "resolved": false
    }
]