[
    {
        "a_contents": "class PatchCommandThread;",
        "b_contents": "class IAfPatchRecord;\nclass IAfPatchTrack;\nclass IAfPlaybackThread;\nclass IAfRecordThread;\nclass IAfThreadBase;\nclass PatchCommandThread;",
        "base_contents": "class IAfPatchRecord;\nclass IAfPatchTrack;\nclass IAfPlaybackThread;\nclass IAfRecordThread;\nclass IAfThreadBase;",
        "res_region": "class PatchCommandThread;",
        "lookback": "",
        "lookahead": "",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 33,
        "end_line": 48,
        "merge_gen_region": null,
        "confidence": 0.8702251315116882,
        "hesitated": true
    },
    {
        "a_contents": "class IAfPatchPanelCallback : public virtual RefBase {\npublic:\n    virtual void closeThreadInternal_l(const sp<IAfPlaybackThread>& thread) REQUIRES(mutex()) = 0;\n    virtual void closeThreadInternal_l(const sp<IAfRecordThread>& thread) REQUIRES(mutex()) = 0;\n    virtual IAfPlaybackThread* primaryPlaybackThread_l() const REQUIRES(mutex()) = 0;\n    virtual IAfPlaybackThread* checkPlaybackThread_l(audio_io_handle_t output) const\n            REQUIRES(mutex()) = 0;\n    virtual IAfRecordThread* checkRecordThread_l(audio_io_handle_t input) const\n            REQUIRES(mutex()) = 0;\n    virtual IAfMmapThread* checkMmapThread_l(audio_io_handle_t io) const REQUIRES(mutex()) = 0;\n    virtual sp<IAfThreadBase> openInput_l(audio_module_handle_t module,\n            audio_io_handle_t* input,\n            audio_config_t* config,\n            audio_devices_t device,\n            const char* address,\n            audio_source_t source,\n            audio_input_flags_t flags,\n            audio_devices_t outputDevice,\n            const String8& outputDeviceAddress) REQUIRES(mutex()) = 0;\n    virtual sp<IAfThreadBase> openOutput_l(audio_module_handle_t module,\n            audio_io_handle_t* output,\n            audio_config_t* halConfig,\n            audio_config_base_t* mixerConfig,\n            audio_devices_t deviceType,\n            const String8& address,\n            audio_output_flags_t flags) REQUIRES(mutex()) = 0;\n    virtual audio_utils::mutex& mutex() const\n            RETURN_CAPABILITY(audio_utils::AudioFlinger_Mutex) = 0;\n    virtual const DefaultKeyedVector<audio_module_handle_t, AudioHwDevice*>&\n            getAudioHwDevs_l() const REQUIRES(mutex()) = 0;\n    virtual audio_unique_id_t nextUniqueId(audio_unique_id_use_t use) = 0;\n    virtual const sp<PatchCommandThread>& getPatchCommandThread() = 0;\n    virtual void updateDownStreamPatches_l(\n            const struct audio_patch* patch, const std::set<audio_io_handle_t>& streams)\n            REQUIRES(mutex()) = 0;\n    virtual void updateOutDevicesForRecordThreads_l(const DeviceDescriptorBaseVector& devices)\n            REQUIRES(mutex()) = 0;\n};\n",
        "b_contents": "class IAfPatchPanelCallback : public virtual RefBase {\npublic:\n    virtual void closeThreadInternal_l(const sp<IAfPlaybackThread>& thread) = 0;\n    virtual void closeThreadInternal_l(const sp<IAfRecordThread>& thread) = 0;\n    virtual IAfPlaybackThread* primaryPlaybackThread_l() const = 0;\n    virtual IAfPlaybackThread* checkPlaybackThread_l(audio_io_handle_t output) const = 0;\n    virtual IAfRecordThread* checkRecordThread_l(audio_io_handle_t input) const = 0;\n    virtual IAfMmapThread* checkMmapThread_l(audio_io_handle_t io) const = 0;\n    virtual sp<IAfThreadBase> openInput_l(audio_module_handle_t module,\n            audio_io_handle_t* input,\n            audio_config_t* config,\n            audio_devices_t device,\n            const char* address,\n            audio_source_t source,\n            audio_input_flags_t flags,\n            audio_devices_t outputDevice,\n            const String8& outputDeviceAddress) = 0;\n    virtual sp<IAfThreadBase> openOutput_l(audio_module_handle_t module,\n            audio_io_handle_t* output,\n            audio_config_t* halConfig,\n            audio_config_base_t* mixerConfig,\n            audio_devices_t deviceType,\n            const String8& address,\n            audio_output_flags_t flags) = 0;\n    virtual void lock() const = 0;\n    virtual void unlock() const = 0;\n    virtual const DefaultKeyedVector<audio_module_handle_t, AudioHwDevice*>&\n            getAudioHwDevs_l() const = 0;\n    virtual audio_unique_id_t nextUniqueId(audio_unique_id_use_t use) = 0;\n    virtual const sp<PatchCommandThread>& getPatchCommandThread() = 0;\n    virtual void updateDownStreamPatches_l(\n            const struct audio_patch* patch, const std::set<audio_io_handle_t>& streams) = 0;\n    virtual void updateOutDevicesForRecordThreads_l(const DeviceDescriptorBaseVector& devices) = 0;\n};\n",
        "base_contents": "",
        "res_region": "class IAfPatchPanelCallback : public virtual RefBase {\npublic:\n    virtual void closeThreadInternal_l(const sp<IAfPlaybackThread>& thread) REQUIRES(mutex()) = 0;\n    virtual void closeThreadInternal_l(const sp<IAfRecordThread>& thread) REQUIRES(mutex()) = 0;\n    virtual IAfPlaybackThread* primaryPlaybackThread_l() const REQUIRES(mutex()) = 0;\n    virtual IAfPlaybackThread* checkPlaybackThread_l(audio_io_handle_t output) const\n            REQUIRES(mutex()) = 0;\n    virtual IAfRecordThread* checkRecordThread_l(audio_io_handle_t input) const\n            REQUIRES(mutex()) = 0;\n    virtual IAfMmapThread* checkMmapThread_l(audio_io_handle_t io) const REQUIRES(mutex()) = 0;\n    virtual sp<IAfThreadBase> openInput_l(audio_module_handle_t module,\n            audio_io_handle_t* input,\n            audio_config_t* config,\n            audio_devices_t device,\n            const char* address,\n            audio_source_t source,\n            audio_input_flags_t flags,\n            audio_devices_t outputDevice,\n            const String8& outputDeviceAddress) REQUIRES(mutex()) = 0;\n    virtual sp<IAfThreadBase> openOutput_l(audio_module_handle_t module,\n            audio_io_handle_t* output,\n            audio_config_t* halConfig,\n            audio_config_base_t* mixerConfig,\n            audio_devices_t deviceType,\n            const String8& address,\n            audio_output_flags_t flags) REQUIRES(mutex()) = 0;\n    virtual audio_utils::mutex& mutex() const\n            RETURN_CAPABILITY(audio_utils::AudioFlinger_Mutex) = 0;\n    virtual const DefaultKeyedVector<audio_module_handle_t, AudioHwDevice*>&\n            getAudioHwDevs_l() const REQUIRES(mutex()) = 0;\n    virtual audio_unique_id_t nextUniqueId(audio_unique_id_use_t use) = 0;\n    virtual const sp<PatchCommandThread>& getPatchCommandThread() = 0;\n    virtual void updateDownStreamPatches_l(\n            const struct audio_patch* patch, const std::set<audio_io_handle_t>& streams)\n            REQUIRES(mutex()) = 0;\n    virtual void updateOutDevicesForRecordThreads_l(const DeviceDescriptorBaseVector& devices)\n            REQUIRES(mutex()) = 0;\n};\n",
        "lookback": "public:",
        "lookahead": "class IAfPatchPanel : public virtual RefBase {",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 75,
        "end_line": 152,
        "merge_gen_region": " IAfPanel : virtualBase public virtual closeInternallconst<fThread>&)RESmutex =; void closeInternallconst<fRecord>&)RESmutex =; IAPlayback* primaryThread_() REQUI(mutex =; IAPlayback* checkThread_(audioiohandlet) REQUI(mutex =; IARecord* checkThreadlaudioiohandlet) REQUI(mutex =; IARecord* checkThreadlaudioiohandlet) REQUI(mutex =; IARecord* checkThreadlaudioiohandlet) REQUI(mutex =; IAfThread(()) 0 virtualfmap* checkmap_(_(__ io constRESmutex =; spIAThread>Inputlaudiomodulehandlet,___ module audioiohandlet input audioconfigt config audiodevicest, char address audiosourcet,____,,___ source audioinputflagst,___ output, String& outputAddress REQUI(()) 0; spIAThread>Outputlaudiomodulehandlet,___ module audioiohandlet output audioconfigt hal,_______*Config audiodevicestType const8 address audiooutputflagst)RESmutex =; audioutilsmutex&() RETURN",
        "confidence": 0.9457474946975708,
        "hesitated": false,
        "resolved": false
    }
]