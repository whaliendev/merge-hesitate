[
    {
        "a_contents": "// not needed with the includes above, added to prevent transitive include dependency.\n#include <utils/KeyedVector.h>\n#include <utils/String16.h>\n#include <atomic>\n#include <functional>\n#include <map>\n#include <optional>\n#include <set>",
        "b_contents": "#include <sounddose/SoundDoseManager.h>\n#include <timing/MonotonicFrameCounter.h>\n#include <timing/SyncEvent.h>\n#include <timing/SynchronizedRecordState.h>\n\n#include <datapath/AudioHwDevice.h>\n#include <datapath/AudioStreamIn.h>\n#include <datapath/AudioStreamOut.h>\n#include <datapath/SpdifStreamOut.h>\n#include <datapath/ThreadMetrics.h>\n#include <datapath/TrackMetrics.h>\n#include <datapath/VolumeInterface.h>\n#include <fastpath/FastCapture.h>\n#include <fastpath/FastMixer.h>\n#include <media/nbaio/NBAIO.h>\n\n#include <android/os/IPowerManager.h>\n\n#include <media/nblog/NBLog.h>\n#include <private/media/AudioEffectShared.h>\n#include <private/media/AudioTrackShared.h>\n\n#include <vibrator/ExternalVibration.h>\n#include <vibrator/ExternalVibrationUtils.h>\n\n#include \"android/media/BnAudioRecord.h\"\n#include \"android/media/BnEffect.h\"\n\n#include \"Client.h\"\n#include \"ResamplerBufferProvider.h\"\n\n// include AudioFlinger component interfaces\n#include \"IAfEffect.h\"\n#include \"IAfTrack.h\"",
        "base_contents": "#include <sounddose/SoundDoseManager.h>\n#include <timing/MonotonicFrameCounter.h>\n#include <timing/SyncEvent.h>\n#include <timing/SynchronizedRecordState.h>\n\n#include <datapath/AudioHwDevice.h>\n#include <datapath/AudioStreamIn.h>\n#include <datapath/AudioStreamOut.h>\n#include <datapath/SpdifStreamOut.h>\n#include <datapath/ThreadMetrics.h>\n#include <datapath/TrackMetrics.h>\n#include <fastpath/FastCapture.h>\n#include <fastpath/FastMixer.h>\n#include <media/nbaio/NBAIO.h>\n\n#include <android/os/IPowerManager.h>\n\n#include <media/nblog/NBLog.h>\n#include <private/media/AudioEffectShared.h>\n#include <private/media/AudioTrackShared.h>\n\n#include <vibrator/ExternalVibration.h>\n#include <vibrator/ExternalVibrationUtils.h>\n\n#include \"android/media/BnAudioRecord.h\"\n#include \"android/media/BnEffect.h\"\n\n#include \"Client.h\"\n#include \"ResamplerBufferProvider.h\"\n\n// include AudioFlinger component interfaces\n#include \"IAfEffect.h\"\n#include \"IAfTrack.h\"",
        "res_region": "// not needed with the includes above, added to prevent transitive include dependency.\n#include <utils/KeyedVector.h>\n#include <utils/String16.h>\n#include <atomic>\n#include <functional>\n#include <map>\n#include <optional>\n#include <set>",
        "lookback": "#include <utils/KeyedVector.h>",
        "lookahead": "",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 38,
        "end_line": 116,
        "merge_gen_region": null,
        "confidence": 0.6327112317085266,
        "hesitated": true
    },
    {
        "a_contents": "\n    void closeOutputFinish(const sp<IAfPlaybackThread>& thread);\n    void closeInputFinish(const sp<IAfRecordThread>& thread);",
        "b_contents": "              ThreadBase *checkThread_l(audio_io_handle_t ioHandle) const;\n              sp<AudioFlinger::ThreadBase> checkOutputThread_l(audio_io_handle_t ioHandle) const\n                      REQUIRES(mLock);\n              PlaybackThread *checkPlaybackThread_l(audio_io_handle_t output) const;\n              MixerThread *checkMixerThread_l(audio_io_handle_t output) const;\n              RecordThread *checkRecordThread_l(audio_io_handle_t input) const;\n              MmapThread *checkMmapThread_l(audio_io_handle_t io) const;\n              sp<VolumeInterface> getVolumeInterface_l(audio_io_handle_t output) const;\n              std::vector<sp<VolumeInterface>> getAllVolumeInterfaces_l() const;\n\n              sp<ThreadBase> openInput_l(audio_module_handle_t module,\n                                           audio_io_handle_t *input,\n                                           audio_config_t *config,\n                                           audio_devices_t device,\n                                           const char* address,\n                                           audio_source_t source,\n                                           audio_input_flags_t flags,\n                                           audio_devices_t outputDevice,\n                                           const String8& outputDeviceAddress);\n              sp<ThreadBase> openOutput_l(audio_module_handle_t module,\n                                          audio_io_handle_t *output,\n                                          audio_config_t *halConfig,\n                                          audio_config_base_t *mixerConfig,\n                                          audio_devices_t deviceType,\n                                          const String8& address,\n                                          audio_output_flags_t flags);\n\n              void closeOutputFinish(const sp<PlaybackThread>& thread);\n              void closeInputFinish(const sp<RecordThread>& thread);\n\n              // no range check, AudioFlinger::mLock held\n              bool streamMute_l(audio_stream_type_t stream) const\n                                { return mStreamTypes[stream].mute; }\n              void ioConfigChanged(audio_io_config_event_t event,\n                                   const sp<AudioIoDescriptor>& ioDesc,\n                                   pid_t pid = 0);\n              void onSupportedLatencyModesChanged(\n                    audio_io_handle_t output, const std::vector<audio_latency_mode_t>& modes);",
        "base_contents": "              ThreadBase *checkThread_l(audio_io_handle_t ioHandle) const;\n              sp<AudioFlinger::ThreadBase> checkOutputThread_l(audio_io_handle_t ioHandle) const\n                      REQUIRES(mLock);\n              PlaybackThread *checkPlaybackThread_l(audio_io_handle_t output) const;\n              MixerThread *checkMixerThread_l(audio_io_handle_t output) const;\n              RecordThread *checkRecordThread_l(audio_io_handle_t input) const;\n              MmapThread *checkMmapThread_l(audio_io_handle_t io) const;\n              VolumeInterface *getVolumeInterface_l(audio_io_handle_t output) const;\n              Vector <VolumeInterface *> getAllVolumeInterfaces_l() const;\n\n              sp<ThreadBase> openInput_l(audio_module_handle_t module,\n                                           audio_io_handle_t *input,\n                                           audio_config_t *config,\n                                           audio_devices_t device,\n                                           const char* address,\n                                           audio_source_t source,\n                                           audio_input_flags_t flags,\n                                           audio_devices_t outputDevice,\n                                           const String8& outputDeviceAddress);\n              sp<ThreadBase> openOutput_l(audio_module_handle_t module,\n                                          audio_io_handle_t *output,\n                                          audio_config_t *halConfig,\n                                          audio_config_base_t *mixerConfig,\n                                          audio_devices_t deviceType,\n                                          const String8& address,\n                                          audio_output_flags_t flags);\n\n              void closeOutputFinish(const sp<PlaybackThread>& thread);\n              void closeInputFinish(const sp<RecordThread>& thread);\n\n              // no range check, AudioFlinger::mLock held\n              bool streamMute_l(audio_stream_type_t stream) const\n                                { return mStreamTypes[stream].mute; }\n              void ioConfigChanged(audio_io_config_event_t event,\n                                   const sp<AudioIoDescriptor>& ioDesc,\n                                   pid_t pid = 0);\n              void onSupportedLatencyModesChanged(\n                    audio_io_handle_t output, const std::vector<audio_latency_mode_t>& modes);",
        "res_region": "\n    void closeOutputFinish(const sp<IAfPlaybackThread>& thread);\n    void closeInputFinish(const sp<IAfRecordThread>& thread);",
        "lookback": "    void closeOutputFinish(const sp<IAfPlaybackThread>& thread);",
        "lookahead": "",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 560,
        "end_line": 642,
        "merge_gen_region": null,
        "confidence": 0.5641175508499146,
        "hesitated": true
    }
]