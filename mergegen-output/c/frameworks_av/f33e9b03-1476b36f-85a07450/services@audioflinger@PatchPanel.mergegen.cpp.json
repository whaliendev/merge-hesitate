[
    {
        "a_contents": "            // For endpoint patches, we do not need to re-evaluate the device effect state\n            // if the same HAL patch is reused (see calls to mAfPatchPanelCallback below)\n            if (endpointPatch) {\n                for (auto& p : mPatches) {\n                    // end point patches are skipped so we do not compare against this patch\n                    if (!p.second.mIsEndpointPatch && patchesHaveSameRoute(\n                            newPatch.mAudioPatch, p.second.mAudioPatch)) {\n                        ALOGV(\"%s() Sw Bridge endpoint reusing halHandle=%d\", __func__,\n                              p.second.mHalHandle);\n                        halHandle = p.second.mHalHandle;\n                        reuseExistingHalPatch = true;\n                        break;\n                    }\n                }\n            }\n            mAfPatchPanelCallback->mutex().unlock();\n",
        "b_contents": "            mAfPatchPanelCallback->mutex().unlock();",
        "base_contents": "            mAfPatchPanelCallback->unlock();",
        "res_region": "            // For endpoint patches, we do not need to re-evaluate the device effect state\n            // if the same HAL patch is reused (see calls to mAfPatchPanelCallback below)\n            if (endpointPatch) {\n                for (auto& p : mPatches) {\n                    // end point patches are skipped so we do not compare against this patch\n                    if (!p.second.mIsEndpointPatch && patchesHaveSameRoute(\n                            newPatch.mAudioPatch, p.second.mAudioPatch)) {\n                        ALOGV(\"%s() Sw Bridge endpoint reusing halHandle=%d\", __func__,\n                              p.second.mHalHandle);\n                        halHandle = p.second.mHalHandle;\n                        reuseExistingHalPatch = true;\n                        break;\n                    }\n                }\n            }\n            mAfPatchPanelCallback->mutex().unlock();\n",
        "lookback": "            // if the same HAL patch is reused (see calls to mAfPatchPanelCallback below)",
        "lookahead": "            status = thread->sendCreateAudioPatchConfigEvent(patch, &halHandle);",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 414,
        "end_line": 436,
        "merge_gen_region": " For pat, {outputoutputReqPacketoutputoutputReqPacketoutputoutputReqPacketoutputoutputReqPacketoutputoutputReqPacketoutputReqPacketoutputReqPacketoutputReqPacketoutputReqPacketoutputReqPacketoutputReqPacketoutputReqPacketoutputReqPacketoutputReqPacketoutputReqPacketoutputReqPacketoutputReqPacketoutputReqPacketoutputReqPacketoutputReqPacketoutputReqPacketoutputReqPacketoutputReqPacketoutputReqPacketoutputReqPacketoutputReqPacketoutputReqPacketoutputReq bodyReqPacketReq bodyReqPacketReq bodyReqPacketReq bodyReq bodyReq bodyReq bodyReq bodyReq bodyReq bodyReq bodyReq bodyReq bodyReq bodyReq bodyReq bodyReq bodyReq bodyReq bodyReq bodyReq bodyReq bodyReq bodyReq bodyReq bodyReq bodyReq bodyReq bodyReq bodyReq bodyReq bodyReq onlyReq bodyReq onlyReq onlyReq onlyReq onlyReq onlyReq onlyReq onlyReq onlyReq onlyReq onlyReq onlyReq onlyReq onlyReq onlyReq onlyReq onlyReq onlyReq onlyReq onlyReq onlyReq onlyReq onlyReq onlyReq onlyReq onlyReq onlyReq onlyReq onlyReq onlyReq onlyReq onlyReq onlyReq onlyReq onlyReq onlyReq onlyReq onlyReq onlyReq onlyReq onlyReq onlyReq onlyReq only",
        "confidence": 0.9087316393852234,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "            // Check whether the removed patch Hal Handle is used in another non-Endpoint patch.\n            // Since this is a non-Endpoint patch, the removed patch is not considered (it is\n            // removed later from mPatches).\n            if (removedPatch.mIsEndpointPatch) {\n                for (auto& p: mPatches) {\n                    if (!p.second.mIsEndpointPatch\n                            && p.second.mHalHandle == removedPatch.mHalHandle) {\n                        ALOGV(\"%s() Sw Bridge endpoint used existing halHandle=%d, do not release\",\n                              __func__,  p.second.mHalHandle);\n                        doReleasePatch = false;\n                        break;\n                    }\n                }\n            }\n            if (doReleasePatch) {\n                mAfPatchPanelCallback->mutex().unlock();\n                status = thread->sendReleaseAudioPatchConfigEvent(removedPatch.mHalHandle);\n                mAfPatchPanelCallback->mutex().lock();\n            }",
        "b_contents": "            mAfPatchPanelCallback->mutex().unlock();\n            status = thread->sendReleaseAudioPatchConfigEvent(removedPatch.mHalHandle);\n            mAfPatchPanelCallback->mutex().lock();",
        "base_contents": "            mAfPatchPanelCallback->unlock();\n            status = thread->sendReleaseAudioPatchConfigEvent(removedPatch.mHalHandle);\n            mAfPatchPanelCallback->lock();",
        "res_region": "            // Check whether the removed patch Hal Handle is used in another non-Endpoint patch.\n            // Since this is a non-Endpoint patch, the removed patch is not considered (it is\n            // removed later from mPatches).\n            if (removedPatch.mIsEndpointPatch) {\n                for (auto& p: mPatches) {\n                    if (!p.second.mIsEndpointPatch\n                            && p.second.mHalHandle == removedPatch.mHalHandle) {\n                        ALOGV(\"%s() Sw Bridge endpoint used existing halHandle=%d, do not release\",\n                              __func__,  p.second.mHalHandle);\n                        doReleasePatch = false;\n                        break;\n                    }\n                }\n            }\n            if (doReleasePatch) {\n                mAfPatchPanelCallback->mutex().unlock();\n                status = thread->sendReleaseAudioPatchConfigEvent(removedPatch.mHalHandle);\n                mAfPatchPanelCallback->mutex().lock();\n            }",
        "lookback": "            // Since this is a non-Endpoint patch, the removed patch is not considered (it is",
        "lookahead": "        } break;",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 824,
        "end_line": 852,
        "merge_gen_region": "outputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutput",
        "confidence": 0.9035026431083679,
        "hesitated": false,
        "resolved": false
    }
]