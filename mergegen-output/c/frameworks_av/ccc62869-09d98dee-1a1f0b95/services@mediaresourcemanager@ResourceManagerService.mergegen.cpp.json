[
    {
        "a_contents": "std::shared_ptr<DeathNotifier> DeathNotifier::Create(\n    const std::shared_ptr<IResourceManagerClient>& client,\n    const std::shared_ptr<ResourceManagerService>& service,\n    const ClientInfoParcel& clientInfo,\n    bool overrideProcessInfo) {\n    std::shared_ptr<DeathNotifier> deathNotifier = nullptr;\n    if (overrideProcessInfo) {\n        deathNotifier = std::make_shared<OverrideProcessInfoDeathNotifier>(\n            client, service, clientInfo);\n    } else {\n        deathNotifier = std::make_shared<DeathNotifier>(client, service, clientInfo);\n    }\n\n    if (deathNotifier) {\n        deathNotifier->link();\n    }\n\n    return deathNotifier;\n}\n",
        "b_contents": "",
        "base_contents": "template <typename T>\nstatic String8 getString(const std::vector<T>& items) {\n    String8 itemsStr;\n    for (size_t i = 0; i < items.size(); ++i) {\n        itemsStr.appendFormat(\"%s \", toString(items[i]).c_str());\n    }\n    return itemsStr;\n}\n\nstatic bool hasResourceType(MediaResource::Type type, MediaResource::SubType subType,\n        const MediaResourceParcel& resource) {\n    if (type != resource.type) {\n      return false;\n    }\n    switch (type) {\n        // Codec subtypes (e.g. video vs. audio) are each considered separate resources, so\n        // compare the subtypes as well.\n        case MediaResource::Type::kSecureCodec:\n        case MediaResource::Type::kNonSecureCodec:\n            if (resource.subType == subType) {\n                return true;\n            }\n            break;\n        // Non-codec resources are not segregated by the subtype (e.g. video vs. audio).\n        default:\n            return true;\n    }\n    return false;\n}\n\nstatic bool hasResourceType(MediaResource::Type type, MediaResource::SubType subType,\n        const ResourceList& resources) {\n    for (auto it = resources.begin(); it != resources.end(); it++) {\n        if (hasResourceType(type, subType, it->second)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nstatic bool hasResourceType(MediaResource::Type type, MediaResource::SubType subType,\n        const ResourceInfos& infos) {\n    for (const auto& [id, info] : infos) {\n        if (hasResourceType(type, subType, info.resources)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nstatic ResourceInfos& getResourceInfosForEdit(int pid, PidResourceInfosMap& map) {\n    PidResourceInfosMap::iterator found = map.find(pid);\n    if (found == map.end()) {\n        // new pid\n        ResourceInfos infosForPid;\n        auto [it, inserted] = map.emplace(pid, infosForPid);\n        found = it;\n    }\n\n    return found->second;\n}\n\nstatic ResourceInfo& getResourceInfoForEdit(uid_t uid, int64_t clientId,\n                                            const std::string& name,\n        const std::shared_ptr<IResourceManagerClient>& client, ResourceInfos& infos) {\n    ResourceInfos::iterator found = infos.find(clientId);\n\n    if (found == infos.end()) {\n        ResourceInfo info{.uid = uid,\n                          .clientId = clientId,\n                          .name = name.empty()? \"<unknown client>\" : name,\n                          .client = client,\n                          .deathNotifier = nullptr,\n                          .pendingRemoval = false};\n        auto [it, inserted] = infos.emplace(clientId, info);\n        found = it;\n    }\n\n    return found->second;\n}\n",
        "res_region": "std::shared_ptr<DeathNotifier> DeathNotifier::Create(\n    const std::shared_ptr<IResourceManagerClient>& client,\n    const std::shared_ptr<ResourceManagerService>& service,\n    const ClientInfoParcel& clientInfo,\n    bool overrideProcessInfo) {\n    std::shared_ptr<DeathNotifier> deathNotifier = nullptr;\n    if (overrideProcessInfo) {\n        deathNotifier = std::make_shared<OverrideProcessInfoDeathNotifier>(\n            client, service, clientInfo);\n    } else {\n        deathNotifier = std::make_shared<DeathNotifier>(client, service, clientInfo);\n    }\n\n    if (deathNotifier) {\n        deathNotifier->link();\n    }\n\n    return deathNotifier;\n}\n",
        "lookback": "    const std::shared_ptr<IResourceManagerClient>& client,",
        "lookahead": "static void notifyResourceGranted(int pid, const std::vector<MediaResourceParcel>& resources) {",
        "label": [
            "ours",
            "base_empty"
        ],
        "start_line": 169,
        "end_line": 273,
        "merge_gen_region": null,
        "confidence": 0.8269215226173401,
        "hesitated": true
    }
]