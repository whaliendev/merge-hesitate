[
    {
        "a_contents": "static const nsecs_t kDefaultStandbyTimeInNsecs = seconds(3);\n\nstatic nsecs_t getStandbyTimeInNanos() {\n    static nsecs_t standbyTimeInNanos = []() {\n        const int ms = property_get_int32(\"ro.audio.flinger_standbytime_ms\",\n                    kDefaultStandbyTimeInNsecs / NANOS_PER_MILLISECOND);\n        ALOGI(\"%s: Using %d ms as standby time\", __func__, ms);\n        return milliseconds(ms);\n    }();\n    return standbyTimeInNanos;\n}\n\n// Set kEnableExtendedChannels to true to enable greater than stereo output\n// for the MixerThread and device sink.  Number of channels allowed is\n// FCC_2 <= channels <= FCC_LIMIT.\nconstexpr bool kEnableExtendedChannels = true;\n\n// Returns true if channel mask is permitted for the PCM sink in the MixerThread\n/* static */\nbool IAfThreadBase::isValidPcmSinkChannelMask(audio_channel_mask_t channelMask) {\n    switch (audio_channel_mask_get_representation(channelMask)) {\n    case AUDIO_CHANNEL_REPRESENTATION_POSITION: {\n        // Haptic channel mask is only applicable for channel position mask.\n        const uint32_t channelCount = audio_channel_count_from_out_mask(\n                static_cast<audio_channel_mask_t>(channelMask & ~AUDIO_CHANNEL_HAPTIC_ALL));\n        const uint32_t maxChannelCount = kEnableExtendedChannels\n                ? FCC_LIMIT : FCC_2;\n        if (channelCount < FCC_2 // mono is not supported at this time\n                || channelCount > maxChannelCount) {\n            return false;\n        }\n        // check that channelMask is the \"canonical\" one we expect for the channelCount.\n        return audio_channel_position_mask_is_out_canonical(channelMask);\n        }\n    case AUDIO_CHANNEL_REPRESENTATION_INDEX:\n        if (kEnableExtendedChannels) {\n            const uint32_t channelCount = audio_channel_count_from_out_mask(channelMask);\n            if (channelCount >= FCC_2 // mono is not supported at this time\n                    && channelCount <= FCC_LIMIT) {\n                return true;\n            }\n        }\n        return false;\n    default:\n        return false;\n    }\n}\n\n// Set kEnableExtendedPrecision to true to use extended precision in MixerThread\nconstexpr bool kEnableExtendedPrecision = true;\n\n// Returns true if format is permitted for the PCM sink in the MixerThread\n/* static */\nbool IAfThreadBase::isValidPcmSinkFormat(audio_format_t format) {\n    switch (format) {\n    case AUDIO_FORMAT_PCM_16_BIT:\n        return true;\n    case AUDIO_FORMAT_PCM_FLOAT:\n    case AUDIO_FORMAT_PCM_24_BIT_PACKED:\n    case AUDIO_FORMAT_PCM_32_BIT:\n    case AUDIO_FORMAT_PCM_8_24_BIT:\n        return kEnableExtendedPrecision;\n    default:\n        return false;\n    }\n}\n",
        "b_contents": "static constexpr nsecs_t kDefaultStandbyTimeInNsecs = seconds(3);\n\nstatic nsecs_t getStandbyTimeInNanos() {\n    static nsecs_t standbyTimeInNanos = []() {\n        const int ms = property_get_int32(\"ro.audio.flinger_standbytime_ms\",\n                    kDefaultStandbyTimeInNsecs / NANOS_PER_MILLISECOND);\n        ALOGI(\"%s: Using %d ms as standby time\", __func__, ms);\n        return milliseconds(ms);\n    }();\n    return standbyTimeInNanos;\n}\n",
        "base_contents": "",
        "res_region": "static const nsecs_t kDefaultStandbyTimeInNsecs = seconds(3);\n\nstatic nsecs_t getStandbyTimeInNanos() {\n    static nsecs_t standbyTimeInNanos = []() {\n        const int ms = property_get_int32(\"ro.audio.flinger_standbytime_ms\",\n                    kDefaultStandbyTimeInNsecs / NANOS_PER_MILLISECOND);\n        ALOGI(\"%s: Using %d ms as standby time\", __func__, ms);\n        return milliseconds(ms);\n    }();\n    return standbyTimeInNanos;\n}\n\n// Set kEnableExtendedChannels to true to enable greater than stereo output\n// for the MixerThread and device sink.  Number of channels allowed is\n// FCC_2 <= channels <= FCC_LIMIT.\nconstexpr bool kEnableExtendedChannels = true;\n\n// Returns true if channel mask is permitted for the PCM sink in the MixerThread\n/* static */\nbool IAfThreadBase::isValidPcmSinkChannelMask(audio_channel_mask_t channelMask) {\n    switch (audio_channel_mask_get_representation(channelMask)) {\n    case AUDIO_CHANNEL_REPRESENTATION_POSITION: {\n        // Haptic channel mask is only applicable for channel position mask.\n        const uint32_t channelCount = audio_channel_count_from_out_mask(\n                static_cast<audio_channel_mask_t>(channelMask & ~AUDIO_CHANNEL_HAPTIC_ALL));\n        const uint32_t maxChannelCount = kEnableExtendedChannels\n                ? FCC_LIMIT : FCC_2;\n        if (channelCount < FCC_2 // mono is not supported at this time\n                || channelCount > maxChannelCount) {\n            return false;\n        }\n        // check that channelMask is the \"canonical\" one we expect for the channelCount.\n        return audio_channel_position_mask_is_out_canonical(channelMask);\n        }\n    case AUDIO_CHANNEL_REPRESENTATION_INDEX:\n        if (kEnableExtendedChannels) {\n            const uint32_t channelCount = audio_channel_count_from_out_mask(channelMask);\n            if (channelCount >= FCC_2 // mono is not supported at this time\n                    && channelCount <= FCC_LIMIT) {\n                return true;\n            }\n        }\n        return false;\n    default:\n        return false;\n    }\n}\n\n// Set kEnableExtendedPrecision to true to use extended precision in MixerThread\nconstexpr bool kEnableExtendedPrecision = true;\n\n// Returns true if format is permitted for the PCM sink in the MixerThread\n/* static */\nbool IAfThreadBase::isValidPcmSinkFormat(audio_format_t format) {\n    switch (format) {\n    case AUDIO_FORMAT_PCM_16_BIT:\n        return true;\n    case AUDIO_FORMAT_PCM_FLOAT:\n    case AUDIO_FORMAT_PCM_24_BIT_PACKED:\n    case AUDIO_FORMAT_PCM_32_BIT:\n    case AUDIO_FORMAT_PCM_8_24_BIT:\n        return kEnableExtendedPrecision;\n    default:\n        return false;\n    }\n}\n",
        "lookback": "",
        "lookahead": "// ----------------------------------------------------------------------------",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 245,
        "end_line": 327,
        "merge_gen_region": " constsecstStandTimeInsecstStandTimeN =(); n_ getbyInos { n_ standbyInos [] { int =__32ro...lingerstandby_\",StandTimeN /OSPERMILLISE);Is: % ms asby\",func ms return(); millisecondsms } returnbyInos } SetEnableChannels true to to greater stereo // theThread and sink Number channels is F_ <= <=CCLIMIT constexpr kExtended =; Returns if mask permitted the PCM in theThread /* */ IAThread::PSinkMaskaudiochannelmasktMask { (_______(Mask)) case_CHANNELREATIONPOSITION { H channel mask only for position. uint_ channelCount audiochannelcountfromoutmask staticcastaudiochannelmasktchannel &AUDIOCHANNELHAP_)); const32tChannel =EnableChannels ?CCLIMIT F_; (Count FCC2 mono not at time channel at time channel >Channel) return false } check channelMask thecanonical one expect the channel. audiochannelpositionmaskisoutcanonicalchannel); case__PRESENT__PRESENT_: ifkExtended) const32tCount audiochannelcountfromoutmaskchannel); (Count >=CC2 mono not at time channel",
        "confidence": 0.9366574883460999,
        "hesitated": false,
        "resolved": false
    }
]