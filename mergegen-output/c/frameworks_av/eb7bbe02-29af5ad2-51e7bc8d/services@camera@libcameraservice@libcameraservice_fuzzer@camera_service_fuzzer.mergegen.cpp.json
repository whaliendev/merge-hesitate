[
    {
        "a_contents": "void CameraFuzzer::invokeCameraAPIs() {\n    /** In order to avoid the timeout issue caused due to multiple iteration of loops, the 'for'\n     * loops are removed and the 'cameraId', 'pictureSize' and 'videoSize' are derived using the\n     * FuzzedDataProvider from the available cameras and vectors of 'pictureSizes' and 'videoSizes'\n     */\n    int32_t cameraId = mFuzzedDataProvider->ConsumeIntegralInRange<int32_t>(0, mNumCameras - 1);\n    getCameraInformation(cameraId);\n    invokeTorchAPIs(cameraId);\n\n    ::android::binder::Status rc;\n    sp<ICamera> cameraDevice;\n\n    rc = mCameraService->connect(this, cameraId, std::string(),\n                                 android::CameraService::USE_CALLING_UID,\n                                 android::CameraService::USE_CALLING_PID,\n                                 /*targetSdkVersion*/ __ANDROID_API_FUTURE__,\n                                 /*overrideToPortrait*/true, /*forceSlowJpegMode*/false,\n                                 &cameraDevice);\n    if (!rc.isOk()) {\n        // camera not connected\n        return;\n    }\n    if (cameraDevice) {\n        sp<Surface> previewSurface;\n        sp<SurfaceControl> surfaceControl;\n        CameraParameters params(cameraDevice->getParameters());\n        String8 focusModes(params.get(CameraParameters::KEY_SUPPORTED_FOCUS_MODES));\n        bool isAFSupported = false;\n        const char* focusMode = nullptr;\n\n        if (focusModes.contains(CameraParameters::FOCUS_MODE_AUTO)) {\n            isAFSupported = true;\n        } else if (focusModes.contains(CameraParameters::FOCUS_MODE_CONTINUOUS_PICTURE)) {\n            isAFSupported = true;\n            focusMode = CameraParameters::FOCUS_MODE_CONTINUOUS_PICTURE;\n        } else if (focusModes.contains(CameraParameters::FOCUS_MODE_CONTINUOUS_VIDEO)) {\n            isAFSupported = true;\n            focusMode = CameraParameters::FOCUS_MODE_CONTINUOUS_VIDEO;\n        } else if (focusModes.contains(CameraParameters::FOCUS_MODE_MACRO)) {\n            isAFSupported = true;\n            focusMode = CameraParameters::FOCUS_MODE_MACRO;",
        "b_contents": "        rc = mCameraService->connect(this, cameraId, std::string(),\n                android::CameraService::USE_CALLING_UID, android::CameraService::USE_CALLING_PID,\n                /*targetSdkVersion*/__ANDROID_API_FUTURE__, /*overrideToPortrait*/true,\n                /*forceSlowJpegMode*/false,\n                &cameraDevice);\n        if (!rc.isOk()) {\n            // camera not connected\n            return;",
        "base_contents": "        rc = mCameraService->connect(this, cameraId, String16(),\n                android::CameraService::USE_CALLING_UID, android::CameraService::USE_CALLING_PID,\n                /*targetSdkVersion*/__ANDROID_API_FUTURE__, /*overrideToPortrait*/true,\n                /*forceSlowJpegMode*/false,\n                &cameraDevice);\n        if (!rc.isOk()) {\n            // camera not connected\n            return;",
        "res_region": "void CameraFuzzer::invokeCameraAPIs() {\n    /** In order to avoid the timeout issue caused due to multiple iteration of loops, the 'for'\n     * loops are removed and the 'cameraId', 'pictureSize' and 'videoSize' are derived using the\n     * FuzzedDataProvider from the available cameras and vectors of 'pictureSizes' and 'videoSizes'\n     */\n    int32_t cameraId = mFuzzedDataProvider->ConsumeIntegralInRange<int32_t>(0, mNumCameras - 1);\n    getCameraInformation(cameraId);\n    invokeTorchAPIs(cameraId);\n\n    ::android::binder::Status rc;\n    sp<ICamera> cameraDevice;\n\n    rc = mCameraService->connect(this, cameraId, std::string(),\n                                 android::CameraService::USE_CALLING_UID,\n                                 android::CameraService::USE_CALLING_PID,\n                                 /*targetSdkVersion*/ __ANDROID_API_FUTURE__,\n                                 /*overrideToPortrait*/true, /*forceSlowJpegMode*/false,\n                                 &cameraDevice);\n    if (!rc.isOk()) {\n        // camera not connected\n        return;\n    }\n    if (cameraDevice) {\n        sp<Surface> previewSurface;\n        sp<SurfaceControl> surfaceControl;\n        CameraParameters params(cameraDevice->getParameters());\n        String8 focusModes(params.get(CameraParameters::KEY_SUPPORTED_FOCUS_MODES));\n        bool isAFSupported = false;\n        const char* focusMode = nullptr;\n\n        if (focusModes.contains(CameraParameters::FOCUS_MODE_AUTO)) {\n            isAFSupported = true;\n        } else if (focusModes.contains(CameraParameters::FOCUS_MODE_CONTINUOUS_PICTURE)) {\n            isAFSupported = true;\n            focusMode = CameraParameters::FOCUS_MODE_CONTINUOUS_PICTURE;\n        } else if (focusModes.contains(CameraParameters::FOCUS_MODE_CONTINUOUS_VIDEO)) {\n            isAFSupported = true;\n            focusMode = CameraParameters::FOCUS_MODE_CONTINUOUS_VIDEO;\n        } else if (focusModes.contains(CameraParameters::FOCUS_MODE_MACRO)) {\n            isAFSupported = true;\n            focusMode = CameraParameters::FOCUS_MODE_MACRO;",
        "lookback": "    /** In order to avoid the timeout issue caused due to multiple iteration of loops, the 'for'",
        "lookahead": "        }",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 332,
        "end_line": 392,
        "merge_gen_region": null,
        "confidence": 0.874471127986908,
        "hesitated": true
    }
]