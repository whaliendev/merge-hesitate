[
    {
        "a_contents": "\n            tempTouchState.addOrUpdateWindow(windowHandle, targetFlags, pointerIds,\n                                             entry.eventTime);\n\n            // If this is the pointer going down and the touched window has a wallpaper\n            // then also add the touched wallpaper windows so they are locked in for the duration\n            // of the touch gesture.\n            // We do not collect wallpapers during HOVER_MOVE or SCROLL because the wallpaper\n            // engine only supports touch events.  We would need to add a mechanism similar\n            // to View.onGenericMotionEvent to enable wallpapers to handle these events.\n            if (maskedAction == AMOTION_EVENT_ACTION_DOWN ||\n                maskedAction == AMOTION_EVENT_ACTION_POINTER_DOWN) {\n                if (targetFlags.test(InputTarget::Flags::FOREGROUND) &&\n                    windowHandle->getInfo()->inputConfig.test(\n                            gui::WindowInfo::InputConfig::DUPLICATE_TOUCH_TO_WALLPAPER)) {\n                    sp<WindowInfoHandle> wallpaper = findWallpaperWindowBelow(windowHandle);\n                    if (wallpaper != nullptr) {\n                        ftl::Flags<InputTarget::Flags> wallpaperFlags =\n                                InputTarget::Flags::WINDOW_IS_OBSCURED |\n                                InputTarget::Flags::WINDOW_IS_PARTIALLY_OBSCURED |\n                                InputTarget::Flags::DISPATCH_AS_IS;\n                        if (isSplit) {\n                            wallpaperFlags |= InputTarget::Flags::SPLIT;\n                        }\n                        tempTouchState.addOrUpdateWindow(wallpaper, wallpaperFlags, pointerIds,\n                                                         entry.eventTime);\n                    }\n                }\n            }\n        }\n\n        // If any existing window is pilfering pointers from newly added window, remove it\n        BitSet32 canceledPointers = BitSet32(0);\n        for (const TouchedWindow& window : tempTouchState.windows) {\n            if (window.isPilferingPointers) {\n                canceledPointers |= window.pointerIds;\n            }",
        "b_contents": "            tempTouchState.addOrUpdateWindow(windowHandle, targetFlags, pointerIds);\n\n            // If this is the pointer going down and the touched window has a wallpaper\n            // then also add the touched wallpaper windows so they are locked in for the duration\n            // of the touch gesture.\n            // We do not collect wallpapers during HOVER_MOVE or SCROLL because the wallpaper\n            // engine only supports touch events.  We would need to add a mechanism similar\n            // to View.onGenericMotionEvent to enable wallpapers to handle these events.\n            if (maskedAction == AMOTION_EVENT_ACTION_DOWN ||\n                maskedAction == AMOTION_EVENT_ACTION_POINTER_DOWN) {\n                if ((targetFlags & InputTarget::FLAG_FOREGROUND) &&\n                    windowHandle->getInfo()->inputConfig.test(\n                            gui::WindowInfo::InputConfig::DUPLICATE_TOUCH_TO_WALLPAPER)) {\n                    sp<WindowInfoHandle> wallpaper = findWallpaperWindowBelow(windowHandle);\n                    if (wallpaper != nullptr) {\n                        int32_t wallpaperFlags = InputTarget::FLAG_WINDOW_IS_OBSCURED |\n                                InputTarget::FLAG_WINDOW_IS_PARTIALLY_OBSCURED |\n                                InputTarget::FLAG_DISPATCH_AS_IS;\n                        if (isSplit) {\n                            wallpaperFlags |= InputTarget::FLAG_SPLIT;\n                        }\n                        tempTouchState.addOrUpdateWindow(wallpaper, wallpaperFlags, pointerIds);\n                    }\n                }\n            }",
        "base_contents": "\n            tempTouchState.addOrUpdateWindow(windowHandle, targetFlags, pointerIds);",
        "res_region": "\n            tempTouchState.addOrUpdateWindow(windowHandle, targetFlags, pointerIds,\n                                             entry.eventTime);\n\n            // If this is the pointer going down and the touched window has a wallpaper\n            // then also add the touched wallpaper windows so they are locked in for the duration\n            // of the touch gesture.\n            // We do not collect wallpapers during HOVER_MOVE or SCROLL because the wallpaper\n            // engine only supports touch events.  We would need to add a mechanism similar\n            // to View.onGenericMotionEvent to enable wallpapers to handle these events.\n            if (maskedAction == AMOTION_EVENT_ACTION_DOWN ||\n                maskedAction == AMOTION_EVENT_ACTION_POINTER_DOWN) {\n                if (targetFlags.test(InputTarget::Flags::FOREGROUND) &&\n                    windowHandle->getInfo()->inputConfig.test(\n                            gui::WindowInfo::InputConfig::DUPLICATE_TOUCH_TO_WALLPAPER)) {\n                    sp<WindowInfoHandle> wallpaper = findWallpaperWindowBelow(windowHandle);\n                    if (wallpaper != nullptr) {\n                        ftl::Flags<InputTarget::Flags> wallpaperFlags =\n                                InputTarget::Flags::WINDOW_IS_OBSCURED |\n                                InputTarget::Flags::WINDOW_IS_PARTIALLY_OBSCURED |\n                                InputTarget::Flags::DISPATCH_AS_IS;\n                        if (isSplit) {\n                            wallpaperFlags |= InputTarget::Flags::SPLIT;\n                        }\n                        tempTouchState.addOrUpdateWindow(wallpaper, wallpaperFlags, pointerIds,\n                                                         entry.eventTime);\n                    }\n                }\n            }\n        }\n\n        // If any existing window is pilfering pointers from newly added window, remove it\n        BitSet32 canceledPointers = BitSet32(0);\n        for (const TouchedWindow& window : tempTouchState.windows) {\n            if (window.isPilferingPointers) {\n                canceledPointers |= window.pointerIds;\n            }",
        "lookback": "            tempTouchState.addOrUpdateWindow(windowHandle, targetFlags, pointerIds,",
        "lookahead": "        }",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 2228,
        "end_line": 2295,
        "merge_gen_region": "Touch.OrUpdate(Handle target,Ids tempStateaddUpdate(Handle target,Flags pointer,Ids entryevent); If is is pointer down thehed has wall // also thehedpaper so are in the duration of touch. We not wallpap duringOVERMOVE SC because wall // only touch. We need add mechanism // ViewonGenericEvent enablepap to handle events ifmasked ==MOTIONEVENTACTIONDOWN maskedAction A_____) iftarget.(TargetFlagsFlagsFOROUND &&Handle->Infoinput.(::::::REGWindow::InfoInput::LICATETOUCHTOWALLAPER {<Info>paper findpaperBelowwindow); ifwall !=) f::<TargetFlags wallpaper =TargetFlagsWINDOWISOBURED InputTargetFlagsWINDOWISPARALLYOBURED InputTargetFlagsDISPATCHASIS ifisSplit { wallFlags |=TargetFlagsFlagsSPLIT }Touch.OrUpdate(paper wallFlags pointer,.Time } } // any window isiling from added, itSet canceled =Set320 forconstouWindow window tempStatewindows { (.PferPointers { canceled |=.Ids }",
        "confidence": 0.9432936906814575,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "                tempTouchState.addOrUpdateWindow(newTouchedWindowHandle, targetFlags, pointerIds,\n                                                 entry.eventTime);\n\n                // Check if the wallpaper window should deliver the corresponding event.\n                slipWallpaperTouch(targetFlags, oldTouchedWindowHandle, newTouchedWindowHandle,\n                                   tempTouchState, pointerIds);",
        "b_contents": "                tempTouchState.addOrUpdateWindow(newTouchedWindowHandle, targetFlags, pointerIds);\n\n                // Check if the wallpaper window should deliver the corresponding event.\n                slipWallpaperTouch(targetFlags, oldTouchedWindowHandle, newTouchedWindowHandle,\n                                   tempTouchState, pointerIds);",
        "base_contents": "                tempTouchState.addOrUpdateWindow(newTouchedWindowHandle, targetFlags, pointerIds);",
        "res_region": "                tempTouchState.addOrUpdateWindow(newTouchedWindowHandle, targetFlags, pointerIds,\n                                                 entry.eventTime);\n\n                // Check if the wallpaper window should deliver the corresponding event.\n                slipWallpaperTouch(targetFlags, oldTouchedWindowHandle, newTouchedWindowHandle,\n                                   tempTouchState, pointerIds);",
        "lookback": "                                                 entry.eventTime);",
        "lookahead": "            }",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 2370,
        "end_line": 2385,
        "merge_gen_region": null,
        "confidence": 0.8581097722053528,
        "hesitated": true
    },
    {
        "a_contents": "        const nsecs_t downTime, const sp<Connection>& connection,\n        ftl::Flags<InputTarget::Flags> targetFlags) {",
        "b_contents": "        const sp<Connection>& connection, int32_t targetFlags) {",
        "base_contents": "        const sp<Connection>& connection) {",
        "res_region": "        const nsecs_t downTime, const sp<Connection>& connection,\n        ftl::Flags<InputTarget::Flags> targetFlags) {",
        "lookback": "        ftl::Flags<InputTarget::Flags> targetFlags) {",
        "lookahead": "    if (connection->status == Connection::Status::BROKEN) {",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 3773,
        "end_line": 3780,
        "merge_gen_region": null,
        "confidence": 0.8715616464614868,
        "hesitated": true
    },
    {
        "a_contents": "            synthesizePointerDownEventsForConnectionLocked(downTimeInTarget, toConnection,\n                                                           newTargetFlags);",
        "b_contents": "            synthesizePointerDownEventsForConnectionLocked(toConnection, newTargetFlags);\n            // Check if the wallpaper window should deliver the corresponding event.\n            transferWallpaperTouch(oldTargetFlags, newTargetFlags, fromWindowHandle, toWindowHandle,\n                                   *state, pointerIds);\n        }",
        "base_contents": "            synthesizePointerDownEventsForConnectionLocked(toConnection);\n        }",
        "res_region": "            synthesizePointerDownEventsForConnectionLocked(downTimeInTarget, toConnection,\n                                                           newTargetFlags);",
        "lookback": "                                                           newTargetFlags);",
        "lookahead": "",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 5255,
        "end_line": 5267,
        "merge_gen_region": null,
        "confidence": 0.6141465902328491,
        "hesitated": true
    },
    {
        "a_contents": "void InputDispatcher::slipWallpaperTouch(ftl::Flags<InputTarget::Flags> targetFlags,\n                                         const sp<WindowInfoHandle>& oldWindowHandle,\n                                         const sp<WindowInfoHandle>& newWindowHandle,\n                                         TouchState& state, const BitSet32& pointerIds) {\n    const bool oldHasWallpaper = oldWindowHandle->getInfo()->inputConfig.test(\n            gui::WindowInfo::InputConfig::DUPLICATE_TOUCH_TO_WALLPAPER);\n    const bool newHasWallpaper = targetFlags.test(InputTarget::Flags::FOREGROUND) &&\n            newWindowHandle->getInfo()->inputConfig.test(\n                    gui::WindowInfo::InputConfig::DUPLICATE_TOUCH_TO_WALLPAPER);\n    const sp<WindowInfoHandle> oldWallpaper =\n            oldHasWallpaper ? state.getWallpaperWindow() : nullptr;\n    const sp<WindowInfoHandle> newWallpaper =\n            newHasWallpaper ? findWallpaperWindowBelow(newWindowHandle) : nullptr;\n    if (oldWallpaper == newWallpaper) {\n        return;\n    }\n\n    if (oldWallpaper != nullptr) {\n        state.addOrUpdateWindow(oldWallpaper, InputTarget::Flags::DISPATCH_AS_SLIPPERY_EXIT,\n                                BitSet32(0));\n    }\n\n    if (newWallpaper != nullptr) {\n        state.addOrUpdateWindow(newWallpaper,\n                                InputTarget::Flags::DISPATCH_AS_SLIPPERY_ENTER |\n                                        InputTarget::Flags::WINDOW_IS_OBSCURED |\n                                        InputTarget::Flags::WINDOW_IS_PARTIALLY_OBSCURED,\n                                pointerIds);\n    }\n}\n\nvoid InputDispatcher::transferWallpaperTouch(ftl::Flags<InputTarget::Flags> oldTargetFlags,\n                                             ftl::Flags<InputTarget::Flags> newTargetFlags,\n                                             const sp<WindowInfoHandle> fromWindowHandle,\n                                             const sp<WindowInfoHandle> toWindowHandle,\n                                             TouchState& state, const BitSet32& pointerIds) {\n    const bool oldHasWallpaper = oldTargetFlags.test(InputTarget::Flags::FOREGROUND) &&\n            fromWindowHandle->getInfo()->inputConfig.test(\n                    gui::WindowInfo::InputConfig::DUPLICATE_TOUCH_TO_WALLPAPER);\n    const bool newHasWallpaper = newTargetFlags.test(InputTarget::Flags::FOREGROUND) &&\n            toWindowHandle->getInfo()->inputConfig.test(\n                    gui::WindowInfo::InputConfig::DUPLICATE_TOUCH_TO_WALLPAPER);\n\n    const sp<WindowInfoHandle> oldWallpaper =\n            oldHasWallpaper ? state.getWallpaperWindow() : nullptr;\n    const sp<WindowInfoHandle> newWallpaper =\n            newHasWallpaper ? findWallpaperWindowBelow(toWindowHandle) : nullptr;\n    if (oldWallpaper == newWallpaper) {\n        return;\n    }\n\n    if (oldWallpaper != nullptr) {\n        CancelationOptions options(CancelationOptions::Mode::CANCEL_POINTER_EVENTS,\n                                   \"transferring touch focus to another window\");\n        state.removeWindowByToken(oldWallpaper->getToken());\n        synthesizeCancelationEventsForWindowLocked(oldWallpaper, options);\n    }\n\n    if (newWallpaper != nullptr) {\n        nsecs_t downTimeInTarget = now();\n        ftl::Flags<InputTarget::Flags> wallpaperFlags =\n                oldTargetFlags & (InputTarget::Flags::SPLIT | InputTarget::Flags::DISPATCH_AS_IS);\n        wallpaperFlags |= InputTarget::Flags::WINDOW_IS_OBSCURED |\n                InputTarget::Flags::WINDOW_IS_PARTIALLY_OBSCURED;\n        state.addOrUpdateWindow(newWallpaper, wallpaperFlags, pointerIds, downTimeInTarget);\n        sp<Connection> wallpaperConnection = getConnectionLocked(newWallpaper->getToken());\n        if (wallpaperConnection != nullptr) {\n            sp<Connection> toConnection = getConnectionLocked(toWindowHandle->getToken());\n            toConnection->inputState.mergePointerStateTo(wallpaperConnection->inputState);\n            synthesizePointerDownEventsForConnectionLocked(downTimeInTarget, wallpaperConnection,\n                                                           wallpaperFlags);\n        }\n    }\n}\n\nsp<WindowInfoHandle> InputDispatcher::findWallpaperWindowBelow(\n        const sp<WindowInfoHandle>& windowHandle) const {\n    const std::vector<sp<WindowInfoHandle>>& windowHandles =\n            getWindowHandlesLocked(windowHandle->getInfo()->displayId);\n    bool foundWindow = false;\n    for (const sp<WindowInfoHandle>& otherHandle : windowHandles) {\n        if (!foundWindow && otherHandle != windowHandle) {\n            continue;\n        }\n        if (windowHandle == otherHandle) {\n            foundWindow = true;\n            continue;\n        }\n\n        if (otherHandle->getInfo()->inputConfig.test(WindowInfo::InputConfig::IS_WALLPAPER)) {\n            return otherHandle;\n        }\n    }\n    return nullptr;\n}\n",
        "b_contents": "void InputDispatcher::slipWallpaperTouch(int32_t targetFlags,\n                                         const sp<WindowInfoHandle>& oldWindowHandle,\n                                         const sp<WindowInfoHandle>& newWindowHandle,\n                                         TouchState& state, const BitSet32& pointerIds) {\n    const bool oldHasWallpaper = oldWindowHandle->getInfo()->inputConfig.test(\n            gui::WindowInfo::InputConfig::DUPLICATE_TOUCH_TO_WALLPAPER);\n    const bool newHasWallpaper = (targetFlags & InputTarget::FLAG_FOREGROUND) &&\n            newWindowHandle->getInfo()->inputConfig.test(\n                    gui::WindowInfo::InputConfig::DUPLICATE_TOUCH_TO_WALLPAPER);\n    const sp<WindowInfoHandle> oldWallpaper =\n            oldHasWallpaper ? state.getWallpaperWindow() : nullptr;\n    const sp<WindowInfoHandle> newWallpaper =\n            newHasWallpaper ? findWallpaperWindowBelow(newWindowHandle) : nullptr;\n    if (oldWallpaper == newWallpaper) {\n        return;\n    }\n\n    if (oldWallpaper != nullptr) {\n        state.addOrUpdateWindow(oldWallpaper, InputTarget::FLAG_DISPATCH_AS_SLIPPERY_EXIT,\n                                BitSet32(0));\n    }\n\n    if (newWallpaper != nullptr) {\n        state.addOrUpdateWindow(newWallpaper,\n                                InputTarget::FLAG_DISPATCH_AS_SLIPPERY_ENTER |\n                                        InputTarget::FLAG_WINDOW_IS_OBSCURED |\n                                        InputTarget::FLAG_WINDOW_IS_PARTIALLY_OBSCURED,\n                                pointerIds);\n    }\n}\n\nvoid InputDispatcher::transferWallpaperTouch(int32_t oldTargetFlags, int32_t newTargetFlags,\n                                             const sp<WindowInfoHandle> fromWindowHandle,\n                                             const sp<WindowInfoHandle> toWindowHandle,\n                                             TouchState& state, const BitSet32& pointerIds) {\n    const bool oldHasWallpaper = (oldTargetFlags & InputTarget::FLAG_FOREGROUND) &&\n            fromWindowHandle->getInfo()->inputConfig.test(\n                    gui::WindowInfo::InputConfig::DUPLICATE_TOUCH_TO_WALLPAPER);\n    const bool newHasWallpaper = (newTargetFlags & InputTarget::FLAG_FOREGROUND) &&\n            toWindowHandle->getInfo()->inputConfig.test(\n                    gui::WindowInfo::InputConfig::DUPLICATE_TOUCH_TO_WALLPAPER);\n\n    const sp<WindowInfoHandle> oldWallpaper =\n            oldHasWallpaper ? state.getWallpaperWindow() : nullptr;\n    const sp<WindowInfoHandle> newWallpaper =\n            newHasWallpaper ? findWallpaperWindowBelow(toWindowHandle) : nullptr;\n    if (oldWallpaper == newWallpaper) {\n        return;\n    }\n\n    if (oldWallpaper != nullptr) {\n        CancelationOptions options(CancelationOptions::Mode::CANCEL_POINTER_EVENTS,\n                                   \"transferring touch focus to another window\");\n        state.removeWindowByToken(oldWallpaper->getToken());\n        synthesizeCancelationEventsForWindowLocked(oldWallpaper, options);\n    }\n\n    if (newWallpaper != nullptr) {\n        int32_t wallpaperFlags =\n                oldTargetFlags & (InputTarget::FLAG_SPLIT | InputTarget::FLAG_DISPATCH_AS_IS);\n        wallpaperFlags |= InputTarget::FLAG_WINDOW_IS_OBSCURED |\n                InputTarget::FLAG_WINDOW_IS_PARTIALLY_OBSCURED;\n        state.addOrUpdateWindow(newWallpaper, wallpaperFlags, pointerIds);\n        sp<Connection> wallpaperConnection = getConnectionLocked(newWallpaper->getToken());\n        if (wallpaperConnection != nullptr) {\n            sp<Connection> toConnection = getConnectionLocked(toWindowHandle->getToken());\n            toConnection->inputState.mergePointerStateTo(wallpaperConnection->inputState);\n            synthesizePointerDownEventsForConnectionLocked(wallpaperConnection, wallpaperFlags);\n        }\n    }\n}\n\nsp<WindowInfoHandle> InputDispatcher::findWallpaperWindowBelow(\n        const sp<WindowInfoHandle>& windowHandle) const {\n    const std::vector<sp<WindowInfoHandle>>& windowHandles =\n            getWindowHandlesLocked(windowHandle->getInfo()->displayId);\n    bool foundWindow = false;\n    for (const sp<WindowInfoHandle>& otherHandle : windowHandles) {\n        if (!foundWindow && otherHandle != windowHandle) {\n            continue;\n        }\n        if (windowHandle == otherHandle) {\n            foundWindow = true;\n            continue;\n        }\n\n        if (otherHandle->getInfo()->inputConfig.test(WindowInfo::InputConfig::IS_WALLPAPER)) {\n            return otherHandle;\n        }\n    }\n    return nullptr;\n}\n",
        "base_contents": "",
        "res_region": "void InputDispatcher::slipWallpaperTouch(ftl::Flags<InputTarget::Flags> targetFlags,\n                                         const sp<WindowInfoHandle>& oldWindowHandle,\n                                         const sp<WindowInfoHandle>& newWindowHandle,\n                                         TouchState& state, const BitSet32& pointerIds) {\n    const bool oldHasWallpaper = oldWindowHandle->getInfo()->inputConfig.test(\n            gui::WindowInfo::InputConfig::DUPLICATE_TOUCH_TO_WALLPAPER);\n    const bool newHasWallpaper = targetFlags.test(InputTarget::Flags::FOREGROUND) &&\n            newWindowHandle->getInfo()->inputConfig.test(\n                    gui::WindowInfo::InputConfig::DUPLICATE_TOUCH_TO_WALLPAPER);\n    const sp<WindowInfoHandle> oldWallpaper =\n            oldHasWallpaper ? state.getWallpaperWindow() : nullptr;\n    const sp<WindowInfoHandle> newWallpaper =\n            newHasWallpaper ? findWallpaperWindowBelow(newWindowHandle) : nullptr;\n    if (oldWallpaper == newWallpaper) {\n        return;\n    }\n\n    if (oldWallpaper != nullptr) {\n        state.addOrUpdateWindow(oldWallpaper, InputTarget::Flags::DISPATCH_AS_SLIPPERY_EXIT,\n                                BitSet32(0));\n    }\n\n    if (newWallpaper != nullptr) {\n        state.addOrUpdateWindow(newWallpaper,\n                                InputTarget::Flags::DISPATCH_AS_SLIPPERY_ENTER |\n                                        InputTarget::Flags::WINDOW_IS_OBSCURED |\n                                        InputTarget::Flags::WINDOW_IS_PARTIALLY_OBSCURED,\n                                pointerIds);\n    }\n}\n\nvoid InputDispatcher::transferWallpaperTouch(ftl::Flags<InputTarget::Flags> oldTargetFlags,\n                                             ftl::Flags<InputTarget::Flags> newTargetFlags,\n                                             const sp<WindowInfoHandle> fromWindowHandle,\n                                             const sp<WindowInfoHandle> toWindowHandle,\n                                             TouchState& state, const BitSet32& pointerIds) {\n    const bool oldHasWallpaper = oldTargetFlags.test(InputTarget::Flags::FOREGROUND) &&\n            fromWindowHandle->getInfo()->inputConfig.test(\n                    gui::WindowInfo::InputConfig::DUPLICATE_TOUCH_TO_WALLPAPER);\n    const bool newHasWallpaper = newTargetFlags.test(InputTarget::Flags::FOREGROUND) &&\n            toWindowHandle->getInfo()->inputConfig.test(\n                    gui::WindowInfo::InputConfig::DUPLICATE_TOUCH_TO_WALLPAPER);\n\n    const sp<WindowInfoHandle> oldWallpaper =\n            oldHasWallpaper ? state.getWallpaperWindow() : nullptr;\n    const sp<WindowInfoHandle> newWallpaper =\n            newHasWallpaper ? findWallpaperWindowBelow(toWindowHandle) : nullptr;\n    if (oldWallpaper == newWallpaper) {\n        return;\n    }\n\n    if (oldWallpaper != nullptr) {\n        CancelationOptions options(CancelationOptions::Mode::CANCEL_POINTER_EVENTS,\n                                   \"transferring touch focus to another window\");\n        state.removeWindowByToken(oldWallpaper->getToken());\n        synthesizeCancelationEventsForWindowLocked(oldWallpaper, options);\n    }\n\n    if (newWallpaper != nullptr) {\n        nsecs_t downTimeInTarget = now();\n        ftl::Flags<InputTarget::Flags> wallpaperFlags =\n                oldTargetFlags & (InputTarget::Flags::SPLIT | InputTarget::Flags::DISPATCH_AS_IS);\n        wallpaperFlags |= InputTarget::Flags::WINDOW_IS_OBSCURED |\n                InputTarget::Flags::WINDOW_IS_PARTIALLY_OBSCURED;\n        state.addOrUpdateWindow(newWallpaper, wallpaperFlags, pointerIds, downTimeInTarget);\n        sp<Connection> wallpaperConnection = getConnectionLocked(newWallpaper->getToken());\n        if (wallpaperConnection != nullptr) {\n            sp<Connection> toConnection = getConnectionLocked(toWindowHandle->getToken());\n            toConnection->inputState.mergePointerStateTo(wallpaperConnection->inputState);\n            synthesizePointerDownEventsForConnectionLocked(downTimeInTarget, wallpaperConnection,\n                                                           wallpaperFlags);\n        }\n    }\n}\n\nsp<WindowInfoHandle> InputDispatcher::findWallpaperWindowBelow(\n        const sp<WindowInfoHandle>& windowHandle) const {\n    const std::vector<sp<WindowInfoHandle>>& windowHandles =\n            getWindowHandlesLocked(windowHandle->getInfo()->displayId);\n    bool foundWindow = false;\n    for (const sp<WindowInfoHandle>& otherHandle : windowHandles) {\n        if (!foundWindow && otherHandle != windowHandle) {\n            continue;\n        }\n        if (windowHandle == otherHandle) {\n            foundWindow = true;\n            continue;\n        }\n\n        if (otherHandle->getInfo()->inputConfig.test(WindowInfo::InputConfig::IS_WALLPAPER)) {\n            return otherHandle;\n        }\n    }\n    return nullptr;\n}\n",
        "lookback": "                                         const sp<WindowInfoHandle>& oldWindowHandle,",
        "lookahead": "} // namespace android::inputdispatcher",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 6549,
        "end_line": 6741,
        "merge_gen_region": " Input::lippaper(l::<Target::>Flags, spWindowHandle>&Window, spWindowHandle>&Window, spWindowHandle>&WindowHandle Touch&, Bit32 pointer) const oldWall = oldHandle->->Infoinput.(::::Info::ConfigDUP___PAPER const boolHaspaper target.(Target::::::REG) newHandleget()->input.test guiWindow::::Config::LICATETOUCHTOWALLAPER const boolHaspaper target.(Input::::::REGROUND &&WindowHandleget()->input.test guiWindow::::ConfigDUP____PAPER const<Info>Wall = oldWall ?.Wall_,REG) newHandleget()-> :.(::Info; (Wall ==Wall) return } ifoldWall !=) stateaddUpdate(oldpaper Inputpaper Input::::::___PYEXIT Bit320 } ifoldpaper nullptrWall !=) stateaddUpdate(Wall,Target::::__SCD InputTargetFlagsWINDOWISPARALLYOBURED pointer); } voidDispatchertransferpaper(lFlagsInput::>Target,tlFlagsFlagsInput::>Target, spWindowHandle fromHandle const<Info>WindowHandle const<Info>WindowHandle const",
        "confidence": 0.9159119129180908,
        "hesitated": false,
        "resolved": false
    }
]