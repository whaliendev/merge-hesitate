[
    {
        "a_contents": "/** Ensure consistent behavior of InputDispatcher in all orientations. */\nclass InputDispatcherDisplayOrientationFixture\n      : public InputDispatcherDisplayProjectionTest,\n        public ::testing::WithParamInterface<ui::Rotation> {};\n\n// This test verifies the touchable region of a window for all rotations of the display by tapping\n// in different locations on the display, specifically points close to the four corners of a\n// window.\nTEST_P(InputDispatcherDisplayOrientationFixture, HitTestInDifferentOrientations) {\n    constexpr static int32_t displayWidth = 400;\n    constexpr static int32_t displayHeight = 800;\n\n    std::shared_ptr<FakeApplicationHandle> application = std::make_shared<FakeApplicationHandle>();\n\n    const auto rotation = GetParam();\n\n    // Set up the display with the specified rotation.\n    const bool isRotated = rotation == ui::ROTATION_90 || rotation == ui::ROTATION_270;\n    const int32_t logicalDisplayWidth = isRotated ? displayHeight : displayWidth;\n    const int32_t logicalDisplayHeight = isRotated ? displayWidth : displayHeight;\n    const ui::Transform displayTransform(ui::Transform::toRotationFlags(rotation),\n                                         logicalDisplayWidth, logicalDisplayHeight);\n    addDisplayInfo(ADISPLAY_ID_DEFAULT, displayTransform);\n\n    // Create a window with its bounds determined in the logical display.\n    const Rect frameInLogicalDisplay(100, 100, 200, 300);\n    const Rect frameInDisplay = displayTransform.inverse().transform(frameInLogicalDisplay);\n    sp<FakeWindowHandle> window =\n            sp<FakeWindowHandle>::make(application, mDispatcher, \"Window\", ADISPLAY_ID_DEFAULT);\n    window->setFrame(frameInDisplay, displayTransform);\n    addWindow(window);\n\n    // The following points in logical display space should be inside the window.\n    static const std::array<vec2, 4> insidePoints{\n            {{100, 100}, {199.99, 100}, {100, 299.99}, {199.99, 299.99}}};\n    for (const auto pointInsideWindow : insidePoints) {\n        const vec2 p = displayTransform.inverse().transform(pointInsideWindow);\n        const PointF pointInDisplaySpace{p.x, p.y};\n        const auto down = generateMotionArgs(AMOTION_EVENT_ACTION_DOWN, AINPUT_SOURCE_TOUCHSCREEN,\n                                             ADISPLAY_ID_DEFAULT, {pointInDisplaySpace});\n        mDispatcher->notifyMotion(&down);\n        window->consumeMotionDown();\n\n        const auto up = generateMotionArgs(AMOTION_EVENT_ACTION_UP, AINPUT_SOURCE_TOUCHSCREEN,\n                                           ADISPLAY_ID_DEFAULT, {pointInDisplaySpace});\n        mDispatcher->notifyMotion(&up);\n        window->consumeMotionUp();\n    }\n\n    // The following points in logical display space should be outside the window.\n    static const std::array<vec2, 5> outsidePoints{\n            {{200, 100}, {100, 300}, {200, 300}, {100, 99.99}, {99.99, 100}}};\n    for (const auto pointOutsideWindow : outsidePoints) {\n        const vec2 p = displayTransform.inverse().transform(pointOutsideWindow);\n        const PointF pointInDisplaySpace{p.x, p.y};\n        const auto down = generateMotionArgs(AMOTION_EVENT_ACTION_DOWN, AINPUT_SOURCE_TOUCHSCREEN,\n                                             ADISPLAY_ID_DEFAULT, {pointInDisplaySpace});\n        mDispatcher->notifyMotion(&down);\n\n        const auto up = generateMotionArgs(AMOTION_EVENT_ACTION_UP, AINPUT_SOURCE_TOUCHSCREEN,\n                                           ADISPLAY_ID_DEFAULT, {pointInDisplaySpace});\n        mDispatcher->notifyMotion(&up);\n    }\n    window->assertNoEvents();\n}\n\n// Run the precision tests for all rotations.\nINSTANTIATE_TEST_SUITE_P(InputDispatcherDisplayOrientationTests,\n                         InputDispatcherDisplayOrientationFixture,\n                         ::testing::Values(ui::ROTATION_0, ui::ROTATION_90, ui::ROTATION_180,\n                                           ui::ROTATION_270),\n                         [](const testing::TestParamInfo<ui::Rotation>& testParamInfo) {\n                             return ftl::enum_string(testParamInfo.param);\n                         });\n",
        "b_contents": "/** Ensure consistent behavior of InputDispatcher in all orientations. */\nclass InputDispatcherDisplayOrientationFixture\n      : public InputDispatcherDisplayProjectionTest,\n        public ::testing::WithParamInterface<ui::Rotation> {};\n\n// This test verifies the touchable region of a window for all rotations of the display by tapping\n// in different locations on the display, specifically points close to the four corners of a\n// window.\nTEST_P(InputDispatcherDisplayOrientationFixture, HitTestInDifferentOrientations) {\n    constexpr static int32_t displayWidth = 400;\n    constexpr static int32_t displayHeight = 800;\n\n    std::shared_ptr<FakeApplicationHandle> application = std::make_shared<FakeApplicationHandle>();\n\n    const auto rotation = GetParam();\n\n    // Set up the display with the specified rotation.\n    const bool isRotated = rotation == ui::ROTATION_90 || rotation == ui::ROTATION_270;\n    const int32_t logicalDisplayWidth = isRotated ? displayHeight : displayWidth;\n    const int32_t logicalDisplayHeight = isRotated ? displayWidth : displayHeight;\n    const ui::Transform displayTransform(ui::Transform::toRotationFlags(rotation),\n                                         logicalDisplayWidth, logicalDisplayHeight);\n    addDisplayInfo(ADISPLAY_ID_DEFAULT, displayTransform);\n\n    // Create a window with its bounds determined in the logical display.\n    const Rect frameInLogicalDisplay(100, 100, 200, 300);\n    const Rect frameInDisplay = displayTransform.inverse().transform(frameInLogicalDisplay);\n    sp<FakeWindowHandle> window =\n            sp<FakeWindowHandle>::make(application, mDispatcher, \"Window\", ADISPLAY_ID_DEFAULT);\n    window->setFrame(frameInDisplay, displayTransform);\n    addWindow(window);\n\n    // The following points in logical display space should be inside the window.\n    static const std::array<vec2, 4> insidePoints{\n            {{100, 100}, {199.99, 100}, {100, 299.99}, {199.99, 299.99}}};\n    for (const auto pointInsideWindow : insidePoints) {\n        const vec2 p = displayTransform.inverse().transform(pointInsideWindow);\n        const PointF pointInDisplaySpace{p.x, p.y};\n        const auto down = generateMotionArgs(AMOTION_EVENT_ACTION_DOWN, AINPUT_SOURCE_TOUCHSCREEN,\n                                             ADISPLAY_ID_DEFAULT, {pointInDisplaySpace});\n        mDispatcher->notifyMotion(&down);\n        window->consumeMotionDown();\n\n        const auto up = generateMotionArgs(AMOTION_EVENT_ACTION_UP, AINPUT_SOURCE_TOUCHSCREEN,\n                                           ADISPLAY_ID_DEFAULT, {pointInDisplaySpace});\n        mDispatcher->notifyMotion(&up);\n        window->consumeMotionUp();\n    }\n\n    // The following points in logical display space should be outside the window.\n    static const std::array<vec2, 5> outsidePoints{\n            {{200, 100}, {100, 300}, {200, 300}, {100, 99.99}, {99.99, 100}}};\n    for (const auto pointOutsideWindow : outsidePoints) {\n        const vec2 p = displayTransform.inverse().transform(pointOutsideWindow);\n        const PointF pointInDisplaySpace{p.x, p.y};\n        const auto down = generateMotionArgs(AMOTION_EVENT_ACTION_DOWN, AINPUT_SOURCE_TOUCHSCREEN,\n                                             ADISPLAY_ID_DEFAULT, {pointInDisplaySpace});\n        mDispatcher->notifyMotion(&down);\n\n        const auto up = generateMotionArgs(AMOTION_EVENT_ACTION_UP, AINPUT_SOURCE_TOUCHSCREEN,\n                                           ADISPLAY_ID_DEFAULT, {pointInDisplaySpace});\n        mDispatcher->notifyMotion(&up);\n    }\n    window->assertNoEvents();\n}\n\n// Run the precision tests for all rotations.\nINSTANTIATE_TEST_SUITE_P(InputDispatcherDisplayOrientationTests,\n                         InputDispatcherDisplayOrientationFixture,\n                         ::testing::Values(ui::ROTATION_0, ui::ROTATION_90, ui::ROTATION_180,\n                                           ui::ROTATION_270));\n",
        "base_contents": "",
        "res_region": "/** Ensure consistent behavior of InputDispatcher in all orientations. */\nclass InputDispatcherDisplayOrientationFixture\n      : public InputDispatcherDisplayProjectionTest,\n        public ::testing::WithParamInterface<ui::Rotation> {};\n\n// This test verifies the touchable region of a window for all rotations of the display by tapping\n// in different locations on the display, specifically points close to the four corners of a\n// window.\nTEST_P(InputDispatcherDisplayOrientationFixture, HitTestInDifferentOrientations) {\n    constexpr static int32_t displayWidth = 400;\n    constexpr static int32_t displayHeight = 800;\n\n    std::shared_ptr<FakeApplicationHandle> application = std::make_shared<FakeApplicationHandle>();\n\n    const auto rotation = GetParam();\n\n    // Set up the display with the specified rotation.\n    const bool isRotated = rotation == ui::ROTATION_90 || rotation == ui::ROTATION_270;\n    const int32_t logicalDisplayWidth = isRotated ? displayHeight : displayWidth;\n    const int32_t logicalDisplayHeight = isRotated ? displayWidth : displayHeight;\n    const ui::Transform displayTransform(ui::Transform::toRotationFlags(rotation),\n                                         logicalDisplayWidth, logicalDisplayHeight);\n    addDisplayInfo(ADISPLAY_ID_DEFAULT, displayTransform);\n\n    // Create a window with its bounds determined in the logical display.\n    const Rect frameInLogicalDisplay(100, 100, 200, 300);\n    const Rect frameInDisplay = displayTransform.inverse().transform(frameInLogicalDisplay);\n    sp<FakeWindowHandle> window =\n            sp<FakeWindowHandle>::make(application, mDispatcher, \"Window\", ADISPLAY_ID_DEFAULT);\n    window->setFrame(frameInDisplay, displayTransform);\n    addWindow(window);\n\n    // The following points in logical display space should be inside the window.\n    static const std::array<vec2, 4> insidePoints{\n            {{100, 100}, {199.99, 100}, {100, 299.99}, {199.99, 299.99}}};\n    for (const auto pointInsideWindow : insidePoints) {\n        const vec2 p = displayTransform.inverse().transform(pointInsideWindow);\n        const PointF pointInDisplaySpace{p.x, p.y};\n        const auto down = generateMotionArgs(AMOTION_EVENT_ACTION_DOWN, AINPUT_SOURCE_TOUCHSCREEN,\n                                             ADISPLAY_ID_DEFAULT, {pointInDisplaySpace});\n        mDispatcher->notifyMotion(&down);\n        window->consumeMotionDown();\n\n        const auto up = generateMotionArgs(AMOTION_EVENT_ACTION_UP, AINPUT_SOURCE_TOUCHSCREEN,\n                                           ADISPLAY_ID_DEFAULT, {pointInDisplaySpace});\n        mDispatcher->notifyMotion(&up);\n        window->consumeMotionUp();\n    }\n\n    // The following points in logical display space should be outside the window.\n    static const std::array<vec2, 5> outsidePoints{\n            {{200, 100}, {100, 300}, {200, 300}, {100, 99.99}, {99.99, 100}}};\n    for (const auto pointOutsideWindow : outsidePoints) {\n        const vec2 p = displayTransform.inverse().transform(pointOutsideWindow);\n        const PointF pointInDisplaySpace{p.x, p.y};\n        const auto down = generateMotionArgs(AMOTION_EVENT_ACTION_DOWN, AINPUT_SOURCE_TOUCHSCREEN,\n                                             ADISPLAY_ID_DEFAULT, {pointInDisplaySpace});\n        mDispatcher->notifyMotion(&down);\n\n        const auto up = generateMotionArgs(AMOTION_EVENT_ACTION_UP, AINPUT_SOURCE_TOUCHSCREEN,\n                                           ADISPLAY_ID_DEFAULT, {pointInDisplaySpace});\n        mDispatcher->notifyMotion(&up);\n    }\n    window->assertNoEvents();\n}\n\n// Run the precision tests for all rotations.\nINSTANTIATE_TEST_SUITE_P(InputDispatcherDisplayOrientationTests,\n                         InputDispatcherDisplayOrientationFixture,\n                         ::testing::Values(ui::ROTATION_0, ui::ROTATION_90, ui::ROTATION_180,\n                                           ui::ROTATION_270),\n                         [](const testing::TestParamInfo<ui::Rotation>& testParamInfo) {\n                             return ftl::enum_string(testParamInfo.param);\n                         });\n",
        "lookback": "class InputDispatcherDisplayOrientationFixture",
        "lookahead": "using TransferFunction = std::function<bool(const std::unique_ptr<InputDispatcher>& dispatcher,",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 4072,
        "end_line": 4222,
        "merge_gen_region": " InputDisplayFixture Ensure behavior Input in orient. classDispatcherOrientationFixture publicDispatcherProjection, publictestingWithInterfaceuiRotation {}; This ver theable region a window allations of display t // in locations the display specific points to fourners a window allations the byapping in locations the display specific points to fourners a window TESTPInputDisplayFixture,TestD on display specific points to fourners a window TESTPInputDisplayFixture HitInifferentations { constexpr int_tWidth 400 constexpr int_tHeight 800 stdsharedptrFakeHandle application stdmakesharedFakeHandle const rotation Get(); Set the with specified. boolRotated rotation uiROT_ || ==::ATION270 const32tDisplayWidth isRotated display :Width const32tDisplay =Height is ?Width display; uiTransformTransformuiTransformuiTransformtoFlags(),DisplayWidth logicalHeight addInfoADPLAY____,Transform); Create window its determined the display const frameLogicalLogical(,,,,,,,,,,,,,); RectIn =Transform.().(InTransform const::::Rotation(,Dispatcher \"\",DISPLAYIDDEFAULT window->FrameframeDisplay,Transform);Windowwindow add(); The points logical space be inside window static stdarrayvec,>>>",
        "confidence": 0.9121044278144836,
        "hesitated": false,
        "resolved": false
    }
]