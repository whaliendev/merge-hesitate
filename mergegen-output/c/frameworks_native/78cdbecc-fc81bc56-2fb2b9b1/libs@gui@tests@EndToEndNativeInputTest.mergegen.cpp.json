[
    {
        "a_contents": "        if (noInputChannel) {\n            mInputInfo.setInputConfig(WindowInfo::InputConfig::NO_INPUT_CHANNEL, true);\n        } else {\n            mClientChannel = std::make_shared<InputChannel>();\n            mInputFlinger->createInputChannel(\"testchannels\", mClientChannel.get());\n            mInputInfo.token = mClientChannel->getConnectionToken();\n            mInputConsumer = new InputConsumer(mClientChannel);\n        }",
        "b_contents": "        if (noInputChannel) {\n            mInputInfo.inputFeatures = InputWindowInfo::Feature::NO_INPUT_CHANNEL;\n        } else {\n            mClientChannel = std::make_shared<InputChannel>();\n            mInputFlinger->createInputChannel(\"testchannels\", mClientChannel.get());\n            mInputInfo.token = mClientChannel->getConnectionToken();\n            mInputConsumer = new InputConsumer(mClientChannel);\n        }",
        "base_contents": "        mClientChannel = std::make_shared<InputChannel>();\n        mInputFlinger->createInputChannel(\"testchannels\", mClientChannel.get());",
        "res_region": "        if (noInputChannel) {\n            mInputInfo.setInputConfig(WindowInfo::InputConfig::NO_INPUT_CHANNEL, true);\n        } else {\n            mClientChannel = std::make_shared<InputChannel>();\n            mInputFlinger->createInputChannel(\"testchannels\", mClientChannel.get());\n            mInputInfo.token = mClientChannel->getConnectionToken();\n            mInputConsumer = new InputConsumer(mClientChannel);\n        }",
        "lookback": "            mInputInfo.setInputConfig(WindowInfo::InputConfig::NO_INPUT_CHANNEL, true);",
        "lookahead": "",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 82,
        "end_line": 103,
        "merge_gen_region": "Input(WindowInfosetConfig(InfoWindow::ConfigBBmmmmmmmmm",
        "confidence": 0.9200519919395447,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "        mInputInfo.name = \"Test info\";\n        mInputInfo.dispatchingTimeout = 5s;\n        mInputInfo.globalScaleFactor = 1.0;\n        mInputInfo.touchableRegion.orSelf(Rect(0, 0, width, height));",
        "b_contents": "        mInputInfo.name = \"Test info\";\n        mInputInfo.dispatchingTimeout = 5s;\n        mInputInfo.globalScaleFactor = 1.0;\n        mInputInfo.flags = InputWindowInfo::Flag::NOT_TOUCH_MODAL;\n        mInputInfo.type = InputWindowInfo::Type::BASE_APPLICATION;\n        mInputInfo.focusable = true;\n        mInputInfo.hasWallpaper = false;\n        mInputInfo.paused = false;\n        // TODO: Fill in from SF?\n        mInputInfo.ownerPid = 11111;\n        mInputInfo.ownerUid = 11111;\n        mInputInfo.displayId = 0;\n        mInputInfo.touchableRegion.orSelf(Rect(0, 0, width, height));",
        "base_contents": "        populateInputInfo(width, height);",
        "res_region": "        mInputInfo.name = \"Test info\";\n        mInputInfo.dispatchingTimeout = 5s;\n        mInputInfo.globalScaleFactor = 1.0;\n        mInputInfo.touchableRegion.orSelf(Rect(0, 0, width, height));",
        "lookback": "        mInputInfo.dispatchingTimeout = 5s;",
        "lookahead": "",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 105,
        "end_line": 126,
        "merge_gen_region": "Input. =Test\";Input.ingTimeout 5;Inputmmmmmmmmmmmm",
        "confidence": 0.9390400052070618,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "    static std::unique_ptr<InputSurface> makeContainerInputSurfaceNoInputChannel(\n            const sp<SurfaceComposerClient> &scc, int width, int height) {\n        sp<SurfaceControl> surfaceControl =\n                scc->createSurface(String8(\"Test Container Surface\"), 100 /* height */,\n                                   100 /* width */, PIXEL_FORMAT_RGBA_8888,\n                                   ISurfaceComposerClient::eFXSurfaceContainer);\n        return std::make_unique<InputSurface>(surfaceControl, width, height,\n                                              true /* noInputChannel */);\n    }\n",
        "b_contents": "    static std::unique_ptr<InputSurface> makeContainerInputSurfaceNoInputChannel(\n            const sp<SurfaceComposerClient> &scc, int width, int height) {\n        sp<SurfaceControl> surfaceControl =\n                scc->createSurface(String8(\"Test Container Surface\"), 0 /* bufHeight */,\n                                   0 /* bufWidth */, PIXEL_FORMAT_RGBA_8888,\n                                   ISurfaceComposerClient::eFXSurfaceContainer);\n        return std::make_unique<InputSurface>(surfaceControl, width, height,\n                                              true /* noInputChannel */);\n    }\n",
        "base_contents": "",
        "res_region": "    static std::unique_ptr<InputSurface> makeContainerInputSurfaceNoInputChannel(\n            const sp<SurfaceComposerClient> &scc, int width, int height) {\n        sp<SurfaceControl> surfaceControl =\n                scc->createSurface(String8(\"Test Container Surface\"), 100 /* height */,\n                                   100 /* width */, PIXEL_FORMAT_RGBA_8888,\n                                   ISurfaceComposerClient::eFXSurfaceContainer);\n        return std::make_unique<InputSurface>(surfaceControl, width, height,\n                                              true /* noInputChannel */);\n    }\n",
        "lookback": "            const sp<SurfaceComposerClient> &scc, int width, int height) {",
        "lookahead": "    static std::unique_ptr<InputSurface> makeCursorInputSurface(",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 162,
        "end_line": 185,
        "merge_gen_region": " stduniqueptrInput>79797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979797979",
        "confidence": 0.9516037702560425,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "TEST_F(InputSurfacesTest, strict_unobscured_input_unobscured_window) {\n    std::unique_ptr<InputSurface> surface = makeSurface(100, 100);\n    surface->doTransaction(\n            [&](auto &t, auto &sc) { t.setDropInputMode(sc, gui::DropInputMode::OBSCURED); });\n    surface->showAt(100, 100);\n\n    injectTap(101, 101);\n\n    EXPECT_NE(surface->consumeEvent(), nullptr);\n    EXPECT_NE(surface->consumeEvent(), nullptr);\n\n    surface->requestFocus();\n    surface->assertFocusChange(true);\n    injectKey(AKEYCODE_V);\n    surface->expectKey(AKEYCODE_V);\n}\n\nTEST_F(InputSurfacesTest, strict_unobscured_input_scaled_without_crop_window) {\n    std::unique_ptr<InputSurface> surface = makeSurface(100, 100);\n    surface->doTransaction([&](auto &t, auto &sc) {\n        t.setDropInputMode(sc, gui::DropInputMode::OBSCURED);\n        t.setMatrix(sc, 2.0, 0, 0, 2.0);\n    });\n    surface->showAt(100, 100);\n\n    injectTap(101, 101);\n\n    EXPECT_NE(surface->consumeEvent(), nullptr);\n    EXPECT_NE(surface->consumeEvent(), nullptr);\n\n    surface->requestFocus();\n    surface->assertFocusChange(true);\n    injectKey(AKEYCODE_V);\n    surface->expectKey(AKEYCODE_V);\n}\n\nTEST_F(InputSurfacesTest, strict_unobscured_input_obscured_window) {\n    std::unique_ptr<InputSurface> surface = makeSurface(100, 100);\n    surface->mInputInfo.ownerUid = 11111;\n    surface->doTransaction(\n            [&](auto &t, auto &sc) { t.setDropInputMode(sc, gui::DropInputMode::OBSCURED); });\n    surface->showAt(100, 100);\n    std::unique_ptr<InputSurface> obscuringSurface = makeSurface(100, 100);\n    obscuringSurface->mInputInfo.setInputConfig(WindowInfo::InputConfig::NOT_TOUCHABLE, true);\n    obscuringSurface->mInputInfo.ownerUid = 22222;\n    obscuringSurface->showAt(100, 100);\n    injectTap(101, 101);\n    EXPECT_EQ(surface->consumeEvent(100), nullptr);\n\n    surface->requestFocus();\n    surface->assertFocusChange(true);\n    injectKey(AKEYCODE_V);\n    EXPECT_EQ(surface->consumeEvent(100), nullptr);\n}\n\nTEST_F(InputSurfacesTest, strict_unobscured_input_partially_obscured_window) {\n    std::unique_ptr<InputSurface> surface = makeSurface(100, 100);\n    surface->mInputInfo.ownerUid = 11111;\n    surface->doTransaction(\n            [&](auto &t, auto &sc) { t.setDropInputMode(sc, gui::DropInputMode::OBSCURED); });\n    surface->showAt(100, 100);\n    std::unique_ptr<InputSurface> obscuringSurface = makeSurface(100, 100);\n    obscuringSurface->mInputInfo.setInputConfig(WindowInfo::InputConfig::NOT_TOUCHABLE, true);\n    obscuringSurface->mInputInfo.ownerUid = 22222;\n    obscuringSurface->showAt(190, 190);\n\n    injectTap(101, 101);\n\n    EXPECT_EQ(surface->consumeEvent(100), nullptr);\n\n    surface->requestFocus();\n    surface->assertFocusChange(true);\n    injectKey(AKEYCODE_V);\n    EXPECT_EQ(surface->consumeEvent(100), nullptr);\n}\n\nTEST_F(InputSurfacesTest, strict_unobscured_input_alpha_window) {\n    std::unique_ptr<InputSurface> parentSurface = makeSurface(300, 300);\n    parentSurface->showAt(0, 0, Rect(0, 0, 300, 300));\n\n    std::unique_ptr<InputSurface> surface = makeSurface(100, 100);\n    surface->showAt(100, 100);\n    surface->doTransaction([&](auto &t, auto &sc) {\n        t.setDropInputMode(sc, gui::DropInputMode::OBSCURED);\n        t.reparent(sc, parentSurface->mSurfaceControl);\n        t.setAlpha(parentSurface->mSurfaceControl, 0.9f);\n    });\n\n    injectTap(101, 101);\n\n    EXPECT_EQ(surface->consumeEvent(100), nullptr);\n\n    surface->requestFocus();\n    surface->assertFocusChange(true);\n    injectKey(AKEYCODE_V);\n    EXPECT_EQ(surface->consumeEvent(100), nullptr);\n}\n\nTEST_F(InputSurfacesTest, strict_unobscured_input_cropped_window) {\n    std::unique_ptr<InputSurface> parentSurface = makeSurface(300, 300);\n    parentSurface->showAt(0, 0, Rect(0, 0, 300, 300));\n\n    std::unique_ptr<InputSurface> surface = makeSurface(100, 100);\n    surface->doTransaction([&](auto &t, auto &sc) {\n        t.setDropInputMode(sc, gui::DropInputMode::OBSCURED);\n        t.reparent(sc, parentSurface->mSurfaceControl);\n        t.setCrop(parentSurface->mSurfaceControl, Rect(10, 10, 100, 100));\n    });\n    surface->showAt(100, 100);\n\n    injectTap(111, 111);\n\n    EXPECT_EQ(surface->consumeEvent(100), nullptr);\n\n    surface->requestFocus();\n    surface->assertFocusChange(true);\n    injectKey(AKEYCODE_V);\n    EXPECT_EQ(surface->consumeEvent(100), nullptr);\n}\n\nTEST_F(InputSurfacesTest, ignore_touch_region_with_zero_sized_blast) {\n    std::unique_ptr<InputSurface> surface = makeSurface(100, 100);\n\n    std::unique_ptr<BlastInputSurface> bufferSurface =\n            BlastInputSurface::makeBlastInputSurface(mComposerClient, 0, 0);\n\n    surface->showAt(100, 100);\n    bufferSurface->mInputInfo.touchableRegion.orSelf(Rect(0, 0, 200, 200));\n    bufferSurface->showAt(100, 100, Rect::EMPTY_RECT);\n\n    injectTap(101, 101);\n    surface->expectTap(1, 1);\n}\n\nTEST_F(InputSurfacesTest, drop_input_policy) {\n    std::unique_ptr<InputSurface> surface = makeSurface(100, 100);\n    surface->doTransaction(\n            [&](auto &t, auto &sc) { t.setDropInputMode(sc, gui::DropInputMode::ALL); });\n    surface->showAt(100, 100);\n\n    injectTap(101, 101);\n\n    EXPECT_EQ(surface->consumeEvent(100), nullptr);\n\n    surface->requestFocus();\n    surface->assertFocusChange(true);\n    injectKey(AKEYCODE_V);\n    EXPECT_EQ(surface->consumeEvent(100), nullptr);\n}\n\nTEST_F(InputSurfacesTest, layer_with_valid_crop_can_be_focused) {\n    std::unique_ptr<InputSurface> bufferSurface =\n            InputSurface::makeBufferInputSurface(mComposerClient, 100, 100);\n\n    bufferSurface->showAt(50, 50, Rect{0, 0, 100, 100});\n\n    bufferSurface->requestFocus();\n    bufferSurface->assertFocusChange(true);\n}\n\n/**\n * If a cropped layer's touchable region is replaced with a null crop, it should receive input in\n * its own crop.\n */\nTEST_F(InputSurfacesTest, cropped_container_replaces_touchable_region_with_null_crop) {\n    std::unique_ptr<InputSurface> parentContainer =\n            InputSurface::makeContainerInputSurface(mComposerClient, 0, 0);\n    std::unique_ptr<InputSurface> containerSurface =\n            InputSurface::makeContainerInputSurface(mComposerClient, 100, 100);\n    containerSurface->doTransaction(\n            [&](auto &t, auto &sc) { t.reparent(sc, parentContainer->mSurfaceControl); });\n    containerSurface->mInputInfo.replaceTouchableRegionWithCrop = true;\n    containerSurface->mInputInfo.touchableRegionCropHandle = nullptr;\n    parentContainer->showAt(10, 10, Rect(0, 0, 20, 20));\n    containerSurface->showAt(10, 10, Rect(0, 0, 5, 5));\n\n    // Receives events inside its own crop\n    injectTap(21, 21);\n    containerSurface->expectTap(1, 1); // Event is in layer space\n\n    // Does not receive events outside its crop\n    injectTap(26, 26);\n    EXPECT_EQ(containerSurface->consumeEvent(100), nullptr);\n}\n\n/**\n * If an un-cropped layer's touchable region is replaced with a null crop, it should receive input\n * in its parent's touchable region. The input events should be in the layer's coordinate space.\n */\nTEST_F(InputSurfacesTest, uncropped_container_replaces_touchable_region_with_null_crop) {\n    std::unique_ptr<InputSurface> parentContainer =\n            InputSurface::makeContainerInputSurface(mComposerClient, 0, 0);\n    std::unique_ptr<InputSurface> containerSurface =\n            InputSurface::makeContainerInputSurface(mComposerClient, 100, 100);\n    containerSurface->doTransaction(\n            [&](auto &t, auto &sc) { t.reparent(sc, parentContainer->mSurfaceControl); });\n    containerSurface->mInputInfo.replaceTouchableRegionWithCrop = true;\n    containerSurface->mInputInfo.touchableRegionCropHandle = nullptr;\n    parentContainer->showAt(10, 10, Rect(0, 0, 20, 20));\n    containerSurface->showAt(10, 10, Rect::INVALID_RECT);\n\n    // Receives events inside parent bounds\n    injectTap(21, 21);\n    containerSurface->expectTap(1, 1); // Event is in layer space\n\n    // Does not receive events outside parent bounds\n    injectTap(31, 31);\n    EXPECT_EQ(containerSurface->consumeEvent(100), nullptr);\n}\n\n/**\n * If a layer's touchable region is replaced with a layer crop, it should receive input in the crop\n * layer's bounds. The input events should be in the layer's coordinate space.\n */\nTEST_F(InputSurfacesTest, replace_touchable_region_with_crop) {\n    std::unique_ptr<InputSurface> cropLayer =\n            InputSurface::makeContainerInputSurface(mComposerClient, 0, 0);\n    cropLayer->showAt(50, 50, Rect(0, 0, 20, 20));\n\n    std::unique_ptr<InputSurface> containerSurface =\n            InputSurface::makeContainerInputSurface(mComposerClient, 100, 100);\n    containerSurface->mInputInfo.replaceTouchableRegionWithCrop = true;\n    containerSurface->mInputInfo.touchableRegionCropHandle =\n            cropLayer->mSurfaceControl->getHandle();\n    containerSurface->showAt(10, 10, Rect::INVALID_RECT);\n\n    // Receives events inside crop layer bounds\n    injectTap(51, 51);\n    containerSurface->expectTap(41, 41); // Event is in layer space\n\n    // Does not receive events outside crop layer bounds\n    injectTap(21, 21);\n    injectTap(71, 71);\n    EXPECT_EQ(containerSurface->consumeEvent(100), nullptr);\n}\n\nTEST_F(InputSurfacesTest, child_container_with_no_input_channel_blocks_parent) {\n    std::unique_ptr<InputSurface> parent = makeSurface(100, 100);\n\n    parent->showAt(100, 100);\n    injectTap(101, 101);\n    parent->expectTap(1, 1);\n\n    std::unique_ptr<InputSurface> childContainerSurface =\n            InputSurface::makeContainerInputSurfaceNoInputChannel(mComposerClient, 100, 100);\n    childContainerSurface->showAt(0, 0);\n    childContainerSurface->doTransaction(\n            [&](auto &t, auto &sc) { t.reparent(sc, parent->mSurfaceControl); });\n    injectTap(101, 101);\n\n    EXPECT_EQ(parent->consumeEvent(100), nullptr);\n}\n\nclass MultiDisplayTests : public InputSurfacesTest {\npublic:\n    MultiDisplayTests() : InputSurfacesTest() { ProcessState::self()->startThreadPool(); }\n    void TearDown() override {\n        for (auto &token : mVirtualDisplays) {\n            SurfaceComposerClient::destroyDisplay(token);\n        }\n        InputSurfacesTest::TearDown();\n    }\n\n    void createDisplay(int32_t width, int32_t height, bool isSecure, ui::LayerStack layerStack,\n                       bool receivesInput = true, int32_t offsetX = 0, int32_t offsetY = 0) {\n        sp<IGraphicBufferConsumer> consumer;\n        sp<IGraphicBufferProducer> producer;\n        BufferQueue::createBufferQueue(&producer, &consumer);\n        consumer->setConsumerName(String8(\"Virtual disp consumer\"));\n        consumer->setDefaultBufferSize(width, height);\n        mProducers.push_back(producer);\n\n        std::string name = \"VirtualDisplay\";\n        name += std::to_string(mVirtualDisplays.size());\n        sp<IBinder> token = SurfaceComposerClient::createDisplay(String8(name.c_str()), isSecure);\n        SurfaceComposerClient::Transaction t;\n        t.setDisplaySurface(token, producer);\n        t.setDisplayFlags(token, receivesInput ? 0x01 /* DisplayDevice::eReceivesInput */ : 0);\n        t.setDisplayLayerStack(token, layerStack);\n        t.setDisplayProjection(token, ui::ROTATION_0, {0, 0, width, height},\n                               {offsetX, offsetY, offsetX + width, offsetY + height});\n        t.apply(true);\n\n        mVirtualDisplays.push_back(token);\n    }\n\n    std::vector<sp<IBinder>> mVirtualDisplays;\n    std::vector<sp<IGraphicBufferProducer>> mProducers;\n};\n\nTEST_F(MultiDisplayTests, drop_input_if_layer_on_invalid_display) {\n    ui::LayerStack layerStack = ui::LayerStack::fromValue(42);\n    // Do not create a display associated with the LayerStack.\n    std::unique_ptr<InputSurface> surface = makeSurface(100, 100);\n    surface->doTransaction([&](auto &t, auto &sc) { t.setLayerStack(sc, layerStack); });\n    surface->showAt(100, 100);\n\n    injectTapOnDisplay(101, 101, layerStack.id);\n    surface->requestFocus(layerStack.id);\n    injectKeyOnDisplay(AKEYCODE_V, layerStack.id);\n\n    EXPECT_EQ(surface->consumeEvent(100), nullptr);\n}\n\nTEST_F(MultiDisplayTests, virtual_display_receives_input) {\n    ui::LayerStack layerStack = ui::LayerStack::fromValue(42);\n    createDisplay(1000, 1000, false /*isSecure*/, layerStack);\n    std::unique_ptr<InputSurface> surface = makeSurface(100, 100);\n    surface->doTransaction([&](auto &t, auto &sc) { t.setLayerStack(sc, layerStack); });\n    surface->showAt(100, 100);\n\n    injectTapOnDisplay(101, 101, layerStack.id);\n    surface->expectTap(1, 1);\n\n    surface->requestFocus(layerStack.id);\n    surface->assertFocusChange(true);\n    injectKeyOnDisplay(AKEYCODE_V, layerStack.id);\n    surface->expectKey(AKEYCODE_V);\n}\n\n/**\n * When multiple DisplayDevices are mapped to the same layerStack, use the configuration for the\n * display that can receive input.\n */\nTEST_F(MultiDisplayTests, many_to_one_display_mapping) {\n    ui::LayerStack layerStack = ui::LayerStack::fromValue(42);\n    createDisplay(1000, 1000, false /*isSecure*/, layerStack, false /*receivesInput*/,\n                  100 /*offsetX*/, 100 /*offsetY*/);\n    createDisplay(1000, 1000, false /*isSecure*/, layerStack, true /*receivesInput*/,\n                  200 /*offsetX*/, 200 /*offsetY*/);\n    createDisplay(1000, 1000, false /*isSecure*/, layerStack, false /*receivesInput*/,\n                  300 /*offsetX*/, 300 /*offsetY*/);\n    std::unique_ptr<InputSurface> surface = makeSurface(100, 100);\n    surface->doTransaction([&](auto &t, auto &sc) { t.setLayerStack(sc, layerStack); });\n    surface->showAt(10, 10);\n\n    // Input injection happens in logical display coordinates.\n    injectTapOnDisplay(11, 11, layerStack.id);\n    // Expect that the display transform for the display that receives input was used.\n    surface->expectTapInDisplayCoordinates(211, 211);\n\n    surface->requestFocus(layerStack.id);\n    surface->assertFocusChange(true);\n    injectKeyOnDisplay(AKEYCODE_V, layerStack.id);\n}\n\nTEST_F(MultiDisplayTests, drop_input_for_secure_layer_on_nonsecure_display) {\n    ui::LayerStack layerStack = ui::LayerStack::fromValue(42);\n    createDisplay(1000, 1000, false /*isSecure*/, layerStack);\n    std::unique_ptr<InputSurface> surface = makeSurface(100, 100);\n    surface->doTransaction([&](auto &t, auto &sc) {\n        t.setFlags(sc, layer_state_t::eLayerSecure, layer_state_t::eLayerSecure);\n        t.setLayerStack(sc, layerStack);\n    });\n    surface->showAt(100, 100);\n\n    injectTapOnDisplay(101, 101, layerStack.id);\n\n    EXPECT_EQ(surface->consumeEvent(100), nullptr);\n\n    surface->requestFocus(layerStack.id);\n    surface->assertFocusChange(true);\n    injectKeyOnDisplay(AKEYCODE_V, layerStack.id);\n    EXPECT_EQ(surface->consumeEvent(100), nullptr);\n}\n\nTEST_F(MultiDisplayTests, dont_drop_input_for_secure_layer_on_secure_display) {\n    ui::LayerStack layerStack = ui::LayerStack::fromValue(42);\n\n    // Create the secure display as system, because only certain users can create secure displays.\n    seteuid(AID_SYSTEM);\n    createDisplay(1000, 1000, true /*isSecure*/, layerStack);\n    // Change the uid back to root.\n    seteuid(AID_ROOT);\n\n    std::unique_ptr<InputSurface> surface = makeSurface(100, 100);\n    surface->doTransaction([&](auto &t, auto &sc) {\n        t.setFlags(sc, layer_state_t::eLayerSecure, layer_state_t::eLayerSecure);\n        t.setLayerStack(sc, layerStack);\n    });\n    surface->showAt(100, 100);\n\n    injectTapOnDisplay(101, 101, layerStack.id);\n    EXPECT_NE(surface->consumeEvent(), nullptr);\n    EXPECT_NE(surface->consumeEvent(), nullptr);\n\n    surface->requestFocus(layerStack.id);\n    surface->assertFocusChange(true);\n    injectKeyOnDisplay(AKEYCODE_V, layerStack.id);\n\n    surface->expectKey(AKEYCODE_V);\n}\n",
        "b_contents": "TEST_F(InputSurfacesTest, child_container_with_no_input_channel_blocks_parent) {\n    std::unique_ptr<InputSurface> parent = makeSurface(100, 100);\n\n    parent->showAt(100, 100);\n    injectTap(101, 101);\n    parent->expectTap(1, 1);\n\n    std::unique_ptr<InputSurface> childContainerSurface =\n            InputSurface::makeContainerInputSurfaceNoInputChannel(mComposerClient, 100, 100);\n    childContainerSurface->showAt(0, 0);\n    childContainerSurface->doTransaction(\n            [&](auto &t, auto &sc) { t.reparent(sc, parent->mSurfaceControl); });\n    injectTap(101, 101);\n\n    EXPECT_EQ(parent->consumeEvent(100), nullptr);\n}\n",
        "base_contents": "",
        "res_region": "TEST_F(InputSurfacesTest, strict_unobscured_input_unobscured_window) {\n    std::unique_ptr<InputSurface> surface = makeSurface(100, 100);\n    surface->doTransaction(\n            [&](auto &t, auto &sc) { t.setDropInputMode(sc, gui::DropInputMode::OBSCURED); });\n    surface->showAt(100, 100);\n\n    injectTap(101, 101);\n\n    EXPECT_NE(surface->consumeEvent(), nullptr);\n    EXPECT_NE(surface->consumeEvent(), nullptr);\n\n    surface->requestFocus();\n    surface->assertFocusChange(true);\n    injectKey(AKEYCODE_V);\n    surface->expectKey(AKEYCODE_V);\n}\n\nTEST_F(InputSurfacesTest, strict_unobscured_input_scaled_without_crop_window) {\n    std::unique_ptr<InputSurface> surface = makeSurface(100, 100);\n    surface->doTransaction([&](auto &t, auto &sc) {\n        t.setDropInputMode(sc, gui::DropInputMode::OBSCURED);\n        t.setMatrix(sc, 2.0, 0, 0, 2.0);\n    });\n    surface->showAt(100, 100);\n\n    injectTap(101, 101);\n\n    EXPECT_NE(surface->consumeEvent(), nullptr);\n    EXPECT_NE(surface->consumeEvent(), nullptr);\n\n    surface->requestFocus();\n    surface->assertFocusChange(true);\n    injectKey(AKEYCODE_V);\n    surface->expectKey(AKEYCODE_V);\n}\n\nTEST_F(InputSurfacesTest, strict_unobscured_input_obscured_window) {\n    std::unique_ptr<InputSurface> surface = makeSurface(100, 100);\n    surface->mInputInfo.ownerUid = 11111;\n    surface->doTransaction(\n            [&](auto &t, auto &sc) { t.setDropInputMode(sc, gui::DropInputMode::OBSCURED); });\n    surface->showAt(100, 100);\n    std::unique_ptr<InputSurface> obscuringSurface = makeSurface(100, 100);\n    obscuringSurface->mInputInfo.setInputConfig(WindowInfo::InputConfig::NOT_TOUCHABLE, true);\n    obscuringSurface->mInputInfo.ownerUid = 22222;\n    obscuringSurface->showAt(100, 100);\n    injectTap(101, 101);\n    EXPECT_EQ(surface->consumeEvent(100), nullptr);\n\n    surface->requestFocus();\n    surface->assertFocusChange(true);\n    injectKey(AKEYCODE_V);\n    EXPECT_EQ(surface->consumeEvent(100), nullptr);\n}\n\nTEST_F(InputSurfacesTest, strict_unobscured_input_partially_obscured_window) {\n    std::unique_ptr<InputSurface> surface = makeSurface(100, 100);\n    surface->mInputInfo.ownerUid = 11111;\n    surface->doTransaction(\n            [&](auto &t, auto &sc) { t.setDropInputMode(sc, gui::DropInputMode::OBSCURED); });\n    surface->showAt(100, 100);\n    std::unique_ptr<InputSurface> obscuringSurface = makeSurface(100, 100);\n    obscuringSurface->mInputInfo.setInputConfig(WindowInfo::InputConfig::NOT_TOUCHABLE, true);\n    obscuringSurface->mInputInfo.ownerUid = 22222;\n    obscuringSurface->showAt(190, 190);\n\n    injectTap(101, 101);\n\n    EXPECT_EQ(surface->consumeEvent(100), nullptr);\n\n    surface->requestFocus();\n    surface->assertFocusChange(true);\n    injectKey(AKEYCODE_V);\n    EXPECT_EQ(surface->consumeEvent(100), nullptr);\n}\n\nTEST_F(InputSurfacesTest, strict_unobscured_input_alpha_window) {\n    std::unique_ptr<InputSurface> parentSurface = makeSurface(300, 300);\n    parentSurface->showAt(0, 0, Rect(0, 0, 300, 300));\n\n    std::unique_ptr<InputSurface> surface = makeSurface(100, 100);\n    surface->showAt(100, 100);\n    surface->doTransaction([&](auto &t, auto &sc) {\n        t.setDropInputMode(sc, gui::DropInputMode::OBSCURED);\n        t.reparent(sc, parentSurface->mSurfaceControl);\n        t.setAlpha(parentSurface->mSurfaceControl, 0.9f);\n    });\n\n    injectTap(101, 101);\n\n    EXPECT_EQ(surface->consumeEvent(100), nullptr);\n\n    surface->requestFocus();\n    surface->assertFocusChange(true);\n    injectKey(AKEYCODE_V);\n    EXPECT_EQ(surface->consumeEvent(100), nullptr);\n}\n\nTEST_F(InputSurfacesTest, strict_unobscured_input_cropped_window) {\n    std::unique_ptr<InputSurface> parentSurface = makeSurface(300, 300);\n    parentSurface->showAt(0, 0, Rect(0, 0, 300, 300));\n\n    std::unique_ptr<InputSurface> surface = makeSurface(100, 100);\n    surface->doTransaction([&](auto &t, auto &sc) {\n        t.setDropInputMode(sc, gui::DropInputMode::OBSCURED);\n        t.reparent(sc, parentSurface->mSurfaceControl);\n        t.setCrop(parentSurface->mSurfaceControl, Rect(10, 10, 100, 100));\n    });\n    surface->showAt(100, 100);\n\n    injectTap(111, 111);\n\n    EXPECT_EQ(surface->consumeEvent(100), nullptr);\n\n    surface->requestFocus();\n    surface->assertFocusChange(true);\n    injectKey(AKEYCODE_V);\n    EXPECT_EQ(surface->consumeEvent(100), nullptr);\n}\n\nTEST_F(InputSurfacesTest, ignore_touch_region_with_zero_sized_blast) {\n    std::unique_ptr<InputSurface> surface = makeSurface(100, 100);\n\n    std::unique_ptr<BlastInputSurface> bufferSurface =\n            BlastInputSurface::makeBlastInputSurface(mComposerClient, 0, 0);\n\n    surface->showAt(100, 100);\n    bufferSurface->mInputInfo.touchableRegion.orSelf(Rect(0, 0, 200, 200));\n    bufferSurface->showAt(100, 100, Rect::EMPTY_RECT);\n\n    injectTap(101, 101);\n    surface->expectTap(1, 1);\n}\n\nTEST_F(InputSurfacesTest, drop_input_policy) {\n    std::unique_ptr<InputSurface> surface = makeSurface(100, 100);\n    surface->doTransaction(\n            [&](auto &t, auto &sc) { t.setDropInputMode(sc, gui::DropInputMode::ALL); });\n    surface->showAt(100, 100);\n\n    injectTap(101, 101);\n\n    EXPECT_EQ(surface->consumeEvent(100), nullptr);\n\n    surface->requestFocus();\n    surface->assertFocusChange(true);\n    injectKey(AKEYCODE_V);\n    EXPECT_EQ(surface->consumeEvent(100), nullptr);\n}\n\nTEST_F(InputSurfacesTest, layer_with_valid_crop_can_be_focused) {\n    std::unique_ptr<InputSurface> bufferSurface =\n            InputSurface::makeBufferInputSurface(mComposerClient, 100, 100);\n\n    bufferSurface->showAt(50, 50, Rect{0, 0, 100, 100});\n\n    bufferSurface->requestFocus();\n    bufferSurface->assertFocusChange(true);\n}\n\n/**\n * If a cropped layer's touchable region is replaced with a null crop, it should receive input in\n * its own crop.\n */\nTEST_F(InputSurfacesTest, cropped_container_replaces_touchable_region_with_null_crop) {\n    std::unique_ptr<InputSurface> parentContainer =\n            InputSurface::makeContainerInputSurface(mComposerClient, 0, 0);\n    std::unique_ptr<InputSurface> containerSurface =\n            InputSurface::makeContainerInputSurface(mComposerClient, 100, 100);\n    containerSurface->doTransaction(\n            [&](auto &t, auto &sc) { t.reparent(sc, parentContainer->mSurfaceControl); });\n    containerSurface->mInputInfo.replaceTouchableRegionWithCrop = true;\n    containerSurface->mInputInfo.touchableRegionCropHandle = nullptr;\n    parentContainer->showAt(10, 10, Rect(0, 0, 20, 20));\n    containerSurface->showAt(10, 10, Rect(0, 0, 5, 5));\n\n    // Receives events inside its own crop\n    injectTap(21, 21);\n    containerSurface->expectTap(1, 1); // Event is in layer space\n\n    // Does not receive events outside its crop\n    injectTap(26, 26);\n    EXPECT_EQ(containerSurface->consumeEvent(100), nullptr);\n}\n\n/**\n * If an un-cropped layer's touchable region is replaced with a null crop, it should receive input\n * in its parent's touchable region. The input events should be in the layer's coordinate space.\n */\nTEST_F(InputSurfacesTest, uncropped_container_replaces_touchable_region_with_null_crop) {\n    std::unique_ptr<InputSurface> parentContainer =\n            InputSurface::makeContainerInputSurface(mComposerClient, 0, 0);\n    std::unique_ptr<InputSurface> containerSurface =\n            InputSurface::makeContainerInputSurface(mComposerClient, 100, 100);\n    containerSurface->doTransaction(\n            [&](auto &t, auto &sc) { t.reparent(sc, parentContainer->mSurfaceControl); });\n    containerSurface->mInputInfo.replaceTouchableRegionWithCrop = true;\n    containerSurface->mInputInfo.touchableRegionCropHandle = nullptr;\n    parentContainer->showAt(10, 10, Rect(0, 0, 20, 20));\n    containerSurface->showAt(10, 10, Rect::INVALID_RECT);\n\n    // Receives events inside parent bounds\n    injectTap(21, 21);\n    containerSurface->expectTap(1, 1); // Event is in layer space\n\n    // Does not receive events outside parent bounds\n    injectTap(31, 31);\n    EXPECT_EQ(containerSurface->consumeEvent(100), nullptr);\n}\n\n/**\n * If a layer's touchable region is replaced with a layer crop, it should receive input in the crop\n * layer's bounds. The input events should be in the layer's coordinate space.\n */\nTEST_F(InputSurfacesTest, replace_touchable_region_with_crop) {\n    std::unique_ptr<InputSurface> cropLayer =\n            InputSurface::makeContainerInputSurface(mComposerClient, 0, 0);\n    cropLayer->showAt(50, 50, Rect(0, 0, 20, 20));\n\n    std::unique_ptr<InputSurface> containerSurface =\n            InputSurface::makeContainerInputSurface(mComposerClient, 100, 100);\n    containerSurface->mInputInfo.replaceTouchableRegionWithCrop = true;\n    containerSurface->mInputInfo.touchableRegionCropHandle =\n            cropLayer->mSurfaceControl->getHandle();\n    containerSurface->showAt(10, 10, Rect::INVALID_RECT);\n\n    // Receives events inside crop layer bounds\n    injectTap(51, 51);\n    containerSurface->expectTap(41, 41); // Event is in layer space\n\n    // Does not receive events outside crop layer bounds\n    injectTap(21, 21);\n    injectTap(71, 71);\n    EXPECT_EQ(containerSurface->consumeEvent(100), nullptr);\n}\n\nTEST_F(InputSurfacesTest, child_container_with_no_input_channel_blocks_parent) {\n    std::unique_ptr<InputSurface> parent = makeSurface(100, 100);\n\n    parent->showAt(100, 100);\n    injectTap(101, 101);\n    parent->expectTap(1, 1);\n\n    std::unique_ptr<InputSurface> childContainerSurface =\n            InputSurface::makeContainerInputSurfaceNoInputChannel(mComposerClient, 100, 100);\n    childContainerSurface->showAt(0, 0);\n    childContainerSurface->doTransaction(\n            [&](auto &t, auto &sc) { t.reparent(sc, parent->mSurfaceControl); });\n    injectTap(101, 101);\n\n    EXPECT_EQ(parent->consumeEvent(100), nullptr);\n}\n\nclass MultiDisplayTests : public InputSurfacesTest {\npublic:\n    MultiDisplayTests() : InputSurfacesTest() { ProcessState::self()->startThreadPool(); }\n    void TearDown() override {\n        for (auto &token : mVirtualDisplays) {\n            SurfaceComposerClient::destroyDisplay(token);\n        }\n        InputSurfacesTest::TearDown();\n    }\n\n    void createDisplay(int32_t width, int32_t height, bool isSecure, ui::LayerStack layerStack,\n                       bool receivesInput = true, int32_t offsetX = 0, int32_t offsetY = 0) {\n        sp<IGraphicBufferConsumer> consumer;\n        sp<IGraphicBufferProducer> producer;\n        BufferQueue::createBufferQueue(&producer, &consumer);\n        consumer->setConsumerName(String8(\"Virtual disp consumer\"));\n        consumer->setDefaultBufferSize(width, height);\n        mProducers.push_back(producer);\n\n        std::string name = \"VirtualDisplay\";\n        name += std::to_string(mVirtualDisplays.size());\n        sp<IBinder> token = SurfaceComposerClient::createDisplay(String8(name.c_str()), isSecure);\n        SurfaceComposerClient::Transaction t;\n        t.setDisplaySurface(token, producer);\n        t.setDisplayFlags(token, receivesInput ? 0x01 /* DisplayDevice::eReceivesInput */ : 0);\n        t.setDisplayLayerStack(token, layerStack);\n        t.setDisplayProjection(token, ui::ROTATION_0, {0, 0, width, height},\n                               {offsetX, offsetY, offsetX + width, offsetY + height});\n        t.apply(true);\n\n        mVirtualDisplays.push_back(token);\n    }\n\n    std::vector<sp<IBinder>> mVirtualDisplays;\n    std::vector<sp<IGraphicBufferProducer>> mProducers;\n};\n\nTEST_F(MultiDisplayTests, drop_input_if_layer_on_invalid_display) {\n    ui::LayerStack layerStack = ui::LayerStack::fromValue(42);\n    // Do not create a display associated with the LayerStack.\n    std::unique_ptr<InputSurface> surface = makeSurface(100, 100);\n    surface->doTransaction([&](auto &t, auto &sc) { t.setLayerStack(sc, layerStack); });\n    surface->showAt(100, 100);\n\n    injectTapOnDisplay(101, 101, layerStack.id);\n    surface->requestFocus(layerStack.id);\n    injectKeyOnDisplay(AKEYCODE_V, layerStack.id);\n\n    EXPECT_EQ(surface->consumeEvent(100), nullptr);\n}\n\nTEST_F(MultiDisplayTests, virtual_display_receives_input) {\n    ui::LayerStack layerStack = ui::LayerStack::fromValue(42);\n    createDisplay(1000, 1000, false /*isSecure*/, layerStack);\n    std::unique_ptr<InputSurface> surface = makeSurface(100, 100);\n    surface->doTransaction([&](auto &t, auto &sc) { t.setLayerStack(sc, layerStack); });\n    surface->showAt(100, 100);\n\n    injectTapOnDisplay(101, 101, layerStack.id);\n    surface->expectTap(1, 1);\n\n    surface->requestFocus(layerStack.id);\n    surface->assertFocusChange(true);\n    injectKeyOnDisplay(AKEYCODE_V, layerStack.id);\n    surface->expectKey(AKEYCODE_V);\n}\n\n/**\n * When multiple DisplayDevices are mapped to the same layerStack, use the configuration for the\n * display that can receive input.\n */\nTEST_F(MultiDisplayTests, many_to_one_display_mapping) {\n    ui::LayerStack layerStack = ui::LayerStack::fromValue(42);\n    createDisplay(1000, 1000, false /*isSecure*/, layerStack, false /*receivesInput*/,\n                  100 /*offsetX*/, 100 /*offsetY*/);\n    createDisplay(1000, 1000, false /*isSecure*/, layerStack, true /*receivesInput*/,\n                  200 /*offsetX*/, 200 /*offsetY*/);\n    createDisplay(1000, 1000, false /*isSecure*/, layerStack, false /*receivesInput*/,\n                  300 /*offsetX*/, 300 /*offsetY*/);\n    std::unique_ptr<InputSurface> surface = makeSurface(100, 100);\n    surface->doTransaction([&](auto &t, auto &sc) { t.setLayerStack(sc, layerStack); });\n    surface->showAt(10, 10);\n\n    // Input injection happens in logical display coordinates.\n    injectTapOnDisplay(11, 11, layerStack.id);\n    // Expect that the display transform for the display that receives input was used.\n    surface->expectTapInDisplayCoordinates(211, 211);\n\n    surface->requestFocus(layerStack.id);\n    surface->assertFocusChange(true);\n    injectKeyOnDisplay(AKEYCODE_V, layerStack.id);\n}\n\nTEST_F(MultiDisplayTests, drop_input_for_secure_layer_on_nonsecure_display) {\n    ui::LayerStack layerStack = ui::LayerStack::fromValue(42);\n    createDisplay(1000, 1000, false /*isSecure*/, layerStack);\n    std::unique_ptr<InputSurface> surface = makeSurface(100, 100);\n    surface->doTransaction([&](auto &t, auto &sc) {\n        t.setFlags(sc, layer_state_t::eLayerSecure, layer_state_t::eLayerSecure);\n        t.setLayerStack(sc, layerStack);\n    });\n    surface->showAt(100, 100);\n\n    injectTapOnDisplay(101, 101, layerStack.id);\n\n    EXPECT_EQ(surface->consumeEvent(100), nullptr);\n\n    surface->requestFocus(layerStack.id);\n    surface->assertFocusChange(true);\n    injectKeyOnDisplay(AKEYCODE_V, layerStack.id);\n    EXPECT_EQ(surface->consumeEvent(100), nullptr);\n}\n\nTEST_F(MultiDisplayTests, dont_drop_input_for_secure_layer_on_secure_display) {\n    ui::LayerStack layerStack = ui::LayerStack::fromValue(42);\n\n    // Create the secure display as system, because only certain users can create secure displays.\n    seteuid(AID_SYSTEM);\n    createDisplay(1000, 1000, true /*isSecure*/, layerStack);\n    // Change the uid back to root.\n    seteuid(AID_ROOT);\n\n    std::unique_ptr<InputSurface> surface = makeSurface(100, 100);\n    surface->doTransaction([&](auto &t, auto &sc) {\n        t.setFlags(sc, layer_state_t::eLayerSecure, layer_state_t::eLayerSecure);\n        t.setLayerStack(sc, layerStack);\n    });\n    surface->showAt(100, 100);\n\n    injectTapOnDisplay(101, 101, layerStack.id);\n    EXPECT_NE(surface->consumeEvent(), nullptr);\n    EXPECT_NE(surface->consumeEvent(), nullptr);\n\n    surface->requestFocus(layerStack.id);\n    surface->assertFocusChange(true);\n    injectKeyOnDisplay(AKEYCODE_V, layerStack.id);\n\n    surface->expectKey(AKEYCODE_V);\n}\n",
        "lookback": "    std::unique_ptr<InputSurface> surface = makeSurface(100, 100);",
        "lookahead": "} // namespace android::test",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 942,
        "end_line": 1355,
        "merge_gen_region": "::_((SurTest strictunsc___oburedinputunsc_) stduniqueptrInput> =Surface100 100 surfacedo(autot autosc) tsetInputModesc guiDropModeOBURED });->At100 100 injectTap101 101 EXPECTNEsurfaceconsume(),);_(->Event nullptr surfacerequest();->Focus surfaceassertChangetrue inKeyA_KEYCODEV surfaceexpect(KEYCODEV }_(SurTest strictunsc________________) stduniqueptrInput> surface make(,);->Transaction]( &t autosc) t.DropModesc,::InputModeOBURED tsetMatrixsc 200 0 0 0 20 });->At100 100 inTap101 101 EXPECTNEsurfaceconsume(),);_(->Event nullptr surfacerequest();->Focus(Changetrue inKeyA_KEYCODEV surfaceexpect(KEYCODEV }_(SurTest strictunsc_________________________->KeyA_); TESTFInputfaces,__________________",
        "confidence": 0.9220528602600098,
        "hesitated": false,
        "resolved": false
    }
]