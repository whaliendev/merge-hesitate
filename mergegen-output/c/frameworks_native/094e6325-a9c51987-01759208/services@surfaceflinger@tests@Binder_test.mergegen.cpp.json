[
    {
        "a_contents": "/*\n * Copyright 2023 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <errno.h>\n#include <sched.h>\n\n#include <android/gui/ISurfaceComposer.h>\n#include <android/gui/ISurfaceComposerClient.h>\n#include <binder/IBinder.h>\n#include <binder/IServiceManager.h>\n#include <gtest/gtest.h>\n#include <gui/ISurfaceComposer.h>\n\n#include <com_android_graphics_surfaceflinger_flags.h>\n\nnamespace android::test {\nusing namespace com::android::graphics::surfaceflinger;\n\nclass BinderTest : public ::testing::Test {\nprotected:\n    BinderTest();\n\n    void SetUp() override;\n\n    void getSchedulingPolicy(gui::SchedulingPolicy* outPolicy);\n    void getNonAidlSchedulingPolicy(gui::SchedulingPolicy* outPolicy);\n    void getClientSchedulingPolicy(gui::SchedulingPolicy* outPolicy);\n    void getDisplayEventConnectionSchedulingPolicy(gui::SchedulingPolicy* outPolicy);\n\nprivate:\n    sp<gui::ISurfaceComposer> mISurfaceComposerAidl;\n    sp<ISurfaceComposer> mISurfaceComposer;\n    sp<gui::ISurfaceComposerClient> mISurfaceComposerClient;\n    sp<gui::IDisplayEventConnection> mConnection;\n};\n\nBinderTest::BinderTest() {\n    const String16 name(\"SurfaceFlingerAIDL\");\n    mISurfaceComposerAidl = waitForService<gui::ISurfaceComposer>(String16(\"SurfaceFlingerAIDL\"));\n    mISurfaceComposer = waitForService<ISurfaceComposer>(String16(\"SurfaceFlinger\"));\n    mISurfaceComposerAidl->createConnection(&mISurfaceComposerClient);\n    mISurfaceComposerAidl\n            ->createDisplayEventConnection(gui::ISurfaceComposer::VsyncSource::eVsyncSourceApp,\n                                           gui::ISurfaceComposer::EventRegistration(0), {},\n                                           &mConnection);\n}\n\nvoid BinderTest::SetUp() {\n    ASSERT_TRUE(mISurfaceComposerAidl);\n    ASSERT_TRUE(mISurfaceComposer);\n    ASSERT_TRUE(mISurfaceComposerClient);\n    ASSERT_TRUE(mConnection);\n}\n\nvoid BinderTest::getSchedulingPolicy(gui::SchedulingPolicy* outPolicy) {\n    const auto status = mISurfaceComposerAidl->getSchedulingPolicy(outPolicy);\n    ASSERT_TRUE(status.isOk());\n}\n\nvoid BinderTest::getNonAidlSchedulingPolicy(gui::SchedulingPolicy* outPolicy) {\n    Parcel data, reply;\n    const status_t status =\n            IInterface::asBinder(mISurfaceComposer)\n                    ->transact(BnSurfaceComposer::GET_SCHEDULING_POLICY, data, &reply);\n    ASSERT_EQ(OK, status);\n\n    outPolicy->policy = reply.readInt32();\n    outPolicy->priority = reply.readInt32();\n}\n\nvoid BinderTest::getClientSchedulingPolicy(gui::SchedulingPolicy* outPolicy) {\n    const auto status = mISurfaceComposerClient->getSchedulingPolicy(outPolicy);\n    ASSERT_TRUE(status.isOk());\n}\n\nvoid BinderTest::getDisplayEventConnectionSchedulingPolicy(gui::SchedulingPolicy* outPolicy) {\n    const auto status = mConnection->getSchedulingPolicy(outPolicy);\n    ASSERT_TRUE(status.isOk());\n}\n\nTEST_F(BinderTest, SchedulingPolicy) {\n    if (!flags::misc1()) GTEST_SKIP();\n\n    const int policy = SCHED_FIFO;\n    const int priority = sched_get_priority_min(policy);\n\n    gui::SchedulingPolicy sfPolicy;\n    ASSERT_NO_FATAL_FAILURE(getSchedulingPolicy(&sfPolicy));\n\n    ASSERT_EQ(policy, sfPolicy.policy & (~SCHED_RESET_ON_FORK));\n    ASSERT_EQ(priority, sfPolicy.priority);\n}\n\nTEST_F(BinderTest, NonAidlSchedulingPolicy) {\n    const int policy = SCHED_FIFO;\n    const int priority = sched_get_priority_min(policy);\n\n    gui::SchedulingPolicy sfPolicy;\n    ASSERT_NO_FATAL_FAILURE(getNonAidlSchedulingPolicy(&sfPolicy));\n\n    ASSERT_EQ(policy, sfPolicy.policy & (~SCHED_RESET_ON_FORK));\n    ASSERT_EQ(priority, sfPolicy.priority);\n}\n\nTEST_F(BinderTest, ClientSchedulingPolicy) {\n    if (!flags::misc1()) GTEST_SKIP();\n\n    const int policy = SCHED_FIFO;\n    const int priority = sched_get_priority_min(policy);\n\n    gui::SchedulingPolicy sfPolicy;\n    ASSERT_NO_FATAL_FAILURE(getClientSchedulingPolicy(&sfPolicy));\n\n    ASSERT_EQ(policy, sfPolicy.policy & (~SCHED_RESET_ON_FORK));\n    ASSERT_EQ(priority, sfPolicy.priority);\n}\n\nTEST_F(BinderTest, DisplayEventConnectionSchedulingPolicy) {\n    if (!flags::misc1()) GTEST_SKIP();\n\n    const int policy = SCHED_FIFO;\n    const int priority = sched_get_priority_min(policy);\n\n    gui::SchedulingPolicy sfPolicy;\n    ASSERT_NO_FATAL_FAILURE(getDisplayEventConnectionSchedulingPolicy(&sfPolicy));\n\n    ASSERT_EQ(policy, sfPolicy.policy & (~SCHED_RESET_ON_FORK));\n    ASSERT_EQ(priority, sfPolicy.priority);\n}\n\nclass BinderTestRtCaller : public BinderTest {\nprotected:\n    void SetUp() override;\n    void TearDown() override;\n\nprivate:\n    int mOrigPolicy;\n    int mOrigPriority;\n};\n\nvoid BinderTestRtCaller::SetUp() {\n    const int policy = SCHED_FIFO;\n    const int priority = sched_get_priority_min(policy);\n\n    mOrigPolicy = sched_getscheduler(0);\n    struct sched_param origSchedParam;\n    ASSERT_GE(0, sched_getparam(0, &origSchedParam)) << \"errno: \" << strerror(errno);\n    mOrigPriority = origSchedParam.sched_priority;\n\n    struct sched_param param;\n    param.sched_priority = priority;\n    ASSERT_GE(0, sched_setscheduler(0, policy, &param)) << \"errno: \" << strerror(errno);\n}\n\nvoid BinderTestRtCaller::TearDown() {\n    struct sched_param origSchedParam;\n    origSchedParam.sched_priority = mOrigPriority;\n    ASSERT_GE(0, sched_setscheduler(0, mOrigPolicy, &origSchedParam))\n            << \"errno: \" << strerror(errno);\n}\n\nTEST_F(BinderTestRtCaller, SchedulingPolicy) {\n    if (!flags::misc1()) GTEST_SKIP();\n\n    const int policy = SCHED_FIFO;\n    const int priority = sched_get_priority_min(policy);\n\n    gui::SchedulingPolicy sfPolicy;\n    ASSERT_NO_FATAL_FAILURE(getSchedulingPolicy(&sfPolicy));\n\n    ASSERT_EQ(policy, sfPolicy.policy & (~SCHED_RESET_ON_FORK));\n    ASSERT_EQ(priority, sfPolicy.priority);\n}\n\nTEST_F(BinderTestRtCaller, NonAidlSchedulingPolicy) {\n    const int policy = SCHED_FIFO;\n    const int priority = sched_get_priority_min(policy);\n\n    gui::SchedulingPolicy sfPolicy;\n    ASSERT_NO_FATAL_FAILURE(getNonAidlSchedulingPolicy(&sfPolicy));\n\n    ASSERT_EQ(policy, sfPolicy.policy & (~SCHED_RESET_ON_FORK));\n    ASSERT_EQ(priority, sfPolicy.priority);\n}\n\nTEST_F(BinderTestRtCaller, ClientSchedulingPolicy) {\n    if (!flags::misc1()) GTEST_SKIP();\n\n    const int policy = SCHED_FIFO;\n    const int priority = sched_get_priority_min(policy);\n\n    gui::SchedulingPolicy sfPolicy;\n    ASSERT_NO_FATAL_FAILURE(getClientSchedulingPolicy(&sfPolicy));\n\n    ASSERT_EQ(policy, sfPolicy.policy & (~SCHED_RESET_ON_FORK));\n    ASSERT_EQ(priority, sfPolicy.priority);\n}\n\nTEST_F(BinderTestRtCaller, DisplayEventConnectionSchedulingPolicy) {\n    if (!flags::misc1()) GTEST_SKIP();\n\n    const int policy = SCHED_FIFO;\n    const int priority = sched_get_priority_min(policy);\n\n    gui::SchedulingPolicy sfPolicy;\n    ASSERT_NO_FATAL_FAILURE(getDisplayEventConnectionSchedulingPolicy(&sfPolicy));\n\n    ASSERT_EQ(policy, sfPolicy.policy & (~SCHED_RESET_ON_FORK));\n    ASSERT_EQ(priority, sfPolicy.priority);\n}\n\n} // namespace android::test",
        "b_contents": "/*\n * Copyright 2023 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <errno.h>\n#include <sched.h>\n\n#include <android/gui/ISurfaceComposer.h>\n#include <android/gui/ISurfaceComposerClient.h>\n#include <binder/IBinder.h>\n#include <binder/IServiceManager.h>\n#include <gtest/gtest.h>\n#include <gui/ISurfaceComposer.h>\n\nnamespace android::test {\n\nclass BinderTest : public ::testing::Test {\nprotected:\n    BinderTest();\n\n    void SetUp() override;\n\n    void getSchedulingPolicy(gui::SchedulingPolicy* outPolicy);\n    void getNonAidlSchedulingPolicy(gui::SchedulingPolicy* outPolicy);\n    void getClientSchedulingPolicy(gui::SchedulingPolicy* outPolicy);\n    void getDisplayEventConnectionSchedulingPolicy(gui::SchedulingPolicy* outPolicy);\n\nprivate:\n    sp<gui::ISurfaceComposer> mISurfaceComposerAidl;\n    sp<ISurfaceComposer> mISurfaceComposer;\n    sp<gui::ISurfaceComposerClient> mISurfaceComposerClient;\n    sp<gui::IDisplayEventConnection> mConnection;\n};\n\nBinderTest::BinderTest() {\n    const String16 name(\"SurfaceFlingerAIDL\");\n    mISurfaceComposerAidl = waitForService<gui::ISurfaceComposer>(String16(\"SurfaceFlingerAIDL\"));\n    mISurfaceComposer = waitForService<ISurfaceComposer>(String16(\"SurfaceFlinger\"));\n    mISurfaceComposerAidl->createConnection(&mISurfaceComposerClient);\n    mISurfaceComposerAidl\n            ->createDisplayEventConnection(gui::ISurfaceComposer::VsyncSource::eVsyncSourceApp,\n                                           gui::ISurfaceComposer::EventRegistration(0), {},\n                                           &mConnection);\n}\n\nvoid BinderTest::SetUp() {\n    ASSERT_TRUE(mISurfaceComposerAidl);\n    ASSERT_TRUE(mISurfaceComposer);\n    ASSERT_TRUE(mISurfaceComposerClient);\n    ASSERT_TRUE(mConnection);\n}\n\nvoid BinderTest::getSchedulingPolicy(gui::SchedulingPolicy* outPolicy) {\n    const auto status = mISurfaceComposerAidl->getSchedulingPolicy(outPolicy);\n    ASSERT_TRUE(status.isOk());\n}\n\nvoid BinderTest::getNonAidlSchedulingPolicy(gui::SchedulingPolicy* outPolicy) {\n    Parcel data, reply;\n    const status_t status =\n            IInterface::asBinder(mISurfaceComposer)\n                    ->transact(BnSurfaceComposer::GET_SCHEDULING_POLICY, data, &reply);\n    ASSERT_EQ(OK, status);\n\n    outPolicy->policy = reply.readInt32();\n    outPolicy->priority = reply.readInt32();\n}\n\nvoid BinderTest::getClientSchedulingPolicy(gui::SchedulingPolicy* outPolicy) {\n    const auto status = mISurfaceComposerClient->getSchedulingPolicy(outPolicy);\n    ASSERT_TRUE(status.isOk());\n}\n\nvoid BinderTest::getDisplayEventConnectionSchedulingPolicy(gui::SchedulingPolicy* outPolicy) {\n    const auto status = mConnection->getSchedulingPolicy(outPolicy);\n    ASSERT_TRUE(status.isOk());\n}\n\nTEST_F(BinderTest, SchedulingPolicy) {\n    const int policy = SCHED_FIFO;\n    const int priority = sched_get_priority_min(policy);\n\n    gui::SchedulingPolicy sfPolicy;\n    ASSERT_NO_FATAL_FAILURE(getSchedulingPolicy(&sfPolicy));\n\n    ASSERT_EQ(policy, sfPolicy.policy & (~SCHED_RESET_ON_FORK));\n    ASSERT_EQ(priority, sfPolicy.priority);\n}\n\nTEST_F(BinderTest, NonAidlSchedulingPolicy) {\n    const int policy = SCHED_FIFO;\n    const int priority = sched_get_priority_min(policy);\n\n    gui::SchedulingPolicy sfPolicy;\n    ASSERT_NO_FATAL_FAILURE(getNonAidlSchedulingPolicy(&sfPolicy));\n\n    ASSERT_EQ(policy, sfPolicy.policy & (~SCHED_RESET_ON_FORK));\n    ASSERT_EQ(priority, sfPolicy.priority);\n}\n\nTEST_F(BinderTest, ClientSchedulingPolicy) {\n    const int policy = SCHED_FIFO;\n    const int priority = sched_get_priority_min(policy);\n\n    gui::SchedulingPolicy sfPolicy;\n    ASSERT_NO_FATAL_FAILURE(getClientSchedulingPolicy(&sfPolicy));\n\n    ASSERT_EQ(policy, sfPolicy.policy & (~SCHED_RESET_ON_FORK));\n    ASSERT_EQ(priority, sfPolicy.priority);\n}\n\nTEST_F(BinderTest, DisplayEventConnectionSchedulingPolicy) {\n    const int policy = SCHED_FIFO;\n    const int priority = sched_get_priority_min(policy);\n\n    gui::SchedulingPolicy sfPolicy;\n    ASSERT_NO_FATAL_FAILURE(getDisplayEventConnectionSchedulingPolicy(&sfPolicy));\n\n    ASSERT_EQ(policy, sfPolicy.policy & (~SCHED_RESET_ON_FORK));\n    ASSERT_EQ(priority, sfPolicy.priority);\n}\n\nclass BinderTestRtCaller : public BinderTest {\nprotected:\n    void SetUp() override;\n    void TearDown() override;\n\nprivate:\n    int mOrigPolicy;\n    int mOrigPriority;\n};\n\nvoid BinderTestRtCaller::SetUp() {\n    const int policy = SCHED_FIFO;\n    const int priority = sched_get_priority_min(policy);\n\n    mOrigPolicy = sched_getscheduler(0);\n    struct sched_param origSchedParam;\n    ASSERT_GE(0, sched_getparam(0, &origSchedParam)) << \"errno: \" << strerror(errno);\n    mOrigPriority = origSchedParam.sched_priority;\n\n    struct sched_param param;\n    param.sched_priority = priority;\n    ASSERT_GE(0, sched_setscheduler(0, policy, &param)) << \"errno: \" << strerror(errno);\n}\n\nvoid BinderTestRtCaller::TearDown() {\n    struct sched_param origSchedParam;\n    origSchedParam.sched_priority = mOrigPriority;\n    ASSERT_GE(0, sched_setscheduler(0, mOrigPolicy, &origSchedParam))\n            << \"errno: \" << strerror(errno);\n}\n\nTEST_F(BinderTestRtCaller, SchedulingPolicy) {\n    const int policy = SCHED_FIFO;\n    const int priority = sched_get_priority_min(policy);\n\n    gui::SchedulingPolicy sfPolicy;\n    ASSERT_NO_FATAL_FAILURE(getSchedulingPolicy(&sfPolicy));\n\n    ASSERT_EQ(policy, sfPolicy.policy & (~SCHED_RESET_ON_FORK));\n    ASSERT_EQ(priority, sfPolicy.priority);\n}\n\nTEST_F(BinderTestRtCaller, NonAidlSchedulingPolicy) {\n    const int policy = SCHED_FIFO;\n    const int priority = sched_get_priority_min(policy);\n\n    gui::SchedulingPolicy sfPolicy;\n    ASSERT_NO_FATAL_FAILURE(getNonAidlSchedulingPolicy(&sfPolicy));\n\n    ASSERT_EQ(policy, sfPolicy.policy & (~SCHED_RESET_ON_FORK));\n    ASSERT_EQ(priority, sfPolicy.priority);\n}\n\nTEST_F(BinderTestRtCaller, ClientSchedulingPolicy) {\n    const int policy = SCHED_FIFO;\n    const int priority = sched_get_priority_min(policy);\n\n    gui::SchedulingPolicy sfPolicy;\n    ASSERT_NO_FATAL_FAILURE(getClientSchedulingPolicy(&sfPolicy));\n\n    ASSERT_EQ(policy, sfPolicy.policy & (~SCHED_RESET_ON_FORK));\n    ASSERT_EQ(priority, sfPolicy.priority);\n}\n\nTEST_F(BinderTestRtCaller, DisplayEventConnectionSchedulingPolicy) {\n    const int policy = SCHED_FIFO;\n    const int priority = sched_get_priority_min(policy);\n\n    gui::SchedulingPolicy sfPolicy;\n    ASSERT_NO_FATAL_FAILURE(getDisplayEventConnectionSchedulingPolicy(&sfPolicy));\n\n    ASSERT_EQ(policy, sfPolicy.policy & (~SCHED_RESET_ON_FORK));\n    ASSERT_EQ(priority, sfPolicy.priority);\n}\n\n} // namespace android::test",
        "base_contents": "",
        "res_region": "/*\n * Copyright 2023 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <errno.h>\n#include <sched.h>\n\n#include <android/gui/ISurfaceComposer.h>\n#include <android/gui/ISurfaceComposerClient.h>\n#include <binder/IBinder.h>\n#include <binder/IServiceManager.h>\n#include <gtest/gtest.h>\n#include <gui/ISurfaceComposer.h>\n\n#include <com_android_graphics_surfaceflinger_flags.h>\n\nnamespace android::test {\nusing namespace com::android::graphics::surfaceflinger;\n\nclass BinderTest : public ::testing::Test {\nprotected:\n    BinderTest();\n\n    void SetUp() override;\n\n    void getSchedulingPolicy(gui::SchedulingPolicy* outPolicy);\n    void getNonAidlSchedulingPolicy(gui::SchedulingPolicy* outPolicy);\n    void getClientSchedulingPolicy(gui::SchedulingPolicy* outPolicy);\n    void getDisplayEventConnectionSchedulingPolicy(gui::SchedulingPolicy* outPolicy);\n\nprivate:\n    sp<gui::ISurfaceComposer> mISurfaceComposerAidl;\n    sp<ISurfaceComposer> mISurfaceComposer;\n    sp<gui::ISurfaceComposerClient> mISurfaceComposerClient;\n    sp<gui::IDisplayEventConnection> mConnection;\n};\n\nBinderTest::BinderTest() {\n    const String16 name(\"SurfaceFlingerAIDL\");\n    mISurfaceComposerAidl = waitForService<gui::ISurfaceComposer>(String16(\"SurfaceFlingerAIDL\"));\n    mISurfaceComposer = waitForService<ISurfaceComposer>(String16(\"SurfaceFlinger\"));\n    mISurfaceComposerAidl->createConnection(&mISurfaceComposerClient);\n    mISurfaceComposerAidl\n            ->createDisplayEventConnection(gui::ISurfaceComposer::VsyncSource::eVsyncSourceApp,\n                                           gui::ISurfaceComposer::EventRegistration(0), {},\n                                           &mConnection);\n}\n\nvoid BinderTest::SetUp() {\n    ASSERT_TRUE(mISurfaceComposerAidl);\n    ASSERT_TRUE(mISurfaceComposer);\n    ASSERT_TRUE(mISurfaceComposerClient);\n    ASSERT_TRUE(mConnection);\n}\n\nvoid BinderTest::getSchedulingPolicy(gui::SchedulingPolicy* outPolicy) {\n    const auto status = mISurfaceComposerAidl->getSchedulingPolicy(outPolicy);\n    ASSERT_TRUE(status.isOk());\n}\n\nvoid BinderTest::getNonAidlSchedulingPolicy(gui::SchedulingPolicy* outPolicy) {\n    Parcel data, reply;\n    const status_t status =\n            IInterface::asBinder(mISurfaceComposer)\n                    ->transact(BnSurfaceComposer::GET_SCHEDULING_POLICY, data, &reply);\n    ASSERT_EQ(OK, status);\n\n    outPolicy->policy = reply.readInt32();\n    outPolicy->priority = reply.readInt32();\n}\n\nvoid BinderTest::getClientSchedulingPolicy(gui::SchedulingPolicy* outPolicy) {\n    const auto status = mISurfaceComposerClient->getSchedulingPolicy(outPolicy);\n    ASSERT_TRUE(status.isOk());\n}\n\nvoid BinderTest::getDisplayEventConnectionSchedulingPolicy(gui::SchedulingPolicy* outPolicy) {\n    const auto status = mConnection->getSchedulingPolicy(outPolicy);\n    ASSERT_TRUE(status.isOk());\n}\n\nTEST_F(BinderTest, SchedulingPolicy) {\n    if (!flags::misc1()) GTEST_SKIP();\n\n    const int policy = SCHED_FIFO;\n    const int priority = sched_get_priority_min(policy);\n\n    gui::SchedulingPolicy sfPolicy;\n    ASSERT_NO_FATAL_FAILURE(getSchedulingPolicy(&sfPolicy));\n\n    ASSERT_EQ(policy, sfPolicy.policy & (~SCHED_RESET_ON_FORK));\n    ASSERT_EQ(priority, sfPolicy.priority);\n}\n\nTEST_F(BinderTest, NonAidlSchedulingPolicy) {\n    const int policy = SCHED_FIFO;\n    const int priority = sched_get_priority_min(policy);\n\n    gui::SchedulingPolicy sfPolicy;\n    ASSERT_NO_FATAL_FAILURE(getNonAidlSchedulingPolicy(&sfPolicy));\n\n    ASSERT_EQ(policy, sfPolicy.policy & (~SCHED_RESET_ON_FORK));\n    ASSERT_EQ(priority, sfPolicy.priority);\n}\n\nTEST_F(BinderTest, ClientSchedulingPolicy) {\n    if (!flags::misc1()) GTEST_SKIP();\n\n    const int policy = SCHED_FIFO;\n    const int priority = sched_get_priority_min(policy);\n\n    gui::SchedulingPolicy sfPolicy;\n    ASSERT_NO_FATAL_FAILURE(getClientSchedulingPolicy(&sfPolicy));\n\n    ASSERT_EQ(policy, sfPolicy.policy & (~SCHED_RESET_ON_FORK));\n    ASSERT_EQ(priority, sfPolicy.priority);\n}\n\nTEST_F(BinderTest, DisplayEventConnectionSchedulingPolicy) {\n    if (!flags::misc1()) GTEST_SKIP();\n\n    const int policy = SCHED_FIFO;\n    const int priority = sched_get_priority_min(policy);\n\n    gui::SchedulingPolicy sfPolicy;\n    ASSERT_NO_FATAL_FAILURE(getDisplayEventConnectionSchedulingPolicy(&sfPolicy));\n\n    ASSERT_EQ(policy, sfPolicy.policy & (~SCHED_RESET_ON_FORK));\n    ASSERT_EQ(priority, sfPolicy.priority);\n}\n\nclass BinderTestRtCaller : public BinderTest {\nprotected:\n    void SetUp() override;\n    void TearDown() override;\n\nprivate:\n    int mOrigPolicy;\n    int mOrigPriority;\n};\n\nvoid BinderTestRtCaller::SetUp() {\n    const int policy = SCHED_FIFO;\n    const int priority = sched_get_priority_min(policy);\n\n    mOrigPolicy = sched_getscheduler(0);\n    struct sched_param origSchedParam;\n    ASSERT_GE(0, sched_getparam(0, &origSchedParam)) << \"errno: \" << strerror(errno);\n    mOrigPriority = origSchedParam.sched_priority;\n\n    struct sched_param param;\n    param.sched_priority = priority;\n    ASSERT_GE(0, sched_setscheduler(0, policy, &param)) << \"errno: \" << strerror(errno);\n}\n\nvoid BinderTestRtCaller::TearDown() {\n    struct sched_param origSchedParam;\n    origSchedParam.sched_priority = mOrigPriority;\n    ASSERT_GE(0, sched_setscheduler(0, mOrigPolicy, &origSchedParam))\n            << \"errno: \" << strerror(errno);\n}\n\nTEST_F(BinderTestRtCaller, SchedulingPolicy) {\n    if (!flags::misc1()) GTEST_SKIP();\n\n    const int policy = SCHED_FIFO;\n    const int priority = sched_get_priority_min(policy);\n\n    gui::SchedulingPolicy sfPolicy;\n    ASSERT_NO_FATAL_FAILURE(getSchedulingPolicy(&sfPolicy));\n\n    ASSERT_EQ(policy, sfPolicy.policy & (~SCHED_RESET_ON_FORK));\n    ASSERT_EQ(priority, sfPolicy.priority);\n}\n\nTEST_F(BinderTestRtCaller, NonAidlSchedulingPolicy) {\n    const int policy = SCHED_FIFO;\n    const int priority = sched_get_priority_min(policy);\n\n    gui::SchedulingPolicy sfPolicy;\n    ASSERT_NO_FATAL_FAILURE(getNonAidlSchedulingPolicy(&sfPolicy));\n\n    ASSERT_EQ(policy, sfPolicy.policy & (~SCHED_RESET_ON_FORK));\n    ASSERT_EQ(priority, sfPolicy.priority);\n}\n\nTEST_F(BinderTestRtCaller, ClientSchedulingPolicy) {\n    if (!flags::misc1()) GTEST_SKIP();\n\n    const int policy = SCHED_FIFO;\n    const int priority = sched_get_priority_min(policy);\n\n    gui::SchedulingPolicy sfPolicy;\n    ASSERT_NO_FATAL_FAILURE(getClientSchedulingPolicy(&sfPolicy));\n\n    ASSERT_EQ(policy, sfPolicy.policy & (~SCHED_RESET_ON_FORK));\n    ASSERT_EQ(priority, sfPolicy.priority);\n}\n\nTEST_F(BinderTestRtCaller, DisplayEventConnectionSchedulingPolicy) {\n    if (!flags::misc1()) GTEST_SKIP();\n\n    const int policy = SCHED_FIFO;\n    const int priority = sched_get_priority_min(policy);\n\n    gui::SchedulingPolicy sfPolicy;\n    ASSERT_NO_FATAL_FAILURE(getDisplayEventConnectionSchedulingPolicy(&sfPolicy));\n\n    ASSERT_EQ(policy, sfPolicy.policy & (~SCHED_RESET_ON_FORK));\n    ASSERT_EQ(priority, sfPolicy.priority);\n}\n\n} // namespace android::test",
        "lookback": " * Copyright 2023 The Android Open Source Project",
        "lookahead": "",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 0,
        "end_line": 438,
        "merge_gen_region": " Copyright023 Android Source/* Copyright023 Android Source * Licensed the Apache, 2. ( \"\"); you not this except in with License * may a of License * may a of License * *://..///LICENSE20 * Unless by applicable or to writing software distributed the is on \" IS BASIS * WITHOUT OR OF KIND either or. See License for specific governing and limitations the License */includeerrnoh # <.>includeschedh # <androidguiISComposerh # <//urfaceClienth # <binderIB.>includebinderISManager.>includegtestgtesthh # <//Composerh # </urface.>includecomandroidgraphicssurfacelinger_.h namespace::test using comandroidgraphicssurfacelinger classer : ::::Test protected BindTest void(); getuling(::uling*Policy); getAScheduling(::uling*Policy voidNonidlulingPolicyguiSchedPolicy(::uling*Policy voidClientuling(::uling*Policy voidDisplayConnectionuling(::uling*Policy private spguiISComposer murfaceAidl spISComposer murface;<<urface>ISComposerurfaceClient murfaceClient spguiIDplayConnection m; BindTestBinder() { String nameSurfaceA\");ISComposer",
        "confidence": 0.9254608750343323,
        "hesitated": false,
        "resolved": false
    }
]