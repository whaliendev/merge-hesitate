[
    {
        "a_contents": "",
        "b_contents": "    status_t getDisplayState(const sp<IBinder>& display, ui::DisplayState* state) override {\n        Parcel data, reply;\n        data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());\n        data.writeStrongBinder(display);\n        remote()->transact(BnSurfaceComposer::GET_DISPLAY_STATE, data, &reply);\n        const status_t result = reply.readInt32();\n        if (result == NO_ERROR) {\n            memcpy(state, reply.readInplace(sizeof(ui::DisplayState)), sizeof(ui::DisplayState));\n        }\n        return result;\n    }\n\n    status_t getStaticDisplayInfo(const sp<IBinder>& display,\n                                  ui::StaticDisplayInfo* info) override {\n        Parcel data, reply;\n        data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());\n        data.writeStrongBinder(display);\n        remote()->transact(BnSurfaceComposer::GET_STATIC_DISPLAY_INFO, data, &reply);\n        const status_t result = reply.readInt32();\n        if (result != NO_ERROR) return result;\n        return reply.read(*info);\n    }\n\n    status_t getDynamicDisplayInfo(const sp<IBinder>& display,\n                                   ui::DynamicDisplayInfo* info) override {\n        Parcel data, reply;\n        data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());\n        data.writeStrongBinder(display);\n        remote()->transact(BnSurfaceComposer::GET_DYNAMIC_DISPLAY_INFO, data, &reply);\n        const status_t result = reply.readInt32();\n        if (result != NO_ERROR) return result;\n        return reply.read(*info);\n    }\n\n    status_t getDisplayStats(const sp<IBinder>& display, DisplayStatInfo* stats) override {\n        Parcel data, reply;\n        data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());\n        data.writeStrongBinder(display);\n        remote()->transact(BnSurfaceComposer::GET_DISPLAY_STATS, data, &reply);\n        status_t result = reply.readInt32();\n        if (result == NO_ERROR) {\n            memcpy(stats,\n                    reply.readInplace(sizeof(DisplayStatInfo)),\n                    sizeof(DisplayStatInfo));\n        }\n        return result;\n    }\n\n    status_t getDisplayNativePrimaries(const sp<IBinder>& display,\n                                       ui::DisplayPrimaries& primaries) override {\n        Parcel data, reply;\n        status_t result = data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());\n        if (result != NO_ERROR) {\n            ALOGE(\"getDisplayNativePrimaries failed to writeInterfaceToken: %d\", result);\n            return result;\n        }\n        result = data.writeStrongBinder(display);\n        if (result != NO_ERROR) {\n            ALOGE(\"getDisplayNativePrimaries failed to writeStrongBinder: %d\", result);\n            return result;\n        }\n        result = remote()->transact(BnSurfaceComposer::GET_DISPLAY_NATIVE_PRIMARIES, data, &reply);\n        if (result != NO_ERROR) {\n            ALOGE(\"getDisplayNativePrimaries failed to transact: %d\", result);\n            return result;\n        }\n        result = reply.readInt32();\n        if (result == NO_ERROR) {\n            memcpy(&primaries, reply.readInplace(sizeof(ui::DisplayPrimaries)),\n                    sizeof(ui::DisplayPrimaries));\n        }\n        return result;\n    }\n\n    status_t setActiveColorMode(const sp<IBinder>& display, ColorMode colorMode) override {\n        Parcel data, reply;\n        status_t result = data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());\n        if (result != NO_ERROR) {\n            ALOGE(\"setActiveColorMode failed to writeInterfaceToken: %d\", result);\n            return result;\n        }\n        result = data.writeStrongBinder(display);\n        if (result != NO_ERROR) {\n            ALOGE(\"setActiveColorMode failed to writeStrongBinder: %d\", result);\n            return result;\n        }\n        result = data.writeInt32(static_cast<int32_t>(colorMode));\n        if (result != NO_ERROR) {\n            ALOGE(\"setActiveColorMode failed to writeInt32: %d\", result);\n            return result;\n        }\n        result = remote()->transact(BnSurfaceComposer::SET_ACTIVE_COLOR_MODE, data, &reply);\n        if (result != NO_ERROR) {\n            ALOGE(\"setActiveColorMode failed to transact: %d\", result);\n            return result;\n        }\n        return static_cast<status_t>(reply.readInt32());\n    }\n\n    status_t setBootDisplayMode(const sp<IBinder>& display,\n                                ui::DisplayModeId displayModeId) override {\n        Parcel data, reply;\n        status_t result = data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());\n        if (result != NO_ERROR) {\n            ALOGE(\"setBootDisplayMode failed to writeInterfaceToken: %d\", result);\n            return result;\n        }\n        result = data.writeStrongBinder(display);\n        if (result != NO_ERROR) {\n            ALOGE(\"setBootDisplayMode failed to writeStrongBinder: %d\", result);\n            return result;\n        }\n        result = data.writeInt32(displayModeId);\n        if (result != NO_ERROR) {\n            ALOGE(\"setBootDisplayMode failed to writeIint32: %d\", result);\n            return result;\n        }\n        result = remote()->transact(BnSurfaceComposer::SET_BOOT_DISPLAY_MODE, data, &reply);\n        if (result != NO_ERROR) {\n            ALOGE(\"setBootDisplayMode failed to transact: %d\", result);\n        }\n        return result;\n    }\n\n    status_t clearAnimationFrameStats() override {\n        Parcel data, reply;\n        status_t result = data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());\n        if (result != NO_ERROR) {\n            ALOGE(\"clearAnimationFrameStats failed to writeInterfaceToken: %d\", result);\n            return result;\n        }\n        result = remote()->transact(BnSurfaceComposer::CLEAR_ANIMATION_FRAME_STATS, data, &reply);\n        if (result != NO_ERROR) {\n            ALOGE(\"clearAnimationFrameStats failed to transact: %d\", result);\n            return result;\n        }\n        return reply.readInt32();\n    }\n\n    status_t getAnimationFrameStats(FrameStats* outStats) const override {\n        Parcel data, reply;\n        data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());\n        remote()->transact(BnSurfaceComposer::GET_ANIMATION_FRAME_STATS, data, &reply);\n        reply.read(*outStats);\n        return reply.readInt32();\n    }\n\n    virtual status_t overrideHdrTypes(const sp<IBinder>& display,\n                                      const std::vector<ui::Hdr>& hdrTypes) {\n        Parcel data, reply;\n        SAFE_PARCEL(data.writeInterfaceToken, ISurfaceComposer::getInterfaceDescriptor());\n        SAFE_PARCEL(data.writeStrongBinder, display);\n\n        std::vector<int32_t> hdrTypesVector;\n        for (ui::Hdr i : hdrTypes) {\n            hdrTypesVector.push_back(static_cast<int32_t>(i));\n        }\n        SAFE_PARCEL(data.writeInt32Vector, hdrTypesVector);\n\n        status_t result = remote()->transact(BnSurfaceComposer::OVERRIDE_HDR_TYPES, data, &reply);\n        if (result != NO_ERROR) {\n            ALOGE(\"overrideHdrTypes failed to transact: %d\", result);\n            return result;\n        }\n        return result;\n    }\n\n    status_t onPullAtom(const int32_t atomId, std::string* pulledData, bool* success) {\n        Parcel data, reply;\n        SAFE_PARCEL(data.writeInterfaceToken, ISurfaceComposer::getInterfaceDescriptor());\n        SAFE_PARCEL(data.writeInt32, atomId);\n\n        status_t err = remote()->transact(BnSurfaceComposer::ON_PULL_ATOM, data, &reply);\n        if (err != NO_ERROR) {\n            ALOGE(\"onPullAtom failed to transact: %d\", err);\n            return err;\n        }\n\n        int32_t size = 0;\n        SAFE_PARCEL(reply.readInt32, &size);\n        const void* dataPtr = reply.readInplace(size);\n        if (dataPtr == nullptr) {\n            return UNEXPECTED_NULL;\n        }\n        pulledData->assign((const char*)dataPtr, size);\n        SAFE_PARCEL(reply.readBool, success);\n        return NO_ERROR;\n    }\n\n    status_t enableVSyncInjections(bool enable) override {\n        Parcel data, reply;\n        status_t result = data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());\n        if (result != NO_ERROR) {\n            ALOGE(\"enableVSyncInjections failed to writeInterfaceToken: %d\", result);\n            return result;\n        }\n        result = data.writeBool(enable);\n        if (result != NO_ERROR) {\n            ALOGE(\"enableVSyncInjections failed to writeBool: %d\", result);\n            return result;\n        }\n        result = remote()->transact(BnSurfaceComposer::ENABLE_VSYNC_INJECTIONS, data, &reply,\n                                    IBinder::FLAG_ONEWAY);\n        if (result != NO_ERROR) {\n            ALOGE(\"enableVSyncInjections failed to transact: %d\", result);\n            return result;\n        }\n        return result;\n    }\n\n    status_t injectVSync(nsecs_t when) override {\n        Parcel data, reply;\n        status_t result = data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());\n        if (result != NO_ERROR) {\n            ALOGE(\"injectVSync failed to writeInterfaceToken: %d\", result);\n            return result;\n        }\n        result = data.writeInt64(when);\n        if (result != NO_ERROR) {\n            ALOGE(\"injectVSync failed to writeInt64: %d\", result);\n            return result;\n        }\n        result = remote()->transact(BnSurfaceComposer::INJECT_VSYNC, data, &reply,\n                                    IBinder::FLAG_ONEWAY);\n        if (result != NO_ERROR) {\n            ALOGE(\"injectVSync failed to transact: %d\", result);\n            return result;\n        }\n        return result;\n    }\n\n    status_t getLayerDebugInfo(std::vector<LayerDebugInfo>* outLayers) override {\n        if (!outLayers) {\n            return UNEXPECTED_NULL;\n        }\n\n        Parcel data, reply;\n\n        status_t err = data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());\n        if (err != NO_ERROR) {\n            return err;\n        }\n\n        err = remote()->transact(BnSurfaceComposer::GET_LAYER_DEBUG_INFO, data, &reply);\n        if (err != NO_ERROR) {\n            return err;\n        }\n\n        int32_t result = 0;\n        err = reply.readInt32(&result);\n        if (err != NO_ERROR) {\n            return err;\n        }\n        if (result != NO_ERROR) {\n            return result;\n        }\n\n        outLayers->clear();\n        return reply.readParcelableVector(outLayers);\n    }\n\n    status_t getCompositionPreference(ui::Dataspace* defaultDataspace,\n                                      ui::PixelFormat* defaultPixelFormat,\n                                      ui::Dataspace* wideColorGamutDataspace,\n                                      ui::PixelFormat* wideColorGamutPixelFormat) const override {\n        Parcel data, reply;\n        status_t error = data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());\n        if (error != NO_ERROR) {\n            return error;\n        }\n        error = remote()->transact(BnSurfaceComposer::GET_COMPOSITION_PREFERENCE, data, &reply);\n        if (error != NO_ERROR) {\n            return error;\n        }\n        error = static_cast<status_t>(reply.readInt32());\n        if (error == NO_ERROR) {\n            *defaultDataspace = static_cast<ui::Dataspace>(reply.readInt32());\n            *defaultPixelFormat = static_cast<ui::PixelFormat>(reply.readInt32());\n            *wideColorGamutDataspace = static_cast<ui::Dataspace>(reply.readInt32());\n            *wideColorGamutPixelFormat = static_cast<ui::PixelFormat>(reply.readInt32());\n        }\n        return error;\n    }\n\n    status_t getColorManagement(bool* outGetColorManagement) const override {\n        Parcel data, reply;\n        data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());\n        remote()->transact(BnSurfaceComposer::GET_COLOR_MANAGEMENT, data, &reply);\n        bool result;\n        status_t err = reply.readBool(&result);\n        if (err == NO_ERROR) {\n            *outGetColorManagement = result;\n        }\n        return err;\n    }\n\n    status_t getDisplayedContentSamplingAttributes(const sp<IBinder>& display,\n                                                   ui::PixelFormat* outFormat,\n                                                   ui::Dataspace* outDataspace,\n                                                   uint8_t* outComponentMask) const override {\n        if (!outFormat || !outDataspace || !outComponentMask) return BAD_VALUE;\n        Parcel data, reply;\n        data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());\n        data.writeStrongBinder(display);\n\n        status_t error =\n                remote()->transact(BnSurfaceComposer::GET_DISPLAYED_CONTENT_SAMPLING_ATTRIBUTES,\n                                   data, &reply);\n        if (error != NO_ERROR) {\n            return error;\n        }\n\n        uint32_t value = 0;\n        error = reply.readUint32(&value);\n        if (error != NO_ERROR) {\n            return error;\n        }\n        *outFormat = static_cast<ui::PixelFormat>(value);\n\n        error = reply.readUint32(&value);\n        if (error != NO_ERROR) {\n            return error;\n        }\n        *outDataspace = static_cast<ui::Dataspace>(value);\n\n        error = reply.readUint32(&value);\n        if (error != NO_ERROR) {\n            return error;\n        }\n        *outComponentMask = static_cast<uint8_t>(value);\n        return error;\n    }\n\n    status_t setDisplayContentSamplingEnabled(const sp<IBinder>& display, bool enable,\n                                              uint8_t componentMask, uint64_t maxFrames) override {\n        Parcel data, reply;\n        data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());\n        data.writeStrongBinder(display);\n        data.writeBool(enable);\n        data.writeByte(static_cast<int8_t>(componentMask));\n        data.writeUint64(maxFrames);\n        status_t result =\n                remote()->transact(BnSurfaceComposer::SET_DISPLAY_CONTENT_SAMPLING_ENABLED, data,\n                                   &reply);\n        return result;\n    }\n",
        "base_contents": "    void setPowerMode(const sp<IBinder>& display, int mode) override {\n        Parcel data, reply;\n        data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());\n        data.writeStrongBinder(display);\n        data.writeInt32(mode);\n        remote()->transact(BnSurfaceComposer::SET_POWER_MODE, data, &reply);\n    }\n\n    status_t getDisplayState(const sp<IBinder>& display, ui::DisplayState* state) override {\n        Parcel data, reply;\n        data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());\n        data.writeStrongBinder(display);\n        remote()->transact(BnSurfaceComposer::GET_DISPLAY_STATE, data, &reply);\n        const status_t result = reply.readInt32();\n        if (result == NO_ERROR) {\n            memcpy(state, reply.readInplace(sizeof(ui::DisplayState)), sizeof(ui::DisplayState));\n        }\n        return result;\n    }\n\n    status_t getStaticDisplayInfo(const sp<IBinder>& display,\n                                  ui::StaticDisplayInfo* info) override {\n        Parcel data, reply;\n        data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());\n        data.writeStrongBinder(display);\n        remote()->transact(BnSurfaceComposer::GET_STATIC_DISPLAY_INFO, data, &reply);\n        const status_t result = reply.readInt32();\n        if (result != NO_ERROR) return result;\n        return reply.read(*info);\n    }\n\n    status_t getDynamicDisplayInfo(const sp<IBinder>& display,\n                                   ui::DynamicDisplayInfo* info) override {\n        Parcel data, reply;\n        data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());\n        data.writeStrongBinder(display);\n        remote()->transact(BnSurfaceComposer::GET_DYNAMIC_DISPLAY_INFO, data, &reply);\n        const status_t result = reply.readInt32();\n        if (result != NO_ERROR) return result;\n        return reply.read(*info);\n    }\n\n    status_t getDisplayStats(const sp<IBinder>& display, DisplayStatInfo* stats) override {\n        Parcel data, reply;\n        data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());\n        data.writeStrongBinder(display);\n        remote()->transact(BnSurfaceComposer::GET_DISPLAY_STATS, data, &reply);\n        status_t result = reply.readInt32();\n        if (result == NO_ERROR) {\n            memcpy(stats,\n                    reply.readInplace(sizeof(DisplayStatInfo)),\n                    sizeof(DisplayStatInfo));\n        }\n        return result;\n    }\n\n    status_t getDisplayNativePrimaries(const sp<IBinder>& display,\n                                       ui::DisplayPrimaries& primaries) override {\n        Parcel data, reply;\n        status_t result = data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());\n        if (result != NO_ERROR) {\n            ALOGE(\"getDisplayNativePrimaries failed to writeInterfaceToken: %d\", result);\n            return result;\n        }\n        result = data.writeStrongBinder(display);\n        if (result != NO_ERROR) {\n            ALOGE(\"getDisplayNativePrimaries failed to writeStrongBinder: %d\", result);\n            return result;\n        }\n        result = remote()->transact(BnSurfaceComposer::GET_DISPLAY_NATIVE_PRIMARIES, data, &reply);\n        if (result != NO_ERROR) {\n            ALOGE(\"getDisplayNativePrimaries failed to transact: %d\", result);\n            return result;\n        }\n        result = reply.readInt32();\n        if (result == NO_ERROR) {\n            memcpy(&primaries, reply.readInplace(sizeof(ui::DisplayPrimaries)),\n                    sizeof(ui::DisplayPrimaries));\n        }\n        return result;\n    }\n\n    status_t setActiveColorMode(const sp<IBinder>& display, ColorMode colorMode) override {\n        Parcel data, reply;\n        status_t result = data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());\n        if (result != NO_ERROR) {\n            ALOGE(\"setActiveColorMode failed to writeInterfaceToken: %d\", result);\n            return result;\n        }\n        result = data.writeStrongBinder(display);\n        if (result != NO_ERROR) {\n            ALOGE(\"setActiveColorMode failed to writeStrongBinder: %d\", result);\n            return result;\n        }\n        result = data.writeInt32(static_cast<int32_t>(colorMode));\n        if (result != NO_ERROR) {\n            ALOGE(\"setActiveColorMode failed to writeInt32: %d\", result);\n            return result;\n        }\n        result = remote()->transact(BnSurfaceComposer::SET_ACTIVE_COLOR_MODE, data, &reply);\n        if (result != NO_ERROR) {\n            ALOGE(\"setActiveColorMode failed to transact: %d\", result);\n            return result;\n        }\n        return static_cast<status_t>(reply.readInt32());\n    }\n\n    // TODO(b/213909104) : Add unit tests to verify surface flinger boot time APIs\n    status_t getBootDisplayModeSupport(bool* outSupport) const override {\n        Parcel data, reply;\n        status_t error = data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());\n        if (error != NO_ERROR) {\n            ALOGE(\"getBootDisplayModeSupport: failed to write interface token: %d\", error);\n            return error;\n        }\n        error = remote()->transact(BnSurfaceComposer::GET_BOOT_DISPLAY_MODE_SUPPORT, data, &reply);\n        if (error != NO_ERROR) {\n            ALOGE(\"getBootDisplayModeSupport: failed to transact: %d\", error);\n            return error;\n        }\n        bool support;\n        error = reply.readBool(&support);\n        if (error != NO_ERROR) {\n            ALOGE(\"getBootDisplayModeSupport: failed to read support: %d\", error);\n            return error;\n        }\n        *outSupport = support;\n        return NO_ERROR;\n    }\n\n    status_t setBootDisplayMode(const sp<IBinder>& display,\n                                ui::DisplayModeId displayModeId) override {\n        Parcel data, reply;\n        status_t result = data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());\n        if (result != NO_ERROR) {\n            ALOGE(\"setBootDisplayMode failed to writeInterfaceToken: %d\", result);\n            return result;\n        }\n        result = data.writeStrongBinder(display);\n        if (result != NO_ERROR) {\n            ALOGE(\"setBootDisplayMode failed to writeStrongBinder: %d\", result);\n            return result;\n        }\n        result = data.writeInt32(displayModeId);\n        if (result != NO_ERROR) {\n            ALOGE(\"setBootDisplayMode failed to writeIint32: %d\", result);\n            return result;\n        }\n        result = remote()->transact(BnSurfaceComposer::SET_BOOT_DISPLAY_MODE, data, &reply);\n        if (result != NO_ERROR) {\n            ALOGE(\"setBootDisplayMode failed to transact: %d\", result);\n        }\n        return result;\n    }\n\n    status_t clearBootDisplayMode(const sp<IBinder>& display) override {\n        Parcel data, reply;\n        status_t result = data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());\n        if (result != NO_ERROR) {\n            ALOGE(\"clearBootDisplayMode failed to writeInterfaceToken: %d\", result);\n            return result;\n        }\n        result = data.writeStrongBinder(display);\n        if (result != NO_ERROR) {\n            ALOGE(\"clearBootDisplayMode failed to writeStrongBinder: %d\", result);\n            return result;\n        }\n        result = remote()->transact(BnSurfaceComposer::CLEAR_BOOT_DISPLAY_MODE, data, &reply);\n        if (result != NO_ERROR) {\n            ALOGE(\"clearBootDisplayMode failed to transact: %d\", result);\n        }\n        return result;\n    }\n\n    void setAutoLowLatencyMode(const sp<IBinder>& display, bool on) override {\n        Parcel data, reply;\n        status_t result = data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());\n        if (result != NO_ERROR) {\n            ALOGE(\"setAutoLowLatencyMode failed to writeInterfaceToken: %d\", result);\n            return;\n        }\n\n        result = data.writeStrongBinder(display);\n        if (result != NO_ERROR) {\n            ALOGE(\"setAutoLowLatencyMode failed to writeStrongBinder: %d\", result);\n            return;\n        }\n        result = data.writeBool(on);\n        if (result != NO_ERROR) {\n            ALOGE(\"setAutoLowLatencyMode failed to writeBool: %d\", result);\n            return;\n        }\n        result = remote()->transact(BnSurfaceComposer::SET_AUTO_LOW_LATENCY_MODE, data, &reply);\n        if (result != NO_ERROR) {\n            ALOGE(\"setAutoLowLatencyMode failed to transact: %d\", result);\n            return;\n        }\n    }\n\n    void setGameContentType(const sp<IBinder>& display, bool on) override {\n        Parcel data, reply;\n        status_t result = data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());\n        if (result != NO_ERROR) {\n            ALOGE(\"setGameContentType failed to writeInterfaceToken: %d\", result);\n            return;\n        }\n        result = data.writeStrongBinder(display);\n        if (result != NO_ERROR) {\n            ALOGE(\"setGameContentType failed to writeStrongBinder: %d\", result);\n            return;\n        }\n        result = data.writeBool(on);\n        if (result != NO_ERROR) {\n            ALOGE(\"setGameContentType failed to writeBool: %d\", result);\n            return;\n        }\n        result = remote()->transact(BnSurfaceComposer::SET_GAME_CONTENT_TYPE, data, &reply);\n        if (result != NO_ERROR) {\n            ALOGE(\"setGameContentType failed to transact: %d\", result);\n        }\n    }\n\n    status_t clearAnimationFrameStats() override {\n        Parcel data, reply;\n        status_t result = data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());\n        if (result != NO_ERROR) {\n            ALOGE(\"clearAnimationFrameStats failed to writeInterfaceToken: %d\", result);\n            return result;\n        }\n        result = remote()->transact(BnSurfaceComposer::CLEAR_ANIMATION_FRAME_STATS, data, &reply);\n        if (result != NO_ERROR) {\n            ALOGE(\"clearAnimationFrameStats failed to transact: %d\", result);\n            return result;\n        }\n        return reply.readInt32();\n    }\n\n    status_t getAnimationFrameStats(FrameStats* outStats) const override {\n        Parcel data, reply;\n        data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());\n        remote()->transact(BnSurfaceComposer::GET_ANIMATION_FRAME_STATS, data, &reply);\n        reply.read(*outStats);\n        return reply.readInt32();\n    }\n\n    virtual status_t overrideHdrTypes(const sp<IBinder>& display,\n                                      const std::vector<ui::Hdr>& hdrTypes) {\n        Parcel data, reply;\n        SAFE_PARCEL(data.writeInterfaceToken, ISurfaceComposer::getInterfaceDescriptor());\n        SAFE_PARCEL(data.writeStrongBinder, display);\n\n        std::vector<int32_t> hdrTypesVector;\n        for (ui::Hdr i : hdrTypes) {\n            hdrTypesVector.push_back(static_cast<int32_t>(i));\n        }\n        SAFE_PARCEL(data.writeInt32Vector, hdrTypesVector);\n\n        status_t result = remote()->transact(BnSurfaceComposer::OVERRIDE_HDR_TYPES, data, &reply);\n        if (result != NO_ERROR) {\n            ALOGE(\"overrideHdrTypes failed to transact: %d\", result);\n            return result;\n        }\n        return result;\n    }\n\n    status_t onPullAtom(const int32_t atomId, std::string* pulledData, bool* success) {\n        Parcel data, reply;\n        SAFE_PARCEL(data.writeInterfaceToken, ISurfaceComposer::getInterfaceDescriptor());\n        SAFE_PARCEL(data.writeInt32, atomId);\n\n        status_t err = remote()->transact(BnSurfaceComposer::ON_PULL_ATOM, data, &reply);\n        if (err != NO_ERROR) {\n            ALOGE(\"onPullAtom failed to transact: %d\", err);\n            return err;\n        }\n\n        int32_t size = 0;\n        SAFE_PARCEL(reply.readInt32, &size);\n        const void* dataPtr = reply.readInplace(size);\n        if (dataPtr == nullptr) {\n            return UNEXPECTED_NULL;\n        }\n        pulledData->assign((const char*)dataPtr, size);\n        SAFE_PARCEL(reply.readBool, success);\n        return NO_ERROR;\n    }\n\n    status_t enableVSyncInjections(bool enable) override {\n        Parcel data, reply;\n        status_t result = data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());\n        if (result != NO_ERROR) {\n            ALOGE(\"enableVSyncInjections failed to writeInterfaceToken: %d\", result);\n            return result;\n        }\n        result = data.writeBool(enable);\n        if (result != NO_ERROR) {\n            ALOGE(\"enableVSyncInjections failed to writeBool: %d\", result);\n            return result;\n        }\n        result = remote()->transact(BnSurfaceComposer::ENABLE_VSYNC_INJECTIONS, data, &reply,\n                                    IBinder::FLAG_ONEWAY);\n        if (result != NO_ERROR) {\n            ALOGE(\"enableVSyncInjections failed to transact: %d\", result);\n            return result;\n        }\n        return result;\n    }\n\n    status_t injectVSync(nsecs_t when) override {\n        Parcel data, reply;\n        status_t result = data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());\n        if (result != NO_ERROR) {\n            ALOGE(\"injectVSync failed to writeInterfaceToken: %d\", result);\n            return result;\n        }\n        result = data.writeInt64(when);\n        if (result != NO_ERROR) {\n            ALOGE(\"injectVSync failed to writeInt64: %d\", result);\n            return result;\n        }\n        result = remote()->transact(BnSurfaceComposer::INJECT_VSYNC, data, &reply,\n                                    IBinder::FLAG_ONEWAY);\n        if (result != NO_ERROR) {\n            ALOGE(\"injectVSync failed to transact: %d\", result);\n            return result;\n        }\n        return result;\n    }\n\n    status_t getLayerDebugInfo(std::vector<LayerDebugInfo>* outLayers) override {\n        if (!outLayers) {\n            return UNEXPECTED_NULL;\n        }\n\n        Parcel data, reply;\n\n        status_t err = data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());\n        if (err != NO_ERROR) {\n            return err;\n        }\n\n        err = remote()->transact(BnSurfaceComposer::GET_LAYER_DEBUG_INFO, data, &reply);\n        if (err != NO_ERROR) {\n            return err;\n        }\n\n        int32_t result = 0;\n        err = reply.readInt32(&result);\n        if (err != NO_ERROR) {\n            return err;\n        }\n        if (result != NO_ERROR) {\n            return result;\n        }\n\n        outLayers->clear();\n        return reply.readParcelableVector(outLayers);\n    }\n\n    status_t getCompositionPreference(ui::Dataspace* defaultDataspace,\n                                      ui::PixelFormat* defaultPixelFormat,\n                                      ui::Dataspace* wideColorGamutDataspace,\n                                      ui::PixelFormat* wideColorGamutPixelFormat) const override {\n        Parcel data, reply;\n        status_t error = data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());\n        if (error != NO_ERROR) {\n            return error;\n        }\n        error = remote()->transact(BnSurfaceComposer::GET_COMPOSITION_PREFERENCE, data, &reply);\n        if (error != NO_ERROR) {\n            return error;\n        }\n        error = static_cast<status_t>(reply.readInt32());\n        if (error == NO_ERROR) {\n            *defaultDataspace = static_cast<ui::Dataspace>(reply.readInt32());\n            *defaultPixelFormat = static_cast<ui::PixelFormat>(reply.readInt32());\n            *wideColorGamutDataspace = static_cast<ui::Dataspace>(reply.readInt32());\n            *wideColorGamutPixelFormat = static_cast<ui::PixelFormat>(reply.readInt32());\n        }\n        return error;\n    }\n\n    status_t getColorManagement(bool* outGetColorManagement) const override {\n        Parcel data, reply;\n        data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());\n        remote()->transact(BnSurfaceComposer::GET_COLOR_MANAGEMENT, data, &reply);\n        bool result;\n        status_t err = reply.readBool(&result);\n        if (err == NO_ERROR) {\n            *outGetColorManagement = result;\n        }\n        return err;\n    }\n\n    status_t getDisplayedContentSamplingAttributes(const sp<IBinder>& display,\n                                                   ui::PixelFormat* outFormat,\n                                                   ui::Dataspace* outDataspace,\n                                                   uint8_t* outComponentMask) const override {\n        if (!outFormat || !outDataspace || !outComponentMask) return BAD_VALUE;\n        Parcel data, reply;\n        data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());\n        data.writeStrongBinder(display);\n\n        status_t error =\n                remote()->transact(BnSurfaceComposer::GET_DISPLAYED_CONTENT_SAMPLING_ATTRIBUTES,\n                                   data, &reply);\n        if (error != NO_ERROR) {\n            return error;\n        }\n\n        uint32_t value = 0;\n        error = reply.readUint32(&value);\n        if (error != NO_ERROR) {\n            return error;\n        }\n        *outFormat = static_cast<ui::PixelFormat>(value);\n\n        error = reply.readUint32(&value);\n        if (error != NO_ERROR) {\n            return error;\n        }\n        *outDataspace = static_cast<ui::Dataspace>(value);\n\n        error = reply.readUint32(&value);\n        if (error != NO_ERROR) {\n            return error;\n        }\n        *outComponentMask = static_cast<uint8_t>(value);\n        return error;\n    }\n\n    status_t setDisplayContentSamplingEnabled(const sp<IBinder>& display, bool enable,\n                                              uint8_t componentMask, uint64_t maxFrames) override {\n        Parcel data, reply;\n        data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());\n        data.writeStrongBinder(display);\n        data.writeBool(enable);\n        data.writeByte(static_cast<int8_t>(componentMask));\n        data.writeUint64(maxFrames);\n        status_t result =\n                remote()->transact(BnSurfaceComposer::SET_DISPLAY_CONTENT_SAMPLING_ENABLED, data,\n                                   &reply);\n        return result;\n    }\n",
        "res_region": "",
        "lookback": "                                       uint64_t timestamp,",
        "lookahead": "    status_t getDisplayedContentSample(const sp<IBinder>& display, uint64_t maxFrames,",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 183,
        "end_line": 978,
        "merge_gen_region": "",
        "confidence": 0.9799050092697144,
        "hesitated": false,
        "resolved": true
    },
    {
        "a_contents": "",
        "b_contents": "    status_t getProtectedContentSupport(bool* outSupported) const override {\n        Parcel data, reply;\n        data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());\n        status_t error =\n                remote()->transact(BnSurfaceComposer::GET_PROTECTED_CONTENT_SUPPORT, data, &reply);\n        if (error != NO_ERROR) {\n            return error;\n        }\n        error = reply.readBool(outSupported);\n        return error;\n    }\n",
        "base_contents": "    status_t getProtectedContentSupport(bool* outSupported) const override {\n        Parcel data, reply;\n        data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());\n        status_t error =\n                remote()->transact(BnSurfaceComposer::GET_PROTECTED_CONTENT_SUPPORT, data, &reply);\n        if (error != NO_ERROR) {\n            return error;\n        }\n        error = reply.readBool(outSupported);\n        return error;\n    }\n\n    status_t isWideColorDisplay(const sp<IBinder>& token,\n                                bool* outIsWideColorDisplay) const override {\n        Parcel data, reply;\n        status_t error = data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());\n        if (error != NO_ERROR) {\n            return error;\n        }\n        error = data.writeStrongBinder(token);\n        if (error != NO_ERROR) {\n            return error;\n        }\n\n        error = remote()->transact(BnSurfaceComposer::IS_WIDE_COLOR_DISPLAY, data, &reply);\n        if (error != NO_ERROR) {\n            return error;\n        }\n        error = reply.readBool(outIsWideColorDisplay);\n        return error;\n    }\n",
        "res_region": "",
        "lookback": "                                       const sp<IRegionSamplingListener>& listener) override {",
        "lookahead": "    status_t addRegionSamplingListener(const Rect& samplingArea, const sp<IBinder>& stopLayerHandle,",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 1018,
        "end_line": 1065,
        "merge_gen_region": "",
        "confidence": 0.9388538002967834,
        "hesitated": false,
        "resolved": true
    },
    {
        "a_contents": "        result = reply.readInt32(outDefaultMode);\n        if (result != NO_ERROR) {\n            ALOGE(\"getDesiredDisplayModeSpecs failed to read defaultMode: %d\", result);\n            return result;\n        }\n        if (*outDefaultMode < 0) {\n            ALOGE(\"%s: defaultMode must be non-negative but it was %d\", __func__, *outDefaultMode);\n            return BAD_VALUE;\n        }\n\n        result = reply.readBool(outAllowGroupSwitching);\n        if (result != NO_ERROR) {\n            ALOGE(\"getDesiredDisplayModeSpecs failed to read allowGroupSwitching: %d\", result);\n            return result;\n        }\n        result = reply.readFloat(outPrimaryRefreshRateMin);\n        if (result != NO_ERROR) {\n            ALOGE(\"getDesiredDisplayModeSpecs failed to read primaryRefreshRateMin: %d\", result);\n            return result;\n        }\n        result = reply.readFloat(outPrimaryRefreshRateMax);\n        if (result != NO_ERROR) {\n            ALOGE(\"getDesiredDisplayModeSpecs failed to read primaryRefreshRateMax: %d\", result);\n            return result;\n        }\n        result = reply.readFloat(outAppRequestRefreshRateMin);\n        if (result != NO_ERROR) {\n            ALOGE(\"getDesiredDisplayModeSpecs failed to read appRequestRefreshRateMin: %d\", result);\n            return result;\n        }\n        result = reply.readFloat(outAppRequestRefreshRateMax);\n        if (result != NO_ERROR) {\n            ALOGE(\"getDesiredDisplayModeSpecs failed to read appRequestRefreshRateMax: %d\", result);\n            return result;\n        }\n        return reply.readInt32();\n    }\n",
        "b_contents": "        result = reply.readInt32(outDefaultMode);\n        if (result != NO_ERROR) {\n            ALOGE(\"getDesiredDisplayModeSpecs failed to read defaultMode: %d\", result);\n            return result;\n        }\n        if (*outDefaultMode < 0) {\n            ALOGE(\"%s: defaultMode must be non-negative but it was %d\", __func__, *outDefaultMode);\n            return BAD_VALUE;\n        }\n\n        result = reply.readBool(outAllowGroupSwitching);\n        if (result != NO_ERROR) {\n            ALOGE(\"getDesiredDisplayModeSpecs failed to read allowGroupSwitching: %d\", result);\n            return result;\n        }\n        result = reply.readFloat(outPrimaryRefreshRateMin);\n        if (result != NO_ERROR) {\n            ALOGE(\"getDesiredDisplayModeSpecs failed to read primaryRefreshRateMin: %d\", result);\n            return result;\n        }\n        result = reply.readFloat(outPrimaryRefreshRateMax);\n        if (result != NO_ERROR) {\n            ALOGE(\"getDesiredDisplayModeSpecs failed to read primaryRefreshRateMax: %d\", result);\n            return result;\n        }\n        result = reply.readFloat(outAppRequestRefreshRateMin);\n        if (result != NO_ERROR) {\n            ALOGE(\"getDesiredDisplayModeSpecs failed to read appRequestRefreshRateMin: %d\", result);\n            return result;\n        }\n        result = reply.readFloat(outAppRequestRefreshRateMax);\n        if (result != NO_ERROR) {\n            ALOGE(\"getDesiredDisplayModeSpecs failed to read appRequestRefreshRateMax: %d\", result);\n            return result;\n        }\n        return reply.readInt32();\n    }\n",
        "base_contents": "        result = reply.readInt32(outDefaultMode);\n        if (result != NO_ERROR) {\n            ALOGE(\"getDesiredDisplayModeSpecs failed to read defaultMode: %d\", result);\n            return result;\n        }\n        if (*outDefaultMode < 0) {\n            ALOGE(\"%s: defaultMode must be non-negative but it was %d\", __func__, *outDefaultMode);\n            return BAD_VALUE;\n        }\n\n        result = reply.readBool(outAllowGroupSwitching);\n        if (result != NO_ERROR) {\n            ALOGE(\"getDesiredDisplayModeSpecs failed to read allowGroupSwitching: %d\", result);\n            return result;\n        }\n        result = reply.readFloat(outPrimaryRefreshRateMin);\n        if (result != NO_ERROR) {\n            ALOGE(\"getDesiredDisplayModeSpecs failed to read primaryRefreshRateMin: %d\", result);\n            return result;\n        }\n        result = reply.readFloat(outPrimaryRefreshRateMax);\n        if (result != NO_ERROR) {\n            ALOGE(\"getDesiredDisplayModeSpecs failed to read primaryRefreshRateMax: %d\", result);\n            return result;\n        }\n        result = reply.readFloat(outAppRequestRefreshRateMin);\n        if (result != NO_ERROR) {\n            ALOGE(\"getDesiredDisplayModeSpecs failed to read appRequestRefreshRateMin: %d\", result);\n            return result;\n        }\n        result = reply.readFloat(outAppRequestRefreshRateMax);\n        if (result != NO_ERROR) {\n            ALOGE(\"getDesiredDisplayModeSpecs failed to read appRequestRefreshRateMax: %d\", result);\n            return result;\n        }\n        return reply.readInt32();\n    }\n\n    status_t getDisplayBrightnessSupport(const sp<IBinder>& displayToken,\n                                         bool* outSupport) const override {\n        Parcel data, reply;\n        status_t error = data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());\n        if (error != NO_ERROR) {\n            ALOGE(\"getDisplayBrightnessSupport: failed to write interface token: %d\", error);\n            return error;\n        }\n        error = data.writeStrongBinder(displayToken);\n        if (error != NO_ERROR) {\n            ALOGE(\"getDisplayBrightnessSupport: failed to write display token: %d\", error);\n            return error;\n        }\n        error = remote()->transact(BnSurfaceComposer::GET_DISPLAY_BRIGHTNESS_SUPPORT, data, &reply);\n        if (error != NO_ERROR) {\n            ALOGE(\"getDisplayBrightnessSupport: failed to transact: %d\", error);\n            return error;\n        }\n        bool support;\n        error = reply.readBool(&support);\n        if (error != NO_ERROR) {\n            ALOGE(\"getDisplayBrightnessSupport: failed to read support: %d\", error);\n            return error;\n        }\n        *outSupport = support;\n        return NO_ERROR;\n    }\n\n    status_t setDisplayBrightness(const sp<IBinder>& displayToken,\n                                  const gui::DisplayBrightness& brightness) override {\n        Parcel data, reply;\n        status_t error = data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());\n        if (error != NO_ERROR) {\n            ALOGE(\"setDisplayBrightness: failed to write interface token: %d\", error);\n            return error;\n        }\n        error = data.writeStrongBinder(displayToken);\n        if (error != NO_ERROR) {\n            ALOGE(\"setDisplayBrightness: failed to write display token: %d\", error);\n            return error;\n        }\n        error = data.writeParcelable(brightness);\n        if (error != NO_ERROR) {\n            ALOGE(\"setDisplayBrightness: failed to write brightness: %d\", error);\n            return error;\n        }\n        error = remote()->transact(BnSurfaceComposer::SET_DISPLAY_BRIGHTNESS, data, &reply);\n        if (error != NO_ERROR) {\n            ALOGE(\"setDisplayBrightness: failed to transact: %d\", error);\n            return error;\n        }\n        return NO_ERROR;\n    }\n\n    status_t addHdrLayerInfoListener(const sp<IBinder>& displayToken,\n                                     const sp<gui::IHdrLayerInfoListener>& listener) override {\n        Parcel data, reply;\n        SAFE_PARCEL(data.writeInterfaceToken, ISurfaceComposer::getInterfaceDescriptor());\n        SAFE_PARCEL(data.writeStrongBinder, displayToken);\n        SAFE_PARCEL(data.writeStrongBinder, IInterface::asBinder(listener));\n        const status_t error =\n                remote()->transact(BnSurfaceComposer::ADD_HDR_LAYER_INFO_LISTENER, data, &reply);\n        if (error != OK) {\n            ALOGE(\"addHdrLayerInfoListener: Failed to transact; error = %d\", error);\n        }\n        return error;\n    }\n\n    status_t removeHdrLayerInfoListener(const sp<IBinder>& displayToken,\n                                        const sp<gui::IHdrLayerInfoListener>& listener) override {\n        Parcel data, reply;\n        SAFE_PARCEL(data.writeInterfaceToken, ISurfaceComposer::getInterfaceDescriptor());\n        SAFE_PARCEL(data.writeStrongBinder, displayToken);\n        SAFE_PARCEL(data.writeStrongBinder, IInterface::asBinder(listener));\n        const status_t error =\n                remote()->transact(BnSurfaceComposer::REMOVE_HDR_LAYER_INFO_LISTENER, data, &reply);\n        if (error != OK) {\n            ALOGE(\"removeHdrLayerInfoListener: Failed to transact; error = %d\", error);\n        }\n        return error;\n    }\n\n    status_t notifyPowerBoost(int32_t boostId) override {\n        Parcel data, reply;\n        status_t error = data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());\n        if (error != NO_ERROR) {\n            ALOGE(\"notifyPowerBoost: failed to write interface token: %d\", error);\n            return error;\n        }\n        error = data.writeInt32(boostId);\n        if (error != NO_ERROR) {\n            ALOGE(\"notifyPowerBoost: failed to write boostId: %d\", error);\n            return error;\n        }\n        error = remote()->transact(BnSurfaceComposer::NOTIFY_POWER_BOOST, data, &reply,\n                                   IBinder::FLAG_ONEWAY);\n        if (error != NO_ERROR) {\n            ALOGE(\"notifyPowerBoost: failed to transact: %d\", error);\n            return error;\n        }\n        return NO_ERROR;\n    }\n",
        "res_region": "        result = reply.readInt32(outDefaultMode);\n        if (result != NO_ERROR) {\n            ALOGE(\"getDesiredDisplayModeSpecs failed to read defaultMode: %d\", result);\n            return result;\n        }\n        if (*outDefaultMode < 0) {\n            ALOGE(\"%s: defaultMode must be non-negative but it was %d\", __func__, *outDefaultMode);\n            return BAD_VALUE;\n        }\n\n        result = reply.readBool(outAllowGroupSwitching);\n        if (result != NO_ERROR) {\n            ALOGE(\"getDesiredDisplayModeSpecs failed to read allowGroupSwitching: %d\", result);\n            return result;\n        }\n        result = reply.readFloat(outPrimaryRefreshRateMin);\n        if (result != NO_ERROR) {\n            ALOGE(\"getDesiredDisplayModeSpecs failed to read primaryRefreshRateMin: %d\", result);\n            return result;\n        }\n        result = reply.readFloat(outPrimaryRefreshRateMax);\n        if (result != NO_ERROR) {\n            ALOGE(\"getDesiredDisplayModeSpecs failed to read primaryRefreshRateMax: %d\", result);\n            return result;\n        }\n        result = reply.readFloat(outAppRequestRefreshRateMin);\n        if (result != NO_ERROR) {\n            ALOGE(\"getDesiredDisplayModeSpecs failed to read appRequestRefreshRateMin: %d\", result);\n            return result;\n        }\n        result = reply.readFloat(outAppRequestRefreshRateMax);\n        if (result != NO_ERROR) {\n            ALOGE(\"getDesiredDisplayModeSpecs failed to read appRequestRefreshRateMax: %d\", result);\n            return result;\n        }\n        return reply.readInt32();\n    }\n",
        "lookback": "        if (result != NO_ERROR) {",
        "lookahead": "    status_t setGlobalShadowSettings(const half4& ambientColor, const half4& spotColor,",
        "label": [
            "ours",
            "base_underutilized"
        ],
        "start_line": 1260,
        "end_line": 1480,
        "merge_gen_region": " ( !=_) result =.Int32outMode); ( !=_) ALOGEgetDisplayModes to default:d result return; ifoutDefault < 0 { ALOGEs default must non- but it %\",func *); BADVALUE } result replyread(AllowSwitch); ( !=_) ALOGEgetDisplayModes to allowSwitch:d result); result replyreadFloatoutRefreshMin ifresult NOERROR {(\"DesiredSpec failed to primaryRate:d result); result replyreadFloatoutRefreshMax return;",
        "confidence": 0.8827776908874512,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "",
        "b_contents": "        case GET_DISPLAY_STATE: {\n            CHECK_INTERFACE(ISurfaceComposer, data, reply);\n            ui::DisplayState state;\n            const sp<IBinder> display = data.readStrongBinder();\n            const status_t result = getDisplayState(display, &state);\n            reply->writeInt32(result);\n            if (result == NO_ERROR) {\n                memcpy(reply->writeInplace(sizeof(ui::DisplayState)), &state,\n                       sizeof(ui::DisplayState));\n            }\n            return NO_ERROR;\n        }\n        case GET_STATIC_DISPLAY_INFO: {\n            CHECK_INTERFACE(ISurfaceComposer, data, reply);\n            ui::StaticDisplayInfo info;\n            const sp<IBinder> display = data.readStrongBinder();\n            const status_t result = getStaticDisplayInfo(display, &info);\n            SAFE_PARCEL(reply->writeInt32, result);\n            if (result != NO_ERROR) return result;\n            SAFE_PARCEL(reply->write, info);\n            return NO_ERROR;\n        }\n        case GET_DYNAMIC_DISPLAY_INFO: {\n            CHECK_INTERFACE(ISurfaceComposer, data, reply);\n            ui::DynamicDisplayInfo info;\n            const sp<IBinder> display = data.readStrongBinder();\n            const status_t result = getDynamicDisplayInfo(display, &info);\n            SAFE_PARCEL(reply->writeInt32, result);\n            if (result != NO_ERROR) return result;\n            SAFE_PARCEL(reply->write, info);\n            return NO_ERROR;\n        }\n        case GET_DISPLAY_STATS: {\n            CHECK_INTERFACE(ISurfaceComposer, data, reply);\n            DisplayStatInfo stats;\n            sp<IBinder> display = data.readStrongBinder();\n            status_t result = getDisplayStats(display, &stats);\n            reply->writeInt32(result);\n            if (result == NO_ERROR) {\n                memcpy(reply->writeInplace(sizeof(DisplayStatInfo)),\n                        &stats, sizeof(DisplayStatInfo));\n            }\n            return NO_ERROR;\n        }\n        case GET_DISPLAY_NATIVE_PRIMARIES: {\n            CHECK_INTERFACE(ISurfaceComposer, data, reply);\n            ui::DisplayPrimaries primaries;\n            sp<IBinder> display = nullptr;\n\n            status_t result = data.readStrongBinder(&display);\n            if (result != NO_ERROR) {\n                ALOGE(\"getDisplayNativePrimaries failed to readStrongBinder: %d\", result);\n                return result;\n            }\n\n            result = getDisplayNativePrimaries(display, primaries);\n            reply->writeInt32(result);\n            if (result == NO_ERROR) {\n                memcpy(reply->writeInplace(sizeof(ui::DisplayPrimaries)), &primaries,\n                        sizeof(ui::DisplayPrimaries));\n            }\n\n            return NO_ERROR;\n        }\n        case SET_ACTIVE_COLOR_MODE: {\n            CHECK_INTERFACE(ISurfaceComposer, data, reply);\n            sp<IBinder> display = nullptr;\n            status_t result = data.readStrongBinder(&display);\n            if (result != NO_ERROR) {\n                ALOGE(\"getActiveColorMode failed to readStrongBinder: %d\", result);\n                return result;\n            }\n            int32_t colorModeInt = 0;\n            result = data.readInt32(&colorModeInt);\n            if (result != NO_ERROR) {\n                ALOGE(\"setActiveColorMode failed to readInt32: %d\", result);\n                return result;\n            }\n            result = setActiveColorMode(display,\n                    static_cast<ColorMode>(colorModeInt));\n            result = reply->writeInt32(result);\n            return result;\n        }\n        case SET_BOOT_DISPLAY_MODE: {\n            CHECK_INTERFACE(ISurfaceComposer, data, reply);\n            sp<IBinder> display = nullptr;\n            status_t result = data.readStrongBinder(&display);\n            if (result != NO_ERROR) {\n                ALOGE(\"setBootDisplayMode failed to readStrongBinder: %d\", result);\n                return result;\n            }\n            ui::DisplayModeId displayModeId;\n            result = data.readInt32(&displayModeId);\n            if (result != NO_ERROR) {\n                ALOGE(\"setBootDisplayMode failed to readInt32: %d\", result);\n                return result;\n            }\n            return setBootDisplayMode(display, displayModeId);\n        }\n        case CLEAR_ANIMATION_FRAME_STATS: {\n            CHECK_INTERFACE(ISurfaceComposer, data, reply);\n            status_t result = clearAnimationFrameStats();\n            reply->writeInt32(result);\n            return NO_ERROR;\n        }\n        case GET_ANIMATION_FRAME_STATS: {\n            CHECK_INTERFACE(ISurfaceComposer, data, reply);\n            FrameStats stats;\n            status_t result = getAnimationFrameStats(&stats);\n            reply->write(stats);\n            reply->writeInt32(result);\n            return NO_ERROR;\n        }\n        case ENABLE_VSYNC_INJECTIONS: {\n            CHECK_INTERFACE(ISurfaceComposer, data, reply);\n            bool enable = false;\n            status_t result = data.readBool(&enable);\n            if (result != NO_ERROR) {\n                ALOGE(\"enableVSyncInjections failed to readBool: %d\", result);\n                return result;\n            }\n            return enableVSyncInjections(enable);\n        }\n        case INJECT_VSYNC: {\n            CHECK_INTERFACE(ISurfaceComposer, data, reply);\n            int64_t when = 0;\n            status_t result = data.readInt64(&when);\n            if (result != NO_ERROR) {\n                ALOGE(\"enableVSyncInjections failed to readInt64: %d\", result);\n                return result;\n            }\n            return injectVSync(when);\n        }\n        case GET_LAYER_DEBUG_INFO: {\n            CHECK_INTERFACE(ISurfaceComposer, data, reply);\n            std::vector<LayerDebugInfo> outLayers;\n            status_t result = getLayerDebugInfo(&outLayers);\n            reply->writeInt32(result);\n            if (result == NO_ERROR)\n            {\n                result = reply->writeParcelableVector(outLayers);\n            }\n            return result;\n        }\n        case GET_COMPOSITION_PREFERENCE: {\n            CHECK_INTERFACE(ISurfaceComposer, data, reply);\n            ui::Dataspace defaultDataspace;\n            ui::PixelFormat defaultPixelFormat;\n            ui::Dataspace wideColorGamutDataspace;\n            ui::PixelFormat wideColorGamutPixelFormat;\n            status_t error =\n                    getCompositionPreference(&defaultDataspace, &defaultPixelFormat,\n                                             &wideColorGamutDataspace, &wideColorGamutPixelFormat);\n            reply->writeInt32(error);\n            if (error == NO_ERROR) {\n                reply->writeInt32(static_cast<int32_t>(defaultDataspace));\n                reply->writeInt32(static_cast<int32_t>(defaultPixelFormat));\n                reply->writeInt32(static_cast<int32_t>(wideColorGamutDataspace));\n                reply->writeInt32(static_cast<int32_t>(wideColorGamutPixelFormat));\n            }\n            return error;\n        }\n        case GET_COLOR_MANAGEMENT: {\n            CHECK_INTERFACE(ISurfaceComposer, data, reply);\n            bool result;\n            status_t error = getColorManagement(&result);\n            if (error == NO_ERROR) {\n                reply->writeBool(result);\n            }\n            return error;\n        }\n        case GET_DISPLAYED_CONTENT_SAMPLING_ATTRIBUTES: {\n            CHECK_INTERFACE(ISurfaceComposer, data, reply);\n\n            sp<IBinder> display = data.readStrongBinder();\n            ui::PixelFormat format;\n            ui::Dataspace dataspace;\n            uint8_t component = 0;\n            auto result =\n                    getDisplayedContentSamplingAttributes(display, &format, &dataspace, &component);\n            if (result == NO_ERROR) {\n                reply->writeUint32(static_cast<uint32_t>(format));\n                reply->writeUint32(static_cast<uint32_t>(dataspace));\n                reply->writeUint32(static_cast<uint32_t>(component));\n            }\n            return result;\n        }\n        case SET_DISPLAY_CONTENT_SAMPLING_ENABLED: {\n            CHECK_INTERFACE(ISurfaceComposer, data, reply);\n\n            sp<IBinder> display = nullptr;\n            bool enable = false;\n            int8_t componentMask = 0;\n            uint64_t maxFrames = 0;\n            status_t result = data.readStrongBinder(&display);\n            if (result != NO_ERROR) {\n                ALOGE(\"setDisplayContentSamplingEnabled failure in reading Display token: %d\",\n                      result);\n                return result;\n            }\n\n            result = data.readBool(&enable);\n            if (result != NO_ERROR) {\n                ALOGE(\"setDisplayContentSamplingEnabled failure in reading enable: %d\", result);\n                return result;\n            }\n\n            result = data.readByte(static_cast<int8_t*>(&componentMask));\n            if (result != NO_ERROR) {\n                ALOGE(\"setDisplayContentSamplingEnabled failure in reading component mask: %d\",\n                      result);\n                return result;\n            }\n\n            result = data.readUint64(&maxFrames);\n            if (result != NO_ERROR) {\n                ALOGE(\"setDisplayContentSamplingEnabled failure in reading max frames: %d\", result);\n                return result;\n            }\n\n            return setDisplayContentSamplingEnabled(display, enable,\n                                                    static_cast<uint8_t>(componentMask), maxFrames);\n        }",
        "base_contents": "        case GET_DISPLAY_STATE: {\n            CHECK_INTERFACE(ISurfaceComposer, data, reply);\n            ui::DisplayState state;\n            const sp<IBinder> display = data.readStrongBinder();\n            const status_t result = getDisplayState(display, &state);\n            reply->writeInt32(result);\n            if (result == NO_ERROR) {\n                memcpy(reply->writeInplace(sizeof(ui::DisplayState)), &state,\n                       sizeof(ui::DisplayState));\n            }\n            return NO_ERROR;\n        }\n        case GET_STATIC_DISPLAY_INFO: {\n            CHECK_INTERFACE(ISurfaceComposer, data, reply);\n            ui::StaticDisplayInfo info;\n            const sp<IBinder> display = data.readStrongBinder();\n            const status_t result = getStaticDisplayInfo(display, &info);\n            SAFE_PARCEL(reply->writeInt32, result);\n            if (result != NO_ERROR) return result;\n            SAFE_PARCEL(reply->write, info);\n            return NO_ERROR;\n        }\n        case GET_DYNAMIC_DISPLAY_INFO: {\n            CHECK_INTERFACE(ISurfaceComposer, data, reply);\n            ui::DynamicDisplayInfo info;\n            const sp<IBinder> display = data.readStrongBinder();\n            const status_t result = getDynamicDisplayInfo(display, &info);\n            SAFE_PARCEL(reply->writeInt32, result);\n            if (result != NO_ERROR) return result;\n            SAFE_PARCEL(reply->write, info);\n            return NO_ERROR;\n        }\n        case GET_DISPLAY_STATS: {\n            CHECK_INTERFACE(ISurfaceComposer, data, reply);\n            DisplayStatInfo stats;\n            sp<IBinder> display = data.readStrongBinder();\n            status_t result = getDisplayStats(display, &stats);\n            reply->writeInt32(result);\n            if (result == NO_ERROR) {\n                memcpy(reply->writeInplace(sizeof(DisplayStatInfo)),\n                        &stats, sizeof(DisplayStatInfo));\n            }\n            return NO_ERROR;\n        }\n        case GET_DISPLAY_NATIVE_PRIMARIES: {\n            CHECK_INTERFACE(ISurfaceComposer, data, reply);\n            ui::DisplayPrimaries primaries;\n            sp<IBinder> display = nullptr;\n\n            status_t result = data.readStrongBinder(&display);\n            if (result != NO_ERROR) {\n                ALOGE(\"getDisplayNativePrimaries failed to readStrongBinder: %d\", result);\n                return result;\n            }\n\n            result = getDisplayNativePrimaries(display, primaries);\n            reply->writeInt32(result);\n            if (result == NO_ERROR) {\n                memcpy(reply->writeInplace(sizeof(ui::DisplayPrimaries)), &primaries,\n                        sizeof(ui::DisplayPrimaries));\n            }\n\n            return NO_ERROR;\n        }\n        case SET_ACTIVE_COLOR_MODE: {\n            CHECK_INTERFACE(ISurfaceComposer, data, reply);\n            sp<IBinder> display = nullptr;\n            status_t result = data.readStrongBinder(&display);\n            if (result != NO_ERROR) {\n                ALOGE(\"getActiveColorMode failed to readStrongBinder: %d\", result);\n                return result;\n            }\n            int32_t colorModeInt = 0;\n            result = data.readInt32(&colorModeInt);\n            if (result != NO_ERROR) {\n                ALOGE(\"setActiveColorMode failed to readInt32: %d\", result);\n                return result;\n            }\n            result = setActiveColorMode(display,\n                    static_cast<ColorMode>(colorModeInt));\n            result = reply->writeInt32(result);\n            return result;\n        }\n        case GET_BOOT_DISPLAY_MODE_SUPPORT: {\n            CHECK_INTERFACE(ISurfaceComposer, data, reply);\n            bool support = false;\n            status_t result = getBootDisplayModeSupport(&support);\n            if (result == NO_ERROR) {\n                reply->writeBool(support);\n            }\n            return result;\n        }\n        case SET_BOOT_DISPLAY_MODE: {\n            CHECK_INTERFACE(ISurfaceComposer, data, reply);\n            sp<IBinder> display = nullptr;\n            status_t result = data.readStrongBinder(&display);\n            if (result != NO_ERROR) {\n                ALOGE(\"setBootDisplayMode failed to readStrongBinder: %d\", result);\n                return result;\n            }\n            ui::DisplayModeId displayModeId;\n            result = data.readInt32(&displayModeId);\n            if (result != NO_ERROR) {\n                ALOGE(\"setBootDisplayMode failed to readInt32: %d\", result);\n                return result;\n            }\n            return setBootDisplayMode(display, displayModeId);\n        }\n        case CLEAR_BOOT_DISPLAY_MODE: {\n            CHECK_INTERFACE(ISurfaceComposer, data, reply);\n            sp<IBinder> display = nullptr;\n            status_t result = data.readStrongBinder(&display);\n            if (result != NO_ERROR) {\n                ALOGE(\"clearBootDisplayMode failed to readStrongBinder: %d\", result);\n                return result;\n            }\n            return clearBootDisplayMode(display);\n        }\n        case SET_AUTO_LOW_LATENCY_MODE: {\n            CHECK_INTERFACE(ISurfaceComposer, data, reply);\n            sp<IBinder> display = nullptr;\n            status_t result = data.readStrongBinder(&display);\n            if (result != NO_ERROR) {\n                ALOGE(\"setAutoLowLatencyMode failed to readStrongBinder: %d\", result);\n                return result;\n            }\n            bool setAllm = false;\n            result = data.readBool(&setAllm);\n            if (result != NO_ERROR) {\n                ALOGE(\"setAutoLowLatencyMode failed to readBool: %d\", result);\n                return result;\n            }\n            setAutoLowLatencyMode(display, setAllm);\n            return result;\n        }\n        case SET_GAME_CONTENT_TYPE: {\n            CHECK_INTERFACE(ISurfaceComposer, data, reply);\n            sp<IBinder> display = nullptr;\n            status_t result = data.readStrongBinder(&display);\n            if (result != NO_ERROR) {\n                ALOGE(\"setGameContentType failed to readStrongBinder: %d\", result);\n                return result;\n            }\n            bool setGameContentTypeOn = false;\n            result = data.readBool(&setGameContentTypeOn);\n            if (result != NO_ERROR) {\n                ALOGE(\"setGameContentType failed to readBool: %d\", result);\n                return result;\n            }\n            setGameContentType(display, setGameContentTypeOn);\n            return result;\n        }\n        case CLEAR_ANIMATION_FRAME_STATS: {\n            CHECK_INTERFACE(ISurfaceComposer, data, reply);\n            status_t result = clearAnimationFrameStats();\n            reply->writeInt32(result);\n            return NO_ERROR;\n        }\n        case GET_ANIMATION_FRAME_STATS: {\n            CHECK_INTERFACE(ISurfaceComposer, data, reply);\n            FrameStats stats;\n            status_t result = getAnimationFrameStats(&stats);\n            reply->write(stats);\n            reply->writeInt32(result);\n            return NO_ERROR;\n        }\n        case SET_POWER_MODE: {\n            CHECK_INTERFACE(ISurfaceComposer, data, reply);\n            sp<IBinder> display = data.readStrongBinder();\n            int32_t mode = data.readInt32();\n            setPowerMode(display, mode);\n            return NO_ERROR;\n        }\n        case ENABLE_VSYNC_INJECTIONS: {\n            CHECK_INTERFACE(ISurfaceComposer, data, reply);\n            bool enable = false;\n            status_t result = data.readBool(&enable);\n            if (result != NO_ERROR) {\n                ALOGE(\"enableVSyncInjections failed to readBool: %d\", result);\n                return result;\n            }\n            return enableVSyncInjections(enable);\n        }\n        case INJECT_VSYNC: {\n            CHECK_INTERFACE(ISurfaceComposer, data, reply);\n            int64_t when = 0;\n            status_t result = data.readInt64(&when);\n            if (result != NO_ERROR) {\n                ALOGE(\"enableVSyncInjections failed to readInt64: %d\", result);\n                return result;\n            }\n            return injectVSync(when);\n        }\n        case GET_LAYER_DEBUG_INFO: {\n            CHECK_INTERFACE(ISurfaceComposer, data, reply);\n            std::vector<LayerDebugInfo> outLayers;\n            status_t result = getLayerDebugInfo(&outLayers);\n            reply->writeInt32(result);\n            if (result == NO_ERROR)\n            {\n                result = reply->writeParcelableVector(outLayers);\n            }\n            return result;\n        }\n        case GET_COMPOSITION_PREFERENCE: {\n            CHECK_INTERFACE(ISurfaceComposer, data, reply);\n            ui::Dataspace defaultDataspace;\n            ui::PixelFormat defaultPixelFormat;\n            ui::Dataspace wideColorGamutDataspace;\n            ui::PixelFormat wideColorGamutPixelFormat;\n            status_t error =\n                    getCompositionPreference(&defaultDataspace, &defaultPixelFormat,\n                                             &wideColorGamutDataspace, &wideColorGamutPixelFormat);\n            reply->writeInt32(error);\n            if (error == NO_ERROR) {\n                reply->writeInt32(static_cast<int32_t>(defaultDataspace));\n                reply->writeInt32(static_cast<int32_t>(defaultPixelFormat));\n                reply->writeInt32(static_cast<int32_t>(wideColorGamutDataspace));\n                reply->writeInt32(static_cast<int32_t>(wideColorGamutPixelFormat));\n            }\n            return error;\n        }\n        case GET_COLOR_MANAGEMENT: {\n            CHECK_INTERFACE(ISurfaceComposer, data, reply);\n            bool result;\n            status_t error = getColorManagement(&result);\n            if (error == NO_ERROR) {\n                reply->writeBool(result);\n            }\n            return error;\n        }\n        case GET_DISPLAYED_CONTENT_SAMPLING_ATTRIBUTES: {\n            CHECK_INTERFACE(ISurfaceComposer, data, reply);\n\n            sp<IBinder> display = data.readStrongBinder();\n            ui::PixelFormat format;\n            ui::Dataspace dataspace;\n            uint8_t component = 0;\n            auto result =\n                    getDisplayedContentSamplingAttributes(display, &format, &dataspace, &component);\n            if (result == NO_ERROR) {\n                reply->writeUint32(static_cast<uint32_t>(format));\n                reply->writeUint32(static_cast<uint32_t>(dataspace));\n                reply->writeUint32(static_cast<uint32_t>(component));\n            }\n            return result;\n        }\n        case SET_DISPLAY_CONTENT_SAMPLING_ENABLED: {\n            CHECK_INTERFACE(ISurfaceComposer, data, reply);\n\n            sp<IBinder> display = nullptr;\n            bool enable = false;\n            int8_t componentMask = 0;\n            uint64_t maxFrames = 0;\n            status_t result = data.readStrongBinder(&display);\n            if (result != NO_ERROR) {\n                ALOGE(\"setDisplayContentSamplingEnabled failure in reading Display token: %d\",\n                      result);\n                return result;\n            }\n\n            result = data.readBool(&enable);\n            if (result != NO_ERROR) {\n                ALOGE(\"setDisplayContentSamplingEnabled failure in reading enable: %d\", result);\n                return result;\n            }\n\n            result = data.readByte(static_cast<int8_t*>(&componentMask));\n            if (result != NO_ERROR) {\n                ALOGE(\"setDisplayContentSamplingEnabled failure in reading component mask: %d\",\n                      result);\n                return result;\n            }\n\n            result = data.readUint64(&maxFrames);\n            if (result != NO_ERROR) {\n                ALOGE(\"setDisplayContentSamplingEnabled failure in reading max frames: %d\", result);\n                return result;\n            }\n\n            return setDisplayContentSamplingEnabled(display, enable,\n                                                    static_cast<uint8_t>(componentMask), maxFrames);\n        }",
        "res_region": "",
        "lookback": "            CHECK_INTERFACE(ISurfaceComposer, data, reply);",
        "lookahead": "        case GET_DISPLAYED_CONTENT_SAMPLE: {",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 1777,
        "end_line": 2286,
        "merge_gen_region": null,
        "confidence": 0.8615711331367493,
        "hesitated": true
    },
    {
        "a_contents": "",
        "b_contents": "        case GET_PROTECTED_CONTENT_SUPPORT: {\n            CHECK_INTERFACE(ISurfaceComposer, data, reply);\n            bool result;\n            status_t error = getProtectedContentSupport(&result);\n            if (error == NO_ERROR) {\n                reply->writeBool(result);\n            }\n            return error;\n        }",
        "base_contents": "        case GET_PROTECTED_CONTENT_SUPPORT: {\n            CHECK_INTERFACE(ISurfaceComposer, data, reply);\n            bool result;\n            status_t error = getProtectedContentSupport(&result);\n            if (error == NO_ERROR) {\n                reply->writeBool(result);\n            }\n            return error;\n        }\n        case IS_WIDE_COLOR_DISPLAY: {\n            CHECK_INTERFACE(ISurfaceComposer, data, reply);\n            sp<IBinder> display = nullptr;\n            status_t error = data.readStrongBinder(&display);\n            if (error != NO_ERROR) {\n                return error;\n            }\n            bool result;\n            error = isWideColorDisplay(display, &result);\n            if (error == NO_ERROR) {\n                reply->writeBool(result);\n            }\n            return error;\n        }",
        "res_region": "",
        "lookback": "            CHECK_INTERFACE(ISurfaceComposer, data, reply);",
        "lookahead": "        case ADD_REGION_SAMPLING_LISTENER: {",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 2317,
        "end_line": 2352,
        "merge_gen_region": "",
        "confidence": 0.9564924240112305,
        "hesitated": false,
        "resolved": true
    }
]