[
    {
        "a_contents": "",
        "b_contents": "        case SET_ACTIVE_COLOR_MODE:\n        case SET_BOOT_DISPLAY_MODE:",
        "base_contents": "        case SET_ACTIVE_COLOR_MODE:\n        case GET_BOOT_DISPLAY_MODE_SUPPORT:\n        case SET_BOOT_DISPLAY_MODE:\n        case CLEAR_BOOT_DISPLAY_MODE:",
        "res_region": "",
        "lookback": "        case GET_GAME_CONTENT_TYPE_SUPPORT:",
        "lookahead": "        case GET_AUTO_LOW_LATENCY_MODE_SUPPORT:",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 5468,
        "end_line": 5477,
        "merge_gen_region": "",
        "confidence": 0.8824089169502258,
        "hesitated": false,
        "resolved": true
    },
    {
        "a_contents": "",
        "b_contents": "        case GET_DISPLAYED_CONTENT_SAMPLING_ATTRIBUTES:\n        case SET_DISPLAY_CONTENT_SAMPLING_ENABLED:",
        "base_contents": "        case SET_GAME_CONTENT_TYPE:\n        case SET_POWER_MODE:\n        case GET_DISPLAYED_CONTENT_SAMPLING_ATTRIBUTES:\n        case SET_DISPLAY_CONTENT_SAMPLING_ENABLED:",
        "res_region": "",
        "lookback": "        case ADD_TUNNEL_MODE_ENABLED_LISTENER:",
        "lookahead": "        case GET_DISPLAYED_CONTENT_SAMPLE:",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 5480,
        "end_line": 5489,
        "merge_gen_region": "",
        "confidence": 0.8942857980728149,
        "hesitated": false,
        "resolved": true
    },
    {
        "a_contents": "",
        "b_contents": "        case GET_COLOR_MANAGEMENT:\n        case GET_COMPOSITION_PREFERENCE:\n        case GET_PROTECTED_CONTENT_SUPPORT:",
        "base_contents": "        case GET_COLOR_MANAGEMENT:\n        case GET_COMPOSITION_PREFERENCE:\n        case GET_PROTECTED_CONTENT_SUPPORT:\n        case IS_WIDE_COLOR_DISPLAY:",
        "res_region": "",
        "lookback": "        // special permissions.",
        "lookahead": "        // setFrameRate() is deliberately available for apps to call without any",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 5520,
        "end_line": 5530,
        "merge_gen_region": null,
        "confidence": 0.8650938272476196,
        "hesitated": true
    },
    {
        "a_contents": "        case SET_POWER_MODE:\n        case GET_SUPPORTED_FRAME_TIMESTAMPS:\n        case GET_DISPLAY_STATE:\n        case GET_DISPLAY_STATS:\n        case GET_STATIC_DISPLAY_INFO:\n        case GET_DYNAMIC_DISPLAY_INFO:\n        case GET_DISPLAY_NATIVE_PRIMARIES:\n        case SET_ACTIVE_COLOR_MODE:\n        case SET_BOOT_DISPLAY_MODE:\n        case CLEAR_BOOT_DISPLAY_MODE:\n        case GET_BOOT_DISPLAY_MODE_SUPPORT:\n        case SET_AUTO_LOW_LATENCY_MODE:\n        case SET_GAME_CONTENT_TYPE:",
        "b_contents": "        case SET_POWER_MODE:\n        case CLEAR_BOOT_DISPLAY_MODE:\n        case GET_BOOT_DISPLAY_MODE_SUPPORT:\n        case SET_AUTO_LOW_LATENCY_MODE:\n        case SET_GAME_CONTENT_TYPE:",
        "base_contents": "",
        "res_region": "        case SET_POWER_MODE:\n        case GET_SUPPORTED_FRAME_TIMESTAMPS:\n        case GET_DISPLAY_STATE:\n        case GET_DISPLAY_STATS:\n        case GET_STATIC_DISPLAY_INFO:\n        case GET_DYNAMIC_DISPLAY_INFO:\n        case GET_DISPLAY_NATIVE_PRIMARIES:\n        case SET_ACTIVE_COLOR_MODE:\n        case SET_BOOT_DISPLAY_MODE:\n        case CLEAR_BOOT_DISPLAY_MODE:\n        case GET_BOOT_DISPLAY_MODE_SUPPORT:\n        case SET_AUTO_LOW_LATENCY_MODE:\n        case SET_GAME_CONTENT_TYPE:",
        "lookback": "        case GET_SUPPORTED_FRAME_TIMESTAMPS:",
        "lookahead": "        case CAPTURE_LAYERS:",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 5584,
        "end_line": 5605,
        "merge_gen_region": "___casecasecasecasecasecasecase",
        "confidence": 0.9037482738494873,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "        case CLEAR_ANIMATION_FRAME_STATS:\n        case GET_ANIMATION_FRAME_STATS:\n        case OVERRIDE_HDR_TYPES:\n        case ON_PULL_ATOM:\n        case ENABLE_VSYNC_INJECTIONS:\n        case INJECT_VSYNC:\n        case GET_LAYER_DEBUG_INFO:\n        case GET_COLOR_MANAGEMENT:\n        case GET_COMPOSITION_PREFERENCE:\n        case GET_DISPLAYED_CONTENT_SAMPLING_ATTRIBUTES:\n        case SET_DISPLAY_CONTENT_SAMPLING_ENABLED:\n        case GET_PROTECTED_CONTENT_SUPPORT:\n        case IS_WIDE_COLOR_DISPLAY:\n        case GET_DISPLAY_BRIGHTNESS_SUPPORT:\n        case SET_DISPLAY_BRIGHTNESS:\n        case ADD_HDR_LAYER_INFO_LISTENER:\n        case REMOVE_HDR_LAYER_INFO_LISTENER:\n        case NOTIFY_POWER_BOOST:",
        "b_contents": "        case IS_WIDE_COLOR_DISPLAY:\n        case GET_DISPLAY_BRIGHTNESS_SUPPORT:\n        case SET_DISPLAY_BRIGHTNESS:\n        case ADD_HDR_LAYER_INFO_LISTENER:\n        case REMOVE_HDR_LAYER_INFO_LISTENER:\n        case NOTIFY_POWER_BOOST:",
        "base_contents": "",
        "res_region": "        case CLEAR_ANIMATION_FRAME_STATS:\n        case GET_ANIMATION_FRAME_STATS:\n        case OVERRIDE_HDR_TYPES:\n        case ON_PULL_ATOM:\n        case ENABLE_VSYNC_INJECTIONS:\n        case INJECT_VSYNC:\n        case GET_LAYER_DEBUG_INFO:\n        case GET_COLOR_MANAGEMENT:\n        case GET_COMPOSITION_PREFERENCE:\n        case GET_DISPLAYED_CONTENT_SAMPLING_ATTRIBUTES:\n        case SET_DISPLAY_CONTENT_SAMPLING_ENABLED:\n        case GET_PROTECTED_CONTENT_SUPPORT:\n        case IS_WIDE_COLOR_DISPLAY:\n        case GET_DISPLAY_BRIGHTNESS_SUPPORT:\n        case SET_DISPLAY_BRIGHTNESS:\n        case ADD_HDR_LAYER_INFO_LISTENER:\n        case REMOVE_HDR_LAYER_INFO_LISTENER:\n        case NOTIFY_POWER_BOOST:",
        "lookback": "        case GET_ANIMATION_FRAME_STATS:",
        "lookahead": "            LOG_FATAL(\"Deprecated opcode: %d, migrated to AIDL\", code);",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 5609,
        "end_line": 5636,
        "merge_gen_region": " CLEARANIM_ATIONFRAMESTATS case_ATION_: case__: case__: case__: case__: case__: case__: case__: case__: case__: case__: case__: case__: case__: case__: case__: case__: case__: case__: case__: case__: case__: case__: case_",
        "confidence": 0.9203310608863831,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "binder::Status SurfaceComposerAIDL::setPowerMode(const sp<IBinder>& display, int mode) {\n    status_t status = checkAccessPermission();\n    if (status != OK) {\n        return binder::Status::fromStatusT(status);\n    }\n    mFlinger->setPowerMode(display, mode);\n    return binder::Status::ok();\n}\n\nbinder::Status SurfaceComposerAIDL::getSupportedFrameTimestamps(\n        std::vector<FrameEvent>* outSupported) {\n    status_t status;\n    if (!outSupported) {\n        status = UNEXPECTED_NULL;\n    } else {\n        outSupported->clear();\n        status = mFlinger->getSupportedFrameTimestamps(outSupported);\n    }\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::getDisplayStats(const sp<IBinder>& display,\n                                                    gui::DisplayStatInfo* outStatInfo) {\n    DisplayStatInfo statInfo;\n    status_t status = mFlinger->getDisplayStats(display, &statInfo);\n    if (status == NO_ERROR) {\n        outStatInfo->vsyncTime = static_cast<long>(statInfo.vsyncTime);\n        outStatInfo->vsyncPeriod = static_cast<long>(statInfo.vsyncPeriod);\n    }\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::getDisplayState(const sp<IBinder>& display,\n                                                    gui::DisplayState* outState) {\n    ui::DisplayState state;\n    status_t status = mFlinger->getDisplayState(display, &state);\n    if (status == NO_ERROR) {\n        outState->layerStack = state.layerStack.id;\n        outState->orientation = static_cast<gui::Rotation>(state.orientation);\n        outState->layerStackSpaceRect.width = state.layerStackSpaceRect.width;\n        outState->layerStackSpaceRect.height = state.layerStackSpaceRect.height;\n    }\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::getStaticDisplayInfo(const sp<IBinder>& display,\n                                                         gui::StaticDisplayInfo* outInfo) {\n    using Tag = gui::DeviceProductInfo::ManufactureOrModelDate::Tag;\n    ui::StaticDisplayInfo info;\n    status_t status = mFlinger->getStaticDisplayInfo(display, &info);\n    if (status == NO_ERROR) {\n        // convert ui::StaticDisplayInfo to gui::StaticDisplayInfo\n        outInfo->connectionType = static_cast<gui::DisplayConnectionType>(info.connectionType);\n        outInfo->density = info.density;\n        outInfo->secure = info.secure;\n        outInfo->installOrientation = static_cast<gui::Rotation>(info.installOrientation);\n\n        gui::DeviceProductInfo dinfo;\n        std::optional<DeviceProductInfo> dpi = info.deviceProductInfo;\n        dinfo.name = std::move(dpi->name);\n        dinfo.manufacturerPnpId =\n                std::vector<uint8_t>(dpi->manufacturerPnpId.begin(), dpi->manufacturerPnpId.end());\n        dinfo.productId = dpi->productId;\n        if (const auto* model =\n                    std::get_if<DeviceProductInfo::ModelYear>(&dpi->manufactureOrModelDate)) {\n            gui::DeviceProductInfo::ModelYear modelYear;\n            modelYear.year = model->year;\n            dinfo.manufactureOrModelDate.set<Tag::modelYear>(modelYear);\n        } else if (const auto* manufacture = std::get_if<DeviceProductInfo::ManufactureYear>(\n                           &dpi->manufactureOrModelDate)) {\n            gui::DeviceProductInfo::ManufactureYear date;\n            date.modelYear.year = manufacture->year;\n            dinfo.manufactureOrModelDate.set<Tag::manufactureYear>(date);\n        } else if (const auto* manufacture = std::get_if<DeviceProductInfo::ManufactureWeekAndYear>(\n                           &dpi->manufactureOrModelDate)) {\n            gui::DeviceProductInfo::ManufactureWeekAndYear date;\n            date.manufactureYear.modelYear.year = manufacture->year;\n            date.week = manufacture->week;\n            dinfo.manufactureOrModelDate.set<Tag::manufactureWeekAndYear>(date);\n        }\n\n        outInfo->deviceProductInfo = dinfo;\n    }\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::getDynamicDisplayInfo(const sp<IBinder>& display,\n                                                          gui::DynamicDisplayInfo* outInfo) {\n    ui::DynamicDisplayInfo info;\n    status_t status = mFlinger->getDynamicDisplayInfo(display, &info);\n    if (status == NO_ERROR) {\n        // convert ui::DynamicDisplayInfo to gui::DynamicDisplayInfo\n        outInfo->supportedDisplayModes.clear();\n        outInfo->supportedDisplayModes.reserve(info.supportedDisplayModes.size());\n        for (const auto& mode : info.supportedDisplayModes) {\n            gui::DisplayMode outMode;\n            outMode.id = mode.id;\n            outMode.resolution.width = mode.resolution.width;\n            outMode.resolution.height = mode.resolution.height;\n            outMode.xDpi = mode.xDpi;\n            outMode.yDpi = mode.yDpi;\n            outMode.refreshRate = mode.refreshRate;\n            outMode.appVsyncOffset = mode.appVsyncOffset;\n            outMode.sfVsyncOffset = mode.sfVsyncOffset;\n            outMode.presentationDeadline = mode.presentationDeadline;\n            outMode.group = mode.group;\n            outInfo->supportedDisplayModes.push_back(outMode);\n        }\n\n        outInfo->activeDisplayModeId = info.activeDisplayModeId;\n\n        outInfo->supportedColorModes.clear();\n        outInfo->supportedColorModes.reserve(info.supportedColorModes.size());\n        for (const auto& cmode : info.supportedColorModes) {\n            outInfo->supportedColorModes.push_back(static_cast<int32_t>(cmode));\n        }\n\n        outInfo->activeColorMode = static_cast<int32_t>(info.activeColorMode);\n\n        gui::HdrCapabilities& hdrCapabilities = outInfo->hdrCapabilities;\n        hdrCapabilities.supportedHdrTypes.clear();\n        hdrCapabilities.supportedHdrTypes.reserve(\n                info.hdrCapabilities.getSupportedHdrTypes().size());\n        for (const auto& hdr : info.hdrCapabilities.getSupportedHdrTypes()) {\n            hdrCapabilities.supportedHdrTypes.push_back(static_cast<int32_t>(hdr));\n        }\n        hdrCapabilities.maxLuminance = info.hdrCapabilities.getDesiredMaxLuminance();\n        hdrCapabilities.maxAverageLuminance = info.hdrCapabilities.getDesiredMaxAverageLuminance();\n        hdrCapabilities.minLuminance = info.hdrCapabilities.getDesiredMinLuminance();\n\n        outInfo->autoLowLatencyModeSupported = info.autoLowLatencyModeSupported;\n        outInfo->gameContentTypeSupported = info.gameContentTypeSupported;\n        outInfo->preferredBootDisplayMode = info.preferredBootDisplayMode;\n    }\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::getDisplayNativePrimaries(const sp<IBinder>& display,\n                                                              gui::DisplayPrimaries* outPrimaries) {\n    ui::DisplayPrimaries primaries;\n    status_t status = mFlinger->getDisplayNativePrimaries(display, primaries);\n    if (status == NO_ERROR) {\n        outPrimaries->red.X = primaries.red.X;\n        outPrimaries->red.Y = primaries.red.Y;\n        outPrimaries->red.Z = primaries.red.Z;\n\n        outPrimaries->green.X = primaries.green.X;\n        outPrimaries->green.Y = primaries.green.Y;\n        outPrimaries->green.Z = primaries.green.Z;\n\n        outPrimaries->blue.X = primaries.blue.X;\n        outPrimaries->blue.Y = primaries.blue.Y;\n        outPrimaries->blue.Z = primaries.blue.Z;\n\n        outPrimaries->white.X = primaries.white.X;\n        outPrimaries->white.Y = primaries.white.Y;\n        outPrimaries->white.Z = primaries.white.Z;\n    }\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::setActiveColorMode(const sp<IBinder>& display, int colorMode) {\n    status_t status = checkAccessPermission();\n    if (status == OK) {\n        status = mFlinger->setActiveColorMode(display, static_cast<ui::ColorMode>(colorMode));\n    }\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::setBootDisplayMode(const sp<IBinder>& display,\n                                                       int displayModeId) {\n    status_t status = checkAccessPermission();\n    if (status == OK) {\n        status = mFlinger->setBootDisplayMode(display,\n                                              static_cast<ui::DisplayModeId>(displayModeId));\n    }\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::clearBootDisplayMode(const sp<IBinder>& display) {\n    status_t status = checkAccessPermission();\n    if (status == OK) {\n        status = mFlinger->clearBootDisplayMode(display);\n    }\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::getBootDisplayModeSupport(bool* outMode) {\n    status_t status = checkAccessPermission();\n    if (status == OK) {\n        status = mFlinger->getBootDisplayModeSupport(outMode);\n    }\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::setAutoLowLatencyMode(const sp<IBinder>& display, bool on) {\n    status_t status = checkAccessPermission();\n    if (status != OK) {\n        return binder::Status::fromStatusT(status);\n    }\n    mFlinger->setAutoLowLatencyMode(display, on);\n    return binder::Status::ok();\n}\n\nbinder::Status SurfaceComposerAIDL::setGameContentType(const sp<IBinder>& display, bool on) {\n    status_t status = checkAccessPermission();\n    if (status != OK) {\n        return binder::Status::fromStatusT(status);\n    }\n    mFlinger->setGameContentType(display, on);\n    return binder::Status::ok();\n}\n",
        "b_contents": "binder::Status SurfaceComposerAIDL::setPowerMode(const sp<IBinder>& display, int mode) {\n    status_t status = checkAccessPermission();\n    if (status != OK) return binder::Status::fromStatusT(status);\n\n    mFlinger->setPowerMode(display, mode);\n    return binder::Status::ok();\n}\n\nbinder::Status SurfaceComposerAIDL::clearBootDisplayMode(const sp<IBinder>& display) {\n    status_t status = checkAccessPermission();\n    if (status != OK) return binder::Status::fromStatusT(status);\n\n    status = mFlinger->clearBootDisplayMode(display);\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::getBootDisplayModeSupport(bool* outMode) {\n    status_t status = checkAccessPermission();\n    if (status != OK) return binder::Status::fromStatusT(status);\n\n    status = mFlinger->getBootDisplayModeSupport(outMode);\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::setAutoLowLatencyMode(const sp<IBinder>& display, bool on) {\n    status_t status = checkAccessPermission();\n    if (status != OK) return binder::Status::fromStatusT(status);\n\n    mFlinger->setAutoLowLatencyMode(display, on);\n    return binder::Status::ok();\n}\n\nbinder::Status SurfaceComposerAIDL::setGameContentType(const sp<IBinder>& display, bool on) {\n    status_t status = checkAccessPermission();\n    if (status != OK) return binder::Status::fromStatusT(status);\n\n    mFlinger->setGameContentType(display, on);\n    return binder::Status::ok();\n}\n",
        "base_contents": "",
        "res_region": "binder::Status SurfaceComposerAIDL::setPowerMode(const sp<IBinder>& display, int mode) {\n    status_t status = checkAccessPermission();\n    if (status != OK) {\n        return binder::Status::fromStatusT(status);\n    }\n    mFlinger->setPowerMode(display, mode);\n    return binder::Status::ok();\n}\n\nbinder::Status SurfaceComposerAIDL::getSupportedFrameTimestamps(\n        std::vector<FrameEvent>* outSupported) {\n    status_t status;\n    if (!outSupported) {\n        status = UNEXPECTED_NULL;\n    } else {\n        outSupported->clear();\n        status = mFlinger->getSupportedFrameTimestamps(outSupported);\n    }\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::getDisplayStats(const sp<IBinder>& display,\n                                                    gui::DisplayStatInfo* outStatInfo) {\n    DisplayStatInfo statInfo;\n    status_t status = mFlinger->getDisplayStats(display, &statInfo);\n    if (status == NO_ERROR) {\n        outStatInfo->vsyncTime = static_cast<long>(statInfo.vsyncTime);\n        outStatInfo->vsyncPeriod = static_cast<long>(statInfo.vsyncPeriod);\n    }\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::getDisplayState(const sp<IBinder>& display,\n                                                    gui::DisplayState* outState) {\n    ui::DisplayState state;\n    status_t status = mFlinger->getDisplayState(display, &state);\n    if (status == NO_ERROR) {\n        outState->layerStack = state.layerStack.id;\n        outState->orientation = static_cast<gui::Rotation>(state.orientation);\n        outState->layerStackSpaceRect.width = state.layerStackSpaceRect.width;\n        outState->layerStackSpaceRect.height = state.layerStackSpaceRect.height;\n    }\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::getStaticDisplayInfo(const sp<IBinder>& display,\n                                                         gui::StaticDisplayInfo* outInfo) {\n    using Tag = gui::DeviceProductInfo::ManufactureOrModelDate::Tag;\n    ui::StaticDisplayInfo info;\n    status_t status = mFlinger->getStaticDisplayInfo(display, &info);\n    if (status == NO_ERROR) {\n        // convert ui::StaticDisplayInfo to gui::StaticDisplayInfo\n        outInfo->connectionType = static_cast<gui::DisplayConnectionType>(info.connectionType);\n        outInfo->density = info.density;\n        outInfo->secure = info.secure;\n        outInfo->installOrientation = static_cast<gui::Rotation>(info.installOrientation);\n\n        gui::DeviceProductInfo dinfo;\n        std::optional<DeviceProductInfo> dpi = info.deviceProductInfo;\n        dinfo.name = std::move(dpi->name);\n        dinfo.manufacturerPnpId =\n                std::vector<uint8_t>(dpi->manufacturerPnpId.begin(), dpi->manufacturerPnpId.end());\n        dinfo.productId = dpi->productId;\n        if (const auto* model =\n                    std::get_if<DeviceProductInfo::ModelYear>(&dpi->manufactureOrModelDate)) {\n            gui::DeviceProductInfo::ModelYear modelYear;\n            modelYear.year = model->year;\n            dinfo.manufactureOrModelDate.set<Tag::modelYear>(modelYear);\n        } else if (const auto* manufacture = std::get_if<DeviceProductInfo::ManufactureYear>(\n                           &dpi->manufactureOrModelDate)) {\n            gui::DeviceProductInfo::ManufactureYear date;\n            date.modelYear.year = manufacture->year;\n            dinfo.manufactureOrModelDate.set<Tag::manufactureYear>(date);\n        } else if (const auto* manufacture = std::get_if<DeviceProductInfo::ManufactureWeekAndYear>(\n                           &dpi->manufactureOrModelDate)) {\n            gui::DeviceProductInfo::ManufactureWeekAndYear date;\n            date.manufactureYear.modelYear.year = manufacture->year;\n            date.week = manufacture->week;\n            dinfo.manufactureOrModelDate.set<Tag::manufactureWeekAndYear>(date);\n        }\n\n        outInfo->deviceProductInfo = dinfo;\n    }\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::getDynamicDisplayInfo(const sp<IBinder>& display,\n                                                          gui::DynamicDisplayInfo* outInfo) {\n    ui::DynamicDisplayInfo info;\n    status_t status = mFlinger->getDynamicDisplayInfo(display, &info);\n    if (status == NO_ERROR) {\n        // convert ui::DynamicDisplayInfo to gui::DynamicDisplayInfo\n        outInfo->supportedDisplayModes.clear();\n        outInfo->supportedDisplayModes.reserve(info.supportedDisplayModes.size());\n        for (const auto& mode : info.supportedDisplayModes) {\n            gui::DisplayMode outMode;\n            outMode.id = mode.id;\n            outMode.resolution.width = mode.resolution.width;\n            outMode.resolution.height = mode.resolution.height;\n            outMode.xDpi = mode.xDpi;\n            outMode.yDpi = mode.yDpi;\n            outMode.refreshRate = mode.refreshRate;\n            outMode.appVsyncOffset = mode.appVsyncOffset;\n            outMode.sfVsyncOffset = mode.sfVsyncOffset;\n            outMode.presentationDeadline = mode.presentationDeadline;\n            outMode.group = mode.group;\n            outInfo->supportedDisplayModes.push_back(outMode);\n        }\n\n        outInfo->activeDisplayModeId = info.activeDisplayModeId;\n\n        outInfo->supportedColorModes.clear();\n        outInfo->supportedColorModes.reserve(info.supportedColorModes.size());\n        for (const auto& cmode : info.supportedColorModes) {\n            outInfo->supportedColorModes.push_back(static_cast<int32_t>(cmode));\n        }\n\n        outInfo->activeColorMode = static_cast<int32_t>(info.activeColorMode);\n\n        gui::HdrCapabilities& hdrCapabilities = outInfo->hdrCapabilities;\n        hdrCapabilities.supportedHdrTypes.clear();\n        hdrCapabilities.supportedHdrTypes.reserve(\n                info.hdrCapabilities.getSupportedHdrTypes().size());\n        for (const auto& hdr : info.hdrCapabilities.getSupportedHdrTypes()) {\n            hdrCapabilities.supportedHdrTypes.push_back(static_cast<int32_t>(hdr));\n        }\n        hdrCapabilities.maxLuminance = info.hdrCapabilities.getDesiredMaxLuminance();\n        hdrCapabilities.maxAverageLuminance = info.hdrCapabilities.getDesiredMaxAverageLuminance();\n        hdrCapabilities.minLuminance = info.hdrCapabilities.getDesiredMinLuminance();\n\n        outInfo->autoLowLatencyModeSupported = info.autoLowLatencyModeSupported;\n        outInfo->gameContentTypeSupported = info.gameContentTypeSupported;\n        outInfo->preferredBootDisplayMode = info.preferredBootDisplayMode;\n    }\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::getDisplayNativePrimaries(const sp<IBinder>& display,\n                                                              gui::DisplayPrimaries* outPrimaries) {\n    ui::DisplayPrimaries primaries;\n    status_t status = mFlinger->getDisplayNativePrimaries(display, primaries);\n    if (status == NO_ERROR) {\n        outPrimaries->red.X = primaries.red.X;\n        outPrimaries->red.Y = primaries.red.Y;\n        outPrimaries->red.Z = primaries.red.Z;\n\n        outPrimaries->green.X = primaries.green.X;\n        outPrimaries->green.Y = primaries.green.Y;\n        outPrimaries->green.Z = primaries.green.Z;\n\n        outPrimaries->blue.X = primaries.blue.X;\n        outPrimaries->blue.Y = primaries.blue.Y;\n        outPrimaries->blue.Z = primaries.blue.Z;\n\n        outPrimaries->white.X = primaries.white.X;\n        outPrimaries->white.Y = primaries.white.Y;\n        outPrimaries->white.Z = primaries.white.Z;\n    }\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::setActiveColorMode(const sp<IBinder>& display, int colorMode) {\n    status_t status = checkAccessPermission();\n    if (status == OK) {\n        status = mFlinger->setActiveColorMode(display, static_cast<ui::ColorMode>(colorMode));\n    }\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::setBootDisplayMode(const sp<IBinder>& display,\n                                                       int displayModeId) {\n    status_t status = checkAccessPermission();\n    if (status == OK) {\n        status = mFlinger->setBootDisplayMode(display,\n                                              static_cast<ui::DisplayModeId>(displayModeId));\n    }\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::clearBootDisplayMode(const sp<IBinder>& display) {\n    status_t status = checkAccessPermission();\n    if (status == OK) {\n        status = mFlinger->clearBootDisplayMode(display);\n    }\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::getBootDisplayModeSupport(bool* outMode) {\n    status_t status = checkAccessPermission();\n    if (status == OK) {\n        status = mFlinger->getBootDisplayModeSupport(outMode);\n    }\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::setAutoLowLatencyMode(const sp<IBinder>& display, bool on) {\n    status_t status = checkAccessPermission();\n    if (status != OK) {\n        return binder::Status::fromStatusT(status);\n    }\n    mFlinger->setAutoLowLatencyMode(display, on);\n    return binder::Status::ok();\n}\n\nbinder::Status SurfaceComposerAIDL::setGameContentType(const sp<IBinder>& display, bool on) {\n    status_t status = checkAccessPermission();\n    if (status != OK) {\n        return binder::Status::fromStatusT(status);\n    }\n    mFlinger->setGameContentType(display, on);\n    return binder::Status::ok();\n}\n",
        "lookback": "    status_t status = checkAccessPermission();",
        "lookahead": "binder::Status SurfaceComposerAIDL::captureDisplay(",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 7395,
        "end_line": 7651,
        "merge_gen_region": ":: SurfaceA::Power(Power( spIB>&, mode {_ statust =Access(); ( !=) return::::StatusfromTstatus }FlingersetModedisplay mode return::::ok }:: SurfaceA::SupportedFrames stdvectorFrame>*Supported { statust; (!Supported { status UN_; else out->(); status m->SupportedFramesout); return::::StatusfromTstatus }:: SurfaceA::DisplayStatsconst<inder display guiDisplayInfo outInfo {Stat stat;_t =FlingergetStatsdisplay &Info ifstatus ==_) outStat->Time staticcastlongstatInfovsync);Stat->Period staticcastlongstatInfovsync); return::::StatusStatusStatusStatusStatusStatusTstatus }:: SurfaceAIDLgetStateconst<inder display guiDisplay*State) uiDisplay state statust =__ statust =FlingergetState(, &); ( ==_ERROR {Statelayer =.Stackid out-> =__<::>(.);State->Stack =.Stack.;Stateorientation staticcastguiRotationstateorientation out->layerSpace. =.StackRectwidth statelayerSpace.;State->StackRectwidth out->layerSpace.;State->StackRectheight statelayerSpace.",
        "confidence": 0.9261083602905273,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "binder::Status SurfaceComposerAIDL::clearAnimationFrameStats() {\n    status_t status = checkAccessPermission();\n    if (status == OK) {\n        status = mFlinger->clearAnimationFrameStats();\n    }\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::getAnimationFrameStats(gui::FrameStats* outStats) {\n    status_t status = checkAccessPermission();\n    if (status != OK) {\n        return binder::Status::fromStatusT(status);\n    }\n\n    FrameStats stats;\n    status = mFlinger->getAnimationFrameStats(&stats);\n    if (status == NO_ERROR) {\n        outStats->refreshPeriodNano = stats.refreshPeriodNano;\n        outStats->desiredPresentTimesNano.reserve(stats.desiredPresentTimesNano.size());\n        for (const auto& t : stats.desiredPresentTimesNano) {\n            outStats->desiredPresentTimesNano.push_back(t);\n        }\n        outStats->actualPresentTimesNano.reserve(stats.actualPresentTimesNano.size());\n        for (const auto& t : stats.actualPresentTimesNano) {\n            outStats->actualPresentTimesNano.push_back(t);\n        }\n        outStats->frameReadyTimesNano.reserve(stats.frameReadyTimesNano.size());\n        for (const auto& t : stats.frameReadyTimesNano) {\n            outStats->frameReadyTimesNano.push_back(t);\n        }\n    }\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::overrideHdrTypes(const sp<IBinder>& display,\n                                                     const std::vector<int32_t>& hdrTypes) {\n    // overrideHdrTypes is used by CTS tests, which acquire the necessary\n    // permission dynamically. Don't use the permission cache for this check.\n    status_t status = checkAccessPermission(false);\n    if (status != OK) {\n        return binder::Status::fromStatusT(status);\n    }\n\n    std::vector<ui::Hdr> hdrTypesVector;\n    for (int32_t i : hdrTypes) {\n        hdrTypesVector.push_back(static_cast<ui::Hdr>(i));\n    }\n    status = mFlinger->overrideHdrTypes(display, hdrTypesVector);\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::onPullAtom(int32_t atomId, gui::PullAtomData* outPullData) {\n    status_t status;\n    const int uid = IPCThreadState::self()->getCallingUid();\n    if (uid != AID_SYSTEM) {\n        status = PERMISSION_DENIED;\n    } else {\n        status = mFlinger->onPullAtom(atomId, &outPullData->data, &outPullData->success);\n    }\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::enableVSyncInjections(bool enable) {\n    if (!mFlinger->hasMockHwc()) {\n        return binder::Status::fromStatusT(PERMISSION_DENIED);\n    }\n\n    status_t status = checkAccessPermission();\n    if (status == OK) {\n        status = mFlinger->enableVSyncInjections(enable);\n    }\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::injectVSync(int64_t when) {\n    if (!mFlinger->hasMockHwc()) {\n        return binder::Status::fromStatusT(PERMISSION_DENIED);\n    }\n\n    status_t status = checkAccessPermission();\n    if (status == OK) {\n        status = mFlinger->injectVSync(when);\n    }\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::getLayerDebugInfo(std::vector<gui::LayerDebugInfo>* outLayers) {\n    if (!outLayers) {\n        return binder::Status::fromStatusT(UNEXPECTED_NULL);\n    }\n\n    IPCThreadState* ipc = IPCThreadState::self();\n    const int pid = ipc->getCallingPid();\n    const int uid = ipc->getCallingUid();\n    if ((uid != AID_SHELL) && !PermissionCache::checkPermission(sDump, pid, uid)) {\n        ALOGE(\"Layer debug info permission denied for pid=%d, uid=%d\", pid, uid);\n        return binder::Status::fromStatusT(PERMISSION_DENIED);\n    }\n    status_t status = mFlinger->getLayerDebugInfo(outLayers);\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::getColorManagement(bool* outGetColorManagement) {\n    status_t status = mFlinger->getColorManagement(outGetColorManagement);\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::getCompositionPreference(gui::CompositionPreference* outPref) {\n    ui::Dataspace dataspace;\n    ui::PixelFormat pixelFormat;\n    ui::Dataspace wideColorGamutDataspace;\n    ui::PixelFormat wideColorGamutPixelFormat;\n    status_t status =\n            mFlinger->getCompositionPreference(&dataspace, &pixelFormat, &wideColorGamutDataspace,\n                                               &wideColorGamutPixelFormat);\n    if (status == NO_ERROR) {\n        outPref->defaultDataspace = static_cast<int32_t>(dataspace);\n        outPref->defaultPixelFormat = static_cast<int32_t>(pixelFormat);\n        outPref->wideColorGamutDataspace = static_cast<int32_t>(wideColorGamutDataspace);\n        outPref->wideColorGamutPixelFormat = static_cast<int32_t>(wideColorGamutPixelFormat);\n    }\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::getDisplayedContentSamplingAttributes(\n        const sp<IBinder>& display, gui::ContentSamplingAttributes* outAttrs) {\n    status_t status = checkAccessPermission();\n    if (status != OK) {\n        return binder::Status::fromStatusT(status);\n    }\n\n    ui::PixelFormat format;\n    ui::Dataspace dataspace;\n    uint8_t componentMask;\n    status = mFlinger->getDisplayedContentSamplingAttributes(display, &format, &dataspace,\n                                                             &componentMask);\n    if (status == NO_ERROR) {\n        outAttrs->format = static_cast<int32_t>(format);\n        outAttrs->dataspace = static_cast<int32_t>(dataspace);\n        outAttrs->componentMask = static_cast<int8_t>(componentMask);\n    }\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::setDisplayContentSamplingEnabled(const sp<IBinder>& display,\n                                                                     bool enable,\n                                                                     int8_t componentMask,\n                                                                     int64_t maxFrames) {\n    status_t status = checkAccessPermission();\n    if (status == OK) {\n        status = mFlinger->setDisplayContentSamplingEnabled(display, enable,\n                                                            static_cast<uint8_t>(componentMask),\n                                                            static_cast<uint64_t>(maxFrames));\n    }\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::getProtectedContentSupport(bool* outSupported) {\n    status_t status = mFlinger->getProtectedContentSupport(outSupported);\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::isWideColorDisplay(const sp<IBinder>& token,\n                                                       bool* outIsWideColorDisplay) {\n    status_t status = mFlinger->isWideColorDisplay(token, outIsWideColorDisplay);\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::getDisplayBrightnessSupport(const sp<IBinder>& displayToken,\n                                                                bool* outSupport) {\n    status_t status = mFlinger->getDisplayBrightnessSupport(displayToken, outSupport);\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::setDisplayBrightness(const sp<IBinder>& displayToken,\n                                                         const gui::DisplayBrightness& brightness) {\n    status_t status = checkControlDisplayBrightnessPermission();\n    if (status == OK) {\n        status = mFlinger->setDisplayBrightness(displayToken, brightness);\n    }\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::addHdrLayerInfoListener(\n        const sp<IBinder>& displayToken, const sp<gui::IHdrLayerInfoListener>& listener) {\n    status_t status = checkControlDisplayBrightnessPermission();\n    if (status == OK) {\n        status = mFlinger->addHdrLayerInfoListener(displayToken, listener);\n    }\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::removeHdrLayerInfoListener(\n        const sp<IBinder>& displayToken, const sp<gui::IHdrLayerInfoListener>& listener) {\n    status_t status = checkControlDisplayBrightnessPermission();\n    if (status == OK) {\n        status = mFlinger->removeHdrLayerInfoListener(displayToken, listener);\n    }\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::notifyPowerBoost(int boostId) {\n    status_t status = checkAccessPermission();\n    if (status == OK) {\n        status = mFlinger->notifyPowerBoost(boostId);\n    }\n    return binder::Status::fromStatusT(status);\n}\n",
        "b_contents": "binder::Status SurfaceComposerAIDL::isWideColorDisplay(const sp<IBinder>& token,\n                                                       bool* outIsWideColorDisplay) {\n    status_t status = mFlinger->isWideColorDisplay(token, outIsWideColorDisplay);\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::getDisplayBrightnessSupport(const sp<IBinder>& displayToken,\n                                                                bool* outSupport) {\n    status_t status = mFlinger->getDisplayBrightnessSupport(displayToken, outSupport);\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::setDisplayBrightness(const sp<IBinder>& displayToken,\n                                                         const gui::DisplayBrightness& brightness) {\n    status_t status = checkControlDisplayBrightnessPermission();\n    if (status != OK) return binder::Status::fromStatusT(status);\n\n    status = mFlinger->setDisplayBrightness(displayToken, brightness);\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::addHdrLayerInfoListener(\n        const sp<IBinder>& displayToken, const sp<gui::IHdrLayerInfoListener>& listener) {\n    status_t status = checkControlDisplayBrightnessPermission();\n    if (status != OK) return binder::Status::fromStatusT(status);\n\n    status = mFlinger->addHdrLayerInfoListener(displayToken, listener);\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::removeHdrLayerInfoListener(\n        const sp<IBinder>& displayToken, const sp<gui::IHdrLayerInfoListener>& listener) {\n    status_t status = checkControlDisplayBrightnessPermission();\n    if (status != OK) return binder::Status::fromStatusT(status);\n\n    status = mFlinger->removeHdrLayerInfoListener(displayToken, listener);\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::notifyPowerBoost(int boostId) {\n    status_t status = checkAccessPermission();\n    if (status != OK) return binder::Status::fromStatusT(status);\n\n    status = mFlinger->notifyPowerBoost(boostId);\n    return binder::Status::fromStatusT(status);\n}\n",
        "base_contents": "",
        "res_region": "binder::Status SurfaceComposerAIDL::clearAnimationFrameStats() {\n    status_t status = checkAccessPermission();\n    if (status == OK) {\n        status = mFlinger->clearAnimationFrameStats();\n    }\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::getAnimationFrameStats(gui::FrameStats* outStats) {\n    status_t status = checkAccessPermission();\n    if (status != OK) {\n        return binder::Status::fromStatusT(status);\n    }\n\n    FrameStats stats;\n    status = mFlinger->getAnimationFrameStats(&stats);\n    if (status == NO_ERROR) {\n        outStats->refreshPeriodNano = stats.refreshPeriodNano;\n        outStats->desiredPresentTimesNano.reserve(stats.desiredPresentTimesNano.size());\n        for (const auto& t : stats.desiredPresentTimesNano) {\n            outStats->desiredPresentTimesNano.push_back(t);\n        }\n        outStats->actualPresentTimesNano.reserve(stats.actualPresentTimesNano.size());\n        for (const auto& t : stats.actualPresentTimesNano) {\n            outStats->actualPresentTimesNano.push_back(t);\n        }\n        outStats->frameReadyTimesNano.reserve(stats.frameReadyTimesNano.size());\n        for (const auto& t : stats.frameReadyTimesNano) {\n            outStats->frameReadyTimesNano.push_back(t);\n        }\n    }\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::overrideHdrTypes(const sp<IBinder>& display,\n                                                     const std::vector<int32_t>& hdrTypes) {\n    // overrideHdrTypes is used by CTS tests, which acquire the necessary\n    // permission dynamically. Don't use the permission cache for this check.\n    status_t status = checkAccessPermission(false);\n    if (status != OK) {\n        return binder::Status::fromStatusT(status);\n    }\n\n    std::vector<ui::Hdr> hdrTypesVector;\n    for (int32_t i : hdrTypes) {\n        hdrTypesVector.push_back(static_cast<ui::Hdr>(i));\n    }\n    status = mFlinger->overrideHdrTypes(display, hdrTypesVector);\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::onPullAtom(int32_t atomId, gui::PullAtomData* outPullData) {\n    status_t status;\n    const int uid = IPCThreadState::self()->getCallingUid();\n    if (uid != AID_SYSTEM) {\n        status = PERMISSION_DENIED;\n    } else {\n        status = mFlinger->onPullAtom(atomId, &outPullData->data, &outPullData->success);\n    }\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::enableVSyncInjections(bool enable) {\n    if (!mFlinger->hasMockHwc()) {\n        return binder::Status::fromStatusT(PERMISSION_DENIED);\n    }\n\n    status_t status = checkAccessPermission();\n    if (status == OK) {\n        status = mFlinger->enableVSyncInjections(enable);\n    }\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::injectVSync(int64_t when) {\n    if (!mFlinger->hasMockHwc()) {\n        return binder::Status::fromStatusT(PERMISSION_DENIED);\n    }\n\n    status_t status = checkAccessPermission();\n    if (status == OK) {\n        status = mFlinger->injectVSync(when);\n    }\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::getLayerDebugInfo(std::vector<gui::LayerDebugInfo>* outLayers) {\n    if (!outLayers) {\n        return binder::Status::fromStatusT(UNEXPECTED_NULL);\n    }\n\n    IPCThreadState* ipc = IPCThreadState::self();\n    const int pid = ipc->getCallingPid();\n    const int uid = ipc->getCallingUid();\n    if ((uid != AID_SHELL) && !PermissionCache::checkPermission(sDump, pid, uid)) {\n        ALOGE(\"Layer debug info permission denied for pid=%d, uid=%d\", pid, uid);\n        return binder::Status::fromStatusT(PERMISSION_DENIED);\n    }\n    status_t status = mFlinger->getLayerDebugInfo(outLayers);\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::getColorManagement(bool* outGetColorManagement) {\n    status_t status = mFlinger->getColorManagement(outGetColorManagement);\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::getCompositionPreference(gui::CompositionPreference* outPref) {\n    ui::Dataspace dataspace;\n    ui::PixelFormat pixelFormat;\n    ui::Dataspace wideColorGamutDataspace;\n    ui::PixelFormat wideColorGamutPixelFormat;\n    status_t status =\n            mFlinger->getCompositionPreference(&dataspace, &pixelFormat, &wideColorGamutDataspace,\n                                               &wideColorGamutPixelFormat);\n    if (status == NO_ERROR) {\n        outPref->defaultDataspace = static_cast<int32_t>(dataspace);\n        outPref->defaultPixelFormat = static_cast<int32_t>(pixelFormat);\n        outPref->wideColorGamutDataspace = static_cast<int32_t>(wideColorGamutDataspace);\n        outPref->wideColorGamutPixelFormat = static_cast<int32_t>(wideColorGamutPixelFormat);\n    }\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::getDisplayedContentSamplingAttributes(\n        const sp<IBinder>& display, gui::ContentSamplingAttributes* outAttrs) {\n    status_t status = checkAccessPermission();\n    if (status != OK) {\n        return binder::Status::fromStatusT(status);\n    }\n\n    ui::PixelFormat format;\n    ui::Dataspace dataspace;\n    uint8_t componentMask;\n    status = mFlinger->getDisplayedContentSamplingAttributes(display, &format, &dataspace,\n                                                             &componentMask);\n    if (status == NO_ERROR) {\n        outAttrs->format = static_cast<int32_t>(format);\n        outAttrs->dataspace = static_cast<int32_t>(dataspace);\n        outAttrs->componentMask = static_cast<int8_t>(componentMask);\n    }\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::setDisplayContentSamplingEnabled(const sp<IBinder>& display,\n                                                                     bool enable,\n                                                                     int8_t componentMask,\n                                                                     int64_t maxFrames) {\n    status_t status = checkAccessPermission();\n    if (status == OK) {\n        status = mFlinger->setDisplayContentSamplingEnabled(display, enable,\n                                                            static_cast<uint8_t>(componentMask),\n                                                            static_cast<uint64_t>(maxFrames));\n    }\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::getProtectedContentSupport(bool* outSupported) {\n    status_t status = mFlinger->getProtectedContentSupport(outSupported);\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::isWideColorDisplay(const sp<IBinder>& token,\n                                                       bool* outIsWideColorDisplay) {\n    status_t status = mFlinger->isWideColorDisplay(token, outIsWideColorDisplay);\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::getDisplayBrightnessSupport(const sp<IBinder>& displayToken,\n                                                                bool* outSupport) {\n    status_t status = mFlinger->getDisplayBrightnessSupport(displayToken, outSupport);\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::setDisplayBrightness(const sp<IBinder>& displayToken,\n                                                         const gui::DisplayBrightness& brightness) {\n    status_t status = checkControlDisplayBrightnessPermission();\n    if (status == OK) {\n        status = mFlinger->setDisplayBrightness(displayToken, brightness);\n    }\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::addHdrLayerInfoListener(\n        const sp<IBinder>& displayToken, const sp<gui::IHdrLayerInfoListener>& listener) {\n    status_t status = checkControlDisplayBrightnessPermission();\n    if (status == OK) {\n        status = mFlinger->addHdrLayerInfoListener(displayToken, listener);\n    }\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::removeHdrLayerInfoListener(\n        const sp<IBinder>& displayToken, const sp<gui::IHdrLayerInfoListener>& listener) {\n    status_t status = checkControlDisplayBrightnessPermission();\n    if (status == OK) {\n        status = mFlinger->removeHdrLayerInfoListener(displayToken, listener);\n    }\n    return binder::Status::fromStatusT(status);\n}\n\nbinder::Status SurfaceComposerAIDL::notifyPowerBoost(int boostId) {\n    status_t status = checkAccessPermission();\n    if (status == OK) {\n        status = mFlinger->notifyPowerBoost(boostId);\n    }\n    return binder::Status::fromStatusT(status);\n}\n",
        "lookback": "    status_t status = checkAccessPermission();",
        "lookahead": "status_t SurfaceComposerAIDL::checkAccessPermission(bool usePermissionCache) {",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 7678,
        "end_line": 7937,
        "merge_gen_region": "_:: SurfaceA::AnimationFrame() statust =Access(); ( ==) status m->AnimationFrame(); return::::fromTstatus }:: SurfaceAIDLgetFrame(::Frame* out) statust =AccessPermission ifstatus OK { status mFlingerclearFrame(); return::::fromTstatus }:: SurfaceAIDLgetFrame(::Frame* out) statust =AccessPermission ifstatus OK) return::::::StatusfromTstatus } Frame stats status m->AnimationStatsstats); ( ==_ERROR {StatsrefreshNan =.Periodo;Stats->PresentNan.(statsdesiredTimeso.()); ( auto t statsdesiredTimeso) out->PresentTimeso._backt }StatsactualTimesNan.(.PresentNan.()); ( auto t statsactualTimeso) out->PresentNan._backt }StatsframeTimesoreservestatsframeTimesosize forconst& : statsactualTimeso) out->PresentNan._backt }StatsframeTimesoreservestatsframeTimesosize for for statsframeTimesopushbackt } return binderStatusfromTstatus); binderStatus SurfaceA::Hdr( spIB>&, stdvectorint_t hdr) //Hdr is byTS, which the //",
        "confidence": 0.8964269161224365,
        "hesitated": false,
        "resolved": false
    }
]