[
    {
        "a_contents": "/*\n * Copyright (C) 2022 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef ART_LIBARTTOOLS_TOOLS_CMDLINE_BUILDER_H_\n#define ART_LIBARTTOOLS_TOOLS_CMDLINE_BUILDER_H_\n\n#include <algorithm>\n#include <iterator>\n#include <string>\n#include <string_view>\n#include <vector>\n\n#include \"android-base/stringprintf.h\"\n\nnamespace art {\nnamespace tools {\n\nnamespace internal {\n\nconstexpr bool ContainsOneFormatSpecifier(std::string_view format, char specifier) {\n  int count = 0;\n  size_t pos = 0;\n  while ((pos = format.find('%', pos)) != std::string_view::npos) {\n    if (pos == format.length() - 1) {\n      // Invalid trailing '%'.\n      return false;\n    }\n    if (format[pos + 1] == specifier) {\n      count++;\n    } else if (format[pos + 1] != '%') {\n      // \"%%\" is okay. Otherwise, it's a wrong specifier.\n      return false;\n    }\n    pos += 2;\n  }\n  return count == 1;\n}\n\n}  // namespace internal\n\n// A util class that builds cmdline arguments.\nclass CmdlineBuilder {\n public:\n  // Returns all arguments.\n  const std::vector<std::string>& Get() const { return elements_; }\n\n  // Adds an argument as-is.\n  CmdlineBuilder& Add(std::string_view arg) {\n    elements_.push_back(std::string(arg));\n    return *this;\n  }\n\n  // Same as above but adds a runtime argument.\n  CmdlineBuilder& AddRuntime(std::string_view arg) { return Add(\"--runtime-arg\").Add(arg); }\n\n  // Adds a string value formatted by the format string.\n  //\n  // Usage: Add(\"--flag=%s\", \"value\")\n  CmdlineBuilder& Add(const char* arg_format, const std::string& value)\n      __attribute__((enable_if(internal::ContainsOneFormatSpecifier(arg_format, 's'),\n                               \"'arg' must be a string literal that contains '%s'\"))) {\n    return Add(android::base::StringPrintf(arg_format, value.c_str()));\n  }\n\n  // Same as above but adds a runtime argument.\n  CmdlineBuilder& AddRuntime(const char* arg_format, const std::string& value)\n      __attribute__((enable_if(internal::ContainsOneFormatSpecifier(arg_format, 's'),\n                               \"'arg' must be a string literal that contains '%s'\"))) {\n    return AddRuntime(android::base::StringPrintf(arg_format, value.c_str()));\n  }\n\n  // Adds an integer value formatted by the format string.\n  //\n  // Usage: Add(\"--flag=%d\", 123)\n  CmdlineBuilder& Add(const char* arg_format, int value)\n      __attribute__((enable_if(internal::ContainsOneFormatSpecifier(arg_format, 'd'),\n                               \"'arg' must be a string literal that contains '%d'\"))) {\n    return Add(android::base::StringPrintf(arg_format, value));\n  }\n\n  // Same as above but adds a runtime argument.\n  CmdlineBuilder& AddRuntime(const char* arg_format, int value)\n      __attribute__((enable_if(internal::ContainsOneFormatSpecifier(arg_format, 'd'),\n                               \"'arg' must be a string literal that contains '%d'\"))) {\n    return AddRuntime(android::base::StringPrintf(arg_format, value));\n  }\n\n  // Adds a string value formatted by the format string if the value is non-empty. Does nothing\n  // otherwise.\n  //\n  // Usage: AddIfNonEmpty(\"--flag=%s\", \"value\")\n  CmdlineBuilder& AddIfNonEmpty(const char* arg_format, const std::string& value)\n      __attribute__((enable_if(internal::ContainsOneFormatSpecifier(arg_format, 's'),\n                               \"'arg' must be a string literal that contains '%s'\"))) {\n    if (!value.empty()) {\n      Add(android::base::StringPrintf(arg_format, value.c_str()));\n    }\n    return *this;\n  }\n\n  // Same as above but adds a runtime argument.\n  CmdlineBuilder& AddRuntimeIfNonEmpty(const char* arg_format, const std::string& value)\n      __attribute__((enable_if(internal::ContainsOneFormatSpecifier(arg_format, 's'),\n                               \"'arg' must be a string literal that contains '%s'\"))) {\n    if (!value.empty()) {\n      AddRuntime(android::base::StringPrintf(arg_format, value.c_str()));\n    }\n    return *this;\n  }\n\n  // Adds an argument as-is if the boolean value is true. Does nothing otherwise.\n  CmdlineBuilder& AddIf(bool value, std::string_view arg) {\n    if (value) {\n      Add(arg);\n    }\n    return *this;\n  }\n\n  // Same as above but adds a runtime argument.\n  CmdlineBuilder& AddRuntimeIf(bool value, std::string_view arg) {\n    if (value) {\n      AddRuntime(arg);\n    }\n    return *this;\n  }\n\n  // Concatenates this builder with another. Returns the concatenated result and nullifies the input\n  // builder.\n  CmdlineBuilder& Concat(CmdlineBuilder&& other) {\n    elements_.reserve(elements_.size() + other.elements_.size());\n    std::move(other.elements_.begin(), other.elements_.end(), std::back_inserter(elements_));\n    other.elements_.clear();\n    return *this;\n  }\n\n private:\n  std::vector<std::string> elements_;\n};\n\n}  // namespace tools\n}  // namespace art\n\n#endif  // ART_LIBARTTOOLS_TOOLS_CMDLINE_BUILDER_H_",
        "b_contents": "/*\n * Copyright (C) 2022 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef ART_LIBARTTOOLS_TOOLS_CMDLINE_BUILDER_H_\n#define ART_LIBARTTOOLS_TOOLS_CMDLINE_BUILDER_H_\n\n#include <string>\n#include <string_view>\n#include <vector>\n\n#include \"android-base/stringprintf.h\"\n\nnamespace art {\nnamespace tools {\n\nnamespace internal {\n\nconstexpr bool ContainsOneFormatSpecifier(std::string_view format, char specifier) {\n  int count = 0;\n  size_t pos = 0;\n  while ((pos = format.find('%', pos)) != std::string_view::npos) {\n    if (pos == format.length() - 1) {\n      // Invalid trailing '%'.\n      return false;\n    }\n    if (format[pos + 1] == specifier) {\n      count++;\n    } else if (format[pos + 1] != '%') {\n      // \"%%\" is okay. Otherwise, it's a wrong specifier.\n      return false;\n    }\n    pos += 2;\n  }\n  return count == 1;\n}\n\n}  // namespace internal\n\n// A util class that builds cmdline arguments.\nclass CmdlineBuilder {\n public:\n  // Returns all arguments.\n  const std::vector<std::string>& Get() const { return elements_; }\n\n  // Adds an argument as-is.\n  CmdlineBuilder& Add(std::string_view arg) {\n    elements_.push_back(std::string(arg));\n    return *this;\n  }\n\n  // Same as above but adds a runtime argument.\n  CmdlineBuilder& AddRuntime(std::string_view arg) { return Add(\"--runtime-arg\").Add(arg); }\n\n  // Adds a string value formatted by the format string.\n  //\n  // Usage: Add(\"--flag=%s\", \"value\")\n  CmdlineBuilder& Add(const char* arg_format, const std::string& value)\n      __attribute__((enable_if(internal::ContainsOneFormatSpecifier(arg_format, 's'),\n                               \"'arg' must be a string literal that contains '%s'\"))) {\n    return Add(android::base::StringPrintf(arg_format, value.c_str()));\n  }\n\n  // Same as above but adds a runtime argument.\n  CmdlineBuilder& AddRuntime(const char* arg_format, const std::string& value)\n      __attribute__((enable_if(internal::ContainsOneFormatSpecifier(arg_format, 's'),\n                               \"'arg' must be a string literal that contains '%s'\"))) {\n    return AddRuntime(android::base::StringPrintf(arg_format, value.c_str()));\n  }\n\n  // Adds an integer value formatted by the format string.\n  //\n  // Usage: Add(\"--flag=%d\", 123)\n  CmdlineBuilder& Add(const char* arg_format, int value)\n      __attribute__((enable_if(internal::ContainsOneFormatSpecifier(arg_format, 'd'),\n                               \"'arg' must be a string literal that contains '%d'\"))) {\n    return Add(android::base::StringPrintf(arg_format, value));\n  }\n\n  // Same as above but adds a runtime argument.\n  CmdlineBuilder& AddRuntime(const char* arg_format, int value)\n      __attribute__((enable_if(internal::ContainsOneFormatSpecifier(arg_format, 'd'),\n                               \"'arg' must be a string literal that contains '%d'\"))) {\n    return AddRuntime(android::base::StringPrintf(arg_format, value));\n  }\n\n  // Adds a string value formatted by the format string if the value is non-empty. Does nothing\n  // otherwise.\n  //\n  // Usage: AddIfNonEmpty(\"--flag=%s\", \"value\")\n  CmdlineBuilder& AddIfNonEmpty(const char* arg_format, const std::string& value)\n      __attribute__((enable_if(internal::ContainsOneFormatSpecifier(arg_format, 's'),\n                               \"'arg' must be a string literal that contains '%s'\"))) {\n    if (!value.empty()) {\n      Add(android::base::StringPrintf(arg_format, value.c_str()));\n    }\n    return *this;\n  }\n\n  // Same as above but adds a runtime argument.\n  CmdlineBuilder& AddRuntimeIfNonEmpty(const char* arg_format, const std::string& value)\n      __attribute__((enable_if(internal::ContainsOneFormatSpecifier(arg_format, 's'),\n                               \"'arg' must be a string literal that contains '%s'\"))) {\n    if (!value.empty()) {\n      AddRuntime(android::base::StringPrintf(arg_format, value.c_str()));\n    }\n    return *this;\n  }\n\n  // Adds an argument as-is if the boolean value is true. Does nothing otherwise.\n  CmdlineBuilder& AddIf(bool value, std::string_view arg) {\n    if (value) {\n      Add(arg);\n    }\n    return *this;\n  }\n\n  // Same as above but adds a runtime argument.\n  CmdlineBuilder& AddRuntimeIf(bool value, std::string_view arg) {\n    if (value) {\n      AddRuntime(arg);\n    }\n    return *this;\n  }\n\n private:\n  std::vector<std::string> elements_;\n};\n\n}  // namespace tools\n}  // namespace art\n\n#endif  // ART_LIBARTTOOLS_TOOLS_CMDLINE_BUILDER_H_",
        "base_contents": "",
        "res_region": "/*\n * Copyright (C) 2022 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef ART_LIBARTTOOLS_TOOLS_CMDLINE_BUILDER_H_\n#define ART_LIBARTTOOLS_TOOLS_CMDLINE_BUILDER_H_\n\n#include <algorithm>\n#include <iterator>\n#include <string>\n#include <string_view>\n#include <vector>\n\n#include \"android-base/stringprintf.h\"\n\nnamespace art {\nnamespace tools {\n\nnamespace internal {\n\nconstexpr bool ContainsOneFormatSpecifier(std::string_view format, char specifier) {\n  int count = 0;\n  size_t pos = 0;\n  while ((pos = format.find('%', pos)) != std::string_view::npos) {\n    if (pos == format.length() - 1) {\n      // Invalid trailing '%'.\n      return false;\n    }\n    if (format[pos + 1] == specifier) {\n      count++;\n    } else if (format[pos + 1] != '%') {\n      // \"%%\" is okay. Otherwise, it's a wrong specifier.\n      return false;\n    }\n    pos += 2;\n  }\n  return count == 1;\n}\n\n}  // namespace internal\n\n// A util class that builds cmdline arguments.\nclass CmdlineBuilder {\n public:\n  // Returns all arguments.\n  const std::vector<std::string>& Get() const { return elements_; }\n\n  // Adds an argument as-is.\n  CmdlineBuilder& Add(std::string_view arg) {\n    elements_.push_back(std::string(arg));\n    return *this;\n  }\n\n  // Same as above but adds a runtime argument.\n  CmdlineBuilder& AddRuntime(std::string_view arg) { return Add(\"--runtime-arg\").Add(arg); }\n\n  // Adds a string value formatted by the format string.\n  //\n  // Usage: Add(\"--flag=%s\", \"value\")\n  CmdlineBuilder& Add(const char* arg_format, const std::string& value)\n      __attribute__((enable_if(internal::ContainsOneFormatSpecifier(arg_format, 's'),\n                               \"'arg' must be a string literal that contains '%s'\"))) {\n    return Add(android::base::StringPrintf(arg_format, value.c_str()));\n  }\n\n  // Same as above but adds a runtime argument.\n  CmdlineBuilder& AddRuntime(const char* arg_format, const std::string& value)\n      __attribute__((enable_if(internal::ContainsOneFormatSpecifier(arg_format, 's'),\n                               \"'arg' must be a string literal that contains '%s'\"))) {\n    return AddRuntime(android::base::StringPrintf(arg_format, value.c_str()));\n  }\n\n  // Adds an integer value formatted by the format string.\n  //\n  // Usage: Add(\"--flag=%d\", 123)\n  CmdlineBuilder& Add(const char* arg_format, int value)\n      __attribute__((enable_if(internal::ContainsOneFormatSpecifier(arg_format, 'd'),\n                               \"'arg' must be a string literal that contains '%d'\"))) {\n    return Add(android::base::StringPrintf(arg_format, value));\n  }\n\n  // Same as above but adds a runtime argument.\n  CmdlineBuilder& AddRuntime(const char* arg_format, int value)\n      __attribute__((enable_if(internal::ContainsOneFormatSpecifier(arg_format, 'd'),\n                               \"'arg' must be a string literal that contains '%d'\"))) {\n    return AddRuntime(android::base::StringPrintf(arg_format, value));\n  }\n\n  // Adds a string value formatted by the format string if the value is non-empty. Does nothing\n  // otherwise.\n  //\n  // Usage: AddIfNonEmpty(\"--flag=%s\", \"value\")\n  CmdlineBuilder& AddIfNonEmpty(const char* arg_format, const std::string& value)\n      __attribute__((enable_if(internal::ContainsOneFormatSpecifier(arg_format, 's'),\n                               \"'arg' must be a string literal that contains '%s'\"))) {\n    if (!value.empty()) {\n      Add(android::base::StringPrintf(arg_format, value.c_str()));\n    }\n    return *this;\n  }\n\n  // Same as above but adds a runtime argument.\n  CmdlineBuilder& AddRuntimeIfNonEmpty(const char* arg_format, const std::string& value)\n      __attribute__((enable_if(internal::ContainsOneFormatSpecifier(arg_format, 's'),\n                               \"'arg' must be a string literal that contains '%s'\"))) {\n    if (!value.empty()) {\n      AddRuntime(android::base::StringPrintf(arg_format, value.c_str()));\n    }\n    return *this;\n  }\n\n  // Adds an argument as-is if the boolean value is true. Does nothing otherwise.\n  CmdlineBuilder& AddIf(bool value, std::string_view arg) {\n    if (value) {\n      Add(arg);\n    }\n    return *this;\n  }\n\n  // Same as above but adds a runtime argument.\n  CmdlineBuilder& AddRuntimeIf(bool value, std::string_view arg) {\n    if (value) {\n      AddRuntime(arg);\n    }\n    return *this;\n  }\n\n  // Concatenates this builder with another. Returns the concatenated result and nullifies the input\n  // builder.\n  CmdlineBuilder& Concat(CmdlineBuilder&& other) {\n    elements_.reserve(elements_.size() + other.elements_.size());\n    std::move(other.elements_.begin(), other.elements_.end(), std::back_inserter(elements_));\n    other.elements_.clear();\n    return *this;\n  }\n\n private:\n  std::vector<std::string> elements_;\n};\n\n}  // namespace tools\n}  // namespace art\n\n#endif  // ART_LIBARTTOOLS_TOOLS_CMDLINE_BUILDER_H_",
        "lookback": " * Copyright (C) 2022 The Android Open Source Project",
        "lookahead": "",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 0,
        "end_line": 304,
        "merge_gen_region": " CopyrightC 2 The Open Project * Licensed the License Version. (theLicense *\"); you not this except in with the. * may a of License * may a of License * *://./licensesLICENSE20 * Unless by law agreed in, * under License distributed anAS\" BASIS * WARRANTIES CONDITIONS ANY, express implied * the the for specific governing and limitations the License */ifndefRTLIBLIBTOOLSTOOLSTOOLSCMD_LINEBUILD____defineRTLIBLIBTOOLSTOOLSTOOLSCMD_ERH # <>includeiterator # <>includestring>includestring_>includevector # \"androidbasestring.\" namespace { art namespace { tools namespace { boolOneSpecifierstdstringview, specifier { count 0 sizet =; (( =.('',)) stdstring_viewnpos { ( ==.() 1 { Invalid '% return return; ifformatpos formatlength -) // trailing'. false } ifformatpos 1 ==) count } else ([ + 1 !=') //%\" okay Otherwise itOp wrong. false } +=; return ==; } // internal A util that cmdline. CmdBuilder public // all. stdvectorstdstring Get() { elements } Adds argument-is CmdBuilder Addstdstringview) elementspushbackstdstringarg",
        "confidence": 0.9102532267570496,
        "hesitated": false,
        "resolved": false
    }
]