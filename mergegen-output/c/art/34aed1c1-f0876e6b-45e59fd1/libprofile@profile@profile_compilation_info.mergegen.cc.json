[
    {
        "a_contents": "dex::TypeIndex ProfileCompilationInfo::FindOrCreateTypeIndex(const DexFile& dex_file,\n                                                             TypeReference class_ref) {\n  DCHECK(class_ref.dex_file != nullptr);\n  DCHECK_LT(class_ref.TypeIndex().index_, class_ref.dex_file->NumTypeIds());\n  if (class_ref.dex_file == &dex_file) {\n    // We can use the type index from the `class_ref` as it's a valid index in the `dex_file`.\n    return class_ref.TypeIndex();\n  }\n  // Try to find a `TypeId` in the method's dex file.\n  const char* descriptor = class_ref.dex_file->StringByTypeIdx(class_ref.TypeIndex());\n  return FindOrCreateTypeIndex(dex_file, descriptor);\n}\n\ndex::TypeIndex ProfileCompilationInfo::FindOrCreateTypeIndex(const DexFile& dex_file,\n                                                             const char* descriptor) {\n  const dex::TypeId* type_id = dex_file.FindTypeId(descriptor);\n  if (type_id != nullptr) {\n    return dex_file.GetIndexForTypeId(*type_id);\n  }\n  // Try to find an existing extra descriptor.\n  uint32_t num_type_ids = dex_file.NumTypeIds();\n  uint32_t max_artificial_ids = DexFile::kDexNoIndex16 - num_type_ids;\n  std::string_view descriptor_view(descriptor);\n  auto it = extra_descriptors_indexes_.find(descriptor_view);\n  if (it != extra_descriptors_indexes_.end()) {\n    return (*it < max_artificial_ids) ? dex::TypeIndex(num_type_ids + *it) : dex::TypeIndex();\n  }\n  // Check if inserting the extra descriptor yields a valid artificial type index.\n  if (UNLIKELY(extra_descriptors_.size() >= max_artificial_ids)) {\n    return dex::TypeIndex();  // Invalid.\n  }\n  // Add the descriptor to extra descriptors and return the artificial type index.\n  ExtraDescriptorIndex new_extra_descriptor_index = AddExtraDescriptor(descriptor_view);\n  DCHECK_LT(new_extra_descriptor_index, max_artificial_ids);\n  return dex::TypeIndex(num_type_ids + new_extra_descriptor_index);\n}\n\nbool ProfileCompilationInfo::AddClass(const DexFile& dex_file,\n                                      const char* descriptor,\n                                      const ProfileSampleAnnotation& annotation) {\n  DexFileData* const data = GetOrAddDexFileData(&dex_file, annotation);\n  if (data == nullptr) {  // checksum mismatch\n    return false;\n  }\n  dex::TypeIndex type_index = FindOrCreateTypeIndex(dex_file, descriptor);\n  if (!type_index.IsValid()) {\n    return false;\n  }\n  data->class_set.insert(type_index);\n  return true;\n}\n",
        "b_contents": "dex::TypeIndex ProfileCompilationInfo::FindOrCreateTypeIndex(const DexFile& dex_file,\n                                                             TypeReference class_ref) {\n  DCHECK(class_ref.dex_file != nullptr);\n  DCHECK_LT(class_ref.TypeIndex().index_, class_ref.dex_file->NumTypeIds());\n  if (class_ref.dex_file == &dex_file) {\n    // We can use the type index from the `class_ref` as it's a valid index in the `dex_file`.\n    return class_ref.TypeIndex();\n  }\n  // Try to find a `TypeId` in the method's dex file.\n  const char* descriptor = class_ref.dex_file->StringByTypeIdx(class_ref.TypeIndex());\n  return FindOrCreateTypeIndex(dex_file, descriptor);\n}\n\ndex::TypeIndex ProfileCompilationInfo::FindOrCreateTypeIndex(const DexFile& dex_file,\n                                                             const char* descriptor) {\n  const dex::TypeId* type_id = dex_file.FindTypeId(descriptor);\n  if (type_id != nullptr) {\n    return dex_file.GetIndexForTypeId(*type_id);\n  }\n  // Try to find an existing extra descriptor.\n  uint32_t num_type_ids = dex_file.NumTypeIds();\n  uint32_t max_artificial_ids = DexFile::kDexNoIndex16 - num_type_ids;\n  std::string_view descriptor_view(descriptor);\n  auto it = extra_descriptors_indexes_.find(descriptor_view);\n  if (it != extra_descriptors_indexes_.end()) {\n    return (*it < max_artificial_ids) ? dex::TypeIndex(num_type_ids + *it) : dex::TypeIndex();\n  }\n  // Check if inserting the extra descriptor yields a valid artificial type index.\n  if (UNLIKELY(extra_descriptors_.size() >= max_artificial_ids)) {\n    return dex::TypeIndex();  // Invalid.\n  }\n  // Add the descriptor to extra descriptors and return the artificial type index.\n  ExtraDescriptorIndex new_extra_descriptor_index = AddExtraDescriptor(descriptor_view);\n  DCHECK_LT(new_extra_descriptor_index, max_artificial_ids);\n  return dex::TypeIndex(num_type_ids + new_extra_descriptor_index);\n}\n\nbool ProfileCompilationInfo::AddClass(const DexFile& dex_file,\n                                      dex::TypeIndex type_index,\n                                      const ProfileSampleAnnotation& annotation) {\n  DCHECK(type_index.IsValid());\n  DCHECK(type_index.index_ <= dex_file.NumTypeIds() ||\n         type_index.index_ - dex_file.NumTypeIds() < extra_descriptors_.size());\n  DexFileData* const data = GetOrAddDexFileData(&dex_file, annotation);\n  if (data == nullptr) {  // checksum mismatch\n    return false;\n  }\n  data->class_set.insert(type_index);\n  return true;\n}\n\nbool ProfileCompilationInfo::AddClass(const DexFile& dex_file,\n                                      const char* descriptor,\n                                      const ProfileSampleAnnotation& annotation) {\n  DexFileData* const data = GetOrAddDexFileData(&dex_file, annotation);\n  if (data == nullptr) {  // checksum mismatch\n    return false;\n  }\n  dex::TypeIndex type_index = FindOrCreateTypeIndex(dex_file, descriptor);\n  if (!type_index.IsValid()) {\n    return false;\n  }\n  data->class_set.insert(type_index);\n  return true;\n}\n",
        "base_contents": "",
        "res_region": "dex::TypeIndex ProfileCompilationInfo::FindOrCreateTypeIndex(const DexFile& dex_file,\n                                                             TypeReference class_ref) {\n  DCHECK(class_ref.dex_file != nullptr);\n  DCHECK_LT(class_ref.TypeIndex().index_, class_ref.dex_file->NumTypeIds());\n  if (class_ref.dex_file == &dex_file) {\n    // We can use the type index from the `class_ref` as it's a valid index in the `dex_file`.\n    return class_ref.TypeIndex();\n  }\n  // Try to find a `TypeId` in the method's dex file.\n  const char* descriptor = class_ref.dex_file->StringByTypeIdx(class_ref.TypeIndex());\n  return FindOrCreateTypeIndex(dex_file, descriptor);\n}\n\ndex::TypeIndex ProfileCompilationInfo::FindOrCreateTypeIndex(const DexFile& dex_file,\n                                                             const char* descriptor) {\n  const dex::TypeId* type_id = dex_file.FindTypeId(descriptor);\n  if (type_id != nullptr) {\n    return dex_file.GetIndexForTypeId(*type_id);\n  }\n  // Try to find an existing extra descriptor.\n  uint32_t num_type_ids = dex_file.NumTypeIds();\n  uint32_t max_artificial_ids = DexFile::kDexNoIndex16 - num_type_ids;\n  std::string_view descriptor_view(descriptor);\n  auto it = extra_descriptors_indexes_.find(descriptor_view);\n  if (it != extra_descriptors_indexes_.end()) {\n    return (*it < max_artificial_ids) ? dex::TypeIndex(num_type_ids + *it) : dex::TypeIndex();\n  }\n  // Check if inserting the extra descriptor yields a valid artificial type index.\n  if (UNLIKELY(extra_descriptors_.size() >= max_artificial_ids)) {\n    return dex::TypeIndex();  // Invalid.\n  }\n  // Add the descriptor to extra descriptors and return the artificial type index.\n  ExtraDescriptorIndex new_extra_descriptor_index = AddExtraDescriptor(descriptor_view);\n  DCHECK_LT(new_extra_descriptor_index, max_artificial_ids);\n  return dex::TypeIndex(num_type_ids + new_extra_descriptor_index);\n}\n\nbool ProfileCompilationInfo::AddClass(const DexFile& dex_file,\n                                      const char* descriptor,\n                                      const ProfileSampleAnnotation& annotation) {\n  DexFileData* const data = GetOrAddDexFileData(&dex_file, annotation);\n  if (data == nullptr) {  // checksum mismatch\n    return false;\n  }\n  dex::TypeIndex type_index = FindOrCreateTypeIndex(dex_file, descriptor);\n  if (!type_index.IsValid()) {\n    return false;\n  }\n  data->class_set.insert(type_index);\n  return true;\n}\n",
        "lookback": "                                                             TypeReference class_ref) {",
        "lookahead": "bool ProfileCompilationInfo::MergeWith(const std::string& filename) {",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 660,
        "end_line": 781,
        "merge_gen_region": null,
        "confidence": 0.6243350505828857,
        "hesitated": true
    },
    {
        "a_contents": " *\n * The file starts with a header and section information:\n *   FileHeader\n *   FileSectionInfo[]\n * The first FileSectionInfo must be for the DexFiles section.\n *\n * The rest of the file is allowed to contain different sections in any order,\n * at arbitrary offsets, with any gaps betweeen them and each section can be\n * either plaintext or separately zipped. However, we're writing sections\n * without any gaps with the following order and compression:\n *   DexFiles - mandatory, plaintext\n *   ExtraDescriptors - optional, zipped\n *   Classes - optional, zipped\n *   Methods - optional, zipped\n *\n * DexFiles:\n *    number_of_dex_files\n *    (checksum,num_type_ids,num_method_ids,profile_key)[number_of_dex_files]\n * where `profile_key` is a NULL-terminated string.\n *\n * ExtraDescriptors:\n *    number_of_extra_descriptors\n *    (extra_descriptor)[number_of_extra_descriptors]\n * where `extra_descriptor` is a NULL-terminated string.\n *\n * Classes contains records for any number of dex files, each consisting of:\n *    profile_index  // Index of the dex file in DexFiles section.\n *    number_of_classes\n *    type_index_diff[number_of_classes]\n * where instead of storing plain sorted type indexes, we store their differences\n * as smaller numbers are likely to compress better.\n *\n * Methods contains records for any number of dex files, each consisting of:\n *    profile_index  // Index of the dex file in DexFiles section.\n *    following_data_size  // For easy skipping of remaining data when dex file is filtered out.\n *    method_flags\n *    bitmap_data\n *    method_encoding[]  // Until the size indicated by `following_data_size`.\n * where `method_flags` is a union of flags recorded for methods in the referenced dex file,\n * `bitmap_data` contains `num_method_ids` bits for each bit set in `method_flags` other\n * than \"hot\" (the size of `bitmap_data` is rounded up to whole bytes) and `method_encoding[]`\n * contains data for hot methods. The `method_encoding` is:\n *    method_index_diff\n *    number_of_inline_caches\n *    inline_cache_encoding[number_of_inline_caches]\n * where differences in method indexes are used for better compression,\n * and the `inline_cache_encoding` is\n *    dex_pc\n *    (M|dex_map_size)\n *    type_index_diff[dex_map_size]\n * where `M` stands for special encodings indicating missing types (kIsMissingTypesEncoding)\n * or memamorphic call (kIsMegamorphicEncoding) which both imply `dex_map_size == 0`.",
        "b_contents": " *\n * The file starts with a header and section information:\n *   FileHeader\n *   FileSectionInfo[]\n * The first FileSectionInfo must be for the DexFiles section.\n *\n * The rest of the file is allowed to contain different sections in any order,\n * at arbitrary offsets, with any gaps betweeen them and each section can be\n * either plaintext or separately zipped. However, we're writing sections\n * without any gaps with the following order and compression:\n *   DexFiles - mandatory, plaintext\n *   ExtraDescriptors - optional, zipped\n *   Classes - optional, zipped\n *   Methods - optional, zipped\n *\n * DexFiles:\n *    number_of_dex_files\n *    (checksum,num_type_ids,num_method_ids,profile_key)[number_of_dex_files]\n * where `profile_key` is a NULL-terminated string.\n *\n * ExtraDescriptors:\n *    number_of_extra_descriptors\n *    (extra_descriptor)[number_of_extra_descriptors]\n * where `extra_descriptor` is a NULL-terminated string.\n *\n * Classes contains records for any number of dex files, each consisting of:\n *    profile_index\n *    number_of_classes\n *    type_index_diff[number_of_classes]\n * where instead of storing plain sorted type indexes, we store their differences\n * as smaller numbers are likely to compress better.\n *\n * Methods contains records for any number of dex files, each consisting of:\n *    profile_index\n *    following_data_size  // For easy skipping of remaining data when dex file is filtered out.\n *    method_flags\n *    bitmap_data\n *    method_encoding[]  // Until the size indicated by `following_data_size`.\n * where `bitmap_data` contains `num_method_ids` bits for each bit set in `method_flags` other\n * than \"hot\" (the size of `bitmap_data` is rounded up to whole bytes) and `method_encoding[]`\n * contains data for hot methods. The `method_encoding` is:\n *    method_index_diff\n *    number_of_inline_caches\n *    inline_cache_encoding[number_of_inline_caches]\n * where differences in method indexes are used for better compression,\n * and the `inline_cache_encoding` is\n *    dex_pc\n *    (M|dex_map_size)\n *    type_index_diff[dex_map_size]\n * where `M` stands for special encodings indicating missing types (kIsMissingTypesEncoding)\n * or memamorphic call (kIsMegamorphicEncoding) which both imply `dex_map_size == 0`.",
        "base_contents": " * [profile_header, zipped[[profile_line_header1, profile_line_header2...],[profile_line_data1,\n *    profile_line_data2...]]\n * profile_header:\n *   magic,version,number_of_dex_files,uncompressed_size_of_zipped_data,compressed_data_size\n * profile_line_header:\n *   profile_key,number_of_classes,methods_region_size,dex_location_checksum,num_method_ids\n * profile_line_data:\n *   method_encoding_1,method_encoding_2...,class_id1,class_id2...,method_flags bitmap,\n * The method_encoding is:\n *    method_id,number_of_inline_caches,inline_cache1,inline_cache2...\n * The inline_cache is:\n *    dex_pc,[M|dex_map_size], dex_profile_index,class_id1,class_id2...,dex_profile_index2,...\n *    dex_map_size is the number of dex_indeces that follows.\n *       Classes are grouped per their dex files and the line\n *       `dex_profile_index,class_id1,class_id2...,dex_profile_index2,...` encodes the\n *       mapping from `dex_profile_index` to the set of classes `class_id1,class_id2...`\n *    M stands for megamorphic or missing types and it's encoded as either\n *    the byte kIsMegamorphicEncoding or kIsMissingTypesEncoding.\n *    When present, there will be no class ids following.",
        "res_region": " *\n * The file starts with a header and section information:\n *   FileHeader\n *   FileSectionInfo[]\n * The first FileSectionInfo must be for the DexFiles section.\n *\n * The rest of the file is allowed to contain different sections in any order,\n * at arbitrary offsets, with any gaps betweeen them and each section can be\n * either plaintext or separately zipped. However, we're writing sections\n * without any gaps with the following order and compression:\n *   DexFiles - mandatory, plaintext\n *   ExtraDescriptors - optional, zipped\n *   Classes - optional, zipped\n *   Methods - optional, zipped\n *\n * DexFiles:\n *    number_of_dex_files\n *    (checksum,num_type_ids,num_method_ids,profile_key)[number_of_dex_files]\n * where `profile_key` is a NULL-terminated string.\n *\n * ExtraDescriptors:\n *    number_of_extra_descriptors\n *    (extra_descriptor)[number_of_extra_descriptors]\n * where `extra_descriptor` is a NULL-terminated string.\n *\n * Classes contains records for any number of dex files, each consisting of:\n *    profile_index  // Index of the dex file in DexFiles section.\n *    number_of_classes\n *    type_index_diff[number_of_classes]\n * where instead of storing plain sorted type indexes, we store their differences\n * as smaller numbers are likely to compress better.\n *\n * Methods contains records for any number of dex files, each consisting of:\n *    profile_index  // Index of the dex file in DexFiles section.\n *    following_data_size  // For easy skipping of remaining data when dex file is filtered out.\n *    method_flags\n *    bitmap_data\n *    method_encoding[]  // Until the size indicated by `following_data_size`.\n * where `method_flags` is a union of flags recorded for methods in the referenced dex file,\n * `bitmap_data` contains `num_method_ids` bits for each bit set in `method_flags` other\n * than \"hot\" (the size of `bitmap_data` is rounded up to whole bytes) and `method_encoding[]`\n * contains data for hot methods. The `method_encoding` is:\n *    method_index_diff\n *    number_of_inline_caches\n *    inline_cache_encoding[number_of_inline_caches]\n * where differences in method indexes are used for better compression,\n * and the `inline_cache_encoding` is\n *    dex_pc\n *    (M|dex_map_size)\n *    type_index_diff[dex_map_size]\n * where `M` stands for special encodings indicating missing types (kIsMissingTypesEncoding)\n * or memamorphic call (kIsMegamorphicEncoding) which both imply `dex_map_size == 0`.",
        "lookback": " * The file starts with a header and section information:",
        "lookahead": " **/",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 917,
        "end_line": 1042,
        "merge_gen_region": " The The starts a and section: * The starts a and section: File * The starts a and section: File *Header FileInfo * The FileInfo must for DFiles. * The of file allowed contain sections any, at offsets with g betee them and section can * eitheraintext separatelyped.,'re sections without g with following and order compression *exFiles mandatory pl *Descriptors optional zip *asses optional zip * -,ped * -Files *: numberofdexfiles (,__)[_____] whereprofilekey is NULLterminated. * ExtraDescriptors *___)[_____] whereextradescriptor is NULLterminated. * Cl contains for number de files eaching: profileindex Index thex inex section *_____ typeindexdiffnumberofclasses * instead we sorted indexes we theirences as numbers likely compress. * Methods records any ofx files eaching: profileindex Index thex inex section",
        "confidence": 0.9511967301368713,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "    if (!buffer.Deflate()) {\n      return false;\n    }\n    if (!WriteBuffer(fd, buffer.Get(), buffer.Size())) {\n      return false;",
        "b_contents": "    if (!buffer.Deflate()) {\n      return false;",
        "base_contents": "\n    uint16_t last_class_index = 0;\n    for (const auto& class_id : dex_data.class_set) {\n      // Store the difference between the class indices. The set is ordered by\n      // class_id, so the difference will always be non negative.\n      DCHECK_GE(class_id.index_, last_class_index);\n      uint16_t diff_with_last_class_index = class_id.index_ - last_class_index;\n      last_class_index = class_id.index_;\n      AddUintToBuffer(&buffer, diff_with_last_class_index);",
        "res_region": "    if (!buffer.Deflate()) {\n      return false;\n    }",
        "lookback": "      return false;",
        "lookahead": "    if (!WriteBuffer(fd, buffer.Get(), buffer.Size())) {",
        "label": [
            "interleave",
            "complex_conflict"
        ],
        "start_line": 1146,
        "end_line": 1165,
        "merge_gen_region": null,
        "confidence": 0.6862998008728027,
        "hesitated": true
    },
    {
        "a_contents": "    add_section_info(\n        FileSectionType::kExtraDescriptors, buffer.Size(), extra_descriptors_section_size);\n  }",
        "b_contents": "    if (!WriteBuffer(fd, buffer.Get(), buffer.Size())) {\n      return false;\n    }\n    add_section_info(\n        FileSectionType::kExtraDescriptors, buffer.Size(), extra_descriptors_section_size);\n  }",
        "base_contents": "",
        "res_region": "    if (!WriteBuffer(fd, buffer.Get(), buffer.Size())) {\n      return false;\n    }\n    add_section_info(\n        FileSectionType::kExtraDescriptors, buffer.Size(), extra_descriptors_section_size);\n  }",
        "lookback": "      return false;",
        "lookahead": "",
        "label": [
            "base",
            "one_side_deletion"
        ],
        "start_line": 1167,
        "end_line": 1179,
        "merge_gen_region": null,
        "confidence": 0.5870595574378967,
        "hesitated": true
    },
    {
        "a_contents": "  // Write section infos.\n  if (lseek64(fd, sizeof(FileHeader), SEEK_SET) != sizeof(FileHeader)) {\n    return false;\n  }\n  SafeBuffer section_infos_buffer(section_index * 4u * sizeof(uint32_t));\n  for (size_t i = 0; i != section_index; ++i) {\n    const FileSectionInfo& info = section_infos[i];\n    section_infos_buffer.WriteUintAndAdvance(enum_cast<uint32_t>(info.GetType()));\n    section_infos_buffer.WriteUintAndAdvance(info.GetFileOffset());\n    section_infos_buffer.WriteUintAndAdvance(info.GetFileSize());\n    section_infos_buffer.WriteUintAndAdvance(info.GetInflatedSize());\n  }\n  DCHECK_EQ(section_infos_buffer.GetAvailableBytes(), 0u);\n  if (!WriteBuffer(fd, section_infos_buffer.Get(), section_infos_buffer.Size())) {\n    return false;\n  }",
        "b_contents": "  // Write section infos.\n  if (lseek64(fd, sizeof(FileHeader), SEEK_SET) != sizeof(FileHeader)) {\n    return false;\n  }\n  if (!WriteBuffer(fd, section_infos.data(), section_index * sizeof(FileSectionInfo))) {\n    return false;\n  }",
        "base_contents": "  buffer.clear();\n  AddUintToBuffer(&buffer, output_size);",
        "res_region": "  // Write section infos.\n  if (lseek64(fd, sizeof(FileHeader), SEEK_SET) != sizeof(FileHeader)) {\n    return false;\n  }\n  SafeBuffer section_infos_buffer(section_index * 4u * sizeof(uint32_t));\n  for (size_t i = 0; i != section_index; ++i) {\n    const FileSectionInfo& info = section_infos[i];\n    section_infos_buffer.WriteUintAndAdvance(enum_cast<uint32_t>(info.GetType()));\n    section_infos_buffer.WriteUintAndAdvance(info.GetFileOffset());\n    section_infos_buffer.WriteUintAndAdvance(info.GetFileSize());\n    section_infos_buffer.WriteUintAndAdvance(info.GetInflatedSize());\n  }\n  DCHECK_EQ(section_infos_buffer.GetAvailableBytes(), 0u);\n  if (!WriteBuffer(fd, section_infos_buffer.Get(), section_infos_buffer.Size())) {\n    return false;\n  }",
        "lookback": "  if (lseek64(fd, sizeof(FileHeader), SEEK_SET) != sizeof(FileHeader)) {",
        "lookahead": "",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 1217,
        "end_line": 1245,
        "merge_gen_region": null,
        "confidence": 0.8378152251243591,
        "hesitated": true
    },
    {
        "a_contents": "  DCHECK_EQ(info_.size(), profile_key_map_.size());\n  // Note that this doesn't look at the bitmap region, so we will return true\n  // when the profile contains only non-hot methods. This is generally ok\n  // as for speed-profile to be useful we do need hot methods and resolved classes.\n  return GetNumberOfMethods() == 0 && GetNumberOfResolvedClasses() == 0;",
        "b_contents": "  DCHECK_EQ(info_.size(), profile_key_map_.size());\n  return info_.empty();",
        "base_contents": "  DCHECK_EQ(info_.empty(), profile_key_map_.empty());\n  return info_.empty();",
        "res_region": "  DCHECK_EQ(info_.size(), profile_key_map_.size());\n  // Note that this doesn't look at the bitmap region, so we will return true\n  // when the profile contains only non-hot methods. This is generally ok\n  // as for speed-profile to be useful we do need hot methods and resolved classes.\n  return GetNumberOfMethods() == 0 && GetNumberOfResolvedClasses() == 0;",
        "lookback": "  // Note that this doesn't look at the bitmap region, so we will return true",
        "lookahead": "}",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 2393,
        "end_line": 2405,
        "merge_gen_region": null,
        "confidence": 0.8204116821289062,
        "hesitated": true
    }
]