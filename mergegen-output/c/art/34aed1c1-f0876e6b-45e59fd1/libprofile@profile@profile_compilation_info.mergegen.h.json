[
    {
        "a_contents": "  // Find a type index in the `dex_file` if there is a `TypeId` for it. Otherwise,\n  // find or insert the descriptor in \"extra descriptors\" and return an artificial\n  // type index beyond `dex_file.NumTypeIds()`. This fails if the artificial index\n  // would be kDexNoIndex16 (0xffffu) or higher, returning an invalid type index.\n  // The returned type index can be used, if valid, for `AddClass()` or (TODO) as\n  // a type index for inline caches.\n  dex::TypeIndex FindOrCreateTypeIndex(const DexFile& dex_file, TypeReference class_ref);\n  dex::TypeIndex FindOrCreateTypeIndex(const DexFile& dex_file, const char* descriptor);\n\n  // Add a class with the specified `type_index` to the profile. The `type_index`\n  // can be either a normal index for a `TypeId` in the dex file, or an artificial\n  // type index created by `FindOrCreateTypeIndex()`.\n  void AddClass(ProfileIndexType profile_index, dex::TypeIndex type_index) {\n    DCHECK_LT(profile_index, info_.size());\n    DexFileData* const data = info_[profile_index].get();\n    DCHECK(type_index.IsValid());\n    DCHECK(type_index.index_ <= data->num_type_ids ||\n           type_index.index_ - data->num_type_ids < extra_descriptors_.size());\n    data->class_set.insert(type_index);\n  }\n\n  // Add a class with the specified `type_index` to the profile. The `type_index`\n  // can be either a normal index for a `TypeId` in the dex file, or an artificial\n  // type index created by `FindOrCreateTypeIndex()`.\n  // Returns `true` on success, `false` on failure.\n  bool AddClass(const DexFile& dex_file,\n                dex::TypeIndex type_index,\n                const ProfileSampleAnnotation& annotation = ProfileSampleAnnotation::kNone) {\n    DCHECK(type_index.IsValid());\n    DCHECK(type_index.index_ <= dex_file.NumTypeIds() ||\n           type_index.index_ - dex_file.NumTypeIds() < extra_descriptors_.size());\n    DexFileData* const data = GetOrAddDexFileData(&dex_file, annotation);\n    if (data == nullptr) {  // Checksum/num_type_ids/num_method_ids mismatch or too many dex files.\n      return false;\n    }\n    data->class_set.insert(type_index);\n    return true;\n  }\n\n  // Add a class with the specified `descriptor` to the profile.\n  // Returns `true` on success, `false` on failure.\n  bool AddClass(const DexFile& dex_file,\n                const char* descriptor,\n                const ProfileSampleAnnotation& annotation = ProfileSampleAnnotation::kNone);\n  bool AddClass(const DexFile& dex_file,\n                const std::string& descriptor,\n                const ProfileSampleAnnotation& annotation = ProfileSampleAnnotation::kNone) {\n    return AddClass(dex_file, descriptor.c_str(), annotation);\n  }\n  bool AddClass(const DexFile& dex_file,\n                std::string_view descriptor,\n                const ProfileSampleAnnotation& annotation = ProfileSampleAnnotation::kNone) {\n    return AddClass(dex_file, std::string(descriptor).c_str(), annotation);\n  }\n",
        "b_contents": "  // Find a type index in the `dex_file` if there is a `TypeId` for it. Otherwise,\n  // find or insert the descriptor in \"extra descriptors\" and return an artificial\n  // type index beyond `dex_file.NumTypeIds()`. This fails if the artificial index\n  // would be kDexNoIndex16 (0xffffu) or higher, returning an invalid type index.\n  // The returned type index can be used, if valid, for `AddClass()` or (TODO) as\n  // a type index for inline caches.\n  dex::TypeIndex FindOrCreateTypeIndex(const DexFile& dex_file, TypeReference class_ref);\n  dex::TypeIndex FindOrCreateTypeIndex(const DexFile& dex_file, const char* descriptor);\n\n  // Add a class with the specified `type_index` to the profile. The `type_index`\n  // can be either a normal index for a `TypeId` in the dex file, or an artificial\n  // type index created by `FindOrCreateTypeIndex()`.\n  // Returns `true` on success, `false` on failure.\n  bool AddClass(const DexFile& dex_file,\n                dex::TypeIndex type_index,\n                const ProfileSampleAnnotation& annotation = ProfileSampleAnnotation::kNone);\n\n  // Add a class with the specified `descriptor` to the profile.\n  // Returns `true` on success, `false` on failure.\n  bool AddClass(const DexFile& dex_file,\n                const char* descriptor,\n                const ProfileSampleAnnotation& annotation = ProfileSampleAnnotation::kNone);\n  bool AddClass(const DexFile& dex_file,\n                const std::string& descriptor,\n                const ProfileSampleAnnotation& annotation = ProfileSampleAnnotation::kNone) {\n    return AddClass(dex_file, descriptor.c_str(), annotation);\n  }\n  bool AddClass(const DexFile& dex_file,\n                std::string_view descriptor,\n                const ProfileSampleAnnotation& annotation = ProfileSampleAnnotation::kNone) {\n    return AddClass(dex_file, std::string(descriptor).c_str(), annotation);\n  }\n",
        "base_contents": "",
        "res_region": "  // Find a type index in the `dex_file` if there is a `TypeId` for it. Otherwise,\n  // find or insert the descriptor in \"extra descriptors\" and return an artificial\n  // type index beyond `dex_file.NumTypeIds()`. This fails if the artificial index\n  // would be kDexNoIndex16 (0xffffu) or higher, returning an invalid type index.\n  // The returned type index can be used, if valid, for `AddClass()` or (TODO) as\n  // a type index for inline caches.\n  dex::TypeIndex FindOrCreateTypeIndex(const DexFile& dex_file, TypeReference class_ref);\n  dex::TypeIndex FindOrCreateTypeIndex(const DexFile& dex_file, const char* descriptor);\n\n  // Add a class with the specified `type_index` to the profile. The `type_index`\n  // can be either a normal index for a `TypeId` in the dex file, or an artificial\n  // type index created by `FindOrCreateTypeIndex()`.\n  void AddClass(ProfileIndexType profile_index, dex::TypeIndex type_index) {\n    DCHECK_LT(profile_index, info_.size());\n    DexFileData* const data = info_[profile_index].get();\n    DCHECK(type_index.IsValid());\n    DCHECK(type_index.index_ <= data->num_type_ids ||\n           type_index.index_ - data->num_type_ids < extra_descriptors_.size());\n    data->class_set.insert(type_index);\n  }\n\n  // Add a class with the specified `type_index` to the profile. The `type_index`\n  // can be either a normal index for a `TypeId` in the dex file, or an artificial\n  // type index created by `FindOrCreateTypeIndex()`.\n  // Returns `true` on success, `false` on failure.\n  bool AddClass(const DexFile& dex_file,\n                dex::TypeIndex type_index,\n                const ProfileSampleAnnotation& annotation = ProfileSampleAnnotation::kNone) {\n    DCHECK(type_index.IsValid());\n    DCHECK(type_index.index_ <= dex_file.NumTypeIds() ||\n           type_index.index_ - dex_file.NumTypeIds() < extra_descriptors_.size());\n    DexFileData* const data = GetOrAddDexFileData(&dex_file, annotation);\n    if (data == nullptr) {  // Checksum/num_type_ids/num_method_ids mismatch or too many dex files.\n      return false;\n    }\n    data->class_set.insert(type_index);\n    return true;\n  }\n\n  // Add a class with the specified `descriptor` to the profile.\n  // Returns `true` on success, `false` on failure.\n  bool AddClass(const DexFile& dex_file,\n                const char* descriptor,\n                const ProfileSampleAnnotation& annotation = ProfileSampleAnnotation::kNone);\n  bool AddClass(const DexFile& dex_file,\n                const std::string& descriptor,\n                const ProfileSampleAnnotation& annotation = ProfileSampleAnnotation::kNone) {\n    return AddClass(dex_file, descriptor.c_str(), annotation);\n  }\n  bool AddClass(const DexFile& dex_file,\n                std::string_view descriptor,\n                const ProfileSampleAnnotation& annotation = ProfileSampleAnnotation::kNone) {\n    return AddClass(dex_file, std::string(descriptor).c_str(), annotation);\n  }\n",
        "lookback": "  // find or insert the descriptor in \"extra descriptors\" and return an artificial",
        "lookahead": "  // Add multiple type ids for classes in a single dex file. Iterator is for type_ids not",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 319,
        "end_line": 410,
        "merge_gen_region": " Find type in `dexfile if is `` it Otherwise // or the descriptor \"extra\" and anificial type beyonddexfileNums`. fails theificial // would kexNo160xffff) higher returning invalid index // returned index be, valid forAddClass` (TODO as a index inline caches de::Type FindType( DFile de_,Reference_);x::IndexOrCreate FindType( DFile de_,Reference_);x::IndexOrCreate FindType( DFile de_, char descriptor // a with specifiedtypeindex to the. `typeindex // be either normal for aTypeId in de file or art // index byFindType() voidClassProfileType profileindex de::Index typeindex { DCHECKLTprofileindex infosize DexData const =_[_indexget DCHECK(_.()); DCHECKtypeindexindex <=->numtypeids typeindexindex - datanumtypeids extradescriptorssize data->_.(__); // a with specifiedtypeindex to the. Thetypeindex // be either normal for aTypeId` thex file or art // index byFindType() // `true on,false on. failure boolClassconstex& de_file de::Index typeindex const ProfileAnnotation annotation ProfileAnnotationk",
        "confidence": 0.9169135093688965,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "  // Extra descriptors are used to reference classes with `TypeIndex` between the dex\n  // file's `NumTypeIds()` and the `DexFile::kDexNoIndex16`. The range of usable\n  // extra descriptor indexes is therefore also limited by `DexFile::kDexNoIndex16`.\n  using ExtraDescriptorIndex = uint16_t;\n  static constexpr ExtraDescriptorIndex kMaxExtraDescriptors = DexFile::kDexNoIndex16;\n\n  class ExtraDescriptorIndexEmpty {\n   public:\n    void MakeEmpty(ExtraDescriptorIndex& index) const {\n      index = kMaxExtraDescriptors;\n    }\n    bool IsEmpty(const ExtraDescriptorIndex& index) const {\n      return index == kMaxExtraDescriptors;\n    }",
        "b_contents": "  // Extra descriptors are used to reference classes with `TypeIndex` between the dex\n  // file's `NumTypeIds()` and the `DexFile::kDexNoIndex16`. The range of usable\n  // extra descriptor indexes is therefore also limited by `DexFile::kDexNoIndex16`.\n  using ExtraDescriptorIndex = uint16_t;\n  static constexpr ExtraDescriptorIndex kMaxExtraDescriptors = DexFile::kDexNoIndex16;\n\n  class ExtraDescriptorIndexEmpty {\n   public:\n    void MakeEmpty(ExtraDescriptorIndex& index) const {\n      index = kMaxExtraDescriptors;\n    }\n    bool IsEmpty(const ExtraDescriptorIndex& index) const {\n      return index == kMaxExtraDescriptors;\n    }\n  };\n\n  class ExtraDescriptorHash {\n   public:\n    explicit ExtraDescriptorHash(const dchecked_vector<std::string>* extra_descriptors)\n        : extra_descriptors_(extra_descriptors) {}\n\n    size_t operator()(const ExtraDescriptorIndex& index) const {\n      std::string_view str = (*extra_descriptors_)[index];\n      return (*this)(str);\n    }\n\n    size_t operator()(std::string_view str) const {\n      return DataHash()(str);\n    }\n\n   private:\n    const dchecked_vector<std::string>* extra_descriptors_;\n  };\n\n  class ExtraDescriptorEquals {\n   public:\n    explicit ExtraDescriptorEquals(const dchecked_vector<std::string>* extra_descriptors)\n        : extra_descriptors_(extra_descriptors) {}\n\n    size_t operator()(const ExtraDescriptorIndex& lhs, const ExtraDescriptorIndex& rhs) const {\n      DCHECK_EQ(lhs == rhs, (*this)(lhs, (*extra_descriptors_)[rhs]));\n      return lhs == rhs;\n    }\n\n    size_t operator()(const ExtraDescriptorIndex& lhs, std::string_view rhs_str) const {\n      std::string_view lhs_str = (*extra_descriptors_)[lhs];\n      return lhs_str == rhs_str;\n    }\n\n   private:\n    const dchecked_vector<std::string>* extra_descriptors_;",
        "base_contents": "  enum class ProfileLoadStatus : uint32_t {\n    kSuccess,\n    kIOError,\n    kVersionMismatch,\n    kBadData,",
        "res_region": "  // Extra descriptors are used to reference classes with `TypeIndex` between the dex\n  // file's `NumTypeIds()` and the `DexFile::kDexNoIndex16`. The range of usable\n  // extra descriptor indexes is therefore also limited by `DexFile::kDexNoIndex16`.\n  using ExtraDescriptorIndex = uint16_t;\n  static constexpr ExtraDescriptorIndex kMaxExtraDescriptors = DexFile::kDexNoIndex16;\n\n  class ExtraDescriptorIndexEmpty {\n   public:\n    void MakeEmpty(ExtraDescriptorIndex& index) const {\n      index = kMaxExtraDescriptors;\n    }\n    bool IsEmpty(const ExtraDescriptorIndex& index) const {\n      return index == kMaxExtraDescriptors;\n    }\n  };\n\n  class ExtraDescriptorHash {\n   public:\n    explicit ExtraDescriptorHash(const dchecked_vector<std::string>* extra_descriptors)\n        : extra_descriptors_(extra_descriptors) {}\n\n    size_t operator()(const ExtraDescriptorIndex& index) const {\n      std::string_view str = (*extra_descriptors_)[index];\n      return (*this)(str);\n    }\n\n    size_t operator()(std::string_view str) const {\n      return DataHash()(str);\n    }\n\n   private:\n    const dchecked_vector<std::string>* extra_descriptors_;\n  };\n\n  class ExtraDescriptorEquals {\n   public:\n    explicit ExtraDescriptorEquals(const dchecked_vector<std::string>* extra_descriptors)\n        : extra_descriptors_(extra_descriptors) {}\n\n    size_t operator()(const ExtraDescriptorIndex& lhs, const ExtraDescriptorIndex& rhs) const {\n      DCHECK_EQ(lhs == rhs, (*this)(lhs, (*extra_descriptors_)[rhs]));\n      return lhs == rhs;\n    }\n\n    size_t operator()(const ExtraDescriptorIndex& lhs, std::string_view rhs_str) const {\n      std::string_view lhs_str = (*extra_descriptors_)[lhs];\n      return lhs_str == rhs_str;\n    }\n\n   private:\n    const dchecked_vector<std::string>* extra_descriptors_;",
        "lookback": "  // file's `NumTypeIds()` and the `DexFile::kDexNoIndex16`. The range of usable",
        "lookahead": "  };",
        "label": [
            "base",
            "complex_conflict"
        ],
        "start_line": 697,
        "end_line": 770,
        "merge_gen_region": " file ` descriptors used to classes `Type` the de //'sNums` and `DFilekexIndex16 The of usable extra indexes therefore limited `ex::kexIndex16 The range usable extra indexes therefore limited limited `ex::kexIndex`. The of // extra indexes therefore limited limited `ex::kexIndex`. usingDescriptor =16t static ExtraIndex kMaxDescriptors =ex::FilekexIndex16 classDescriptorEmpty public voidEmptyExtraIndex index const index kMaxDescriptors } Is( ExtraIndex&) { index ==Extra; }; ExtraHash public explicitDescriptor( d_<stdstring extradescriptors :__(_) sizet()( ExtraIndex index constIndex index const { index kMaxDescriptors }",
        "confidence": 0.958225429058075,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "  class ExtraDescriptorHash {\n   public:\n    explicit ExtraDescriptorHash(const dchecked_vector<std::string>* extra_descriptors)\n        : extra_descriptors_(extra_descriptors) {}\n\n    size_t operator()(const ExtraDescriptorIndex& index) const {\n      std::string_view str = (*extra_descriptors_)[index];\n      return (*this)(str);\n    }\n\n    size_t operator()(std::string_view str) const {\n      return DataHash()(str);\n    }\n\n   private:\n    const dchecked_vector<std::string>* extra_descriptors_;\n  };\n\n  class ExtraDescriptorEquals {\n   public:\n    explicit ExtraDescriptorEquals(const dchecked_vector<std::string>* extra_descriptors)\n        : extra_descriptors_(extra_descriptors) {}\n\n    size_t operator()(const ExtraDescriptorIndex& lhs, const ExtraDescriptorIndex& rhs) const {\n      DCHECK_EQ(lhs == rhs, (*this)(lhs, (*extra_descriptors_)[rhs]));\n      return lhs == rhs;\n    }\n\n    size_t operator()(const ExtraDescriptorIndex& lhs, std::string_view rhs_str) const {\n      std::string_view lhs_str = (*extra_descriptors_)[lhs];\n      return lhs_str == rhs_str;\n    }\n\n   private:\n    const dchecked_vector<std::string>* extra_descriptors_;\n  };\n\n  using ExtraDescriptorHashSet = HashSet<ExtraDescriptorIndex,\n                                         ExtraDescriptorIndexEmpty,\n                                         ExtraDescriptorHash,\n                                         ExtraDescriptorEquals>;\n",
        "b_contents": "  using ExtraDescriptorHashSet = HashSet<ExtraDescriptorIndex,\n                                         ExtraDescriptorIndexEmpty,\n                                         ExtraDescriptorHash,\n                                         ExtraDescriptorEquals>;\n",
        "base_contents": "",
        "res_region": "  };\n\n  using ExtraDescriptorHashSet = HashSet<ExtraDescriptorIndex,\n                                         ExtraDescriptorIndexEmpty,\n                                         ExtraDescriptorHash,\n                                         ExtraDescriptorEquals>;\n",
        "lookback": "",
        "lookahead": "  // Internal representation of the profile information belonging to a dex file.",
        "label": [
            "interleave",
            "one_side_deletion"
        ],
        "start_line": 773,
        "end_line": 823,
        "merge_gen_region": " ExtraHash public explicitDescriptor( d_<stdstring extradescriptors :__(_) sizet()( ExtraIndex index const stdstringview =extradescriptors[]; (*)(); sizet()(::_ str const { Data()(); }: d_<::>*__; classDescriptor {: ExtraEquals public explicitDescriptor( d_<stdstring extra_) extradsDescriptor {: ExtraEquals public explicitDescriptor( d_<stdstring extra_) extra__(_) sizet()( ExtraIndex lhs constDescriptor&) {_( ==,thislhs,thislhs rhs const DCHECKEQlhs ==,this)(,extradescriptors[])); lhs ==; sizet()( ExtraIndex lhs stdstringview_str const stdstringview__)[]; lhs_ ==_; private const d_<::>*__; usingDescriptorSet =SetDescriptor_; classDescriptor {: ExtraEquals public explicitDescriptor {: ExtraEqualsSet = kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault kDefault",
        "confidence": 0.9536913633346558,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "",
        "b_contents": "  // Returns the maximum value for the profile index.\n  static constexpr ProfileIndexType MaxProfileIndex() {\n    return std::numeric_limits<ProfileIndexType>::max();\n  }\n",
        "base_contents": "  // Returns the maximum value for the profile index. It depends on the profile type.\n  // Boot profiles can store more dex files than regular profiles.\n  ProfileIndexType MaxProfileIndex() const;\n  // Returns the size of the profile index type used for serialization.\n  uint32_t SizeOfProfileIndexType() const;\n  // Writes the profile index to the buffer. The type of profile will determine the\n  // number of bytes used for serialization.\n  void WriteProfileIndex(std::vector<uint8_t>* buffer, ProfileIndexType value) const;\n  // Read the profile index from the buffer. The type of profile will determine the\n  // number of bytes used for serialization.\n  bool ReadProfileIndex(SafeBuffer& safe_buffer, ProfileIndexType* value) const;\n",
        "res_region": "",
        "lookback": "  friend class CompilerDriverProfileTest;",
        "lookahead": "  friend class ProfileCompilationInfoTest;",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 1057,
        "end_line": 1077,
        "merge_gen_region": null,
        "confidence": 0.6310344934463501,
        "hesitated": true
    }
]