[
    {
        "a_contents": "\n  return NonFatal(ART_FORMAT(\"Fstab entries not found for '{}'\", in_dexFile));\n}\n\nScopedAStatus Artd::validateDexPath(const std::string& in_dexPath,\n                                    std::optional<std::string>* _aidl_return) {\n  if (Result<void> result = ValidateDexPath(in_dexPath); !result.ok()) {\n    *_aidl_return = result.error().message();\n  } else {\n    *_aidl_return = std::nullopt;\n  }\n  return ScopedAStatus::ok();\n}\n\nScopedAStatus Artd::validateClassLoaderContext(const std::string& in_dexPath,\n                                               const std::string& in_classLoaderContext,\n                                               std::optional<std::string>* _aidl_return) {\n  if (in_classLoaderContext == ClassLoaderContext::kUnsupportedClassLoaderContextEncoding) {\n    *_aidl_return = std::nullopt;\n    return ScopedAStatus::ok();\n  }\n\n  std::unique_ptr<ClassLoaderContext> context = ClassLoaderContext::Create(in_classLoaderContext);\n  if (context == nullptr) {\n    *_aidl_return = ART_FORMAT(\"Class loader context '{}' is invalid\", in_classLoaderContext);\n    return ScopedAStatus::ok();\n  }\n\n  std::vector<std::string> flattened_context = context->FlattenDexPaths();\n  std::string dex_dir = Dirname(in_dexPath);\n  for (const std::string& context_element : flattened_context) {\n    std::string context_path = std::filesystem::path(dex_dir).append(context_element);\n    if (Result<void> result = ValidateDexPath(context_path); !result.ok()) {\n      *_aidl_return = result.error().message();\n      return ScopedAStatus::ok();\n    }\n  }\n\n  *_aidl_return = std::nullopt;\n  return ScopedAStatus::ok();",
        "b_contents": "\n  return NonFatal(ART_FORMAT(\"Fstab entries not found for '{}'\", in_dexFile));",
        "base_contents": "  *_aidl_return = st.f_type == INCFS_MAGIC_NUMBER;\n  return ScopedAStatus::ok();\n#else\n  *_aidl_return = false;\n  return ScopedAStatus::ok();\n#endif",
        "res_region": "\n  return NonFatal(ART_FORMAT(\"Fstab entries not found for '{}'\", in_dexFile));\n}\n\nScopedAStatus Artd::validateDexPath(const std::string& in_dexPath,\n                                    std::optional<std::string>* _aidl_return) {\n  if (Result<void> result = ValidateDexPath(in_dexPath); !result.ok()) {\n    *_aidl_return = result.error().message();\n  } else {\n    *_aidl_return = std::nullopt;\n  }\n  return ScopedAStatus::ok();\n}\n\nScopedAStatus Artd::validateClassLoaderContext(const std::string& in_dexPath,\n                                               const std::string& in_classLoaderContext,\n                                               std::optional<std::string>* _aidl_return) {\n  if (in_classLoaderContext == ClassLoaderContext::kUnsupportedClassLoaderContextEncoding) {\n    *_aidl_return = std::nullopt;\n    return ScopedAStatus::ok();\n  }\n\n  std::unique_ptr<ClassLoaderContext> context = ClassLoaderContext::Create(in_classLoaderContext);\n  if (context == nullptr) {\n    *_aidl_return = ART_FORMAT(\"Class loader context '{}' is invalid\", in_classLoaderContext);\n    return ScopedAStatus::ok();\n  }\n\n  std::vector<std::string> flattened_context = context->FlattenDexPaths();\n  std::string dex_dir = Dirname(in_dexPath);\n  for (const std::string& context_element : flattened_context) {\n    std::string context_path = std::filesystem::path(dex_dir).append(context_element);\n    if (Result<void> result = ValidateDexPath(context_path); !result.ok()) {\n      *_aidl_return = result.error().message();\n      return ScopedAStatus::ok();\n    }\n  }\n\n  *_aidl_return = std::nullopt;\n  return ScopedAStatus::ok();",
        "lookback": "  return NonFatal(ART_FORMAT(\"Fstab entries not found for '{}'\", in_dexFile));",
        "lookahead": "}",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 1101,
        "end_line": 1152,
        "merge_gen_region": null,
        "confidence": 0.8322324156761169,
        "hesitated": true
    }
]