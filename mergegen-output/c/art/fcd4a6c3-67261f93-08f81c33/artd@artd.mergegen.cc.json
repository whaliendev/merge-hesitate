[
    {
        "a_contents": "CopyAndRewriteProfileResult AnalyzeCopyAndRewriteProfileFailure(\n    File* src, ProfmanResult::CopyAndUpdateResult result) {\n  DCHECK(result == ProfmanResult::kCopyAndUpdateNoMatch ||\n         result == ProfmanResult::kCopyAndUpdateErrorFailedToLoadProfile);\n\n  auto bad_profile = [&](std::string_view error_msg) {\n    return CopyAndRewriteProfileResult{\n        .status = CopyAndRewriteProfileResult::Status::BAD_PROFILE,\n        .errorMsg = ART_FORMAT(\"Failed to load profile '{}': {}\", src->GetPath(), error_msg)};\n  };\n  CopyAndRewriteProfileResult no_profile{.status = CopyAndRewriteProfileResult::Status::NO_PROFILE,\n                                         .errorMsg = \"\"};\n\n  int64_t length = src->GetLength();\n  if (length < 0) {\n    return bad_profile(strerror(-length));\n  }\n  if (length == 0) {\n    return no_profile;\n  }\n\n  std::string error_msg;\n  uint32_t magic;\n  if (!ReadMagicAndReset(src->Fd(), &magic, &error_msg)) {\n    return bad_profile(error_msg);\n  }\n  if (IsZipMagic(magic)) {\n    std::unique_ptr<ZipArchive> zip_archive(\n        ZipArchive::OpenFromOwnedFd(src->Fd(), src->GetPath().c_str(), &error_msg));\n    if (zip_archive == nullptr) {\n      return bad_profile(error_msg);\n    }\n    std::unique_ptr<ZipEntry> zip_entry(zip_archive->Find(\"primary.prof\", &error_msg));\n    if (zip_entry == nullptr || zip_entry->GetUncompressedLength() == 0) {\n      return no_profile;\n    }\n  }\n\n  if (result == ProfmanResult::kCopyAndUpdateNoMatch) {\n    return bad_profile(\n        \"The profile does not match the APK (The checksums in the profile do not match the \"\n        \"checksums of the .dex files in the APK)\");\n  }\n  return bad_profile(\"The profile is in the wrong format or an I/O error has occurred\");\n}\n\n// Returns the fd on success, or an invalid fd if the dex file contains no profile, or error if any\n// error occurs.\nResult<File> ExtractEmbeddedProfileToFd(const std::string& dex_path) {\n  std::unique_ptr<File> dex_file = OR_RETURN(OpenFileForReading(dex_path));\n\n  std::string error_msg;\n  uint32_t magic;\n  if (!ReadMagicAndReset(dex_file->Fd(), &magic, &error_msg)) {\n    return Error() << error_msg;\n  }\n  if (!IsZipMagic(magic)) {\n    if (DexFileLoader::IsMagicValid(magic)) {\n      // The dex file can be a plain dex file. This is expected.\n      return File();\n    }\n    return Error() << \"File is neither a zip file nor a plain dex file\";\n  }\n\n  std::unique_ptr<ZipArchive> zip_archive(\n      ZipArchive::OpenFromOwnedFd(dex_file->Fd(), dex_path.c_str(), &error_msg));\n  if (zip_archive == nullptr) {\n    return Error() << error_msg;\n  }\n  constexpr const char* kEmbeddedProfileEntry = \"assets/art-profile/baseline.prof\";\n  std::unique_ptr<ZipEntry> zip_entry(zip_archive->Find(kEmbeddedProfileEntry, &error_msg));\n  size_t size;\n  if (zip_entry == nullptr || (size = zip_entry->GetUncompressedLength()) == 0) {\n    // From system/libziparchive/zip_error.cpp.\n    constexpr const char* kEntryNotFound = \"Entry not found\";\n    if (error_msg != kEntryNotFound) {\n      LOG(WARNING) << ART_FORMAT(\n          \"Failed to find zip entry '{}' in '{}': {}\", kEmbeddedProfileEntry, dex_path, error_msg);\n    }\n    // The dex file doesn't necessarily contain a profile. This is expected.\n    return File();\n  }\n\n  // The name is for debugging only.\n  std::string memfd_name =\n      ART_FORMAT(\"{} extracted in memory from {}\", kEmbeddedProfileEntry, dex_path);\n  File memfd(memfd_create(memfd_name.c_str(), /*flags=*/0),\n             memfd_name,\n             /*check_usage=*/false);\n  if (!memfd.IsValid()) {\n    return ErrnoError() << \"Failed to create memfd\";\n  }\n  if (ftruncate(memfd.Fd(), size) != 0) {\n    return ErrnoError() << \"Failed to ftruncate memfd\";\n  }\n  // Map with MAP_SHARED because we're feeding the fd to profman.\n  MemMap mem_map = MemMap::MapFile(size,\n                                   PROT_READ | PROT_WRITE,\n                                   MAP_SHARED,\n                                   memfd.Fd(),\n                                   /*start=*/0,\n                                   /*low_4gb=*/false,\n                                   memfd_name.c_str(),\n                                   &error_msg);\n  if (!mem_map.IsValid()) {\n    return Errorf(\"Failed to mmap memfd: {}\", error_msg);\n  }\n  if (!zip_entry->ExtractToMemory(mem_map.Begin(), &error_msg)) {\n    return Errorf(\"Failed to extract '{}': {}\", kEmbeddedProfileEntry, error_msg);\n  }\n\n  return memfd;\n}\n",
        "b_contents": "CopyAndRewriteProfileResult AnalyzeCopyAndRewriteProfileFailure(\n    File* src, ProfmanResult::CopyAndUpdateResult result) {\n  DCHECK(result == ProfmanResult::kCopyAndUpdateNoMatch ||\n         result == ProfmanResult::kCopyAndUpdateErrorFailedToLoadProfile);\n\n  auto bad_profile = [&](std::string_view error_msg) {\n    return CopyAndRewriteProfileResult{\n        .status = CopyAndRewriteProfileResult::Status::BAD_PROFILE,\n        .errorMsg = ART_FORMAT(\"Failed to load profile '{}': {}\", src->GetPath(), error_msg)};\n  };\n  CopyAndRewriteProfileResult no_profile{.status = CopyAndRewriteProfileResult::Status::NO_PROFILE,\n                                         .errorMsg = \"\"};\n\n  int64_t length = src->GetLength();\n  if (length < 0) {\n    return bad_profile(strerror(-length));\n  }\n  if (length == 0) {\n    return no_profile;\n  }\n\n  std::string error_msg;\n  uint32_t magic;\n  if (!ReadMagicAndReset(src->Fd(), &magic, &error_msg)) {\n    return bad_profile(error_msg);\n  }\n  if (IsZipMagic(magic)) {\n    std::unique_ptr<ZipArchive> zip_archive(\n        ZipArchive::OpenFromOwnedFd(src->Fd(), src->GetPath().c_str(), &error_msg));\n    if (zip_archive == nullptr) {\n      return bad_profile(error_msg);\n    }\n    std::unique_ptr<ZipEntry> zip_entry(zip_archive->Find(\"primary.prof\", &error_msg));\n    if (zip_entry == nullptr || zip_entry->GetUncompressedLength() == 0) {\n      return no_profile;\n    }\n  }\n\n  if (result == ProfmanResult::kCopyAndUpdateNoMatch) {\n    return bad_profile(\n        \"The profile does not match the APK (The checksums in the profile do not match the \"\n        \"checksums of the .dex files in the APK)\");\n  }\n  return bad_profile(\"The profile is in the wrong format or an I/O error has occurred\");\n}\n",
        "base_contents": "",
        "res_region": "CopyAndRewriteProfileResult AnalyzeCopyAndRewriteProfileFailure(\n    File* src, ProfmanResult::CopyAndUpdateResult result) {\n  DCHECK(result == ProfmanResult::kCopyAndUpdateNoMatch ||\n         result == ProfmanResult::kCopyAndUpdateErrorFailedToLoadProfile);\n\n  auto bad_profile = [&](std::string_view error_msg) {\n    return CopyAndRewriteProfileResult{\n        .status = CopyAndRewriteProfileResult::Status::BAD_PROFILE,\n        .errorMsg = ART_FORMAT(\"Failed to load profile '{}': {}\", src->GetPath(), error_msg)};\n  };\n  CopyAndRewriteProfileResult no_profile{.status = CopyAndRewriteProfileResult::Status::NO_PROFILE,\n                                         .errorMsg = \"\"};\n\n  int64_t length = src->GetLength();\n  if (length < 0) {\n    return bad_profile(strerror(-length));\n  }\n  if (length == 0) {\n    return no_profile;\n  }\n\n  std::string error_msg;\n  uint32_t magic;\n  if (!ReadMagicAndReset(src->Fd(), &magic, &error_msg)) {\n    return bad_profile(error_msg);\n  }\n  if (IsZipMagic(magic)) {\n    std::unique_ptr<ZipArchive> zip_archive(\n        ZipArchive::OpenFromOwnedFd(src->Fd(), src->GetPath().c_str(), &error_msg));\n    if (zip_archive == nullptr) {\n      return bad_profile(error_msg);\n    }\n    std::unique_ptr<ZipEntry> zip_entry(zip_archive->Find(\"primary.prof\", &error_msg));\n    if (zip_entry == nullptr || zip_entry->GetUncompressedLength() == 0) {\n      return no_profile;\n    }\n  }\n\n  if (result == ProfmanResult::kCopyAndUpdateNoMatch) {\n    return bad_profile(\n        \"The profile does not match the APK (The checksums in the profile do not match the \"\n        \"checksums of the .dex files in the APK)\");\n  }\n  return bad_profile(\"The profile is in the wrong format or an I/O error has occurred\");\n}\n\n// Returns the fd on success, or an invalid fd if the dex file contains no profile, or error if any\n// error occurs.\nResult<File> ExtractEmbeddedProfileToFd(const std::string& dex_path) {\n  std::unique_ptr<File> dex_file = OR_RETURN(OpenFileForReading(dex_path));\n\n  std::string error_msg;\n  uint32_t magic;\n  if (!ReadMagicAndReset(dex_file->Fd(), &magic, &error_msg)) {\n    return Error() << error_msg;\n  }\n  if (!IsZipMagic(magic)) {\n    if (DexFileLoader::IsMagicValid(magic)) {\n      // The dex file can be a plain dex file. This is expected.\n      return File();\n    }\n    return Error() << \"File is neither a zip file nor a plain dex file\";\n  }\n\n  std::unique_ptr<ZipArchive> zip_archive(\n      ZipArchive::OpenFromOwnedFd(dex_file->Fd(), dex_path.c_str(), &error_msg));\n  if (zip_archive == nullptr) {\n    return Error() << error_msg;\n  }\n  constexpr const char* kEmbeddedProfileEntry = \"assets/art-profile/baseline.prof\";\n  std::unique_ptr<ZipEntry> zip_entry(zip_archive->Find(kEmbeddedProfileEntry, &error_msg));\n  size_t size;\n  if (zip_entry == nullptr || (size = zip_entry->GetUncompressedLength()) == 0) {\n    // From system/libziparchive/zip_error.cpp.\n    constexpr const char* kEntryNotFound = \"Entry not found\";\n    if (error_msg != kEntryNotFound) {\n      LOG(WARNING) << ART_FORMAT(\n          \"Failed to find zip entry '{}' in '{}': {}\", kEmbeddedProfileEntry, dex_path, error_msg);\n    }\n    // The dex file doesn't necessarily contain a profile. This is expected.\n    return File();\n  }\n\n  // The name is for debugging only.\n  std::string memfd_name =\n      ART_FORMAT(\"{} extracted in memory from {}\", kEmbeddedProfileEntry, dex_path);\n  File memfd(memfd_create(memfd_name.c_str(), /*flags=*/0),\n             memfd_name,\n             /*check_usage=*/false);\n  if (!memfd.IsValid()) {\n    return ErrnoError() << \"Failed to create memfd\";\n  }\n  if (ftruncate(memfd.Fd(), size) != 0) {\n    return ErrnoError() << \"Failed to ftruncate memfd\";\n  }\n  // Map with MAP_SHARED because we're feeding the fd to profman.\n  MemMap mem_map = MemMap::MapFile(size,\n                                   PROT_READ | PROT_WRITE,\n                                   MAP_SHARED,\n                                   memfd.Fd(),\n                                   /*start=*/0,\n                                   /*low_4gb=*/false,\n                                   memfd_name.c_str(),\n                                   &error_msg);\n  if (!mem_map.IsValid()) {\n    return Errorf(\"Failed to mmap memfd: {}\", error_msg);\n  }\n  if (!zip_entry->ExtractToMemory(mem_map.Begin(), &error_msg)) {\n    return Errorf(\"Failed to extract '{}': {}\", kEmbeddedProfileEntry, error_msg);\n  }\n\n  return memfd;\n}\n",
        "lookback": "    File* src, ProfmanResult::CopyAndUpdateResult result) {",
        "lookahead": "class FdLogger {",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 359,
        "end_line": 522,
        "merge_gen_region": null,
        "confidence": 0.8543978333473206,
        "hesitated": true
    },
    {
        "a_contents": "ndk::ScopedAStatus Artd::CopyAndRewriteProfileImpl(File src,\n                                                   OutputProfile* dst_aidl,\n                                                   const std::string& dex_path,\n                                                   CopyAndRewriteProfileResult* aidl_return) {\n  std::string dst_path = OR_RETURN_FATAL(BuildFinalProfilePath(dst_aidl->profilePath));\n  OR_RETURN_FATAL(ValidateDexPath(dex_path));",
        "b_contents": "ndk::ScopedAStatus Artd::copyAndRewriteProfile(const ProfilePath& in_src,\n                                               OutputProfile* in_dst,\n                                               const std::string& in_dexFile,\n                                               CopyAndRewriteProfileResult* _aidl_return) {\n  std::string src_path = OR_RETURN_FATAL(BuildProfileOrDmPath(in_src));\n  std::string dst_path = OR_RETURN_FATAL(BuildFinalProfilePath(in_dst->profilePath));\n  OR_RETURN_FATAL(ValidateDexPath(in_dexFile));",
        "base_contents": "ndk::ScopedAStatus Artd::copyAndRewriteProfile(const ProfilePath& in_src,\n                                               OutputProfile* in_dst,\n                                               const std::string& in_dexFile,\n                                               bool* _aidl_return) {\n  std::string src_path = OR_RETURN_FATAL(BuildProfileOrDmPath(in_src));\n  std::string dst_path = OR_RETURN_FATAL(BuildFinalProfilePath(in_dst->profilePath));\n  OR_RETURN_FATAL(ValidateDexPath(in_dexFile));",
        "res_region": "ndk::ScopedAStatus Artd::CopyAndRewriteProfileImpl(File src,\n                                                   OutputProfile* dst_aidl,\n                                                   const std::string& dex_path,\n                                                   CopyAndRewriteProfileResult* aidl_return) {\n  std::string dst_path = OR_RETURN_FATAL(BuildFinalProfilePath(dst_aidl->profilePath));\n  OR_RETURN_FATAL(ValidateDexPath(dex_path));",
        "lookback": "                                                   OutputProfile* dst_aidl,",
        "lookahead": "",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 670,
        "end_line": 693,
        "merge_gen_region": null,
        "confidence": 0.8319717645645142,
        "hesitated": true
    },
    {
        "a_contents": "  args.Add(\"--profile-file-fd=%d\", src.Fd());\n  fd_logger.Add(src);",
        "b_contents": "  Result<std::unique_ptr<File>> src = OpenFileForReading(src_path);\n  if (!src.ok()) {\n    if (src.error().code() == ENOENT) {\n      _aidl_return->status = CopyAndRewriteProfileResult::Status::NO_PROFILE;\n      return ScopedAStatus::ok();\n    }\n    return NonFatal(\n        ART_FORMAT(\"Failed to open src profile '{}': {}\", src_path, src.error().message()));\n  }\n  args.Add(\"--profile-file-fd=%d\", src.value()->Fd());\n  fd_logger.Add(*src.value());",
        "base_contents": "  Result<std::unique_ptr<File>> src = OpenFileForReading(src_path);\n  if (!src.ok()) {\n    if (src.error().code() == ENOENT) {\n      *_aidl_return = false;\n      return ScopedAStatus::ok();\n    }\n    return NonFatal(\n        ART_FORMAT(\"Failed to open src profile '{}': {}\", src_path, src.error().message()));\n  }\n  args.Add(\"--profile-file-fd=%d\", src.value()->Fd());\n  fd_logger.Add(*src.value());",
        "res_region": "  args.Add(\"--profile-file-fd=%d\", src.Fd());\n  fd_logger.Add(src);",
        "lookback": "  fd_logger.Add(src);",
        "lookahead": "",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 703,
        "end_line": 730,
        "merge_gen_region": null,
        "confidence": 0.7850767374038696,
        "hesitated": true
    },
    {
        "a_contents": "  if (result.value() == ProfmanResult::kCopyAndUpdateNoMatch ||\n      result.value() == ProfmanResult::kCopyAndUpdateErrorFailedToLoadProfile) {\n    *aidl_return = AnalyzeCopyAndRewriteProfileFailure(\n        &src, static_cast<ProfmanResult::CopyAndUpdateResult>(result.value()));",
        "b_contents": "  if (result.value() == ProfmanResult::kCopyAndUpdateNoMatch ||\n      result.value() == ProfmanResult::kCopyAndUpdateErrorFailedToLoadProfile) {\n    *_aidl_return = AnalyzeCopyAndRewriteProfileFailure(\n        src->get(), static_cast<ProfmanResult::CopyAndUpdateResult>(result.value()));",
        "base_contents": "  if (result.value() == ProfmanResult::kCopyAndUpdateNoMatch) {\n    *_aidl_return = false;",
        "res_region": "  if (result.value() == ProfmanResult::kCopyAndUpdateNoMatch ||\n      result.value() == ProfmanResult::kCopyAndUpdateErrorFailedToLoadProfile) {\n    *aidl_return = AnalyzeCopyAndRewriteProfileFailure(\n        &src, static_cast<ProfmanResult::CopyAndUpdateResult>(result.value()));",
        "lookback": "      result.value() == ProfmanResult::kCopyAndUpdateErrorFailedToLoadProfile) {",
        "lookahead": "    return ScopedAStatus::ok();",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 753,
        "end_line": 766,
        "merge_gen_region": null,
        "confidence": 0.8044528365135193,
        "hesitated": true
    },
    {
        "a_contents": "  aidl_return->status = CopyAndRewriteProfileResult::Status::SUCCESS;\n  dst_aidl->profilePath.id = dst->TempId();\n  dst_aidl->profilePath.tmpPath = dst->TempPath();",
        "b_contents": "  _aidl_return->status = CopyAndRewriteProfileResult::Status::SUCCESS;\n  in_dst->profilePath.id = dst->TempId();\n  in_dst->profilePath.tmpPath = dst->TempPath();",
        "base_contents": "  *_aidl_return = true;\n  in_dst->profilePath.id = dst->TempId();\n  in_dst->profilePath.tmpPath = dst->TempPath();",
        "res_region": "  aidl_return->status = CopyAndRewriteProfileResult::Status::SUCCESS;\n  dst_aidl->profilePath.id = dst->TempId();\n  dst_aidl->profilePath.tmpPath = dst->TempPath();",
        "lookback": "  dst_aidl->profilePath.id = dst->TempId();",
        "lookahead": "  return ScopedAStatus::ok();",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 775,
        "end_line": 787,
        "merge_gen_region": null,
        "confidence": 0.7647967338562012,
        "hesitated": true
    }
]