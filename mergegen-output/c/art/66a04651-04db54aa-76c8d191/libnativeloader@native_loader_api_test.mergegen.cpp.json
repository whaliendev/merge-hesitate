[
    {
        "a_contents": "/*\n * Copyright (C) 2021 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <memory>\n#include <string>\n\n#include \"gmock/gmock.h\"\n#include \"gtest/gtest.h\"\n#include \"jni.h\"\n#include \"native_loader_test.h\"\n#include \"nativehelper/scoped_utf_chars.h\"\n#include \"nativeloader/native_loader.h\"\n\nnamespace android {\nnamespace nativeloader {\n\nusing ::testing::Return;\nusing ::testing::StrEq;\n\n// Test the exported API in libnativeloader and libnativeloader_lazy. The\n// testing we can do here outside a full VM is limited, but this is only to\n// complement other tests and ensure coverage of the APIs that aren't in the\n// common call paths.\n\nclass NativeLoaderLazyTest : public ::testing::Test {\n protected:\n  void SetUp() override {\n    jni_mock = std::make_unique<testing::NiceMock<MockJni>>();\n    env = std::make_unique<JNIEnv>();\n    env->functions = CreateJNINativeInterface();\n  }\n\n  void TearDown() override {\n    // ResetNativeLoader isn't accessible through the lazy library, so we cannot\n    // reset libnativeloader internal state. Hence be sure to not reuse the same\n    // class loader/namespace names.\n    delete env->functions;\n    jni_mock.reset();\n  }\n\n  void CallCreateClassLoaderNamespace(const char* class_loader) {\n    ON_CALL(*jni_mock, JniObject_getParent(StrEq(class_loader))).WillByDefault(Return(nullptr));\n\n    jstring err = CreateClassLoaderNamespace(env.get(),\n                                             17,\n                                             env.get()->NewStringUTF(class_loader),\n                                             false,\n                                             env.get()->NewStringUTF(\"/data/app/foo/classes.dex\"),\n                                             env.get()->NewStringUTF(\"/data/app/foo\"),\n                                             /*permitted_path=*/nullptr,\n                                             /*uses_library_list=*/nullptr);\n    EXPECT_EQ(err, nullptr) << \"Error is: \" << std::string(ScopedUtfChars(env.get(), err).c_str());\n  }\n\n  std::unique_ptr<JNIEnv> env;\n};\n\nTEST_F(NativeLoaderLazyTest, CreateClassLoaderNamespace) {\n  CallCreateClassLoaderNamespace(\"my_classloader_1\");\n  EXPECT_NE(FindNamespaceByClassLoader(env.get(), env.get()->NewStringUTF(\"my_classloader_1\")),\n            nullptr);\n}\n\nTEST_F(NativeLoaderLazyTest, OpenNativeLibrary) {\n  bool needs_native_bridge;\n  char* errmsg = nullptr;\n  EXPECT_EQ(nullptr,\n            OpenNativeLibrary(env.get(),\n                              17,\n                              \"libnotfound.so\",\n                              env.get()->NewStringUTF(\"my_classloader\"),\n                              /*caller_location=*/nullptr,\n                              /*library_path=*/nullptr,\n                              &needs_native_bridge,\n                              &errmsg));\n  EXPECT_NE(nullptr, errmsg);\n  NativeLoaderFreeErrorMessage(errmsg);\n}\n\nTEST_F(NativeLoaderLazyTest, CloseNativeLibrary) {\n  char* errmsg = nullptr;\n  EXPECT_FALSE(CloseNativeLibrary(nullptr, false, &errmsg));\n  EXPECT_NE(nullptr, errmsg);\n  NativeLoaderFreeErrorMessage(errmsg);\n}\n\nTEST_F(NativeLoaderLazyTest, OpenNativeLibraryInNamespace) {\n  CallCreateClassLoaderNamespace(\"my_classloader_2\");\n  struct NativeLoaderNamespace* ns = FindNativeLoaderNamespaceByClassLoader(\n      env.get(), env.get()->NewStringUTF(\"my_classloader_2\"));\n  ASSERT_NE(nullptr, ns);\n\n  bool needs_native_bridge;\n  char* errmsg = nullptr;\n  EXPECT_FALSE(OpenNativeLibraryInNamespace(ns, \"libnotfound.so\", &needs_native_bridge, &errmsg));\n  EXPECT_NE(nullptr, errmsg);\n  NativeLoaderFreeErrorMessage(errmsg);\n}\n\nTEST_F(NativeLoaderLazyTest, FindNamespaceByClassLoader) {\n  EXPECT_EQ(nullptr, FindNamespaceByClassLoader(env.get(), env.get()->NewStringUTF(\"namespace\")));\n}\n\nTEST_F(NativeLoaderLazyTest, FindNativeLoaderNamespaceByClassLoader) {\n  EXPECT_EQ(\n      nullptr,\n      FindNativeLoaderNamespaceByClassLoader(env.get(), env.get()->NewStringUTF(\"namespace\")));\n}\n\nTEST_F(NativeLoaderLazyTest, NativeLoaderFreeErrorMessage) {\n  NativeLoaderFreeErrorMessage(nullptr);\n}\n\n}  // namespace nativeloader\n}  // namespace android",
        "b_contents": "/*\n * Copyright (C) 2021 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#if defined(ART_TARGET_ANDROID)\n\n#include \"gtest/gtest.h\"\n#include \"native_loader_test.h\"\n#include \"nativehelper/scoped_utf_chars.h\"\n#include \"nativeloader/native_loader.h\"\n\nnamespace android {\nnamespace nativeloader {\n\nusing ::testing::Return;\nusing ::testing::StrEq;\n\n// Test the exported API in libnativeloader and libnativeloader_lazy. The\n// testing we can do here outside a full VM is limited, but this is only to\n// complement other tests and ensure coverage of the APIs that aren't in the\n// common call paths.\n\nclass NativeLoaderLazyTest : public ::testing::Test {\n protected:\n  void SetUp() override {\n    mock = std::make_unique<testing::NiceMock<MockPlatform>>(false);\n    env = std::make_unique<JNIEnv>();\n    env->functions = CreateJNINativeInterface();\n  }\n\n  void TearDown() override {\n    // ResetNativeLoader isn't accessible through the lazy library, so we cannot\n    // reset libnativeloader internal state. Hence be sure to not reuse the same\n    // class loader/namespace names.\n    delete env->functions;\n    mock.reset();\n  }\n\n  void CallCreateClassLoaderNamespace(const char* class_loader) {\n    ON_CALL(*mock, JniObject_getParent(StrEq(class_loader))).WillByDefault(Return(nullptr));\n\n    jstring err = CreateClassLoaderNamespace(env.get(),\n                                             17,\n                                             env.get()->NewStringUTF(class_loader),\n                                             false,\n                                             env.get()->NewStringUTF(\"/data/app/foo/classes.dex\"),\n                                             env.get()->NewStringUTF(\"/data/app/foo\"),\n                                             /*permitted_path=*/nullptr,\n                                             /*uses_library_list=*/nullptr);\n    EXPECT_EQ(err, nullptr) << \"Error is: \" << std::string(ScopedUtfChars(env.get(), err).c_str());\n  }\n\n  std::unique_ptr<JNIEnv> env;\n};\n\nTEST_F(NativeLoaderLazyTest, CreateClassLoaderNamespace) {\n  CallCreateClassLoaderNamespace(\"my_classloader_1\");\n  EXPECT_NE(FindNamespaceByClassLoader(env.get(), env.get()->NewStringUTF(\"my_classloader_1\")),\n            nullptr);\n}\n\nTEST_F(NativeLoaderLazyTest, OpenNativeLibrary) {\n  bool needs_native_bridge;\n  char* errmsg = nullptr;\n  EXPECT_EQ(nullptr,\n            OpenNativeLibrary(env.get(),\n                              17,\n                              \"libnotfound.so\",\n                              env.get()->NewStringUTF(\"my_classloader\"),\n                              /*caller_location=*/nullptr,\n                              /*library_path=*/nullptr,\n                              &needs_native_bridge,\n                              &errmsg));\n  EXPECT_NE(nullptr, errmsg);\n  NativeLoaderFreeErrorMessage(errmsg);\n}\n\nTEST_F(NativeLoaderLazyTest, CloseNativeLibrary) {\n  char* errmsg = nullptr;\n  EXPECT_FALSE(CloseNativeLibrary(nullptr, false, &errmsg));\n  EXPECT_NE(nullptr, errmsg);\n  NativeLoaderFreeErrorMessage(errmsg);\n}\n\nTEST_F(NativeLoaderLazyTest, OpenNativeLibraryInNamespace) {\n  CallCreateClassLoaderNamespace(\"my_classloader_2\");\n  struct NativeLoaderNamespace* ns = FindNativeLoaderNamespaceByClassLoader(\n      env.get(), env.get()->NewStringUTF(\"my_classloader_2\"));\n  ASSERT_NE(nullptr, ns);\n\n  bool needs_native_bridge;\n  char* errmsg = nullptr;\n  EXPECT_FALSE(OpenNativeLibraryInNamespace(ns, \"libnotfound.so\", &needs_native_bridge, &errmsg));\n  EXPECT_NE(nullptr, errmsg);\n  NativeLoaderFreeErrorMessage(errmsg);\n}\n\nTEST_F(NativeLoaderLazyTest, FindNamespaceByClassLoader) {\n  EXPECT_EQ(nullptr, FindNamespaceByClassLoader(env.get(), env.get()->NewStringUTF(\"namespace\")));\n}\n\nTEST_F(NativeLoaderLazyTest, FindNativeLoaderNamespaceByClassLoader) {\n  EXPECT_EQ(\n      nullptr,\n      FindNativeLoaderNamespaceByClassLoader(env.get(), env.get()->NewStringUTF(\"namespace\")));\n}\n\nTEST_F(NativeLoaderLazyTest, NativeLoaderFreeErrorMessage) {\n  NativeLoaderFreeErrorMessage(nullptr);\n}\n\n}  // namespace nativeloader\n}  // namespace android\n\n#endif  // defined(ART_TARGET_ANDROID)",
        "base_contents": "",
        "res_region": "/*\n * Copyright (C) 2021 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <memory>\n#include <string>\n\n#include \"gmock/gmock.h\"\n#include \"gtest/gtest.h\"\n#include \"jni.h\"\n#include \"native_loader_test.h\"\n#include \"nativehelper/scoped_utf_chars.h\"\n#include \"nativeloader/native_loader.h\"\n\nnamespace android {\nnamespace nativeloader {\n\nusing ::testing::Return;\nusing ::testing::StrEq;\n\n// Test the exported API in libnativeloader and libnativeloader_lazy. The\n// testing we can do here outside a full VM is limited, but this is only to\n// complement other tests and ensure coverage of the APIs that aren't in the\n// common call paths.\n\nclass NativeLoaderLazyTest : public ::testing::Test {\n protected:\n  void SetUp() override {\n    jni_mock = std::make_unique<testing::NiceMock<MockJni>>();\n    env = std::make_unique<JNIEnv>();\n    env->functions = CreateJNINativeInterface();\n  }\n\n  void TearDown() override {\n    // ResetNativeLoader isn't accessible through the lazy library, so we cannot\n    // reset libnativeloader internal state. Hence be sure to not reuse the same\n    // class loader/namespace names.\n    delete env->functions;\n    jni_mock.reset();\n  }\n\n  void CallCreateClassLoaderNamespace(const char* class_loader) {\n    ON_CALL(*jni_mock, JniObject_getParent(StrEq(class_loader))).WillByDefault(Return(nullptr));\n\n    jstring err = CreateClassLoaderNamespace(env.get(),\n                                             17,\n                                             env.get()->NewStringUTF(class_loader),\n                                             false,\n                                             env.get()->NewStringUTF(\"/data/app/foo/classes.dex\"),\n                                             env.get()->NewStringUTF(\"/data/app/foo\"),\n                                             /*permitted_path=*/nullptr,\n                                             /*uses_library_list=*/nullptr);\n    EXPECT_EQ(err, nullptr) << \"Error is: \" << std::string(ScopedUtfChars(env.get(), err).c_str());\n  }\n\n  std::unique_ptr<JNIEnv> env;\n};\n\nTEST_F(NativeLoaderLazyTest, CreateClassLoaderNamespace) {\n  CallCreateClassLoaderNamespace(\"my_classloader_1\");\n  EXPECT_NE(FindNamespaceByClassLoader(env.get(), env.get()->NewStringUTF(\"my_classloader_1\")),\n            nullptr);\n}\n\nTEST_F(NativeLoaderLazyTest, OpenNativeLibrary) {\n  bool needs_native_bridge;\n  char* errmsg = nullptr;\n  EXPECT_EQ(nullptr,\n            OpenNativeLibrary(env.get(),\n                              17,\n                              \"libnotfound.so\",\n                              env.get()->NewStringUTF(\"my_classloader\"),\n                              /*caller_location=*/nullptr,\n                              /*library_path=*/nullptr,\n                              &needs_native_bridge,\n                              &errmsg));\n  EXPECT_NE(nullptr, errmsg);\n  NativeLoaderFreeErrorMessage(errmsg);\n}\n\nTEST_F(NativeLoaderLazyTest, CloseNativeLibrary) {\n  char* errmsg = nullptr;\n  EXPECT_FALSE(CloseNativeLibrary(nullptr, false, &errmsg));\n  EXPECT_NE(nullptr, errmsg);\n  NativeLoaderFreeErrorMessage(errmsg);\n}\n\nTEST_F(NativeLoaderLazyTest, OpenNativeLibraryInNamespace) {\n  CallCreateClassLoaderNamespace(\"my_classloader_2\");\n  struct NativeLoaderNamespace* ns = FindNativeLoaderNamespaceByClassLoader(\n      env.get(), env.get()->NewStringUTF(\"my_classloader_2\"));\n  ASSERT_NE(nullptr, ns);\n\n  bool needs_native_bridge;\n  char* errmsg = nullptr;\n  EXPECT_FALSE(OpenNativeLibraryInNamespace(ns, \"libnotfound.so\", &needs_native_bridge, &errmsg));\n  EXPECT_NE(nullptr, errmsg);\n  NativeLoaderFreeErrorMessage(errmsg);\n}\n\nTEST_F(NativeLoaderLazyTest, FindNamespaceByClassLoader) {\n  EXPECT_EQ(nullptr, FindNamespaceByClassLoader(env.get(), env.get()->NewStringUTF(\"namespace\")));\n}\n\nTEST_F(NativeLoaderLazyTest, FindNativeLoaderNamespaceByClassLoader) {\n  EXPECT_EQ(\n      nullptr,\n      FindNativeLoaderNamespaceByClassLoader(env.get(), env.get()->NewStringUTF(\"namespace\")));\n}\n\nTEST_F(NativeLoaderLazyTest, NativeLoaderFreeErrorMessage) {\n  NativeLoaderFreeErrorMessage(nullptr);\n}\n\n}  // namespace nativeloader\n}  // namespace android",
        "lookback": " * Copyright (C) 2021 The Android Open Source Project",
        "lookahead": "",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 0,
        "end_line": 258,
        "merge_gen_region": " CopyrightC 2 The Open Project * Licensed the License, 2. ( \"License * may use file in with the. * may a of License * *://../licensesLICENSE20 * Unless by law agreed in, * under License distributed anAS\" BASIS * WITHOUT OR OF KIND either or. See License the for specific governing and limitations the License */includememory # <>includestring # \"gmockgmockh # \"gtestgtesthh # \"jnih # \"nativeloadertesth # \"helperscopedutfcharsh # \"native/_.\" android namespaceloader using ::::Return usingtestingStr; Test exported innativeloader libnative_. // testing can here a VM limited but is to co other and coverage the APIs aren in // call. NativeLazyTest publictestingTest protected void() {_ = stdmakeuniquetestingNMock<J>> env stdmakeuniqueJNIEnv envfunctions CreateNINInterface } T() { ResetLoader't through lazy, we cannot resetnative internal. be to reuse same class/namespace. envfunctions jnimockreset } CallClassNamespaceconst*_) ONCALLjnimock JObjectgetParentStr(()); err CreateLoader(.(), live envgetNewUTFclassloader false envgetNewUTF(\"/",
        "confidence": 0.9596365094184875,
        "hesitated": false,
        "resolved": false
    }
]