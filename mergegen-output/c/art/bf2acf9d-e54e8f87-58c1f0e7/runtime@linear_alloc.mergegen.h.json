[
    {
        "a_contents": "enum class LinearAllocKind : uint32_t {\n  kNoGCRoots,\n  kGCRootArray,\n  kArtMethodArray,\n  kArtFieldArray,\n  kDexCacheArray,\n  kArtMethod\n};\n\n// Header for every allocation in LinearAlloc. The header provides the type\n// and size information to the GC for invoking the right visitor.\nclass TrackingHeader final {\n public:\n  static constexpr uint32_t kIs16Aligned = 1;\n  TrackingHeader(size_t size, LinearAllocKind kind, bool is_16_aligned = false)\n      : kind_(kind), size_(dchecked_integral_cast<uint32_t>(size)) {\n    // We need the last bit to store 16-byte alignment flag.\n    CHECK_EQ(size_ & kIs16Aligned, 0u);\n    if (is_16_aligned) {\n      size_ |= kIs16Aligned;\n    }\n  }\n\n  LinearAllocKind GetKind() const { return kind_; }\n  size_t GetSize() const { return size_ & ~kIs16Aligned; }\n  bool Is16Aligned() const { return size_ & kIs16Aligned; }\n\n private:\n  LinearAllocKind kind_;\n  uint32_t size_;\n\n  DISALLOW_IMPLICIT_CONSTRUCTORS(TrackingHeader);\n};\n\nstd::ostream& operator<<(std::ostream& os, LinearAllocKind value);\n",
        "b_contents": "enum class LinearAllocKind : uint32_t {\n  kNoGCRoots,\n  kGCRootArray,\n  kArtMethodArray,\n  kArtFieldArray,\n  kDexCacheArray,\n  kArtMethod\n};\n\n// Header for every allocation in LinearAlloc. The header provides the type\n// and size information to the GC for invoking the right visitor.\nclass TrackingHeader final {\n public:\n  static constexpr uint32_t kIs16Aligned = 1;\n  TrackingHeader(size_t size, LinearAllocKind kind, bool is_16_aligned = false)\n      : kind_(kind), size_(dchecked_integral_cast<uint32_t>(size)) {\n    // We need the last bit to store 16-byte alignment flag.\n    CHECK_EQ(size_ & kIs16Aligned, 0u);\n    if (is_16_aligned) {\n      size_ |= kIs16Aligned;\n    }\n  }\n\n  LinearAllocKind GetKind() const { return kind_; }\n  size_t GetSize() const { return size_ & ~kIs16Aligned; }\n  bool Is16Aligned() const { return size_ & kIs16Aligned; }\n\n private:\n  LinearAllocKind kind_;\n  uint32_t size_;\n\n  DISALLOW_IMPLICIT_CONSTRUCTORS(TrackingHeader);\n};\n\nstd::ostream& operator<<(std::ostream& os, LinearAllocKind value);\n\n// TODO: Support freeing if we add class unloading.",
        "base_contents": "// TODO: Support freeing if we add class unloading.",
        "res_region": "enum class LinearAllocKind : uint32_t {\n  kNoGCRoots,\n  kGCRootArray,\n  kArtMethodArray,\n  kArtFieldArray,\n  kDexCacheArray,\n  kArtMethod\n};\n\n// Header for every allocation in LinearAlloc. The header provides the type\n// and size information to the GC for invoking the right visitor.\nclass TrackingHeader final {\n public:\n  static constexpr uint32_t kIs16Aligned = 1;\n  TrackingHeader(size_t size, LinearAllocKind kind, bool is_16_aligned = false)\n      : kind_(kind), size_(dchecked_integral_cast<uint32_t>(size)) {\n    // We need the last bit to store 16-byte alignment flag.\n    CHECK_EQ(size_ & kIs16Aligned, 0u);\n    if (is_16_aligned) {\n      size_ |= kIs16Aligned;\n    }\n  }\n\n  LinearAllocKind GetKind() const { return kind_; }\n  size_t GetSize() const { return size_ & ~kIs16Aligned; }\n  bool Is16Aligned() const { return size_ & kIs16Aligned; }\n\n private:\n  LinearAllocKind kind_;\n  uint32_t size_;\n\n  DISALLOW_IMPLICIT_CONSTRUCTORS(TrackingHeader);\n};\n\nstd::ostream& operator<<(std::ostream& os, LinearAllocKind value);\n",
        "lookback": "  kNoGCRoots,",
        "lookahead": "class LinearAlloc {",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 27,
        "end_line": 104,
        "merge_gen_region": " classAlloc :32t kNoCRs kCRArray,ArtMethod,ArtArrayArrayDCacheArray kMethod // for allocation Linear. header provides type and size to GC invok the visitor classing final public static uint_tIsAligned 1 TrackHeader(_ size LinearKind, is16aligned false :_(),_(checkedintegralcastuint_>()) // need last to store- alignment._(__ k16,u ifis16aligned { size |=IsAligned } LinearKindKind() { kind_; sizetSize const return_ ~Is16; bool16() { size &Is16; private LinearKind_;32_ size DISALLOWIMPLICITCONSTRUCT(Header };::&<<(::&,Alloc value //: constexpr32_ kIsAligned 1 TrackHeader(_ size LinearKind, is16aligned false : kindkind size_(checked___<32tsize { We the last to store- alignment._(_ kIsAligned 0); (__) size |=IsAligned } LinearKindKind const return_; sizetSize const return size &k16; bool16() { size &Is16; private LinearKind_;32t_;___ORSTracking); stdostream operatorstdostream os LinearKind);); std",
        "confidence": 0.8853633403778076,
        "hesitated": false,
        "resolved": false
    }
]