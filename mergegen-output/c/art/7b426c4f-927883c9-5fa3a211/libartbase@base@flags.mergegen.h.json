[
    {
        "a_contents": "/*\n * Copyright (C) 2021 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef ART_LIBARTBASE_BASE_FLAGS_H_\n#define ART_LIBARTBASE_BASE_FLAGS_H_\n\n#include <forward_list>\n#include <optional>\n#include <string>\n#include <variant>\n\n#include \"logging.h\"\n\n// This file defines a set of flags that can be used to enable/disable features within ART or\n// otherwise tune ART's behavior. Flags can be set through command line options, server side\n// configuration, system properties, or default values. This flexibility enables easier development\n// and also larger experiments.\n//\n// The value is retrieved in the following oder:\n//   1) server side (device config) property\n//   2) system property\n//   3) cmdline flag\n//   4) default value\n//\n// The flags are defined in the Flags struct near the bottom of the file. To define a new flag, add\n// a Flag field to the struct. Then to read the value of the flag, use gFlag.MyNewFlag().\n\n#pragma clang diagnostic push\n#pragma clang diagnostic error \"-Wconversion\"\n\nnamespace art {\n\n// FlagMetaBase handles automatically adding flags to the command line parser. It is parameterized\n// by all supported flag types. In general, this should be treated as though it does not exist and\n// FlagBase, which is already specialized to the types we support, should be used instead.\ntemplate <typename... T>\nclass FlagMetaBase {\n public:\n  FlagMetaBase(const std::string&& command_line_argument_name,\n               const std::string&& system_property_name,\n               const std::string&& server_setting_name) :\n      command_line_argument_name_(command_line_argument_name),\n      system_property_name_(system_property_name),\n      server_setting_name_(server_setting_name) {}\n  virtual ~FlagMetaBase() {}\n\n  template <typename Builder>\n  static void AddFlagsToCmdlineParser(Builder* builder) {\n    for (auto* flag : ALL_FLAGS) {\n      // Each flag can return a pointer to where its command line value is stored. Because these can\n      // be different types, the return value comes as a variant. The cases list below contains a\n      // lambda that is specialized to handle each branch of the variant and call the correct\n      // methods on the command line parser builder.\n      FlagValuePointer location = flag->GetCmdLineLocation();\n      auto cases = {std::function<void()>([&]() {\n        if (std::holds_alternative<std::optional<T>*>(location)) {\n          builder = &builder->Define(flag->command_line_argument_name_.c_str())\n                         .template WithType<T>()\n                         .IntoLocation(std::get<std::optional<T>*>(location));\n        }\n      })...};\n      for (auto c : cases) {\n        c();\n      }\n    }\n  }\n\n  // Reload the value of the flags.\n  //\n  // DO NOT CALL this outside Runtime Init or Zygote post fork.\n  // This is a convention, as we should strive to have a constant view\n  // of the flags and not change the runtime behaviour midway during execution.\n  static void ReloadAllFlags(const std::string& caller) {\n    // Check the caller. This is a simple workaround to attract the attention\n    // to a possible dangerous call to ReloadAllFlags, while avoid building\n    // a lot of infra for it or having a complex friend definition.\n    DCHECK(caller == \"Init\"\n        || caller == \"ZygoteHooks_nativePostForkChild\"\n        || caller == \"ZygoteHooks_nativePostForkSystemServer\"\n        || caller == \"test\") << caller;\n    for (auto* flag : ALL_FLAGS) {\n      flag->Reload();\n    }\n\n    if (VLOG_IS_ON(startup)) {\n      VLOG_STREAM(startup) << \"Dumping flags for \" << caller;\n      DumpFlags(VLOG_STREAM(startup));\n    }\n  }\n\n  // Dump all the flags info to the given stream.\n  static void DumpFlags(std::ostream& oss) {\n    for (auto* flag : ALL_FLAGS) {\n      oss << \"\\n{\\n\";\n      flag->Dump(oss);\n      oss << \"\\n}\";\n    }\n  }\n\n protected:\n  using FlagValuePointer = std::variant<std::optional<T>*...>;\n  // Return the pointer to the value holder associated with the cmd line location.\n  virtual FlagValuePointer GetCmdLineLocation() = 0;\n  // Reloads the flag values.\n  virtual void Reload() = 0;\n  // Dumps the flags info to the given stream.\n  virtual void Dump(std::ostream& oss) const = 0;\n\n  static std::forward_list<FlagMetaBase<T...>*> ALL_FLAGS;\n\n  const std::string command_line_argument_name_;\n  const std::string system_property_name_;\n  const std::string server_setting_name_;\n};\n\nusing FlagBase = FlagMetaBase<bool, int, std::string>;\n\ntemplate <>\nstd::forward_list<FlagBase*> FlagBase::ALL_FLAGS;\n\nclass FlagsTests;\n\n// This class defines a flag with a value of a particular type.\ntemplate <typename Value>\nclass Flag : public FlagBase {\n public:\n  // Create a new Flag. The name parameter is used to generate the names from the various parameter\n  // sources. See the documentation on the Flags struct for an example.\n  explicit Flag(const std::string& name, Value default_value = {});\n  virtual ~Flag();\n\n\n  // Returns the flag value.\n  //\n  // The value is retrieved in the following oder:\n  //   1) server side (device config) property\n  //   2) system property\n  //   3) cmdline flag\n  //   4) default value\n  ALWAYS_INLINE Value GetValue() const {\n    return std::get<0>(GetValueLocation());\n  }\n\n  ALWAYS_INLINE Value operator()() const {\n    return GetValue();\n  }\n\n  // Returns the value and the location of that value for the given flag.\n  ALWAYS_INLINE std::pair<Value, std::string> GetValueLocation() const {\n    DCHECK(initialized_);\n    if (from_server_setting_.has_value()) {\n      return std::pair{from_server_setting_.value(), server_setting_name_};\n    }\n    if (from_system_property_.has_value()) {\n      return std::pair{from_system_property_.value(), system_property_name_};\n    }\n    if (from_command_line_.has_value()) {\n      return std::pair{from_command_line_.value(), command_line_argument_name_};\n    }\n    return std::pair{default_, \"default_value\"};\n  }\n\n  void Dump(std::ostream& oss) const override;\n\n protected:\n  FlagValuePointer GetCmdLineLocation() override { return &from_command_line_; }\n\n\n  // Reload the server-configured value and system property values. In general this should not be\n  // used directly, but it can be used to support reloading the value without restarting the device.\n  void Reload() override;\n\n private:\n  bool initialized_;\n  const Value default_;\n  std::optional<Value> from_command_line_;\n  std::optional<Value> from_system_property_;\n  std::optional<Value> from_server_setting_;\n\n  friend class TestFlag;\n};\n\n// This struct contains the list of ART flags. Flags are parameterized by the type of value they\n// support (bool, int, string, etc.). In addition to field name, flags have a name for the parameter\n// as well.\n//\n// Example:\n//\n//     Flag<int> WriteMetricsToLog{\"my-feature-test.flag\", 42};\n//\n// This creates a boolean flag that can be read through gFlags.WriteMetricsToLog(). The default\n// value is false. Note that the default value can be left unspecified, in which the value of the\n// type's default constructor will be used.\n//\n// The flag can be set through the following generated means:\n//\n// Command Line:\n//\n//     -Xmy-feature-test-flag=1\n//\n// Server Side (Phenotype) Configuration:\n//\n//     persist.device_config.runtime_native.my-feature-test.flag\n//\n// System Property:\n//\n//     setprop dalvik.vm.metrics.my-feature-test.flag 2\nstruct Flags {\n  // Flag used to test the infra.\n  // TODO: can be removed once we add real flags.\n  Flag<int> MyFeatureTestFlag{\"my-feature-test.flag\", /*default_value=*/ 42};\n};\n\n// This is the actual instance of all the flags.\nextern Flags gFlags;\n\n}  // namespace art\n\n#pragma clang diagnostic pop  // -Wconversion\n\n#endif  // ART_LIBARTBASE_BASE_FLAGS_H_",
        "b_contents": "/*\n * Copyright (C) 2021 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef ART_LIBARTBASE_BASE_FLAGS_H_\n#define ART_LIBARTBASE_BASE_FLAGS_H_\n\n#include <forward_list>\n#include <optional>\n#include <string>\n#include <variant>\n\n#include \"logging.h\"\n\n// This file defines a set of flags that can be used to enable/disable features within ART or\n// otherwise tune ART's behavior. Flags can be set through command line options, server side\n// configuration, system properties, or default values. This flexibility enables easier development\n// and also larger experiments.\n//\n// The value is retrieved in the following oder:\n//   1) server side (device config) property\n//   2) system property\n//   3) cmdline flag\n//   4) default value\n//\n// The flags are defined in the Flags struct near the bottom of the file. To define a new flag, add\n// a Flag field to the struct. Then to read the value of the flag, use gFlag.MyNewFlag().\n\n#pragma clang diagnostic push\n#pragma clang diagnostic error \"-Wconversion\"\n\nnamespace art {\n\n// FlagMetaBase handles automatically adding flags to the command line parser. It is parameterized\n// by all supported flag types. In general, this should be treated as though it does not exist and\n// FlagBase, which is already specialized to the types we support, should be used instead.\ntemplate <typename... T>\nclass FlagMetaBase {\n public:\n  FlagMetaBase(const std::string&& command_line_argument_name,\n               const std::string&& system_property_name,\n               const std::string&& server_setting_name) :\n      command_line_argument_name_(command_line_argument_name),\n      system_property_name_(system_property_name),\n      server_setting_name_(server_setting_name) {}\n  virtual ~FlagMetaBase() {}\n\n  template <typename Builder>\n  static void AddFlagsToCmdlineParser(Builder* builder) {\n    for (auto* flag : ALL_FLAGS) {\n      // Each flag can return a pointer to where its command line value is stored. Because these can\n      // be different types, the return value comes as a variant. The cases list below contains a\n      // lambda that is specialized to handle each branch of the variant and call the correct\n      // methods on the command line parser builder.\n      FlagValuePointer location = flag->GetCmdLineLocation();\n      auto cases = {std::function<void()>([&]() {\n        if (std::holds_alternative<std::optional<T>*>(location)) {\n          builder = &builder->Define(flag->command_line_argument_name_.c_str())\n                         .template WithType<T>()\n                         .IntoLocation(std::get<std::optional<T>*>(location));\n        }\n      })...};\n      for (auto c : cases) {\n        c();\n      }\n    }\n  }\n\n  // Reload the value of the flags.\n  //\n  // DO NOT CALL this outside Runtime Init or Zygote post fork.\n  // This is a convention, as we should strive to have a constant view\n  // of the flags and not change the runtime behaviour midway during execution.\n  static void ReloadAllFlags(const std::string& caller) {\n    // Check the caller. This is a simple workaround to attract the attention\n    // to a possible dangerous call to ReloadAllFlags, while avoid building\n    // a lot of infra for it or having a complex friend definition.\n    DCHECK(caller == \"Init\"\n        || caller == \"ZygoteHooks_nativePostForkChild\"\n        || caller == \"ZygoteHooks_nativePostForkSystemServer\"\n        || caller == \"test\") << caller;\n    for (auto* flag : ALL_FLAGS) {\n      flag->Reload();\n    }\n\n    if (VLOG_IS_ON(startup)) {\n      VLOG_STREAM(startup) << \"Dumping flags for \" << caller;\n      DumpFlags(VLOG_STREAM(startup));\n    }\n  }\n\n  // Dump all the flags info to the given stream.\n  static void DumpFlags(std::ostream& oss) {\n    for (auto* flag : ALL_FLAGS) {\n      oss << \"\\n{\\n\";\n      flag->Dump(oss);\n      oss << \"\\n}\";\n    }\n  }\n\n protected:\n  using FlagValuePointer = std::variant<std::optional<T>*...>;\n  // Return the pointer to the value holder associated with the cmd line location.\n  virtual FlagValuePointer GetCmdLineLocation() = 0;\n  // Reloads the flag values.\n  virtual void Reload() = 0;\n  // Dumps the flags info to the given stream.\n  virtual void Dump(std::ostream& oss) const = 0;\n\n  static std::forward_list<FlagMetaBase<T...>*> ALL_FLAGS;\n\n  const std::string command_line_argument_name_;\n  const std::string system_property_name_;\n  const std::string server_setting_name_;\n};\n\nusing FlagBase = FlagMetaBase<bool, int, std::string>;\n\ntemplate <>\nstd::forward_list<FlagBase*> FlagBase::ALL_FLAGS;\n\nclass FlagsTests;\n\n// This class defines a flag with a value of a particular type.\ntemplate <typename Value>\nclass Flag : public FlagBase {\n public:\n  // Create a new Flag. The name parameter is used to generate the names from the various parameter\n  // sources. See the documentation on the Flags struct for an example.\n  explicit Flag(const std::string& name, Value default_value = {});\n  virtual ~Flag() {}\n\n\n  // Returns the flag value.\n  //\n  // The value is retrieved in the following oder:\n  //   1) server side (device config) property\n  //   2) system property\n  //   3) cmdline flag\n  //   4) default value\n  ALWAYS_INLINE Value GetValue() const {\n    return std::get<0>(GetValueLocation());\n  }\n\n  ALWAYS_INLINE Value operator()() const {\n    return GetValue();\n  }\n\n  // Returns the value and the location of that value for the given flag.\n  ALWAYS_INLINE std::pair<Value, std::string> GetValueLocation() const {\n    DCHECK(initialized_);\n    if (from_server_setting_.has_value()) {\n      return std::pair{from_server_setting_.value(), server_setting_name_};\n    }\n    if (from_system_property_.has_value()) {\n      return std::pair{from_system_property_.value(), system_property_name_};\n    }\n    if (from_command_line_.has_value()) {\n      return std::pair{from_command_line_.value(), command_line_argument_name_};\n    }\n    return std::pair{default_, \"default_value\"};\n  }\n\n  void Dump(std::ostream& oss) const override;\n\n protected:\n  FlagValuePointer GetCmdLineLocation() override { return &from_command_line_; }\n\n\n  // Reload the server-configured value and system property values. In general this should not be\n  // used directly, but it can be used to support reloading the value without restarting the device.\n  void Reload() override;\n\n private:\n  bool initialized_;\n  const Value default_;\n  std::optional<Value> from_command_line_;\n  std::optional<Value> from_system_property_;\n  std::optional<Value> from_server_setting_;\n\n  friend class FlagsTests;\n};\n\n// This struct contains the list of ART flags. Flags are parameterized by the type of value they\n// support (bool, int, string, etc.). In addition to field name, flags have a name for the parameter\n// as well.\n//\n// Example:\n//\n//     Flag<int> WriteMetricsToLog{\"my-feature-test.flag\", 42};\n//\n// This creates a boolean flag that can be read through gFlags.WriteMetricsToLog(). The default\n// value is false. Note that the default value can be left unspecified, in which the value of the\n// type's default constructor will be used.\n//\n// The flag can be set through the following generated means:\n//\n// Command Line:\n//\n//     -Xmy-feature-test-flag=1\n//\n// Server Side (Phenotype) Configuration:\n//\n//     persist.device_config.runtime_native.my-feature-test.flag\n//\n// System Property:\n//\n//     setprop dalvik.vm.metrics.my-feature-test.flag 2\nstruct Flags {\n  // Flag used to test the infra.\n  // TODO: can be removed once we add real flags.\n  Flag<int> MyFeatureTestFlag{\"my-feature-test.flag\", /*default_value=*/ 42};\n};\n\n// This is the actual instance of all the flags.\nextern Flags gFlags;\n\n}  // namespace art\n\n#pragma clang diagnostic pop  // -Wconversion\n\n#endif  // ART_LIBARTBASE_BASE_FLAGS_H_",
        "base_contents": "",
        "res_region": "/*\n * Copyright (C) 2021 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef ART_LIBARTBASE_BASE_FLAGS_H_\n#define ART_LIBARTBASE_BASE_FLAGS_H_\n\n#include <forward_list>\n#include <optional>\n#include <string>\n#include <variant>\n\n#include \"logging.h\"\n\n// This file defines a set of flags that can be used to enable/disable features within ART or\n// otherwise tune ART's behavior. Flags can be set through command line options, server side\n// configuration, system properties, or default values. This flexibility enables easier development\n// and also larger experiments.\n//\n// The value is retrieved in the following oder:\n//   1) server side (device config) property\n//   2) system property\n//   3) cmdline flag\n//   4) default value\n//\n// The flags are defined in the Flags struct near the bottom of the file. To define a new flag, add\n// a Flag field to the struct. Then to read the value of the flag, use gFlag.MyNewFlag().\n\n#pragma clang diagnostic push\n#pragma clang diagnostic error \"-Wconversion\"\n\nnamespace art {\n\n// FlagMetaBase handles automatically adding flags to the command line parser. It is parameterized\n// by all supported flag types. In general, this should be treated as though it does not exist and\n// FlagBase, which is already specialized to the types we support, should be used instead.\ntemplate <typename... T>\nclass FlagMetaBase {\n public:\n  FlagMetaBase(const std::string&& command_line_argument_name,\n               const std::string&& system_property_name,\n               const std::string&& server_setting_name) :\n      command_line_argument_name_(command_line_argument_name),\n      system_property_name_(system_property_name),\n      server_setting_name_(server_setting_name) {}\n  virtual ~FlagMetaBase() {}\n\n  template <typename Builder>\n  static void AddFlagsToCmdlineParser(Builder* builder) {\n    for (auto* flag : ALL_FLAGS) {\n      // Each flag can return a pointer to where its command line value is stored. Because these can\n      // be different types, the return value comes as a variant. The cases list below contains a\n      // lambda that is specialized to handle each branch of the variant and call the correct\n      // methods on the command line parser builder.\n      FlagValuePointer location = flag->GetCmdLineLocation();\n      auto cases = {std::function<void()>([&]() {\n        if (std::holds_alternative<std::optional<T>*>(location)) {\n          builder = &builder->Define(flag->command_line_argument_name_.c_str())\n                         .template WithType<T>()\n                         .IntoLocation(std::get<std::optional<T>*>(location));\n        }\n      })...};\n      for (auto c : cases) {\n        c();\n      }\n    }\n  }\n\n  // Reload the value of the flags.\n  //\n  // DO NOT CALL this outside Runtime Init or Zygote post fork.\n  // This is a convention, as we should strive to have a constant view\n  // of the flags and not change the runtime behaviour midway during execution.\n  static void ReloadAllFlags(const std::string& caller) {\n    // Check the caller. This is a simple workaround to attract the attention\n    // to a possible dangerous call to ReloadAllFlags, while avoid building\n    // a lot of infra for it or having a complex friend definition.\n    DCHECK(caller == \"Init\"\n        || caller == \"ZygoteHooks_nativePostForkChild\"\n        || caller == \"ZygoteHooks_nativePostForkSystemServer\"\n        || caller == \"test\") << caller;\n    for (auto* flag : ALL_FLAGS) {\n      flag->Reload();\n    }\n\n    if (VLOG_IS_ON(startup)) {\n      VLOG_STREAM(startup) << \"Dumping flags for \" << caller;\n      DumpFlags(VLOG_STREAM(startup));\n    }\n  }\n\n  // Dump all the flags info to the given stream.\n  static void DumpFlags(std::ostream& oss) {\n    for (auto* flag : ALL_FLAGS) {\n      oss << \"\\n{\\n\";\n      flag->Dump(oss);\n      oss << \"\\n}\";\n    }\n  }\n\n protected:\n  using FlagValuePointer = std::variant<std::optional<T>*...>;\n  // Return the pointer to the value holder associated with the cmd line location.\n  virtual FlagValuePointer GetCmdLineLocation() = 0;\n  // Reloads the flag values.\n  virtual void Reload() = 0;\n  // Dumps the flags info to the given stream.\n  virtual void Dump(std::ostream& oss) const = 0;\n\n  static std::forward_list<FlagMetaBase<T...>*> ALL_FLAGS;\n\n  const std::string command_line_argument_name_;\n  const std::string system_property_name_;\n  const std::string server_setting_name_;\n};\n\nusing FlagBase = FlagMetaBase<bool, int, std::string>;\n\ntemplate <>\nstd::forward_list<FlagBase*> FlagBase::ALL_FLAGS;\n\nclass FlagsTests;\n\n// This class defines a flag with a value of a particular type.\ntemplate <typename Value>\nclass Flag : public FlagBase {\n public:\n  // Create a new Flag. The name parameter is used to generate the names from the various parameter\n  // sources. See the documentation on the Flags struct for an example.\n  explicit Flag(const std::string& name, Value default_value = {});\n  virtual ~Flag();\n\n\n  // Returns the flag value.\n  //\n  // The value is retrieved in the following oder:\n  //   1) server side (device config) property\n  //   2) system property\n  //   3) cmdline flag\n  //   4) default value\n  ALWAYS_INLINE Value GetValue() const {\n    return std::get<0>(GetValueLocation());\n  }\n\n  ALWAYS_INLINE Value operator()() const {\n    return GetValue();\n  }\n\n  // Returns the value and the location of that value for the given flag.\n  ALWAYS_INLINE std::pair<Value, std::string> GetValueLocation() const {\n    DCHECK(initialized_);\n    if (from_server_setting_.has_value()) {\n      return std::pair{from_server_setting_.value(), server_setting_name_};\n    }\n    if (from_system_property_.has_value()) {\n      return std::pair{from_system_property_.value(), system_property_name_};\n    }\n    if (from_command_line_.has_value()) {\n      return std::pair{from_command_line_.value(), command_line_argument_name_};\n    }\n    return std::pair{default_, \"default_value\"};\n  }\n\n  void Dump(std::ostream& oss) const override;\n\n protected:\n  FlagValuePointer GetCmdLineLocation() override { return &from_command_line_; }\n\n\n  // Reload the server-configured value and system property values. In general this should not be\n  // used directly, but it can be used to support reloading the value without restarting the device.\n  void Reload() override;\n\n private:\n  bool initialized_;\n  const Value default_;\n  std::optional<Value> from_command_line_;\n  std::optional<Value> from_system_property_;\n  std::optional<Value> from_server_setting_;\n\n  friend class TestFlag;\n};\n\n// This struct contains the list of ART flags. Flags are parameterized by the type of value they\n// support (bool, int, string, etc.). In addition to field name, flags have a name for the parameter\n// as well.\n//\n// Example:\n//\n//     Flag<int> WriteMetricsToLog{\"my-feature-test.flag\", 42};\n//\n// This creates a boolean flag that can be read through gFlags.WriteMetricsToLog(). The default\n// value is false. Note that the default value can be left unspecified, in which the value of the\n// type's default constructor will be used.\n//\n// The flag can be set through the following generated means:\n//\n// Command Line:\n//\n//     -Xmy-feature-test-flag=1\n//\n// Server Side (Phenotype) Configuration:\n//\n//     persist.device_config.runtime_native.my-feature-test.flag\n//\n// System Property:\n//\n//     setprop dalvik.vm.metrics.my-feature-test.flag 2\nstruct Flags {\n  // Flag used to test the infra.\n  // TODO: can be removed once we add real flags.\n  Flag<int> MyFeatureTestFlag{\"my-feature-test.flag\", /*default_value=*/ 42};\n};\n\n// This is the actual instance of all the flags.\nextern Flags gFlags;\n\n}  // namespace art\n\n#pragma clang diagnostic pop  // -Wconversion\n\n#endif  // ART_LIBARTBASE_BASE_FLAGS_H_",
        "lookback": " * Copyright (C) 2021 The Android Open Source Project",
        "lookahead": "",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 0,
        "end_line": 471,
        "merge_gen_region": " CopyrightC 2 The Open Project * Licensed the Apache, 2. ( \"\"); you not this except in with the. * may a of License * may a of License * *://./licensesLICENSE20 * Unless by law agreed in, * under License distributed anAS\" BASIS * WARRANTIES CONDITIONS ANY, express implied * the the for specific governing and limitations the License */ifndefRTLIBBASEBASEBASEFLAGSH # ARTLIBBASEBASEBASEFLAGSH # <__>includeoptional # <>includevariant # \".\" // file a of that be to enabledisable withinRT // otherwise A's. can set command options server //, properties or values Thisibility easier development and also exments // The value retrieved the o: 1 server ( config property 2 system // 3 cmdline //) value // The are in Flags near bottom the file To a flag add a Flag to struct. to the of, gFlagMyFlag # clang push # clang errorW\" art //Meta handles adding to command parser It parameter // all flag. general this be treated though does exist // Flag, is spec to the we, be instead templatetypename T classMeta {:Meta( stdstring commandlineargumentname const::&&____, stdstring system",
        "confidence": 0.9149680137634277,
        "hesitated": false,
        "resolved": false
    }
]