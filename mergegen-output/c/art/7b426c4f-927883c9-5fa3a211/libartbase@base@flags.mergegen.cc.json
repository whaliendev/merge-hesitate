[
    {
        "a_contents": "/*\n * Copyright (C) 2021 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"flags.h\"\n\n#include <algorithm>\n\n#include \"android-base/parsebool.h\"\n#include \"android-base/parseint.h\"\n#include \"android-base/properties.h\"\n\n#include \"base/utils.h\"\n\n#pragma clang diagnostic push\n#pragma clang diagnostic error \"-Wconversion\"\n\nnamespace {\nconstexpr const char* kPhenotypeFlagPrefix = \"persist.device_config.runtime_native.\";\nconstexpr const char* kSysPropertyFlagPrefix = \"dalvik.vm.\";\nconstexpr const char* kUndefinedValue = \"\";\n\n// The various ParseValue functions store the parsed value into *destination. If parsing fails for\n// some reason, ParseValue makes no changes to *destination.\n\nvoid ParseValue(const std::string_view value, std::optional<bool>* destination) {\n  switch (::android::base::ParseBool(value)) {\n    case ::android::base::ParseBoolResult::kError:\n      return;\n    case ::android::base::ParseBoolResult::kTrue:\n      *destination = true;\n      return;\n    case ::android::base::ParseBoolResult::kFalse:\n      *destination = false;\n      return;\n  }\n}\n\nvoid ParseValue(const std::string_view value, std::optional<int>* destination) {\n  int parsed_value = 0;\n  if (::android::base::ParseInt(std::string{value}, &parsed_value)) {\n    *destination = parsed_value;\n  }\n}\n\nvoid ParseValue(const std::string_view value, std::optional<std::string>* destination) {\n  *destination = value;\n}\n\n}  // namespace\n\nnamespace art {\n\ntemplate <>\nstd::forward_list<FlagBase*> FlagBase::ALL_FLAGS{};\n\n// gFlags must be defined after FlagBase::ALL_FLAGS so the constructors run in the right order.\nFlags gFlags;\n\nstatic std::string GenerateCmdLineArgName(const std::string& name) {\n  std::string result = \"-X\" + name + \":_\";\n  std::replace(result.begin(), result.end(), '.', '-');\n  return result;\n}\n\nstatic std::string GenerateSysPropName(const std::string& name) {\n  return kSysPropertyFlagPrefix + name;\n}\n\nstatic std::string GeneratePhenotypeName(const std::string& name) {\n  return kPhenotypeFlagPrefix + name;\n}\n\ntemplate <typename Value>\nFlag<Value>::Flag(const std::string& name, Value default_value) :\n    FlagBase(GenerateCmdLineArgName(name),\n             GenerateSysPropName(name),\n             GeneratePhenotypeName(name)),\n    initialized_{false},\n    default_{default_value} {\n  ALL_FLAGS.push_front(this);\n}\n\ntemplate <typename Value>\nFlag<Value>::~Flag() {\n  ALL_FLAGS.remove(this);\n}\n\ntemplate <typename Value>\nvoid Flag<Value>::Reload() {\n  // The cmdline flags are loaded by the parsed_options infra.\n\n  // Load system properties.\n  from_system_property_ = std::nullopt;\n  const std::string sysprop = ::android::base::GetProperty(system_property_name_, kUndefinedValue);\n  if (sysprop != kUndefinedValue) {\n    ParseValue(sysprop, &from_system_property_);\n  }\n\n  // Load the server-side configuration.\n  from_server_setting_ = std::nullopt;\n  const std::string server_config =\n      ::android::base::GetProperty(server_setting_name_, kUndefinedValue);\n  if (server_config != kUndefinedValue) {\n    ParseValue(server_config, &from_server_setting_);\n  }\n\n  initialized_ = true;\n}\n\ntemplate <typename Value>\nvoid DumpValue(std::ostream& oss, const std::optional<Value>& val) {\n  if (val.has_value()) {\n    oss << val.value();\n  } else {\n    oss << kUndefinedValue;\n  }\n}\n\ntemplate <typename Value>\nvoid Flag<Value>::Dump(std::ostream& oss) const {\n  std::pair<Value, std::string> valueLoc = GetValueLocation();\n  oss << \"value: \" << std::get<0>(valueLoc) << \" (from \" << std::get<1>(valueLoc) << \")\";\n\n  oss << \"\\n default: \" << default_;\n  oss << \"\\n \" << command_line_argument_name_ << \": \";\n  DumpValue(oss, from_command_line_);\n  oss << \"\\n \" << system_property_name_ << \": \";\n  DumpValue(oss, from_system_property_);\n  oss << \"\\n \" << server_setting_name_ << \": \";\n  DumpValue(oss, from_server_setting_);\n}\n\ntemplate class Flag<bool>;\ntemplate class Flag<int>;\ntemplate class Flag<std::string>;\n\n}  // namespace art\n\n#pragma clang diagnostic pop  // -Wconversion",
        "b_contents": "/*\n * Copyright (C) 2021 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"flags.h\"\n\n#include <algorithm>\n\n#include \"android-base/parsebool.h\"\n#include \"android-base/parseint.h\"\n#include \"android-base/properties.h\"\n\n#include \"base/utils.h\"\n\n#pragma clang diagnostic push\n#pragma clang diagnostic error \"-Wconversion\"\n\nnamespace {\nconstexpr const char* kPhenotypeFlagPrefix = \"persist.device_config.runtime_native.\";\nconstexpr const char* kSysPropertyFlagPrefix = \"dalvik.vm.\";\nconstexpr const char* kUndefinedValue = \"\";\n\n// The various ParseValue functions store the parsed value into *destination. If parsing fails for\n// some reason, ParseValue makes no changes to *destination.\n\nvoid ParseValue(const std::string_view value, std::optional<bool>* destination) {\n  switch (::android::base::ParseBool(value)) {\n    case ::android::base::ParseBoolResult::kError:\n      return;\n    case ::android::base::ParseBoolResult::kTrue:\n      *destination = true;\n      return;\n    case ::android::base::ParseBoolResult::kFalse:\n      *destination = false;\n      return;\n  }\n}\n\nvoid ParseValue(const std::string_view value, std::optional<int>* destination) {\n  int parsed_value = 0;\n  if (::android::base::ParseInt(std::string{value}, &parsed_value)) {\n    *destination = parsed_value;\n  }\n}\n\nvoid ParseValue(const std::string_view value, std::optional<std::string>* destination) {\n  *destination = value;\n}\n\n}  // namespace\n\nnamespace art {\n\ntemplate <>\nstd::forward_list<FlagBase*> FlagBase::ALL_FLAGS{};\n\n// gFlags must be defined after FlagBase::ALL_FLAGS so the constructors run in the right order.\nFlags gFlags;\n\nstatic std::string GenerateCmdLineArgName(const std::string& name) {\n  std::string result = \"-X\" + name + \":_\";\n  std::replace(result.begin(), result.end(), '.', '-');\n  return result;\n}\n\nstatic std::string GenerateSysPropName(const std::string& name) {\n  return kSysPropertyFlagPrefix + name;\n}\n\nstatic std::string GeneratePhenotypeName(const std::string& name) {\n  return kPhenotypeFlagPrefix + name;\n}\n\ntemplate <typename Value>\nFlag<Value>::Flag(const std::string& name, Value default_value) :\n    FlagBase(GenerateCmdLineArgName(name),\n             GenerateSysPropName(name),\n             GeneratePhenotypeName(name)),\n    initialized_{false},\n    default_{default_value} {\n  ALL_FLAGS.push_front(this);\n}\n\ntemplate <typename Value>\nvoid Flag<Value>::Reload() {\n  // The cmdline flags are loaded by the parsed_options infra.\n\n  // Load system properties.\n  from_system_property_ = std::nullopt;\n  const std::string sysprop = ::android::base::GetProperty(system_property_name_, kUndefinedValue);\n  if (sysprop != kUndefinedValue) {\n    ParseValue(sysprop, &from_system_property_);\n  }\n\n  // Load the server-side configuration.\n  from_server_setting_ = std::nullopt;\n  const std::string server_config =\n      ::android::base::GetProperty(server_setting_name_, kUndefinedValue);\n  if (server_config != kUndefinedValue) {\n    ParseValue(server_config, &from_server_setting_);\n  }\n\n  initialized_ = true;\n}\n\ntemplate <typename Value>\nvoid DumpValue(std::ostream& oss, const std::optional<Value>& val) {\n  if (val.has_value()) {\n    oss << val.value();\n  } else {\n    oss << kUndefinedValue;\n  }\n}\n\ntemplate <typename Value>\nvoid Flag<Value>::Dump(std::ostream& oss) const {\n  std::pair<Value, std::string> valueLoc = GetValueLocation();\n  oss << \"value: \" << std::get<0>(valueLoc) << \" (from \" << std::get<1>(valueLoc) << \")\";\n\n  oss << \"\\n default: \" << default_;\n  oss << \"\\n \" << command_line_argument_name_ << \": \";\n  DumpValue(oss, from_command_line_);\n  oss << \"\\n \" << system_property_name_ << \": \";\n  DumpValue(oss, from_system_property_);\n  oss << \"\\n \" << server_setting_name_ << \": \";\n  DumpValue(oss, from_server_setting_);\n}\n\ntemplate class Flag<bool>;\ntemplate class Flag<int>;\ntemplate class Flag<std::string>;\n\n}  // namespace art\n\n#pragma clang diagnostic pop  // -Wconversion",
        "base_contents": "",
        "res_region": "/*\n * Copyright (C) 2021 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"flags.h\"\n\n#include <algorithm>\n\n#include \"android-base/parsebool.h\"\n#include \"android-base/parseint.h\"\n#include \"android-base/properties.h\"\n\n#include \"base/utils.h\"\n\n#pragma clang diagnostic push\n#pragma clang diagnostic error \"-Wconversion\"\n\nnamespace {\nconstexpr const char* kPhenotypeFlagPrefix = \"persist.device_config.runtime_native.\";\nconstexpr const char* kSysPropertyFlagPrefix = \"dalvik.vm.\";\nconstexpr const char* kUndefinedValue = \"\";\n\n// The various ParseValue functions store the parsed value into *destination. If parsing fails for\n// some reason, ParseValue makes no changes to *destination.\n\nvoid ParseValue(const std::string_view value, std::optional<bool>* destination) {\n  switch (::android::base::ParseBool(value)) {\n    case ::android::base::ParseBoolResult::kError:\n      return;\n    case ::android::base::ParseBoolResult::kTrue:\n      *destination = true;\n      return;\n    case ::android::base::ParseBoolResult::kFalse:\n      *destination = false;\n      return;\n  }\n}\n\nvoid ParseValue(const std::string_view value, std::optional<int>* destination) {\n  int parsed_value = 0;\n  if (::android::base::ParseInt(std::string{value}, &parsed_value)) {\n    *destination = parsed_value;\n  }\n}\n\nvoid ParseValue(const std::string_view value, std::optional<std::string>* destination) {\n  *destination = value;\n}\n\n}  // namespace\n\nnamespace art {\n\ntemplate <>\nstd::forward_list<FlagBase*> FlagBase::ALL_FLAGS{};\n\n// gFlags must be defined after FlagBase::ALL_FLAGS so the constructors run in the right order.\nFlags gFlags;\n\nstatic std::string GenerateCmdLineArgName(const std::string& name) {\n  std::string result = \"-X\" + name + \":_\";\n  std::replace(result.begin(), result.end(), '.', '-');\n  return result;\n}\n\nstatic std::string GenerateSysPropName(const std::string& name) {\n  return kSysPropertyFlagPrefix + name;\n}\n\nstatic std::string GeneratePhenotypeName(const std::string& name) {\n  return kPhenotypeFlagPrefix + name;\n}\n\ntemplate <typename Value>\nFlag<Value>::Flag(const std::string& name, Value default_value) :\n    FlagBase(GenerateCmdLineArgName(name),\n             GenerateSysPropName(name),\n             GeneratePhenotypeName(name)),\n    initialized_{false},\n    default_{default_value} {\n  ALL_FLAGS.push_front(this);\n}\n\ntemplate <typename Value>\nFlag<Value>::~Flag() {\n  ALL_FLAGS.remove(this);\n}\n\ntemplate <typename Value>\nvoid Flag<Value>::Reload() {\n  // The cmdline flags are loaded by the parsed_options infra.\n\n  // Load system properties.\n  from_system_property_ = std::nullopt;\n  const std::string sysprop = ::android::base::GetProperty(system_property_name_, kUndefinedValue);\n  if (sysprop != kUndefinedValue) {\n    ParseValue(sysprop, &from_system_property_);\n  }\n\n  // Load the server-side configuration.\n  from_server_setting_ = std::nullopt;\n  const std::string server_config =\n      ::android::base::GetProperty(server_setting_name_, kUndefinedValue);\n  if (server_config != kUndefinedValue) {\n    ParseValue(server_config, &from_server_setting_);\n  }\n\n  initialized_ = true;\n}\n\ntemplate <typename Value>\nvoid DumpValue(std::ostream& oss, const std::optional<Value>& val) {\n  if (val.has_value()) {\n    oss << val.value();\n  } else {\n    oss << kUndefinedValue;\n  }\n}\n\ntemplate <typename Value>\nvoid Flag<Value>::Dump(std::ostream& oss) const {\n  std::pair<Value, std::string> valueLoc = GetValueLocation();\n  oss << \"value: \" << std::get<0>(valueLoc) << \" (from \" << std::get<1>(valueLoc) << \")\";\n\n  oss << \"\\n default: \" << default_;\n  oss << \"\\n \" << command_line_argument_name_ << \": \";\n  DumpValue(oss, from_command_line_);\n  oss << \"\\n \" << system_property_name_ << \": \";\n  DumpValue(oss, from_system_property_);\n  oss << \"\\n \" << server_setting_name_ << \": \";\n  DumpValue(oss, from_server_setting_);\n}\n\ntemplate class Flag<bool>;\ntemplate class Flag<int>;\ntemplate class Flag<std::string>;\n\n}  // namespace art\n\n#pragma clang diagnostic pop  // -Wconversion",
        "lookback": " * Copyright (C) 2021 The Android Open Source Project",
        "lookahead": "",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 0,
        "end_line": 302,
        "merge_gen_region": " CopyrightC 2 The Open Project * Licensed the Apache, 2. ( \"Content * may use file in with License * may a of License * may a of License * *://..///LICENSE20 * Unless by law agreed in, * under License distributed anAS\" BASIS * WITHOUT OR OF KIND either or. See License the specific governing and limitations the License */includeflagsh # <>includeandroidbase/boolh # \"androidbaseparse.h # \"androidbaseparse.h # \"androidbasepropertiesh # \"baseutilsh # clang pushpragma diagnostic #W\" # clang errorW\" { constexpr char kheypePrefix \"persistdeviceconfigruntimenative constexpr char kPropertyPrefix \"alkvm constexpr char kValue \"\"; The variousValue store parsed intodestination If fails // some,Value makes changes *.destination voidValueconst::_view,::<>*) switchandroidbaseParse()) caseandroidbaseParseResultk:; ::::baseParseResultk:destination true return caseandroidbaseParseResultk: * =;; ::::baseParseResultk: * =;; } voidValueconst::_view,::<>*) {destination value } // namespace art template stdforwardlistFlag*> Flag",
        "confidence": 0.9016820788383484,
        "hesitated": false,
        "resolved": false
    }
]