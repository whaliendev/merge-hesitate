[
    {
        "a_contents": "\nstruct pid_workspace {\n\tpid_t pid;\n\tchar *workspace;\n\tstruct timespec time_added;\n\n\tstruct sway_container *output;\n\tstruct wl_listener output_destroy;\n\n\tstruct wl_list link;\n};\n\nstatic struct wl_list pid_workspaces;\n\nstruct sway_container *workspace_for_pid(pid_t pid) {\n\tif (!pid_workspaces.prev && !pid_workspaces.next) {\n\t\twl_list_init(&pid_workspaces);\n\t\treturn NULL;\n\t}\n\n\tstruct sway_container *ws = NULL;\n\tstruct pid_workspace *pw = NULL;\n\n\twlr_log(L_DEBUG, \"Looking up workspace for pid %d\", pid);\n\n\tdo {\n\t\tstruct pid_workspace *_pw = NULL;\n\t\twl_list_for_each(_pw, &pid_workspaces, link) {\n\t\t\tif (pid == _pw->pid) {\n\t\t\t\tpw = _pw;\n\t\t\t\twlr_log(L_DEBUG,\n\t\t\t\t\t\t\"found pid_workspace for pid %d, workspace %s\",\n\t\t\t\t\t\tpid, pw->workspace);\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t\tpid = get_parent_pid(pid);\n\t} while (pid > 1);\nfound:\n\n\tif (pw && pw->workspace) {\n\t\tws = workspace_by_name(pw->workspace);\n\n\t\tif (!ws) {\n\t\t\twlr_log(L_DEBUG,\n\t\t\t\t\t\"Creating workspace %s for pid %d because it disappeared\",\n\t\t\t\t\tpw->workspace, pid);\n\t\t\tws = workspace_create(pw->output, pw->workspace);\n\t\t}\n\n\t\twl_list_remove(&pw->output_destroy.link);\n\t\twl_list_remove(&pw->link);\n\t\tfree(pw->workspace);\n\t\tfree(pw);\n\t}\n\n\treturn ws;\n}\n\nstatic void pw_handle_output_destroy(struct wl_listener *listener, void *data) {\n\tstruct pid_workspace *pw = wl_container_of(listener, pw, output_destroy);\n\tpw->output = NULL;\n}\n\nvoid workspace_record_pid(pid_t pid) {\n\twlr_log(L_DEBUG, \"Recording workspace for process %d\", pid);\n\tif (!pid_workspaces.prev && !pid_workspaces.next) {\n\t\twl_list_init(&pid_workspaces);\n\t}\n\n\tstruct sway_seat *seat = input_manager_current_seat(input_manager);\n\tstruct sway_container *ws =\n\t\tseat_get_focus_inactive(seat, &root_container);\n\tif (ws && ws->type != C_WORKSPACE) {\n\t\tws = container_parent(ws, C_WORKSPACE);\n\t}\n\tif (!ws) {\n\t\twlr_log(L_DEBUG, \"Bailing out, no workspace\");\n\t\treturn;\n\t}\n\tstruct sway_container *output = ws->parent;\n\tif (!output) {\n\t\twlr_log(L_DEBUG, \"Bailing out, no output\");\n\t\treturn;\n\t}\n\n\tstruct timespec now;\n\tclock_gettime(CLOCK_MONOTONIC, &now);\n\n\t// Remove expired entries\n\tstatic const int timeout = 60;\n\tstruct pid_workspace *old, *_old;\n\twl_list_for_each_safe(old, _old, &pid_workspaces, link) {\n\t\tif (now.tv_sec - old->time_added.tv_sec >= timeout) {\n\t\t\twl_list_remove(&old->output_destroy.link);\n\t\t\twl_list_remove(&old->link);\n\t\t\tfree(old->workspace);\n\t\t\tfree(old);\n\t\t}\n\t}\n\n\tstruct pid_workspace *pw = calloc(1, sizeof(struct pid_workspace));\n\tpw->workspace = strdup(ws->name);\n\tpw->output = output;\n\tpw->pid = pid;\n\tmemcpy(&pw->time_added, &now, sizeof(struct timespec));\n\tpw->output_destroy.notify = pw_handle_output_destroy;\n\twl_signal_add(&output->sway_output->wlr_output->events.destroy,\n\t\t\t&pw->output_destroy);\n\twl_list_insert(&pid_workspaces, &pw->link);\n}",
        "b_contents": "\nvoid workspace_detect_urgent(struct sway_container *workspace) {\n\tbool new_urgent = container_has_urgent_child(workspace);\n\n\tif (workspace->sway_workspace->urgent != new_urgent) {\n\t\tworkspace->sway_workspace->urgent = new_urgent;\n\t\tipc_event_workspace(NULL, workspace, \"urgent\");\n\t\tcontainer_damage_whole(workspace);\n\t}\n}",
        "base_contents": "",
        "res_region": "\nvoid workspace_detect_urgent(struct sway_container *workspace) {\n\tbool new_urgent = container_has_urgent_child(workspace);\n\n\tif (workspace->sway_workspace->urgent != new_urgent) {\n\t\tworkspace->sway_workspace->urgent = new_urgent;\n\t\tipc_event_workspace(NULL, workspace, \"urgent\");\n\t\tcontainer_damage_whole(workspace);\n\t}\n}\n\nstruct pid_workspace {\n\tpid_t pid;\n\tchar *workspace;\n\tstruct timespec time_added;\n\n\tstruct sway_container *output;\n\tstruct wl_listener output_destroy;\n\n\tstruct wl_list link;\n};\n\nstatic struct wl_list pid_workspaces;\n\nstruct sway_container *workspace_for_pid(pid_t pid) {\n\tif (!pid_workspaces.prev && !pid_workspaces.next) {\n\t\twl_list_init(&pid_workspaces);\n\t\treturn NULL;\n\t}\n\n\tstruct sway_container *ws = NULL;\n\tstruct pid_workspace *pw = NULL;\n\n\twlr_log(WLR_DEBUG, \"Looking up workspace for pid %d\", pid);\n\n\tdo {\n\t\tstruct pid_workspace *_pw = NULL;\n\t\twl_list_for_each(_pw, &pid_workspaces, link) {\n\t\t\tif (pid == _pw->pid) {\n\t\t\t\tpw = _pw;\n\t\t\t\twlr_log(WLR_DEBUG,\n\t\t\t\t\t\t\"found pid_workspace for pid %d, workspace %s\",\n\t\t\t\t\t\tpid, pw->workspace);\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t\tpid = get_parent_pid(pid);\n\t} while (pid > 1);\nfound:\n\n\tif (pw && pw->workspace) {\n\t\tws = workspace_by_name(pw->workspace);\n\n\t\tif (!ws) {\n\t\t\twlr_log(WLR_DEBUG,\n\t\t\t\t\t\"Creating workspace %s for pid %d because it disappeared\",\n\t\t\t\t\tpw->workspace, pid);\n\t\t\tws = workspace_create(pw->output, pw->workspace);\n\t\t}\n\n\t\twl_list_remove(&pw->output_destroy.link);\n\t\twl_list_remove(&pw->link);\n\t\tfree(pw->workspace);\n\t\tfree(pw);\n\t}\n\n\treturn ws;\n}\n\nstatic void pw_handle_output_destroy(struct wl_listener *listener, void *data) {\n\tstruct pid_workspace *pw = wl_container_of(listener, pw, output_destroy);\n\tpw->output = NULL;\n}\n\nvoid workspace_record_pid(pid_t pid) {\n\twlr_log(WLR_DEBUG, \"Recording workspace for process %d\", pid);\n\tif (!pid_workspaces.prev && !pid_workspaces.next) {\n\t\twl_list_init(&pid_workspaces);\n\t}\n\n\tstruct sway_seat *seat = input_manager_current_seat(input_manager);\n\tstruct sway_container *ws =\n\t\tseat_get_focus_inactive(seat, &root_container);\n\tif (ws && ws->type != C_WORKSPACE) {\n\t\tws = container_parent(ws, C_WORKSPACE);\n\t}\n\tif (!ws) {\n\t\twlr_log(WLR_DEBUG, \"Bailing out, no workspace\");\n\t\treturn;\n\t}\n\tstruct sway_container *output = ws->parent;\n\tif (!output) {\n\t\twlr_log(WLR_DEBUG, \"Bailing out, no output\");\n\t\treturn;\n\t}\n\n\tstruct timespec now;\n\tclock_gettime(CLOCK_MONOTONIC, &now);\n\n\t// Remove expired entries\n\tstatic const int timeout = 60;\n\tstruct pid_workspace *old, *_old;\n\twl_list_for_each_safe(old, _old, &pid_workspaces, link) {\n\t\tif (now.tv_sec - old->time_added.tv_sec >= timeout) {\n\t\t\twl_list_remove(&old->output_destroy.link);\n\t\t\twl_list_remove(&old->link);\n\t\t\tfree(old->workspace);\n\t\t\tfree(old);\n\t\t}\n\t}\n\n\tstruct pid_workspace *pw = calloc(1, sizeof(struct pid_workspace));\n\tpw->workspace = strdup(ws->name);\n\tpw->output = output;\n\tpw->pid = pid;\n\tmemcpy(&pw->time_added, &now, sizeof(struct timespec));\n\tpw->output_destroy.notify = pw_handle_output_destroy;\n\twl_signal_add(&output->sway_output->wlr_output->events.destroy,\n\t\t\t&pw->output_destroy);\n\twl_list_insert(&pid_workspaces, &pw->link);\n}",
        "lookback": "void workspace_detect_urgent(struct sway_container *workspace) {",
        "lookahead": "",
        "label": [
            "newcode",
            "one_side_deletion"
        ],
        "start_line": 522,
        "end_line": 646,
        "merge_gen_region": null,
        "confidence": 0.8592514991760254,
        "hesitated": true
    }
]