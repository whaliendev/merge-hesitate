[
    {
        "a_contents": "const char *argv0 = 0;\nvoid RecordMyLocation( const char *_argv0 ) { argv0 = _argv0; }\n\n#if !defined(_WIN32)\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n\nmap< int, pid_t > dbs;\n\nchar *copyString( const char *original ) {\n    char *ret = reinterpret_cast< char * >( malloc( strlen( original ) + 1 ) );\n    strcpy( ret, original );\n    return ret;\n}\n\nv8::Handle< v8::Value > StartMongod( const v8::Arguments &a ) {\n    assert( argv0 );\n    boost::filesystem::path mongod = ( boost::filesystem::path( argv0 ) ).branch_path() / \"mongod\";\n    assert( boost::filesystem::exists( mongod ) );\n    \n    int port = -1;\n    char * argv[ a.Length() + 2 ];\n    argv[ 0 ] = copyString( mongod.native_file_string().c_str() );\n    for( int i = 0; i < a.Length(); ++i ) {\n        v8::String::Utf8Value str( a[ i ] );\n        char *s = copyString( *str );\n        if ( string( \"--port\" ) == s )\n            port = -2;\n        else if ( port == -2 )\n            port = strtol( s, 0, 10 );\n        argv[ 1 + i ] = s;\n    }\n    argv[ a.Length() + 1 ] = 0;\n    \n    assert( port > 0 );\n    assert( dbs.count( port ) == 0 );\n\n    fflush( 0 );\n    pid_t pid = fork();\n    assert( pid != -1 );\n    \n    if ( pid == 0 ) {\n        stringstream ss;\n        ss << \"mongod.\" << port << \".log\";\n        string name = ss.str();\n        int d = open( name.c_str(), O_WRONLY | O_APPEND | O_CREAT );\n        assert( d != -1 );\n        assert( fchmod( d, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP ) == 0 );\n        const char *bar = \"\\n\\n--- NEW INSTANCE ---\\n\\n\";\n        write( d, bar, strlen( bar ) );\n        assert( dup2( d, STDOUT_FILENO ) != -1 );\n        assert( dup2( d, STDERR_FILENO ) != -1 );\n        execvp( argv[ 0 ], argv );\n        assert( false );\n    }\n\n    int i = 0;\n    while( argv[ i ] )\n        free( argv[ i++ ] );\n    \n    dbs.insert( make_pair( port, pid ) );\n    return v8::Undefined();\n}\n\nv8::Handle< v8::Value > ResetDbpath( const v8::Arguments &a ) {\n    assert( a.Length() == 1 );\n    v8::String::Utf8Value path( a[ 0 ] );\n    if ( boost::filesystem::exists( *path ) )\n        boost::filesystem::remove_all( *path );\n    boost::filesystem::create_directory( *path );    \n    return v8::Undefined();\n}\n\nvoid killDb( int port ) {\n    assert( dbs.count( port ) == 1 );\n    pid_t pid = dbs[ port ];\n    kill( pid, SIGTERM );\n    int temp;\n    waitpid( pid, &temp, 0 );\n    dbs.erase( port );\n}\n\nv8::Handle< v8::Value > StopMongod( const v8::Arguments &a ) {\n    assert( a.Length() == 1 );\n    assert( a[ 0 ]->IsInt32() );\n    int port = a[ 0 ]->ToInt32()->Value();\n    killDb( port );\n    return v8::Undefined();\n}\n\nMongodScope::~MongodScope() {\n    try {\n        for( map< int, pid_t >::iterator i = dbs.begin(); i != dbs.end(); ++i )\n            killDb( i->first );\n    } catch ( ... ) {\n        assert( false );\n    }\n}\n\n#else\nMongodScope::~MongodScope() {}\n#endif\n\nvoid installShellUtils( v8::Handle<v8::ObjectTemplate>& global ){",
        "b_contents": "void installShellUtils( Handle<v8::ObjectTemplate>& global ){",
        "base_contents": "void installShellUtils( v8::Handle<v8::ObjectTemplate>& global ){",
        "res_region": "const char *argv0 = 0;\nvoid RecordMyLocation( const char *_argv0 ) { argv0 = _argv0; }\n\n#if !defined(_WIN32)\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n\nmap< int, pid_t > dbs;\n\nchar *copyString( const char *original ) {\n    char *ret = reinterpret_cast< char * >( malloc( strlen( original ) + 1 ) );\n    strcpy( ret, original );\n    return ret;\n}\n\nv8::Handle< v8::Value > StartMongod( const v8::Arguments &a ) {\n    assert( argv0 );\n    boost::filesystem::path mongod = ( boost::filesystem::path( argv0 ) ).branch_path() / \"mongod\";\n    assert( boost::filesystem::exists( mongod ) );\n    \n    int port = -1;\n    char * argv[ a.Length() + 2 ];\n    argv[ 0 ] = copyString( mongod.native_file_string().c_str() );\n    for( int i = 0; i < a.Length(); ++i ) {\n        v8::String::Utf8Value str( a[ i ] );\n        char *s = copyString( *str );\n        if ( string( \"--port\" ) == s )\n            port = -2;\n        else if ( port == -2 )\n            port = strtol( s, 0, 10 );\n        argv[ 1 + i ] = s;\n    }\n    argv[ a.Length() + 1 ] = 0;\n    \n    assert( port > 0 );\n    assert( dbs.count( port ) == 0 );\n\n    fflush( 0 );\n    pid_t pid = fork();\n    assert( pid != -1 );\n    \n    if ( pid == 0 ) {\n        stringstream ss;\n        ss << \"mongod.\" << port << \".log\";\n        string name = ss.str();\n        int d = open( name.c_str(), O_WRONLY | O_APPEND | O_CREAT );\n        assert( d != -1 );\n        assert( fchmod( d, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP ) == 0 );\n        const char *bar = \"\\n\\n--- NEW INSTANCE ---\\n\\n\";\n        write( d, bar, strlen( bar ) );\n        assert( dup2( d, STDOUT_FILENO ) != -1 );\n        assert( dup2( d, STDERR_FILENO ) != -1 );\n        execvp( argv[ 0 ], argv );\n        assert( false );\n    }\n\n    int i = 0;\n    while( argv[ i ] )\n        free( argv[ i++ ] );\n    \n    dbs.insert( make_pair( port, pid ) );\n    return v8::Undefined();\n}\n\nv8::Handle< v8::Value > ResetDbpath( const v8::Arguments &a ) {\n    assert( a.Length() == 1 );\n    v8::String::Utf8Value path( a[ 0 ] );\n    if ( boost::filesystem::exists( *path ) )\n        boost::filesystem::remove_all( *path );\n    boost::filesystem::create_directory( *path );    \n    return v8::Undefined();\n}\n\nvoid killDb( int port ) {\n    assert( dbs.count( port ) == 1 );\n    pid_t pid = dbs[ port ];\n    kill( pid, SIGTERM );\n    int temp;\n    waitpid( pid, &temp, 0 );\n    dbs.erase( port );\n}\n\nv8::Handle< v8::Value > StopMongod( const v8::Arguments &a ) {\n    assert( a.Length() == 1 );\n    assert( a[ 0 ]->IsInt32() );\n    int port = a[ 0 ]->ToInt32()->Value();\n    killDb( port );\n    return v8::Undefined();\n}\n\nMongodScope::~MongodScope() {\n    try {\n        for( map< int, pid_t >::iterator i = dbs.begin(); i != dbs.end(); ++i )\n            killDb( i->first );\n    } catch ( ... ) {\n        assert( false );\n    }\n}\n\n#else\nMongodScope::~MongodScope() {}\n#endif\n\nvoid installShellUtils( Handle<v8::ObjectTemplate>& global ){",
        "lookback": "void RecordMyLocation( const char *_argv0 ) { argv0 = _argv0; }",
        "lookahead": "    global->Set(v8::String::New(\"sleep\"), v8::FunctionTemplate::New(JSSleep));",
        "label": [
            "interleave",
            "complex_conflict"
        ],
        "start_line": 223,
        "end_line": 333,
        "merge_gen_region": " RecordLocation const *_0 {0 _0;const *0 =; RecordMy( charargv0 {0 _0 0 voidMy( charargv const *_0 {0 _0; # !(_32 # <.>includefcntlh # </.>includesysstath map int pidt dbs charcopy( charoriginal { * = reinterpretcast char >(((( ) 1 );(, ); return; v::<8:: >Mod const8Argumentsa {(0 boostfilesystempath mod (::::::(0 )._() \"ong\";(::::::::(ong ) int port -; *[.() 2 argv 0 =String modnativefilestringcstr );((2.() for int =; <.Length ++ ) {8StringUtfValue str a a i ); ] chars copy(str if (( );__ pid fork assert pid - ); if pid 0 ) string \"--\" ) s ) =set -; if port - - ) =(,,, ); argv 1 i =; argv aLength + ] 0;( string ss ss <<mod << <<log string name ssstr(); d open namecstr OWRONLY OAPPEND OCREAT assert d",
        "confidence": 0.9458460211753845,
        "hesitated": false,
        "resolved": false
    }
]