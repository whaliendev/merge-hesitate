[
    {
        "a_contents": "\tbool isMaster(bool& isMaster, BSONObj *info=0);\n\n    /*\n\t   Create a new collection in the database.  Normally, collection creation is automatic.  You would\n\t   use this function if you wish to specify special options on creation.\n\n\t   If the collection already exists, no action occurs.\n\n\t   ns:     fully qualified collection name   \n \t   size:   desired initial extent size for the collection.  \n\t           Must be <= 1000000000 for normal collections.\n\t\t\t   For fixed size (capped) collections, this size is the total/max size of the \n\t\t\t   collection.\n\t   capped: if true, this is a fixed size collection (where old data rolls out).\n\t   max:    maximum number of objects if capped (optional).\n\n\t   returns true if successful.\n\t*/\n\tbool createCollection(const char *ns, unsigned size = 0, bool capped = false, int max = 0, BSONObj *info = 0);\n\n\t/* Erase / drop an entire database */\n\tbool dropDatabase(const char *dbname, BSONObj *info = 0) { return simpleCommand(dbname, info, \"dropDatabase\"); }\n\n\t/* Perform a repair and compaction of the specified database.  May take a long time to run.  Disk space \n\t   must be available equal to the size of the database while repairing. \n\t*/\n\tbool repairDatabase(const char *dbname, BSONObj *info = 0) { return simpleCommand(dbname, info, \"repairDatabase\"); }\n\n\t/* Copy database from one server or name to another server or name.\n\n\t   Generally, you should dropDatabase() first as otherwise the copied information will MERGE \n\t   into whatever data is already present in this database.\n\n\t   For security reasons this function only works when you are authorized to access the \"admin\" db.  However, \n\t   if you have access to said db, you can copy any database from one place to another.  \n\t   TODO: this needs enhancement to be more flexible in terms of security.\n\n\t   This method provides a way to \"rename\" a database by copying it to a new db name and \n\t   location.  The copy is \"repaired\" and compacted.\n\n\t   fromdb   database name from which to copy.\n\t   todb     database name to copy to.\n\t   fromhost hostname of the database (and optionally, \":port\") from which to \n\t            copy the data.  copies from self if \"\".\n\n\t   returns true if successful\n    */\n\tbool copyDatabase(const char *fromdb, const char *todb, const char *fromhost = \"\", BSONObj *info = 0);\n\n\t/* The Mongo database provides built-in performance profiling capabilities.  Uset setDbProfilingLevel() \n\t   to enable.  Profiling information is then written to the system.profiling collection, which one can \n\t   then query. \n\t*/\n\tenum ProfilingLevel { \n\t\tProfileOff = 0, \n\t\tProfileSlow = 1, // log very slow (>100ms) operations\n\t\tProfileAll = 2\n\t};\n\tbool setDbProfilingLevel(const char *dbname, ProfilingLevel level, BSONObj *info = 0);\n\tbool getDbProfilingLevel(const char *dbname, ProfilingLevel& level, BSONObj *info = 0);\n\n\t/* Run javascript code on the database server.\n\t   dbname    database context in which the code runs. The javascript variable 'db' will be assigned \n\t             to this database when the function is invoked.\n\t   jscode    source code for a javascript function.\n\t   info      the command object which contains any information on the invocation result including \n \t             the return value and other information.  If an error occurs running the jscode, error \n\t\t\t\t information will be in info.  (try \"cout << info.toString()\")\n       retValue  return value from the jscode function. \n       args      args to pass to the jscode function.  when invoked, the 'args' variable will be defined \n\t             for use by the jscode.\n\n\t   returns true if runs ok.\n\n\t   See testDbEval() in dbclient.cpp for an example of usage.\n\t*/\n\tbool eval(const char *dbname, const char *jscode, BSONObj& info, BSONElement& retValue, BSONObj *args = 0);\n\n\t/* The following helpers are simply more convenient forms of eval() for certain common cases */\n\t\n\t/* invocation with no return value of interest -- with or without one simple parameter */\n\tbool eval(const char *dbname, const char *jscode);\n\ttemplate< class T >\n\tbool eval(const char *dbname, const char *jscode, T parm1) {\n\t\tBSONObj info;\n\t\tBSONElement retValue;\n\t\tBSONObjBuilder b;\n\t\tb.append(\"0\", parm1);\n\t\tBSONObj args = b.done();\n\t\treturn eval(dbname, jscode, info, retValue, &args);\n\t}\n\n\t/* invocation with one parm to server and one numeric field (either int or double) returned */\n\ttemplate< class T, class NumType >\n\tbool eval(const char *dbname, const char *jscode, T parm1, NumType& ret) {\n\t\tBSONObj info;\n\t\tBSONElement retValue;\n\t\tBSONObjBuilder b;\n\t\tb.append(\"0\", parm1);\n\t\tBSONObj args = b.done();\n\t\tif( !eval(dbname, jscode, info, retValue, &args) ) \n\t\t\treturn false;\n\t\tret = (NumType) retValue.number();\n\t\treturn true;\n\t}\n",
        "b_contents": "    virtual\n    BSONObj cmdIsMaster(bool& isMaster);\n\n    virtual string toString() = 0; \n};\n\nclass DBClientBase : public DBClientWithCommands, public DBConnector {\npublic:\n    /* send a query to the database.\n     ns:            namespace to query, format is <dbname>.<collectname>[.<collectname>]*\n     query:         query to perform on the collection.  this is a BSONObj (binary JSON)\n     You may format as\n     { query: { ... }, order: { ... } }\n     to specify a sort order.\n     nToReturn:     n to return.  0 = unlimited\n     nToSkip:       start with the nth item\n     fieldsToReturn:\n     optional template of which fields to select. if unspecified, returns all fields\n     queryOptions:  see options enum at top of this file\n     \n     returns:       cursor.\n     0 if error (connection failure)\n     */\n    /*throws AssertionException*/\n    virtual\n    auto_ptr<DBClientCursor> query(const char *ns, BSONObj query, int nToReturn = 0, int nToSkip = 0,\n                                   BSONObj *fieldsToReturn = 0, int queryOptions = 0);\n\n    /*throws AssertionException*/\n    virtual\n    BSONObj findOne(const char *ns, BSONObj query, BSONObj *fieldsToReturn = 0, int queryOptions = 0);\n    \n    virtual void insert( const char * ns , BSONObj obj );",
        "base_contents": "    virtual\n    BSONObj cmdIsMaster(bool& isMaster);",
        "res_region": "\tbool isMaster(bool& isMaster, BSONObj *info=0);\n\n    /*\n\t   Create a new collection in the database.  Normally, collection creation is automatic.  You would\n\t   use this function if you wish to specify special options on creation.\n\n\t   If the collection already exists, no action occurs.\n\n\t   ns:     fully qualified collection name   \n \t   size:   desired initial extent size for the collection.  \n\t           Must be <= 1000000000 for normal collections.\n\t\t\t   For fixed size (capped) collections, this size is the total/max size of the \n\t\t\t   collection.\n\t   capped: if true, this is a fixed size collection (where old data rolls out).\n\t   max:    maximum number of objects if capped (optional).\n\n\t   returns true if successful.\n\t*/\n\tbool createCollection(const char *ns, unsigned size = 0, bool capped = false, int max = 0, BSONObj *info = 0);\n\n\t/* Erase / drop an entire database */\n\tbool dropDatabase(const char *dbname, BSONObj *info = 0) { return simpleCommand(dbname, info, \"dropDatabase\"); }\n\n\t/* Perform a repair and compaction of the specified database.  May take a long time to run.  Disk space \n\t   must be available equal to the size of the database while repairing. \n\t*/\n\tbool repairDatabase(const char *dbname, BSONObj *info = 0) { return simpleCommand(dbname, info, \"repairDatabase\"); }\n\n\t/* Copy database from one server or name to another server or name.\n\n\t   Generally, you should dropDatabase() first as otherwise the copied information will MERGE \n\t   into whatever data is already present in this database.\n\n\t   For security reasons this function only works when you are authorized to access the \"admin\" db.  However, \n\t   if you have access to said db, you can copy any database from one place to another.  \n\t   TODO: this needs enhancement to be more flexible in terms of security.\n\n\t   This method provides a way to \"rename\" a database by copying it to a new db name and \n\t   location.  The copy is \"repaired\" and compacted.\n\n\t   fromdb   database name from which to copy.\n\t   todb     database name to copy to.\n\t   fromhost hostname of the database (and optionally, \":port\") from which to \n\t            copy the data.  copies from self if \"\".\n\n\t   returns true if successful\n    */\n\tbool copyDatabase(const char *fromdb, const char *todb, const char *fromhost = \"\", BSONObj *info = 0);\n\n\t/* The Mongo database provides built-in performance profiling capabilities.  Uset setDbProfilingLevel() \n\t   to enable.  Profiling information is then written to the system.profiling collection, which one can \n\t   then query. \n\t*/\n\tenum ProfilingLevel { \n\t\tProfileOff = 0, \n\t\tProfileSlow = 1, // log very slow (>100ms) operations\n\t\tProfileAll = 2\n\t};\n\tbool setDbProfilingLevel(const char *dbname, ProfilingLevel level, BSONObj *info = 0);\n\tbool getDbProfilingLevel(const char *dbname, ProfilingLevel& level, BSONObj *info = 0);\n\n\t/* Run javascript code on the database server.\n\t   dbname    database context in which the code runs. The javascript variable 'db' will be assigned \n\t             to this database when the function is invoked.\n\t   jscode    source code for a javascript function.\n\t   info      the command object which contains any information on the invocation result including \n \t             the return value and other information.  If an error occurs running the jscode, error \n\t\t\t\t information will be in info.  (try \"cout << info.toString()\")\n       retValue  return value from the jscode function. \n       args      args to pass to the jscode function.  when invoked, the 'args' variable will be defined \n\t             for use by the jscode.\n\n\t   returns true if runs ok.\n\n\t   See testDbEval() in dbclient.cpp for an example of usage.\n\t*/\n\tbool eval(const char *dbname, const char *jscode, BSONObj& info, BSONElement& retValue, BSONObj *args = 0);\n\n\t/* The following helpers are simply more convenient forms of eval() for certain common cases */\n\t\n\t/* invocation with no return value of interest -- with or without one simple parameter */\n\tbool eval(const char *dbname, const char *jscode);\n\ttemplate< class T >\n\tbool eval(const char *dbname, const char *jscode, T parm1) {\n\t\tBSONObj info;\n\t\tBSONElement retValue;\n\t\tBSONObjBuilder b;\n\t\tb.append(\"0\", parm1);\n\t\tBSONObj args = b.done();\n\t\treturn eval(dbname, jscode, info, retValue, &args);\n\t}\n\n\t/* invocation with one parm to server and one numeric field (either int or double) returned */\n\ttemplate< class T, class NumType >\n\tbool eval(const char *dbname, const char *jscode, T parm1, NumType& ret) {\n\t\tBSONObj info;\n\t\tBSONElement retValue;\n\t\tBSONObjBuilder b;\n\t\tb.append(\"0\", parm1);\n\t\tBSONObj args = b.done();\n\t\tif( !eval(dbname, jscode, info, retValue, &args) ) \n\t\t\treturn false;\n\t\tret = (NumType) retValue.number();\n\t\treturn true;\n\t}\n\n    virtual string toString() = 0; \n};\n\nclass DBClientBase : public DBClientWithCommands, public DBConnector {\npublic:\n    /* send a query to the database.\n     ns:            namespace to query, format is <dbname>.<collectname>[.<collectname>]*\n     query:         query to perform on the collection.  this is a BSONObj (binary JSON)\n     You may format as\n     { query: { ... }, order: { ... } }\n     to specify a sort order.\n     nToReturn:     n to return.  0 = unlimited\n     nToSkip:       start with the nth item\n     fieldsToReturn:\n     optional template of which fields to select. if unspecified, returns all fields\n     queryOptions:  see options enum at top of this file\n     \n     returns:       cursor.\n     0 if error (connection failure)\n     */\n    /*throws AssertionException*/\n    virtual\n    auto_ptr<DBClientCursor> query(const char *ns, BSONObj query, int nToReturn = 0, int nToSkip = 0,\n                                   BSONObj *fieldsToReturn = 0, int queryOptions = 0);\n\n    /*throws AssertionException*/\n    virtual\n    BSONObj findOne(const char *ns, BSONObj query, BSONObj *fieldsToReturn = 0, int queryOptions = 0);\n    \n    virtual void insert( const char * ns , BSONObj obj );",
        "lookback": "",
        "lookahead": "};",
        "label": [
            "interleave",
            "complex_conflict"
        ],
        "start_line": 186,
        "end_line": 330,
        "merge_gen_region": null,
        "confidence": 0.8218923211097717,
        "hesitated": true
    }
]