[
    {
        "a_contents": "",
        "b_contents": "#include \"mongo/db/field_ref.h\"\n#include \"mongo/db/fts/fts_iterator.h\"",
        "base_contents": "#include \"mongo/db/field_ref.h\"",
        "res_region": "",
        "lookback": "",
        "lookahead": "#include \"mongo/db/fts/fts_spec.h\"",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 31,
        "end_line": 37,
        "merge_gen_region": null,
        "confidence": 0.5027875304222107,
        "hesitated": true
    },
    {
        "a_contents": "        const FTSLanguage& FTSSpec::_getLanguageToUseV2( const BSONObj& userDoc,\n                                                         const FTSLanguage& currentLanguage ) const {",
        "b_contents": "        FTSLanguage FTSSpec::getLanguageToUse( const BSONObj& userDoc,\n                                               const FTSLanguage currentLanguage ) const {\n",
        "base_contents": "        const FTSLanguage FTSSpec::getLanguageToUse( const BSONObj& userDoc,\n                                                     const FTSLanguage currentLanguage ) const {",
        "res_region": "        const FTSLanguage* FTSSpec::_getLanguageToUseV2( const BSONObj& userDoc,\n                                                         const FTSLanguage* currentLanguage ) const {",
        "lookback": "                                                         const FTSLanguage* currentLanguage ) const {",
        "lookahead": "            BSONElement e = userDoc[_languageOverrideField];",
        "label": [
            "newcode",
            "complex_conflict"
        ],
        "start_line": 148,
        "end_line": 158,
        "merge_gen_region": null,
        "confidence": 0.8684941530227661,
        "hesitated": true
    },
    {
        "a_contents": "        namespace {\n            /**\n             * Check for exact match or path prefix match.\n             */\n            inline bool _matchPrefix( const string& dottedName, const string& weight ) {\n                if ( weight == dottedName ) {\n                    return true;\n                }\n                return str::startsWith( weight, dottedName + '.' );\n            }\n        }\n\n        void FTSSpec::scoreDocument( const BSONObj& obj,\n                                     const FTSLanguage& parentLanguage,\n                                     const string& parentPath,\n                                     bool isArray,\n                                     TermFrequencyMap* term_freqs ) const {\n\n            if ( _textIndexVersion == TEXT_INDEX_VERSION_1 ) {\n                dassert( parentPath == \"\" );\n                dassert( !isArray );\n                return _scoreDocumentV1( obj, term_freqs );\n            }\n\n            const FTSLanguage& language = _getLanguageToUseV2( obj, parentLanguage );\n            Stemmer stemmer( language );\n            Tools tools( language, &stemmer, StopWords::getStopWords( language ) );\n\n            // Perform a depth-first traversal of obj, skipping fields not touched by this spec.\n            BSONObjIterator j( obj );\n            while ( j.more() ) {\n\n                BSONElement elem = j.next();\n                string fieldName = elem.fieldName();\n\n                // Skip \"language\" specifier fields if wildcard.\n                if ( wildcard() && languageOverrideField() == fieldName ) {\n                    continue;\n                }\n\n                // Compose the dotted name of the current field:\n                // 1. parent path empty (top level): use the current field name\n                // 2. parent path non-empty and obj is an array: use the parent path\n                // 3. parent path non-empty and obj is a sub-doc: append field name to parent path\n                string dottedName = ( parentPath.empty() ? fieldName\n                                          : isArray ? parentPath\n                                          : parentPath + '.' + fieldName );\n\n                // Find lower bound of dottedName in _weights.  lower_bound leaves us at the first\n                // weight that could possibly match or be a prefix of dottedName.  And if this\n                // element fails to match, then no subsequent weight can match, since the weights\n                // are lexicographically ordered.\n                Weights::const_iterator i = _weights.lower_bound( elem.type() == Object\n                                                                  ? dottedName + '.'\n                                                                  : dottedName );\n\n                // possibleWeightMatch is set if the weight map contains either a match or some item\n                // lexicographically larger than fieldName.  This boolean acts as a guard on\n                // dereferences of iterator 'i'.\n                bool possibleWeightMatch = ( i != _weights.end() );\n\n                // Optimize away two cases, when not wildcard:\n                // 1. lower_bound seeks to end(): no prefix match possible\n                // 2. lower_bound seeks to a name which is not a prefix\n                if ( !wildcard() ) {\n                    if ( !possibleWeightMatch ) {\n                        continue;\n                    }\n                    else if ( !_matchPrefix( dottedName, i->first ) ) {\n                        continue;\n                    }\n                }\n\n                // Is the current field an exact match on a weight?\n                bool exactMatch = ( possibleWeightMatch && i->first == dottedName );\n\n                double weight = ( possibleWeightMatch ? i->second : DEFAULT_WEIGHT );\n\n                switch ( elem.type() ) {\n                case String:\n                    // Only index strings on exact match or wildcard.\n                    if ( exactMatch || wildcard() ) {\n                        _scoreStringV2( tools, elem.valuestr(), term_freqs, weight );\n                    }\n                    break;\n                case Object:\n                    // Only descend into a sub-document on proper prefix or wildcard.  Note that\n                    // !exactMatch is a sufficient test for proper prefix match, because of\n                    // matchPrefix() continue block above.\n                    if ( !exactMatch || wildcard() ) {\n                        scoreDocument( elem.Obj(), language, dottedName, false, term_freqs );\n                    }\n                    break;\n                case Array:\n                    // Only descend into arrays from non-array parents or on wildcard.\n                    if ( !isArray || wildcard() ) {\n                        scoreDocument( elem.Obj(), language, dottedName, true, term_freqs );\n                    }\n                    break;\n                default:\n                    // Skip over all other BSON types.\n                    break;\n                }",
        "b_contents": "            while ( it.more() ) {\n                FTSIteratorValue val = it.next();\n                Stemmer stemmer( val._language );\n                Tools tools( val._language, &stemmer, StopWords::getStopWords( val._language ) );\n                _scoreString( tools, val._text, term_freqs, val._weight );",
        "base_contents": "        namespace {\n            /**\n             * Check for exact match or path prefix match.\n             */\n            inline bool _matchPrefix( const string& dottedName, const string& weight ) {\n                if ( weight == dottedName ) {\n                    return true;\n                }\n                return str::startsWith( weight, dottedName + '.' );\n            }\n        }\n\n        void FTSSpec::scoreDocument( const BSONObj& obj,\n                                     const FTSLanguage parentLanguage,\n                                     const string& parentPath,\n                                     bool isArray,\n                                     TermFrequencyMap* term_freqs ) const {\n            const FTSLanguage language = getLanguageToUse( obj, parentLanguage );\n            Stemmer stemmer( language );\n            Tools tools( language, &stemmer, StopWords::getStopWords( language ) );\n\n            // Perform a depth-first traversal of obj, skipping fields not touched by this spec.\n            BSONObjIterator j( obj );\n            while ( j.more() ) {\n\n                BSONElement elem = j.next();\n                string fieldName = elem.fieldName();\n\n                // Skip \"language\" specifier fields if wildcard.\n                if ( wildcard() && languageOverrideField() == fieldName ) {\n                    continue;\n                }\n\n                // Compose the dotted name of the current field:\n                // 1. parent path empty (top level): use the current field name\n                // 2. parent path non-empty and obj is an array: use the parent path\n                // 3. parent path non-empty and obj is a sub-doc: append field name to parent path\n                string dottedName = ( parentPath.empty() ? fieldName\n                                          : isArray ? parentPath\n                                          : parentPath + '.' + fieldName );\n\n                // Find lower bound of dottedName in _weights.  lower_bound leaves us at the first\n                // weight that could possibly match or be a prefix of dottedName.  And if this\n                // element fails to match, then no subsequent weight can match, since the weights\n                // are lexicographically ordered.\n                Weights::const_iterator i = _weights.lower_bound( dottedName );\n\n                // possibleWeightMatch is set if the weight map contains either a match or some item\n                // lexicographically larger than fieldName.  This boolean acts as a guard on\n                // dereferences of iterator 'i'.\n                bool possibleWeightMatch = ( i != _weights.end() );\n\n                // Optimize away two cases, when not wildcard:\n                // 1. lower_bound seeks to end(): no prefix match possible\n                // 2. lower_bound seeks to a name which is not a prefix\n                if ( !wildcard() ) {\n                    if ( !possibleWeightMatch ) {\n                        continue;\n                    }\n                    else if ( !_matchPrefix( dottedName, i->first ) ) {\n                        continue;\n                    }\n                }\n\n                // Is the current field an exact match on a weight?\n                bool exactMatch = ( possibleWeightMatch && i->first == dottedName );\n\n                double weight = ( possibleWeightMatch ? i->second : DEFAULT_WEIGHT );\n\n                switch ( elem.type() ) {\n                case String:\n                    // Only index strings on exact match or wildcard.\n                    if ( exactMatch || wildcard() ) {\n                        _scoreString( tools, elem.valuestr(), term_freqs, weight );\n                    }\n                    break;\n                case Object:\n                    // Only descend into a sub-document on proper prefix or wildcard.  Note that\n                    // !exactMatch is a sufficient test for proper prefix match, because of\n                    // matchPrefix() continue block above.\n                    if ( !exactMatch || wildcard() ) {\n                        scoreDocument( elem.Obj(), language, dottedName, false, term_freqs );\n                    }\n                    break;\n                case Array:\n                    // Only descend into arrays from non-array parents or on wildcard.\n                    if ( !isArray || wildcard() ) {\n                        scoreDocument( elem.Obj(), language, dottedName, true, term_freqs );\n                    }\n                    break;\n                default:\n                    // Skip over all other BSON types.\n                    break;\n                }",
        "res_region": "            while ( it.more() ) {\n                FTSIteratorValue val = it.next();\n                Stemmer stemmer( *val._language );\n                Tools tools( *val._language, &stemmer, StopWords::getStopWords( *val._language ) );\n                _scoreStringV2( tools, val._text, term_freqs, val._weight );",
        "lookback": "                FTSIteratorValue val = it.next();",
        "lookahead": "            }",
        "label": [
            "newcode",
            "complex_conflict"
        ],
        "start_line": 177,
        "end_line": 382,
        "merge_gen_region": null,
        "confidence": 0.7575326561927795,
        "hesitated": true
    }
]