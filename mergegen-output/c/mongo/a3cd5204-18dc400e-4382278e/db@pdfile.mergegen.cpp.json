[
    {
        "a_contents": "        {\n            BtreeBuilder btBuilder(dupsAllowed, idx);\n            BSONObj keyLast;\n            auto_ptr<BSONObjExternalSorter::Iterator> i = sorter.iterator();\n            assert( pm == op->setMessage( \"index: (2/3) btree bottom up\" , phase1->nkeys , 10 ) );\n            while( i->more() ) {\n                RARELY killCurrentOp.checkForInterrupt();\n                BSONObjExternalSorter::Data d = i->next();\n\n                try {\n                    btBuilder.addKey(d.first, d.second);\n                }\n                catch( AssertionException& e ) {\n                    if ( dupsAllowed ) {\n                        // unknow exception??\n                        throw;\n                    }\n\n                    if( e.interrupted() )\n                        throw;\n\n                    if ( ! dropDups )\n                        throw;\n\n                    /* we could queue these on disk, but normally there are very few dups, so instead we\n                       keep in ram and have a limit.\n                    */\n                    // so we get error # script checking: uasserted(14046, \"asdf\");\n                    raiseError(14046, \"dups were encountered and dropped\");\n                    dupsToDrop.push_back(d.second);\n                    uassert( 10092 , \"too may dups on index build with dropDups=true\", dupsToDrop.size() < 1000000 );\n                }\n                pm.hit();\n            }\n            pm.finished();\n            op->setMessage( \"index: (3/3) btree-middle\" );\n            log(t.seconds() > 10 ? 0 : 1 ) << \"\\t done building bottom layer, going to commit\" << endl;\n            btBuilder.commit();\n            if ( btBuilder.getn() != phase1->nkeys && ! dropDups ) {\n                warning() << \"not all entries were added to the index, probably some keys were too large\" << endl;\n            }\n        }",
        "b_contents": "        if( idx.version() == 0 )\n            buildBottomUpPhases2And3<V0>(dupsAllowed, idx, sorter, dropDups, dupsToDrop, op, phase1, pm, t);\n        else if( idx.version() == 1 ) \n            buildBottomUpPhases2And3<V1>(dupsAllowed, idx, sorter, dropDups, dupsToDrop, op, phase1, pm, t);\n        else\n            assert(false);",
        "base_contents": "        {\n            BtreeBuilder btBuilder(dupsAllowed, idx);\n            BSONObj keyLast;\n            auto_ptr<BSONObjExternalSorter::Iterator> i = sorter.iterator();\n            assert( pm == op->setMessage( \"index: (2/3) btree bottom up\" , phase1->nkeys , 10 ) );\n            while( i->more() ) {\n                RARELY killCurrentOp.checkForInterrupt();\n                BSONObjExternalSorter::Data d = i->next();\n\n                try {\n                    btBuilder.addKey(d.first, d.second);\n                }\n                catch( AssertionException& e ) {\n                    if ( dupsAllowed ) {\n                        // unknow exception??\n                        throw;\n                    }\n\n                    if( e.interrupted() )\n                        throw;\n\n                    if ( ! dropDups )\n                        throw;\n\n                    /* we could queue these on disk, but normally there are very few dups, so instead we\n                       keep in ram and have a limit.\n                    */\n                    dupsToDrop.push_back(d.second);\n                    uassert( 10092 , \"too may dups on index build with dropDups=true\", dupsToDrop.size() < 1000000 );\n                }\n                pm.hit();\n            }\n            pm.finished();\n            op->setMessage( \"index: (3/3) btree-middle\" );\n            log(t.seconds() > 10 ? 0 : 1 ) << \"\\t done building bottom layer, going to commit\" << endl;\n            btBuilder.commit();\n            if ( btBuilder.getn() != phase1->nkeys && ! dropDups ) {\n                warning() << \"not all entries were added to the index, probably some keys were too large\" << endl;\n            }\n        }",
        "res_region": "        if( idx.version() == 0 )\n            buildBottomUpPhases2And3<V0>(dupsAllowed, idx, sorter, dropDups, dupsToDrop, op, phase1, pm, t);\n        else if( idx.version() == 1 ) \n            buildBottomUpPhases2And3<V1>(dupsAllowed, idx, sorter, dropDups, dupsToDrop, op, phase1, pm, t);\n        else\n            assert(false);",
        "lookback": "            buildBottomUpPhases2And3<V0>(dupsAllowed, idx, sorter, dropDups, dupsToDrop, op, phase1, pm, t);",
        "lookahead": "",
        "label": [
            "base",
            "complex_conflict"
        ],
        "start_line": 1281,
        "end_line": 1372,
        "merge_gen_region": null,
        "confidence": 0.7053630948066711,
        "hesitated": true
    }
]