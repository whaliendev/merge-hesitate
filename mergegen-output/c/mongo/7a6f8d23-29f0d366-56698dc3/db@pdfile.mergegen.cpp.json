[
    {
        "a_contents": "        if( idxNo == 1 ) { \n            // TEMP!\n\n            BSONObjExternalSorter::Iterator i = sorter.iterator();\n            while( i.more() ) { \n                BSONObjExternalSorter::Data d = i.next();\n                cout << d.second.toString() << endl;\n                cout << d.first.objsize() << endl;\n                cout<<\"SORTER next:\" << d.first.toString() << endl;\n            }\n\n            cout << \"stop here\" << endl;\n            cout << \"stop here\" << endl;\n        }\n\n        list<DiskLoc> dupsToDrop;\n\n        /* build index --- */ \n        {\n            BtreeBuilder btBuilder(dupsAllowed, idx);\n            BSONObj keyLast;\n            BSONObjExternalSorter::Iterator i = sorter.iterator();\n            while( i.more() ) { \n                BSONObjExternalSorter::Data d = i.next();\n                cout<<\"TEMP SORTER next \" << d.first.toString() << endl;\n//zzz\n                try { \n                    btBuilder.addKey(d.first, d.second);\n                }\n                catch( AssertionException& ) { \n                    if( !dupsAllowed ) { \n                        if( dropDups ) { \n                            /* we could queue these on disk, but normally there are very few dups, so instead we \n                            keep in ram and have a limit.\n                            */\n                            dupsToDrop.push_back(d.second);\n                            uassert(\"too may dups on index build with dropDups=true\", dupsToDrop.size() < 1000000 );\n                        }\n                    else\n                        throw;",
        "b_contents": "        BSONObj keyLast;\n        auto_ptr<BSONObjExternalSorter::Iterator> i = sorter.iterator();\n        int m = 0;\n        while( i->more() ) { \n            BSONObjExternalSorter::Data d = i->next();\n            if( !dupsAllowed ) { \n                if( keyLast.woCompare(d.first) == 0 && m > 0 ) { \n                    // duplicate\n                    if( dropDups ) { \n                        // ...",
        "base_contents": "        BSONObj keyLast;\n        BSONObjExternalSorter::Iterator i = sorter.iterator();\n        int m = 0;\n        while( i.more() ) { \n            BSONObjExternalSorter::Data d = i.next();\n            if( !dupsAllowed ) { \n                if( keyLast.woCompare(d.first) == 0 && m > 0 ) { \n                    // duplicate\n                    if( dropDups ) { \n                        // ...",
        "res_region": "        if( idxNo == 1 ) { \n            // TEMP!\n\n            auto_ptr<BSONObjExternalSorter::Iterator> i = sorter.iterator();\n            while( i->more() ) { \n                BSONObjExternalSorter::Data d = i->next();\n                cout << d.second.toString() << endl;\n                cout << d.first.objsize() << endl;\n                cout<<\"SORTER next:\" << d.first.toString() << endl;\n            }\n\n            cout << \"stop here\" << endl;\n            cout << \"stop here\" << endl;\n        }\n\n        list<DiskLoc> dupsToDrop;\n\n        /* build index --- */ \n        {\n            BtreeBuilder btBuilder(dupsAllowed, idx);\n            BSONObj keyLast;\n            auto_ptr<BSONObjExternalSorter::Iterator> i = sorter.iterator();\n            while( i->more() ) { \n                BSONObjExternalSorter::Data d = i->next();\n                cout<<\"TEMP SORTER next \" << d.first.toString() << endl;\n//zzz\n                try { \n                    btBuilder.addKey(d.first, d.second);\n                }\n                catch( AssertionException& ) { \n                    if( !dupsAllowed ) { \n                        if( dropDups ) { \n                            /* we could queue these on disk, but normally there are very few dups, so instead we \n                            keep in ram and have a limit.\n                            */\n                            dupsToDrop.push_back(d.second);\n                            uassert(\"too may dups on index build with dropDups=true\", dupsToDrop.size() < 1000000 );\n                        }\n                    else\n                        throw;",
        "lookback": "            // TEMP!",
        "lookahead": "                    }",
        "label": [
            "newcode",
            "complex_conflict"
        ],
        "start_line": 1095,
        "end_line": 1158,
        "merge_gen_region": " TEMP BSONExternalerIterator =er.();(.() ) BSONExternalerData =.();::() BSONExternalerData d inext cout dsecondtoString <<; <<..size() <<;<<\"ER next <<..() {ObjSort:: d =.();TypesTypesTypes::&&..\":: <<;;::&&...&&&&&&&&&1 { {::&&1 {::&1 {::&1 {::&1 {::&1 {::&1 {::&1 {::&1 {::&1 {::&1 {::&1 {::&1 {::&1 {::&1 {::&1 {::&1 {::<&1 {::<&1 {::<&1 {::<&1 {::<&&1 {::<&&1 {::&&1 {::&1 {::&1 {::&1 {::&1 {::&1 {::&1 {::&1 {::&1 {::&1 {::&1 {::&1 {::&1 {::&1 {::&",
        "confidence": 0.9311785101890564,
        "hesitated": false,
        "resolved": false
    }
]