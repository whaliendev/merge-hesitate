[
    {
        "a_contents": "\n    class DocumentSourceUnwind :\n        public DocumentSource,\n        public boost::enable_shared_from_this<DocumentSourceUnwind> {\n    public:\n        // virtuals from DocumentSource\n        virtual ~DocumentSourceUnwind();\n        virtual bool eof();\n        virtual bool advance();\n        virtual intrusive_ptr<Document> getCurrent();\n\n        /*\n          Create a new DocumentSource that can implement unwind.\n\n\t  @returns the projection DocumentSource\n        */\n        static intrusive_ptr<DocumentSourceUnwind> create();\n\n        /*\n\t  Specify the field to unwind.  There must be exactly one before\n\t  the pipeline begins execution.\n\n\t  @param rFieldPath - path to the field to unwind\n        */\n\tvoid unwindField(const FieldPath &rFieldPath);\n\n\t/*\n\t  Create a new projection DocumentSource from BSON.\n\n\t  This is a convenience for directly handling BSON, and relies on the\n\t  above methods.\n\n\t  @params pBsonElement the BSONElement with an object named $project\n\t  @returns the created projection\n\t */\n        static intrusive_ptr<DocumentSource> createFromBson(\n            BSONElement *pBsonElement,\n\t    const intrusive_ptr<ExpressionContext> &pCtx);\n\n\tstatic const char unwindName[];\n\n    protected:\n\t// virtuals from DocumentSource\n\tvirtual void sourceToBson(BSONObjBuilder *pBuilder) const;\n\n    private:\n        DocumentSourceUnwind();\n\n        // configuration state\n\tFieldPath unwindPath;\n\n\tvector<int> fieldIndex; /* for the current document, the indices\n\t\t\t\t   leading down to the field being unwound */\n\n        // iteration state\n        intrusive_ptr<Document> pNoUnwindDocument;\n                                              // document to return, pre-unwind\n        intrusive_ptr<const Value> pUnwindArray; // field being unwound\n        intrusive_ptr<ValueIterator> pUnwinder; // iterator used for unwinding\n        intrusive_ptr<const Value> pUnwindValue; // current value\n\n\t/*\n\t  Clear all the state related to unwinding an array.\n\t */\n\tvoid resetArray();\n\n\t/*\n\t  Clone the current document being unwound.\n\n\t  This is a partial deep clone.  Because we're going to replace the\n\t  value at the end, we have to replace everything along the path\n\t  leading to that in order to not share that change with any other\n\t  clones (or the original) that we've made.\n\n\t  This expects pUnwindValue to have been set by a prior call to\n\t  advance().  However, pUnwindValue may also be NULL, in which case\n\t  the field will be removed -- this is the action for an empty\n\t  array.\n\n\t  @returns a partial deep clone of pNoUnwindDocument\n\t */\n\tintrusive_ptr<Document> clonePath() const;\n    };\n",
        "b_contents": "    class DocumentSourceLimit :\n        public DocumentSource {\n    public:\n        // virtuals from DocumentSource\n        virtual ~DocumentSourceLimit();\n        virtual bool eof();\n        virtual bool advance();\n        virtual intrusive_ptr<Document> getCurrent();\n\n        /*\n          Create a new limiting DocumentSource.\n\n\t  @param pCtx the expression context\n\t  @returns the DocumentSource\n         */\n        static intrusive_ptr<DocumentSourceLimit> create(\n\t    const intrusive_ptr<ExpressionContext> &pCtx);\n\n\t/*\n\t  Create a limiting DocumentSource from BSON.\n\n\t  This is a convenience method that uses the above, and operates on\n\t  a BSONElement that has been deteremined to be an Object with an\n\t  element named $limit.\n\n\t  @param pBsonElement the BSONELement that defines the limit\n\t  @param pCtx the expression context\n\t  @returns the grouping DocumentSource\n\t */\n        static intrusive_ptr<DocumentSource> createFromBson(\n\t    BSONElement *pBsonElement,\n\t    const intrusive_ptr<ExpressionContext> &pCtx);\n\n\n\tstatic const char limitName[];\n\n    protected:\n\t// virtuals from DocumentSource\n\tvirtual void sourceToBson(BSONObjBuilder *pBuilder) const;\n\n    private:\n        DocumentSourceLimit(const intrusive_ptr<ExpressionContext> &pCtx);\n\n        long long limit;\n        long long count;\n        intrusive_ptr<Document> pCurrent;\n\n\tintrusive_ptr<ExpressionContext> pCtx;\n    };\n\n    class DocumentSourceSkip :\n        public DocumentSource {\n    public:\n        // virtuals from DocumentSource\n        virtual ~DocumentSourceSkip();\n        virtual bool eof();\n        virtual bool advance();\n        virtual intrusive_ptr<Document> getCurrent();\n\n        /*\n          Create a new skipping DocumentSource.\n\n\t  @param pCtx the expression context\n\t  @returns the DocumentSource\n         */\n        static intrusive_ptr<DocumentSourceSkip> create(\n\t    const intrusive_ptr<ExpressionContext> &pCtx);\n\n\t/*\n\t  Create a skipping DocumentSource from BSON.\n\n\t  This is a convenience method that uses the above, and operates on\n\t  a BSONElement that has been deteremined to be an Object with an\n\t  element named $skip.\n\n\t  @param pBsonElement the BSONELement that defines the skip\n\t  @param pCtx the expression context\n\t  @returns the grouping DocumentSource\n\t */\n        static intrusive_ptr<DocumentSource> createFromBson(\n\t    BSONElement *pBsonElement,\n\t    const intrusive_ptr<ExpressionContext> &pCtx);\n\n\n\tstatic const char skipName[];\n\n    protected:\n\t// virtuals from DocumentSource\n\tvirtual void sourceToBson(BSONObjBuilder *pBuilder) const;\n\n    private:\n        DocumentSourceSkip(const intrusive_ptr<ExpressionContext> &pCtx);\n\n        /*\n          Skips initial documents.\n         */\n        void skipper();\n\n        long long skip;\n        long long count;\n        intrusive_ptr<Document> pCurrent;\n\n\tintrusive_ptr<ExpressionContext> pCtx;\n    };\n",
        "base_contents": "",
        "res_region": "\n    class DocumentSourceLimit :\n        public DocumentSource {\n    public:\n        // virtuals from DocumentSource\n        virtual ~DocumentSourceLimit();\n        virtual bool eof();\n        virtual bool advance();\n        virtual intrusive_ptr<Document> getCurrent();\n\n        /*\n          Create a new limiting DocumentSource.\n\n\t  @param pCtx the expression context\n\t  @returns the DocumentSource\n         */\n        static intrusive_ptr<DocumentSourceLimit> create(\n\t    const intrusive_ptr<ExpressionContext> &pCtx);\n\n\t/*\n\t  Create a limiting DocumentSource from BSON.\n\n\t  This is a convenience method that uses the above, and operates on\n\t  a BSONElement that has been deteremined to be an Object with an\n\t  element named $limit.\n\n\t  @param pBsonElement the BSONELement that defines the limit\n\t  @param pCtx the expression context\n\t  @returns the grouping DocumentSource\n\t */\n        static intrusive_ptr<DocumentSource> createFromBson(\n\t    BSONElement *pBsonElement,\n\t    const intrusive_ptr<ExpressionContext> &pCtx);\n\n\n\tstatic const char limitName[];\n\n    protected:\n\t// virtuals from DocumentSource\n\tvirtual void sourceToBson(BSONObjBuilder *pBuilder) const;\n\n    private:\n        DocumentSourceLimit(const intrusive_ptr<ExpressionContext> &pCtx);\n\n        long long limit;\n        long long count;\n        intrusive_ptr<Document> pCurrent;\n\n\tintrusive_ptr<ExpressionContext> pCtx;\n    };\n\n    class DocumentSourceSkip :\n        public DocumentSource {\n    public:\n        // virtuals from DocumentSource\n        virtual ~DocumentSourceSkip();\n        virtual bool eof();\n        virtual bool advance();\n        virtual intrusive_ptr<Document> getCurrent();\n\n        /*\n          Create a new skipping DocumentSource.\n\n\t  @param pCtx the expression context\n\t  @returns the DocumentSource\n         */\n        static intrusive_ptr<DocumentSourceSkip> create(\n\t    const intrusive_ptr<ExpressionContext> &pCtx);\n\n\t/*\n\t  Create a skipping DocumentSource from BSON.\n\n\t  This is a convenience method that uses the above, and operates on\n\t  a BSONElement that has been deteremined to be an Object with an\n\t  element named $skip.\n\n\t  @param pBsonElement the BSONELement that defines the skip\n\t  @param pCtx the expression context\n\t  @returns the grouping DocumentSource\n\t */\n        static intrusive_ptr<DocumentSource> createFromBson(\n\t    BSONElement *pBsonElement,\n\t    const intrusive_ptr<ExpressionContext> &pCtx);\n\n\n\tstatic const char skipName[];\n\n    protected:\n\t// virtuals from DocumentSource\n\tvirtual void sourceToBson(BSONObjBuilder *pBuilder) const;\n\n    private:\n        DocumentSourceSkip(const intrusive_ptr<ExpressionContext> &pCtx);\n\n        /*\n          Skips initial documents.\n         */\n        void skipper();\n\n        long long skip;\n        long long count;\n        intrusive_ptr<Document> pCurrent;\n\n\tintrusive_ptr<ExpressionContext> pCtx;\n    };\n\n\n    class DocumentSourceUnwind :\n        public DocumentSource,\n        public boost::enable_shared_from_this<DocumentSourceUnwind> {\n    public:\n        // virtuals from DocumentSource\n        virtual ~DocumentSourceUnwind();\n        virtual bool eof();\n        virtual bool advance();\n        virtual intrusive_ptr<Document> getCurrent();\n\n        /*\n          Create a new DocumentSource that can implement unwind.\n\n\t  @returns the projection DocumentSource\n        */\n        static intrusive_ptr<DocumentSourceUnwind> create();\n\n        /*\n\t  Specify the field to unwind.  There must be exactly one before\n\t  the pipeline begins execution.\n\n\t  @param rFieldPath - path to the field to unwind\n        */\n\tvoid unwindField(const FieldPath &rFieldPath);\n\n\t/*\n\t  Create a new projection DocumentSource from BSON.\n\n\t  This is a convenience for directly handling BSON, and relies on the\n\t  above methods.\n\n\t  @params pBsonElement the BSONElement with an object named $project\n\t  @returns the created projection\n\t */\n        static intrusive_ptr<DocumentSource> createFromBson(\n            BSONElement *pBsonElement,\n\t    const intrusive_ptr<ExpressionContext> &pCtx);\n\n\tstatic const char unwindName[];\n\n    protected:\n\t// virtuals from DocumentSource\n\tvirtual void sourceToBson(BSONObjBuilder *pBuilder) const;\n\n    private:\n        DocumentSourceUnwind();\n\n        // configuration state\n\tFieldPath unwindPath;\n\n\tvector<int> fieldIndex; /* for the current document, the indices\n\t\t\t\t   leading down to the field being unwound */\n\n        // iteration state\n        intrusive_ptr<Document> pNoUnwindDocument;\n                                              // document to return, pre-unwind\n        intrusive_ptr<const Value> pUnwindArray; // field being unwound\n        intrusive_ptr<ValueIterator> pUnwinder; // iterator used for unwinding\n        intrusive_ptr<const Value> pUnwindValue; // current value\n\n\t/*\n\t  Clear all the state related to unwinding an array.\n\t */\n\tvoid resetArray();\n\n\t/*\n\t  Clone the current document being unwound.\n\n\t  This is a partial deep clone.  Because we're going to replace the\n\t  value at the end, we have to replace everything along the path\n\t  leading to that in order to not share that change with any other\n\t  clones (or the original) that we've made.\n\n\t  This expects pUnwindValue to have been set by a prior call to\n\t  advance().  However, pUnwindValue may also be NULL, in which case\n\t  the field will be removed -- this is the action for an empty\n\t  array.\n\n\t  @returns a partial deep clone of pNoUnwindDocument\n\t */\n\tintrusive_ptr<Document> clonePath() const;\n\n    };\n",
        "lookback": "    class DocumentSourceLimit :",
        "lookahead": "}",
        "label": [
            "interleave",
            "one_side_deletion"
        ],
        "start_line": 759,
        "end_line": 951,
        "merge_gen_region": null,
        "confidence": 0.8536641001701355,
        "hesitated": true
    }
]