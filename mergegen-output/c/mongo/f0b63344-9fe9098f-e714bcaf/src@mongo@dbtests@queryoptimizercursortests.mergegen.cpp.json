[
    {
        "a_contents": "    /** Yield cursor and delete current entry, then continue iteration. */\n    class YieldNoOp : public Base {\n    public:\n        void run() {\n            _cli.insert( ns(), BSON( \"_id\" << 1 ) );\n            _cli.insert( ns(), BSON( \"_id\" << 2 ) );\n            \n            {\n                Lock::GlobalWrite lk;\n                Client::Context ctx( ns() );\n                setQueryOptimizerCursor( BSON( \"_id\" << GT << 0 ) );\n                ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                ASSERT( prepareToYield() );\n            }\n            \n            {\n                Lock::GlobalWrite lk;\n                Client::Context ctx( ns() );\n                recoverFromYield();\n                ASSERT( ok() );\n                ASSERT_EQUALS( 2, current().getIntField( \"_id\" ) );\n                ASSERT( !advance() );\n                ASSERT( !ok() );\n                ASSERT( prepareToYield() );\n                recoverFromYield();\n            }\n        }            \n    };\n    \n    /** Yield cursor and delete current entry. */\n    class YieldDelete : public Base {\n    public:\n        void run() {\n            _cli.insert( ns(), BSON( \"_id\" << 1 ) );\n            \n            {\n                Lock::GlobalWrite lk;\n                Client::Context ctx( ns() );\n                setQueryOptimizerCursor( BSON( \"_id\" << 1 ) );\n                ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                ASSERT( prepareToYield() );",
        "b_contents": "    namespace Yield {\n        \n        /** Yield cursor and delete current entry, then continue iteration. */\n        class NoOp : public Base {\n        public:\n            void run() {\n                _cli.insert( ns(), BSON( \"_id\" << 1 ) );\n                _cli.insert( ns(), BSON( \"_id\" << 2 ) );\n                \n                {\n                    dblock lk;\n                    Client::Context ctx( ns() );\n                    setQueryOptimizerCursor( BSON( \"_id\" << GT << 0 ) );\n                    ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                    prepareToYield();\n                }\n                \n                {\n                    dblock lk;\n                    Client::Context ctx( ns() );\n                    recoverFromYield();\n                    ASSERT( ok() );\n                    ASSERT_EQUALS( 2, current().getIntField( \"_id\" ) );\n                    ASSERT( !advance() );\n                    ASSERT( !ok() );\n                    prepareToYield();\n                    recoverFromYield();\n                }\n            }            \n        };\n        \n        /** Yield cursor and delete current entry. */\n        class Delete : public Base {\n        public:\n            void run() {\n                _cli.insert( ns(), BSON( \"_id\" << 1 ) );\n                \n                {\n                    dblock lk;\n                    Client::Context ctx( ns() );\n                    setQueryOptimizerCursor( BSON( \"_id\" << 1 ) );\n                    ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                    prepareToYield();\n                }\n                \n                _cli.remove( ns(), BSON( \"_id\" << 1 ) );\n                \n                {\n                    dblock lk;\n                    Client::Context ctx( ns() );\n                    recoverFromYield();\n                    ASSERT( !ok() );\n                    ASSERT( !advance() );\n                }",
        "base_contents": "    /** Yield cursor and delete current entry, then continue iteration. */\n    class YieldNoOp : public Base {\n    public:\n        void run() {\n            _cli.insert( ns(), BSON( \"_id\" << 1 ) );\n            _cli.insert( ns(), BSON( \"_id\" << 2 ) );\n            \n            {\n                dblock lk;\n                Client::Context ctx( ns() );\n                setQueryOptimizerCursor( BSON( \"_id\" << GT << 0 ) );\n                ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                ASSERT( prepareToYield() );\n            }\n            \n            {\n                dblock lk;\n                Client::Context ctx( ns() );\n                recoverFromYield();\n                ASSERT( ok() );\n                ASSERT_EQUALS( 2, current().getIntField( \"_id\" ) );\n                ASSERT( !advance() );\n                ASSERT( !ok() );\n                ASSERT( prepareToYield() );\n                recoverFromYield();\n            }\n        }            \n    };\n    \n    /** Yield cursor and delete current entry. */\n    class YieldDelete : public Base {\n    public:\n        void run() {\n            _cli.insert( ns(), BSON( \"_id\" << 1 ) );\n            \n            {\n                dblock lk;\n                Client::Context ctx( ns() );\n                setQueryOptimizerCursor( BSON( \"_id\" << 1 ) );\n                ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                ASSERT( prepareToYield() );",
        "res_region": "    namespace Yield {\n        \n        /** Yield cursor and delete current entry, then continue iteration. */\n        class NoOp : public Base {\n        public:\n            void run() {\n                _cli.insert( ns(), BSON( \"_id\" << 1 ) );\n                _cli.insert( ns(), BSON( \"_id\" << 2 ) );\n                \n                {\n                    Lock::GlobalWrite lk;\n\n                    Client::Context ctx( ns() );\n                    setQueryOptimizerCursor( BSON( \"_id\" << GT << 0 ) );\n                    ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                    prepareToYield();\n                }\n                \n                {\n                    Lock::GlobalWrite lk;\n\n                    Client::Context ctx( ns() );\n                    recoverFromYield();\n                    ASSERT( ok() );\n                    ASSERT_EQUALS( 2, current().getIntField( \"_id\" ) );\n                    ASSERT( !advance() );\n                    ASSERT( !ok() );\n                    prepareToYield();\n                    recoverFromYield();\n                }\n            }            \n        };\n        \n        /** Yield cursor and delete current entry. */\n        class Delete : public Base {\n        public:\n            void run() {\n                _cli.insert( ns(), BSON( \"_id\" << 1 ) );\n                \n                {\n                    Lock::GlobalWrite lk;\n\n                    Client::Context ctx( ns() );\n                    setQueryOptimizerCursor( BSON( \"_id\" << 1 ) );\n                    ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                    prepareToYield();\n                }\n                \n                _cli.remove( ns(), BSON( \"_id\" << 1 ) );\n                \n                {\n                    Lock::GlobalWrite lk;\n\n                    Client::Context ctx( ns() );\n                    recoverFromYield();\n                    ASSERT( !ok() );\n                    ASSERT( !advance() );\n                }",
        "lookback": "        ",
        "lookahead": "            }",
        "label": [
            "newcode",
            "complex_conflict"
        ],
        "start_line": 1074,
        "end_line": 1213,
        "merge_gen_region": null,
        "confidence": 0.8533293604850769,
        "hesitated": true
    },
    {
        "a_contents": "            \n            _cli.remove( ns(), BSON( \"_id\" << 1 ) );\n            \n            {\n                Lock::GlobalWrite lk;\n                Client::Context ctx( ns() );\n                recoverFromYield();\n                ASSERT( !ok() );\n                ASSERT( !advance() );",
        "b_contents": "        };\n        \n        /** Yield cursor and delete current entry, then continue iteration. */\n        class DeleteContinue : public Base {\n        public:\n            void run() {\n                _cli.insert( ns(), BSON( \"_id\" << 1 ) );\n                _cli.insert( ns(), BSON( \"_id\" << 2 ) );\n                \n                {\n                    dblock lk;\n                    Client::Context ctx( ns() );\n                    setQueryOptimizerCursor( BSON( \"_id\" << GT << 0 ) );\n                    ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                    prepareToYield();\n                }\n                \n                _cli.remove( ns(), BSON( \"_id\" << 1 ) );\n                \n                {\n                    dblock lk;\n                    Client::Context ctx( ns() );\n                    recoverFromYield();\n                    ASSERT( ok() );\n                    ASSERT_EQUALS( 2, current().getIntField( \"_id\" ) );\n                    ASSERT( !advance() );\n                    ASSERT( !ok() );\n                }\n            }            \n        };\n        \n        /** Yield cursor and delete current entry, then continue iteration. */\n        class DeleteContinueFurther : public Base {\n        public:\n            void run() {\n                _cli.insert( ns(), BSON( \"_id\" << 1 ) );\n                _cli.insert( ns(), BSON( \"_id\" << 2 ) );\n                _cli.insert( ns(), BSON( \"_id\" << 3 ) );\n                \n                {\n                    dblock lk;\n                    Client::Context ctx( ns() );\n                    setQueryOptimizerCursor( BSON( \"_id\" << GT << 0 ) );\n                    ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                    prepareToYield();\n                }\n                \n                _cli.remove( ns(), BSON( \"_id\" << 1 ) );\n                \n                {\n                    dblock lk;\n                    Client::Context ctx( ns() );\n                    recoverFromYield();\n                    ASSERT( ok() );\n                    ASSERT_EQUALS( 2, current().getIntField( \"_id\" ) );\n                    ASSERT( advance() );\n                    ASSERT_EQUALS( 3, current().getIntField( \"_id\" ) );\n                    ASSERT( !advance() );\n                    ASSERT( !ok() );\n                }\n            }            \n        };\n        \n        /** Yield and update current. */\n        class Update : public Base {\n        public:\n            void run() {\n                _cli.insert( ns(), BSON( \"a\" << 1 ) );\n                _cli.insert( ns(), BSON( \"a\" << 2 ) );\n                _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n                \n                {\n                    dblock lk;\n                    Client::Context ctx( ns() );\n                    setQueryOptimizerCursor( BSON( \"a\" << GT << 0 ) );\n                    ASSERT_EQUALS( 1, current().getIntField( \"a\" ) );\n                    prepareToYield();\n                }\n                \n                _cli.update( ns(), BSON( \"a\" << 1 ), BSON( \"$set\" << BSON( \"a\" << 3 ) ) );\n                \n                {\n                    dblock lk;\n                    Client::Context ctx( ns() );\n                    recoverFromYield();\n                    ASSERT( ok() );\n                    ASSERT_EQUALS( 2, current().getIntField( \"a\" ) );\n                    ASSERT( !advance() );\n                    ASSERT( !ok() );\n                }                ",
        "base_contents": "            \n            _cli.remove( ns(), BSON( \"_id\" << 1 ) );\n            \n            {\n                dblock lk;\n                Client::Context ctx( ns() );\n                recoverFromYield();\n                ASSERT( !ok() );\n                ASSERT( !advance() );",
        "res_region": "        };\n        \n        /** Yield cursor and delete current entry, then continue iteration. */\n        class DeleteContinue : public Base {\n        public:\n            void run() {\n                _cli.insert( ns(), BSON( \"_id\" << 1 ) );\n                _cli.insert( ns(), BSON( \"_id\" << 2 ) );\n                \n                {\n                    Lock::GlobalWrite lk;\n\n                    Client::Context ctx( ns() );\n                    setQueryOptimizerCursor( BSON( \"_id\" << GT << 0 ) );\n                    ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                    prepareToYield();\n                }\n                \n                _cli.remove( ns(), BSON( \"_id\" << 1 ) );\n                \n                {\n                    Lock::GlobalWrite lk;\n\n                    Client::Context ctx( ns() );\n                    recoverFromYield();\n                    ASSERT( ok() );\n                    ASSERT_EQUALS( 2, current().getIntField( \"_id\" ) );\n                    ASSERT( !advance() );\n                    ASSERT( !ok() );\n                }\n            }            \n        };\n        \n        /** Yield cursor and delete current entry, then continue iteration. */\n        class DeleteContinueFurther : public Base {\n        public:\n            void run() {\n                _cli.insert( ns(), BSON( \"_id\" << 1 ) );\n                _cli.insert( ns(), BSON( \"_id\" << 2 ) );\n                _cli.insert( ns(), BSON( \"_id\" << 3 ) );\n                \n                {\n                    Lock::GlobalWrite lk;\n\n                    Client::Context ctx( ns() );\n                    setQueryOptimizerCursor( BSON( \"_id\" << GT << 0 ) );\n                    ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                    prepareToYield();\n                }\n                \n                _cli.remove( ns(), BSON( \"_id\" << 1 ) );\n                \n                {\n                    Lock::GlobalWrite lk;\n\n                    Client::Context ctx( ns() );\n                    recoverFromYield();\n                    ASSERT( ok() );\n                    ASSERT_EQUALS( 2, current().getIntField( \"_id\" ) );\n                    ASSERT( advance() );\n                    ASSERT_EQUALS( 3, current().getIntField( \"_id\" ) );\n                    ASSERT( !advance() );\n                    ASSERT( !ok() );\n                }\n            }            \n        };\n        \n        /** Yield and update current. */\n        class Update : public Base {\n        public:\n            void run() {\n                _cli.insert( ns(), BSON( \"a\" << 1 ) );\n                _cli.insert( ns(), BSON( \"a\" << 2 ) );\n                _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n                \n                {\n                    Lock::GlobalWrite lk;\n\n                    Client::Context ctx( ns() );\n                    setQueryOptimizerCursor( BSON( \"a\" << GT << 0 ) );\n                    ASSERT_EQUALS( 1, current().getIntField( \"a\" ) );\n                    prepareToYield();\n                }\n                \n                _cli.update( ns(), BSON( \"a\" << 1 ), BSON( \"$set\" << BSON( \"a\" << 3 ) ) );\n                \n                {\n                    Lock::GlobalWrite lk;\n\n                    Client::Context ctx( ns() );\n                    recoverFromYield();\n                    ASSERT( ok() );\n                    ASSERT_EQUALS( 2, current().getIntField( \"a\" ) );\n                    ASSERT( !advance() );\n                    ASSERT( !ok() );\n                }                ",
        "lookback": "        ",
        "lookahead": "            }",
        "label": [
            "newcode",
            "complex_conflict"
        ],
        "start_line": 1215,
        "end_line": 1326,
        "merge_gen_region": null,
        "confidence": 0.5040339231491089,
        "hesitated": true
    },
    {
        "a_contents": "        }\n    };\n    \n    /** Yield cursor and delete current entry, then continue iteration. */\n    class YieldDeleteContinue : public Base {\n    public:\n        void run() {\n            _cli.insert( ns(), BSON( \"_id\" << 1 ) );\n            _cli.insert( ns(), BSON( \"_id\" << 2 ) );\n            \n            {\n                Lock::GlobalWrite lk;\n                Client::Context ctx( ns() );\n                setQueryOptimizerCursor( BSON( \"_id\" << GT << 0 ) );\n                ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                ASSERT( prepareToYield() );",
        "b_contents": "        };\n        \n        /** Yield and drop collection. */\n        class Drop : public Base {\n        public:\n            void run() {\n                _cli.insert( ns(), BSON( \"_id\" << 1 ) );\n                _cli.insert( ns(), BSON( \"_id\" << 2 ) );\n                \n                {\n                    dblock lk;\n                    Client::Context ctx( ns() );\n                    setQueryOptimizerCursor( BSON( \"_id\" << GT << 0 ) );\n                    ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                    prepareToYield();\n                }\n                \n                _cli.dropCollection( ns() );\n                \n                {\n                    dblock lk;\n                    Client::Context ctx( ns() );\n                    recoverFromYield();\n                    ASSERT( !ok() );\n                }                ",
        "base_contents": "        }\n    };\n    \n    /** Yield cursor and delete current entry, then continue iteration. */\n    class YieldDeleteContinue : public Base {\n    public:\n        void run() {\n            _cli.insert( ns(), BSON( \"_id\" << 1 ) );\n            _cli.insert( ns(), BSON( \"_id\" << 2 ) );\n            \n            {\n                dblock lk;\n                Client::Context ctx( ns() );\n                setQueryOptimizerCursor( BSON( \"_id\" << GT << 0 ) );\n                ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                ASSERT( prepareToYield() );",
        "res_region": "        };\n        \n        /** Yield and drop collection. */\n        class Drop : public Base {\n        public:\n            void run() {\n                _cli.insert( ns(), BSON( \"_id\" << 1 ) );\n                _cli.insert( ns(), BSON( \"_id\" << 2 ) );\n                \n                {\n                    Lock::GlobalWrite lk;\n\n                    Client::Context ctx( ns() );\n                    setQueryOptimizerCursor( BSON( \"_id\" << GT << 0 ) );\n                    ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                    prepareToYield();\n                }\n                \n                _cli.dropCollection( ns() );\n                \n                {\n                    Lock::GlobalWrite lk;\n\n                    Client::Context ctx( ns() );\n                    recoverFromYield();\n                    ASSERT( !ok() );\n                }                ",
        "lookback": "        ",
        "lookahead": "            }",
        "label": [
            "newcode",
            "complex_conflict"
        ],
        "start_line": 1328,
        "end_line": 1388,
        "merge_gen_region": null,
        "confidence": 0.49507153034210205,
        "hesitated": true
    },
    {
        "a_contents": "            \n            _cli.remove( ns(), BSON( \"_id\" << 1 ) );\n            \n            {\n                Lock::GlobalWrite lk;\n                Client::Context ctx( ns() );\n                recoverFromYield();\n                ASSERT( ok() );\n                ASSERT_EQUALS( 2, current().getIntField( \"_id\" ) );\n                ASSERT( !advance() );\n                ASSERT( !ok() );",
        "b_contents": "        };\n        \n        /** Yield and drop collection with $or query. */\n        class DropOr : public Base {\n        public:\n            void run() {\n                _cli.insert( ns(), BSON( \"_id\" << 1 ) );\n                _cli.insert( ns(), BSON( \"_id\" << 2 ) );\n                \n                {\n                    dblock lk;\n                    Client::Context ctx( ns() );\n                    setQueryOptimizerCursor( BSON( \"$or\" << BSON_ARRAY( BSON( \"_id\" << 1 ) << BSON( \"_id\" << 2 ) ) ) );\n                    ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                    prepareToYield();\n                }\n                \n                _cli.dropCollection( ns() );\n                \n                {\n                    dblock lk;\n                    Client::Context ctx( ns() );\n                    ASSERT_THROWS( recoverFromYield(), MsgAssertionException );\n                    ASSERT( !ok() );\n                }                ",
        "base_contents": "            \n            _cli.remove( ns(), BSON( \"_id\" << 1 ) );\n            \n            {\n                dblock lk;\n                Client::Context ctx( ns() );\n                recoverFromYield();\n                ASSERT( ok() );\n                ASSERT_EQUALS( 2, current().getIntField( \"_id\" ) );\n                ASSERT( !advance() );\n                ASSERT( !ok() );",
        "res_region": "        };\n        \n        /** Yield and drop collection with $or query. */\n        class DropOr : public Base {\n        public:\n            void run() {\n                _cli.insert( ns(), BSON( \"_id\" << 1 ) );\n                _cli.insert( ns(), BSON( \"_id\" << 2 ) );\n                \n                {\n                    Lock::GlobalWrite lk;\n\n                    Client::Context ctx( ns() );\n                    setQueryOptimizerCursor( BSON( \"$or\" << BSON_ARRAY( BSON( \"_id\" << 1 ) << BSON( \"_id\" << 2 ) ) ) );\n                    ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                    prepareToYield();\n                }\n                \n                _cli.dropCollection( ns() );\n                \n                {\n                    Lock::GlobalWrite lk;\n\n                    Client::Context ctx( ns() );\n                    ASSERT_THROWS( recoverFromYield(), MsgAssertionException );\n                    ASSERT( !ok() );\n                }                ",
        "lookback": "        ",
        "lookahead": "            }",
        "label": [
            "newcode",
            "complex_conflict"
        ],
        "start_line": 1390,
        "end_line": 1440,
        "merge_gen_region": null,
        "confidence": 0.5290629863739014,
        "hesitated": true
    },
    {
        "a_contents": "        }            \n    };\n    \n    /** Yield cursor and delete current entry, then continue iteration. */\n    class YieldDeleteContinueFurther : public Base {\n    public:\n        void run() {\n            _cli.insert( ns(), BSON( \"_id\" << 1 ) );\n            _cli.insert( ns(), BSON( \"_id\" << 2 ) );\n            _cli.insert( ns(), BSON( \"_id\" << 3 ) );\n            \n            {\n                Lock::GlobalWrite lk;\n                Client::Context ctx( ns() );\n                setQueryOptimizerCursor( BSON( \"_id\" << GT << 0 ) );\n                ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                ASSERT( prepareToYield() );",
        "b_contents": "        };\n        \n        /** Yield and remove document with $or query. */\n        class RemoveOr : public Base {\n        public:\n            void run() {\n                _cli.insert( ns(), BSON( \"_id\" << 1 ) );\n                _cli.insert( ns(), BSON( \"_id\" << 2 ) );\n\n                {\n                    dblock lk;\n                    Client::Context ctx( ns() );\n                    setQueryOptimizerCursor( BSON( \"$or\" << BSON_ARRAY( BSON( \"_id\" << 1 ) << BSON( \"_id\" << 2 ) ) ) );\n                    ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                    prepareToYield();\n                }\n\n                _cli.remove( ns(), BSON( \"_id\" << 1 ) );\n\n                {\n                    dblock lk;\n                    Client::Context ctx( ns() );\n                    recoverFromYield();\n                    ASSERT( ok() );\n                    ASSERT_EQUALS( 2, current().getIntField( \"_id\" ) );\n                }",
        "base_contents": "        }            \n    };\n    \n    /** Yield cursor and delete current entry, then continue iteration. */\n    class YieldDeleteContinueFurther : public Base {\n    public:\n        void run() {\n            _cli.insert( ns(), BSON( \"_id\" << 1 ) );\n            _cli.insert( ns(), BSON( \"_id\" << 2 ) );\n            _cli.insert( ns(), BSON( \"_id\" << 3 ) );\n            \n            {\n                dblock lk;\n                Client::Context ctx( ns() );\n                setQueryOptimizerCursor( BSON( \"_id\" << GT << 0 ) );\n                ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                ASSERT( prepareToYield() );",
        "res_region": "        };\n        \n        /** Yield and remove document with $or query. */\n        class RemoveOr : public Base {\n        public:\n            void run() {\n                _cli.insert( ns(), BSON( \"_id\" << 1 ) );\n                _cli.insert( ns(), BSON( \"_id\" << 2 ) );\n\n                {\n                    Lock::GlobalWrite lk;\n\n                    Client::Context ctx( ns() );\n                    setQueryOptimizerCursor( BSON( \"$or\" << BSON_ARRAY( BSON( \"_id\" << 1 ) << BSON( \"_id\" << 2 ) ) ) );\n                    ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                    prepareToYield();\n                }\n\n                _cli.remove( ns(), BSON( \"_id\" << 1 ) );\n\n                {\n                    Lock::GlobalWrite lk;\n\n                    Client::Context ctx( ns() );\n                    recoverFromYield();\n                    ASSERT( ok() );\n                    ASSERT_EQUALS( 2, current().getIntField( \"_id\" ) );\n                }",
        "lookback": "        ",
        "lookahead": "            }",
        "label": [
            "newcode",
            "complex_conflict"
        ],
        "start_line": 1442,
        "end_line": 1505,
        "merge_gen_region": null,
        "confidence": 0.554636538028717,
        "hesitated": true
    },
    {
        "a_contents": "            \n            _cli.remove( ns(), BSON( \"_id\" << 1 ) );\n            \n            {\n                Lock::GlobalWrite lk;\n                Client::Context ctx( ns() );\n                recoverFromYield();\n                ASSERT( ok() );\n                ASSERT_EQUALS( 2, current().getIntField( \"_id\" ) );\n                ASSERT( advance() );\n                ASSERT_EQUALS( 3, current().getIntField( \"_id\" ) );\n                ASSERT( !advance() );\n                ASSERT( !ok() );",
        "b_contents": "        };\n\n        /** Yield and overwrite current in capped collection. */\n        class CappedOverwrite : public Base {\n        public:\n            void run() {\n                _cli.createCollection( ns(), 1000, true );\n                _cli.insert( ns(), BSON( \"x\" << 1 ) );\n                \n                {\n                    dblock lk;\n                    Client::Context ctx( ns() );\n                    setQueryOptimizerCursor( BSON( \"x\" << GT << 0 ) );\n                    ASSERT_EQUALS( 1, current().getIntField( \"x\" ) );\n                    prepareToYield();\n                }\n                \n                int x = 2;\n                while( _cli.count( ns(), BSON( \"x\" << 1 ) ) > 0 ) {\n                    _cli.insert( ns(), BSON( \"x\" << x++ ) );   \n                }\n                \n                {\n                    dblock lk;\n                    Client::Context ctx( ns() );\n                    ASSERT_THROWS( recoverFromYield(), MsgAssertionException );\n                    ASSERT( !ok() );\n                }                ",
        "base_contents": "            \n            _cli.remove( ns(), BSON( \"_id\" << 1 ) );\n            \n            {\n                dblock lk;\n                Client::Context ctx( ns() );\n                recoverFromYield();\n                ASSERT( ok() );\n                ASSERT_EQUALS( 2, current().getIntField( \"_id\" ) );\n                ASSERT( advance() );\n                ASSERT_EQUALS( 3, current().getIntField( \"_id\" ) );\n                ASSERT( !advance() );\n                ASSERT( !ok() );",
        "res_region": "        };\n\n        /** Yield and overwrite current in capped collection. */\n        class CappedOverwrite : public Base {\n        public:\n            void run() {\n                _cli.createCollection( ns(), 1000, true );\n                _cli.insert( ns(), BSON( \"x\" << 1 ) );\n                \n                {\n                    Lock::GlobalWrite lk;\n\n                    Client::Context ctx( ns() );\n                    setQueryOptimizerCursor( BSON( \"x\" << GT << 0 ) );\n                    ASSERT_EQUALS( 1, current().getIntField( \"x\" ) );\n                    prepareToYield();\n                }\n                \n                int x = 2;\n                while( _cli.count( ns(), BSON( \"x\" << 1 ) ) > 0 ) {\n                    _cli.insert( ns(), BSON( \"x\" << x++ ) );   \n                }\n                \n                {\n                    Lock::GlobalWrite lk;\n\n                    Client::Context ctx( ns() );\n                    ASSERT_THROWS( recoverFromYield(), MsgAssertionException );\n                    ASSERT( !ok() );\n                }                ",
        "lookback": "",
        "lookahead": "            }",
        "label": [
            "newcode",
            "complex_conflict"
        ],
        "start_line": 1507,
        "end_line": 1564,
        "merge_gen_region": null,
        "confidence": 0.4512103199958801,
        "hesitated": true
    },
    {
        "a_contents": "        }            \n    };\n    \n    /** Yield and update current. */\n    class YieldUpdate : public Base {\n    public:\n        void run() {\n            _cli.insert( ns(), BSON( \"a\" << 1 ) );\n            _cli.insert( ns(), BSON( \"a\" << 2 ) );\n            _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n            \n            {\n                Lock::GlobalWrite lk;\n                Client::Context ctx( ns() );\n                setQueryOptimizerCursor( BSON( \"a\" << GT << 0 ) );\n                ASSERT_EQUALS( 1, current().getIntField( \"a\" ) );\n                ASSERT( prepareToYield() );\n            }\n            \n            _cli.update( ns(), BSON( \"a\" << 1 ), BSON( \"$set\" << BSON( \"a\" << 3 ) ) );\n            \n            {\n                Lock::GlobalWrite lk;\n                Client::Context ctx( ns() );\n                recoverFromYield();\n                ASSERT( ok() );\n                ASSERT_EQUALS( 2, current().getIntField( \"a\" ) );\n                ASSERT( !advance() );\n                ASSERT( !ok() );\n            }                \n        }\n    };\n    \n    /** Yield and drop collection. */\n    class YieldDrop : public Base {\n    public:\n        void run() {\n            _cli.insert( ns(), BSON( \"_id\" << 1 ) );\n            _cli.insert( ns(), BSON( \"_id\" << 2 ) );\n            \n            {\n                Lock::GlobalWrite lk;\n                Client::Context ctx( ns() );\n                setQueryOptimizerCursor( BSON( \"_id\" << GT << 0 ) );\n                ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                ASSERT( prepareToYield() );\n            }\n            \n            _cli.dropCollection( ns() );\n            \n            {\n                Lock::GlobalWrite lk;\n                Client::Context ctx( ns() );\n                recoverFromYield();\n                ASSERT( !ok() );\n            }                \n        }\n    };\n    \n    /** Yield and drop collection with $or query. */\n    class YieldDropOr : public Base {\n    public:\n        void run() {\n            _cli.insert( ns(), BSON( \"_id\" << 1 ) );\n            _cli.insert( ns(), BSON( \"_id\" << 2 ) );\n            \n            {\n                Lock::GlobalWrite lk;\n                Client::Context ctx( ns() );\n                setQueryOptimizerCursor( BSON( \"$or\" << BSON_ARRAY( BSON( \"_id\" << 1 ) << BSON( \"_id\" << 2 ) ) ) );\n                ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                ASSERT( prepareToYield() );\n            }\n            \n            _cli.dropCollection( ns() );\n            \n            {\n                Lock::GlobalWrite lk;\n                Client::Context ctx( ns() );\n                ASSERT_THROWS( recoverFromYield(), MsgAssertionException );\n                ASSERT( !ok() );\n            }                \n        }\n    };\n    \n    /** Yield and remove document with $or query. */\n    class YieldRemoveOr : public Base {\n    public:\n        void run() {\n            _cli.insert( ns(), BSON( \"_id\" << 1 ) );\n            _cli.insert( ns(), BSON( \"_id\" << 2 ) );\n\n            {\n                Lock::GlobalWrite lk;\n                Client::Context ctx( ns() );\n                setQueryOptimizerCursor( BSON( \"$or\" << BSON_ARRAY( BSON( \"_id\" << 1 ) << BSON( \"_id\" << 2 ) ) ) );\n                ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                ASSERT( prepareToYield() );\n            }\n\n            _cli.remove( ns(), BSON( \"_id\" << 1 ) );\n\n            {\n                Lock::GlobalWrite lk;\n                Client::Context ctx( ns() );\n                recoverFromYield();\n                ASSERT( ok() );\n                ASSERT_EQUALS( 2, current().getIntField( \"_id\" ) );\n            }\n        }\n    };\n\n    /** Yield and overwrite current in capped collection. */\n    class YieldCappedOverwrite : public Base {\n    public:\n        void run() {\n            _cli.createCollection( ns(), 1000, true );\n            _cli.insert( ns(), BSON( \"x\" << 1 ) );\n            \n            {\n                Lock::GlobalWrite lk;\n                Client::Context ctx( ns() );\n                setQueryOptimizerCursor( BSON( \"x\" << GT << 0 ) );\n                ASSERT_EQUALS( 1, current().getIntField( \"x\" ) );\n                ASSERT( prepareToYield() );\n            }\n            \n            int x = 2;\n            while( _cli.count( ns(), BSON( \"x\" << 1 ) ) > 0 ) {\n                _cli.insert( ns(), BSON( \"x\" << x++ ) );   \n            }\n            \n            {\n                Lock::GlobalWrite lk;\n                Client::Context ctx( ns() );\n                ASSERT_THROWS( recoverFromYield(), MsgAssertionException );\n                ASSERT( !ok() );\n            }                \n        }\n    };\n    \n    /** Yield and drop unrelated index - see SERVER-2454. */\n    class YieldDropIndex : public Base {\n    public:\n        void run() {\n            _cli.insert( ns(), BSON( \"_id\" << 1 ) );\n            _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n            \n            {\n                Lock::GlobalWrite lk;\n                Client::Context ctx( ns() );\n                setQueryOptimizerCursor( BSON( \"_id\" << 1 ) );\n                ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                ASSERT( prepareToYield() );\n            }\n            \n            _cli.dropIndex( ns(), BSON( \"a\" << 1 ) );\n            \n            {\n                Lock::GlobalWrite lk;\n                Client::Context ctx( ns() );\n                recoverFromYield();\n                ASSERT( !ok() );\n            }                \n        }\n    };\n    \n    /** Yielding with multiple plans active. */\n    class YieldMultiplePlansNoOp : public Base {\n    public:\n        void run() {\n            _cli.insert( ns(), BSON( \"_id\" << 1 << \"a\" << 2 ) );\n            _cli.insert( ns(), BSON( \"_id\" << 2 << \"a\" << 1 ) );\n            _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n            \n            {\n                Lock::GlobalWrite lk;\n                Client::Context ctx( ns() );\n                setQueryOptimizerCursor( BSON( \"_id\" << GT << 0 << \"a\" << GT << 0 ) );\n                ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                ASSERT( prepareToYield() );\n            }\n            \n            {\n                Lock::GlobalWrite lk;\n                Client::Context ctx( ns() );\n                recoverFromYield();\n                ASSERT( ok() );\n                ASSERT_EQUALS( 2, current().getIntField( \"_id\" ) );\n                ASSERT( !advance() );\n                ASSERT( !ok() );\n            }                \n        }\n    };\n    \n    /** Yielding with advance and multiple plans active. */\n    class YieldMultiplePlansAdvanceNoOp : public Base {\n    public:\n        void run() {\n            _cli.insert( ns(), BSON( \"_id\" << 1 << \"a\" << 2 ) );\n            _cli.insert( ns(), BSON( \"_id\" << 2 << \"a\" << 1 ) );\n            _cli.insert( ns(), BSON( \"_id\" << 3 << \"a\" << 3 ) );\n            _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n            \n            {\n                Lock::GlobalWrite lk;\n                Client::Context ctx( ns() );\n                setQueryOptimizerCursor( BSON( \"_id\" << GT << 0 << \"a\" << GT << 0 ) );\n                ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                advance();\n                ASSERT_EQUALS( 2, current().getIntField( \"_id\" ) );\n                ASSERT( prepareToYield() );\n            }\n            \n            {\n                Lock::GlobalWrite lk;\n                Client::Context ctx( ns() );\n                recoverFromYield();\n                ASSERT( ok() );\n                ASSERT_EQUALS( 3, current().getIntField( \"_id\" ) );\n                ASSERT( !advance() );\n                ASSERT( !ok() );\n            }                \n        }\n    };\n    \n    /** Yielding with delete and multiple plans active. */\n    class YieldMultiplePlansDelete : public Base {\n    public:\n        void run() {\n            _cli.insert( ns(), BSON( \"_id\" << 1 << \"a\" << 2 ) );\n            _cli.insert( ns(), BSON( \"_id\" << 2 << \"a\" << 1 ) );\n            _cli.insert( ns(), BSON( \"_id\" << 3 << \"a\" << 4 ) );\n            _cli.insert( ns(), BSON( \"_id\" << 4 << \"a\" << 3 ) );\n            _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n            \n            {\n                Lock::GlobalWrite lk;\n                Client::Context ctx( ns() );\n                setQueryOptimizerCursor( BSON( \"_id\" << GT << 0 << \"a\" << GT << 0 ) );\n                ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                advance();\n                ASSERT_EQUALS( 2, current().getIntField( \"_id\" ) );\n                ASSERT( prepareToYield() );\n            }\n            \n            _cli.remove( ns(), BSON( \"_id\" << 2 ) );\n            \n            {\n                Lock::GlobalWrite lk;\n                Client::Context ctx( ns() );\n                c()->recoverFromYield();\n                ASSERT( ok() );\n                // index {a:1} active during yield\n                ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                ASSERT( advance() );\n                ASSERT_EQUALS( 3, current().getIntField( \"_id\" ) );\n                ASSERT( advance() );\n                ASSERT_EQUALS( 4, current().getIntField( \"_id\" ) );\n                ASSERT( !advance() );\n                ASSERT( !ok() );\n            }                \n        }\n    };\n\n    /** Yielding with delete, multiple plans active, and $or clause. */\n    class YieldMultiplePlansDeleteOr : public Base {\n    public:\n        void run() {\n            _cli.insert( ns(), BSON( \"_id\" << 1 << \"a\" << 2 ) );\n            _cli.insert( ns(), BSON( \"_id\" << 2 << \"a\" << 1 ) );\n            _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n\n            {\n                Lock::GlobalWrite lk;\n                Client::Context ctx( ns() );\n                setQueryOptimizerCursor( BSON( \"$or\" << BSON_ARRAY( BSON( \"_id\" << 1 << \"a\" << 2 ) << BSON( \"_id\" << 2 << \"a\" << 1 ) ) ) );\n                ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                ASSERT( prepareToYield() );\n            }\n\n            _cli.remove( ns(), BSON( \"_id\" << 1 ) );\n\n            {\n                Lock::GlobalWrite lk;\n                Client::Context ctx( ns() );\n                c()->recoverFromYield();\n                ASSERT( ok() );\n                ASSERT_EQUALS( 2, current().getIntField( \"_id\" ) );\n                ASSERT( !advance() );\n                ASSERT( !ok() );\n            }\n        }\n    };\n    \n    /** Yielding with delete, multiple plans active with advancement to the second, and $or clause. */\n    class YieldMultiplePlansDeleteOrAdvance : public Base {\n    public:\n        void run() {\n            _cli.insert( ns(), BSON( \"_id\" << 1 << \"a\" << 2 ) );\n            _cli.insert( ns(), BSON( \"_id\" << 2 << \"a\" << 1 ) );\n            _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n\n            {\n                Lock::GlobalWrite lk;\n                Client::Context ctx( ns() );\n                setQueryOptimizerCursor( BSON( \"$or\" << BSON_ARRAY( BSON( \"_id\" << 1 << \"a\" << 2 ) << BSON( \"_id\" << 2 << \"a\" << 1 ) ) ) );\n                ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                ASSERT( prepareToYield() );\n                c()->advance();\n                ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n            }\n\n            _cli.remove( ns(), BSON( \"_id\" << 1 ) );\n\n            {\n                Lock::GlobalWrite lk;\n                Client::Context ctx( ns() );\n                c()->recoverFromYield();\n                ASSERT( ok() );\n                ASSERT_EQUALS( 2, current().getIntField( \"_id\" ) );\n                ASSERT( !advance() );\n                ASSERT( !ok() );\n            }\n        }\n    };\n\n    /** Yielding with multiple plans and capped overwrite. */\n    class YieldMultiplePlansCappedOverwrite : public Base {\n    public:\n        void run() {\n            _cli.createCollection( ns(), 1000, true );\n            _cli.insert( ns(), BSON( \"_id\" << 1 << \"a\" << 1 ) );\n            _cli.ensureIndex( ns(), BSON( \"_id\" << 1 ) );\n            \n            {\n                Lock::GlobalWrite lk;\n                Client::Context ctx( ns() );\n                setQueryOptimizerCursor( BSON( \"_id\" << GT << 0 << \"a\" << GT << 0 ) );\n                ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                ASSERT( prepareToYield() );",
        "b_contents": "        };\n        \n        /** Yield and drop unrelated index - see SERVER-2454. */\n        class DropIndex : public Base {\n        public:\n            void run() {\n                _cli.insert( ns(), BSON( \"_id\" << 1 ) );\n                _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n                \n                {\n                    dblock lk;\n                    Client::Context ctx( ns() );\n                    setQueryOptimizerCursor( BSON( \"_id\" << 1 ) );\n                    ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                    prepareToYield();\n                }\n                \n                _cli.dropIndex( ns(), BSON( \"a\" << 1 ) );\n                \n                {\n                    dblock lk;\n                    Client::Context ctx( ns() );\n                    recoverFromYield();\n                    ASSERT( !ok() );\n                }                ",
        "base_contents": "        }            \n    };\n    \n    /** Yield and update current. */\n    class YieldUpdate : public Base {\n    public:\n        void run() {\n            _cli.insert( ns(), BSON( \"a\" << 1 ) );\n            _cli.insert( ns(), BSON( \"a\" << 2 ) );\n            _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n            \n            {\n                dblock lk;\n                Client::Context ctx( ns() );\n                setQueryOptimizerCursor( BSON( \"a\" << GT << 0 ) );\n                ASSERT_EQUALS( 1, current().getIntField( \"a\" ) );\n                ASSERT( prepareToYield() );\n            }\n            \n            _cli.update( ns(), BSON( \"a\" << 1 ), BSON( \"$set\" << BSON( \"a\" << 3 ) ) );\n            \n            {\n                dblock lk;\n                Client::Context ctx( ns() );\n                recoverFromYield();\n                ASSERT( ok() );\n                ASSERT_EQUALS( 2, current().getIntField( \"a\" ) );\n                ASSERT( !advance() );\n                ASSERT( !ok() );\n            }                \n        }\n    };\n    \n    /** Yield and drop collection. */\n    class YieldDrop : public Base {\n    public:\n        void run() {\n            _cli.insert( ns(), BSON( \"_id\" << 1 ) );\n            _cli.insert( ns(), BSON( \"_id\" << 2 ) );\n            \n            {\n                dblock lk;\n                Client::Context ctx( ns() );\n                setQueryOptimizerCursor( BSON( \"_id\" << GT << 0 ) );\n                ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                ASSERT( prepareToYield() );\n            }\n            \n            _cli.dropCollection( ns() );\n            \n            {\n                dblock lk;\n                Client::Context ctx( ns() );\n                recoverFromYield();\n                ASSERT( !ok() );\n            }                \n        }\n    };\n    \n    /** Yield and drop collection with $or query. */\n    class YieldDropOr : public Base {\n    public:\n        void run() {\n            _cli.insert( ns(), BSON( \"_id\" << 1 ) );\n            _cli.insert( ns(), BSON( \"_id\" << 2 ) );\n            \n            {\n                dblock lk;\n                Client::Context ctx( ns() );\n                setQueryOptimizerCursor( BSON( \"$or\" << BSON_ARRAY( BSON( \"_id\" << 1 ) << BSON( \"_id\" << 2 ) ) ) );\n                ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                ASSERT( prepareToYield() );\n            }\n            \n            _cli.dropCollection( ns() );\n            \n            {\n                dblock lk;\n                Client::Context ctx( ns() );\n                ASSERT_THROWS( recoverFromYield(), MsgAssertionException );\n                ASSERT( !ok() );\n            }                \n        }\n    };\n    \n    /** Yield and remove document with $or query. */\n    class YieldRemoveOr : public Base {\n    public:\n        void run() {\n            _cli.insert( ns(), BSON( \"_id\" << 1 ) );\n            _cli.insert( ns(), BSON( \"_id\" << 2 ) );\n\n            {\n                dblock lk;\n                Client::Context ctx( ns() );\n                setQueryOptimizerCursor( BSON( \"$or\" << BSON_ARRAY( BSON( \"_id\" << 1 ) << BSON( \"_id\" << 2 ) ) ) );\n                ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                ASSERT( prepareToYield() );\n            }\n\n            _cli.remove( ns(), BSON( \"_id\" << 1 ) );\n\n            {\n                dblock lk;\n                Client::Context ctx( ns() );\n                recoverFromYield();\n                ASSERT( ok() );\n                ASSERT_EQUALS( 2, current().getIntField( \"_id\" ) );\n            }\n        }\n    };\n\n    /** Yield and overwrite current in capped collection. */\n    class YieldCappedOverwrite : public Base {\n    public:\n        void run() {\n            _cli.createCollection( ns(), 1000, true );\n            _cli.insert( ns(), BSON( \"x\" << 1 ) );\n            \n            {\n                dblock lk;\n                Client::Context ctx( ns() );\n                setQueryOptimizerCursor( BSON( \"x\" << GT << 0 ) );\n                ASSERT_EQUALS( 1, current().getIntField( \"x\" ) );\n                ASSERT( prepareToYield() );\n            }\n            \n            int x = 2;\n            while( _cli.count( ns(), BSON( \"x\" << 1 ) ) > 0 ) {\n                _cli.insert( ns(), BSON( \"x\" << x++ ) );   \n            }\n            \n            {\n                dblock lk;\n                Client::Context ctx( ns() );\n                ASSERT_THROWS( recoverFromYield(), MsgAssertionException );\n                ASSERT( !ok() );\n            }                \n        }\n    };\n    \n    /** Yield and drop unrelated index - see SERVER-2454. */\n    class YieldDropIndex : public Base {\n    public:\n        void run() {\n            _cli.insert( ns(), BSON( \"_id\" << 1 ) );\n            _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n            \n            {\n                dblock lk;\n                Client::Context ctx( ns() );\n                setQueryOptimizerCursor( BSON( \"_id\" << 1 ) );\n                ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                ASSERT( prepareToYield() );\n            }\n            \n            _cli.dropIndex( ns(), BSON( \"a\" << 1 ) );\n            \n            {\n                dblock lk;\n                Client::Context ctx( ns() );\n                recoverFromYield();\n                ASSERT( !ok() );\n            }                \n        }\n    };\n    \n    /** Yielding with multiple plans active. */\n    class YieldMultiplePlansNoOp : public Base {\n    public:\n        void run() {\n            _cli.insert( ns(), BSON( \"_id\" << 1 << \"a\" << 2 ) );\n            _cli.insert( ns(), BSON( \"_id\" << 2 << \"a\" << 1 ) );\n            _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n            \n            {\n                dblock lk;\n                Client::Context ctx( ns() );\n                setQueryOptimizerCursor( BSON( \"_id\" << GT << 0 << \"a\" << GT << 0 ) );\n                ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                ASSERT( prepareToYield() );\n            }\n            \n            {\n                dblock lk;\n                Client::Context ctx( ns() );\n                recoverFromYield();\n                ASSERT( ok() );\n                ASSERT_EQUALS( 2, current().getIntField( \"_id\" ) );\n                ASSERT( !advance() );\n                ASSERT( !ok() );\n            }                \n        }\n    };\n    \n    /** Yielding with advance and multiple plans active. */\n    class YieldMultiplePlansAdvanceNoOp : public Base {\n    public:\n        void run() {\n            _cli.insert( ns(), BSON( \"_id\" << 1 << \"a\" << 2 ) );\n            _cli.insert( ns(), BSON( \"_id\" << 2 << \"a\" << 1 ) );\n            _cli.insert( ns(), BSON( \"_id\" << 3 << \"a\" << 3 ) );\n            _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n            \n            {\n                dblock lk;\n                Client::Context ctx( ns() );\n                setQueryOptimizerCursor( BSON( \"_id\" << GT << 0 << \"a\" << GT << 0 ) );\n                ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                advance();\n                ASSERT_EQUALS( 2, current().getIntField( \"_id\" ) );\n                ASSERT( prepareToYield() );\n            }\n            \n            {\n                dblock lk;\n                Client::Context ctx( ns() );\n                recoverFromYield();\n                ASSERT( ok() );\n                ASSERT_EQUALS( 3, current().getIntField( \"_id\" ) );\n                ASSERT( !advance() );\n                ASSERT( !ok() );\n            }                \n        }\n    };\n    \n    /** Yielding with delete and multiple plans active. */\n    class YieldMultiplePlansDelete : public Base {\n    public:\n        void run() {\n            _cli.insert( ns(), BSON( \"_id\" << 1 << \"a\" << 2 ) );\n            _cli.insert( ns(), BSON( \"_id\" << 2 << \"a\" << 1 ) );\n            _cli.insert( ns(), BSON( \"_id\" << 3 << \"a\" << 4 ) );\n            _cli.insert( ns(), BSON( \"_id\" << 4 << \"a\" << 3 ) );\n            _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n            \n            {\n                dblock lk;\n                Client::Context ctx( ns() );\n                setQueryOptimizerCursor( BSON( \"_id\" << GT << 0 << \"a\" << GT << 0 ) );\n                ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                advance();\n                ASSERT_EQUALS( 2, current().getIntField( \"_id\" ) );\n                ASSERT( prepareToYield() );\n            }\n            \n            _cli.remove( ns(), BSON( \"_id\" << 2 ) );\n            \n            {\n                dblock lk;\n                Client::Context ctx( ns() );\n                c()->recoverFromYield();\n                ASSERT( ok() );\n                // index {a:1} active during yield\n                ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                ASSERT( advance() );\n                ASSERT_EQUALS( 3, current().getIntField( \"_id\" ) );\n                ASSERT( advance() );\n                ASSERT_EQUALS( 4, current().getIntField( \"_id\" ) );\n                ASSERT( !advance() );\n                ASSERT( !ok() );\n            }                \n        }\n    };\n\n    /** Yielding with delete, multiple plans active, and $or clause. */\n    class YieldMultiplePlansDeleteOr : public Base {\n    public:\n        void run() {\n            _cli.insert( ns(), BSON( \"_id\" << 1 << \"a\" << 2 ) );\n            _cli.insert( ns(), BSON( \"_id\" << 2 << \"a\" << 1 ) );\n            _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n\n            {\n                dblock lk;\n                Client::Context ctx( ns() );\n                setQueryOptimizerCursor( BSON( \"$or\" << BSON_ARRAY( BSON( \"_id\" << 1 << \"a\" << 2 ) << BSON( \"_id\" << 2 << \"a\" << 1 ) ) ) );\n                ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                ASSERT( prepareToYield() );\n            }\n\n            _cli.remove( ns(), BSON( \"_id\" << 1 ) );\n\n            {\n                dblock lk;\n                Client::Context ctx( ns() );\n                c()->recoverFromYield();\n                ASSERT( ok() );\n                ASSERT_EQUALS( 2, current().getIntField( \"_id\" ) );\n                ASSERT( !advance() );\n                ASSERT( !ok() );\n            }\n        }\n    };\n    \n    /** Yielding with delete, multiple plans active with advancement to the second, and $or clause. */\n    class YieldMultiplePlansDeleteOrAdvance : public Base {\n    public:\n        void run() {\n            _cli.insert( ns(), BSON( \"_id\" << 1 << \"a\" << 2 ) );\n            _cli.insert( ns(), BSON( \"_id\" << 2 << \"a\" << 1 ) );\n            _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n\n            {\n                dblock lk;\n                Client::Context ctx( ns() );\n                setQueryOptimizerCursor( BSON( \"$or\" << BSON_ARRAY( BSON( \"_id\" << 1 << \"a\" << 2 ) << BSON( \"_id\" << 2 << \"a\" << 1 ) ) ) );\n                ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                ASSERT( prepareToYield() );\n                c()->advance();\n                ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n            }\n\n            _cli.remove( ns(), BSON( \"_id\" << 1 ) );\n\n            {\n                dblock lk;\n                Client::Context ctx( ns() );\n                c()->recoverFromYield();\n                ASSERT( ok() );\n                ASSERT_EQUALS( 2, current().getIntField( \"_id\" ) );\n                ASSERT( !advance() );\n                ASSERT( !ok() );\n            }\n        }\n    };\n\n    /** Yielding with multiple plans and capped overwrite. */\n    class YieldMultiplePlansCappedOverwrite : public Base {\n    public:\n        void run() {\n            _cli.createCollection( ns(), 1000, true );\n            _cli.insert( ns(), BSON( \"_id\" << 1 << \"a\" << 1 ) );\n            _cli.ensureIndex( ns(), BSON( \"_id\" << 1 ) );\n            \n            {\n                dblock lk;\n                Client::Context ctx( ns() );\n                setQueryOptimizerCursor( BSON( \"_id\" << GT << 0 << \"a\" << GT << 0 ) );\n                ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                ASSERT( prepareToYield() );",
        "res_region": "        };\n        \n        /** Yield and drop unrelated index - see SERVER-2454. */\n        class DropIndex : public Base {\n        public:\n            void run() {\n                _cli.insert( ns(), BSON( \"_id\" << 1 ) );\n                _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n                \n                {\n                    Lock::GlobalWrite lk;\n\n                    Client::Context ctx( ns() );\n                    setQueryOptimizerCursor( BSON( \"_id\" << 1 ) );\n                    ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                    prepareToYield();\n                }\n                \n                _cli.dropIndex( ns(), BSON( \"a\" << 1 ) );\n                \n                {\n                    Lock::GlobalWrite lk;\n\n                    Client::Context ctx( ns() );\n                    recoverFromYield();\n                    ASSERT( !ok() );\n                }                ",
        "lookback": "        ",
        "lookahead": "            }",
        "label": [
            "newcode",
            "complex_conflict"
        ],
        "start_line": 1566,
        "end_line": 2276,
        "merge_gen_region": null,
        "confidence": 0.5112181305885315,
        "hesitated": true
    },
    {
        "a_contents": "            \n            {\n                Lock::GlobalWrite lk;\n                Client::Context ctx( ns() );\n                recoverFromYield();\n                ASSERT( ok() );\n                // {$natural:1} plan does not recover, {_id:1} plan does.\n                ASSERT( 1 < current().getIntField( \"_id\" ) );\n            }                \n        }\n    };\n    \n    /**\n     * Yielding with multiple plans and capped overwrite with unrecoverable cursor\n     * active at time of yield.\n     */\n    class YieldMultiplePlansCappedOverwriteManual : public Base {\n    public:\n        void run() {\n            _cli.createCollection( ns(), 1000, true );\n            _cli.insert( ns(), BSON( \"a\" << 1 << \"b\" << 1 ) );\n            _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n            \n            shared_ptr<Cursor> c;\n            {\n                Lock::GlobalWrite lk;\n                Client::Context ctx( ns() );\n                c = newQueryOptimizerCursor( ns(), BSON( \"a\" << GT << 0 << \"b\" << GT << 0 ) );\n                ASSERT_EQUALS( 1, c->current().getIntField( \"a\" ) );\n                ASSERT( !c->getsetdup( c->currLoc() ) );\n                c->advance();\n                ASSERT_EQUALS( 1, c->current().getIntField( \"a\" ) );\n                ASSERT( c->getsetdup( c->currLoc() ) );\n                ASSERT( c->prepareToYield() );",
        "b_contents": "        };\n        \n        /** Yielding with advance and multiple plans active. */\n        class MultiplePlansAdvanceNoOp : public Base {\n        public:\n            void run() {\n                _cli.insert( ns(), BSON( \"_id\" << 1 << \"a\" << 2 ) );\n                _cli.insert( ns(), BSON( \"_id\" << 2 << \"a\" << 1 ) );\n                _cli.insert( ns(), BSON( \"_id\" << 3 << \"a\" << 3 ) );\n                _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n                \n                {\n                    dblock lk;\n                    Client::Context ctx( ns() );\n                    setQueryOptimizerCursor( BSON( \"_id\" << GT << 0 << \"a\" << GT << 0 ) );\n                    ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                    advance();\n                    ASSERT_EQUALS( 2, current().getIntField( \"_id\" ) );\n                    prepareToYield();\n                }\n                \n                {\n                    dblock lk;\n                    Client::Context ctx( ns() );\n                    recoverFromYield();\n                    ASSERT( ok() );\n                    ASSERT_EQUALS( 3, current().getIntField( \"_id\" ) );\n                    ASSERT( !advance() );\n                    ASSERT( !ok() );\n                }                ",
        "base_contents": "            \n            {\n                dblock lk;\n                Client::Context ctx( ns() );\n                recoverFromYield();\n                ASSERT( ok() );\n                // {$natural:1} plan does not recover, {_id:1} plan does.\n                ASSERT( 1 < current().getIntField( \"_id\" ) );\n            }                \n        }\n    };\n    \n    /**\n     * Yielding with multiple plans and capped overwrite with unrecoverable cursor\n     * active at time of yield.\n     */\n    class YieldMultiplePlansCappedOverwriteManual : public Base {\n    public:\n        void run() {\n            _cli.createCollection( ns(), 1000, true );\n            _cli.insert( ns(), BSON( \"a\" << 1 << \"b\" << 1 ) );\n            _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n            \n            shared_ptr<Cursor> c;\n            {\n                dblock lk;\n                Client::Context ctx( ns() );\n                c = newQueryOptimizerCursor( ns(), BSON( \"a\" << GT << 0 << \"b\" << GT << 0 ) );\n                ASSERT_EQUALS( 1, c->current().getIntField( \"a\" ) );\n                ASSERT( !c->getsetdup( c->currLoc() ) );\n                c->advance();\n                ASSERT_EQUALS( 1, c->current().getIntField( \"a\" ) );\n                ASSERT( c->getsetdup( c->currLoc() ) );\n                ASSERT( c->prepareToYield() );",
        "res_region": "        };\n        \n        /** Yielding with advance and multiple plans active. */\n        class MultiplePlansAdvanceNoOp : public Base {\n        public:\n            void run() {\n                _cli.insert( ns(), BSON( \"_id\" << 1 << \"a\" << 2 ) );\n                _cli.insert( ns(), BSON( \"_id\" << 2 << \"a\" << 1 ) );\n                _cli.insert( ns(), BSON( \"_id\" << 3 << \"a\" << 3 ) );\n                _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n                \n                {\n                    Lock::GlobalWrite lk;\n\n                    Client::Context ctx( ns() );\n                    setQueryOptimizerCursor( BSON( \"_id\" << GT << 0 << \"a\" << GT << 0 ) );\n                    ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                    advance();\n                    ASSERT_EQUALS( 2, current().getIntField( \"_id\" ) );\n                    prepareToYield();\n                }\n                \n                {\n                    Lock::GlobalWrite lk;\n\n                    Client::Context ctx( ns() );\n                    recoverFromYield();\n                    ASSERT( ok() );\n                    ASSERT_EQUALS( 3, current().getIntField( \"_id\" ) );\n                    ASSERT( !advance() );\n                    ASSERT( !ok() );\n                }                ",
        "lookback": "        ",
        "lookahead": "            }",
        "label": [
            "newcode",
            "complex_conflict"
        ],
        "start_line": 2306,
        "end_line": 2407,
        "merge_gen_region": null,
        "confidence": 0.4312879145145416,
        "hesitated": true
    },
    {
        "a_contents": "            \n            {\n                Lock::GlobalWrite lk;\n                Client::Context ctx( ns() );\n                c->recoverFromYield();\n                ASSERT( c->ok() );\n                // {$natural:1} plan does not recover, {_id:1} plan does.\n                ASSERT( 1 < c->current().getIntField( \"a\" ) );\n            }                \n        }\n    };\n    \n    /**\n     * Yielding with multiple plans and capped overwrite with unrecoverable cursor\n     * inctive at time of yield.\n     */\n    class YieldMultiplePlansCappedOverwriteManual2 : public Base {\n    public:\n        void run() {\n            _cli.createCollection( ns(), 1000, true );\n            _cli.insert( ns(), BSON( \"_id\" << 1 << \"a\" << 1 ) );\n            _cli.ensureIndex( ns(), BSON( \"_id\" << 1 ) );\n            \n            shared_ptr<Cursor> c;\n            {\n                Lock::GlobalWrite lk;\n                Client::Context ctx( ns() );\n                c = newQueryOptimizerCursor( ns(), BSON( \"_id\" << GT << 0 << \"a\" << GT << 0 ) );\n                ASSERT_EQUALS( 1, c->current().getIntField( \"_id\" ) );\n                ASSERT( !c->getsetdup( c->currLoc() ) );\n                ASSERT( c->prepareToYield() );",
        "b_contents": "        };\n\n        /** Yielding with delete, multiple plans active, and $or clause. */\n        class MultiplePlansDeleteOr : public Base {\n        public:\n            void run() {\n                _cli.insert( ns(), BSON( \"_id\" << 1 << \"a\" << 2 ) );\n                _cli.insert( ns(), BSON( \"_id\" << 2 << \"a\" << 1 ) );\n                _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n\n                {\n                    dblock lk;\n                    Client::Context ctx( ns() );\n                    setQueryOptimizerCursor( BSON( \"$or\" << BSON_ARRAY( BSON( \"_id\" << 1 << \"a\" << 2 ) << BSON( \"_id\" << 2 << \"a\" << 1 ) ) ) );\n                    ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                    prepareToYield();\n                }\n\n                _cli.remove( ns(), BSON( \"_id\" << 1 ) );\n\n                {\n                    dblock lk;\n                    Client::Context ctx( ns() );\n                    c()->recoverFromYield();\n                    ASSERT( ok() );\n                    ASSERT_EQUALS( 2, current().getIntField( \"_id\" ) );\n                    ASSERT( !advance() );\n                    ASSERT( !ok() );\n                }",
        "base_contents": "            \n            {\n                dblock lk;\n                Client::Context ctx( ns() );\n                c->recoverFromYield();\n                ASSERT( c->ok() );\n                // {$natural:1} plan does not recover, {_id:1} plan does.\n                ASSERT( 1 < c->current().getIntField( \"a\" ) );\n            }                \n        }\n    };\n    \n    /**\n     * Yielding with multiple plans and capped overwrite with unrecoverable cursor\n     * inctive at time of yield.\n     */\n    class YieldMultiplePlansCappedOverwriteManual2 : public Base {\n    public:\n        void run() {\n            _cli.createCollection( ns(), 1000, true );\n            _cli.insert( ns(), BSON( \"_id\" << 1 << \"a\" << 1 ) );\n            _cli.ensureIndex( ns(), BSON( \"_id\" << 1 ) );\n            \n            shared_ptr<Cursor> c;\n            {\n                dblock lk;\n                Client::Context ctx( ns() );\n                c = newQueryOptimizerCursor( ns(), BSON( \"_id\" << GT << 0 << \"a\" << GT << 0 ) );\n                ASSERT_EQUALS( 1, c->current().getIntField( \"_id\" ) );\n                ASSERT( !c->getsetdup( c->currLoc() ) );\n                ASSERT( c->prepareToYield() );",
        "res_region": "        };\n\n        /** Yielding with delete, multiple plans active, and $or clause. */\n        class MultiplePlansDeleteOr : public Base {\n        public:\n            void run() {\n                _cli.insert( ns(), BSON( \"_id\" << 1 << \"a\" << 2 ) );\n                _cli.insert( ns(), BSON( \"_id\" << 2 << \"a\" << 1 ) );\n                _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n\n                {\n                    Lock::GlobalWrite lk;\n\n                    Client::Context ctx( ns() );\n                    setQueryOptimizerCursor( BSON( \"$or\" << BSON_ARRAY( BSON( \"_id\" << 1 << \"a\" << 2 ) << BSON( \"_id\" << 2 << \"a\" << 1 ) ) ) );\n                    ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                    prepareToYield();\n                }\n\n                _cli.remove( ns(), BSON( \"_id\" << 1 ) );\n\n                {\n                    Lock::GlobalWrite lk;\n\n                    Client::Context ctx( ns() );\n                    c()->recoverFromYield();\n                    ASSERT( ok() );\n                    ASSERT_EQUALS( 2, current().getIntField( \"_id\" ) );\n                    ASSERT( !advance() );\n                    ASSERT( !ok() );\n                }",
        "lookback": "",
        "lookahead": "            }",
        "label": [
            "newcode",
            "complex_conflict"
        ],
        "start_line": 2448,
        "end_line": 2542,
        "merge_gen_region": null,
        "confidence": 0.4033277928829193,
        "hesitated": true
    },
    {
        "a_contents": "            \n            {\n                Lock::GlobalWrite lk;\n                Client::Context ctx( ns() );\n                c->recoverFromYield();\n                ASSERT( c->ok() );\n                // {$natural:1} plan does not recover, {_id:1} plan does.\n                ASSERT( 1 < c->current().getIntField( \"_id\" ) );\n                ASSERT( !c->getsetdup( c->currLoc() ) );\n                int i = c->current().getIntField( \"_id\" );\n                ASSERT( c->advance() );\n                ASSERT( c->getsetdup( c->currLoc() ) );\n                while( i < n ) {\n                    ASSERT( c->advance() );",
        "b_contents": "        };\n\n        /** Yielding with multiple plans and capped overwrite. */\n        class MultiplePlansCappedOverwrite : public Base {\n        public:\n            void run() {\n                _cli.createCollection( ns(), 1000, true );\n                _cli.insert( ns(), BSON( \"_id\" << 1 << \"a\" << 1 ) );\n                _cli.ensureIndex( ns(), BSON( \"_id\" << 1 ) );\n                \n                {\n                    dblock lk;\n                    Client::Context ctx( ns() );\n                    setQueryOptimizerCursor( BSON( \"_id\" << GT << 0 << \"a\" << GT << 0 ) );\n                    ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                    prepareToYield();\n                }\n                \n                int i = 1;\n                while( _cli.count( ns(), BSON( \"_id\" << 1 ) ) > 0 ) {",
        "base_contents": "            \n            {\n                dblock lk;\n                Client::Context ctx( ns() );\n                c->recoverFromYield();\n                ASSERT( c->ok() );\n                // {$natural:1} plan does not recover, {_id:1} plan does.\n                ASSERT( 1 < c->current().getIntField( \"_id\" ) );\n                ASSERT( !c->getsetdup( c->currLoc() ) );\n                int i = c->current().getIntField( \"_id\" );\n                ASSERT( c->advance() );\n                ASSERT( c->getsetdup( c->currLoc() ) );\n                while( i < n ) {\n                    ASSERT( c->advance() );",
        "res_region": "        };\n\n        /** Yielding with multiple plans and capped overwrite. */\n        class MultiplePlansCappedOverwrite : public Base {\n        public:\n            void run() {\n                _cli.createCollection( ns(), 1000, true );\n                _cli.insert( ns(), BSON( \"_id\" << 1 << \"a\" << 1 ) );\n                _cli.ensureIndex( ns(), BSON( \"_id\" << 1 ) );\n                \n                {\n                    Lock::GlobalWrite lk;\n\n                    Client::Context ctx( ns() );\n                    setQueryOptimizerCursor( BSON( \"_id\" << GT << 0 << \"a\" << GT << 0 ) );\n                    ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                    prepareToYield();\n                }\n                \n                int i = 1;\n                while( _cli.count( ns(), BSON( \"_id\" << 1 ) ) > 0 ) {",
        "lookback": "",
        "lookahead": "                    ++i;",
        "label": [
            "newcode",
            "complex_conflict"
        ],
        "start_line": 2576,
        "end_line": 2627,
        "merge_gen_region": null,
        "confidence": 0.4023018777370453,
        "hesitated": true
    },
    {
        "a_contents": "            _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n            \n            {\n                Lock::GlobalWrite lk;\n                Client::Context ctx( ns() );\n                setQueryOptimizerCursor( BSON( \"_id\" << GTE << 0 << \"a\" << GTE << 0 ) );\n                for( int i = 0; i < 120; ++i ) {\n                    ASSERT( advance() );",
        "b_contents": "        };\n        \n        /**\n         * Yielding with multiple plans and capped overwrite with unrecoverable cursor\n         * active at time of yield.\n         */\n        class MultiplePlansCappedOverwriteManual : public Base {\n        public:\n            void run() {\n                _cli.createCollection( ns(), 1000, true );\n                _cli.insert( ns(), BSON( \"a\" << 1 << \"b\" << 1 ) );\n                _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n                \n                shared_ptr<Cursor> c;\n                {\n                    dblock lk;\n                    Client::Context ctx( ns() );\n                    c = newQueryOptimizerCursor( ns(), BSON( \"a\" << GT << 0 << \"b\" << GT << 0 ) );\n                    ASSERT_EQUALS( 1, c->current().getIntField( \"a\" ) );\n                    ASSERT( !c->getsetdup( c->currLoc() ) );\n                    c->advance();\n                    ASSERT_EQUALS( 1, c->current().getIntField( \"a\" ) );\n                    ASSERT( c->getsetdup( c->currLoc() ) );\n                    c->prepareToYield();",
        "base_contents": "            _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n            \n            {\n                dblock lk;\n                Client::Context ctx( ns() );\n                setQueryOptimizerCursor( BSON( \"_id\" << GTE << 0 << \"a\" << GTE << 0 ) );\n                for( int i = 0; i < 120; ++i ) {\n                    ASSERT( advance() );",
        "res_region": "        };\n        \n        /**\n         * Yielding with multiple plans and capped overwrite with unrecoverable cursor\n         * active at time of yield.\n         */\n        class MultiplePlansCappedOverwriteManual : public Base {\n        public:\n            void run() {\n                _cli.createCollection( ns(), 1000, true );\n                _cli.insert( ns(), BSON( \"a\" << 1 << \"b\" << 1 ) );\n                _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n                \n                shared_ptr<Cursor> c;\n                {\n                    Lock::GlobalWrite lk;\n\n                    Client::Context ctx( ns() );\n                    c = newQueryOptimizerCursor( ns(), BSON( \"a\" << GT << 0 << \"b\" << GT << 0 ) );\n                    ASSERT_EQUALS( 1, c->current().getIntField( \"a\" ) );\n                    ASSERT( !c->getsetdup( c->currLoc() ) );\n                    c->advance();\n                    ASSERT_EQUALS( 1, c->current().getIntField( \"a\" ) );\n                    ASSERT( c->getsetdup( c->currLoc() ) );\n                    c->prepareToYield();",
        "lookback": "        ",
        "lookahead": "                }",
        "label": [
            "newcode",
            "complex_conflict"
        ],
        "start_line": 2641,
        "end_line": 2684,
        "merge_gen_region": null,
        "confidence": 0.4831056594848633,
        "hesitated": true
    },
    {
        "a_contents": "                ASSERT( ok() );\n                ASSERT_EQUALS( 120, current().getIntField( \"_id\" ) );\n                ASSERT( prepareToYield() );\n            }\n            \n            _cli.remove( ns(), BSON( \"_id\" << 120 ) );\n            \n            {\n                Lock::GlobalWrite lk;\n                Client::Context ctx( ns() );\n                recoverFromYield();\n                ASSERT( ok() );\n                ASSERT_EQUALS( 121, current().getIntField( \"_id\" ) );\n                ASSERT( advance() );\n                ASSERT_EQUALS( 122, current().getIntField( \"_id\" ) );",
        "b_contents": "                \n                int i = 1;\n                while( _cli.count( ns(), BSON( \"a\" << 1 ) ) > 0 ) {\n                    ++i;\n                    _cli.insert( ns(), BSON( \"a\" << i << \"b\" << i ) );\n                }\n                \n                {\n                    dblock lk;\n                    Client::Context ctx( ns() );\n                    c->recoverFromYield();\n                    ASSERT( c->ok() );\n                    // {$natural:1} plan does not recover, {_id:1} plan does.\n                    ASSERT( 1 < c->current().getIntField( \"a\" ) );\n                }                ",
        "base_contents": "                ASSERT( ok() );\n                ASSERT_EQUALS( 120, current().getIntField( \"_id\" ) );\n                ASSERT( prepareToYield() );\n            }\n            \n            _cli.remove( ns(), BSON( \"_id\" << 120 ) );\n            \n            {\n                dblock lk;\n                Client::Context ctx( ns() );\n                recoverFromYield();\n                ASSERT( ok() );\n                ASSERT_EQUALS( 121, current().getIntField( \"_id\" ) );\n                ASSERT( advance() );\n                ASSERT_EQUALS( 122, current().getIntField( \"_id\" ) );",
        "res_region": "                \n                int i = 1;\n                while( _cli.count( ns(), BSON( \"a\" << 1 ) ) > 0 ) {\n                    ++i;\n                    _cli.insert( ns(), BSON( \"a\" << i << \"b\" << i ) );\n                }\n                \n                {\n                    Lock::GlobalWrite lk;\n\n                    Client::Context ctx( ns() );\n                    c->recoverFromYield();\n                    ASSERT( c->ok() );\n                    // {$natural:1} plan does not recover, {_id:1} plan does.\n                    ASSERT( 1 < c->current().getIntField( \"a\" ) );\n                }                ",
        "lookback": "                int i = 1;",
        "lookahead": "            }",
        "label": [
            "newcode",
            "complex_conflict"
        ],
        "start_line": 2686,
        "end_line": 2734,
        "merge_gen_region": null,
        "confidence": 0.8515231013298035,
        "hesitated": true
    },
    {
        "a_contents": "            _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n            \n            auto_ptr<ClientCursor> cc;\n            auto_ptr<ClientCursor::YieldData> data( new ClientCursor::YieldData() );\n            {\n                Lock::GlobalWrite lk;\n                Client::Context ctx( ns() );\n                setQueryOptimizerCursor( BSON( \"b\" << NE << 0 << \"a\" << GTE << 0 ) );\n                cc.reset( new ClientCursor( QueryOption_NoCursorTimeout, c(), ns() ) );\n                for( int i = 0; i < 120; ++i ) {",
        "b_contents": "        };\n        \n        /** Yield with takeover cursor. */\n        class Takeover : public Base {\n        public:\n            void run() {\n                for( int i = 0; i < 150; ++i ) {\n                    _cli.insert( ns(), BSON( \"_id\" << i << \"a\" << i ) );   \n                }\n                _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n                \n                {\n                    dblock lk;\n                    Client::Context ctx( ns() );\n                    setQueryOptimizerCursor( BSON( \"_id\" << GTE << 0 << \"a\" << GTE << 0 ) );\n                    for( int i = 0; i < 120; ++i ) {\n                        ASSERT( advance() );\n                    }\n                    ASSERT( ok() );\n                    ASSERT_EQUALS( 120, current().getIntField( \"_id\" ) );\n                    prepareToYield();\n                }\n                \n                _cli.remove( ns(), BSON( \"_id\" << 120 ) );\n                \n                {\n                    dblock lk;\n                    Client::Context ctx( ns() );\n                    recoverFromYield();\n                    ASSERT( ok() );\n                    ASSERT_EQUALS( 121, current().getIntField( \"_id\" ) );",
        "base_contents": "            _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n            \n            auto_ptr<ClientCursor> cc;\n            auto_ptr<ClientCursor::YieldData> data( new ClientCursor::YieldData() );\n            {\n                dblock lk;\n                Client::Context ctx( ns() );\n                setQueryOptimizerCursor( BSON( \"b\" << NE << 0 << \"a\" << GTE << 0 ) );\n                cc.reset( new ClientCursor( QueryOption_NoCursorTimeout, c(), ns() ) );\n                for( int i = 0; i < 120; ++i ) {",
        "res_region": "        };\n        \n        /** Yield with takeover cursor. */\n        class Takeover : public Base {\n        public:\n            void run() {\n                for( int i = 0; i < 150; ++i ) {\n                    _cli.insert( ns(), BSON( \"_id\" << i << \"a\" << i ) );   \n                }\n                _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n                \n                {\n                    Lock::GlobalWrite lk;\n\n                    Client::Context ctx( ns() );\n                    setQueryOptimizerCursor( BSON( \"_id\" << GTE << 0 << \"a\" << GTE << 0 ) );\n                    for( int i = 0; i < 120; ++i ) {\n                        ASSERT( advance() );\n                    }\n                    ASSERT( ok() );\n                    ASSERT_EQUALS( 120, current().getIntField( \"_id\" ) );\n                    prepareToYield();\n                }\n                \n                _cli.remove( ns(), BSON( \"_id\" << 120 ) );\n                \n                {\n                    Lock::GlobalWrite lk;\n\n                    Client::Context ctx( ns() );\n                    recoverFromYield();\n                    ASSERT( ok() );\n                    ASSERT_EQUALS( 121, current().getIntField( \"_id\" ) );",
        "lookback": "        ",
        "lookahead": "                    ASSERT( advance() );",
        "label": [
            "newcode",
            "complex_conflict"
        ],
        "start_line": 2783,
        "end_line": 2837,
        "merge_gen_region": null,
        "confidence": 0.4642099440097809,
        "hesitated": true
    },
    {
        "a_contents": "                ASSERT( ok() );\n                ASSERT_EQUALS( 120, current().getIntField( \"_id\" ) );\n                cc->prepareToYield( *data );\n            }                \n            _cli.remove( ns(), BSON( \"_id\" << 120 ) );\n            \n            {\n                Lock::GlobalWrite lk;\n                Client::Context ctx( ns() );\n                ASSERT( ClientCursor::recoverFromYield( *data ) );\n                ASSERT( ok() );\n                ASSERT_EQUALS( 121, current().getIntField( \"_id\" ) );\n                ASSERT( advance() );\n                ASSERT_EQUALS( 122, current().getIntField( \"_id\" ) );",
        "b_contents": "",
        "base_contents": "                ASSERT( ok() );\n                ASSERT_EQUALS( 120, current().getIntField( \"_id\" ) );\n                cc->prepareToYield( *data );\n            }                \n            _cli.remove( ns(), BSON( \"_id\" << 120 ) );\n            \n            {\n                dblock lk;\n                Client::Context ctx( ns() );\n                ASSERT( ClientCursor::recoverFromYield( *data ) );\n                ASSERT( ok() );\n                ASSERT_EQUALS( 121, current().getIntField( \"_id\" ) );\n                ASSERT( advance() );\n                ASSERT_EQUALS( 122, current().getIntField( \"_id\" ) );",
        "res_region": "",
        "lookback": "        };",
        "lookahead": "            }",
        "label": [
            "base",
            "base_empty"
        ],
        "start_line": 2841,
        "end_line": 2872,
        "merge_gen_region": null,
        "confidence": 0.7309446334838867,
        "hesitated": true
    },
    {
        "a_contents": "            _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n            \n            {\n                Lock::GlobalWrite lk;\n                Client::Context ctx( ns() );\n                setQueryOptimizerCursor( BSON( \"_id\" << GT << 0 << \"a\" << GT << 0 ) );\n                ASSERT( ok() );\n                ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                ASSERT( advance() );\n                ASSERT_EQUALS( 9, current().getIntField( \"_id\" ) );\n                ASSERT( advance() );\n                ASSERT_EQUALS( 2, current().getIntField( \"_id\" ) );\n                ASSERT( prepareToYield() );",
        "b_contents": "        };\n        \n        /** Yield with advance of inactive cursor. */\n        class InactiveCursorAdvance : public Base {\n        public:\n            void run() {\n                for( int i = 0; i < 10; ++i ) {\n                    _cli.insert( ns(), BSON( \"_id\" << i << \"a\" << 10 - i ) );\n                }\n                _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n                \n                {\n                    dblock lk;\n                    Client::Context ctx( ns() );\n                    setQueryOptimizerCursor( BSON( \"_id\" << GT << 0 << \"a\" << GT << 0 ) );\n                    ASSERT( ok() );\n                    ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                    ASSERT( advance() );\n                    ASSERT_EQUALS( 9, current().getIntField( \"_id\" ) );\n                    ASSERT( advance() );\n                    ASSERT_EQUALS( 2, current().getIntField( \"_id\" ) );\n                    prepareToYield();\n                }\n                \n                _cli.remove( ns(), BSON( \"_id\" << 9 ) );\n                \n                {\n                    dblock lk;\n                    Client::Context ctx( ns() );\n                    recoverFromYield();\n                    ASSERT( ok() );\n                    ASSERT_EQUALS( 8, current().getIntField( \"_id\" ) );\n                    ASSERT( advance() );\n                    ASSERT_EQUALS( 3, current().getIntField( \"_id\" ) );\n                    ASSERT( advance() );\n                    ASSERT_EQUALS( 7, current().getIntField( \"_id\" ) );\n                }                    ",
        "base_contents": "            _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n            \n            {\n                dblock lk;\n                Client::Context ctx( ns() );\n                setQueryOptimizerCursor( BSON( \"_id\" << GT << 0 << \"a\" << GT << 0 ) );\n                ASSERT( ok() );\n                ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                ASSERT( advance() );\n                ASSERT_EQUALS( 9, current().getIntField( \"_id\" ) );\n                ASSERT( advance() );\n                ASSERT_EQUALS( 2, current().getIntField( \"_id\" ) );\n                ASSERT( prepareToYield() );",
        "res_region": "        };\n        \n        /** Yield with advance of inactive cursor. */\n        class InactiveCursorAdvance : public Base {\n        public:\n            void run() {\n                for( int i = 0; i < 10; ++i ) {\n                    _cli.insert( ns(), BSON( \"_id\" << i << \"a\" << 10 - i ) );\n                }\n                _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n                \n                {\n                    Lock::GlobalWrite lk;\n\n                    Client::Context ctx( ns() );\n                    setQueryOptimizerCursor( BSON( \"_id\" << GT << 0 << \"a\" << GT << 0 ) );\n                    ASSERT( ok() );\n                    ASSERT_EQUALS( 1, current().getIntField( \"_id\" ) );\n                    ASSERT( advance() );\n                    ASSERT_EQUALS( 9, current().getIntField( \"_id\" ) );\n                    ASSERT( advance() );\n                    ASSERT_EQUALS( 2, current().getIntField( \"_id\" ) );\n                    prepareToYield();\n                }\n                \n                _cli.remove( ns(), BSON( \"_id\" << 9 ) );\n                \n                {\n                    Lock::GlobalWrite lk;\n\n                    Client::Context ctx( ns() );\n                    recoverFromYield();\n                    ASSERT( ok() );\n                    ASSERT_EQUALS( 8, current().getIntField( \"_id\" ) );\n                    ASSERT( advance() );\n                    ASSERT_EQUALS( 3, current().getIntField( \"_id\" ) );\n                    ASSERT( advance() );\n                    ASSERT_EQUALS( 7, current().getIntField( \"_id\" ) );\n                }                    ",
        "lookback": "        ",
        "lookahead": "            }",
        "label": [
            "newcode",
            "complex_conflict"
        ],
        "start_line": 2911,
        "end_line": 2977,
        "merge_gen_region": null,
        "confidence": 0.47714555263519287,
        "hesitated": true
    },
    {
        "a_contents": "            _cli.remove( ns(), BSON( \"_id\" << 9 ) );\n            \n            {\n                Lock::GlobalWrite lk;\n                Client::Context ctx( ns() );\n                recoverFromYield();\n                ASSERT( ok() );\n                ASSERT_EQUALS( 8, current().getIntField( \"_id\" ) );\n                ASSERT( advance() );\n                ASSERT_EQUALS( 3, current().getIntField( \"_id\" ) );\n                ASSERT( advance() );\n                ASSERT_EQUALS( 7, current().getIntField( \"_id\" ) );\n            }                    \n        }\n    };",
        "b_contents": "    } // namespace Yield",
        "base_contents": "            _cli.remove( ns(), BSON( \"_id\" << 9 ) );\n            \n            {\n                dblock lk;\n                Client::Context ctx( ns() );\n                recoverFromYield();\n                ASSERT( ok() );\n                ASSERT_EQUALS( 8, current().getIntField( \"_id\" ) );\n                ASSERT( advance() );\n                ASSERT_EQUALS( 3, current().getIntField( \"_id\" ) );\n                ASSERT( advance() );\n                ASSERT_EQUALS( 7, current().getIntField( \"_id\" ) );\n            }                    \n        }\n    };",
        "res_region": "    } // namespace Yield",
        "lookback": "    ",
        "lookahead": "    ",
        "label": [
            "base",
            "complex_conflict"
        ],
        "start_line": 2981,
        "end_line": 3015,
        "merge_gen_region": "",
        "confidence": 0.9559280276298523,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "                c->advance();\n            }\n            ASSERT( !c->ok() );\n        }\n    };\n\n    /* Test 'touching earlier iterate' without doc modifications. */\n    class TouchEarlierIterate : public Base {\n    public:\n        void run() {            \n            _cli.insert( ns(), BSON( \"_id\" << 1 << \"b\" << 1 ) );\n            _cli.insert( ns(), BSON( \"_id\" << 2 << \"b\" << 2 ) );\n            _cli.ensureIndex( ns(), BSON( \"b\" << 1 ) );\n\n            Client::ReadContext ctx( ns() );\n            shared_ptr<Cursor> c = newQueryOptimizerCursor( ns(), BSON( \"_id\" << GT << 0 << \"b\" << GT << 0 ) );\n            \n            ASSERT( c->ok() );\n            while( c->ok() ) {\n                DiskLoc loc = c->currLoc();\n                BSONObj obj = c->current();\n                c->prepareToTouchEarlierIterate();\n                c->recoverFromTouchingEarlierIterate();\n                ASSERT( loc == c->currLoc() );\n                ASSERT_EQUALS( obj, c->current() );\n                c->advance();\n            }\n        }\n    };\n\n    /* Test 'touching earlier iterate' with doc modifications. */\n    class TouchEarlierIterateDelete : public Base {\n    public:\n        void run() {            \n            _cli.insert( ns(), BSON( \"_id\" << 1 << \"b\" << 1 ) );\n            _cli.insert( ns(), BSON( \"_id\" << 2 << \"b\" << 2 ) );\n            _cli.ensureIndex( ns(), BSON( \"b\" << 1 ) );\n            \n            DiskLoc firstLoc;\n            Lock::GlobalWrite lk;\n            Client::Context ctx( ns() );\n            setQueryOptimizerCursor( BSON( \"_id\" << GT << 0 << \"b\" << GT << 0 ) );\n            ASSERT( ok() );\n            firstLoc = currLoc();\n            ASSERT( c()->advance() );\n            prepareToTouchEarlierIterate();\n            \n            _cli.remove( ns(), BSON( \"_id\" << 1 ), true );\n\n            recoverFromTouchingEarlierIterate();\n            ASSERT( ok() );\n            while( ok() ) {\n                ASSERT( firstLoc != currLoc() );\n                c()->advance();\n            }\n        }\n    };\n\n    /* Test 'touch earlier iterate' with several doc modifications. */\n    class TouchEarlierIterateDeleteMultiple : public Base {\n    public:\n        void run() {\n            for( int i = 1; i < 10; ++i ) {\n                _cli.insert( ns(), BSON( \"_id\" << i << \"b\" << i ) );\n            }\n            _cli.ensureIndex( ns(), BSON( \"b\" << 1 ) );\n            \n            set<DiskLoc> deleted;\n            int id = 0;\n            Lock::GlobalWrite lk;\n            Client::Context ctx( ns() );\n            setQueryOptimizerCursor( BSON( \"_id\" << GT << 0 << \"b\" << GT << 0 ) );\n            while( 1 ) {\n                if ( !ok() ) {\n                    break;\n                }\n                ASSERT( deleted.count( currLoc() ) == 0 );\n                id = current()[\"_id\"].Int();\n                deleted.insert( currLoc() );\n                c()->advance();\n                prepareToTouchEarlierIterate();\n                \n                _cli.remove( ns(), BSON( \"_id\" << id ), true );\n\n                recoverFromTouchingEarlierIterate();",
        "b_contents": "                c->advance();",
        "base_contents": "                c->advance();\n            }\n            ASSERT( !c->ok() );\n        }\n    };\n\n    /* Test 'touching earlier iterate' without doc modifications. */\n    class TouchEarlierIterate : public Base {\n    public:\n        void run() {            \n            _cli.insert( ns(), BSON( \"_id\" << 1 << \"b\" << 1 ) );\n            _cli.insert( ns(), BSON( \"_id\" << 2 << \"b\" << 2 ) );\n            _cli.ensureIndex( ns(), BSON( \"b\" << 1 ) );\n\n            Client::ReadContext ctx( ns() );\n            shared_ptr<Cursor> c = newQueryOptimizerCursor( ns(), BSON( \"_id\" << GT << 0 << \"b\" << GT << 0 ) );\n            \n            ASSERT( c->ok() );\n            while( c->ok() ) {\n                DiskLoc loc = c->currLoc();\n                BSONObj obj = c->current();\n                c->prepareToTouchEarlierIterate();\n                c->recoverFromTouchingEarlierIterate();\n                ASSERT( loc == c->currLoc() );\n                ASSERT_EQUALS( obj, c->current() );\n                c->advance();\n            }\n        }\n    };\n\n    /* Test 'touching earlier iterate' with doc modifications. */\n    class TouchEarlierIterateDelete : public Base {\n    public:\n        void run() {            \n            _cli.insert( ns(), BSON( \"_id\" << 1 << \"b\" << 1 ) );\n            _cli.insert( ns(), BSON( \"_id\" << 2 << \"b\" << 2 ) );\n            _cli.ensureIndex( ns(), BSON( \"b\" << 1 ) );\n            \n            DiskLoc firstLoc;\n            dblock lk;\n            Client::Context ctx( ns() );\n            setQueryOptimizerCursor( BSON( \"_id\" << GT << 0 << \"b\" << GT << 0 ) );\n            ASSERT( ok() );\n            firstLoc = currLoc();\n            ASSERT( c()->advance() );\n            prepareToTouchEarlierIterate();\n            \n            _cli.remove( ns(), BSON( \"_id\" << 1 ), true );\n\n            recoverFromTouchingEarlierIterate();\n            ASSERT( ok() );\n            while( ok() ) {\n                ASSERT( firstLoc != currLoc() );\n                c()->advance();\n            }\n        }\n    };\n\n    /* Test 'touch earlier iterate' with several doc modifications. */\n    class TouchEarlierIterateDeleteMultiple : public Base {\n    public:\n        void run() {\n            for( int i = 1; i < 10; ++i ) {\n                _cli.insert( ns(), BSON( \"_id\" << i << \"b\" << i ) );\n            }\n            _cli.ensureIndex( ns(), BSON( \"b\" << 1 ) );\n            \n            set<DiskLoc> deleted;\n            int id = 0;\n            dblock lk;\n            Client::Context ctx( ns() );\n            setQueryOptimizerCursor( BSON( \"_id\" << GT << 0 << \"b\" << GT << 0 ) );\n            while( 1 ) {\n                if ( !ok() ) {\n                    break;\n                }\n                ASSERT( deleted.count( currLoc() ) == 0 );\n                id = current()[\"_id\"].Int();\n                deleted.insert( currLoc() );\n                c()->advance();\n                prepareToTouchEarlierIterate();\n                \n                _cli.remove( ns(), BSON( \"_id\" << id ), true );\n\n                recoverFromTouchingEarlierIterate();",
        "res_region": "                c->advance();",
        "lookback": "            }",
        "lookahead": "            }",
        "label": [
            "base",
            "complex_conflict"
        ],
        "start_line": 3187,
        "end_line": 3361,
        "merge_gen_region": null,
        "confidence": 0.6258436441421509,
        "hesitated": true
    },
    {
        "a_contents": "            Lock::GlobalWrite lk;\n            Client::Context ctx( ns() );\n            setQueryOptimizerCursorWithoutAdvancing( BSON( \"_id\" << GT << 0 << \"b\" << GT << 0 ) );\n            while( 1 ) {\n                if ( !ok() ) {\n                    break;",
        "b_contents": "        /* Test 'touch earlier iterate' after an earlier yield. */\n        class DeleteAfterYield : public Base {\n        public:\n            void run() {\n                for( int i = 0; i < 3; ++i ) {\n                    _cli.insert( ns(), BSON( \"b\" << i ) );                    ",
        "base_contents": "            dblock lk;\n            Client::Context ctx( ns() );\n            setQueryOptimizerCursorWithoutAdvancing( BSON( \"_id\" << GT << 0 << \"b\" << GT << 0 ) );\n            while( 1 ) {\n                if ( !ok() ) {\n                    break;",
        "res_region": "        /* Test 'touch earlier iterate' after an earlier yield. */\n        class DeleteAfterYield : public Base {\n        public:\n            void run() {\n                for( int i = 0; i < 3; ++i ) {\n                    _cli.insert( ns(), BSON( \"b\" << i ) );                    ",
        "lookback": "        class DeleteAfterYield : public Base {",
        "lookahead": "                }",
        "label": [
            "base",
            "complex_conflict"
        ],
        "start_line": 3453,
        "end_line": 3474,
        "merge_gen_region": null,
        "confidence": 0.8275700211524963,
        "hesitated": true
    },
    {
        "a_contents": "            _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n            _cli.ensureIndex( ns(), BSON( \"b\" << 1 ) );\n            \n            set<DiskLoc> deleted;\n            int id = 0;\n            \n            Lock::GlobalWrite lk;\n            Client::Context ctx( ns() );\n            setQueryOptimizerCursorWithoutAdvancing( BSON( \"a\" << GT << 0 << \"b\" << GT << 0 ) );\n            while( 1 ) {\n                if ( !ok() ) {\n                    break;",
        "b_contents": "        };\n        \n        /* Test 'touch earlier iterate' with takeover. */\n        class Takeover : public Base {\n        public:\n            void run() {\n                for( int i = 1; i < 600; ++i ) {\n                    _cli.insert( ns(), BSON( \"_id\" << i << \"b\" << i ) );",
        "base_contents": "            _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n            _cli.ensureIndex( ns(), BSON( \"b\" << 1 ) );\n            \n            set<DiskLoc> deleted;\n            int id = 0;\n            \n            dblock lk;\n            Client::Context ctx( ns() );\n            setQueryOptimizerCursorWithoutAdvancing( BSON( \"a\" << GT << 0 << \"b\" << GT << 0 ) );\n            while( 1 ) {\n                if ( !ok() ) {\n                    break;",
        "res_region": "        };\n        \n        /* Test 'touch earlier iterate' with takeover. */\n        class Takeover : public Base {\n        public:\n            void run() {\n                for( int i = 1; i < 600; ++i ) {\n                    _cli.insert( ns(), BSON( \"_id\" << i << \"b\" << i ) );",
        "lookback": "        ",
        "lookahead": "                }",
        "label": [
            "base",
            "complex_conflict"
        ],
        "start_line": 3506,
        "end_line": 3541,
        "merge_gen_region": null,
        "confidence": 0.6404032111167908,
        "hesitated": true
    },
    {
        "a_contents": "            Lock::GlobalWrite lk;\n            Client::Context ctx( ns() );\n            setQueryOptimizerCursor( BSON( \"_id\" << GT << 0 << \"b\" << GT << 0 ) );\n            while( 1 ) {\n                if ( !ok() ) {\n                    break;",
        "b_contents": "        /* Test 'touch earlier iterate' with takeover and deletes. */\n        class TakeoverDeleteMultiple : public Base {\n        public:\n            void run() {\n                for( int i = 1; i < 600; ++i ) {\n                    _cli.insert( ns(), BSON( \"_id\" << i << \"b\" << i ) );",
        "base_contents": "            dblock lk;\n            Client::Context ctx( ns() );\n            setQueryOptimizerCursor( BSON( \"_id\" << GT << 0 << \"b\" << GT << 0 ) );\n            while( 1 ) {\n                if ( !ok() ) {\n                    break;",
        "res_region": "        /* Test 'touch earlier iterate' with takeover and deletes. */\n        class TakeoverDeleteMultiple : public Base {\n        public:\n            void run() {\n                for( int i = 1; i < 600; ++i ) {\n                    _cli.insert( ns(), BSON( \"_id\" << i << \"b\" << i ) );",
        "lookback": "        class TakeoverDeleteMultiple : public Base {",
        "lookahead": "                }",
        "label": [
            "base",
            "complex_conflict"
        ],
        "start_line": 3564,
        "end_line": 3585,
        "merge_gen_region": " Takeclassoverclassoverclass969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696",
        "confidence": 0.8924495577812195,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "    /** Test that a ClientCursor holding a QueryOptimizerCursor may be safely invalidated. */\n    class InvalidateClientCursorHolder : public Base {\n    public:\n        void run() {\n            _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n            _cli.ensureIndex( ns(), BSON( \"b\" << 1 ) );\n            _cli.insert( ns(), BSON( \"a\" << 1 << \"b\" << 1 ) );\n            Lock::GlobalWrite lk;\n            Client::Context ctx( ns() );\n            ClientCursor::CleanupPointer p;\n            p.reset\n            ( new ClientCursor\n             ( QueryOption_NoCursorTimeout,\n              NamespaceDetailsTransient::getCursor\n              ( ns(), BSON( \"a\" << GTE << 0 << \"b\" << GTE << 0 ) ),\n              ns() ) );",
        "b_contents": "    namespace ClientCursor {\n        \n        using mongo::ClientCursor;\n        \n        /** Test that a ClientCursor holding a QueryOptimizerCursor may be safely invalidated. */\n        class Invalidate : public Base {\n        public:\n            void run() {\n                _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n                _cli.ensureIndex( ns(), BSON( \"b\" << 1 ) );\n                _cli.insert( ns(), BSON( \"a\" << 1 << \"b\" << 1 ) );\n                dblock lk;\n                Client::Context ctx( ns() );\n                ClientCursor::CleanupPointer p;\n                p.reset\n                ( new ClientCursor\n                 ( QueryOption_NoCursorTimeout,\n                  NamespaceDetailsTransient::getCursor\n                  ( ns(), BSON( \"a\" << GTE << 0 << \"b\" << GTE << 0 ) ),\n                  ns() ) );",
        "base_contents": "    /** Test that a ClientCursor holding a QueryOptimizerCursor may be safely invalidated. */\n    class InvalidateClientCursorHolder : public Base {\n    public:\n        void run() {\n            _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n            _cli.ensureIndex( ns(), BSON( \"b\" << 1 ) );\n            _cli.insert( ns(), BSON( \"a\" << 1 << \"b\" << 1 ) );\n            dblock lk;\n            Client::Context ctx( ns() );\n            ClientCursor::CleanupPointer p;\n            p.reset\n            ( new ClientCursor\n             ( QueryOption_NoCursorTimeout,\n              NamespaceDetailsTransient::getCursor\n              ( ns(), BSON( \"a\" << GTE << 0 << \"b\" << GTE << 0 ) ),\n              ns() ) );",
        "res_region": "    namespace ClientCursor {\n        \n        using mongo::ClientCursor;\n        \n        /** Test that a ClientCursor holding a QueryOptimizerCursor may be safely invalidated. */\n        class Invalidate : public Base {\n        public:\n            void run() {\n                _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n                _cli.ensureIndex( ns(), BSON( \"b\" << 1 ) );\n                _cli.insert( ns(), BSON( \"a\" << 1 << \"b\" << 1 ) );\n                Lock::GlobalWrite lk;\n\n                Client::Context ctx( ns() );\n                ClientCursor::CleanupPointer p;\n                p.reset\n                ( new ClientCursor\n                 ( QueryOption_NoCursorTimeout,\n                  NamespaceDetailsTransient::getCursor\n                  ( ns(), BSON( \"a\" << GTE << 0 << \"b\" << GTE << 0 ) ),\n                  ns() ) );",
        "lookback": "        ",
        "lookahead": "            ClientCursor::invalidate( ns() );",
        "label": [
            "newcode",
            "complex_conflict"
        ],
        "start_line": 3751,
        "end_line": 3806,
        "merge_gen_region": null,
        "confidence": 0.8540671467781067,
        "hesitated": true
    },
    {
        "a_contents": "            ClientCursor::invalidate( ns() );\n            ASSERT_EQUALS( 0U, nNsCursors() );\n        }\n    };\n    \n    /** Test that a ClientCursor holding a QueryOptimizerCursor may be safely timed out. */\n    class TimeoutClientCursorHolder : public Base {\n    public:\n        void run() {\n            _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n            _cli.ensureIndex( ns(), BSON( \"b\" << 1 ) );\n            _cli.insert( ns(), BSON( \"a\" << 1 << \"b\" << 1 ) );\n            Lock::GlobalWrite lk;\n            Client::Context ctx( ns() );\n            ClientCursor::CleanupPointer p;\n            p.reset\n            ( new ClientCursor\n             ( 0,\n              NamespaceDetailsTransient::getCursor\n              ( ns(), BSON( \"a\" << GTE << 0 << \"b\" << GTE << 0 ) ),\n              ns() ) );\n            \n            // Construct component client cursors.\n            ClientCursor::YieldData yieldData;\n            p->prepareToYield( yieldData );\n            ASSERT( nNsCursors() > 1 );\n            \n            ClientCursor::idleTimeReport( 600001 );\n            ASSERT_EQUALS( 0U, nNsCursors() );\n        }\n    };\n    ",
        "b_contents": "                ClientCursor::invalidate( ns() );\n                ASSERT_EQUALS( 0U, nNsCursors() );\n            }\n        };\n        \n        /** Test that a ClientCursor holding a QueryOptimizerCursor may be safely timed out. */\n        class Timeout : public Base {\n        public:\n            void run() {\n                _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n                _cli.ensureIndex( ns(), BSON( \"b\" << 1 ) );\n                _cli.insert( ns(), BSON( \"a\" << 1 << \"b\" << 1 ) );\n                dblock lk;\n                Client::Context ctx( ns() );\n                ClientCursor::CleanupPointer p;\n                p.reset\n                ( new ClientCursor\n                 ( 0,\n                  NamespaceDetailsTransient::getCursor\n                  ( ns(), BSON( \"a\" << GTE << 0 << \"b\" << GTE << 0 ) ),\n                  ns() ) );\n                \n                // Construct component client cursors.\n                ClientCursor::YieldData yieldData;\n                p->prepareToYield( yieldData );\n                ASSERT( nNsCursors() > 1 );\n                \n                ClientCursor::idleTimeReport( 600001 );\n                ASSERT_EQUALS( 0U, nNsCursors() );\n            }\n        };\n        \n        /**\n         * Test that a ClientCursor properly recovers a QueryOptimizerCursor after a btree\n         * modification in preparation for a pre delete advance.\n         */\n        class AboutToDeleteRecoverFromYield : public Base {\n        public:\n            void run() {\n                // Create a sparse index, so we can easily remove entries from it with an update.\n                _cli.insert( Namespace( ns() ).getSisterNS( \"system.indexes\" ).c_str(),\n                            BSON( \"ns\" << ns() << \"key\" << BSON( \"a\" << 1 ) << \"name\" << \"idx\" <<\n                                 \"sparse\" << true ) );\n\n                _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n                for( int i = 0; i < 150; ++i ) {\n                    _cli.insert( ns(), BSON( \"a\" << i << \"b\" << 0 ) );\n                }\n                dblock lk;\n                Client::Context ctx( ns() );\n                ClientCursor::CleanupPointer p;\n                p.reset\n                ( new ClientCursor\n                 ( QueryOption_NoCursorTimeout,\n                  NamespaceDetailsTransient::getCursor\n                  ( ns(), BSON( \"a\" << GTE << 0 << \"b\" << 0 ) ),\n                  ns() ) );\n                \n                // Iterate until after MultiCursor takes over.\n                int readTo = 110;\n                while( p->current()[ \"a\" ].number() < readTo ) {\n                    p->advance();\n                }\n                \n                // Check that the btree plan was picked.\n                ASSERT_EQUALS( BSON( \"a\" << 1 ), p->indexKeyPattern() );\n                \n                // Yield the cursor.\n                ClientCursor::YieldData yieldData;\n                ASSERT( p->prepareToYield( yieldData ) );\n                \n                // Remove keys from the a:1 index, invalidating the cursor's position.\n                _cli.update( ns(), BSON( \"a\" << LT << 100 ), BSON( \"$unset\" << BSON( \"a\" << 1 ) ),\n                            false, true );\n                \n                // Delete the cursor's current document.  If the cursor's position is recovered\n                // improperly in preparation for deleting the document, this will cause an\n                // assertion.\n                _cli.remove( ns(), BSON( \"a\" << readTo ) );\n                \n                // Check that the document was deleted.\n                ASSERT_EQUALS( BSONObj(), _cli.findOne( ns(), BSON( \"a\" << readTo ) ) );\n                \n                // Recover the cursor.\n                ASSERT( p->recoverFromYield( yieldData ) );\n                \n                // Check that the remaining documents are iterated as expected.\n                for( int i = 111; i < 150; ++i ) {\n                    ASSERT_EQUALS( i, p->current()[ \"a\" ].number() );\n                    p->advance();\n                }\n                ASSERT( !p->ok() );\n            }\n        };\n\n        /**\n         * Test that a ClientCursor properly prepares a QueryOptimizerCursor to yield after a pre\n         * delete advance.\n         */\n        class AboutToDeletePrepareToYield : public Base {\n        public:\n            void run() {\n                // Create two indexes for serial $or clause traversal.\n                _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n                _cli.ensureIndex( ns(), BSON( \"b\" << 1 ) );\n                for( int i = 0; i < 110; ++i ) {\n                    _cli.insert( ns(), BSON( \"a\" << i ) );\n                }\n                _cli.insert( ns(), BSON( \"b\" << 1 ) );\n                dblock lk;\n                Client::Context ctx( ns() );\n                ClientCursor::CleanupPointer p;\n                p.reset\n                ( new ClientCursor\n                 ( QueryOption_NoCursorTimeout,\n                  NamespaceDetailsTransient::getCursor\n                  ( ns(), OR( BSON( \"a\" << GTE << 0 ), BSON( \"b\" << 1 ) ) ),\n                  ns() ) );\n                \n                // Iterate until after MultiCursor takes over.\n                int readTo = 109;\n                while( p->current()[ \"a\" ].number() < readTo ) {\n                    p->advance();\n                }\n                \n                // Check the key pattern.\n                ASSERT_EQUALS( BSON( \"a\" << 1 ), p->indexKeyPattern() );\n                \n                // Yield the cursor.\n                ClientCursor::YieldData yieldData;\n                ASSERT( p->prepareToYield( yieldData ) );\n                \n                // Delete the cursor's current document.  The cursor should advance to the b:1\n                // index.\n                _cli.remove( ns(), BSON( \"a\" << readTo ) );\n                \n                // Check that the document was deleted.\n                ASSERT_EQUALS( BSONObj(), _cli.findOne( ns(), BSON( \"a\" << readTo ) ) );\n\n                // Recover the cursor.  If the cursor was not properly prepared for yielding\n                // after the pre deletion advance, this will assert.\n                ASSERT( p->recoverFromYield( yieldData ) );\n                \n                // Check that the remaining documents are as expected.\n                ASSERT_EQUALS( 1, p->current()[ \"b\" ].number() );\n                ASSERT( !p->advance() );\n            }\n        };\n\n    } // namespace ClientCursor\n        ",
        "base_contents": "            ClientCursor::invalidate( ns() );\n            ASSERT_EQUALS( 0U, nNsCursors() );\n        }\n    };\n    \n    /** Test that a ClientCursor holding a QueryOptimizerCursor may be safely timed out. */\n    class TimeoutClientCursorHolder : public Base {\n    public:\n        void run() {\n            _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n            _cli.ensureIndex( ns(), BSON( \"b\" << 1 ) );\n            _cli.insert( ns(), BSON( \"a\" << 1 << \"b\" << 1 ) );\n            dblock lk;\n            Client::Context ctx( ns() );\n            ClientCursor::CleanupPointer p;\n            p.reset\n            ( new ClientCursor\n             ( 0,\n              NamespaceDetailsTransient::getCursor\n              ( ns(), BSON( \"a\" << GTE << 0 << \"b\" << GTE << 0 ) ),\n              ns() ) );\n            \n            // Construct component client cursors.\n            ClientCursor::YieldData yieldData;\n            p->prepareToYield( yieldData );\n            ASSERT( nNsCursors() > 1 );\n            \n            ClientCursor::idleTimeReport( 600001 );\n            ASSERT_EQUALS( 0U, nNsCursors() );\n        }\n    };\n    ",
        "res_region": "            ClientCursor::invalidate( ns() );\n            ASSERT_EQUALS( 0U, nNsCursors() );\n        }\n    };\n    \n    /** Test that a ClientCursor holding a QueryOptimizerCursor may be safely timed out. */\n    class TimeoutClientCursorHolder : public Base {\n    public:\n        void run() {\n            _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n            _cli.ensureIndex( ns(), BSON( \"b\" << 1 ) );\n            _cli.insert( ns(), BSON( \"a\" << 1 << \"b\" << 1 ) );\n            Lock::GlobalWrite lk;\n            Client::Context ctx( ns() );\n            ClientCursor::CleanupPointer p;\n            p.reset\n            ( new ClientCursor\n             ( 0,\n              NamespaceDetailsTransient::getCursor\n              ( ns(), BSON( \"a\" << GTE << 0 << \"b\" << GTE << 0 ) ),\n              ns() ) );\n            \n            // Construct component client cursors.\n            ClientCursor::YieldData yieldData;\n            p->prepareToYield( yieldData );\n            ASSERT( nNsCursors() > 1 );\n            \n                ClientCursor::invalidate( ns() );\n                ASSERT_EQUALS( 0U, nNsCursors() );\n            }\n        };\n        \n        /** Test that a ClientCursor holding a QueryOptimizerCursor may be safely timed out. */\n        class Timeout : public Base {\n        public:\n            void run() {\n                _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n                _cli.ensureIndex( ns(), BSON( \"b\" << 1 ) );\n                _cli.insert( ns(), BSON( \"a\" << 1 << \"b\" << 1 ) );\n                Lock::GlobalWrite lk;\n\n                Client::Context ctx( ns() );\n                ClientCursor::CleanupPointer p;\n                p.reset\n                ( new ClientCursor\n                 ( 0,\n                  NamespaceDetailsTransient::getCursor\n                  ( ns(), BSON( \"a\" << GTE << 0 << \"b\" << GTE << 0 ) ),\n                  ns() ) );\n                \n                // Construct component client cursors.\n                ClientCursor::YieldData yieldData;\n                p->prepareToYield( yieldData );\n                ASSERT( nNsCursors() > 1 );\n                \n                ClientCursor::idleTimeReport( 600001 );\n                ASSERT_EQUALS( 0U, nNsCursors() );\n            }\n        };\n        \n        /**\n         * Test that a ClientCursor properly recovers a QueryOptimizerCursor after a btree\n         * modification in preparation for a pre delete advance.\n         */\n        class AboutToDeleteRecoverFromYield : public Base {\n        public:\n            void run() {\n                // Create a sparse index, so we can easily remove entries from it with an update.\n                _cli.insert( Namespace( ns() ).getSisterNS( \"system.indexes\" ).c_str(),\n                            BSON( \"ns\" << ns() << \"key\" << BSON( \"a\" << 1 ) << \"name\" << \"idx\" <<\n                                 \"sparse\" << true ) );\n\n                _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n                for( int i = 0; i < 150; ++i ) {\n                    _cli.insert( ns(), BSON( \"a\" << i << \"b\" << 0 ) );\n                }\n                Lock::GlobalWrite lk;\n\n                Client::Context ctx( ns() );\n                ClientCursor::CleanupPointer p;\n                p.reset\n                ( new ClientCursor\n                 ( QueryOption_NoCursorTimeout,\n                  NamespaceDetailsTransient::getCursor\n                  ( ns(), BSON( \"a\" << GTE << 0 << \"b\" << 0 ) ),\n                  ns() ) );\n                \n                // Iterate until after MultiCursor takes over.\n                int readTo = 110;\n                while( p->current()[ \"a\" ].number() < readTo ) {\n                    p->advance();\n                }\n                \n                // Check that the btree plan was picked.\n                ASSERT_EQUALS( BSON( \"a\" << 1 ), p->indexKeyPattern() );\n                \n                // Yield the cursor.\n                ClientCursor::YieldData yieldData;\n                ASSERT( p->prepareToYield( yieldData ) );\n                \n                // Remove keys from the a:1 index, invalidating the cursor's position.\n                _cli.update( ns(), BSON( \"a\" << LT << 100 ), BSON( \"$unset\" << BSON( \"a\" << 1 ) ),\n                            false, true );\n                \n                // Delete the cursor's current document.  If the cursor's position is recovered\n                // improperly in preparation for deleting the document, this will cause an\n                // assertion.\n                _cli.remove( ns(), BSON( \"a\" << readTo ) );\n                \n                // Check that the document was deleted.\n                ASSERT_EQUALS( BSONObj(), _cli.findOne( ns(), BSON( \"a\" << readTo ) ) );\n                \n                // Recover the cursor.\n                ASSERT( p->recoverFromYield( yieldData ) );\n                \n                // Check that the remaining documents are iterated as expected.\n                for( int i = 111; i < 150; ++i ) {\n                    ASSERT_EQUALS( i, p->current()[ \"a\" ].number() );\n                    p->advance();\n                }\n                ASSERT( !p->ok() );\n            }\n        };\n\n        /**\n         * Test that a ClientCursor properly prepares a QueryOptimizerCursor to yield after a pre\n         * delete advance.\n         */\n        class AboutToDeletePrepareToYield : public Base {\n        public:\n            void run() {\n                // Create two indexes for serial $or clause traversal.\n                _cli.ensureIndex( ns(), BSON( \"a\" << 1 ) );\n                _cli.ensureIndex( ns(), BSON( \"b\" << 1 ) );\n                for( int i = 0; i < 110; ++i ) {\n                    _cli.insert( ns(), BSON( \"a\" << i ) );\n                }\n                _cli.insert( ns(), BSON( \"b\" << 1 ) );\n                Lock::GlobalWrite lk;\n\n                Client::Context ctx( ns() );\n                ClientCursor::CleanupPointer p;\n                p.reset\n                ( new ClientCursor\n                 ( QueryOption_NoCursorTimeout,\n                  NamespaceDetailsTransient::getCursor\n                  ( ns(), OR( BSON( \"a\" << GTE << 0 ), BSON( \"b\" << 1 ) ) ),\n                  ns() ) );\n                \n                // Iterate until after MultiCursor takes over.\n                int readTo = 109;\n                while( p->current()[ \"a\" ].number() < readTo ) {\n                    p->advance();\n                }\n                \n                // Check the key pattern.\n                ASSERT_EQUALS( BSON( \"a\" << 1 ), p->indexKeyPattern() );\n                \n                // Yield the cursor.\n                ClientCursor::YieldData yieldData;\n                ASSERT( p->prepareToYield( yieldData ) );\n                \n                // Delete the cursor's current document.  The cursor should advance to the b:1\n                // index.\n                _cli.remove( ns(), BSON( \"a\" << readTo ) );\n                \n                // Check that the document was deleted.\n                ASSERT_EQUALS( BSONObj(), _cli.findOne( ns(), BSON( \"a\" << readTo ) ) );\n\n                // Recover the cursor.  If the cursor was not properly prepared for yielding\n                // after the pre deletion advance, this will assert.\n                ASSERT( p->recoverFromYield( yieldData ) );\n                \n                // Check that the remaining documents are as expected.\n                ASSERT_EQUALS( 1, p->current()[ \"b\" ].number() );\n                ASSERT( !p->advance() );\n            }\n        };\n\n    } // namespace ClientCursor\n        ",
        "lookback": "            ASSERT_EQUALS( 0U, nNsCursors() );",
        "lookahead": "    class AllowOutOfOrderPlan : public Base {",
        "label": [
            "newcode",
            "complex_conflict"
        ],
        "start_line": 3813,
        "end_line": 4031,
        "merge_gen_region": null,
        "confidence": 0.6899049878120422,
        "hesitated": true
    }
]