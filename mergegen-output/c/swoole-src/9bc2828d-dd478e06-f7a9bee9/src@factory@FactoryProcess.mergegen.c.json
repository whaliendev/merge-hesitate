[
    {
        "a_contents": "/*\n  +----------------------------------------------------------------------+\n  | Swoole                                                               |\n  +----------------------------------------------------------------------+\n  | This source file is subject to version 2.0 of the Apache license,    |\n  | that is bundled with this package in the file LICENSE, and is        |\n  | available through the world-wide-web at the following url:           |\n  | http://www.apache.org/licenses/LICENSE-2.0.html                      |\n  | If you did not receive a copy of the Apache2.0 license and are unable|\n  | to obtain it through the world-wide-web, please send a note to       |\n  | license@php.net so we can mail you a copy immediately.               |\n  +----------------------------------------------------------------------+\n  | Author: Tianfeng Han  <mikan.tenny@gmail.com>                        |\n  +----------------------------------------------------------------------+\n*/\n\n#include \"swoole.h\"\n#include \"Server.h\"\n#include <signal.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n\ntypedef struct\n{\n    uint8_t reloading;\n    uint8_t reload_event_worker;\n    uint8_t reload_task_worker;\n\n} swManagerProcess;\n\nstatic int swFactoryProcess_manager_loop(swFactory *factory);\nstatic int swFactoryProcess_manager_start(swFactory *factory);\n\nstatic int swFactoryProcess_worker_spawn(swFactory *factory, int worker_pti);\n\nstatic int swFactoryProcess_writer_start(swFactory *factory);\nstatic int swFactoryProcess_writer_loop_queue(swThreadParam *param);\n\nstatic int swFactoryProcess_notify(swFactory *factory, swDataHead *event);\nstatic int swFactoryProcess_dispatch(swFactory *factory, swDispatchData *buf);\nstatic int swFactoryProcess_finish(swFactory *factory, swSendData *data);\n\nstatic void swManager_signal_handle(int sig);\nstatic pid_t swManager_create_user_worker(swServer *serv, swWorker* worker);\n\nstatic swManagerProcess ManagerProcess;\n\nint swFactoryProcess_create(swFactory *factory, int writer_num, int worker_num)\n{\n    swFactoryProcess *object;\n    swServer *serv = SwooleG.serv;\n    object = SwooleG.memory_pool->alloc(SwooleG.memory_pool, sizeof(swFactoryProcess));\n    if (object == NULL)\n    {\n        swWarn(\"[Master] malloc[object] failed\");\n        return SW_ERR;\n    }\n    serv->writer_threads = SwooleG.memory_pool->alloc(SwooleG.memory_pool, serv->reactor_num * sizeof(swWorkerThread));\n    if (serv->writer_threads == NULL)\n    {\n        swWarn(\"[Master] malloc[object->writers] failed\");\n        return SW_ERR;\n    }\n    object->writer_pti = 0;\n\n    factory->object = object;\n    factory->dispatch = swFactoryProcess_dispatch;\n    factory->finish = swFactoryProcess_finish;\n    factory->start = swFactoryProcess_start;\n    factory->notify = swFactoryProcess_notify;\n    factory->shutdown = swFactoryProcess_shutdown;\n    factory->end = swFactoryProcess_end;\n    factory->onTask = NULL;\n    factory->onFinish = NULL;\n\n    return SW_OK;\n}\n\nint swFactoryProcess_shutdown(swFactory *factory)\n{\n    swServer *serv = SwooleG.serv;\n    int status;\n\n    if (kill(SwooleGS->manager_pid, SIGTERM) < 0)\n    {\n        swSysError(\"kill(%d) failed.\", SwooleGS->manager_pid);\n    }\n\n    if (swWaitpid(SwooleGS->manager_pid, &status, 0) < 0)\n    {\n        swSysError(\"waitpid(%d) failed.\", SwooleGS->manager_pid);\n    }\n\n    if (serv->ipc_mode == SW_IPC_MSGQUEUE)\n    {\n        swQueueMsg_set_destory(&serv->read_queue, 1);\n        serv->read_queue.free(&serv->read_queue);\n\n        swQueueMsg_set_destory(&serv->read_queue, 1);\n        serv->write_queue.free(&serv->write_queue);\n    }\n\n    //close pipes\n    return SW_OK;\n}\n\nint swFactoryProcess_start(swFactory *factory)\n{\n    if (swFactory_check_callback(factory) < 0)\n    {\n        swWarn(\"swFactory_check_callback failed\");\n        return SW_ERR;\n    }\n\n    int i;\n    swServer *serv = factory->ptr;\n    swWorker *worker;\n\n    for (i = 0; i < serv->worker_num; i++)\n    {\n        worker = swServer_get_worker(serv, i);\n        if (swWorker_create(worker) < 0)\n        {\n            return SW_ERR;\n        }\n    }\n\n    serv->reactor_pipe_num = serv->worker_num / serv->reactor_num;\n\n    //\u5fc5\u987b\u5148\u542f\u52a8manager\u8fdb\u7a0b\u7ec4\uff0c\u5426\u5219\u4f1a\u5e26\u7ebf\u7a0bfork\n    if (swFactoryProcess_manager_start(factory) < 0)\n    {\n        swWarn(\"swFactoryProcess_manager_start failed.\");\n        return SW_ERR;\n    }\n\n    if (serv->ipc_mode == SW_IPC_MSGQUEUE)\n    {\n        swQueueMsg_set_blocking(&serv->read_queue, 1);\n        //tcp & message queue require writer pthread\n        if (serv->have_tcp_sock == 1)\n        {\n            int ret = swFactoryProcess_writer_start(factory);\n            if (ret < 0)\n            {\n                return SW_ERR;\n            }\n        }\n    }\n    //\u4e3b\u8fdb\u7a0b\u9700\u8981\u8bbe\u7f6e\u4e3a\u76f4\u5199\u6a21\u5f0f\n    factory->finish = swFactory_finish;\n    return SW_OK;\n}\n\n\n//create worker child proccess\nstatic int swFactoryProcess_manager_start(swFactory *factory)\n{\n    swFactoryProcess *object = factory->object;\n    int i, ret;\n    pid_t pid;\n    int reactor_pti;\n    swServer *serv = factory->ptr;\n\n    if (serv->ipc_mode == SW_IPC_MSGQUEUE)\n    {\n        //\u8bfb\u6570\u636e\u961f\u5217\n        if (swQueueMsg_create(&serv->read_queue, 1, serv->message_queue_key, 1) < 0)\n        {\n            swError(\"[Master] swPipeMsg_create[In] fail. Error: %s [%d]\", strerror(errno), errno);\n            return SW_ERR;\n        }\n        //\u4e3aTCP\u521b\u5efa\u5199\u961f\u5217\n        if (serv->have_tcp_sock == 1)\n        {\n            //\u5199\u6570\u636e\u961f\u5217\n            if (swQueueMsg_create(&serv->write_queue, 1, serv->message_queue_key + 1, 1) < 0)\n            {\n                swError(\"[Master] swPipeMsg_create[out] fail. Error: %s [%d]\", strerror(errno), errno);\n                return SW_ERR;\n            }\n        }\n    }\n    else\n    {\n        object->pipes = sw_calloc(serv->worker_num, sizeof(swPipe));\n        if (object->pipes == NULL)\n        {\n            swError(\"malloc[worker_pipes] failed. Error: %s [%d]\", strerror(errno), errno);\n            return SW_ERR;\n        }\n        //worker\u8fdb\u7a0b\u7684pipes\n        for (i = 0; i < serv->worker_num; i++)\n        {\n            if (swPipeUnsock_create(&object->pipes[i], 1, SOCK_DGRAM) < 0)\n            {\n                return SW_ERR;\n            }\n            if (serv->ipc_mode == SW_IPC_UNSOCK)\n            {\n                serv->workers[i].pipe_master = object->pipes[i].getFd(&object->pipes[i], SW_PIPE_MASTER);\n                serv->workers[i].pipe_worker = object->pipes[i].getFd(&object->pipes[i], SW_PIPE_WORKER);\n                serv->workers[i].pipe_object = &object->pipes[i];\n                swServer_pipe_set(serv, serv->workers[i].pipe_object);\n            }\n        }\n    }\n\n    if (SwooleG.task_worker_num > 0)\n    {\n        key_t key = 0;\n        if (SwooleG.task_ipc_mode == SW_IPC_MSGQUEUE)\n        {\n            key = serv->message_queue_key + 2;\n        }\n\n        int task_num = SwooleG.task_worker_max > 0 ? SwooleG.task_worker_max : SwooleG.task_worker_num;\n        SwooleGS->task_num = SwooleG.task_worker_num;  //\u542f\u52a8min\u4e2a.\u6b64\u65f6\u7684pool->worker_num\u76f8\u5f53\u4e8emax\n\n        if (swProcessPool_create(&SwooleG.task_workers, task_num, serv->task_max_request, key, 1) < 0)\n        {\n            swWarn(\"[Master] create task_workers failed.\");\n            return SW_ERR;\n        }\n        \n        swProcessPool *pool = &SwooleG.task_workers;\n        swTaskWorker_init(pool);\n\n        int worker_id;\n        swWorker *worker;\n        for (i = 0; i < task_num; i++)\n        {\n            worker_id = serv->worker_num + i;\n            worker = swServer_get_worker(serv, worker_id);\n            if (swWorker_create(worker) < 0)\n            {\n                return SW_ERR;\n            }\n            if (SwooleG.task_ipc_mode == SW_IPC_UNSOCK)\n            {\n                swServer_pipe_set(serv, worker->pipe_object);\n            }\n            pool->workers[i].id = pool->start_id + i;\n            pool->workers[i].pool = pool;\n            pool->workers[i].type = pool->type;\n        }\n    }\n\n    pid = fork();\n    switch (pid)\n    {\n    //\u521b\u5efamanager\u8fdb\u7a0b\n    case 0:\n        //wait master process\n        SW_START_SLEEP;\n        if (SwooleGS->start == 0)\n        {\n            return SW_OK;\n        }\n        /**\n         * create worker process\n         */\n        for (i = 0; i < serv->worker_num; i++)\n        {\n            //close(worker_pipes[i].pipes[0]);\n            reactor_pti = (i % serv->writer_num);\n            serv->workers[i].reactor_id = reactor_pti;\n            pid = swFactoryProcess_worker_spawn(factory, i);\n            if (pid < 0)\n            {\n                swError(\"fork() failed.\");\n                return SW_ERR;\n            }\n            else\n            {\n                serv->workers[i].pid = pid;\n            }\n        }\n\n        /**\n         * create task worker process\n         */\n        if (SwooleG.task_worker_num > 0)\n        {\n            swProcessPool_start(&SwooleG.task_workers);\n        }\n\n        /**\n         * create user workers\n         */\n        if (serv->user_worker_list)\n        {\n            swUserWorker_node *user_worker;\n            LL_FOREACH(serv->user_worker_list, user_worker)\n            {\n                swManager_create_user_worker(serv, user_worker->worker);\n            }\n        }\n\n        //\u6807\u8bc6\u4e3a\u7ba1\u7406\u8fdb\u7a0b\n        SwooleG.process_type = SW_PROCESS_MANAGER;\n        ret = swFactoryProcess_manager_loop(factory);\n        exit(ret);\n        break;\n        //\u4e3b\u8fdb\u7a0b\n    default:\n        SwooleGS->manager_pid = pid;\n        break;\n    case -1:\n        swError(\"fork() failed.\");\n        return SW_ERR;\n    }\n    return SW_OK;\n}\n\nstatic pid_t swManager_create_user_worker(swServer *serv, swWorker* worker)\n{\n    pid_t pid = fork();\n\n    if (pid < 0)\n    {\n        swWarn(\"Fork Worker failed. Error: %s [%d]\", strerror(errno), errno);\n        return SW_ERR;\n    }\n    //child\n    else if (pid == 0)\n    {\n        serv->onUserWorkerStart(serv, worker);\n        exit(0);\n    }\n    //parent\n    else\n    {\n        if (worker->pid)\n        {\n            swHashMap_del_int(serv->user_worker_map, worker->pid);\n        }\n        worker->pid = pid;\n        swHashMap_add_int(serv->user_worker_map, pid, worker, NULL);\n        return pid;\n    }\n}\n\nstatic void swManager_signal_handle(int sig)\n{\n    swProcessPool *pool = &(SwooleG.task_workers);\n    swWorker *worker = NULL;\n    int i = 0,ret,over_load_num = 0,zero_load_num = 0;\n        \n    switch (sig)\n    {\n    case SIGTERM:\n        SwooleG.running = 0;\n        break;\n    case SIGALRM:\n        worker = &(pool->workers[SwooleGS->task_num]);\n        if(worker->del == 1&&worker->tasking_num == 0){\n            ret = kill(worker->pid, SIGTERM);\n            if (ret < 0)\n            {\n                    swWarn(\"[Manager]kill fail.pid=%d. Error: %s [%d]\", worker->pid, strerror(errno), errno);\n            }\n             alarm(1);\n             break;\n        }\n        for(;i<SwooleGS->task_num;i++)\n        {\n            worker = &(pool->workers[i]);\n            if(worker->tasking_num >=1)//todo support config\n            {\n                over_load_num++;\n            }\n            else// == 0\n            {\n               zero_load_num++;\n            }\n        }\n        \n        if(over_load_num>SwooleGS->task_num/2&&SwooleGS->task_num<SwooleG.task_worker_max)\n        {\n           if(swProcessPool_spawn(&(pool->workers[SwooleGS->task_num])) < 0)\n           {\n                swWarn(\"swProcessPool_spawn fail\");\n           }\n           else\n           {\n                SwooleGS->task_num++;\n           }\n        }\n        else if(zero_load_num>=SwooleG.task_worker_num&&SwooleGS->task_num>SwooleG.task_worker_num)\n        { \n                  SwooleG.task_recycle_num++;\n                  if(SwooleG.task_recycle_num>3)\n                  {\n                    SwooleGS->task_num--;\n                    worker = &(pool->workers[SwooleGS->task_num]);\n                    worker->del = 1;\n                    SwooleG.task_recycle_num = 0;\n                  }\n        }\n        alarm(1);\n        break;\n    /**\n     * reload all workers\n     */\n    case SIGUSR1:\n        if (ManagerProcess.reloading == 0)\n        {\n            ManagerProcess.reloading = 1;\n            ManagerProcess.reload_event_worker = 1;\n        }\n        break;\n    /**\n     * only reload task workers\n     */\n    case SIGUSR2:\n        if (ManagerProcess.reloading == 0)\n        {\n            ManagerProcess.reloading = 1;\n            ManagerProcess.reload_task_worker = 1;\n        }\n        break;\n    default:\n        break;\n    }\n}\n\nstatic int swFactoryProcess_manager_loop(swFactory *factory)\n{\n    int pid, new_pid;\n    int i;\n    int reload_worker_i = 0;\n    int reload_worker_num;\n    int ret;\n    int worker_exit_code;\n\n    SwooleG.use_signalfd = 0;\n    SwooleG.use_timerfd = 0;\n\n    memset(&ManagerProcess, 0, sizeof(ManagerProcess));\n\n    swServer *serv = factory->ptr;\n    swWorker *reload_workers;\n\n    if (serv->onManagerStart)\n    {\n        serv->onManagerStart(serv);\n    }\n\n    reload_worker_num = serv->worker_num + SwooleG.task_worker_num;\n    reload_workers = sw_calloc(reload_worker_num, sizeof(swWorker));\n    if (reload_workers == NULL)\n    {\n        swError(\"malloc[reload_workers] failed\");\n        return SW_ERR;\n    }\n\n    //for reload\n    swSignal_add(SIGHUP, NULL);\n    swSignal_add(SIGTERM, swManager_signal_handle);\n    swSignal_add(SIGUSR1, swManager_signal_handle);\n    swSignal_add(SIGUSR2, swManager_signal_handle);\n    //swSignal_add(SIGINT, swManager_signal_handle);\n    \n     //for add/recycle task process\n    if(SwooleG.task_worker_max>0)\n    {\n             swSignal_add(SIGALRM, swManager_signal_handle);\n             alarm(1);\n    }\n\n    while (SwooleG.running > 0)\n    {\n        pid = wait(&worker_exit_code);\n\n        if (pid < 0)\n        {\n            if (ManagerProcess.reloading == 0)\n            {\n                swTrace(\"wait() failed. Error: %s [%d]\", strerror(errno), errno);\n            }\n            else if (ManagerProcess.reload_event_worker == 1)\n            {\n                memcpy(reload_workers, serv->workers, sizeof(swWorker) * serv->worker_num);\n                reload_worker_num = serv->worker_num;\n                if (SwooleG.task_worker_num > 0)\n                {\n                    memcpy(reload_workers + serv->worker_num, SwooleG.task_workers.workers,\n                            sizeof(swWorker) * SwooleG.task_worker_num);\n                    reload_worker_num += SwooleG.task_worker_num;\n                }\n                reload_worker_i = 0;\n                ManagerProcess.reload_event_worker = 0;\n                goto kill_worker;\n            }\n            else if (ManagerProcess.reload_task_worker == 1)\n            {\n                if (SwooleG.task_worker_num == 0)\n                {\n                    swWarn(\"Cannot reload workers, because server no have task workers.\");\n                    continue;\n                }\n                memcpy(reload_workers, SwooleG.task_workers.workers, sizeof(swWorker) * SwooleG.task_worker_num);\n                reload_worker_num = SwooleG.task_worker_num;\n                reload_worker_i = 0;\n                ManagerProcess.reload_task_worker = 0;\n                goto kill_worker;\n            }\n        }\n        if (SwooleG.running == 1)\n        {\n            for (i = 0; i < serv->worker_num; i++)\n            {\n                //compare PID\n                if (pid != serv->workers[i].pid)\n                {\n                    continue;\n                }\n                else\n                {\n                    if (serv->onWorkerError != NULL && WEXITSTATUS(worker_exit_code) > 0)\n                    {\n                        serv->onWorkerError(serv, i, pid, WEXITSTATUS(worker_exit_code));\n                    }\n                    pid = 0;\n                    while (1)\n                    {\n                        new_pid = swFactoryProcess_worker_spawn(factory, i);\n                        if (new_pid < 0)\n                        {\n                            usleep(100000);\n                            continue;\n                        }\n                        else\n                        {\n                            serv->workers[i].pid = new_pid;\n                            break;\n                        }\n                    }\n                }\n            }\n\n            //task worker\n            if (pid > 0)\n            {\n                swWorker *exit_worker = swHashMap_find_int(SwooleG.task_workers.map, pid);\n                if (exit_worker != NULL)\n                {\n                    if(exit_worker->del == 1)//\u4e3b\u52a8\u56de\u6536\u4e0d\u91cd\u542f\n                    {\n                        exit_worker->del = 0;\n                    }\n                    else\n                    {\n                      swProcessPool_spawn(exit_worker);\n                      goto kill_worker;\n                    }\n                }\n\n                if(serv->user_worker_map != NULL)\n                {\n                    exit_worker = swHashMap_find_int(serv->user_worker_map, pid);\n                    if (exit_worker != NULL)\n                    {\n                        swManager_create_user_worker(serv, exit_worker);\n                        goto kill_worker;\n                    }\n                }\n            }\n        }\n        //reload worker\n        kill_worker:\n        if (ManagerProcess.reloading == 1)\n        {\n            //reload finish\n            if (reload_worker_i >= reload_worker_num)\n            {\n                ManagerProcess.reloading = 0;\n                reload_worker_i = 0;\n                continue;\n            }\n            ret = kill(reload_workers[reload_worker_i].pid, SIGTERM);\n            if (ret < 0)\n            {\n                swSysError(\"[Manager]kill(%d) failed.\", reload_workers[reload_worker_i].pid);\n                continue;\n            }\n            reload_worker_i++;\n        }\n    }\n\n    sw_free(reload_workers);\n\n    //kill all child process\n    for (i = 0; i < serv->worker_num; i++)\n    {\n        swTrace(\"[Manager]kill worker processor\");\n        kill(serv->workers[i].pid, SIGTERM);\n    }\n\n    if (SwooleG.task_worker_num > 0)\n    {\n        swProcessPool_shutdown(&SwooleG.task_workers);\n    }\n\n    if (serv->onManagerStop)\n    {\n        serv->onManagerStop(serv);\n    }\n    return SW_OK;\n}\n\nstatic int swFactoryProcess_worker_spawn(swFactory *factory, int worker_pti)\n{\n    int pid, ret;\n    struct passwd *passwd;\n    struct group *group;\n    int is_root = !geteuid();\n\n    pid = fork();\n    if (pid < 0)\n    {\n        swWarn(\"Fork Worker failed. Error: %s [%d]\", strerror(errno), errno);\n        return SW_ERR;\n    }\n    //worker child processor\n    else if (pid == 0)\n    {\n        if(is_root) \n        {\n            passwd = getpwnam(SwooleG.user);\n            group  = getgrnam(SwooleG.group);\n\n            if(passwd != NULL) \n            {\n                if (0 > setuid(passwd->pw_uid)) \n                {\n                    swWarn(\"setuid to %s fail \\r\\n\", SwooleG.user);\n                }\n            }\n            else\n            {\n                swWarn(\"get user %s info fail \\r\\n\", SwooleG.user);\n            }\n\n            if(group != NULL) \n            {\n                if(0 > setgid(group->gr_gid)) \n                {\n                    swWarn(\"setgid to %s fail \\r\\n\", SwooleG.group);\n                }\n            }\n            else\n            {\n                swWarn(\"get group %s info fail \\r\\n\", SwooleG.group);\n            }\n        }\n        ret = swWorker_loop(factory, worker_pti);\n        exit(ret);\n    }\n    //parent,add to writer\n    else\n    {\n        return pid;\n    }\n}\n\n/**\n * Close the connection\n */\nint swFactoryProcess_end(swFactory *factory, int fd)\n{\n    swServer *serv = factory->ptr;\n    swSendData _send;\n\n    bzero(&_send, sizeof(_send));\n    _send.info.fd = fd;\n    _send.info.len = 0;\n    _send.info.type = SW_EVENT_CLOSE;\n\n    swConnection *conn = swServer_connection_get(serv, _send.info.fd);\n    if (conn == NULL || conn->active == 0)\n    {\n        //swWarn(\"can not close. Connection[%d] not found.\", _send.info.fd);\n        return SW_ERR;\n    }\n    else if (conn->closing)\n    {\n        swWarn(\"The connection[%d] is closing.\", fd);\n        return SW_ERR;\n    }\n    else if (conn->closed)\n    {\n        return SW_ERR;\n    }\n    else\n    {\n        if (serv->onClose != NULL)\n        {\n            serv->onClose(serv, fd, conn->from_id);\n        }\n        conn->closed = 1;\n        return swFactoryProcess_finish(factory, &_send);\n    }\n}\n\n/**\n * worker: send to client\n */\nint swFactoryProcess_finish(swFactory *factory, swSendData *resp)\n{\n    int ret, sendn;\n    swServer *serv = factory->ptr;\n    int fd = resp->info.fd;\n\n    //unix dgram\n    if (resp->info.type == SW_EVENT_UNIX_DGRAM)\n    {\n        socklen_t len;\n        struct sockaddr_un addr_un;\n        int from_sock = resp->info.from_fd;\n\n        addr_un.sun_family = AF_UNIX;\n        memcpy(addr_un.sun_path, resp->sun_path, resp->sun_path_len);\n        len = sizeof(addr_un);\n        ret = swSendto(from_sock, resp->data, resp->info.len, 0, (struct sockaddr *) &addr_un, len);\n        goto finish;\n    }\n    //UDP pacakge\n    else if (resp->info.type == SW_EVENT_UDP || resp->info.type == SW_EVENT_UDP6)\n    {\n        return swServer_udp_send(serv, resp);\n    }\n\n    //for message queue\n    swEventData_overflow sdata;\n    sdata.pti = (SwooleWG.id % serv->writer_num) + 1;\n\n    swConnection *conn = swServer_connection_get(serv, fd);\n    if (conn == NULL || conn->active == 0)\n    {\n        swWarn(\"send failed, because connection[%d] has been closed.\", fd);\n        return SW_ERR;\n    }\n\n    sdata._send.info.fd = fd;\n    sdata._send.info.type = resp->info.type;\n    swWorker *worker = swServer_get_worker(serv, SwooleWG.id);\n\n\t/**\n     * Big response, use shared memory\n     */\n    if (resp->length > 0)\n    {\n        swPackage_response response;\n\n        worker->lock.lock(&worker->lock);\n\n        response.length = resp->length;\n        response.worker_id = SwooleWG.id;\n\n        //swWarn(\"BigPackage, length=%d|worker_id=%d\", response.length, response.worker_id);\n\n        sdata._send.info.from_fd = SW_RESPONSE_BIG;\n        sdata._send.info.len = sizeof(response);\n\n        memcpy(sdata._send.data, &response, sizeof(response));\n        memcpy(worker->send_shm, resp->data, resp->length);\n    }\n    else\n    {\n        //copy data\n        memcpy(sdata._send.data, resp->data, resp->info.len);\n\n        sdata._send.info.len = resp->info.len;\n        sdata._send.info.from_fd = SW_RESPONSE_SMALL;\n    }\n\n#if SW_REACTOR_SCHEDULE == 2\n    sdata._send.info.from_id = fd % serv->reactor_num;\n#else\n    sdata._send.info.from_id = conn->from_id;\n#endif\n\n    sendn = sdata._send.info.len + sizeof(resp->info);\n    //swWarn(\"send: sendn=%d|type=%d|content=%s\", sendn, resp->info.type, resp->data);\n    swTrace(\"[Worker]input_queue[%ld]->in| fd=%d\", sdata.pti, fd);\n\n    ret = swWorker_send2reactor(&sdata, sendn, fd);\n\n    finish:\n    if (ret < 0)\n    {\n        swWarn(\"sendto to reactor failed. Error: %s [%d]\", strerror(errno), errno);\n    }\n    return ret;\n}\n\nstatic __thread struct\n{\n    long target_worker_id;\n    swDataHead _send;\n} sw_notify_data;\n\n/**\n * \u4e3b\u8fdb\u7a0b\u901a\u77e5worker\u8fdb\u7a0b\n */\nint swFactoryProcess_notify(swFactory *factory, swDataHead *ev)\n{\n    memcpy(&sw_notify_data._send, ev, sizeof(swDataHead));\n    sw_notify_data._send.len = 0;\n    sw_notify_data.target_worker_id = -1;\n    return factory->dispatch(factory, (swDispatchData *) &sw_notify_data);\n}\n\n/**\n * [ReactorThread] dispatch request to worker\n */\nint swFactoryProcess_dispatch(swFactory *factory, swDispatchData *task)\n{\n    uint32_t schedule_key;\n    uint32_t send_len = sizeof(task->data.info) + task->data.info.len;\n    uint16_t target_worker_id;\n    swServer *serv = SwooleG.serv;\n\n    if (task->target_worker_id < 0)\n    {\n        //udp use remote port\n        if (task->data.info.type == SW_EVENT_UDP || task->data.info.type == SW_EVENT_UDP6\n                || task->data.info.type == SW_EVENT_UNIX_DGRAM)\n        {\n            if (serv->dispatch_mode == SW_DISPATCH_IPMOD)\n            {\n                schedule_key = task->data.info.fd;\n            }\n            else\n            {\n                schedule_key = task->data.info.from_id;\n            }\n        }\n        else\n        {\n            schedule_key = task->data.info.fd;\n        }\n\n#ifndef SW_USE_RINGBUFFER\n        if (SwooleTG.factory_lock_target)\n        {\n            if (SwooleTG.factory_target_worker < 0)\n            {\n                target_worker_id = swServer_worker_schedule(serv, schedule_key);\n                SwooleTG.factory_target_worker = target_worker_id;\n            }\n            else\n            {\n                target_worker_id = SwooleTG.factory_target_worker;\n            }\n        }\n        else\n#endif\n        {\n            target_worker_id = swServer_worker_schedule(serv, schedule_key);\n        }\n    }\n    else\n    {\n        target_worker_id = task->target_worker_id;\n    }\n\n    if (SwooleTG.type == SW_THREAD_REACTOR)\n    {\n        return swReactorThread_send2worker((void *) &(task->data), send_len, target_worker_id);\n    }\n    else\n    {\n        return swServer_send2worker_blocking(serv, (void *) &(task->data), send_len, target_worker_id);\n    }\n}\n\n/**\n * for message queue\n */\nstatic int swFactoryProcess_writer_start(swFactory *factory)\n{\n    swServer *serv = SwooleG.serv;\n    swThreadParam *param;\n    int i;\n    pthread_t pidt;\n\n    for (i = 0; i < serv->writer_num; i++)\n    {\n        param = sw_malloc(sizeof(swPipe));\n        if (param == NULL)\n        {\n            swSysError(\"malloc failed.\");\n            return SW_ERR;\n        }\n        param->object = factory;\n        param->pti = i;\n        if (pthread_create(&pidt, NULL, (swThreadStartFunc) swFactoryProcess_writer_loop_queue, (void *) param) < 0)\n        {\n            swSysError(\"pthread_create() failed.\");\n            return SW_ERR;\n        }\n        pthread_detach(pidt);\n        serv->writer_threads[i].ptid = pidt;\n        SW_START_SLEEP;\n    }\n    return SW_OK;\n}\n\n/**\n * Use message queue ipc\n */\nint swFactoryProcess_writer_loop_queue(swThreadParam *param)\n{\n    swEventData *resp;\n    swServer *serv = SwooleG.serv;\n    swConnection *conn;\n\n    int pti = param->pti;\n    swQueue_data sdata;\n    //\u5fc5\u987b\u52a01,msg_type\u5fc5\u987b\u4e0d\u80fd\u4e3a0\n    sdata.mtype = pti + 1;\n\n    swSignal_none();\n    while (SwooleG.running > 0)\n    {\n        swTrace(\"[Writer]wt_queue[%ld]->out wait\", sdata.mtype);\n        if (serv->write_queue.out(&serv->write_queue, &sdata, sizeof(sdata.mdata)) < 0)\n        {\n            swSysError(\"[writer#%d]wt_queue->out() failed.\", pti);\n        }\n        else\n        {\n            int ret;\n            resp = (swEventData *) sdata.mdata;\n            conn = swServer_connection_get(serv, resp->info.fd);\n            if (!conn)\n            {\n                swWarn(\"Connection[%d] not found.\", resp->info.fd);\n                continue;\n            }\n            swReactor *reactor = &serv->reactor_threads[conn->from_id].reactor;\n            //close connection\n            //TODO: thread safe, should close in reactor thread.\n            if (resp->info.type == SW_EVENT_CLOSE)\n            {\n                close_fd:\n                reactor->close(reactor, resp->info.fd);\n                continue;\n            }\n            //sendfile\n            else if (resp->info.type == SW_EVENT_SENDFILE)\n            {\n                ret = swSocket_sendfile_sync(resp->info.fd, resp->data, SW_WRITER_TIMEOUT);\n            }\n            //send data\n            else\n            {\n                ret = swConnection_send_blocking(resp->info.fd, resp->data, resp->info.len, 1000 * SW_WRITER_TIMEOUT);\n            }\n\n            if (ret < 0)\n            {\n                switch (swConnection_error(errno))\n                {\n                case SW_ERROR:\n                    swSysError(\"send to client[%d] failed.\", resp->info.fd);\n                    break;\n                case SW_CLOSE:\n                    goto close_fd;\n                default:\n                    break;\n                }\n            }\n        }\n    }\n    pthread_exit((void *) param);\n    return SW_OK;\n}\n",
        "b_contents": "/*\n  +----------------------------------------------------------------------+\n  | Swoole                                                               |\n  +----------------------------------------------------------------------+\n  | This source file is subject to version 2.0 of the Apache license,    |\n  | that is bundled with this package in the file LICENSE, and is        |\n  | available through the world-wide-web at the following url:           |\n  | http://www.apache.org/licenses/LICENSE-2.0.html                      |\n  | If you did not receive a copy of the Apache2.0 license and are unable|\n  | to obtain it through the world-wide-web, please send a note to       |\n  | license@php.net so we can mail you a copy immediately.               |\n  +----------------------------------------------------------------------+\n  | Author: Tianfeng Han  <mikan.tenny@gmail.com>                        |\n  +----------------------------------------------------------------------+\n*/\n\n#include \"swoole.h\"\n#include \"Server.h\"\n#include <signal.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n\ntypedef struct\n{\n    uint8_t reloading;\n    uint8_t reload_event_worker;\n    uint8_t reload_task_worker;\n\n} swManagerProcess;\n\nstatic int swFactoryProcess_manager_loop(swFactory *factory);\nstatic int swFactoryProcess_manager_start(swFactory *factory);\n\nstatic int swFactoryProcess_worker_spawn(swFactory *factory, int worker_pti);\n\nstatic int swFactoryProcess_writer_start(swFactory *factory);\nstatic int swFactoryProcess_writer_loop_queue(swThreadParam *param);\n\nstatic int swFactoryProcess_notify(swFactory *factory, swDataHead *event);\nstatic int swFactoryProcess_dispatch(swFactory *factory, swDispatchData *buf);\nstatic int swFactoryProcess_finish(swFactory *factory, swSendData *data);\n\nstatic void swManager_signal_handle(int sig);\nstatic pid_t swManager_create_user_worker(swServer *serv, swWorker* worker);\n\nstatic swManagerProcess ManagerProcess;\n\nint swFactoryProcess_create(swFactory *factory, int writer_num, int worker_num)\n{\n    swFactoryProcess *object;\n    swServer *serv = SwooleG.serv;\n    object = SwooleG.memory_pool->alloc(SwooleG.memory_pool, sizeof(swFactoryProcess));\n    if (object == NULL)\n    {\n        swWarn(\"[Master] malloc[object] failed\");\n        return SW_ERR;\n    }\n    serv->writer_threads = SwooleG.memory_pool->alloc(SwooleG.memory_pool, serv->reactor_num * sizeof(swWorkerThread));\n    if (serv->writer_threads == NULL)\n    {\n        swWarn(\"[Master] malloc[object->writers] failed\");\n        return SW_ERR;\n    }\n    object->writer_pti = 0;\n\n    factory->object = object;\n    factory->dispatch = swFactoryProcess_dispatch;\n    factory->finish = swFactoryProcess_finish;\n    factory->start = swFactoryProcess_start;\n    factory->notify = swFactoryProcess_notify;\n    factory->shutdown = swFactoryProcess_shutdown;\n    factory->end = swFactoryProcess_end;\n    factory->onTask = NULL;\n    factory->onFinish = NULL;\n\n    return SW_OK;\n}\n\nint swFactoryProcess_shutdown(swFactory *factory)\n{\n    swServer *serv = SwooleG.serv;\n    int status;\n\n    if (kill(SwooleGS->manager_pid, SIGTERM) < 0)\n    {\n        swSysError(\"kill(%d) failed.\", SwooleGS->manager_pid);\n    }\n\n    if (swWaitpid(SwooleGS->manager_pid, &status, 0) < 0)\n    {\n        swSysError(\"waitpid(%d) failed.\", SwooleGS->manager_pid);\n    }\n\n    if (serv->ipc_mode == SW_IPC_MSGQUEUE)\n    {\n        swQueueMsg_set_destory(&serv->read_queue, 1);\n        serv->read_queue.free(&serv->read_queue);\n\n        swQueueMsg_set_destory(&serv->read_queue, 1);\n        serv->write_queue.free(&serv->write_queue);\n    }\n\n    //close pipes\n    return SW_OK;\n}\n\nint swFactoryProcess_start(swFactory *factory)\n{\n    if (swFactory_check_callback(factory) < 0)\n    {\n        swWarn(\"swFactory_check_callback failed\");\n        return SW_ERR;\n    }\n\n    int i;\n    swServer *serv = factory->ptr;\n    swWorker *worker;\n\n    for (i = 0; i < serv->worker_num; i++)\n    {\n        worker = swServer_get_worker(serv, i);\n        if (swWorker_create(worker) < 0)\n        {\n            return SW_ERR;\n        }\n    }\n\n    serv->reactor_pipe_num = serv->worker_num / serv->reactor_num;\n\n    //\u5fc5\u987b\u5148\u542f\u52a8manager\u8fdb\u7a0b\u7ec4\uff0c\u5426\u5219\u4f1a\u5e26\u7ebf\u7a0bfork\n    if (swFactoryProcess_manager_start(factory) < 0)\n    {\n        swWarn(\"swFactoryProcess_manager_start failed.\");\n        return SW_ERR;\n    }\n\n    if (serv->ipc_mode == SW_IPC_MSGQUEUE)\n    {\n        swQueueMsg_set_blocking(&serv->read_queue, 1);\n        //tcp & message queue require writer pthread\n        if (serv->have_tcp_sock == 1)\n        {\n            int ret = swFactoryProcess_writer_start(factory);\n            if (ret < 0)\n            {\n                return SW_ERR;\n            }\n        }\n    }\n    //\u4e3b\u8fdb\u7a0b\u9700\u8981\u8bbe\u7f6e\u4e3a\u76f4\u5199\u6a21\u5f0f\n    factory->finish = swFactory_finish;\n    return SW_OK;\n}\n\n\n//create worker child proccess\nstatic int swFactoryProcess_manager_start(swFactory *factory)\n{\n    swFactoryProcess *object = factory->object;\n    int i, ret;\n    pid_t pid;\n    int reactor_pti;\n    swServer *serv = factory->ptr;\n\n    if (serv->ipc_mode == SW_IPC_MSGQUEUE)\n    {\n        //\u8bfb\u6570\u636e\u961f\u5217\n        if (swQueueMsg_create(&serv->read_queue, 1, serv->message_queue_key, 1) < 0)\n        {\n            swError(\"[Master] swPipeMsg_create[In] fail. Error: %s [%d]\", strerror(errno), errno);\n            return SW_ERR;\n        }\n        //\u4e3aTCP\u521b\u5efa\u5199\u961f\u5217\n        if (serv->have_tcp_sock == 1)\n        {\n            //\u5199\u6570\u636e\u961f\u5217\n            if (swQueueMsg_create(&serv->write_queue, 1, serv->message_queue_key + 1, 1) < 0)\n            {\n                swError(\"[Master] swPipeMsg_create[out] fail. Error: %s [%d]\", strerror(errno), errno);\n                return SW_ERR;\n            }\n        }\n    }\n    else\n    {\n        object->pipes = sw_calloc(serv->worker_num, sizeof(swPipe));\n        if (object->pipes == NULL)\n        {\n            swError(\"malloc[worker_pipes] failed. Error: %s [%d]\", strerror(errno), errno);\n            return SW_ERR;\n        }\n        //worker\u8fdb\u7a0b\u7684pipes\n        for (i = 0; i < serv->worker_num; i++)\n        {\n            if (swPipeUnsock_create(&object->pipes[i], 1, SOCK_DGRAM) < 0)\n            {\n                return SW_ERR;\n            }\n            if (serv->ipc_mode == SW_IPC_UNSOCK)\n            {\n                serv->workers[i].pipe_master = object->pipes[i].getFd(&object->pipes[i], SW_PIPE_MASTER);\n                serv->workers[i].pipe_worker = object->pipes[i].getFd(&object->pipes[i], SW_PIPE_WORKER);\n                serv->workers[i].pipe_object = &object->pipes[i];\n                swServer_pipe_set(serv, serv->workers[i].pipe_object);\n            }\n        }\n    }\n\n    if (SwooleG.task_worker_num > 0)\n    {\n        key_t key = 0;\n        if (SwooleG.task_ipc_mode == SW_IPC_MSGQUEUE)\n        {\n            key = serv->message_queue_key + 2;\n        }\n\n        int task_num = SwooleG.task_worker_max > 0 ? SwooleG.task_worker_max : SwooleG.task_worker_num;\n        SwooleGS->task_num = SwooleG.task_worker_num;  //\u542f\u52a8min\u4e2a.\u6b64\u65f6\u7684pool->worker_num\u76f8\u5f53\u4e8emax\n\n        if (swProcessPool_create(&SwooleG.task_workers, task_num, serv->task_max_request, key, 1) < 0)\n        {\n            swWarn(\"[Master] create task_workers failed.\");\n            return SW_ERR;\n        }\n        \n        swProcessPool *pool = &SwooleG.task_workers;\n        swTaskWorker_init(pool);\n\n        int worker_id;\n        swWorker *worker;\n        for (i = 0; i < task_num; i++)\n        {\n            worker_id = serv->worker_num + i;\n            worker = swServer_get_worker(serv, worker_id);\n            if (swWorker_create(worker) < 0)\n            {\n                return SW_ERR;\n            }\n            if (SwooleG.task_ipc_mode == SW_IPC_UNSOCK)\n            {\n                swServer_pipe_set(serv, worker->pipe_object);\n            }\n            pool->workers[i].id = pool->start_id + i;\n            pool->workers[i].pool = pool;\n            pool->workers[i].type = pool->type;\n        }\n    }\n\n    pid = fork();\n    switch (pid)\n    {\n    //\u521b\u5efamanager\u8fdb\u7a0b\n    case 0:\n        //wait master process\n        SW_START_SLEEP;\n        if (SwooleGS->start == 0)\n        {\n            return SW_OK;\n        }\n        /**\n         * create worker process\n         */\n        for (i = 0; i < serv->worker_num; i++)\n        {\n            //close(worker_pipes[i].pipes[0]);\n            reactor_pti = (i % serv->writer_num);\n            serv->workers[i].reactor_id = reactor_pti;\n            pid = swFactoryProcess_worker_spawn(factory, i);\n            if (pid < 0)\n            {\n                swError(\"fork() failed.\");\n                return SW_ERR;\n            }\n            else\n            {\n                serv->workers[i].pid = pid;\n            }\n        }\n\n        /**\n         * create task worker process\n         */\n        if (SwooleG.task_worker_num > 0)\n        {\n            swProcessPool_start(&SwooleG.task_workers);\n        }\n\n        /**\n         * create user workers\n         */\n        if (serv->user_worker_list)\n        {\n            swUserWorker_node *user_worker;\n            LL_FOREACH(serv->user_worker_list, user_worker)\n            {\n                swManager_create_user_worker(serv, user_worker->worker);\n            }\n        }\n\n        //\u6807\u8bc6\u4e3a\u7ba1\u7406\u8fdb\u7a0b\n        SwooleG.process_type = SW_PROCESS_MANAGER;\n        SwooleG.pid = getpid();\n\n        ret = swFactoryProcess_manager_loop(factory);\n        exit(ret);\n        break;\n        //\u4e3b\u8fdb\u7a0b\n    default:\n        SwooleGS->manager_pid = pid;\n        break;\n    case -1:\n        swError(\"fork() failed.\");\n        return SW_ERR;\n    }\n    return SW_OK;\n}\n\nstatic pid_t swManager_create_user_worker(swServer *serv, swWorker* worker)\n{\n    pid_t pid = fork();\n\n    if (pid < 0)\n    {\n        swWarn(\"Fork Worker failed. Error: %s [%d]\", strerror(errno), errno);\n        return SW_ERR;\n    }\n    //child\n    else if (pid == 0)\n    {\n        serv->onUserWorkerStart(serv, worker);\n        exit(0);\n    }\n    //parent\n    else\n    {\n        if (worker->pid)\n        {\n            swHashMap_del_int(serv->user_worker_map, worker->pid);\n        }\n        worker->pid = pid;\n        swHashMap_add_int(serv->user_worker_map, pid, worker, NULL);\n        return pid;\n    }\n}\n\nstatic void swManager_signal_handle(int sig)\n{\n    swProcessPool *pool = &(SwooleG.task_workers);\n    swWorker *worker = NULL;\n    int i = 0,ret,over_load_num = 0,zero_load_num = 0;\n        \n    switch (sig)\n    {\n    case SIGTERM:\n        SwooleG.running = 0;\n        break;\n    case SIGALRM:\n        worker = &(pool->workers[SwooleGS->task_num]);\n        if(worker->del == 1&&worker->tasking_num == 0){\n            ret = kill(worker->pid, SIGTERM);\n            if (ret < 0)\n            {\n                    swWarn(\"[Manager]kill fail.pid=%d. Error: %s [%d]\", worker->pid, strerror(errno), errno);\n            }\n             alarm(1);\n             break;\n        }\n        for(;i<SwooleGS->task_num;i++)\n        {\n            worker = &(pool->workers[i]);\n            if(worker->tasking_num >=1)//todo support config\n            {\n                over_load_num++;\n            }\n            else// == 0\n            {\n               zero_load_num++;\n            }\n        }\n        \n        if(over_load_num>SwooleGS->task_num/2&&SwooleGS->task_num<SwooleG.task_worker_max)\n        {\n           if(swProcessPool_spawn(&(pool->workers[SwooleGS->task_num])) < 0)\n           {\n                swWarn(\"swProcessPool_spawn fail\");\n           }\n           else\n           {\n                SwooleGS->task_num++;\n           }\n        }\n        else if(zero_load_num>=SwooleG.task_worker_num&&SwooleGS->task_num>SwooleG.task_worker_num)\n        { \n                  SwooleG.task_recycle_num++;\n                  if(SwooleG.task_recycle_num>3)\n                  {\n                    SwooleGS->task_num--;\n                    worker = &(pool->workers[SwooleGS->task_num]);\n                    worker->del = 1;\n                    SwooleG.task_recycle_num = 0;\n                  }\n        }\n        alarm(1);\n        break;\n    /**\n     * reload all workers\n     */\n    case SIGUSR1:\n        if (ManagerProcess.reloading == 0)\n        {\n            ManagerProcess.reloading = 1;\n            ManagerProcess.reload_event_worker = 1;\n        }\n        break;\n    /**\n     * only reload task workers\n     */\n    case SIGUSR2:\n        if (ManagerProcess.reloading == 0)\n        {\n            ManagerProcess.reloading = 1;\n            ManagerProcess.reload_task_worker = 1;\n        }\n        break;\n    default:\n        break;\n    }\n}\n\nstatic int swFactoryProcess_manager_loop(swFactory *factory)\n{\n    int pid, new_pid;\n    int i;\n    int reload_worker_i = 0;\n    int reload_worker_num;\n    int ret;\n    int worker_exit_code;\n\n    SwooleG.use_signalfd = 0;\n    SwooleG.use_timerfd = 0;\n\n    memset(&ManagerProcess, 0, sizeof(ManagerProcess));\n\n    swServer *serv = factory->ptr;\n    swWorker *reload_workers;\n\n    if (serv->onManagerStart)\n    {\n        serv->onManagerStart(serv);\n    }\n\n    reload_worker_num = serv->worker_num + SwooleG.task_worker_num;\n    reload_workers = sw_calloc(reload_worker_num, sizeof(swWorker));\n    if (reload_workers == NULL)\n    {\n        swError(\"malloc[reload_workers] failed\");\n        return SW_ERR;\n    }\n\n    //for reload\n    swSignal_add(SIGHUP, NULL);\n    swSignal_add(SIGTERM, swManager_signal_handle);\n    swSignal_add(SIGUSR1, swManager_signal_handle);\n    swSignal_add(SIGUSR2, swManager_signal_handle);\n    //swSignal_add(SIGINT, swManager_signal_handle);\n    \n     //for add/recycle task process\n    if (SwooleG.task_worker_max > 0)\n    {\n        swSignal_add(SIGALRM, swManager_signal_handle);\n        alarm(1);\n    }\n\n    while (SwooleG.running > 0)\n    {\n        pid = wait(&worker_exit_code);\n\n        if (pid < 0)\n        {\n            if (ManagerProcess.reloading == 0)\n            {\n                swTrace(\"wait() failed. Error: %s [%d]\", strerror(errno), errno);\n            }\n            else if (ManagerProcess.reload_event_worker == 1)\n            {\n                memcpy(reload_workers, serv->workers, sizeof(swWorker) * serv->worker_num);\n                reload_worker_num = serv->worker_num;\n                if (SwooleG.task_worker_num > 0)\n                {\n                    memcpy(reload_workers + serv->worker_num, SwooleG.task_workers.workers,\n                            sizeof(swWorker) * SwooleG.task_worker_num);\n                    reload_worker_num += SwooleG.task_worker_num;\n                }\n                reload_worker_i = 0;\n                ManagerProcess.reload_event_worker = 0;\n                goto kill_worker;\n            }\n            else if (ManagerProcess.reload_task_worker == 1)\n            {\n                if (SwooleG.task_worker_num == 0)\n                {\n                    swWarn(\"Cannot reload workers, because server no have task workers.\");\n                    continue;\n                }\n                memcpy(reload_workers, SwooleG.task_workers.workers, sizeof(swWorker) * SwooleG.task_worker_num);\n                reload_worker_num = SwooleG.task_worker_num;\n                reload_worker_i = 0;\n                ManagerProcess.reload_task_worker = 0;\n                goto kill_worker;\n            }\n        }\n        if (SwooleG.running == 1)\n        {\n            for (i = 0; i < serv->worker_num; i++)\n            {\n                //compare PID\n                if (pid != serv->workers[i].pid)\n                {\n                    continue;\n                }\n                else\n                {\n                    if (serv->onWorkerError != NULL && WEXITSTATUS(worker_exit_code) > 0)\n                    {\n                        serv->onWorkerError(serv, i, pid, WEXITSTATUS(worker_exit_code));\n                    }\n                    pid = 0;\n                    while (1)\n                    {\n                        new_pid = swFactoryProcess_worker_spawn(factory, i);\n                        if (new_pid < 0)\n                        {\n                            usleep(100000);\n                            continue;\n                        }\n                        else\n                        {\n                            serv->workers[i].pid = new_pid;\n                            break;\n                        }\n                    }\n                }\n            }\n\n            //task worker\n            if (pid > 0)\n            {\n                swWorker *exit_worker = swHashMap_find_int(SwooleG.task_workers.map, pid);\n                if (exit_worker != NULL)\n                {\n                    if(exit_worker->del == 1)//\u4e3b\u52a8\u56de\u6536\u4e0d\u91cd\u542f\n                    {\n                        exit_worker->del = 0;\n                    }\n                    else\n                    {\n                      swProcessPool_spawn(exit_worker);\n                      goto kill_worker;\n                    }\n                }\n\n                if(serv->user_worker_map != NULL)\n                {\n                    exit_worker = swHashMap_find_int(serv->user_worker_map, pid);\n                    if (exit_worker != NULL)\n                    {\n                        swManager_create_user_worker(serv, exit_worker);\n                        goto kill_worker;\n                    }\n                }\n            }\n        }\n        //reload worker\n        kill_worker:\n        if (ManagerProcess.reloading == 1)\n        {\n            //reload finish\n            if (reload_worker_i >= reload_worker_num)\n            {\n                ManagerProcess.reloading = 0;\n                reload_worker_i = 0;\n                continue;\n            }\n            ret = kill(reload_workers[reload_worker_i].pid, SIGTERM);\n            if (ret < 0)\n            {\n                swSysError(\"[Manager]kill(%d) failed.\", reload_workers[reload_worker_i].pid);\n                continue;\n            }\n            reload_worker_i++;\n        }\n    }\n\n    sw_free(reload_workers);\n\n    //kill all child process\n    for (i = 0; i < serv->worker_num; i++)\n    {\n        swTrace(\"[Manager]kill worker processor\");\n        kill(serv->workers[i].pid, SIGTERM);\n    }\n\n    if (SwooleG.task_worker_num > 0)\n    {\n        swProcessPool_shutdown(&SwooleG.task_workers);\n    }\n\n    if (serv->onManagerStop)\n    {\n        serv->onManagerStop(serv);\n    }\n    return SW_OK;\n}\n\nstatic int swFactoryProcess_worker_spawn(swFactory *factory, int worker_pti)\n{\n    int pid, ret;\n\n    pid = fork();\n    if (pid < 0)\n    {\n        swWarn(\"Fork Worker failed. Error: %s [%d]\", strerror(errno), errno);\n        return SW_ERR;\n    }\n    //worker child processor\n    else if (pid == 0)\n    {\n        ret = swWorker_loop(factory, worker_pti);\n        exit(ret);\n    }\n    //parent,add to writer\n    else\n    {\n        return pid;\n    }\n}\n\n/**\n * Close the connection\n */\nint swFactoryProcess_end(swFactory *factory, int fd)\n{\n    swServer *serv = factory->ptr;\n    swSendData _send;\n\n    bzero(&_send, sizeof(_send));\n    _send.info.fd = fd;\n    _send.info.len = 0;\n    _send.info.type = SW_EVENT_CLOSE;\n\n    swConnection *conn = swServer_connection_get(serv, _send.info.fd);\n    if (conn == NULL || conn->active == 0)\n    {\n        //swWarn(\"can not close. Connection[%d] not found.\", _send.info.fd);\n        return SW_ERR;\n    }\n    else if (conn->closing)\n    {\n        swWarn(\"The connection[%d] is closing.\", fd);\n        return SW_ERR;\n    }\n    else if (conn->closed)\n    {\n        return SW_ERR;\n    }\n    else\n    {\n        if (serv->onClose != NULL)\n        {\n            serv->onClose(serv, fd, conn->from_id);\n        }\n        conn->closed = 1;\n        return swFactoryProcess_finish(factory, &_send);\n    }\n}\n\n/**\n * worker: send to client\n */\nint swFactoryProcess_finish(swFactory *factory, swSendData *resp)\n{\n    int ret, sendn;\n    swServer *serv = factory->ptr;\n    int fd = resp->info.fd;\n\n    //unix dgram\n    if (resp->info.type == SW_EVENT_UNIX_DGRAM)\n    {\n        socklen_t len;\n        struct sockaddr_un addr_un;\n        int from_sock = resp->info.from_fd;\n\n        addr_un.sun_family = AF_UNIX;\n        memcpy(addr_un.sun_path, resp->sun_path, resp->sun_path_len);\n        len = sizeof(addr_un);\n        ret = swSocket_sendto_blocking(from_sock, resp->data, resp->info.len, 0, (struct sockaddr *) &addr_un, len);\n        goto finish;\n    }\n    //UDP pacakge\n    else if (resp->info.type == SW_EVENT_UDP || resp->info.type == SW_EVENT_UDP6)\n    {\n        return swServer_udp_send(serv, resp);\n    }\n\n    //for message queue\n    swEventData_overflow sdata;\n    sdata.pti = (SwooleWG.id % serv->writer_num) + 1;\n\n    swConnection *conn = swServer_connection_get(serv, fd);\n    if (conn == NULL || conn->active == 0)\n    {\n        swWarn(\"send failed, because connection[%d] has been closed.\", fd);\n        return SW_ERR;\n    }\n\n    sdata._send.info.fd = fd;\n    sdata._send.info.type = resp->info.type;\n    swWorker *worker = swServer_get_worker(serv, SwooleWG.id);\n\n\t/**\n     * Big response, use shared memory\n     */\n    if (resp->length > 0)\n    {\n        swPackage_response response;\n\n        worker->lock.lock(&worker->lock);\n\n        response.length = resp->length;\n        response.worker_id = SwooleWG.id;\n\n        //swWarn(\"BigPackage, length=%d|worker_id=%d\", response.length, response.worker_id);\n\n        sdata._send.info.from_fd = SW_RESPONSE_BIG;\n        sdata._send.info.len = sizeof(response);\n\n        memcpy(sdata._send.data, &response, sizeof(response));\n        memcpy(worker->send_shm, resp->data, resp->length);\n    }\n    else\n    {\n        //copy data\n        memcpy(sdata._send.data, resp->data, resp->info.len);\n\n        sdata._send.info.len = resp->info.len;\n        sdata._send.info.from_fd = SW_RESPONSE_SMALL;\n    }\n\n#if SW_REACTOR_SCHEDULE == 2\n    sdata._send.info.from_id = fd % serv->reactor_num;\n#else\n    sdata._send.info.from_id = conn->from_id;\n#endif\n\n    sendn = sdata._send.info.len + sizeof(resp->info);\n    //swWarn(\"send: sendn=%d|type=%d|content=%s\", sendn, resp->info.type, resp->data);\n    swTrace(\"[Worker]input_queue[%ld]->in| fd=%d\", sdata.pti, fd);\n\n    ret = swWorker_send2reactor(&sdata, sendn, fd);\n\n    finish:\n    if (ret < 0)\n    {\n        swWarn(\"sendto to reactor failed. Error: %s [%d]\", strerror(errno), errno);\n    }\n    return ret;\n}\n\nstatic __thread struct\n{\n    long target_worker_id;\n    swDataHead _send;\n} sw_notify_data;\n\n/**\n * \u4e3b\u8fdb\u7a0b\u901a\u77e5worker\u8fdb\u7a0b\n */\nint swFactoryProcess_notify(swFactory *factory, swDataHead *ev)\n{\n    memcpy(&sw_notify_data._send, ev, sizeof(swDataHead));\n    sw_notify_data._send.len = 0;\n    sw_notify_data.target_worker_id = -1;\n    return factory->dispatch(factory, (swDispatchData *) &sw_notify_data);\n}\n\n/**\n * [ReactorThread] dispatch request to worker\n */\nint swFactoryProcess_dispatch(swFactory *factory, swDispatchData *task)\n{\n    uint32_t schedule_key;\n    uint32_t send_len = sizeof(task->data.info) + task->data.info.len;\n    uint16_t target_worker_id;\n    swServer *serv = SwooleG.serv;\n\n    if (task->target_worker_id < 0)\n    {\n        //udp use remote port\n        if (task->data.info.type == SW_EVENT_UDP || task->data.info.type == SW_EVENT_UDP6\n                || task->data.info.type == SW_EVENT_UNIX_DGRAM)\n        {\n            if (serv->dispatch_mode == SW_DISPATCH_IPMOD)\n            {\n                schedule_key = task->data.info.fd;\n            }\n            else\n            {\n                schedule_key = task->data.info.from_id;\n            }\n        }\n        else\n        {\n            schedule_key = task->data.info.fd;\n        }\n\n#ifndef SW_USE_RINGBUFFER\n        if (SwooleTG.factory_lock_target)\n        {\n            if (SwooleTG.factory_target_worker < 0)\n            {\n                target_worker_id = swServer_worker_schedule(serv, schedule_key);\n                SwooleTG.factory_target_worker = target_worker_id;\n            }\n            else\n            {\n                target_worker_id = SwooleTG.factory_target_worker;\n            }\n        }\n        else\n#endif\n        {\n            target_worker_id = swServer_worker_schedule(serv, schedule_key);\n        }\n    }\n    else\n    {\n        target_worker_id = task->target_worker_id;\n    }\n\n    if (SwooleTG.type == SW_THREAD_REACTOR)\n    {\n        return swReactorThread_send2worker((void *) &(task->data), send_len, target_worker_id);\n    }\n    else\n    {\n        return swServer_send2worker_blocking(serv, (void *) &(task->data), send_len, target_worker_id);\n    }\n}\n\n/**\n * for message queue\n */\nstatic int swFactoryProcess_writer_start(swFactory *factory)\n{\n    swServer *serv = SwooleG.serv;\n    swThreadParam *param;\n    int i;\n    pthread_t pidt;\n\n    for (i = 0; i < serv->writer_num; i++)\n    {\n        param = sw_malloc(sizeof(swPipe));\n        if (param == NULL)\n        {\n            swSysError(\"malloc failed.\");\n            return SW_ERR;\n        }\n        param->object = factory;\n        param->pti = i;\n        if (pthread_create(&pidt, NULL, (swThreadStartFunc) swFactoryProcess_writer_loop_queue, (void *) param) < 0)\n        {\n            swSysError(\"pthread_create() failed.\");\n            return SW_ERR;\n        }\n        pthread_detach(pidt);\n        serv->writer_threads[i].ptid = pidt;\n        SW_START_SLEEP;\n    }\n    return SW_OK;\n}\n\n/**\n * Use message queue ipc\n */\nint swFactoryProcess_writer_loop_queue(swThreadParam *param)\n{\n    swEventData *resp;\n    swServer *serv = SwooleG.serv;\n    swConnection *conn;\n\n    int pti = param->pti;\n    swQueue_data sdata;\n    //\u5fc5\u987b\u52a01,msg_type\u5fc5\u987b\u4e0d\u80fd\u4e3a0\n    sdata.mtype = pti + 1;\n\n    swSignal_none();\n    while (SwooleG.running > 0)\n    {\n        swTrace(\"[Writer]wt_queue[%ld]->out wait\", sdata.mtype);\n        if (serv->write_queue.out(&serv->write_queue, &sdata, sizeof(sdata.mdata)) < 0)\n        {\n            swSysError(\"[writer#%d]wt_queue->out() failed.\", pti);\n        }\n        else\n        {\n            int ret;\n            resp = (swEventData *) sdata.mdata;\n            conn = swServer_connection_get(serv, resp->info.fd);\n            if (!conn)\n            {\n                swWarn(\"Connection[%d] not found.\", resp->info.fd);\n                continue;\n            }\n            swReactor *reactor = &serv->reactor_threads[conn->from_id].reactor;\n            //close connection\n            //TODO: thread safe, should close in reactor thread.\n            if (resp->info.type == SW_EVENT_CLOSE)\n            {\n                close_fd:\n                reactor->close(reactor, resp->info.fd);\n                continue;\n            }\n            //sendfile\n            else if (resp->info.type == SW_EVENT_SENDFILE)\n            {\n                ret = swSocket_sendfile_sync(resp->info.fd, resp->data, SW_WRITER_TIMEOUT);\n            }\n            //send data\n            else\n            {\n                ret = swConnection_send_blocking(resp->info.fd, resp->data, resp->info.len, 1000 * SW_WRITER_TIMEOUT);\n            }\n\n            if (ret < 0)\n            {\n                switch (swConnection_error(errno))\n                {\n                case SW_ERROR:\n                    swSysError(\"send to client[%d] failed.\", resp->info.fd);\n                    break;\n                case SW_CLOSE:\n                    goto close_fd;\n                default:\n                    break;\n                }\n            }\n        }\n    }\n    pthread_exit((void *) param);\n    return SW_OK;\n}\n",
        "base_contents": "/*\n  +----------------------------------------------------------------------+\n  | Swoole                                                               |\n  +----------------------------------------------------------------------+\n  | This source file is subject to version 2.0 of the Apache license,    |\n  | that is bundled with this package in the file LICENSE, and is        |\n  | available through the world-wide-web at the following url:           |\n  | http://www.apache.org/licenses/LICENSE-2.0.html                      |\n  | If you did not receive a copy of the Apache2.0 license and are unable|\n  | to obtain it through the world-wide-web, please send a note to       |\n  | license@php.net so we can mail you a copy immediately.               |\n  +----------------------------------------------------------------------+\n  | Author: Tianfeng Han  <mikan.tenny@gmail.com>                        |\n  +----------------------------------------------------------------------+\n*/\n\n#include \"swoole.h\"\n#include \"Server.h\"\n#include <signal.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n\ntypedef struct\n{\n    uint8_t reloading;\n    uint8_t reload_event_worker;\n    uint8_t reload_task_worker;\n\n} swManagerProcess;\n\nstatic int swFactoryProcess_manager_loop(swFactory *factory);\nstatic int swFactoryProcess_manager_start(swFactory *factory);\n\nstatic int swFactoryProcess_worker_spawn(swFactory *factory, int worker_pti);\n\nstatic int swFactoryProcess_writer_start(swFactory *factory);\nstatic int swFactoryProcess_writer_loop_queue(swThreadParam *param);\n\nstatic int swFactoryProcess_notify(swFactory *factory, swDataHead *event);\nstatic int swFactoryProcess_dispatch(swFactory *factory, swDispatchData *buf);\nstatic int swFactoryProcess_finish(swFactory *factory, swSendData *data);\n\nstatic void swManager_signal_handle(int sig);\nstatic pid_t swManager_create_user_worker(swServer *serv, swWorker* worker);\n\nstatic swManagerProcess ManagerProcess;\n\nint swFactoryProcess_create(swFactory *factory, int writer_num, int worker_num)\n{\n    swFactoryProcess *object;\n    swServer *serv = SwooleG.serv;\n    object = SwooleG.memory_pool->alloc(SwooleG.memory_pool, sizeof(swFactoryProcess));\n    if (object == NULL)\n    {\n        swWarn(\"[Master] malloc[object] failed\");\n        return SW_ERR;\n    }\n    serv->writer_threads = SwooleG.memory_pool->alloc(SwooleG.memory_pool, serv->reactor_num * sizeof(swWorkerThread));\n    if (serv->writer_threads == NULL)\n    {\n        swWarn(\"[Master] malloc[object->writers] failed\");\n        return SW_ERR;\n    }\n    object->writer_pti = 0;\n\n    factory->object = object;\n    factory->dispatch = swFactoryProcess_dispatch;\n    factory->finish = swFactoryProcess_finish;\n    factory->start = swFactoryProcess_start;\n    factory->notify = swFactoryProcess_notify;\n    factory->shutdown = swFactoryProcess_shutdown;\n    factory->end = swFactoryProcess_end;\n    factory->onTask = NULL;\n    factory->onFinish = NULL;\n\n    return SW_OK;\n}\n\nint swFactoryProcess_shutdown(swFactory *factory)\n{\n    swServer *serv = SwooleG.serv;\n    int status;\n\n    if (kill(SwooleGS->manager_pid, SIGTERM) < 0)\n    {\n        swSysError(\"kill(%d) failed.\", SwooleGS->manager_pid);\n    }\n\n    if (swWaitpid(SwooleGS->manager_pid, &status, 0) < 0)\n    {\n        swSysError(\"waitpid(%d) failed.\", SwooleGS->manager_pid);\n    }\n\n    if (serv->ipc_mode == SW_IPC_MSGQUEUE)\n    {\n        swQueueMsg_set_destory(&serv->read_queue, 1);\n        serv->read_queue.free(&serv->read_queue);\n\n        swQueueMsg_set_destory(&serv->read_queue, 1);\n        serv->write_queue.free(&serv->write_queue);\n    }\n\n    //close pipes\n    return SW_OK;\n}\n\nint swFactoryProcess_start(swFactory *factory)\n{\n    if (swFactory_check_callback(factory) < 0)\n    {\n        swWarn(\"swFactory_check_callback failed\");\n        return SW_ERR;\n    }\n\n    int i;\n    swServer *serv = factory->ptr;\n    swWorker *worker;\n\n    for (i = 0; i < serv->worker_num; i++)\n    {\n        worker = swServer_get_worker(serv, i);\n        if (swWorker_create(worker) < 0)\n        {\n            return SW_ERR;\n        }\n    }\n\n    serv->reactor_pipe_num = serv->worker_num / serv->reactor_num;\n\n    //\u5fc5\u987b\u5148\u542f\u52a8manager\u8fdb\u7a0b\u7ec4\uff0c\u5426\u5219\u4f1a\u5e26\u7ebf\u7a0bfork\n    if (swFactoryProcess_manager_start(factory) < 0)\n    {\n        swWarn(\"swFactoryProcess_manager_start failed.\");\n        return SW_ERR;\n    }\n\n    if (serv->ipc_mode == SW_IPC_MSGQUEUE)\n    {\n        swQueueMsg_set_blocking(&serv->read_queue, 1);\n        //tcp & message queue require writer pthread\n        if (serv->have_tcp_sock == 1)\n        {\n            int ret = swFactoryProcess_writer_start(factory);\n            if (ret < 0)\n            {\n                return SW_ERR;\n            }\n        }\n    }\n    //\u4e3b\u8fdb\u7a0b\u9700\u8981\u8bbe\u7f6e\u4e3a\u76f4\u5199\u6a21\u5f0f\n    factory->finish = swFactory_finish;\n    return SW_OK;\n}\n\n\n//create worker child proccess\nstatic int swFactoryProcess_manager_start(swFactory *factory)\n{\n    swFactoryProcess *object = factory->object;\n    int i, ret;\n    pid_t pid;\n    int reactor_pti;\n    swServer *serv = factory->ptr;\n\n    if (serv->ipc_mode == SW_IPC_MSGQUEUE)\n    {\n        //\u8bfb\u6570\u636e\u961f\u5217\n        if (swQueueMsg_create(&serv->read_queue, 1, serv->message_queue_key, 1) < 0)\n        {\n            swError(\"[Master] swPipeMsg_create[In] fail. Error: %s [%d]\", strerror(errno), errno);\n            return SW_ERR;\n        }\n        //\u4e3aTCP\u521b\u5efa\u5199\u961f\u5217\n        if (serv->have_tcp_sock == 1)\n        {\n            //\u5199\u6570\u636e\u961f\u5217\n            if (swQueueMsg_create(&serv->write_queue, 1, serv->message_queue_key + 1, 1) < 0)\n            {\n                swError(\"[Master] swPipeMsg_create[out] fail. Error: %s [%d]\", strerror(errno), errno);\n                return SW_ERR;\n            }\n        }\n    }\n    else\n    {\n        object->pipes = sw_calloc(serv->worker_num, sizeof(swPipe));\n        if (object->pipes == NULL)\n        {\n            swError(\"malloc[worker_pipes] failed. Error: %s [%d]\", strerror(errno), errno);\n            return SW_ERR;\n        }\n        //worker\u8fdb\u7a0b\u7684pipes\n        for (i = 0; i < serv->worker_num; i++)\n        {\n            if (swPipeUnsock_create(&object->pipes[i], 1, SOCK_DGRAM) < 0)\n            {\n                return SW_ERR;\n            }\n            if (serv->ipc_mode == SW_IPC_UNSOCK)\n            {\n                serv->workers[i].pipe_master = object->pipes[i].getFd(&object->pipes[i], SW_PIPE_MASTER);\n                serv->workers[i].pipe_worker = object->pipes[i].getFd(&object->pipes[i], SW_PIPE_WORKER);\n                serv->workers[i].pipe_object = &object->pipes[i];\n                swServer_pipe_set(serv, serv->workers[i].pipe_object);\n            }\n        }\n    }\n\n    if (SwooleG.task_worker_num > 0)\n    {\n        key_t key = 0;\n        if (SwooleG.task_ipc_mode == SW_IPC_MSGQUEUE)\n        {\n            key = serv->message_queue_key + 2;\n        }\n\n        int task_num = SwooleG.task_worker_max > 0 ? SwooleG.task_worker_max : SwooleG.task_worker_num;\n        SwooleGS->task_num = SwooleG.task_worker_num;  //\u542f\u52a8min\u4e2a.\u6b64\u65f6\u7684pool->worker_num\u76f8\u5f53\u4e8emax\n\n        if (swProcessPool_create(&SwooleG.task_workers, task_num, serv->task_max_request, key, 1) < 0)\n        {\n            swWarn(\"[Master] create task_workers failed.\");\n            return SW_ERR;\n        }\n        \n        swProcessPool *pool = &SwooleG.task_workers;\n        swTaskWorker_init(pool);\n\n        int worker_id;\n        swWorker *worker;\n        for (i = 0; i < task_num; i++)\n        {\n            worker_id = serv->worker_num + i;\n            worker = swServer_get_worker(serv, worker_id);\n            if (swWorker_create(worker) < 0)\n            {\n                return SW_ERR;\n            }\n            if (SwooleG.task_ipc_mode == SW_IPC_UNSOCK)\n            {\n                swServer_pipe_set(serv, worker->pipe_object);\n            }\n            pool->workers[i].id = pool->start_id + i;\n            pool->workers[i].pool = pool;\n            pool->workers[i].type = pool->type;\n        }\n    }\n\n    pid = fork();\n    switch (pid)\n    {\n    //\u521b\u5efamanager\u8fdb\u7a0b\n    case 0:\n        //wait master process\n        SW_START_SLEEP;\n        if (SwooleGS->start == 0)\n        {\n            return SW_OK;\n        }\n        /**\n         * create worker process\n         */\n        for (i = 0; i < serv->worker_num; i++)\n        {\n            //close(worker_pipes[i].pipes[0]);\n            reactor_pti = (i % serv->writer_num);\n            serv->workers[i].reactor_id = reactor_pti;\n            pid = swFactoryProcess_worker_spawn(factory, i);\n            if (pid < 0)\n            {\n                swError(\"fork() failed.\");\n                return SW_ERR;\n            }\n            else\n            {\n                serv->workers[i].pid = pid;\n            }\n        }\n\n        /**\n         * create task worker process\n         */\n        if (SwooleG.task_worker_num > 0)\n        {\n            swProcessPool_start(&SwooleG.task_workers);\n        }\n\n        /**\n         * create user workers\n         */\n        if (serv->user_worker_list)\n        {\n            swUserWorker_node *user_worker;\n            LL_FOREACH(serv->user_worker_list, user_worker)\n            {\n                swManager_create_user_worker(serv, user_worker->worker);\n            }\n        }\n\n        //\u6807\u8bc6\u4e3a\u7ba1\u7406\u8fdb\u7a0b\n        SwooleG.process_type = SW_PROCESS_MANAGER;\n        ret = swFactoryProcess_manager_loop(factory);\n        exit(ret);\n        break;\n        //\u4e3b\u8fdb\u7a0b\n    default:\n        SwooleGS->manager_pid = pid;\n        break;\n    case -1:\n        swError(\"fork() failed.\");\n        return SW_ERR;\n    }\n    return SW_OK;\n}\n\nstatic pid_t swManager_create_user_worker(swServer *serv, swWorker* worker)\n{\n    pid_t pid = fork();\n\n    if (pid < 0)\n    {\n        swWarn(\"Fork Worker failed. Error: %s [%d]\", strerror(errno), errno);\n        return SW_ERR;\n    }\n    //child\n    else if (pid == 0)\n    {\n        serv->onUserWorkerStart(serv, worker);\n        exit(0);\n    }\n    //parent\n    else\n    {\n        if (worker->pid)\n        {\n            swHashMap_del_int(serv->user_worker_map, worker->pid);\n        }\n        worker->pid = pid;\n        swHashMap_add_int(serv->user_worker_map, pid, worker, NULL);\n        return pid;\n    }\n}\n\nstatic void swManager_signal_handle(int sig)\n{\n    swProcessPool *pool = &(SwooleG.task_workers);\n    swWorker *worker = NULL;\n    int i = 0,ret,over_load_num = 0,zero_load_num = 0;\n        \n    switch (sig)\n    {\n    case SIGTERM:\n        SwooleG.running = 0;\n        break;\n    case SIGALRM:\n        worker = &(pool->workers[SwooleGS->task_num]);\n        if(worker->del == 1&&worker->tasking_num == 0){\n            ret = kill(worker->pid, SIGTERM);\n            if (ret < 0)\n            {\n                    swWarn(\"[Manager]kill fail.pid=%d. Error: %s [%d]\", worker->pid, strerror(errno), errno);\n            }\n             alarm(1);\n             break;\n        }\n        for(;i<SwooleGS->task_num;i++)\n        {\n            worker = &(pool->workers[i]);\n            if(worker->tasking_num >=1)//todo support config\n            {\n                over_load_num++;\n            }\n            else// == 0\n            {\n               zero_load_num++;\n            }\n        }\n        \n        if(over_load_num>SwooleGS->task_num/2&&SwooleGS->task_num<SwooleG.task_worker_max)\n        {\n           if(swProcessPool_spawn(&(pool->workers[SwooleGS->task_num])) < 0)\n           {\n                swWarn(\"swProcessPool_spawn fail\");\n           }\n           else\n           {\n                SwooleGS->task_num++;\n           }\n        }\n        else if(zero_load_num>=SwooleG.task_worker_num&&SwooleGS->task_num>SwooleG.task_worker_num)\n        { \n                  SwooleG.task_recycle_num++;\n                  if(SwooleG.task_recycle_num>3)\n                  {\n                    SwooleGS->task_num--;\n                    worker = &(pool->workers[SwooleGS->task_num]);\n                    worker->del = 1;\n                    SwooleG.task_recycle_num = 0;\n                  }\n        }\n        alarm(1);\n        break;\n    /**\n     * reload all workers\n     */\n    case SIGUSR1:\n        if (ManagerProcess.reloading == 0)\n        {\n            ManagerProcess.reloading = 1;\n            ManagerProcess.reload_event_worker = 1;\n        }\n        break;\n    /**\n     * only reload task workers\n     */\n    case SIGUSR2:\n        if (ManagerProcess.reloading == 0)\n        {\n            ManagerProcess.reloading = 1;\n            ManagerProcess.reload_task_worker = 1;\n        }\n        break;\n    default:\n        break;\n    }\n}\n\nstatic int swFactoryProcess_manager_loop(swFactory *factory)\n{\n    int pid, new_pid;\n    int i;\n    int reload_worker_i = 0;\n    int reload_worker_num;\n    int ret;\n    int worker_exit_code;\n\n    SwooleG.use_signalfd = 0;\n    SwooleG.use_timerfd = 0;\n\n    memset(&ManagerProcess, 0, sizeof(ManagerProcess));\n\n    swServer *serv = factory->ptr;\n    swWorker *reload_workers;\n\n    if (serv->onManagerStart)\n    {\n        serv->onManagerStart(serv);\n    }\n\n    reload_worker_num = serv->worker_num + SwooleG.task_worker_num;\n    reload_workers = sw_calloc(reload_worker_num, sizeof(swWorker));\n    if (reload_workers == NULL)\n    {\n        swError(\"malloc[reload_workers] failed\");\n        return SW_ERR;\n    }\n\n    //for reload\n    swSignal_add(SIGHUP, NULL);\n    swSignal_add(SIGTERM, swManager_signal_handle);\n    swSignal_add(SIGUSR1, swManager_signal_handle);\n    swSignal_add(SIGUSR2, swManager_signal_handle);\n    //swSignal_add(SIGINT, swManager_signal_handle);\n    \n     //for add/recycle task process\n    if(SwooleG.task_worker_max>0)\n    {\n             swSignal_add(SIGALRM, swManager_signal_handle);\n             alarm(1);\n    }\n\n    while (SwooleG.running > 0)\n    {\n        pid = wait(&worker_exit_code);\n\n        if (pid < 0)\n        {\n            if (ManagerProcess.reloading == 0)\n            {\n                swTrace(\"wait() failed. Error: %s [%d]\", strerror(errno), errno);\n            }\n            else if (ManagerProcess.reload_event_worker == 1)\n            {\n                memcpy(reload_workers, serv->workers, sizeof(swWorker) * serv->worker_num);\n                reload_worker_num = serv->worker_num;\n                if (SwooleG.task_worker_num > 0)\n                {\n                    memcpy(reload_workers + serv->worker_num, SwooleG.task_workers.workers,\n                            sizeof(swWorker) * SwooleG.task_worker_num);\n                    reload_worker_num += SwooleG.task_worker_num;\n                }\n                reload_worker_i = 0;\n                ManagerProcess.reload_event_worker = 0;\n                goto kill_worker;\n            }\n            else if (ManagerProcess.reload_task_worker == 1)\n            {\n                if (SwooleG.task_worker_num == 0)\n                {\n                    swWarn(\"Cannot reload workers, because server no have task workers.\");\n                    continue;\n                }\n                memcpy(reload_workers, SwooleG.task_workers.workers, sizeof(swWorker) * SwooleG.task_worker_num);\n                reload_worker_num = SwooleG.task_worker_num;\n                reload_worker_i = 0;\n                ManagerProcess.reload_task_worker = 0;\n                goto kill_worker;\n            }\n        }\n        if (SwooleG.running == 1)\n        {\n            for (i = 0; i < serv->worker_num; i++)\n            {\n                //compare PID\n                if (pid != serv->workers[i].pid)\n                {\n                    continue;\n                }\n                else\n                {\n                    if (serv->onWorkerError != NULL && WEXITSTATUS(worker_exit_code) > 0)\n                    {\n                        serv->onWorkerError(serv, i, pid, WEXITSTATUS(worker_exit_code));\n                    }\n                    pid = 0;\n                    while (1)\n                    {\n                        new_pid = swFactoryProcess_worker_spawn(factory, i);\n                        if (new_pid < 0)\n                        {\n                            usleep(100000);\n                            continue;\n                        }\n                        else\n                        {\n                            serv->workers[i].pid = new_pid;\n                            break;\n                        }\n                    }\n                }\n            }\n\n            //task worker\n            if (pid > 0)\n            {\n                swWorker *exit_worker = swHashMap_find_int(SwooleG.task_workers.map, pid);\n                if (exit_worker != NULL)\n                {\n                    if(exit_worker->del == 1)//\u4e3b\u52a8\u56de\u6536\u4e0d\u91cd\u542f\n                    {\n                        exit_worker->del = 0;\n                    }\n                    else\n                    {\n                      swProcessPool_spawn(exit_worker);\n                      goto kill_worker;\n                    }\n                }\n\n                if(serv->user_worker_map != NULL)\n                {\n                    exit_worker = swHashMap_find_int(serv->user_worker_map, pid);\n                    if (exit_worker != NULL)\n                    {\n                        swManager_create_user_worker(serv, exit_worker);\n                        goto kill_worker;\n                    }\n                }\n            }\n        }\n        //reload worker\n        kill_worker:\n        if (ManagerProcess.reloading == 1)\n        {\n            //reload finish\n            if (reload_worker_i >= reload_worker_num)\n            {\n                ManagerProcess.reloading = 0;\n                reload_worker_i = 0;\n                continue;\n            }\n            ret = kill(reload_workers[reload_worker_i].pid, SIGTERM);\n            if (ret < 0)\n            {\n                swSysError(\"[Manager]kill(%d) failed.\", reload_workers[reload_worker_i].pid);\n                continue;\n            }\n            reload_worker_i++;\n        }\n    }\n\n    sw_free(reload_workers);\n\n    //kill all child process\n    for (i = 0; i < serv->worker_num; i++)\n    {\n        swTrace(\"[Manager]kill worker processor\");\n        kill(serv->workers[i].pid, SIGTERM);\n    }\n\n    if (SwooleG.task_worker_num > 0)\n    {\n        swProcessPool_shutdown(&SwooleG.task_workers);\n    }\n\n    if (serv->onManagerStop)\n    {\n        serv->onManagerStop(serv);\n    }\n    return SW_OK;\n}\n\nstatic int swFactoryProcess_worker_spawn(swFactory *factory, int worker_pti)\n{\n    int pid, ret;\n\n    pid = fork();\n    if (pid < 0)\n    {\n        swWarn(\"Fork Worker failed. Error: %s [%d]\", strerror(errno), errno);\n        return SW_ERR;\n    }\n    //worker child processor\n    else if (pid == 0)\n    {\n        ret = swWorker_loop(factory, worker_pti);\n        exit(ret);\n    }\n    //parent,add to writer\n    else\n    {\n        return pid;\n    }\n}\n\n/**\n * Close the connection\n */\nint swFactoryProcess_end(swFactory *factory, int fd)\n{\n    swServer *serv = factory->ptr;\n    swSendData _send;\n\n    bzero(&_send, sizeof(_send));\n    _send.info.fd = fd;\n    _send.info.len = 0;\n    _send.info.type = SW_EVENT_CLOSE;\n\n    swConnection *conn = swServer_connection_get(serv, _send.info.fd);\n    if (conn == NULL || conn->active == 0)\n    {\n        //swWarn(\"can not close. Connection[%d] not found.\", _send.info.fd);\n        return SW_ERR;\n    }\n    else if (conn->closing)\n    {\n        swWarn(\"The connection[%d] is closing.\", fd);\n        return SW_ERR;\n    }\n    else if (conn->closed)\n    {\n        return SW_ERR;\n    }\n    else\n    {\n        if (serv->onClose != NULL)\n        {\n            serv->onClose(serv, fd, conn->from_id);\n        }\n        conn->closed = 1;\n        return swFactoryProcess_finish(factory, &_send);\n    }\n}\n\n/**\n * worker: send to client\n */\nint swFactoryProcess_finish(swFactory *factory, swSendData *resp)\n{\n    int ret, sendn;\n    swServer *serv = factory->ptr;\n    int fd = resp->info.fd;\n\n    //unix dgram\n    if (resp->info.type == SW_EVENT_UNIX_DGRAM)\n    {\n        socklen_t len;\n        struct sockaddr_un addr_un;\n        int from_sock = resp->info.from_fd;\n\n        addr_un.sun_family = AF_UNIX;\n        memcpy(addr_un.sun_path, resp->sun_path, resp->sun_path_len);\n        len = sizeof(addr_un);\n        ret = swSendto(from_sock, resp->data, resp->info.len, 0, (struct sockaddr *) &addr_un, len);\n        goto finish;\n    }\n    //UDP pacakge\n    else if (resp->info.type == SW_EVENT_UDP || resp->info.type == SW_EVENT_UDP6)\n    {\n        return swServer_udp_send(serv, resp);\n    }\n\n    //for message queue\n    swEventData_overflow sdata;\n    sdata.pti = (SwooleWG.id % serv->writer_num) + 1;\n\n    swConnection *conn = swServer_connection_get(serv, fd);\n    if (conn == NULL || conn->active == 0)\n    {\n        swWarn(\"send failed, because connection[%d] has been closed.\", fd);\n        return SW_ERR;\n    }\n\n    sdata._send.info.fd = fd;\n    sdata._send.info.type = resp->info.type;\n    swWorker *worker = swServer_get_worker(serv, SwooleWG.id);\n\n\t/**\n     * Big response, use shared memory\n     */\n    if (resp->length > 0)\n    {\n        swPackage_response response;\n\n        worker->lock.lock(&worker->lock);\n\n        response.length = resp->length;\n        response.worker_id = SwooleWG.id;\n\n        //swWarn(\"BigPackage, length=%d|worker_id=%d\", response.length, response.worker_id);\n\n        sdata._send.info.from_fd = SW_RESPONSE_BIG;\n        sdata._send.info.len = sizeof(response);\n\n        memcpy(sdata._send.data, &response, sizeof(response));\n        memcpy(worker->send_shm, resp->data, resp->length);\n    }\n    else\n    {\n        //copy data\n        memcpy(sdata._send.data, resp->data, resp->info.len);\n\n        sdata._send.info.len = resp->info.len;\n        sdata._send.info.from_fd = SW_RESPONSE_SMALL;\n    }\n\n#if SW_REACTOR_SCHEDULE == 2\n    sdata._send.info.from_id = fd % serv->reactor_num;\n#else\n    sdata._send.info.from_id = conn->from_id;\n#endif\n\n    sendn = sdata._send.info.len + sizeof(resp->info);\n    //swWarn(\"send: sendn=%d|type=%d|content=%s\", sendn, resp->info.type, resp->data);\n    swTrace(\"[Worker]input_queue[%ld]->in| fd=%d\", sdata.pti, fd);\n\n    ret = swWorker_send2reactor(&sdata, sendn, fd);\n\n    finish:\n    if (ret < 0)\n    {\n        swWarn(\"sendto to reactor failed. Error: %s [%d]\", strerror(errno), errno);\n    }\n    return ret;\n}\n\nstatic __thread struct\n{\n    long target_worker_id;\n    swDataHead _send;\n} sw_notify_data;\n\n/**\n * \u4e3b\u8fdb\u7a0b\u901a\u77e5worker\u8fdb\u7a0b\n */\nint swFactoryProcess_notify(swFactory *factory, swDataHead *ev)\n{\n    memcpy(&sw_notify_data._send, ev, sizeof(swDataHead));\n    sw_notify_data._send.len = 0;\n    sw_notify_data.target_worker_id = -1;\n    return factory->dispatch(factory, (swDispatchData *) &sw_notify_data);\n}\n\n/**\n * [ReactorThread] dispatch request to worker\n */\nint swFactoryProcess_dispatch(swFactory *factory, swDispatchData *task)\n{\n    uint32_t schedule_key;\n    uint32_t send_len = sizeof(task->data.info) + task->data.info.len;\n    uint16_t target_worker_id;\n    swServer *serv = SwooleG.serv;\n\n    if (task->target_worker_id < 0)\n    {\n        //udp use remote port\n        if (task->data.info.type == SW_EVENT_UDP || task->data.info.type == SW_EVENT_UDP6\n                || task->data.info.type == SW_EVENT_UNIX_DGRAM)\n        {\n            if (serv->dispatch_mode == SW_DISPATCH_IPMOD)\n            {\n                schedule_key = task->data.info.fd;\n            }\n            else\n            {\n                schedule_key = task->data.info.from_id;\n            }\n        }\n        else\n        {\n            schedule_key = task->data.info.fd;\n        }\n\n#ifndef SW_USE_RINGBUFFER\n        if (SwooleTG.factory_lock_target)\n        {\n            if (SwooleTG.factory_target_worker < 0)\n            {\n                target_worker_id = swServer_worker_schedule(serv, schedule_key);\n                SwooleTG.factory_target_worker = target_worker_id;\n            }\n            else\n            {\n                target_worker_id = SwooleTG.factory_target_worker;\n            }\n        }\n        else\n#endif\n        {\n            target_worker_id = swServer_worker_schedule(serv, schedule_key);\n        }\n    }\n    else\n    {\n        target_worker_id = task->target_worker_id;\n    }\n\n    if (SwooleTG.type == SW_THREAD_REACTOR)\n    {\n        return swReactorThread_send2worker((void *) &(task->data), send_len, target_worker_id);\n    }\n    else\n    {\n        return swServer_send2worker_blocking(serv, (void *) &(task->data), send_len, target_worker_id);\n    }\n}\n\n/**\n * for message queue\n */\nstatic int swFactoryProcess_writer_start(swFactory *factory)\n{\n    swServer *serv = SwooleG.serv;\n    swThreadParam *param;\n    int i;\n    pthread_t pidt;\n\n    for (i = 0; i < serv->writer_num; i++)\n    {\n        param = sw_malloc(sizeof(swPipe));\n        if (param == NULL)\n        {\n            swSysError(\"malloc failed.\");\n            return SW_ERR;\n        }\n        param->object = factory;\n        param->pti = i;\n        if (pthread_create(&pidt, NULL, (swThreadStartFunc) swFactoryProcess_writer_loop_queue, (void *) param) < 0)\n        {\n            swSysError(\"pthread_create() failed.\");\n            return SW_ERR;\n        }\n        pthread_detach(pidt);\n        serv->writer_threads[i].ptid = pidt;\n        SW_START_SLEEP;\n    }\n    return SW_OK;\n}\n\n/**\n * Use message queue ipc\n */\nint swFactoryProcess_writer_loop_queue(swThreadParam *param)\n{\n    swEventData *resp;\n    swServer *serv = SwooleG.serv;\n    swConnection *conn;\n\n    int pti = param->pti;\n    swQueue_data sdata;\n    //\u5fc5\u987b\u52a01,msg_type\u5fc5\u987b\u4e0d\u80fd\u4e3a0\n    sdata.mtype = pti + 1;\n\n    swSignal_none();\n    while (SwooleG.running > 0)\n    {\n        swTrace(\"[Writer]wt_queue[%ld]->out wait\", sdata.mtype);\n        if (serv->write_queue.out(&serv->write_queue, &sdata, sizeof(sdata.mdata)) < 0)\n        {\n            swSysError(\"[writer#%d]wt_queue->out() failed.\", pti);\n        }\n        else\n        {\n            int ret;\n            resp = (swEventData *) sdata.mdata;\n            conn = swServer_connection_get(serv, resp->info.fd);\n            if (!conn)\n            {\n                swWarn(\"Connection[%d] not found.\", resp->info.fd);\n                continue;\n            }\n            swReactor *reactor = &serv->reactor_threads[conn->from_id].reactor;\n            //close connection\n            //TODO: thread safe, should close in reactor thread.\n            if (resp->info.type == SW_EVENT_CLOSE)\n            {\n                close_fd:\n                reactor->close(reactor, resp->info.fd);\n                continue;\n            }\n            //sendfile\n            else if (resp->info.type == SW_EVENT_SENDFILE)\n            {\n                ret = swSocket_sendfile_sync(resp->info.fd, resp->data, SW_WRITER_TIMEOUT);\n            }\n            //send data\n            else\n            {\n                ret = swConnection_send_blocking(resp->info.fd, resp->data, resp->info.len, 1000 * SW_WRITER_TIMEOUT);\n            }\n\n            if (ret < 0)\n            {\n                switch (swConnection_error(errno))\n                {\n                case SW_ERROR:\n                    swSysError(\"send to client[%d] failed.\", resp->info.fd);\n                    break;\n                case SW_CLOSE:\n                    goto close_fd;\n                default:\n                    break;\n                }\n            }\n        }\n    }\n    pthread_exit((void *) param);\n    return SW_OK;\n}\n",
        "res_region": "/*\n  +----------------------------------------------------------------------+\n  | Swoole                                                               |\n  +----------------------------------------------------------------------+\n  | This source file is subject to version 2.0 of the Apache license,    |\n  | that is bundled with this package in the file LICENSE, and is        |\n  | available through the world-wide-web at the following url:           |\n  | http://www.apache.org/licenses/LICENSE-2.0.html                      |\n  | If you did not receive a copy of the Apache2.0 license and are unable|\n  | to obtain it through the world-wide-web, please send a note to       |\n  | license@php.net so we can mail you a copy immediately.               |\n  +----------------------------------------------------------------------+\n  | Author: Tianfeng Han  <mikan.tenny@gmail.com>                        |\n  +----------------------------------------------------------------------+\n*/\n\n#include \"swoole.h\"\n#include \"Server.h\"\n#include <signal.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n\ntypedef struct\n{\n    uint8_t reloading;\n    uint8_t reload_event_worker;\n    uint8_t reload_task_worker;\n\n} swManagerProcess;\n\nstatic int swFactoryProcess_manager_loop(swFactory *factory);\nstatic int swFactoryProcess_manager_start(swFactory *factory);\n\nstatic int swFactoryProcess_worker_spawn(swFactory *factory, int worker_pti);\n\nstatic int swFactoryProcess_writer_start(swFactory *factory);\nstatic int swFactoryProcess_writer_loop_queue(swThreadParam *param);\n\nstatic int swFactoryProcess_notify(swFactory *factory, swDataHead *event);\nstatic int swFactoryProcess_dispatch(swFactory *factory, swDispatchData *buf);\nstatic int swFactoryProcess_finish(swFactory *factory, swSendData *data);\n\nstatic void swManager_signal_handle(int sig);\nstatic pid_t swManager_create_user_worker(swServer *serv, swWorker* worker);\n\nstatic swManagerProcess ManagerProcess;\n\nint swFactoryProcess_create(swFactory *factory, int writer_num, int worker_num)\n{\n    swFactoryProcess *object;\n    swServer *serv = SwooleG.serv;\n    object = SwooleG.memory_pool->alloc(SwooleG.memory_pool, sizeof(swFactoryProcess));\n    if (object == NULL)\n    {\n        swWarn(\"[Master] malloc[object] failed\");\n        return SW_ERR;\n    }\n    serv->writer_threads = SwooleG.memory_pool->alloc(SwooleG.memory_pool, serv->reactor_num * sizeof(swWorkerThread));\n    if (serv->writer_threads == NULL)\n    {\n        swWarn(\"[Master] malloc[object->writers] failed\");\n        return SW_ERR;\n    }\n    object->writer_pti = 0;\n\n    factory->object = object;\n    factory->dispatch = swFactoryProcess_dispatch;\n    factory->finish = swFactoryProcess_finish;\n    factory->start = swFactoryProcess_start;\n    factory->notify = swFactoryProcess_notify;\n    factory->shutdown = swFactoryProcess_shutdown;\n    factory->end = swFactoryProcess_end;\n    factory->onTask = NULL;\n    factory->onFinish = NULL;\n\n    return SW_OK;\n}\n\nint swFactoryProcess_shutdown(swFactory *factory)\n{\n    swServer *serv = SwooleG.serv;\n    int status;\n\n    if (kill(SwooleGS->manager_pid, SIGTERM) < 0)\n    {\n        swSysError(\"kill(%d) failed.\", SwooleGS->manager_pid);\n    }\n\n    if (swWaitpid(SwooleGS->manager_pid, &status, 0) < 0)\n    {\n        swSysError(\"waitpid(%d) failed.\", SwooleGS->manager_pid);\n    }\n\n    if (serv->ipc_mode == SW_IPC_MSGQUEUE)\n    {\n        swQueueMsg_set_destory(&serv->read_queue, 1);\n        serv->read_queue.free(&serv->read_queue);\n\n        swQueueMsg_set_destory(&serv->read_queue, 1);\n        serv->write_queue.free(&serv->write_queue);\n    }\n\n    //close pipes\n    return SW_OK;\n}\n\nint swFactoryProcess_start(swFactory *factory)\n{\n    if (swFactory_check_callback(factory) < 0)\n    {\n        swWarn(\"swFactory_check_callback failed\");\n        return SW_ERR;\n    }\n\n    int i;\n    swServer *serv = factory->ptr;\n    swWorker *worker;\n\n    for (i = 0; i < serv->worker_num; i++)\n    {\n        worker = swServer_get_worker(serv, i);\n        if (swWorker_create(worker) < 0)\n        {\n            return SW_ERR;\n        }\n    }\n\n    serv->reactor_pipe_num = serv->worker_num / serv->reactor_num;\n\n    //\u5fc5\u987b\u5148\u542f\u52a8manager\u8fdb\u7a0b\u7ec4\uff0c\u5426\u5219\u4f1a\u5e26\u7ebf\u7a0bfork\n    if (swFactoryProcess_manager_start(factory) < 0)\n    {\n        swWarn(\"swFactoryProcess_manager_start failed.\");\n        return SW_ERR;\n    }\n\n    if (serv->ipc_mode == SW_IPC_MSGQUEUE)\n    {\n        swQueueMsg_set_blocking(&serv->read_queue, 1);\n        //tcp & message queue require writer pthread\n        if (serv->have_tcp_sock == 1)\n        {\n            int ret = swFactoryProcess_writer_start(factory);\n            if (ret < 0)\n            {\n                return SW_ERR;\n            }\n        }\n    }\n    //\u4e3b\u8fdb\u7a0b\u9700\u8981\u8bbe\u7f6e\u4e3a\u76f4\u5199\u6a21\u5f0f\n    factory->finish = swFactory_finish;\n    return SW_OK;\n}\n\n\n//create worker child proccess\nstatic int swFactoryProcess_manager_start(swFactory *factory)\n{\n    swFactoryProcess *object = factory->object;\n    int i, ret;\n    pid_t pid;\n    int reactor_pti;\n    swServer *serv = factory->ptr;\n\n    if (serv->ipc_mode == SW_IPC_MSGQUEUE)\n    {\n        //\u8bfb\u6570\u636e\u961f\u5217\n        if (swQueueMsg_create(&serv->read_queue, 1, serv->message_queue_key, 1) < 0)\n        {\n            swError(\"[Master] swPipeMsg_create[In] fail. Error: %s [%d]\", strerror(errno), errno);\n            return SW_ERR;\n        }\n        //\u4e3aTCP\u521b\u5efa\u5199\u961f\u5217\n        if (serv->have_tcp_sock == 1)\n        {\n            //\u5199\u6570\u636e\u961f\u5217\n            if (swQueueMsg_create(&serv->write_queue, 1, serv->message_queue_key + 1, 1) < 0)\n            {\n                swError(\"[Master] swPipeMsg_create[out] fail. Error: %s [%d]\", strerror(errno), errno);\n                return SW_ERR;\n            }\n        }\n    }\n    else\n    {\n        object->pipes = sw_calloc(serv->worker_num, sizeof(swPipe));\n        if (object->pipes == NULL)\n        {\n            swError(\"malloc[worker_pipes] failed. Error: %s [%d]\", strerror(errno), errno);\n            return SW_ERR;\n        }\n        //worker\u8fdb\u7a0b\u7684pipes\n        for (i = 0; i < serv->worker_num; i++)\n        {\n            if (swPipeUnsock_create(&object->pipes[i], 1, SOCK_DGRAM) < 0)\n            {\n                return SW_ERR;\n            }\n            if (serv->ipc_mode == SW_IPC_UNSOCK)\n            {\n                serv->workers[i].pipe_master = object->pipes[i].getFd(&object->pipes[i], SW_PIPE_MASTER);\n                serv->workers[i].pipe_worker = object->pipes[i].getFd(&object->pipes[i], SW_PIPE_WORKER);\n                serv->workers[i].pipe_object = &object->pipes[i];\n                swServer_pipe_set(serv, serv->workers[i].pipe_object);\n            }\n        }\n    }\n\n    if (SwooleG.task_worker_num > 0)\n    {\n        key_t key = 0;\n        if (SwooleG.task_ipc_mode == SW_IPC_MSGQUEUE)\n        {\n            key = serv->message_queue_key + 2;\n        }\n\n        int task_num = SwooleG.task_worker_max > 0 ? SwooleG.task_worker_max : SwooleG.task_worker_num;\n        SwooleGS->task_num = SwooleG.task_worker_num;  //\u542f\u52a8min\u4e2a.\u6b64\u65f6\u7684pool->worker_num\u76f8\u5f53\u4e8emax\n\n        if (swProcessPool_create(&SwooleG.task_workers, task_num, serv->task_max_request, key, 1) < 0)\n        {\n            swWarn(\"[Master] create task_workers failed.\");\n            return SW_ERR;\n        }\n        \n        swProcessPool *pool = &SwooleG.task_workers;\n        swTaskWorker_init(pool);\n\n        int worker_id;\n        swWorker *worker;\n        for (i = 0; i < task_num; i++)\n        {\n            worker_id = serv->worker_num + i;\n            worker = swServer_get_worker(serv, worker_id);\n            if (swWorker_create(worker) < 0)\n            {\n                return SW_ERR;\n            }\n            if (SwooleG.task_ipc_mode == SW_IPC_UNSOCK)\n            {\n                swServer_pipe_set(serv, worker->pipe_object);\n            }\n            pool->workers[i].id = pool->start_id + i;\n            pool->workers[i].pool = pool;\n            pool->workers[i].type = pool->type;\n        }\n    }\n\n    pid = fork();\n    switch (pid)\n    {\n    //\u521b\u5efamanager\u8fdb\u7a0b\n    case 0:\n        //wait master process\n        SW_START_SLEEP;\n        if (SwooleGS->start == 0)\n        {\n            return SW_OK;\n        }\n        /**\n         * create worker process\n         */\n        for (i = 0; i < serv->worker_num; i++)\n        {\n            //close(worker_pipes[i].pipes[0]);\n            reactor_pti = (i % serv->writer_num);\n            serv->workers[i].reactor_id = reactor_pti;\n            pid = swFactoryProcess_worker_spawn(factory, i);\n            if (pid < 0)\n            {\n                swError(\"fork() failed.\");\n                return SW_ERR;\n            }\n            else\n            {\n                serv->workers[i].pid = pid;\n            }\n        }\n\n        /**\n         * create task worker process\n         */\n        if (SwooleG.task_worker_num > 0)\n        {\n            swProcessPool_start(&SwooleG.task_workers);\n        }\n\n        /**\n         * create user workers\n         */\n        if (serv->user_worker_list)\n        {\n            swUserWorker_node *user_worker;\n            LL_FOREACH(serv->user_worker_list, user_worker)\n            {\n                swManager_create_user_worker(serv, user_worker->worker);\n            }\n        }\n\n        //\u6807\u8bc6\u4e3a\u7ba1\u7406\u8fdb\u7a0b\n        SwooleG.process_type = SW_PROCESS_MANAGER;\n        SwooleG.pid = getpid();\n\n        ret = swFactoryProcess_manager_loop(factory);\n        exit(ret);\n        break;\n        //\u4e3b\u8fdb\u7a0b\n    default:\n        SwooleGS->manager_pid = pid;\n        break;\n    case -1:\n        swError(\"fork() failed.\");\n        return SW_ERR;\n    }\n    return SW_OK;\n}\n\nstatic pid_t swManager_create_user_worker(swServer *serv, swWorker* worker)\n{\n    pid_t pid = fork();\n\n    if (pid < 0)\n    {\n        swWarn(\"Fork Worker failed. Error: %s [%d]\", strerror(errno), errno);\n        return SW_ERR;\n    }\n    //child\n    else if (pid == 0)\n    {\n        serv->onUserWorkerStart(serv, worker);\n        exit(0);\n    }\n    //parent\n    else\n    {\n        if (worker->pid)\n        {\n            swHashMap_del_int(serv->user_worker_map, worker->pid);\n        }\n        worker->pid = pid;\n        swHashMap_add_int(serv->user_worker_map, pid, worker, NULL);\n        return pid;\n    }\n}\n\nstatic void swManager_signal_handle(int sig)\n{\n    swProcessPool *pool = &(SwooleG.task_workers);\n    swWorker *worker = NULL;\n    int i = 0,ret,over_load_num = 0,zero_load_num = 0;\n        \n    switch (sig)\n    {\n    case SIGTERM:\n        SwooleG.running = 0;\n        break;\n    case SIGALRM:\n        worker = &(pool->workers[SwooleGS->task_num]);\n        if(worker->del == 1&&worker->tasking_num == 0){\n            ret = kill(worker->pid, SIGTERM);\n            if (ret < 0)\n            {\n                    swWarn(\"[Manager]kill fail.pid=%d. Error: %s [%d]\", worker->pid, strerror(errno), errno);\n            }\n             alarm(1);\n             break;\n        }\n        for(;i<SwooleGS->task_num;i++)\n        {\n            worker = &(pool->workers[i]);\n            if(worker->tasking_num >=1)//todo support config\n            {\n                over_load_num++;\n            }\n            else// == 0\n            {\n               zero_load_num++;\n            }\n        }\n        \n        if(over_load_num>SwooleGS->task_num/2&&SwooleGS->task_num<SwooleG.task_worker_max)\n        {\n           if(swProcessPool_spawn(&(pool->workers[SwooleGS->task_num])) < 0)\n           {\n                swWarn(\"swProcessPool_spawn fail\");\n           }\n           else\n           {\n                SwooleGS->task_num++;\n           }\n        }\n        else if(zero_load_num>=SwooleG.task_worker_num&&SwooleGS->task_num>SwooleG.task_worker_num)\n        { \n                  SwooleG.task_recycle_num++;\n                  if(SwooleG.task_recycle_num>3)\n                  {\n                    SwooleGS->task_num--;\n                    worker = &(pool->workers[SwooleGS->task_num]);\n                    worker->del = 1;\n                    SwooleG.task_recycle_num = 0;\n                  }\n        }\n        alarm(1);\n        break;\n    /**\n     * reload all workers\n     */\n    case SIGUSR1:\n        if (ManagerProcess.reloading == 0)\n        {\n            ManagerProcess.reloading = 1;\n            ManagerProcess.reload_event_worker = 1;\n        }\n        break;\n    /**\n     * only reload task workers\n     */\n    case SIGUSR2:\n        if (ManagerProcess.reloading == 0)\n        {\n            ManagerProcess.reloading = 1;\n            ManagerProcess.reload_task_worker = 1;\n        }\n        break;\n    default:\n        break;\n    }\n}\n\nstatic int swFactoryProcess_manager_loop(swFactory *factory)\n{\n    int pid, new_pid;\n    int i;\n    int reload_worker_i = 0;\n    int reload_worker_num;\n    int ret;\n    int worker_exit_code;\n\n    SwooleG.use_signalfd = 0;\n    SwooleG.use_timerfd = 0;\n\n    memset(&ManagerProcess, 0, sizeof(ManagerProcess));\n\n    swServer *serv = factory->ptr;\n    swWorker *reload_workers;\n\n    if (serv->onManagerStart)\n    {\n        serv->onManagerStart(serv);\n    }\n\n    reload_worker_num = serv->worker_num + SwooleG.task_worker_num;\n    reload_workers = sw_calloc(reload_worker_num, sizeof(swWorker));\n    if (reload_workers == NULL)\n    {\n        swError(\"malloc[reload_workers] failed\");\n        return SW_ERR;\n    }\n\n    //for reload\n    swSignal_add(SIGHUP, NULL);\n    swSignal_add(SIGTERM, swManager_signal_handle);\n    swSignal_add(SIGUSR1, swManager_signal_handle);\n    swSignal_add(SIGUSR2, swManager_signal_handle);\n    //swSignal_add(SIGINT, swManager_signal_handle);\n    \n     //for add/recycle task process\n    if (SwooleG.task_worker_max > 0)\n    {\n        swSignal_add(SIGALRM, swManager_signal_handle);\n        alarm(1);\n    }\n\n    while (SwooleG.running > 0)\n    {\n        pid = wait(&worker_exit_code);\n\n        if (pid < 0)\n        {\n            if (ManagerProcess.reloading == 0)\n            {\n                swTrace(\"wait() failed. Error: %s [%d]\", strerror(errno), errno);\n            }\n            else if (ManagerProcess.reload_event_worker == 1)\n            {\n                memcpy(reload_workers, serv->workers, sizeof(swWorker) * serv->worker_num);\n                reload_worker_num = serv->worker_num;\n                if (SwooleG.task_worker_num > 0)\n                {\n                    memcpy(reload_workers + serv->worker_num, SwooleG.task_workers.workers,\n                            sizeof(swWorker) * SwooleG.task_worker_num);\n                    reload_worker_num += SwooleG.task_worker_num;\n                }\n                reload_worker_i = 0;\n                ManagerProcess.reload_event_worker = 0;\n                goto kill_worker;\n            }\n            else if (ManagerProcess.reload_task_worker == 1)\n            {\n                if (SwooleG.task_worker_num == 0)\n                {\n                    swWarn(\"Cannot reload workers, because server no have task workers.\");\n                    continue;\n                }\n                memcpy(reload_workers, SwooleG.task_workers.workers, sizeof(swWorker) * SwooleG.task_worker_num);\n                reload_worker_num = SwooleG.task_worker_num;\n                reload_worker_i = 0;\n                ManagerProcess.reload_task_worker = 0;\n                goto kill_worker;\n            }\n        }\n        if (SwooleG.running == 1)\n        {\n            for (i = 0; i < serv->worker_num; i++)\n            {\n                //compare PID\n                if (pid != serv->workers[i].pid)\n                {\n                    continue;\n                }\n                else\n                {\n                    if (serv->onWorkerError != NULL && WEXITSTATUS(worker_exit_code) > 0)\n                    {\n                        serv->onWorkerError(serv, i, pid, WEXITSTATUS(worker_exit_code));\n                    }\n                    pid = 0;\n                    while (1)\n                    {\n                        new_pid = swFactoryProcess_worker_spawn(factory, i);\n                        if (new_pid < 0)\n                        {\n                            usleep(100000);\n                            continue;\n                        }\n                        else\n                        {\n                            serv->workers[i].pid = new_pid;\n                            break;\n                        }\n                    }\n                }\n            }\n\n            //task worker\n            if (pid > 0)\n            {\n                swWorker *exit_worker = swHashMap_find_int(SwooleG.task_workers.map, pid);\n                if (exit_worker != NULL)\n                {\n                    if(exit_worker->del == 1)//\u4e3b\u52a8\u56de\u6536\u4e0d\u91cd\u542f\n                    {\n                        exit_worker->del = 0;\n                    }\n                    else\n                    {\n                      swProcessPool_spawn(exit_worker);\n                      goto kill_worker;\n                    }\n                }\n\n                if(serv->user_worker_map != NULL)\n                {\n                    exit_worker = swHashMap_find_int(serv->user_worker_map, pid);\n                    if (exit_worker != NULL)\n                    {\n                        swManager_create_user_worker(serv, exit_worker);\n                        goto kill_worker;\n                    }\n                }\n            }\n        }\n        //reload worker\n        kill_worker:\n        if (ManagerProcess.reloading == 1)\n        {\n            //reload finish\n            if (reload_worker_i >= reload_worker_num)\n            {\n                ManagerProcess.reloading = 0;\n                reload_worker_i = 0;\n                continue;\n            }\n            ret = kill(reload_workers[reload_worker_i].pid, SIGTERM);\n            if (ret < 0)\n            {\n                swSysError(\"[Manager]kill(%d) failed.\", reload_workers[reload_worker_i].pid);\n                continue;\n            }\n            reload_worker_i++;\n        }\n    }\n\n    sw_free(reload_workers);\n\n    //kill all child process\n    for (i = 0; i < serv->worker_num; i++)\n    {\n        swTrace(\"[Manager]kill worker processor\");\n        kill(serv->workers[i].pid, SIGTERM);\n    }\n\n    if (SwooleG.task_worker_num > 0)\n    {\n        swProcessPool_shutdown(&SwooleG.task_workers);\n    }\n\n    if (serv->onManagerStop)\n    {\n        serv->onManagerStop(serv);\n    }\n    return SW_OK;\n}\n\nstatic int swFactoryProcess_worker_spawn(swFactory *factory, int worker_pti)\n{\n    int pid, ret;\n    struct passwd *passwd;\n    struct group *group;\n    int is_root = !geteuid();\n\n    pid = fork();\n    if (pid < 0)\n    {\n        swWarn(\"Fork Worker failed. Error: %s [%d]\", strerror(errno), errno);\n        return SW_ERR;\n    }\n    //worker child processor\n    else if (pid == 0)\n    {\n        if(is_root) \n        {\n            passwd = getpwnam(SwooleG.user);\n            group  = getgrnam(SwooleG.group);\n\n            if(passwd != NULL) \n            {\n                if (0 > setuid(passwd->pw_uid)) \n                {\n                    swWarn(\"setuid to %s fail \\r\\n\", SwooleG.user);\n                }\n            }\n            else\n            {\n                swWarn(\"get user %s info fail \\r\\n\", SwooleG.user);\n            }\n\n            if(group != NULL) \n            {\n                if(0 > setgid(group->gr_gid)) \n                {\n                    swWarn(\"setgid to %s fail \\r\\n\", SwooleG.group);\n                }\n            }\n            else\n            {\n                swWarn(\"get group %s info fail \\r\\n\", SwooleG.group);\n            }\n        }\n        ret = swWorker_loop(factory, worker_pti);\n        exit(ret);\n    }\n    //parent,add to writer\n    else\n    {\n        return pid;\n    }\n}\n\n/**\n * Close the connection\n */\nint swFactoryProcess_end(swFactory *factory, int fd)\n{\n    swServer *serv = factory->ptr;\n    swSendData _send;\n\n    bzero(&_send, sizeof(_send));\n    _send.info.fd = fd;\n    _send.info.len = 0;\n    _send.info.type = SW_EVENT_CLOSE;\n\n    swConnection *conn = swServer_connection_get(serv, _send.info.fd);\n    if (conn == NULL || conn->active == 0)\n    {\n        //swWarn(\"can not close. Connection[%d] not found.\", _send.info.fd);\n        return SW_ERR;\n    }\n    else if (conn->closing)\n    {\n        swWarn(\"The connection[%d] is closing.\", fd);\n        return SW_ERR;\n    }\n    else if (conn->closed)\n    {\n        return SW_ERR;\n    }\n    else\n    {\n        if (serv->onClose != NULL)\n        {\n            serv->onClose(serv, fd, conn->from_id);\n        }\n        conn->closed = 1;\n        return swFactoryProcess_finish(factory, &_send);\n    }\n}\n\n/**\n * worker: send to client\n */\nint swFactoryProcess_finish(swFactory *factory, swSendData *resp)\n{\n    int ret, sendn;\n    swServer *serv = factory->ptr;\n    int fd = resp->info.fd;\n\n    //unix dgram\n    if (resp->info.type == SW_EVENT_UNIX_DGRAM)\n    {\n        socklen_t len;\n        struct sockaddr_un addr_un;\n        int from_sock = resp->info.from_fd;\n\n        addr_un.sun_family = AF_UNIX;\n        memcpy(addr_un.sun_path, resp->sun_path, resp->sun_path_len);\n        len = sizeof(addr_un);\n        ret = swSocket_sendto_blocking(from_sock, resp->data, resp->info.len, 0, (struct sockaddr *) &addr_un, len);\n        goto finish;\n    }\n    //UDP pacakge\n    else if (resp->info.type == SW_EVENT_UDP || resp->info.type == SW_EVENT_UDP6)\n    {\n        return swServer_udp_send(serv, resp);\n    }\n\n    //for message queue\n    swEventData_overflow sdata;\n    sdata.pti = (SwooleWG.id % serv->writer_num) + 1;\n\n    swConnection *conn = swServer_connection_get(serv, fd);\n    if (conn == NULL || conn->active == 0)\n    {\n        swWarn(\"send failed, because connection[%d] has been closed.\", fd);\n        return SW_ERR;\n    }\n\n    sdata._send.info.fd = fd;\n    sdata._send.info.type = resp->info.type;\n    swWorker *worker = swServer_get_worker(serv, SwooleWG.id);\n\n\t/**\n     * Big response, use shared memory\n     */\n    if (resp->length > 0)\n    {\n        swPackage_response response;\n\n        worker->lock.lock(&worker->lock);\n\n        response.length = resp->length;\n        response.worker_id = SwooleWG.id;\n\n        //swWarn(\"BigPackage, length=%d|worker_id=%d\", response.length, response.worker_id);\n\n        sdata._send.info.from_fd = SW_RESPONSE_BIG;\n        sdata._send.info.len = sizeof(response);\n\n        memcpy(sdata._send.data, &response, sizeof(response));\n        memcpy(worker->send_shm, resp->data, resp->length);\n    }\n    else\n    {\n        //copy data\n        memcpy(sdata._send.data, resp->data, resp->info.len);\n\n        sdata._send.info.len = resp->info.len;\n        sdata._send.info.from_fd = SW_RESPONSE_SMALL;\n    }\n\n#if SW_REACTOR_SCHEDULE == 2\n    sdata._send.info.from_id = fd % serv->reactor_num;\n#else\n    sdata._send.info.from_id = conn->from_id;\n#endif\n\n    sendn = sdata._send.info.len + sizeof(resp->info);\n    //swWarn(\"send: sendn=%d|type=%d|content=%s\", sendn, resp->info.type, resp->data);\n    swTrace(\"[Worker]input_queue[%ld]->in| fd=%d\", sdata.pti, fd);\n\n    ret = swWorker_send2reactor(&sdata, sendn, fd);\n\n    finish:\n    if (ret < 0)\n    {\n        swWarn(\"sendto to reactor failed. Error: %s [%d]\", strerror(errno), errno);\n    }\n    return ret;\n}\n\nstatic __thread struct\n{\n    long target_worker_id;\n    swDataHead _send;\n} sw_notify_data;\n\n/**\n * \u4e3b\u8fdb\u7a0b\u901a\u77e5worker\u8fdb\u7a0b\n */\nint swFactoryProcess_notify(swFactory *factory, swDataHead *ev)\n{\n    memcpy(&sw_notify_data._send, ev, sizeof(swDataHead));\n    sw_notify_data._send.len = 0;\n    sw_notify_data.target_worker_id = -1;\n    return factory->dispatch(factory, (swDispatchData *) &sw_notify_data);\n}\n\n/**\n * [ReactorThread] dispatch request to worker\n */\nint swFactoryProcess_dispatch(swFactory *factory, swDispatchData *task)\n{\n    uint32_t schedule_key;\n    uint32_t send_len = sizeof(task->data.info) + task->data.info.len;\n    uint16_t target_worker_id;\n    swServer *serv = SwooleG.serv;\n\n    if (task->target_worker_id < 0)\n    {\n        //udp use remote port\n        if (task->data.info.type == SW_EVENT_UDP || task->data.info.type == SW_EVENT_UDP6\n                || task->data.info.type == SW_EVENT_UNIX_DGRAM)\n        {\n            if (serv->dispatch_mode == SW_DISPATCH_IPMOD)\n            {\n                schedule_key = task->data.info.fd;\n            }\n            else\n            {\n                schedule_key = task->data.info.from_id;\n            }\n        }\n        else\n        {\n            schedule_key = task->data.info.fd;\n        }\n\n#ifndef SW_USE_RINGBUFFER\n        if (SwooleTG.factory_lock_target)\n        {\n            if (SwooleTG.factory_target_worker < 0)\n            {\n                target_worker_id = swServer_worker_schedule(serv, schedule_key);\n                SwooleTG.factory_target_worker = target_worker_id;\n            }\n            else\n            {\n                target_worker_id = SwooleTG.factory_target_worker;\n            }\n        }\n        else\n#endif\n        {\n            target_worker_id = swServer_worker_schedule(serv, schedule_key);\n        }\n    }\n    else\n    {\n        target_worker_id = task->target_worker_id;\n    }\n\n    if (SwooleTG.type == SW_THREAD_REACTOR)\n    {\n        return swReactorThread_send2worker((void *) &(task->data), send_len, target_worker_id);\n    }\n    else\n    {\n        return swServer_send2worker_blocking(serv, (void *) &(task->data), send_len, target_worker_id);\n    }\n}\n\n/**\n * for message queue\n */\nstatic int swFactoryProcess_writer_start(swFactory *factory)\n{\n    swServer *serv = SwooleG.serv;\n    swThreadParam *param;\n    int i;\n    pthread_t pidt;\n\n    for (i = 0; i < serv->writer_num; i++)\n    {\n        param = sw_malloc(sizeof(swPipe));\n        if (param == NULL)\n        {\n            swSysError(\"malloc failed.\");\n            return SW_ERR;\n        }\n        param->object = factory;\n        param->pti = i;\n        if (pthread_create(&pidt, NULL, (swThreadStartFunc) swFactoryProcess_writer_loop_queue, (void *) param) < 0)\n        {\n            swSysError(\"pthread_create() failed.\");\n            return SW_ERR;\n        }\n        pthread_detach(pidt);\n        serv->writer_threads[i].ptid = pidt;\n        SW_START_SLEEP;\n    }\n    return SW_OK;\n}\n\n/**\n * Use message queue ipc\n */\nint swFactoryProcess_writer_loop_queue(swThreadParam *param)\n{\n    swEventData *resp;\n    swServer *serv = SwooleG.serv;\n    swConnection *conn;\n\n    int pti = param->pti;\n    swQueue_data sdata;\n    //\u5fc5\u987b\u52a01,msg_type\u5fc5\u987b\u4e0d\u80fd\u4e3a0\n    sdata.mtype = pti + 1;\n\n    swSignal_none();\n    while (SwooleG.running > 0)\n    {\n        swTrace(\"[Writer]wt_queue[%ld]->out wait\", sdata.mtype);\n        if (serv->write_queue.out(&serv->write_queue, &sdata, sizeof(sdata.mdata)) < 0)\n        {\n            swSysError(\"[writer#%d]wt_queue->out() failed.\", pti);\n        }\n        else\n        {\n            int ret;\n            resp = (swEventData *) sdata.mdata;\n            conn = swServer_connection_get(serv, resp->info.fd);\n            if (!conn)\n            {\n                swWarn(\"Connection[%d] not found.\", resp->info.fd);\n                continue;\n            }\n            swReactor *reactor = &serv->reactor_threads[conn->from_id].reactor;\n            //close connection\n            //TODO: thread safe, should close in reactor thread.\n            if (resp->info.type == SW_EVENT_CLOSE)\n            {\n                close_fd:\n                reactor->close(reactor, resp->info.fd);\n                continue;\n            }\n            //sendfile\n            else if (resp->info.type == SW_EVENT_SENDFILE)\n            {\n                ret = swSocket_sendfile_sync(resp->info.fd, resp->data, SW_WRITER_TIMEOUT);\n            }\n            //send data\n            else\n            {\n                ret = swConnection_send_blocking(resp->info.fd, resp->data, resp->info.len, 1000 * SW_WRITER_TIMEOUT);\n            }\n\n            if (ret < 0)\n            {\n                switch (swConnection_error(errno))\n                {\n                case SW_ERROR:\n                    swSysError(\"send to client[%d] failed.\", resp->info.fd);\n                    break;\n                case SW_CLOSE:\n                    goto close_fd;\n                default:\n                    break;\n                }\n            }\n        }\n    }\n    pthread_exit((void *) param);\n    return SW_OK;\n}\n",
        "lookback": "  +----------------------------------------------------------------------+",
        "lookahead": "",
        "label": [
            "interleave",
            "complex_conflict"
        ],
        "start_line": 0,
        "end_line": 2887,
        "merge_gen_region": null,
        "confidence": 0.6651917695999146,
        "hesitated": true
    }
]