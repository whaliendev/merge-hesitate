[
    {
        "a_contents": "/*\n  +----------------------------------------------------------------------+\n  | Swoole                                                               |\n  +----------------------------------------------------------------------+\n  | This source file is subject to version 2.0 of the Apache license,    |\n  | that is bundled with this package in the file LICENSE, and is        |\n  | available through the world-wide-web at the following url:           |\n  | http://www.apache.org/licenses/LICENSE-2.0.html                      |\n  | If you did not receive a copy of the Apache2.0 license and are unable|\n  | to obtain it through the world-wide-web, please send a note to       |\n  | license@swoole.com so we can mail you a copy immediately.            |\n  +----------------------------------------------------------------------+\n  | Author: Tianfeng Han  <mikan.tenny@gmail.com>                        |\n  +----------------------------------------------------------------------+\n */\n\n#include \"php_swoole.h\"\n\n#include \"Connection.h\"\n\n#ifdef SW_COROUTINE\n#include \"swoole_coroutine.h\"\n#endif\n#include \"ext/standard/php_var.h\"\n#if PHP_MAJOR_VERSION < 7\n#include \"ext/standard/php_smart_str.h\"\n#else\n#include \"zend_smart_str.h\"\n#endif\n\nstatic int php_swoole_task_id;\nstatic int udp_server_socket;\nstatic int dgram_server_socket;\n\nstatic struct\n{\n    zval *zobjects[SW_MAX_LISTEN_PORT];\n    zval *zports;\n    uint8_t num;\n} server_port_list;\n\nzval *php_sw_server_callbacks[PHP_SERVER_CALLBACK_NUM];\n#ifdef SW_COROUTINE\nzend_fcall_info_cache *php_sw_server_caches[PHP_SERVER_CALLBACK_NUM];\n#endif\n\nstatic swHashMap *task_callbacks;\n\n#if PHP_MAJOR_VERSION >= 7\nzval _php_sw_server_callbacks[PHP_SERVER_CALLBACK_NUM];\n#endif\n\nstatic int php_swoole_task_finish(swServer *serv, zval *data TSRMLS_DC);\nstatic void php_swoole_onPipeMessage(swServer *serv, swEventData *req);\nstatic void php_swoole_onStart(swServer *);\nstatic void php_swoole_onShutdown(swServer *);\n\nstatic int php_swoole_onPacket(swServer *, swEventData *);\n\nstatic void php_swoole_onWorkerStart(swServer *, int worker_id);\nstatic void php_swoole_onWorkerStop(swServer *, int worker_id);\nstatic void php_swoole_onUserWorkerStart(swServer *serv, swWorker *worker);\nstatic int php_swoole_onTask(swServer *, swEventData *task);\nstatic int php_swoole_onFinish(swServer *, swEventData *task);\nstatic void php_swoole_onWorkerError(swServer *serv, int worker_id, pid_t worker_pid, int exit_code, int signo);\nstatic void php_swoole_onManagerStart(swServer *serv);\nstatic void php_swoole_onManagerStop(swServer *serv);\n\nstatic zval* php_swoole_server_add_port(swListenPort *port TSRMLS_DC);\nstatic zval* php_swoole_get_task_result(swEventData *task_result TSRMLS_DC);\n\nstatic sw_inline int php_swoole_task_pack(swEventData *task, zval *data TSRMLS_DC)\n{\n    smart_str serialized_data = { 0 };\n    php_serialize_data_t var_hash;\n\n    task->info.type = SW_EVENT_TASK;\n    //field fd save task_id\n    task->info.fd = php_swoole_task_id++;\n    //field from_id save the worker_id\n    task->info.from_id = SwooleWG.id;\n    swTask_type(task) = 0;\n\n    char *task_data_str;\n    int task_data_len = 0;\n    //need serialize\n    if (SW_Z_TYPE_P(data) != IS_STRING)\n    {\n        //serialize\n        swTask_type(task) |= SW_TASK_SERIALIZE;\n        PHP_VAR_SERIALIZE_INIT(var_hash);\n        sw_php_var_serialize(&serialized_data, data, &var_hash TSRMLS_CC);\n        PHP_VAR_SERIALIZE_DESTROY(var_hash);\n#if PHP_MAJOR_VERSION<7\n        task_data_str = serialized_data.c;\n        task_data_len = serialized_data.len;\n#else\n        task_data_str = serialized_data.s->val;\n        task_data_len = serialized_data.s->len;\n#endif\n    }\n    else\n    {\n        task_data_str = Z_STRVAL_P(data);\n        task_data_len = Z_STRLEN_P(data);\n    }\n\n    if (task_data_len >= SW_IPC_MAX_SIZE - sizeof(task->info))\n    {\n        if (swTaskWorker_large_pack(task, task_data_str, task_data_len) < 0)\n        {\n            smart_str_free(&serialized_data);\n            swoole_php_fatal_error(E_WARNING, \"large task pack failed()\");\n            return SW_ERR;\n        }\n    }\n    else\n    {\n        memcpy(task->data, task_data_str, task_data_len);\n        task->info.len = task_data_len;\n    }\n    smart_str_free(&serialized_data);\n    return task->info.fd;\n}\n\nvoid php_swoole_get_recv_data(zval *zdata, swEventData *req, char *header, uint32_t header_length)\n{\n    char *data_ptr = NULL;\n    int data_len;\n\n#ifdef SW_USE_RINGBUFFER\n    swPackage package;\n    if (req->info.type == SW_EVENT_PACKAGE)\n    {\n        memcpy(&package, req->data, sizeof (package));\n\n        data_ptr = package.data;\n        data_len = package.length;\n    }\n#else\n    if (req->info.type == SW_EVENT_PACKAGE_END)\n    {\n        swString *worker_buffer = swWorker_get_buffer(SwooleG.serv, req->info.from_id);\n        data_ptr = worker_buffer->str;\n        data_len = worker_buffer->length;\n    }\n#endif\n    else\n    {\n        data_ptr = req->data;\n        data_len = req->info.len;\n    }\n\n    if (header_length >= data_len)\n    {\n        SW_ZVAL_STRING(zdata, \"\", 1);\n    }\n    else\n    {\n        SW_ZVAL_STRINGL(zdata, data_ptr + header_length, data_len - header_length, 1);\n    }\n\n    if (header_length > 0)\n    {\n        memcpy(header, data_ptr, header_length);\n    }\n\n#ifdef SW_USE_RINGBUFFER\n    if (req->info.type == SW_EVENT_PACKAGE)\n    {\n        swReactorThread *thread = swServer_get_thread(SwooleG.serv, req->info.from_id);\n        thread->buffer_input->free(thread->buffer_input, data_ptr);\n    }\n#endif\n}\n\nint php_swoole_get_send_data(zval *zdata, char **str TSRMLS_DC)\n{\n    int length;\n\n    if (SW_Z_TYPE_P(zdata) == IS_OBJECT)\n    {\n        if (!instanceof_function(Z_OBJCE_P(zdata), swoole_buffer_class_entry_ptr TSRMLS_CC))\n        {\n            goto convert;\n        }\n        swString *str_buffer = swoole_get_object(zdata);\n        if (!str_buffer->str)\n        {\n            swoole_php_fatal_error(E_WARNING, \"swoole_buffer object is empty.\");\n            return SW_ERR;\n        }\n        length = str_buffer->length - str_buffer->offset;\n        *str = str_buffer->str + str_buffer->offset;\n    }\n    else\n    {\n        convert:\n        convert_to_string(zdata);\n        length = Z_STRLEN_P(zdata);\n        *str = Z_STRVAL_P(zdata);\n    }\n\n    if (length >= SwooleG.serv->buffer_output_size)\n    {\n        swoole_php_fatal_error(E_WARNING, \"send %d byte data fail, max_size is %d.\", length, SwooleG.serv->buffer_output_size);\n        return SW_ERR;\n    }\n\n    return length;\n}\n\nstatic sw_inline int php_swoole_check_task_param(int dst_worker_id TSRMLS_DC)\n{\n    if (SwooleG.task_worker_num < 1)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Task method cannot use, Please set task_worker_num.\");\n        return SW_ERR;\n    }\n\n    if (dst_worker_id >= SwooleG.task_worker_num)\n    {\n        swoole_php_fatal_error(E_WARNING, \"worker_id must be less than serv->task_worker_num.\");\n        return SW_ERR;\n    }\n\n    if (!swIsWorker())\n    {\n        swoole_php_fatal_error(E_WARNING, \"The method can only be used in the worker process.\");\n        return SW_ERR;\n    }\n\n    return SW_OK;\n}\n\nstatic zval* php_swoole_get_task_result(swEventData *task_result TSRMLS_DC)\n{\n    zval *result_data, *result_unserialized_data;\n    char *result_data_str;\n    int result_data_len = 0;\n    php_unserialize_data_t var_hash;\n\n    int data_len;\n    char *data_str = NULL;\n\n    /**\n     * Large result package\n     */\n    if (swTask_type(task_result) & SW_TASK_TMPFILE)\n    {\n        swTaskWorker_large_unpack(task_result, emalloc, data_str, data_len);\n        /**\n         * unpack failed\n         */\n        if (data_len == -1)\n        {\n            if (data_str)\n            {\n                efree(data_str);\n            }\n            return NULL;\n        }\n        result_data_str = data_str;\n        result_data_len = data_len;\n    }\n    else\n    {\n        result_data_str = task_result->data;\n        result_data_len = task_result->info.len;\n    }\n\n    if (swTask_type(task_result) & SW_TASK_SERIALIZE)\n    {\n        PHP_VAR_UNSERIALIZE_INIT(var_hash);\n        SW_ALLOC_INIT_ZVAL(result_unserialized_data);\n\n        if (sw_php_var_unserialize(&result_unserialized_data, (const unsigned char **) &result_data_str,\n                (const unsigned char *) (result_data_str + result_data_len), &var_hash TSRMLS_CC))\n        {\n            result_data = result_unserialized_data;\n        }\n        else\n        {\n            SW_ALLOC_INIT_ZVAL(result_data);\n            SW_ZVAL_STRINGL(result_data, result_data_str, result_data_len, 1);\n        }\n        PHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n    }\n    else\n    {\n        SW_ALLOC_INIT_ZVAL(result_data);\n        SW_ZVAL_STRINGL(result_data, result_data_str, result_data_len, 1);\n    }\n    if (data_str)\n    {\n        efree(data_str);\n    }\n    return result_data;\n}\n\nstatic zval* php_swoole_server_add_port(swListenPort *port TSRMLS_DC)\n{\n    zval *port_object;\n    SW_ALLOC_INIT_ZVAL(port_object);\n    object_init_ex(port_object, swoole_server_port_class_entry_ptr);\n    server_port_list.zobjects[server_port_list.num++] = port_object;\n\n    swoole_server_port_property *property = emalloc(sizeof(swoole_server_port_property));\n    bzero(property, sizeof(swoole_server_port_property));\n    swoole_set_property(port_object, 0, property);\n    swoole_set_object(port_object, port);\n\n    zend_update_property_string(swoole_server_port_class_entry_ptr, port_object, ZEND_STRL(\"host\"), port->host TSRMLS_CC);\n    zend_update_property_long(swoole_server_port_class_entry_ptr, port_object, ZEND_STRL(\"port\"), port->port TSRMLS_CC);\n    zend_update_property_long(swoole_server_port_class_entry_ptr, port_object, ZEND_STRL(\"type\"), port->type TSRMLS_CC);\n\n    add_next_index_zval(server_port_list.zports, port_object);\n\n    return port_object;\n}\n\nvoid php_swoole_server_before_start(swServer *serv, zval *zobject TSRMLS_DC)\n{\n    /**\n     * create swoole server\n     */\n    if (swServer_create(serv) < 0)\n    {\n        swoole_php_fatal_error(E_ERROR, \"create server failed. Error: %s\", sw_error);\n        return;\n    }\n\n    swTrace(\"Create swoole_server host=%s, port=%d, mode=%d, type=%d\", serv->listen_list->host, (int) serv->listen_list->port, serv->factory_mode, (int) serv->listen_list->type);\n\n#ifdef SW_COROUTINE\n    coro_init(TSRMLS_C);\n#endif\n\n    /**\n     * Master Process ID\n     */\n    zend_update_property_long(swoole_server_class_entry_ptr, zobject, ZEND_STRL(\"master_pid\"), getpid() TSRMLS_CC);\n\n    zval *zsetting = sw_zend_read_property(swoole_server_class_entry_ptr, zobject, ZEND_STRL(\"setting\"), 1 TSRMLS_CC);\n    if (zsetting == NULL || ZVAL_IS_NULL(zsetting))\n    {\n        SW_MAKE_STD_ZVAL(zsetting);\n        array_init(zsetting);\n        zend_update_property(swoole_server_class_entry_ptr, zobject, ZEND_STRL(\"setting\"), zsetting TSRMLS_CC);\n    }\n\n    if (!sw_zend_hash_exists(Z_ARRVAL_P(zsetting), ZEND_STRL(\"worker_num\")))\n    {\n        add_assoc_long(zsetting, \"worker_num\", serv->worker_num);\n    }\n    if (!sw_zend_hash_exists(Z_ARRVAL_P(zsetting), ZEND_STRL(\"task_worker_num\")))\n    {\n        add_assoc_long(zsetting, \"task_worker_num\", SwooleG.task_worker_num);\n    }\n    if (!sw_zend_hash_exists(Z_ARRVAL_P(zsetting), ZEND_STRL(\"pipe_buffer_size\")))\n    {\n        add_assoc_long(zsetting, \"pipe_buffer_size\", serv->pipe_buffer_size);\n    }\n    if (!sw_zend_hash_exists(Z_ARRVAL_P(zsetting), ZEND_STRL(\"buffer_output_size\")))\n    {\n        add_assoc_long(zsetting, \"buffer_output_size\", serv->buffer_output_size);\n    }\n    if (!sw_zend_hash_exists(Z_ARRVAL_P(zsetting), ZEND_STRL(\"max_connection\")))\n    {\n        add_assoc_long(zsetting, \"max_connection\", serv->max_connection);\n    }\n\n    int i;\n    zval *retval = NULL;\n    zval *port_object;\n    zval *port_setting;\n\n    for (i = 1; i < server_port_list.num; i++)\n    {\n        port_object = server_port_list.zobjects[i];\n        port_setting = sw_zend_read_property(swoole_server_port_class_entry_ptr, port_object, ZEND_STRL(\"setting\"), 1 TSRMLS_CC);\n        //use swoole_server->setting\n        if (port_setting == NULL || ZVAL_IS_NULL(port_setting))\n        {\n            sw_zval_add_ref(&port_setting);\n            sw_zval_add_ref(&port_object);\n            sw_zend_call_method_with_1_params(&port_object, swoole_server_port_class_entry_ptr, NULL, \"set\", &retval, zsetting);\n            if (retval != NULL)\n            {\n                sw_zval_ptr_dtor(&retval);\n            }\n        }\n    }\n}\n\nvoid php_swoole_register_callback(swServer *serv)\n{\n    /*\n     * optional callback\n     */\n    if (php_sw_server_callbacks[SW_SERVER_CB_onStart] != NULL)\n    {\n        serv->onStart = php_swoole_onStart;\n    }\n    serv->onShutdown = php_swoole_onShutdown;\n    /**\n     * require callback, set the master/manager/worker PID\n     */\n    serv->onWorkerStart = php_swoole_onWorkerStart;\n\n    if (php_sw_server_callbacks[SW_SERVER_CB_onWorkerStop] != NULL)\n    {\n        serv->onWorkerStop = php_swoole_onWorkerStop;\n    }\n    /**\n     * UDP Packet\n     */\n    if (php_sw_server_callbacks[SW_SERVER_CB_onPacket] != NULL)\n    {\n        serv->onPacket = php_swoole_onPacket;\n    }\n    /**\n     * Task Worker\n     */\n    if (php_sw_server_callbacks[SW_SERVER_CB_onTask] != NULL)\n    {\n        serv->onTask = php_swoole_onTask;\n    }\n    if (php_sw_server_callbacks[SW_SERVER_CB_onFinish] != NULL)\n    {\n        serv->onFinish = php_swoole_onFinish;\n    }\n    if (php_sw_server_callbacks[SW_SERVER_CB_onWorkerError] != NULL)\n    {\n        serv->onWorkerError = php_swoole_onWorkerError;\n    }\n    if (php_sw_server_callbacks[SW_SERVER_CB_onManagerStart] != NULL)\n    {\n        serv->onManagerStart = php_swoole_onManagerStart;\n    }\n    if (php_sw_server_callbacks[SW_SERVER_CB_onManagerStop] != NULL)\n    {\n        serv->onManagerStop = php_swoole_onManagerStop;\n    }\n    if (php_sw_server_callbacks[SW_SERVER_CB_onPipeMessage] != NULL)\n    {\n        serv->onPipeMessage = php_swoole_onPipeMessage;\n    }\n}\n\nstatic int php_swoole_task_finish(swServer *serv, zval *data TSRMLS_DC)\n{\n    int flags = 0;\n    smart_str serialized_data = {0};\n    php_serialize_data_t var_hash;\n    char *data_str;\n    int data_len = 0;\n    int ret;\n\n    //need serialize\n    if (SW_Z_TYPE_P(data) != IS_STRING)\n    {\n        //serialize\n        flags |= SW_TASK_SERIALIZE;\n        PHP_VAR_SERIALIZE_INIT(var_hash);\n        sw_php_var_serialize(&serialized_data, data, &var_hash TSRMLS_CC);\n        PHP_VAR_SERIALIZE_DESTROY(var_hash);\n#if PHP_MAJOR_VERSION<7\n        data_str = serialized_data.c;\n        data_len = serialized_data.len;\n#else\n        data_str = serialized_data.s->val;\n        data_len = serialized_data.s->len;\n#endif\n    }\n    else\n    {\n        data_str = Z_STRVAL_P(data);\n        data_len = Z_STRLEN_P(data);\n    }\n\n    ret = swTaskWorker_finish(serv, data_str, data_len, flags);\n\n    smart_str_free(&serialized_data);\n    return ret;\n}\n\nstatic void php_swoole_onPipeMessage(swServer *serv, swEventData *req)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    zval *zserv = (zval *) serv->ptr2;\n    zval *zworker_id;\n    zval *zdata;\n    zval *retval = NULL;\n\n    SW_MAKE_STD_ZVAL(zworker_id);\n    SW_MAKE_STD_ZVAL(zdata);\n\n    zval **args[3];\n\n    ZVAL_LONG(zworker_id, (long) req->info.from_id);\n\n    if (swTask_type(req) & SW_TASK_TMPFILE)\n    {\n        int data_len;\n        char *buf = NULL;\n        swTaskWorker_large_unpack(req, emalloc, buf, data_len);\n\n        /**\n         * unpack failed\n         */\n        if (data_len == -1)\n        {\n            if (buf)\n            {\n                efree(buf);\n            }\n            return;\n        }\n        SW_ZVAL_STRINGL(zdata, buf, data_len, 0);\n#if PHP_MAJOR_VERSION >= 7\n        efree(buf);\n#endif\n    }\n    else\n    {\n        SW_ZVAL_STRINGL(zdata, req->data, req->info.len, 1);\n    }\n\n    args[0] = &zserv;\n    args[1] = &zworker_id;\n    args[2] = &zdata;\n\n    swTrace(\"PipeMessage: fd=%d|len=%d|from_id=%d|data=%s\\n\", req->info.fd, req->info.len, req->info.from_id, req->data);\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onPipeMessage], &retval, 3, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onPipeMessage handler error\");\n    }\n\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n\n    sw_zval_ptr_dtor(&zworker_id);\n    sw_zval_ptr_dtor(&zdata);\n\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n}\n\nint php_swoole_onReceive(swServer *serv, swEventData *req)\n{\n    swFactory *factory = &serv->factory;\n    zval *zserv = (zval *) serv->ptr2;\n#ifdef SW_COROUTINE\n    zval *args[4];\n#else\n    zval **args[4];\n#endif\n\n    zval *zfd;\n    zval *zfrom_id;\n    zval *zdata;\n    zval *retval = NULL;\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    //UDP\u4f7f\u7528from_id\u4f5c\u4e3aport,fd\u505a\u4e3aip\n    php_swoole_udp_t udp_info;\n    swDgramPacket *packet;\n\n    SW_MAKE_STD_ZVAL(zfd);\n    SW_MAKE_STD_ZVAL(zfrom_id);\n    SW_MAKE_STD_ZVAL(zdata);\n\n    //dgram\n    if (swEventData_is_dgram(req->info.type))\n    {\n        swString *buffer = swWorker_get_buffer(serv, req->info.from_id);\n        packet = (swDgramPacket*) buffer->str;\n\n        //udp ipv4\n        if (req->info.type == SW_EVENT_UDP)\n        {\n            udp_info.from_fd = req->info.from_fd;\n            udp_info.port = packet->port;\n            memcpy(&udp_server_socket, &udp_info, sizeof(udp_server_socket));\n            factory->last_from_id = udp_server_socket;\n            swTrace(\"SendTo: from_id=%d|from_fd=%d\", (uint16_t) req->info.from_id, req->info.from_fd);\n            SW_ZVAL_STRINGL(zdata, packet->data, packet->length, 1);\n            ZVAL_LONG(zfrom_id, (long ) udp_server_socket);\n            ZVAL_LONG(zfd, (long ) packet->addr.v4.s_addr);\n        }\n        //udp ipv6\n        else if (req->info.type == SW_EVENT_UDP6)\n        {\n            udp_info.from_fd = req->info.from_fd;\n            udp_info.port = packet->port;\n            memcpy(&dgram_server_socket, &udp_info, sizeof(udp_server_socket));\n            factory->last_from_id = dgram_server_socket;\n\n            swTrace(\"SendTo: from_id=%d|from_fd=%d\", (uint16_t) req->info.from_id, req->info.from_fd);\n\n            ZVAL_LONG(zfrom_id, (long ) dgram_server_socket);\n            char tmp[INET6_ADDRSTRLEN];\n            inet_ntop(AF_INET6, &packet->addr.v6, tmp, sizeof(tmp));\n            SW_ZVAL_STRING(zfd, tmp, 1);\n            SW_ZVAL_STRINGL(zdata, packet->data, packet->length, 1);\n        }\n        //unix dgram\n        else\n        {\n            SW_ZVAL_STRINGL(zfd, packet->data, packet->addr.un.path_length, 1);\n            SW_ZVAL_STRINGL(zdata, packet->data + packet->addr.un.path_length, packet->length - packet->addr.un.path_length, 1);\n            ZVAL_LONG(zfrom_id, (long ) req->info.from_fd);\n            dgram_server_socket = req->info.from_fd;\n        }\n    }\n    //stream\n    else\n    {\n        ZVAL_LONG(zfrom_id, (long ) req->info.from_id);\n        ZVAL_LONG(zfd, (long ) req->info.fd);\n        php_swoole_get_recv_data(zdata, req, NULL, 0);\n    }\n\n#ifndef SW_COROUTINE\n    zval *callback = php_swoole_server_get_callback(serv, req->info.from_fd, SW_SERVER_CB_onReceive);\n\n    args[0] = &zserv;\n    args[1] = &zfd;\n    args[2] = &zfrom_id;\n    args[3] = &zdata;\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, callback, &retval, 4, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onReceive handler error\");\n    }\n#else\n    args[0] = zserv;\n    args[1] = zfd;\n    args[2] = zfrom_id;\n    args[3] = zdata;\n\n    zend_fcall_info_cache *cache = php_swoole_server_get_cache(serv, req->info.from_fd, SW_SERVER_CB_onReceive);\n    int ret = coro_create(cache, args, 4, &retval);\n    if (ret != 0)\n    {\n        return SW_OK;\n    }\n#endif\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n    sw_zval_ptr_dtor(&zfd);\n    sw_zval_ptr_dtor(&zfrom_id);\n    sw_zval_ptr_dtor(&zdata);\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n    return SW_OK;\n}\n\nstatic int php_swoole_onPacket(swServer *serv, swEventData *req)\n{\n    zval *zserv = (zval *) serv->ptr2;\n    zval **args[3];\n\n    zval *zdata;\n    zval *zaddr;\n    zval *retval = NULL;\n    swDgramPacket *packet;\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    SW_MAKE_STD_ZVAL(zdata);\n    SW_MAKE_STD_ZVAL(zaddr);\n    array_init(zaddr);\n\n    swString *buffer = swWorker_get_buffer(serv, req->info.from_id);\n    packet = (swDgramPacket*) buffer->str;\n\n    add_assoc_long(zaddr, \"server_socket\", req->info.from_fd);\n\n    zval *callback = php_swoole_server_get_callback(serv, req->info.from_fd, SW_SERVER_CB_onPacket);\n\n    //udp ipv4\n    if (req->info.type == SW_EVENT_UDP)\n    {\n        struct in_addr sin_addr;\n        sin_addr.s_addr = packet->addr.v4.s_addr;\n        char *address = inet_ntoa(sin_addr);\n        sw_add_assoc_string(zaddr, \"address\", address, 1);\n        add_assoc_long(zaddr, \"port\", packet->port);\n        SW_ZVAL_STRINGL(zdata, packet->data, packet->length, 1);\n    }\n    //udp ipv6\n    else if (req->info.type == SW_EVENT_UDP6)\n    {\n        char tmp[INET6_ADDRSTRLEN];\n        inet_ntop(AF_INET6, &packet->addr.v6, tmp, sizeof(tmp));\n        sw_add_assoc_string(zaddr, \"address\", tmp, 1);\n        add_assoc_long(zaddr, \"port\", packet->port);\n        SW_ZVAL_STRINGL(zdata, packet->data, packet->length, 1);\n    }\n    //unix dgram\n    else if (req->info.type == SW_EVENT_UNIX_DGRAM)\n    {\n        sw_add_assoc_stringl(zaddr, \"address\", packet->data, packet->addr.un.path_length, 1);\n        SW_ZVAL_STRINGL(zdata, packet->data + packet->addr.un.path_length, packet->length - packet->addr.un.path_length, 1);\n        dgram_server_socket = req->info.from_fd;\n    }\n\n    args[0] = &zserv;\n    args[1] = &zdata;\n    args[2] = &zaddr;\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, callback, &retval, 3, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onPacket handler error\");\n    }\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n    sw_zval_ptr_dtor(&zaddr);\n    sw_zval_ptr_dtor(&zdata);\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n    return SW_OK;\n}\n\nstatic int php_swoole_onTask(swServer *serv, swEventData *req)\n{\n    zval *zserv = (zval *) serv->ptr2;\n    zval **args[4];\n\n    zval *zfd;\n    zval *zfrom_id;\n    zval *zdata;\n\n    sw_atomic_fetch_sub(&SwooleStats->tasking_num, 1);\n\n    char *zdata_str;\n    int zdata_len;\n    zval *unserialized_zdata = NULL;\n    zval *retval = NULL;\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    SW_MAKE_STD_ZVAL(zfd);\n    ZVAL_LONG(zfd, (long) req->info.fd);\n\n    SW_MAKE_STD_ZVAL(zfrom_id);\n    ZVAL_LONG(zfrom_id, (long) req->info.from_id);\n\n    SW_MAKE_STD_ZVAL(zdata);\n\n    if (swTask_type(req) & SW_TASK_TMPFILE)\n    {\n        int data_len;\n        char *buf = NULL;\n\n        swTaskWorker_large_unpack(req, emalloc, buf, data_len);\n\n        /**\n         * unpack failed\n         */\n        if (data_len == -1)\n        {\n            if (buf)\n            {\n                efree(buf);\n            }\n            return SW_OK;\n        }\n        SW_ZVAL_STRINGL(zdata, buf, data_len, 0);\n#if PHP_MAJOR_VERSION >= 7\n        efree(buf);\n#endif\n    }\n    else\n    {\n        SW_ZVAL_STRINGL(zdata, req->data, req->info.len, 1);\n    }\n\n    args[0] = &zserv;\n    args[1] = &zfd;\n    args[2] = &zfrom_id;\n    args[3] = &zdata;\n\n#if PHP_MAJOR_VERSION >= 7\n    zval stack_unserialized_zdata;\n#endif\n\n    if (swTask_type(req) & SW_TASK_SERIALIZE)\n    {\n        php_unserialize_data_t var_hash;\n\n        PHP_VAR_UNSERIALIZE_INIT(var_hash);\n        zdata_str = Z_STRVAL_P(zdata);\n        zdata_len = Z_STRLEN_P(zdata);\n\n#if PHP_MAJOR_VERSION < 7\n        MAKE_STD_ZVAL(unserialized_zdata);\n#else\n        unserialized_zdata = &stack_unserialized_zdata;\n        bzero(unserialized_zdata, sizeof(zval));\n#endif\n\n        if (sw_php_var_unserialize(&unserialized_zdata, (const uchar ** ) &zdata_str,\n                (const uchar * ) (zdata_str + zdata_len), &var_hash TSRMLS_CC))\n        {\n            args[3] = &unserialized_zdata;\n        }\n        else\n        {\n            args[3] = &zdata;\n        }\n        PHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n    }\n    else\n    {\n        args[3] = &zdata;\n    }\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onTask], &retval, 4, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onTask handler error\");\n    }\n\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n\n    sw_zval_ptr_dtor(&zfd);\n    sw_zval_ptr_dtor(&zfrom_id);\n    sw_zval_ptr_dtor(&zdata);\n\n    if (unserialized_zdata)\n    {\n        sw_zval_ptr_dtor(&unserialized_zdata);\n    }\n\n    if (retval)\n    {\n        if (SW_Z_TYPE_P(retval) != IS_NULL)\n        {\n            php_swoole_task_finish(serv, retval TSRMLS_CC);\n        }\n        sw_zval_ptr_dtor(&retval);\n    }\n\n    return SW_OK;\n}\n\nstatic int php_swoole_onFinish(swServer *serv, swEventData *req)\n{\n    zval *zserv = (zval *) serv->ptr2;\n    zval **args[3];\n\n    zval *ztask_id;\n    zval *zdata;\n    zval *retval = NULL;\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    SW_MAKE_STD_ZVAL(ztask_id);\n    ZVAL_LONG(ztask_id, (long) req->info.fd);\n\n    zdata = php_swoole_get_task_result(req TSRMLS_CC);\n\n    args[0] = &zserv;\n    args[1] = &ztask_id;\n    args[2] = &zdata;\n\n    zval *callback;\n    if (swTask_type(req) & SW_TASK_CALLBACK)\n    {\n        callback = swHashMap_find_int(task_callbacks, req->info.fd);\n    }\n    else\n    {\n        callback = php_sw_server_callbacks[SW_SERVER_CB_onFinish];\n    }\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, callback, &retval, 3, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onFinish handler error\");\n    }\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n    sw_zval_ptr_dtor(&ztask_id);\n    sw_zval_ptr_dtor(&zdata);\n#if PHP_MAJOR_VERSION >= 7\n    efree(zdata);\n#endif\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n    if (swTask_type(req) & SW_TASK_CALLBACK)\n    {\n        swHashMap_del_int(task_callbacks, req->info.fd);\n        sw_zval_ptr_dtor(&callback);\n#if PHP_MAJOR_VERSION >= 7\n        efree(callback);\n#endif\n    }\n    return SW_OK;\n}\n\nstatic void php_swoole_onStart(swServer *serv)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    zval *zserv = (zval *) serv->ptr2;\n    zval **args[1];\n    zval *retval = NULL;\n\n    pid_t manager_pid = serv->factory_mode == SW_MODE_PROCESS ? SwooleGS->manager_pid : 0;\n\n    zend_update_property_long(swoole_server_class_entry_ptr, zserv, ZEND_STRL(\"master_pid\"), SwooleGS->master_pid TSRMLS_CC);\n    zend_update_property_long(swoole_server_class_entry_ptr, zserv, ZEND_STRL(\"manager_pid\"), manager_pid TSRMLS_CC);\n\n    args[0] = &zserv;\n    sw_zval_add_ref(&zserv);\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onStart], &retval, 1, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onStart handler error\");\n    }\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n}\n\nstatic void php_swoole_onManagerStart(swServer *serv)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    zval *zserv = (zval *) serv->ptr2;\n    zval **args[1];\n    zval *retval = NULL;\n\n    pid_t manager_pid = serv->factory_mode == SW_MODE_PROCESS ? SwooleGS->manager_pid : 0;\n\n    zend_update_property_long(swoole_server_class_entry_ptr, zserv, ZEND_STRL(\"master_pid\"), SwooleGS->master_pid TSRMLS_CC);\n    zend_update_property_long(swoole_server_class_entry_ptr, zserv, ZEND_STRL(\"manager_pid\"), manager_pid TSRMLS_CC);\n\n    args[0] = &zserv;\n    sw_zval_add_ref(&zserv);\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onManagerStart], &retval, 1, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onManagerStart handler error\");\n    }\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n}\n\nstatic void php_swoole_onManagerStop(swServer *serv)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n    zval *zserv = (zval *) serv->ptr2;\n    zval **args[1];\n    zval *retval = NULL;\n\n    args[0] = &zserv;\n    sw_zval_add_ref(&zserv);\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onManagerStop], &retval, 1, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onManagerStop handler error\");\n    }\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n}\n\nstatic void php_swoole_onShutdown(swServer *serv)\n{\n    zval *zserv = (zval *) serv->ptr2;\n    zval **args[1];\n    zval *retval = NULL;\n\n    args[0] = &zserv;\n    sw_zval_add_ref(&zserv);\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    if (php_sw_server_callbacks[SW_SERVER_CB_onShutdown] != NULL)\n    {\n        if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onShutdown], &retval, 1, args, 0, NULL TSRMLS_CC) == FAILURE)\n        {\n            swoole_php_fatal_error(E_WARNING, \"swoole_server: onShutdown handler error\");\n        }\n        if (EG(exception))\n        {\n            zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n        }\n        if (retval != NULL)\n        {\n            sw_zval_ptr_dtor(&retval);\n        }\n    }\n}\n\nstatic void php_swoole_onWorkerStart(swServer *serv, int worker_id)\n{\n    zval *zserv = (zval *) serv->ptr2;\n    zval *zworker_id;\n    zval **args[2];\n    zval *retval = NULL;\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    SW_MAKE_STD_ZVAL(zworker_id);\n    ZVAL_LONG(zworker_id, worker_id);\n\n    args[0] = &zserv;\n    sw_zval_add_ref(&zserv);\n    args[1] = &zworker_id;\n\n    /**\n     * Manager Process ID\n     */\n    zend_update_property_long(swoole_server_class_entry_ptr, zserv, ZEND_STRL(\"master_pid\"), SwooleGS->master_pid TSRMLS_CC);\n\n    /**\n     * Manager Process ID\n     */\n    zend_update_property_long(swoole_server_class_entry_ptr, zserv, ZEND_STRL(\"manager_pid\"), SwooleGS->manager_pid TSRMLS_CC);\n\n    /**\n     * Worker ID\n     */\n    zend_update_property(swoole_server_class_entry_ptr, zserv, ZEND_STRL(\"worker_id\"), zworker_id TSRMLS_CC);\n\n    /**\n     * Is a task worker?\n     */\n    if (worker_id >= serv->worker_num)\n    {\n        zend_update_property_bool(swoole_server_class_entry_ptr, zserv, ZEND_STRL(\"taskworker\"), 1 TSRMLS_CC);\n    }\n    else\n    {\n        zend_update_property_bool(swoole_server_class_entry_ptr, zserv, ZEND_STRL(\"taskworker\"), 0 TSRMLS_CC);\n    }\n\n    /**\n     * Worker Process ID\n     */\n    zend_update_property_long(swoole_server_class_entry_ptr, zserv, ZEND_STRL(\"worker_pid\"), getpid() TSRMLS_CC);\n\n    sw_zval_ptr_dtor(&zworker_id);\n\n    /**\n     * Have not set the event callback\n     */\n    if (php_sw_server_callbacks[SW_SERVER_CB_onWorkerStart] == NULL)\n    {\n        return;\n    }\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onWorkerStart], &retval, 2, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onWorkerStart handler error\");\n    }\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n    if (retval)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n}\n\nstatic void php_swoole_onWorkerStop(swServer *serv, int worker_id)\n{\n    if (SwooleWG.shutdown)\n    {\n        return;\n    }\n    SwooleWG.shutdown = 1;\n\n    zval *zobject = (zval *) serv->ptr2;\n    zval *zworker_id;\n    zval **args[2]; //\u8fd9\u91cc\u5fc5\u987b\u4e0e\u4e0b\u9762\u7684\u6570\u5b57\u5bf9\u5e94\n    zval *retval = NULL;\n\n    SW_MAKE_STD_ZVAL(zworker_id);\n    ZVAL_LONG(zworker_id, worker_id);\n\n    sw_zval_add_ref(&zobject);\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    args[0] = &zobject;\n    args[1] = &zworker_id;\n    if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onWorkerStop], &retval, 2, args, 0,\n            NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onWorkerStop handler error\");\n    }\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n    sw_zval_ptr_dtor(&zworker_id);\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n\n#if 1\n    shutdown_memory_manager(0, 1 TSRMLS_CC);\n#endif\n}\n\nstatic void php_swoole_onUserWorkerStart(swServer *serv, swWorker *worker)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    zval *object = worker->ptr;\n    zend_update_property_long(swoole_process_class_entry_ptr, object, ZEND_STRL(\"id\"), SwooleWG.id TSRMLS_CC);\n\n    php_swoole_process_start(worker, object TSRMLS_CC);\n}\n\nstatic void php_swoole_onWorkerError(swServer *serv, int worker_id, pid_t worker_pid, int exit_code, int signo)\n{\n    zval *zobject = (zval *) serv->ptr2;\n    zval *zworker_id, *zworker_pid, *zexit_code, *zsigno;\n    zval **args[5];\n    zval *retval = NULL;\n\n    SW_MAKE_STD_ZVAL(zworker_id);\n    ZVAL_LONG(zworker_id, worker_id);\n\n    SW_MAKE_STD_ZVAL(zworker_pid);\n    ZVAL_LONG(zworker_pid, worker_pid);\n\n    SW_MAKE_STD_ZVAL(zexit_code);\n    ZVAL_LONG(zexit_code, exit_code);\n\n    SW_MAKE_STD_ZVAL(zsigno);\n    ZVAL_LONG(zsigno, signo);\n\n    sw_zval_add_ref(&zobject);\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    args[0] = &zobject;\n    args[1] = &zworker_id;\n    args[2] = &zworker_pid;\n    args[3] = &zexit_code;\n    args[4] = &zsigno;\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onWorkerError], &retval, 5, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onWorkerError handler error\");\n    }\n\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n\n    sw_zval_ptr_dtor(&zworker_id);\n    sw_zval_ptr_dtor(&zworker_pid);\n    sw_zval_ptr_dtor(&zexit_code);\n    sw_zval_ptr_dtor(&zsigno);\n\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n}\n\nvoid php_swoole_onConnect(swServer *serv, swDataHead *info)\n{\n    zval *zserv = (zval *) serv->ptr2;\n    zval *zfd;\n    zval *zfrom_id;\n    zval **args[3];\n    zval *retval = NULL;\n\n    SW_MAKE_STD_ZVAL(zfd);\n    ZVAL_LONG(zfd, info->fd);\n\n    SW_MAKE_STD_ZVAL(zfrom_id);\n    ZVAL_LONG(zfrom_id, info->from_id);\n\n    args[0] = &zserv;\n    sw_zval_add_ref(&zserv);\n    args[1] = &zfd;\n    args[2] = &zfrom_id;\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    zval *callback = php_swoole_server_get_callback(serv, info->from_fd, SW_SERVER_CB_onConnect);\n    if (!callback)\n    {\n        return;\n    }\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, callback, &retval, 3, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_error(E_WARNING, \"swoole_server: onConnect handler error\");\n    }\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n\n    sw_zval_ptr_dtor(&zfd);\n    sw_zval_ptr_dtor(&zfrom_id);\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n}\n\nvoid php_swoole_onClose(swServer *serv, swDataHead *info)\n{\n    zval *zserv = (zval *) serv->ptr2;\n    zval *zfd;\n    zval *zfrom_id;\n    zval **args[3];\n    zval *retval = NULL;\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    SW_MAKE_STD_ZVAL(zfd);\n    ZVAL_LONG(zfd, info->fd);\n\n    SW_MAKE_STD_ZVAL(zfrom_id);\n    ZVAL_LONG(zfrom_id, info->from_id);\n\n    args[0] = &zserv;\n    sw_zval_add_ref(&zserv);\n    args[1] = &zfd;\n    args[2] = &zfrom_id;\n\n    zval *callback = php_swoole_server_get_callback(serv, info->from_fd, SW_SERVER_CB_onClose);\n    if (!callback)\n    {\n        return;\n    }\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, callback, &retval, 3, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"onClose handler error\");\n    }\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n\n    sw_zval_ptr_dtor(&zfd);\n    sw_zval_ptr_dtor(&zfrom_id);\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n}\n\nPHP_METHOD(swoole_server, __construct)\n{\n    zend_size_t host_len = 0;\n    char *serv_host;\n    long sock_type = SW_SOCK_TCP;\n    long serv_port;\n    long serv_mode = SW_MODE_PROCESS;\n\n    //only cli env\n    if (strcasecmp(\"cli\", sapi_module.name) != 0)\n    {\n        swoole_php_fatal_error(E_ERROR, \"swoole_server must run at php_cli environment.\");\n        RETURN_FALSE;\n    }\n\n    if (SwooleG.main_reactor != NULL)\n    {\n        swoole_php_fatal_error(E_ERROR, \"eventLoop has been created. Unable to create swoole_server.\");\n        RETURN_FALSE;\n    }\n\n    if (SwooleGS->start > 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"server is already running. Unable to create swoole_server.\");\n        RETURN_FALSE;\n    }\n\n    swServer *serv = sw_malloc(sizeof (swServer));\n    swServer_init(serv);\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"sl|ll\", &serv_host, &host_len, &serv_port, &serv_mode, &sock_type) == FAILURE)\n    {\n        swoole_php_fatal_error(E_ERROR, \"invalid parameters.\");\n        return;\n    }\n\n#ifdef __CYGWIN__\n    serv_mode = SW_MODE_SINGLE;\n#elif !defined(SW_USE_THREAD)\n    if (serv_mode == SW_MODE_THREAD || serv_mode == SW_MODE_BASE)\n    {\n        serv_mode = SW_MODE_SINGLE;\n        swoole_php_fatal_error(E_WARNING, \"PHP can not running at multi-threading. Reset mode to SWOOLE_MODE_BASE\");\n    }\n#endif\n    serv->factory_mode = serv_mode;\n\n    if (serv->factory_mode == SW_MODE_SINGLE)\n    {\n        serv->worker_num = 1;\n        serv->max_request = 0;\n    }\n\n    bzero(php_sw_server_callbacks, sizeof (zval*) * PHP_SERVER_CALLBACK_NUM);\n\n    swListenPort *port = swServer_add_port(serv, sock_type, serv_host, serv_port);\n    if (!port)\n    {\n        swoole_php_fatal_error(E_ERROR, \"listen server port failed.\");\n        return;\n    }\n\n    zval *server_object = getThis();\n\n#ifdef HAVE_PCRE\n    zval *connection_iterator_object;\n    SW_MAKE_STD_ZVAL(connection_iterator_object);\n    object_init_ex(connection_iterator_object, swoole_connection_iterator_class_entry_ptr);\n    zend_update_property(swoole_server_class_entry_ptr, server_object, ZEND_STRL(\"connections\"), connection_iterator_object TSRMLS_CC);\n#endif\n\n    zend_update_property_stringl(swoole_server_class_entry_ptr, server_object, ZEND_STRL(\"host\"), serv_host, host_len TSRMLS_CC);\n    zend_update_property_long(swoole_server_class_entry_ptr, server_object, ZEND_STRL(\"port\"), serv_port TSRMLS_CC);\n    zend_update_property_long(swoole_server_class_entry_ptr, server_object, ZEND_STRL(\"mode\"), serv->factory_mode TSRMLS_CC);\n    zend_update_property_long(swoole_server_class_entry_ptr, server_object, ZEND_STRL(\"type\"), sock_type TSRMLS_CC);\n    swoole_set_object(server_object, serv);\n\n    zval *ports;\n    SW_ALLOC_INIT_ZVAL(ports);\n    array_init(ports);\n    zend_update_property(swoole_server_class_entry_ptr, server_object, ZEND_STRL(\"ports\"), ports TSRMLS_CC);\n    server_port_list.zports = ports;\n\n    php_swoole_server_add_port(port TSRMLS_CC);\n}\n\nPHP_METHOD(swoole_server, set)\n{\n    zval *zset = NULL;\n    zval *zobject = getThis();\n    HashTable *vht;\n\n    zval *v;\n\n    if (SwooleGS->start > 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is running. Unable to execute swoole_server_set now.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z\", &zset) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n\n    vht = Z_ARRVAL_P(zset);\n    //chroot\n    if (php_swoole_array_get_value(vht, \"chroot\", v))\n    {\n        convert_to_string(v);\n        SwooleG.chroot = strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));\n    }\n    //user\n    if (php_swoole_array_get_value(vht, \"user\", v))\n    {\n        convert_to_string(v);\n        SwooleG.user = strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));\n    }\n    //group\n    if (php_swoole_array_get_value(vht, \"group\", v))\n    {\n        convert_to_string(v);\n        SwooleG.group = strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));\n    }\n    //daemonize\n    if (php_swoole_array_get_value(vht, \"daemonize\", v))\n    {\n        convert_to_boolean(v);\n        serv->daemonize = Z_BVAL_P(v);\n    }\n    //reactor thread num\n    if (php_swoole_array_get_value(vht, \"reactor_num\", v))\n    {\n        convert_to_long(v);\n        serv->reactor_num = (int) Z_LVAL_P(v);\n        if (serv->reactor_num <= 0)\n        {\n            serv->reactor_num = SwooleG.cpu_num;\n        }\n    }\n    //worker_num\n    if (php_swoole_array_get_value(vht, \"worker_num\", v))\n    {\n        convert_to_long(v);\n        serv->worker_num = (int) Z_LVAL_P(v);\n        if (serv->worker_num <= 0)\n        {\n            serv->worker_num = SwooleG.cpu_num;\n        }\n    }\n#ifdef SW_COROUTINE\n\tif (php_swoole_array_get_value(vht, \"max_coro_num\", v))\n\t{\n\t\tconvert_to_long(v);\n\t\tCOROG.max_coro_num = (int) Z_LVAL_P(v);\n\t\tif (COROG.max_coro_num <= 0)\n\t\t{\n\t\t\tCOROG.max_coro_num = DEFAULT_MAX_CORO_NUM;\n\t\t}\n\t}\n#endif\n    //dispatch_mode\n    if (php_swoole_array_get_value(vht, \"dispatch_mode\", v))\n    {\n        convert_to_long(v);\n        serv->dispatch_mode = (int) Z_LVAL_P(v);\n    }\n    //log_file\n    if (php_swoole_array_get_value(vht, \"log_file\", v))\n    {\n        convert_to_string(v);\n        SwooleG.log_file = strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));\n    }\n    //log_level\n    if (php_swoole_array_get_value(vht, \"log_level\", v))\n    {\n        convert_to_long(v);\n        SwooleG.log_level = (int) Z_LVAL_P(v);\n    }\n    /**\n     * for dispatch_mode = 1/3\n     */\n    if (php_swoole_array_get_value(vht, \"discard_timeout_request\", v))\n    {\n        convert_to_boolean(v);\n        serv->discard_timeout_request = Z_BVAL_P(v);\n    }\n    //onConnect/onClose event\n    if (php_swoole_array_get_value(vht, \"enable_unsafe_event\", v))\n    {\n        convert_to_boolean(v);\n        serv->enable_unsafe_event = Z_BVAL_P(v);\n    }\n    //port reuse\n    if (php_swoole_array_get_value(vht, \"enable_port_reuse\", v))\n    {\n        convert_to_boolean(v);\n        SwooleG.reuse_port = Z_BVAL_P(v);\n    }\n    //delay receive\n    if (php_swoole_array_get_value(vht, \"enable_delay_receive\", v))\n    {\n        convert_to_boolean(v);\n        serv->enable_delay_receive = Z_BVAL_P(v);\n    }\n    //task_worker_num\n    if (php_swoole_array_get_value(vht, \"task_worker_num\", v))\n    {\n        convert_to_long(v);\n        SwooleG.task_worker_num = (int) Z_LVAL_P(v);\n        task_callbacks = swHashMap_new(1024, NULL);\n    }\n    //task ipc mode, 1,2,3\n    if (php_swoole_array_get_value(vht, \"task_ipc_mode\", v))\n    {\n        convert_to_long(v);\n        SwooleG.task_ipc_mode = (int) Z_LVAL_P(v);\n    }\n    /**\n     * Temporary file directory for task_worker\n     */\n    if (php_swoole_array_get_value(vht, \"task_tmpdir\", v))\n    {\n        convert_to_string(v);\n        SwooleG.task_tmpdir = emalloc(SW_TASK_TMPDIR_SIZE);\n        SwooleG.task_tmpdir_len = snprintf(SwooleG.task_tmpdir, SW_TASK_TMPDIR_SIZE, \"%s/task.XXXXXX\", Z_STRVAL_P(v)) + 1;\n\n        if (SwooleG.task_tmpdir_len > SW_TASK_TMPDIR_SIZE - 1)\n        {\n            swoole_php_fatal_error(E_ERROR, \"task_tmpdir is too long, max size is %d.\", SW_TASK_TMPDIR_SIZE - 1);\n            return;\n        }\n    }\n    else\n    {\n        SwooleG.task_tmpdir = strndup(SW_TASK_TMP_FILE, sizeof (SW_TASK_TMP_FILE));\n        SwooleG.task_tmpdir_len = sizeof (SW_TASK_TMP_FILE);\n    }\n    //task_max_request\n    if (php_swoole_array_get_value(vht, \"task_max_request\", v))\n    {\n        convert_to_long(v);\n        SwooleG.task_max_request = (int) Z_LVAL_P(v);\n    }\n    //max_connection\n    if (php_swoole_array_get_value(vht, \"max_connection\", v) || php_swoole_array_get_value(vht, \"max_conn\", v))\n    {\n        convert_to_long(v);\n        serv->max_connection = (int) Z_LVAL_P(v);\n    }\n    //heartbeat_check_interval\n    if (php_swoole_array_get_value(vht, \"heartbeat_check_interval\", v))\n    {\n        convert_to_long(v);\n        serv->heartbeat_check_interval = (int) Z_LVAL_P(v);\n    }\n    //heartbeat idle time\n    if (php_swoole_array_get_value(vht, \"heartbeat_idle_time\", v))\n    {\n        convert_to_long(v);\n        serv->heartbeat_idle_time = (int) Z_LVAL_P(v);\n\n        if (serv->heartbeat_check_interval > serv->heartbeat_idle_time)\n        {\n            swoole_php_fatal_error(E_WARNING, \"heartbeat_idle_time must be greater than heartbeat_check_interval.\");\n            serv->heartbeat_check_interval = serv->heartbeat_idle_time / 2;\n        }\n    }\n    else if (serv->heartbeat_check_interval > 0)\n    {\n        serv->heartbeat_idle_time = serv->heartbeat_check_interval * 2;\n    }\n    //max_request\n    if (php_swoole_array_get_value(vht, \"max_request\", v))\n    {\n        convert_to_long(v);\n        serv->max_request = (int) Z_LVAL_P(v);\n    }\n    //cpu affinity\n    if (php_swoole_array_get_value(vht, \"open_cpu_affinity\", v))\n    {\n        convert_to_boolean(v);\n        serv->open_cpu_affinity = Z_BVAL_P(v);\n    }\n    //cpu affinity set\n    if (php_swoole_array_get_value(vht, \"cpu_affinity_ignore\", v))\n    {\n        int ignore_num = zend_hash_num_elements(Z_ARRVAL_P(v));\n        if (ignore_num >= SW_CPU_NUM) \n        {\n            swoole_php_fatal_error(E_ERROR, \"cpu_affinity_ignore num must be less than cpu num (%d)\", SW_CPU_NUM);\n            RETURN_FALSE;\n        }\n        int available_num = SW_CPU_NUM - ignore_num;\n        int *available_cpu = (int *) sw_malloc(sizeof(int) * available_num);\n        int flag, i, available_i = 0;\n\n        zval *zval_core = NULL;\n        for (i = 0; i < SW_CPU_NUM; i++)\n        {\n            flag = 1;\n            SW_HASHTABLE_FOREACH_START(Z_ARRVAL_P(v), zval_core)\n                int core = (int) Z_LVAL_P(zval_core);\n                if (i == core)\n                {\n                    flag = 0;\n                    break;\n                }\n            SW_HASHTABLE_FOREACH_END();\n            if (flag)\n            {\n                available_cpu[available_i] = i;\n                available_i++;\n            }\n        }\n        serv->cpu_affinity_available_num = available_num;\n        serv->cpu_affinity_available = available_cpu;\n    }\n    //paser x-www-form-urlencoded form data\n    if (php_swoole_array_get_value(vht, \"http_parse_post\", v))\n    {\n        convert_to_boolean(v);\n        serv->http_parse_post = Z_BVAL_P(v);\n    }\n    /**\n     * buffer input size\n     */\n    if (php_swoole_array_get_value(vht, \"buffer_input_size\", v))\n    {\n        convert_to_long(v);\n        serv->buffer_input_size = (int) Z_LVAL_P(v);\n    }\n    /**\n     * buffer output size\n     */\n    if (php_swoole_array_get_value(vht, \"buffer_output_size\", v))\n    {\n        convert_to_long(v);\n        serv->buffer_output_size = (int) Z_LVAL_P(v);\n    }\n    /**\n     * set pipe memory buffer size\n     */\n    if (php_swoole_array_get_value(vht, \"pipe_buffer_size\", v))\n    {\n        convert_to_long(v);\n        serv->pipe_buffer_size = (int) Z_LVAL_P(v);\n    }\n    //message queue key\n    if (php_swoole_array_get_value(vht, \"message_queue_key\", v))\n    {\n        convert_to_long(v);\n        serv->message_queue_key = (int) Z_LVAL_P(v);\n    }\n\n    zval *retval = NULL;\n    zval *port_object = server_port_list.zobjects[0];\n\n    sw_zval_add_ref(&port_object);\n    sw_zval_add_ref(&zset);\n    sw_zval_add_ref(&zobject);\n\n    sw_zend_call_method_with_1_params(&port_object, swoole_server_port_class_entry_ptr, NULL, \"set\", &retval, zset);\n    zend_update_property(swoole_server_class_entry_ptr, zobject, ZEND_STRL(\"setting\"), zset TSRMLS_CC);\n\n    RETURN_TRUE;\n}\n\nPHP_METHOD(swoole_server, on)\n{\n    zval *name;\n    zval *cb;\n\n    if (SwooleGS->start > 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is running. Unable to set event callback now.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, \"zz\", &name, &cb) == FAILURE)\n    {\n        return;\n    }\n\n#ifdef PHP_SWOOLE_CHECK_CALLBACK\n    char *func_name = NULL;\n#ifdef SW_COROUTINE\n    zend_fcall_info_cache *func_cache = emalloc(sizeof(zend_fcall_info_cache));\n    if (!sw_zend_is_callable_ex(cb, NULL, 0, &func_name, NULL, func_cache, NULL TSRMLS_CC))\n#else\n    if (!sw_zend_is_callable(cb, 0, &func_name TSRMLS_CC))\n#endif\n    {\n        swoole_php_fatal_error(E_ERROR, \"Function '%s' is not callable\", func_name);\n        efree(func_name);\n        return;\n    }\n    efree(func_name);\n#endif\n\n    convert_to_string(name);\n\n    char *callback_name[PHP_SERVER_CALLBACK_NUM] = {\n        \"Connect\",\n        \"Receive\",\n        \"Close\",\n        \"Packet\",\n        \"Start\",\n        \"Shutdown\",\n        \"WorkerStart\",\n        \"WorkerStop\",\n        \"Task\",\n        \"Finish\",\n        \"WorkerError\",\n        \"ManagerStart\",\n        \"ManagerStop\",\n        \"PipeMessage\",\n        NULL,\n        NULL,\n        NULL,\n        NULL,\n    };\n\n    int i;\n    char property_name[128];\n    int l_property_name = 0;\n    memcpy(property_name, \"on\", 2);\n\n    for (i = 0; i < PHP_SERVER_CALLBACK_NUM; i++)\n    {\n        if (callback_name[i] == NULL)\n        {\n            continue;\n        }\n        if (strncasecmp(callback_name[i], Z_STRVAL_P(name), Z_STRLEN_P(name)) == 0)\n        {\n            memcpy(property_name + 2, callback_name[i], Z_STRLEN_P(name));\n            l_property_name = Z_STRLEN_P(name) + 2;\n            property_name[l_property_name] = '\\0';\n            zend_update_property(swoole_server_class_entry_ptr, getThis(), property_name, l_property_name, cb TSRMLS_CC);\n            php_sw_server_callbacks[i] = sw_zend_read_property(swoole_server_class_entry_ptr, getThis(), property_name, l_property_name, 0 TSRMLS_CC);\n            sw_copy_to_stack(php_sw_server_callbacks[i], _php_sw_server_callbacks[i]);\n\n#ifdef SW_COROUTINE\n            php_sw_server_caches[i] = func_cache;\n#endif\n            break;\n        }\n    }\n\n    if (l_property_name == 0)\n    {\n        swoole_php_error(E_WARNING, \"Unknown event types[%s]\", Z_STRVAL_P(name));\n        RETURN_FALSE;\n    }\n\n    if (i < SW_SERVER_CB_onStart)\n    {\n        zval *port_object = server_port_list.zobjects[0];\n        zval *retval = NULL;\n        sw_zval_add_ref(&port_object);\n        sw_zend_call_method_with_2_params(&port_object, swoole_server_port_class_entry_ptr, NULL, \"on\", &retval, name, cb);\n    }\n    else\n    {\n        RETURN_TRUE;\n    }\n}\n\nPHP_METHOD(swoole_server, listen)\n{\n    char *host;\n    zend_size_t host_len;\n    long sock_type;\n    long port;\n\n    if (SwooleGS->start > 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is running. cannot add listener.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"sll\", &host, &host_len, &port, &sock_type) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(getThis());\n    swListenPort *ls = swServer_add_port(serv, (int) sock_type, host, (int) port);\n    if (!ls)\n    {\n        RETURN_FALSE;\n    }\n\n    zval *port_object = php_swoole_server_add_port(ls TSRMLS_CC);\n    RETURN_ZVAL(port_object, 1, NULL);\n}\n\nPHP_METHOD(swoole_server, addProcess)\n{\n    if (SwooleGS->start > 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is running. cannot add process.\");\n        RETURN_FALSE;\n    }\n\n    zval *process = NULL;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z\", &process) == FAILURE)\n    {\n        return;\n    }\n\n    if (ZVAL_IS_NULL(process))\n    {\n        swoole_php_fatal_error(E_WARNING, \"parameter 1 cannot be empty.\");\n        RETURN_FALSE;\n    }\n\n    swServer *serv = swoole_get_object(getThis());\n    if (!instanceof_function(Z_OBJCE_P(process), swoole_process_class_entry_ptr TSRMLS_CC))\n    {\n        swoole_php_fatal_error(E_ERROR, \"object is not instanceof swoole_process.\");\n        RETURN_FALSE;\n    }\n\n    if (serv->onUserWorkerStart == NULL)\n    {\n        serv->onUserWorkerStart = php_swoole_onUserWorkerStart;\n    }\n\n#if PHP_MAJOR_VERSION >= 7\n    zval *tmp_process = emalloc(sizeof(zval));\n    memcpy(tmp_process, process, sizeof(zval));\n    process = tmp_process;\n#endif\n\n    sw_zval_add_ref(&process);\n\n    swWorker *worker = swoole_get_object(process);\n    worker->ptr = process;\n\n    int id = swServer_add_worker(serv, worker);\n    if (id < 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swServer_add_worker failed.\");\n        RETURN_FALSE;\n    }\n    zend_update_property_long(swoole_process_class_entry_ptr, getThis(), ZEND_STRL(\"id\"), id TSRMLS_CC);\n    RETURN_LONG(id);\n}\n\nPHP_METHOD(swoole_server, start)\n{\n    zval *zobject = getThis();\n    int ret;\n\n    if (SwooleGS->start > 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is running. Unable to execute swoole_server::start.\");\n        RETURN_FALSE;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n    php_swoole_register_callback(serv);\n\n    if (php_sw_server_callbacks[SW_SERVER_CB_onReceive] == NULL && php_sw_server_callbacks[SW_SERVER_CB_onPacket] == NULL)\n    {\n        swoole_php_fatal_error(E_ERROR, \"require onReceive/onPacket callback\");\n        RETURN_FALSE;\n    }\n    //-------------------------------------------------------------\n    serv->onReceive = php_swoole_onReceive;\n    serv->ptr2 = zobject;\n\n    php_swoole_server_before_start(serv, zobject TSRMLS_CC);\n\n    ret = swServer_start(serv);\n    if (ret < 0)\n    {\n        swoole_php_fatal_error(E_ERROR, \"start server failed. Error: %s\", sw_error);\n        RETURN_LONG(ret);\n    }\n    RETURN_TRUE;\n}\n\nPHP_METHOD(swoole_server, send)\n{\n    zval *zobject = getThis();\n\n    int ret;\n\n    zval *zfd;\n    zval *zdata;\n    long server_socket = -1;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"zz|l\", &zfd, &zdata, &server_socket) == FAILURE)\n    {\n        return;\n    }\n\n    char *data;\n    int length = php_swoole_get_send_data(zdata, &data TSRMLS_CC);\n\n    if (length < 0)\n    {\n        RETURN_FALSE;\n    }\n    else if (length == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"data is empty.\");\n        RETURN_FALSE;\n    }\n\n   swServer *serv = swoole_get_object(zobject);\n\n    if (serv->have_udp_sock && SW_Z_TYPE_P(zfd) == IS_STRING)\n    {\n        if (server_socket == -1)\n        {\n            server_socket = dgram_server_socket;\n        }\n        //UDP IPv6\n        if (strchr(Z_STRVAL_P(zfd), ':'))\n        {\n            php_swoole_udp_t udp_info;\n            memcpy(&udp_info, &server_socket, sizeof(udp_info));\n            ret = swSocket_udp_sendto6(udp_info.from_fd, Z_STRVAL_P(zfd), udp_info.port, data, length);\n        }\n        //UNIX DGRAM\n        else if (Z_STRVAL_P(zfd)[0] == '/')\n        {\n            struct sockaddr_un addr_un;\n            memcpy(addr_un.sun_path, Z_STRVAL_P(zfd), Z_STRLEN_P(zfd));\n            addr_un.sun_family = AF_UNIX;\n            addr_un.sun_path[Z_STRLEN_P(zfd)] = 0;\n            ret = swSocket_sendto_blocking(server_socket, data, length, 0, (struct sockaddr *) &addr_un, sizeof(addr_un));\n        }\n        else\n        {\n            goto convert;\n        }\n        SW_CHECK_RETURN(ret);\n    }\n\n    convert: convert_to_long(zfd);\n    uint32_t fd = (uint32_t) Z_LVAL_P(zfd);\n    //UDP\n    if (swServer_is_udp(fd))\n    {\n        if (server_socket == -1)\n        {\n            server_socket = udp_server_socket;\n        }\n\n        php_swoole_udp_t udp_info;\n        memcpy(&udp_info, &server_socket, sizeof(udp_info));\n\n        struct sockaddr_in addr_in;\n        addr_in.sin_family = AF_INET;\n        addr_in.sin_port = htons(udp_info.port);\n        addr_in.sin_addr.s_addr = fd;\n        ret = swSocket_sendto_blocking(udp_info.from_fd, data, length, 0, (struct sockaddr *) &addr_in, sizeof(addr_in));\n        SW_CHECK_RETURN(ret);\n    }\n    //TCP\n    else\n    {\n        SW_CHECK_RETURN(swServer_tcp_send(serv, fd, data, length));\n    }\n}\n\nPHP_METHOD(swoole_server, sendto)\n{\n    zval *zobject = getThis();\n\n    char *ip;\n    char *data;\n    zend_size_t len, ip_len;\n\n    long port;\n    long server_socket = -1;\n    zend_bool ipv6 = 0;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"sls|l\", &ip, &ip_len, &port, &data, &len, &server_socket) == FAILURE)\n    {\n        return;\n    }\n\n    if (len <= 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"data is empty.\");\n        RETURN_FALSE;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n\n    if (strchr(ip, ':'))\n    {\n        ipv6 = 1;\n    }\n\n    if (ipv6 == 0 && serv->udp_socket_ipv4 <= 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"You must add an UDP listener to server before using sendto.\");\n        RETURN_FALSE;\n    }\n    else if (ipv6 == 1 && serv->udp_socket_ipv6 <= 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"You must add an UDP6 listener to server before using sendto.\");\n        RETURN_FALSE;\n    }\n\n    if (server_socket < 0)\n    {\n        server_socket = ipv6 ?  serv->udp_socket_ipv6 : serv->udp_socket_ipv4;\n    }\n\n    int ret;\n    if (ipv6)\n    {\n        ret = swSocket_udp_sendto6(server_socket, ip, port, data, len);\n    }\n    else\n    {\n        ret = swSocket_udp_sendto(server_socket, ip, port, data, len);\n    }\n    SW_CHECK_RETURN(ret);\n}\n\nPHP_METHOD(swoole_server, sendfile)\n{\n    zval *zobject = getThis();\n    zend_size_t len;\n\n    char *filename;\n    long fd;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ls\", &fd, &filename, &len) == FAILURE)\n    {\n        return;\n    }\n\n    //check fd\n    if (fd <= 0 || fd > SW_MAX_SOCKET_ID)\n    {\n        swoole_error_log(SW_LOG_WARNING, SW_ERROR_SESSION_INVALID_ID, \"invalid fd[%ld].\", fd);\n        RETURN_FALSE;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n    SW_CHECK_RETURN(swServer_tcp_sendfile(serv, (int) fd, filename, len));\n}\n\nPHP_METHOD(swoole_server, close)\n{\n    zval *zobject = getThis();\n    zend_bool reset = SW_FALSE;\n    long fd;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (swIsMaster())\n    {\n        swoole_php_fatal_error(E_WARNING, \"Cannot close connection in master process.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l|b\", &fd, &reset) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n    swConnection *conn = swServer_connection_verify_no_ssl(serv, fd);\n    if (!conn)\n    {\n        RETURN_FALSE;\n    }\n\n    //Reset send buffer, Immediately close the connection.\n    if (reset)\n    {\n        conn->close_reset = 1;\n    }\n\n    int ret;\n    if (!swIsWorker())\n    {\n        swWorker *worker = swServer_get_worker(serv, conn->fd % serv->worker_num);\n        swDataHead ev;\n        ev.type = SW_EVENT_CLOSE;\n        ev.fd = fd;\n        ev.from_id = conn->from_id;\n        ret = swWorker_send2worker(worker, &ev, sizeof(ev), SW_PIPE_MASTER);\n    }\n    else\n    {\n        ret = serv->factory.end(&serv->factory, fd);\n    }\n    SW_CHECK_RETURN(ret);\n}\n\nPHP_METHOD(swoole_server, confirm)\n{\n    zval *zobject = getThis();\n    long fd;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (swIsMaster())\n    {\n        swoole_php_fatal_error(E_WARNING, \"Cannot confirm connection in master process.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &fd) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n    SW_CHECK_RETURN(swServer_confirm(serv, fd));\n}\n\nPHP_METHOD(swoole_server, stats)\n{\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    array_init(return_value);\n    sw_add_assoc_long_ex(return_value, ZEND_STRS(\"start_time\"), SwooleStats->start_time);\n    sw_add_assoc_long_ex(return_value, ZEND_STRS(\"connection_num\"), SwooleStats->connection_num);\n    sw_add_assoc_long_ex(return_value, ZEND_STRS(\"accept_count\"), SwooleStats->accept_count);\n    sw_add_assoc_long_ex(return_value, ZEND_STRS(\"close_count\"), SwooleStats->close_count);\n    sw_add_assoc_long_ex(return_value, ZEND_STRS(\"tasking_num\"), SwooleStats->tasking_num);\n    sw_add_assoc_long_ex(return_value, ZEND_STRS(\"request_count\"), SwooleStats->request_count);\n    sw_add_assoc_long_ex(return_value, ZEND_STRS(\"worker_request_count\"), SwooleWG.request_count);\n\n    if (SwooleG.task_ipc_mode > SW_IPC_UNSOCK && SwooleGS->task_workers.queue)\n    {\n        int queue_num = -1;\n        int queue_bytes = -1;\n        if (swMsgQueue_stat(SwooleGS->task_workers.queue, &queue_num, &queue_bytes) == 0)\n        {\n            sw_add_assoc_long_ex(return_value, ZEND_STRS(\"task_queue_num\"), queue_num);\n            sw_add_assoc_long_ex(return_value, ZEND_STRS(\"task_queue_bytes\"), queue_bytes);\n        }\n    }\n}\n\nPHP_METHOD(swoole_server, reload)\n{\n    zend_bool only_reload_taskworker = 0;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|b\", &only_reload_taskworker) == FAILURE)\n    {\n        return;\n    }\n\n    int sig = only_reload_taskworker ? SIGUSR2 : SIGUSR1;\n    if (kill(SwooleGS->manager_pid, sig) < 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"kill() failed. Error: %s[%d]\", strerror(errno), errno);\n        RETURN_FALSE;\n    }\n    RETURN_TRUE;\n}\n\nPHP_METHOD(swoole_server, heartbeat)\n{\n    zval *zobject = getThis();\n\n    zend_bool close_connection = 0;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|b\", &close_connection) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n\n    if (serv->heartbeat_idle_time < 1)\n    {\n        RETURN_FALSE;\n    }\n\n    int serv_max_fd = swServer_get_maxfd(serv);\n    int serv_min_fd = swServer_get_minfd(serv);\n\n    array_init(return_value);\n\n    int fd;\n    int checktime = (int) SwooleGS->now - serv->heartbeat_idle_time;\n    swConnection *conn;\n\n    for (fd = serv_min_fd; fd <= serv_max_fd; fd++)\n    {\n        swTrace(\"heartbeat check fd=%d\", fd);\n        conn = &serv->connection_list[fd];\n\n        if (1 == conn->active && conn->last_time < checktime)\n        {\n            conn->close_force = 1;\n            /**\n             * Close the connection\n             */\n            if (close_connection)\n            {\n                serv->factory.end(&serv->factory, fd);\n            }\n#ifdef SW_REACTOR_USE_SESSION\n            add_next_index_long(return_value, conn->session_id);\n#else\n            add_next_index_long(return_value, fd);\n#endif\n        }\n    }\n}\n\nPHP_METHOD(swoole_server, taskwait)\n{\n    swEventData buf;\n    zval *data;\n\n    double timeout = SW_TASKWAIT_TIMEOUT;\n    long dst_worker_id = -1;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z|dl\", &data, &timeout, &dst_worker_id) == FAILURE)\n    {\n        return;\n    }\n\n    if (php_swoole_check_task_param(dst_worker_id TSRMLS_CC) < 0)\n    {\n        RETURN_FALSE;\n    }\n\n    php_swoole_task_pack(&buf, data TSRMLS_CC);\n\n    uint64_t notify;\n    swEventData *task_result = &(SwooleG.task_result[SwooleWG.id]);\n    bzero(task_result, sizeof(swEventData));\n    swPipe *task_notify_pipe = &SwooleG.task_notify[SwooleWG.id];\n    int efd = task_notify_pipe->getFd(task_notify_pipe, 0);\n\n    //clear history task\n    while (read(efd, &notify, sizeof(notify)) > 0);\n\n    if (swProcessPool_dispatch_blocking(&SwooleGS->task_workers, &buf, (int*) &dst_worker_id) >= 0)\n    {\n        sw_atomic_fetch_add(&SwooleStats->tasking_num, 1);\n        task_notify_pipe->timeout = timeout;\n        int ret = task_notify_pipe->read(task_notify_pipe, &notify, sizeof(notify));\n        if (ret > 0)\n        {\n            zval *task_notify_data = php_swoole_get_task_result(task_result TSRMLS_CC);\n            RETURN_ZVAL(task_notify_data, 0, 0);\n        }\n        else\n        {\n            swoole_php_fatal_error(E_WARNING, \"taskwait failed. Error: %s[%d]\", strerror(errno), errno);\n        }\n    }\n    RETURN_FALSE;\n}\n\nPHP_METHOD(swoole_server, taskWaitMulti)\n{\n    swEventData buf;\n    zval *tasks;\n    zval *task;\n    double timeout = SW_TASKWAIT_TIMEOUT;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z|d\", &tasks, &timeout) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(getThis());\n    array_init(return_value);\n\n    int dst_worker_id;\n    int task_id;\n    int i = 0;\n    int n_task = Z_ARRVAL_P(tasks)->nNumOfElements;\n\n    int list_of_id[1024];\n\n    uint64_t notify;\n    swEventData *task_result = &(SwooleG.task_result[SwooleWG.id]);\n    bzero(task_result, sizeof(swEventData));\n    swPipe *task_notify_pipe = &SwooleG.task_notify[SwooleWG.id];\n    swWorker *worker = swServer_get_worker(serv, SwooleWG.id);\n\n    char _tmpfile[sizeof(SW_TASK_TMP_FILE)] = SW_TASK_TMP_FILE;\n    int _tmpfile_fd = swoole_tmpfile(_tmpfile);\n    if (_tmpfile_fd < 0)\n    {\n        swoole_php_sys_error(E_WARNING, \"mktemp(%s) failed.\", SW_TASK_TMP_FILE);\n        RETURN_FALSE;\n    }\n    close(_tmpfile_fd);\n    int *finish_count = (int *) task_result->data;\n\n    worker->lock.lock(&worker->lock);\n    *finish_count = 0;\n    memcpy(task_result->data + 4, _tmpfile, sizeof(_tmpfile));\n    worker->lock.unlock(&worker->lock);\n\n    //clear history task\n    int efd = task_notify_pipe->getFd(task_notify_pipe, 0);\n    while (read(efd, &notify, sizeof(notify)) > 0);\n\n    SW_HASHTABLE_FOREACH_START(Z_ARRVAL_P(tasks), task)\n        task_id = php_swoole_task_pack(&buf, task TSRMLS_CC);\n        if (task_id < 0)\n        {\n            swoole_php_fatal_error(E_WARNING, \"task pack failed.\");\n            goto fail;\n        }\n        swTask_type(&buf) |= SW_TASK_WAITALL;\n        dst_worker_id = -1;\n        if (swProcessPool_dispatch_blocking(&SwooleGS->task_workers, &buf, (int*) &dst_worker_id) >= 0)\n        {\n            sw_atomic_fetch_add(&SwooleStats->tasking_num, 1);\n            list_of_id[i] = task_id;\n        }\n        else\n        {\n            swoole_php_fatal_error(E_WARNING, \"taskwait failed. Error: %s[%d]\", strerror(errno), errno);\n            fail:\n            add_index_bool(return_value, i, 0);\n            n_task --;\n        }\n        i++;\n    SW_HASHTABLE_FOREACH_END();\n\n    while (n_task > 0)\n    {\n        task_notify_pipe->timeout = timeout;\n        int ret = task_notify_pipe->read(task_notify_pipe, &notify, sizeof(notify));\n        if (ret > 0)\n        {\n            if (*finish_count == n_task)\n            {\n                break;\n            }\n        }\n        else\n        {\n            swoole_php_fatal_error(E_WARNING, \"taskwait failed. Error: %s[%d]\", strerror(errno), errno);\n            unlink(_tmpfile);\n            RETURN_FALSE;\n        }\n    }\n\n    swString *content = swoole_file_get_contents(_tmpfile);\n    if (content == NULL)\n    {\n        return;\n    }\n\n    swEventData *result;\n    zval *zdata;\n    int j;\n\n    for (i = 0; i < n_task; i++)\n    {\n        result = (swEventData *) (content->str + content->offset);\n        task_id = result->info.fd;\n        zdata = php_swoole_get_task_result(result TSRMLS_CC);\n        for (j = 0; j < n_task; j++)\n        {\n            if (list_of_id[j] == task_id)\n            {\n                break;\n            }\n        }\n        add_index_zval(return_value, j, zdata);\n        content->offset += sizeof(swDataHead) + result->info.len;\n    }\n    unlink(_tmpfile);\n}\n\nPHP_METHOD(swoole_server, task)\n{\n    swEventData buf;\n    zval *data;\n    zval *callback = NULL;\n\n    long dst_worker_id = -1;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z|lz\", &data, &dst_worker_id, &callback) == FAILURE)\n    {\n        return;\n    }\n\n    if (php_swoole_check_task_param(dst_worker_id TSRMLS_CC) < 0)\n    {\n        RETURN_FALSE;\n    }\n\n    if (php_swoole_task_pack(&buf, data TSRMLS_CC) < 0)\n    {\n        RETURN_FALSE;\n    }\n\n    if (callback && !ZVAL_IS_NULL(callback))\n    {\n#ifdef PHP_SWOOLE_CHECK_CALLBACK\n        char *func_name = NULL;\n        if (!sw_zend_is_callable(callback, 0, &func_name TSRMLS_CC))\n        {\n            swoole_php_fatal_error(E_WARNING, \"Function '%s' is not callable\", func_name);\n            efree(func_name);\n            return;\n        }\n        efree(func_name);\n#endif\n        swTask_type(&buf) |= SW_TASK_CALLBACK;\n        sw_zval_add_ref(&callback);\n        swHashMap_add_int(task_callbacks, buf.info.fd, sw_zval_dup(callback));\n    }\n\n    swTask_type(&buf) |= SW_TASK_NONBLOCK;\n    if (swProcessPool_dispatch(&SwooleGS->task_workers, &buf, (int*) &dst_worker_id) >= 0)\n    {\n        sw_atomic_fetch_add(&SwooleStats->tasking_num, 1);\n        RETURN_LONG(buf.info.fd);\n    }\n    else\n    {\n        RETURN_FALSE;\n    }\n}\n\nPHP_METHOD(swoole_server, sendMessage)\n{\n    zval *zobject = getThis();\n    swEventData buf;\n\n    char *msg;\n    zend_size_t msglen;\n    long worker_id = -1;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"sl\", &msg, &msglen, &worker_id) == FAILURE)\n    {\n        return;\n    }\n\n    if (worker_id == SwooleWG.id)\n    {\n        swoole_php_fatal_error(E_WARNING, \"cannot send message to self.\");\n        RETURN_FALSE;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n    if (worker_id >= serv->worker_num + SwooleG.task_worker_num)\n    {\n        swoole_php_fatal_error(E_WARNING, \"worker_id[%d] is invalid.\", (int) worker_id);\n        RETURN_FALSE;\n    }\n\n    if (!serv->onPipeMessage)\n    {\n        swoole_php_fatal_error(E_WARNING, \"onPipeMessage is null, cannot use sendMessage.\");\n        RETURN_FALSE;\n    }\n\n    buf.info.type = SW_EVENT_PIPE_MESSAGE;\n    buf.info.from_id = SwooleWG.id;\n\n    //write to file\n    if (msglen >= SW_IPC_MAX_SIZE - sizeof(buf.info))\n    {\n        if (swTaskWorker_large_pack(&buf, msg, msglen) < 0)\n        {\n            swoole_php_fatal_error(E_WARNING, \"large task pack failed()\");\n            RETURN_FALSE;\n        }\n    }\n    else\n    {\n        memcpy(buf.data, msg, msglen);\n        buf.info.len = msglen;\n        buf.info.from_fd = 0;\n    }\n\n    swWorker *to_worker = swServer_get_worker(serv, worker_id);\n    SW_CHECK_RETURN(swWorker_send2worker(to_worker, &buf, sizeof(buf.info) + buf.info.len, SW_PIPE_MASTER | SW_PIPE_NONBLOCK));\n}\n\nPHP_METHOD(swoole_server, finish)\n{\n    zval *zobject = getThis();\n    zval *data;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z\", &data) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n    SW_CHECK_RETURN(php_swoole_task_finish(serv, data TSRMLS_CC));\n}\n\nPHP_METHOD(swoole_server, bind)\n{\n    zval *zobject = getThis();\n\n    long fd = 0;\n    long uid = 0;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ll\", &fd, &uid) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n\n    swConnection *conn = swWorker_get_connection(serv, fd);\n\n    //udp client\n    if (conn == NULL)\n    {\n        swTrace(\"%ld conn error\", fd);\n        RETURN_FALSE;\n    }\n\n    //connection is closed\n    if (conn->active == 0)\n    {\n        swTrace(\"fd:%ld a:%d, uid: %ld\", fd, conn->active, conn->uid);\n        RETURN_FALSE;\n    }\n\n    if (conn->uid != 0)\n    {\n        RETURN_FALSE;\n    }\n\n    int ret = 0;\n    SwooleGS->lock.lock(&SwooleGS->lock);\n    if (conn->uid == 0)\n    {\n        conn->uid = uid;\n        ret = 1;\n    }\n    SwooleGS->lock.unlock(&SwooleGS->lock);\n    SW_CHECK_RETURN(ret);\n}\n\n#ifdef SWOOLE_SOCKETS_SUPPORT\nPHP_METHOD(swoole_server, getSocket)\n{\n    long port = 0;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|l\", &port) == FAILURE)\n    {\n        return;\n    }\n\n    zval *zobject = getThis();\n    swServer *serv = swoole_get_object(zobject);\n\n    int sock = swServer_get_socket(serv, port);\n    php_socket *socket_object = swoole_convert_to_socket(sock);\n\n    if (!socket_object)\n    {\n        RETURN_FALSE;\n    }\n    SW_ZEND_REGISTER_RESOURCE(return_value, (void *) socket_object, php_sockets_le_socket());\n}\n#endif\n\nPHP_METHOD(swoole_server, connection_info)\n{\n    zval *zobject = getThis();\n\n    zend_bool noCheckConnection = 0;\n    zval *zfd;\n    long from_id = -1;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z|lb\", &zfd, &from_id, &noCheckConnection) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n\n    long fd = 0;\n    zend_bool ipv6_udp = 0;\n\n    //ipv6 udp\n    if (SW_Z_TYPE_P(zfd) == IS_STRING)\n    {\n        if (is_numeric_string(Z_STRVAL_P(zfd), Z_STRLEN_P(zfd), &fd, NULL, 0))\n        {\n            ipv6_udp = 0;\n        }\n        else\n        {\n            fd = 0;\n            ipv6_udp = 1;\n        }\n    }\n    else\n    {\n        convert_to_long(zfd);\n        fd = Z_LVAL_P(zfd);\n    }\n\n    //udp\n    if (ipv6_udp || swServer_is_udp(fd))\n    {\n        array_init(return_value);\n\n        if (ipv6_udp)\n        {\n            add_assoc_zval(return_value, \"remote_ip\", zfd);\n        }\n        else\n        {\n            struct in_addr sin_addr;\n            sin_addr.s_addr = fd;\n            sw_add_assoc_string(return_value, \"remote_ip\", inet_ntoa(sin_addr), 1);\n        }\n\n        if (from_id == 0)\n        {\n            return;\n        }\n\n        php_swoole_udp_t udp_info;\n        memcpy(&udp_info, &from_id, sizeof(udp_info));\n        //server socket\n        swConnection *from_sock = swServer_connection_get(serv, udp_info.from_fd);\n        if (from_sock)\n        {\n            add_assoc_long(return_value, \"server_fd\", from_sock->fd);\n            add_assoc_long(return_value, \"socket_type\", from_sock->socket_type);\n            add_assoc_long(return_value, \"server_port\", swConnection_get_port(from_sock));\n        }\n        add_assoc_long(return_value, \"remote_port\", udp_info.port);\n        return;\n    }\n\n    swConnection *conn = swServer_connection_verify(serv, fd);\n    if (!conn)\n    {\n        RETURN_FALSE;\n    }\n    //connection is closed\n    if (conn->active == 0 && !noCheckConnection)\n    {\n        RETURN_FALSE;\n    }\n    else\n    {\n        array_init(return_value);\n\n        if (serv->dispatch_mode == SW_DISPATCH_UIDMOD)\n        {\n            add_assoc_long(return_value, \"uid\", conn->uid);\n        }\n\n        swListenPort *port = swServer_get_port(serv, conn->fd);\n        if (port && port->open_websocket_protocol)\n        {\n            add_assoc_long(return_value, \"websocket_status\", conn->websocket_status);\n        }\n\n#ifdef SW_USE_OPENSSL\n        if (conn->ssl_client_cert.length > 0)\n        {\n            sw_add_assoc_stringl(return_value, \"ssl_client_cert\", conn->ssl_client_cert.str, conn->ssl_client_cert.length - 1, 1);\n        }\n#endif\n        //server socket\n        swConnection *from_sock = swServer_connection_get(serv, conn->from_fd);\n        if (from_sock)\n        {\n            add_assoc_long(return_value, \"server_port\", swConnection_get_port(from_sock));\n        }\n        add_assoc_long(return_value, \"server_fd\", conn->from_fd);\n        add_assoc_long(return_value, \"socket_type\", conn->socket_type);\n        add_assoc_long(return_value, \"remote_port\", swConnection_get_port(conn));\n        sw_add_assoc_string(return_value, \"remote_ip\", swConnection_get_ip(conn), 1);\n        add_assoc_long(return_value, \"from_id\", conn->from_id);\n        add_assoc_long(return_value, \"connect_time\", conn->connect_time);\n        add_assoc_long(return_value, \"last_time\", conn->last_time);\n        add_assoc_long(return_value, \"close_errno\", conn->close_errno);\n    }\n}\n\nPHP_METHOD(swoole_server, connection_list)\n{\n    zval *zobject = getThis();\n\n    long start_fd = 0;\n    long find_count = 10;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|ll\", &start_fd, &find_count) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n\n    //\u8d85\u8fc7\u6700\u5927\u67e5\u627e\u6570\u91cf\n    if (find_count > SW_MAX_FIND_COUNT)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_connection_list max_find_count=%d\", SW_MAX_FIND_COUNT);\n        RETURN_FALSE;\n    }\n\n    //\u590d\u5236\u51fa\u6765\u907f\u514d\u88ab\u5176\u4ed6\u8fdb\u7a0b\u6539\u5199\n    int serv_max_fd = swServer_get_maxfd(serv);\n\n    if (start_fd == 0)\n    {\n        start_fd = swServer_get_minfd(serv);\n    }\n#ifdef SW_REACTOR_USE_SESSION\n    else\n    {\n        swConnection *conn = swWorker_get_connection(serv, start_fd);\n        if (!conn)\n        {\n            RETURN_FALSE;\n        }\n        start_fd = conn->fd;\n    }\n#endif\n\n    //\u8fbe\u5230\u6700\u5927\uff0c\u8868\u793a\u5df2\u7ecf\u53d6\u5b8c\u4e86\n    if ((int) start_fd >= serv_max_fd)\n    {\n        RETURN_FALSE;\n    }\n\n    array_init(return_value);\n    int fd = start_fd + 1;\n    swConnection *conn;\n\n    for (; fd <= serv_max_fd; fd++)\n    {\n        swTrace(\"maxfd=%d, fd=%d, find_count=%ld, start_fd=%ld\", serv_max_fd, fd, find_count, start_fd);\n        conn = &serv->connection_list[fd];\n\n        if (conn->active && !conn->closed)\n        {\n#ifdef SW_REACTOR_USE_SESSION\n            add_next_index_long(return_value, conn->session_id);\n#else\n            add_next_index_long(return_value, fd);\n#endif\n            find_count--;\n        }\n        //finish fetch\n        if (find_count <= 0)\n        {\n            break;\n        }\n    }\n}\n\nPHP_METHOD(swoole_server, sendwait)\n{\n    zval *zobject = getThis();\n\n    long fd;\n    zval *zdata;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"lz\", &fd, &zdata) == FAILURE)\n    {\n        return;\n    }\n\n    char *data;\n    int length = php_swoole_get_send_data(zdata, &data TSRMLS_CC);\n\n    if (length < 0)\n    {\n        RETURN_FALSE;\n    }\n    else if (length == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"data is empty.\");\n        RETURN_FALSE;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n\n    if (serv->factory_mode != SW_MODE_SINGLE || swIsTaskWorker())\n    {\n        swoole_php_fatal_error(E_WARNING, \"cannot sendwait.\");\n        RETURN_FALSE;\n    }\n\n    //UDP\n    if (swServer_is_udp(fd))\n    {\n        swoole_php_fatal_error(E_WARNING, \"cannot sendwait.\");\n        RETURN_FALSE;\n    }\n    //TCP\n    else\n    {\n        SW_CHECK_RETURN(swServer_tcp_sendwait(serv, fd, data, length));\n    }\n}\n\nPHP_METHOD(swoole_server, exist)\n{\n    zval *zobject = getThis();\n\n    long fd;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &fd) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n\n    swConnection *conn = swWorker_get_connection(serv, fd);\n    if (!conn)\n    {\n        RETURN_FALSE;\n    }\n    //connection is closed\n    if (conn->active == 0 || conn->closed)\n    {\n        RETURN_FALSE;\n    }\n    else\n    {\n        RETURN_TRUE;\n    }\n}\n\nPHP_METHOD(swoole_server, protect)\n{\n    long fd;\n    zend_bool value = 1;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l|b\", &fd, &value) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(getThis());\n\n    swConnection *conn = swWorker_get_connection(serv, fd);\n    if (!conn)\n    {\n        RETURN_FALSE;\n    }\n    //connection is closed\n    if (conn->active == 0 || conn->closed)\n    {\n        RETURN_FALSE;\n    }\n    else\n    {\n        conn->protect = value;\n        RETURN_TRUE;\n    }\n}\n\nPHP_METHOD(swoole_server, shutdown)\n{\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (kill(SwooleGS->master_pid, SIGTERM) < 0)\n    {\n        swoole_php_sys_error(E_WARNING, \"shutdown failed. kill(%d, SIGTERM) failed.\", SwooleGS->master_pid);\n        RETURN_FALSE;\n    }\n    else\n    {\n        RETURN_TRUE;\n    }\n}\n\nPHP_METHOD(swoole_server, stop)\n{\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    long worker_id = SwooleWG.id;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|l\", &worker_id) == FAILURE)\n    {\n        return;\n    }\n\n    if (worker_id == SwooleWG.id)\n    {\n        SwooleG.main_reactor->running = 0;\n        SwooleG.running = 0;\n    }\n    else\n    {\n        swWorker *worker = swServer_get_worker(SwooleG.serv, worker_id);\n        if (worker == NULL)\n        {\n            RETURN_FALSE;\n        }\n        else if (kill(worker->pid, SIGTERM) < 0)\n        {\n            swoole_php_sys_error(E_WARNING, \"kill(%d, SIGTERM) failed.\", worker->pid);\n            RETURN_FALSE;\n        }\n    }\n    RETURN_TRUE;\n}\n\nPHP_METHOD(swoole_server, getLastError)\n{\n    RETURN_LONG(SwooleG.error);\n}\n\n#ifdef HAVE_PCRE\nstatic struct\n{\n    int current_fd;\n    int max_fd;\n    uint32_t session_id;\n    int end;\n    int index;\n} server_itearator;\n\nPHP_METHOD(swoole_connection_iterator, rewind)\n{\n    bzero(&server_itearator, sizeof(server_itearator));\n    server_itearator.current_fd = swServer_get_minfd(SwooleG.serv);\n}\n\nPHP_METHOD(swoole_connection_iterator, valid)\n{\n    int fd = server_itearator.current_fd;\n    swConnection *conn;\n\n    int max_fd = swServer_get_maxfd(SwooleG.serv);\n    for (; fd <= max_fd; fd++)\n    {\n        conn = &SwooleG.serv->connection_list[fd];\n\n        if (conn->active && !conn->closed)\n        {\n#ifdef SW_USE_OPENSSL\n            if (conn->ssl && conn->ssl_state != SW_SSL_STATE_READY)\n            {\n                continue;\n            }\n#endif\n            server_itearator.session_id = conn->session_id;\n            server_itearator.current_fd = fd;\n            server_itearator.index++;\n            RETURN_TRUE;\n        }\n    }\n\n    RETURN_FALSE;\n}\n\nPHP_METHOD(swoole_connection_iterator, current)\n{\n    RETURN_LONG(server_itearator.session_id);\n}\n\nPHP_METHOD(swoole_connection_iterator, next)\n{\n    server_itearator.current_fd ++;\n}\n\nPHP_METHOD(swoole_connection_iterator, key)\n{\n    RETURN_LONG(server_itearator.index);\n}\n\nPHP_METHOD(swoole_connection_iterator, count)\n{\n    RETURN_LONG(SwooleStats->connection_num);\n}\n#endif\n\n/*\n * Local variables:\n * tab-width: 4\n * c-basic-offset: 4\n * End:\n * vim600: noet sw=4 ts=4 fdm=marker\n * vim<600: noet sw=4 ts=4\n */",
        "b_contents": "/*\n  +----------------------------------------------------------------------+\n  | Swoole                                                               |\n  +----------------------------------------------------------------------+\n  | This source file is subject to version 2.0 of the Apache license,    |\n  | that is bundled with this package in the file LICENSE, and is        |\n  | available through the world-wide-web at the following url:           |\n  | http://www.apache.org/licenses/LICENSE-2.0.html                      |\n  | If you did not receive a copy of the Apache2.0 license and are unable|\n  | to obtain it through the world-wide-web, please send a note to       |\n  | license@swoole.com so we can mail you a copy immediately.            |\n  +----------------------------------------------------------------------+\n  | Author: Tianfeng Han  <mikan.tenny@gmail.com>                        |\n  +----------------------------------------------------------------------+\n */\n\n#include \"php_swoole.h\"\n\n#include \"Connection.h\"\n\n#ifdef SW_COROUTINE\n#include \"swoole_coroutine.h\"\n#endif\n#include \"ext/standard/php_var.h\"\n#if PHP_MAJOR_VERSION < 7\n#include \"ext/standard/php_smart_str.h\"\n#else\n#include \"zend_smart_str.h\"\n#endif\n\nstatic int php_swoole_task_id;\nstatic int udp_server_socket;\nstatic int dgram_server_socket;\n\nstatic struct\n{\n    zval *zobjects[SW_MAX_LISTEN_PORT];\n    zval *zports;\n    uint8_t num;\n} server_port_list;\n\nzval *php_sw_server_callbacks[PHP_SERVER_CALLBACK_NUM];\n#ifdef SW_COROUTINE\nzend_fcall_info_cache *php_sw_server_caches[PHP_SERVER_CALLBACK_NUM];\n#endif\n\nstatic swHashMap *task_callbacks;\n\n#if PHP_MAJOR_VERSION >= 7\nzval _php_sw_server_callbacks[PHP_SERVER_CALLBACK_NUM];\n#endif\n\nstatic int php_swoole_task_finish(swServer *serv, zval *data TSRMLS_DC);\nstatic void php_swoole_onPipeMessage(swServer *serv, swEventData *req);\nstatic void php_swoole_onStart(swServer *);\nstatic void php_swoole_onShutdown(swServer *);\n\nstatic int php_swoole_onPacket(swServer *, swEventData *);\n\nstatic void php_swoole_onWorkerStart(swServer *, int worker_id);\nstatic void php_swoole_onWorkerStop(swServer *, int worker_id);\nstatic void php_swoole_onUserWorkerStart(swServer *serv, swWorker *worker);\nstatic int php_swoole_onTask(swServer *, swEventData *task);\nstatic int php_swoole_onFinish(swServer *, swEventData *task);\nstatic void php_swoole_onWorkerError(swServer *serv, int worker_id, pid_t worker_pid, int exit_code, int signo);\nstatic void php_swoole_onManagerStart(swServer *serv);\nstatic void php_swoole_onManagerStop(swServer *serv);\n\nstatic zval* php_swoole_server_add_port(swListenPort *port TSRMLS_DC);\nstatic zval* php_swoole_get_task_result(swEventData *task_result TSRMLS_DC);\n\nstatic sw_inline int php_swoole_task_pack(swEventData *task, zval *data TSRMLS_DC)\n{\n    smart_str serialized_data = { 0 };\n    php_serialize_data_t var_hash;\n\n    task->info.type = SW_EVENT_TASK;\n    //field fd save task_id\n    task->info.fd = php_swoole_task_id++;\n    //field from_id save the worker_id\n    task->info.from_id = SwooleWG.id;\n    swTask_type(task) = 0;\n\n    char *task_data_str;\n    int task_data_len = 0;\n    //need serialize\n    if (SW_Z_TYPE_P(data) != IS_STRING)\n    {\n        //serialize\n        swTask_type(task) |= SW_TASK_SERIALIZE;\n        PHP_VAR_SERIALIZE_INIT(var_hash);\n        sw_php_var_serialize(&serialized_data, data, &var_hash TSRMLS_CC);\n        PHP_VAR_SERIALIZE_DESTROY(var_hash);\n#if PHP_MAJOR_VERSION<7\n        task_data_str = serialized_data.c;\n        task_data_len = serialized_data.len;\n#else\n        task_data_str = serialized_data.s->val;\n        task_data_len = serialized_data.s->len;\n#endif\n    }\n    else\n    {\n        task_data_str = Z_STRVAL_P(data);\n        task_data_len = Z_STRLEN_P(data);\n    }\n\n    if (task_data_len >= SW_IPC_MAX_SIZE - sizeof(task->info))\n    {\n        if (swTaskWorker_large_pack(task, task_data_str, task_data_len) < 0)\n        {\n            smart_str_free(&serialized_data);\n            swoole_php_fatal_error(E_WARNING, \"large task pack failed()\");\n            return SW_ERR;\n        }\n    }\n    else\n    {\n        memcpy(task->data, task_data_str, task_data_len);\n        task->info.len = task_data_len;\n    }\n    smart_str_free(&serialized_data);\n    return task->info.fd;\n}\n\nvoid php_swoole_get_recv_data(zval *zdata, swEventData *req, char *header, uint32_t header_length)\n{\n    char *data_ptr = NULL;\n    int data_len;\n\n#ifdef SW_USE_RINGBUFFER\n    swPackage package;\n    if (req->info.type == SW_EVENT_PACKAGE)\n    {\n        memcpy(&package, req->data, sizeof (package));\n\n        data_ptr = package.data;\n        data_len = package.length;\n    }\n#else\n    if (req->info.type == SW_EVENT_PACKAGE_END)\n    {\n        swString *worker_buffer = swWorker_get_buffer(SwooleG.serv, req->info.from_id);\n        data_ptr = worker_buffer->str;\n        data_len = worker_buffer->length;\n    }\n#endif\n    else\n    {\n        data_ptr = req->data;\n        data_len = req->info.len;\n    }\n\n    if (header_length >= data_len)\n    {\n        SW_ZVAL_STRING(zdata, \"\", 1);\n    }\n    else\n    {\n        SW_ZVAL_STRINGL(zdata, data_ptr + header_length, data_len - header_length, 1);\n    }\n\n    if (header_length > 0)\n    {\n        memcpy(header, data_ptr, header_length);\n    }\n\n#ifdef SW_USE_RINGBUFFER\n    if (req->info.type == SW_EVENT_PACKAGE)\n    {\n        swReactorThread *thread = swServer_get_thread(SwooleG.serv, req->info.from_id);\n        thread->buffer_input->free(thread->buffer_input, data_ptr);\n    }\n#endif\n}\n\nint php_swoole_get_send_data(zval *zdata, char **str TSRMLS_DC)\n{\n    int length;\n\n    if (SW_Z_TYPE_P(zdata) == IS_OBJECT)\n    {\n        if (!instanceof_function(Z_OBJCE_P(zdata), swoole_buffer_class_entry_ptr TSRMLS_CC))\n        {\n            goto convert;\n        }\n        swString *str_buffer = swoole_get_object(zdata);\n        if (!str_buffer->str)\n        {\n            swoole_php_fatal_error(E_WARNING, \"swoole_buffer object is empty.\");\n            return SW_ERR;\n        }\n        length = str_buffer->length - str_buffer->offset;\n        *str = str_buffer->str + str_buffer->offset;\n    }\n    else\n    {\n        convert:\n        convert_to_string(zdata);\n        length = Z_STRLEN_P(zdata);\n        *str = Z_STRVAL_P(zdata);\n    }\n\n    if (length >= SwooleG.serv->buffer_output_size)\n    {\n        swoole_php_fatal_error(E_WARNING, \"send %d byte data fail, max_size is %d.\", length, SwooleG.serv->buffer_output_size);\n        return SW_ERR;\n    }\n\n    return length;\n}\n\nstatic sw_inline int php_swoole_check_task_param(int dst_worker_id TSRMLS_DC)\n{\n    if (SwooleG.task_worker_num < 1)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Task method cannot use, Please set task_worker_num.\");\n        return SW_ERR;\n    }\n\n    if (dst_worker_id >= SwooleG.task_worker_num)\n    {\n        swoole_php_fatal_error(E_WARNING, \"worker_id must be less than serv->task_worker_num.\");\n        return SW_ERR;\n    }\n\n    if (!swIsWorker())\n    {\n        swoole_php_fatal_error(E_WARNING, \"The method can only be used in the worker process.\");\n        return SW_ERR;\n    }\n\n    return SW_OK;\n}\n\nstatic zval* php_swoole_get_task_result(swEventData *task_result TSRMLS_DC)\n{\n    zval *result_data, *result_unserialized_data;\n    char *result_data_str;\n    int result_data_len = 0;\n    php_unserialize_data_t var_hash;\n\n    int data_len;\n    char *data_str = NULL;\n\n    /**\n     * Large result package\n     */\n    if (swTask_type(task_result) & SW_TASK_TMPFILE)\n    {\n        swTaskWorker_large_unpack(task_result, emalloc, data_str, data_len);\n        /**\n         * unpack failed\n         */\n        if (data_len == -1)\n        {\n            if (data_str)\n            {\n                efree(data_str);\n            }\n            return NULL;\n        }\n        result_data_str = data_str;\n        result_data_len = data_len;\n    }\n    else\n    {\n        result_data_str = task_result->data;\n        result_data_len = task_result->info.len;\n    }\n\n    if (swTask_type(task_result) & SW_TASK_SERIALIZE)\n    {\n        PHP_VAR_UNSERIALIZE_INIT(var_hash);\n        SW_ALLOC_INIT_ZVAL(result_unserialized_data);\n\n        if (sw_php_var_unserialize(&result_unserialized_data, (const unsigned char **) &result_data_str,\n                (const unsigned char *) (result_data_str + result_data_len), &var_hash TSRMLS_CC))\n        {\n            result_data = result_unserialized_data;\n        }\n        else\n        {\n            SW_ALLOC_INIT_ZVAL(result_data);\n            SW_ZVAL_STRINGL(result_data, result_data_str, result_data_len, 1);\n        }\n        PHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n    }\n    else\n    {\n        SW_ALLOC_INIT_ZVAL(result_data);\n        SW_ZVAL_STRINGL(result_data, result_data_str, result_data_len, 1);\n    }\n    if (data_str)\n    {\n        efree(data_str);\n    }\n    return result_data;\n}\n\nstatic zval* php_swoole_server_add_port(swListenPort *port TSRMLS_DC)\n{\n    zval *port_object;\n    SW_ALLOC_INIT_ZVAL(port_object);\n    object_init_ex(port_object, swoole_server_port_class_entry_ptr);\n    server_port_list.zobjects[server_port_list.num++] = port_object;\n\n    swoole_server_port_property *property = emalloc(sizeof(swoole_server_port_property));\n    bzero(property, sizeof(swoole_server_port_property));\n    swoole_set_property(port_object, 0, property);\n    swoole_set_object(port_object, port);\n\n    zend_update_property_string(swoole_server_port_class_entry_ptr, port_object, ZEND_STRL(\"host\"), port->host TSRMLS_CC);\n    zend_update_property_long(swoole_server_port_class_entry_ptr, port_object, ZEND_STRL(\"port\"), port->port TSRMLS_CC);\n    zend_update_property_long(swoole_server_port_class_entry_ptr, port_object, ZEND_STRL(\"type\"), port->type TSRMLS_CC);\n\n    add_next_index_zval(server_port_list.zports, port_object);\n\n    return port_object;\n}\n\nvoid php_swoole_server_before_start(swServer *serv, zval *zobject TSRMLS_DC)\n{\n    /**\n     * create swoole server\n     */\n    if (swServer_create(serv) < 0)\n    {\n        swoole_php_fatal_error(E_ERROR, \"create server failed. Error: %s\", sw_error);\n        return;\n    }\n\n    swTrace(\"Create swoole_server host=%s, port=%d, mode=%d, type=%d\", serv->listen_list->host, (int) serv->listen_list->port, serv->factory_mode, (int) serv->listen_list->type);\n\n#ifdef SW_COROUTINE\n    coro_init(TSRMLS_C);\n#endif\n\n    /**\n     * Master Process ID\n     */\n    zend_update_property_long(swoole_server_class_entry_ptr, zobject, ZEND_STRL(\"master_pid\"), getpid() TSRMLS_CC);\n\n    zval *zsetting = sw_zend_read_property(swoole_server_class_entry_ptr, zobject, ZEND_STRL(\"setting\"), 1 TSRMLS_CC);\n    if (zsetting == NULL || ZVAL_IS_NULL(zsetting))\n    {\n        SW_MAKE_STD_ZVAL(zsetting);\n        array_init(zsetting);\n        zend_update_property(swoole_server_class_entry_ptr, zobject, ZEND_STRL(\"setting\"), zsetting TSRMLS_CC);\n    }\n\n    if (!sw_zend_hash_exists(Z_ARRVAL_P(zsetting), ZEND_STRL(\"worker_num\")))\n    {\n        add_assoc_long(zsetting, \"worker_num\", serv->worker_num);\n    }\n    if (!sw_zend_hash_exists(Z_ARRVAL_P(zsetting), ZEND_STRL(\"task_worker_num\")))\n    {\n        add_assoc_long(zsetting, \"task_worker_num\", SwooleG.task_worker_num);\n    }\n    if (!sw_zend_hash_exists(Z_ARRVAL_P(zsetting), ZEND_STRL(\"pipe_buffer_size\")))\n    {\n        add_assoc_long(zsetting, \"pipe_buffer_size\", serv->pipe_buffer_size);\n    }\n    if (!sw_zend_hash_exists(Z_ARRVAL_P(zsetting), ZEND_STRL(\"buffer_output_size\")))\n    {\n        add_assoc_long(zsetting, \"buffer_output_size\", serv->buffer_output_size);\n    }\n    if (!sw_zend_hash_exists(Z_ARRVAL_P(zsetting), ZEND_STRL(\"max_connection\")))\n    {\n        add_assoc_long(zsetting, \"max_connection\", serv->max_connection);\n    }\n\n    int i;\n    zval *retval = NULL;\n    zval *port_object;\n    zval *port_setting;\n\n    for (i = 1; i < server_port_list.num; i++)\n    {\n        port_object = server_port_list.zobjects[i];\n        port_setting = sw_zend_read_property(swoole_server_port_class_entry_ptr, port_object, ZEND_STRL(\"setting\"), 1 TSRMLS_CC);\n        //use swoole_server->setting\n        if (port_setting == NULL || ZVAL_IS_NULL(port_setting))\n        {\n            sw_zval_add_ref(&port_setting);\n            sw_zval_add_ref(&port_object);\n            sw_zend_call_method_with_1_params(&port_object, swoole_server_port_class_entry_ptr, NULL, \"set\", &retval, zsetting);\n            if (retval != NULL)\n            {\n                sw_zval_ptr_dtor(&retval);\n            }\n        }\n    }\n}\n\nvoid php_swoole_register_callback(swServer *serv)\n{\n    /*\n     * optional callback\n     */\n    if (php_sw_server_callbacks[SW_SERVER_CB_onStart] != NULL)\n    {\n        serv->onStart = php_swoole_onStart;\n    }\n    serv->onShutdown = php_swoole_onShutdown;\n    /**\n     * require callback, set the master/manager/worker PID\n     */\n    serv->onWorkerStart = php_swoole_onWorkerStart;\n\n    if (php_sw_server_callbacks[SW_SERVER_CB_onWorkerStop] != NULL)\n    {\n        serv->onWorkerStop = php_swoole_onWorkerStop;\n    }\n    /**\n     * UDP Packet\n     */\n    if (php_sw_server_callbacks[SW_SERVER_CB_onPacket] != NULL)\n    {\n        serv->onPacket = php_swoole_onPacket;\n    }\n    /**\n     * Task Worker\n     */\n    if (php_sw_server_callbacks[SW_SERVER_CB_onTask] != NULL)\n    {\n        serv->onTask = php_swoole_onTask;\n    }\n    if (php_sw_server_callbacks[SW_SERVER_CB_onFinish] != NULL)\n    {\n        serv->onFinish = php_swoole_onFinish;\n    }\n    if (php_sw_server_callbacks[SW_SERVER_CB_onWorkerError] != NULL)\n    {\n        serv->onWorkerError = php_swoole_onWorkerError;\n    }\n    if (php_sw_server_callbacks[SW_SERVER_CB_onManagerStart] != NULL)\n    {\n        serv->onManagerStart = php_swoole_onManagerStart;\n    }\n    if (php_sw_server_callbacks[SW_SERVER_CB_onManagerStop] != NULL)\n    {\n        serv->onManagerStop = php_swoole_onManagerStop;\n    }\n    if (php_sw_server_callbacks[SW_SERVER_CB_onPipeMessage] != NULL)\n    {\n        serv->onPipeMessage = php_swoole_onPipeMessage;\n    }\n}\n\nstatic int php_swoole_task_finish(swServer *serv, zval *data TSRMLS_DC)\n{\n    int flags = 0;\n    smart_str serialized_data = {0};\n    php_serialize_data_t var_hash;\n    char *data_str;\n    int data_len = 0;\n    int ret;\n\n    //need serialize\n    if (SW_Z_TYPE_P(data) != IS_STRING)\n    {\n        //serialize\n        flags |= SW_TASK_SERIALIZE;\n        PHP_VAR_SERIALIZE_INIT(var_hash);\n        sw_php_var_serialize(&serialized_data, data, &var_hash TSRMLS_CC);\n        PHP_VAR_SERIALIZE_DESTROY(var_hash);\n#if PHP_MAJOR_VERSION<7\n        data_str = serialized_data.c;\n        data_len = serialized_data.len;\n#else\n        data_str = serialized_data.s->val;\n        data_len = serialized_data.s->len;\n#endif\n    }\n    else\n    {\n        data_str = Z_STRVAL_P(data);\n        data_len = Z_STRLEN_P(data);\n    }\n\n    ret = swTaskWorker_finish(serv, data_str, data_len, flags);\n\n    smart_str_free(&serialized_data);\n    return ret;\n}\n\nstatic void php_swoole_onPipeMessage(swServer *serv, swEventData *req)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n#ifdef SW_COROUTINE\n\tCOROG.require = 0;\n#endif\n\n    zval *zserv = (zval *) serv->ptr2;\n    zval *zworker_id;\n    zval *zdata;\n    zval *retval = NULL;\n\n    SW_MAKE_STD_ZVAL(zworker_id);\n    SW_MAKE_STD_ZVAL(zdata);\n\n    zval **args[3];\n\n    ZVAL_LONG(zworker_id, (long) req->info.from_id);\n\n    if (swTask_type(req) & SW_TASK_TMPFILE)\n    {\n        int data_len;\n        char *buf = NULL;\n        swTaskWorker_large_unpack(req, emalloc, buf, data_len);\n\n        /**\n         * unpack failed\n         */\n        if (data_len == -1)\n        {\n            if (buf)\n            {\n                efree(buf);\n            }\n            return;\n        }\n        SW_ZVAL_STRINGL(zdata, buf, data_len, 0);\n#if PHP_MAJOR_VERSION >= 7\n        efree(buf);\n#endif\n    }\n    else\n    {\n        SW_ZVAL_STRINGL(zdata, req->data, req->info.len, 1);\n    }\n\n    args[0] = &zserv;\n    args[1] = &zworker_id;\n    args[2] = &zdata;\n\n    swTrace(\"PipeMessage: fd=%d|len=%d|from_id=%d|data=%s\\n\", req->info.fd, req->info.len, req->info.from_id, req->data);\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onPipeMessage], &retval, 3, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onPipeMessage handler error\");\n    }\n\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n\n    sw_zval_ptr_dtor(&zworker_id);\n    sw_zval_ptr_dtor(&zdata);\n\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n}\n\nint php_swoole_onReceive(swServer *serv, swEventData *req)\n{\n    swFactory *factory = &serv->factory;\n    zval *zserv = (zval *) serv->ptr2;\n#ifdef SW_COROUTINE\n    zval *args[4];\n#else\n    zval **args[4];\n#endif\n\n    zval *zfd;\n    zval *zfrom_id;\n    zval *zdata;\n    zval *retval = NULL;\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    //UDP\u4f7f\u7528from_id\u4f5c\u4e3aport,fd\u505a\u4e3aip\n    php_swoole_udp_t udp_info;\n    swDgramPacket *packet;\n\n    SW_MAKE_STD_ZVAL(zfd);\n    SW_MAKE_STD_ZVAL(zfrom_id);\n    SW_MAKE_STD_ZVAL(zdata);\n\n    //dgram\n    if (swEventData_is_dgram(req->info.type))\n    {\n        swString *buffer = swWorker_get_buffer(serv, req->info.from_id);\n        packet = (swDgramPacket*) buffer->str;\n\n        //udp ipv4\n        if (req->info.type == SW_EVENT_UDP)\n        {\n            udp_info.from_fd = req->info.from_fd;\n            udp_info.port = packet->port;\n            memcpy(&udp_server_socket, &udp_info, sizeof(udp_server_socket));\n            factory->last_from_id = udp_server_socket;\n            swTrace(\"SendTo: from_id=%d|from_fd=%d\", (uint16_t) req->info.from_id, req->info.from_fd);\n            SW_ZVAL_STRINGL(zdata, packet->data, packet->length, 1);\n            ZVAL_LONG(zfrom_id, (long ) udp_server_socket);\n            ZVAL_LONG(zfd, (long ) packet->addr.v4.s_addr);\n        }\n        //udp ipv6\n        else if (req->info.type == SW_EVENT_UDP6)\n        {\n            udp_info.from_fd = req->info.from_fd;\n            udp_info.port = packet->port;\n            memcpy(&dgram_server_socket, &udp_info, sizeof(udp_server_socket));\n            factory->last_from_id = dgram_server_socket;\n\n            swTrace(\"SendTo: from_id=%d|from_fd=%d\", (uint16_t) req->info.from_id, req->info.from_fd);\n\n            ZVAL_LONG(zfrom_id, (long ) dgram_server_socket);\n            char tmp[INET6_ADDRSTRLEN];\n            inet_ntop(AF_INET6, &packet->addr.v6, tmp, sizeof(tmp));\n            SW_ZVAL_STRING(zfd, tmp, 1);\n            SW_ZVAL_STRINGL(zdata, packet->data, packet->length, 1);\n        }\n        //unix dgram\n        else\n        {\n            SW_ZVAL_STRINGL(zfd, packet->data, packet->addr.un.path_length, 1);\n            SW_ZVAL_STRINGL(zdata, packet->data + packet->addr.un.path_length, packet->length - packet->addr.un.path_length, 1);\n            ZVAL_LONG(zfrom_id, (long ) req->info.from_fd);\n            dgram_server_socket = req->info.from_fd;\n        }\n    }\n    //stream\n    else\n    {\n        ZVAL_LONG(zfrom_id, (long ) req->info.from_id);\n        ZVAL_LONG(zfd, (long ) req->info.fd);\n        php_swoole_get_recv_data(zdata, req, NULL, 0);\n    }\n\n#ifndef SW_COROUTINE\n    zval *callback = php_swoole_server_get_callback(serv, req->info.from_fd, SW_SERVER_CB_onReceive);\n\n    args[0] = &zserv;\n    args[1] = &zfd;\n    args[2] = &zfrom_id;\n    args[3] = &zdata;\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, callback, &retval, 4, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onReceive handler error\");\n    }\n#else\n    args[0] = zserv;\n    args[1] = zfd;\n    args[2] = zfrom_id;\n    args[3] = zdata;\n\n    zend_fcall_info_cache *cache = php_swoole_server_get_cache(serv, req->info.from_fd, SW_SERVER_CB_onReceive);\n    int ret = coro_create(cache, args, 4, &retval, NULL, NULL);\n    if (ret != 0)\n    {\n        sw_zval_ptr_dtor(&zfd);\n        sw_zval_ptr_dtor(&zfrom_id);\n        sw_zval_ptr_dtor(&zdata);\n        if (ret == CORO_LIMIT)\n        {\n            SwooleG.serv->factory.end(&SwooleG.serv->factory, req->info.fd);\n        }\n        return SW_OK;\n    }\n#endif\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n    sw_zval_ptr_dtor(&zfd);\n    sw_zval_ptr_dtor(&zfrom_id);\n    sw_zval_ptr_dtor(&zdata);\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n    return SW_OK;\n}\n\nstatic int php_swoole_onPacket(swServer *serv, swEventData *req)\n{\n    zval *zserv = (zval *) serv->ptr2;\n    zval **args[3];\n\n    zval *zdata;\n    zval *zaddr;\n    zval *retval = NULL;\n    swDgramPacket *packet;\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n#ifdef SW_COROUTINE\n\tCOROG.require = 0;\n#endif\n\n    SW_MAKE_STD_ZVAL(zdata);\n    SW_MAKE_STD_ZVAL(zaddr);\n    array_init(zaddr);\n\n    swString *buffer = swWorker_get_buffer(serv, req->info.from_id);\n    packet = (swDgramPacket*) buffer->str;\n\n    add_assoc_long(zaddr, \"server_socket\", req->info.from_fd);\n\n    zval *callback = php_swoole_server_get_callback(serv, req->info.from_fd, SW_SERVER_CB_onPacket);\n\n    //udp ipv4\n    if (req->info.type == SW_EVENT_UDP)\n    {\n        struct in_addr sin_addr;\n        sin_addr.s_addr = packet->addr.v4.s_addr;\n        char *address = inet_ntoa(sin_addr);\n        sw_add_assoc_string(zaddr, \"address\", address, 1);\n        add_assoc_long(zaddr, \"port\", packet->port);\n        SW_ZVAL_STRINGL(zdata, packet->data, packet->length, 1);\n    }\n    //udp ipv6\n    else if (req->info.type == SW_EVENT_UDP6)\n    {\n        char tmp[INET6_ADDRSTRLEN];\n        inet_ntop(AF_INET6, &packet->addr.v6, tmp, sizeof(tmp));\n        sw_add_assoc_string(zaddr, \"address\", tmp, 1);\n        add_assoc_long(zaddr, \"port\", packet->port);\n        SW_ZVAL_STRINGL(zdata, packet->data, packet->length, 1);\n    }\n    //unix dgram\n    else if (req->info.type == SW_EVENT_UNIX_DGRAM)\n    {\n        sw_add_assoc_stringl(zaddr, \"address\", packet->data, packet->addr.un.path_length, 1);\n        SW_ZVAL_STRINGL(zdata, packet->data + packet->addr.un.path_length, packet->length - packet->addr.un.path_length, 1);\n        dgram_server_socket = req->info.from_fd;\n    }\n\n    args[0] = &zserv;\n    args[1] = &zdata;\n    args[2] = &zaddr;\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, callback, &retval, 3, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onPacket handler error\");\n    }\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n    sw_zval_ptr_dtor(&zaddr);\n    sw_zval_ptr_dtor(&zdata);\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n    return SW_OK;\n}\n\nstatic int php_swoole_onTask(swServer *serv, swEventData *req)\n{\n    zval *zserv = (zval *) serv->ptr2;\n    zval **args[4];\n\n    zval *zfd;\n    zval *zfrom_id;\n    zval *zdata;\n\n    sw_atomic_fetch_sub(&SwooleStats->tasking_num, 1);\n\n    char *zdata_str;\n    int zdata_len;\n    zval *unserialized_zdata = NULL;\n    zval *retval = NULL;\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    SW_MAKE_STD_ZVAL(zfd);\n    ZVAL_LONG(zfd, (long) req->info.fd);\n\n    SW_MAKE_STD_ZVAL(zfrom_id);\n    ZVAL_LONG(zfrom_id, (long) req->info.from_id);\n\n    SW_MAKE_STD_ZVAL(zdata);\n\n    if (swTask_type(req) & SW_TASK_TMPFILE)\n    {\n        int data_len;\n        char *buf = NULL;\n\n        swTaskWorker_large_unpack(req, emalloc, buf, data_len);\n\n        /**\n         * unpack failed\n         */\n        if (data_len == -1)\n        {\n            if (buf)\n            {\n                efree(buf);\n            }\n            return SW_OK;\n        }\n        SW_ZVAL_STRINGL(zdata, buf, data_len, 0);\n#if PHP_MAJOR_VERSION >= 7\n        efree(buf);\n#endif\n    }\n    else\n    {\n        SW_ZVAL_STRINGL(zdata, req->data, req->info.len, 1);\n    }\n\n    args[0] = &zserv;\n    args[1] = &zfd;\n    args[2] = &zfrom_id;\n    args[3] = &zdata;\n\n#if PHP_MAJOR_VERSION >= 7\n    zval stack_unserialized_zdata;\n#endif\n\n    if (swTask_type(req) & SW_TASK_SERIALIZE)\n    {\n        php_unserialize_data_t var_hash;\n\n        PHP_VAR_UNSERIALIZE_INIT(var_hash);\n        zdata_str = Z_STRVAL_P(zdata);\n        zdata_len = Z_STRLEN_P(zdata);\n\n#if PHP_MAJOR_VERSION < 7\n        MAKE_STD_ZVAL(unserialized_zdata);\n#else\n        unserialized_zdata = &stack_unserialized_zdata;\n        bzero(unserialized_zdata, sizeof(zval));\n#endif\n\n        if (sw_php_var_unserialize(&unserialized_zdata, (const uchar ** ) &zdata_str,\n                (const uchar * ) (zdata_str + zdata_len), &var_hash TSRMLS_CC))\n        {\n            args[3] = &unserialized_zdata;\n        }\n        else\n        {\n            args[3] = &zdata;\n        }\n        PHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n    }\n    else\n    {\n        args[3] = &zdata;\n    }\n\n#ifdef SW_COROUTINE\n\tCOROG.require = 0;\n#endif\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onTask], &retval, 4, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onTask handler error\");\n    }\n\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n\n    sw_zval_ptr_dtor(&zfd);\n    sw_zval_ptr_dtor(&zfrom_id);\n    sw_zval_ptr_dtor(&zdata);\n\n    if (unserialized_zdata)\n    {\n        sw_zval_ptr_dtor(&unserialized_zdata);\n    }\n\n    if (retval)\n    {\n        if (SW_Z_TYPE_P(retval) != IS_NULL)\n        {\n            php_swoole_task_finish(serv, retval TSRMLS_CC);\n        }\n        sw_zval_ptr_dtor(&retval);\n    }\n\n    return SW_OK;\n}\n\nstatic int php_swoole_onFinish(swServer *serv, swEventData *req)\n{\n    zval *zserv = (zval *) serv->ptr2;\n    zval **args[3];\n\n    zval *ztask_id;\n    zval *zdata;\n    zval *retval = NULL;\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n#ifdef SW_COROUTINE\n\tCOROG.require = 0;\n#endif\n\n    SW_MAKE_STD_ZVAL(ztask_id);\n    ZVAL_LONG(ztask_id, (long) req->info.fd);\n\n    zdata = php_swoole_get_task_result(req TSRMLS_CC);\n\n    args[0] = &zserv;\n    args[1] = &ztask_id;\n    args[2] = &zdata;\n\n    zval *callback;\n    if (swTask_type(req) & SW_TASK_CALLBACK)\n    {\n        callback = swHashMap_find_int(task_callbacks, req->info.fd);\n    }\n    else\n    {\n        callback = php_sw_server_callbacks[SW_SERVER_CB_onFinish];\n    }\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, callback, &retval, 3, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onFinish handler error\");\n    }\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n    sw_zval_ptr_dtor(&ztask_id);\n    sw_zval_ptr_dtor(&zdata);\n#if PHP_MAJOR_VERSION >= 7\n    efree(zdata);\n#endif\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n    if (swTask_type(req) & SW_TASK_CALLBACK)\n    {\n        swHashMap_del_int(task_callbacks, req->info.fd);\n        sw_zval_ptr_dtor(&callback);\n#if PHP_MAJOR_VERSION >= 7\n        efree(callback);\n#endif\n    }\n    return SW_OK;\n}\n\nstatic void php_swoole_onStart(swServer *serv)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n#ifdef SW_COROUTINE\n\tCOROG.require = 0;\n#endif\n\n    zval *zserv = (zval *) serv->ptr2;\n    zval **args[1];\n    zval *retval = NULL;\n\n    pid_t manager_pid = serv->factory_mode == SW_MODE_PROCESS ? SwooleGS->manager_pid : 0;\n\n    zend_update_property_long(swoole_server_class_entry_ptr, zserv, ZEND_STRL(\"master_pid\"), SwooleGS->master_pid TSRMLS_CC);\n    zend_update_property_long(swoole_server_class_entry_ptr, zserv, ZEND_STRL(\"manager_pid\"), manager_pid TSRMLS_CC);\n\n    args[0] = &zserv;\n    sw_zval_add_ref(&zserv);\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onStart], &retval, 1, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onStart handler error\");\n    }\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n}\n\nstatic void php_swoole_onManagerStart(swServer *serv)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n#ifdef SW_COROUTINE\n\tCOROG.require = 0;\n#endif\n\n    zval *zserv = (zval *) serv->ptr2;\n    zval **args[1];\n    zval *retval = NULL;\n\n    pid_t manager_pid = serv->factory_mode == SW_MODE_PROCESS ? SwooleGS->manager_pid : 0;\n\n    zend_update_property_long(swoole_server_class_entry_ptr, zserv, ZEND_STRL(\"master_pid\"), SwooleGS->master_pid TSRMLS_CC);\n    zend_update_property_long(swoole_server_class_entry_ptr, zserv, ZEND_STRL(\"manager_pid\"), manager_pid TSRMLS_CC);\n\n    args[0] = &zserv;\n    sw_zval_add_ref(&zserv);\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onManagerStart], &retval, 1, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onManagerStart handler error\");\n    }\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n}\n\nstatic void php_swoole_onManagerStop(swServer *serv)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n#ifdef SW_COROUTINE\n\tCOROG.require = 0;\n#endif\n\n    zval *zserv = (zval *) serv->ptr2;\n    zval **args[1];\n    zval *retval = NULL;\n\n    args[0] = &zserv;\n    sw_zval_add_ref(&zserv);\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onManagerStop], &retval, 1, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onManagerStop handler error\");\n    }\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n}\n\nstatic void php_swoole_onShutdown(swServer *serv)\n{\n    zval *zserv = (zval *) serv->ptr2;\n    zval **args[1];\n    zval *retval = NULL;\n\n    args[0] = &zserv;\n    sw_zval_add_ref(&zserv);\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n#ifdef SW_COROUTINE\n\tCOROG.require = 0;\n#endif\n\n    if (php_sw_server_callbacks[SW_SERVER_CB_onShutdown] != NULL)\n    {\n        if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onShutdown], &retval, 1, args, 0, NULL TSRMLS_CC) == FAILURE)\n        {\n            swoole_php_fatal_error(E_WARNING, \"swoole_server: onShutdown handler error\");\n        }\n        if (EG(exception))\n        {\n            zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n        }\n        if (retval != NULL)\n        {\n            sw_zval_ptr_dtor(&retval);\n        }\n    }\n}\n\nstatic void php_swoole_onWorkerStart(swServer *serv, int worker_id)\n{\n    zval *zserv = (zval *) serv->ptr2;\n    zval *zworker_id;\n    zval **args[2];\n    zval *retval = NULL;\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    SW_MAKE_STD_ZVAL(zworker_id);\n    ZVAL_LONG(zworker_id, worker_id);\n\n    args[0] = &zserv;\n    sw_zval_add_ref(&zserv);\n    args[1] = &zworker_id;\n\n    /**\n     * Manager Process ID\n     */\n    zend_update_property_long(swoole_server_class_entry_ptr, zserv, ZEND_STRL(\"master_pid\"), SwooleGS->master_pid TSRMLS_CC);\n\n    /**\n     * Manager Process ID\n     */\n    zend_update_property_long(swoole_server_class_entry_ptr, zserv, ZEND_STRL(\"manager_pid\"), SwooleGS->manager_pid TSRMLS_CC);\n\n    /**\n     * Worker ID\n     */\n    zend_update_property(swoole_server_class_entry_ptr, zserv, ZEND_STRL(\"worker_id\"), zworker_id TSRMLS_CC);\n\n    /**\n     * Is a task worker?\n     */\n    if (worker_id >= serv->worker_num)\n    {\n        zend_update_property_bool(swoole_server_class_entry_ptr, zserv, ZEND_STRL(\"taskworker\"), 1 TSRMLS_CC);\n    }\n    else\n    {\n        zend_update_property_bool(swoole_server_class_entry_ptr, zserv, ZEND_STRL(\"taskworker\"), 0 TSRMLS_CC);\n    }\n\n    /**\n     * Worker Process ID\n     */\n    zend_update_property_long(swoole_server_class_entry_ptr, zserv, ZEND_STRL(\"worker_pid\"), getpid() TSRMLS_CC);\n\n    sw_zval_ptr_dtor(&zworker_id);\n\n    /**\n     * Have not set the event callback\n     */\n#ifdef SW_COROUTINE\n\tCOROG.require = 0;\n#endif\n    if (php_sw_server_callbacks[SW_SERVER_CB_onWorkerStart] == NULL)\n    {\n        return;\n    }\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onWorkerStart], &retval, 2, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onWorkerStart handler error\");\n    }\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n    if (retval)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n}\n\nstatic void php_swoole_onWorkerStop(swServer *serv, int worker_id)\n{\n    if (SwooleWG.shutdown)\n    {\n        return;\n    }\n    SwooleWG.shutdown = 1;\n\n    zval *zobject = (zval *) serv->ptr2;\n    zval *zworker_id;\n    zval **args[2]; //\u8fd9\u91cc\u5fc5\u987b\u4e0e\u4e0b\u9762\u7684\u6570\u5b57\u5bf9\u5e94\n    zval *retval = NULL;\n\n    SW_MAKE_STD_ZVAL(zworker_id);\n    ZVAL_LONG(zworker_id, worker_id);\n\n    sw_zval_add_ref(&zobject);\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n#ifdef SW_COROUTINE\n\tCOROG.require = 0;\n#endif\n\n    args[0] = &zobject;\n    args[1] = &zworker_id;\n    if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onWorkerStop], &retval, 2, args, 0,\n            NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onWorkerStop handler error\");\n    }\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n    sw_zval_ptr_dtor(&zworker_id);\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n\n#if 1\n    shutdown_memory_manager(0, 1 TSRMLS_CC);\n#endif\n}\n\nstatic void php_swoole_onUserWorkerStart(swServer *serv, swWorker *worker)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    zval *object = worker->ptr;\n    zend_update_property_long(swoole_process_class_entry_ptr, object, ZEND_STRL(\"id\"), SwooleWG.id TSRMLS_CC);\n\n    php_swoole_process_start(worker, object TSRMLS_CC);\n}\n\nstatic void php_swoole_onWorkerError(swServer *serv, int worker_id, pid_t worker_pid, int exit_code, int signo)\n{\n    zval *zobject = (zval *) serv->ptr2;\n    zval *zworker_id, *zworker_pid, *zexit_code, *zsigno;\n    zval **args[5];\n    zval *retval = NULL;\n\n    SW_MAKE_STD_ZVAL(zworker_id);\n    ZVAL_LONG(zworker_id, worker_id);\n\n    SW_MAKE_STD_ZVAL(zworker_pid);\n    ZVAL_LONG(zworker_pid, worker_pid);\n\n    SW_MAKE_STD_ZVAL(zexit_code);\n    ZVAL_LONG(zexit_code, exit_code);\n\n    SW_MAKE_STD_ZVAL(zsigno);\n    ZVAL_LONG(zsigno, signo);\n\n    sw_zval_add_ref(&zobject);\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n#ifdef SW_COROUTINE\n\tCOROG.require = 0;\n#endif\n\n    args[0] = &zobject;\n    args[1] = &zworker_id;\n    args[2] = &zworker_pid;\n    args[3] = &zexit_code;\n    args[4] = &zsigno;\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onWorkerError], &retval, 5, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onWorkerError handler error\");\n    }\n\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n\n    sw_zval_ptr_dtor(&zworker_id);\n    sw_zval_ptr_dtor(&zworker_pid);\n    sw_zval_ptr_dtor(&zexit_code);\n    sw_zval_ptr_dtor(&zsigno);\n\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n}\n\n#ifdef SW_COROUTINE\nvoid php_swoole_onConnect_finish(void *param)\n{\n    swServer *serv = SwooleG.serv;\n    swTrace(\"onConnect finish and send confirm\");\n    swServer_confirm(serv, (uint32_t)param);\n}\n#endif\n\nvoid php_swoole_onConnect(swServer *serv, swDataHead *info)\n{\n    zval *zserv = (zval *) serv->ptr2;\n    zval *zfd;\n    zval *zfrom_id;\n#ifdef SW_COROUTINE\n    zval *args[3];\n#else\n    zval **args[3];\n#endif\n    zval *retval = NULL;\n\n    SW_MAKE_STD_ZVAL(zfd);\n    ZVAL_LONG(zfd, info->fd);\n\n    SW_MAKE_STD_ZVAL(zfrom_id);\n    ZVAL_LONG(zfrom_id, info->from_id);\n\n#ifndef SW_COROUTINE\n    args[0] = &zserv;\n    sw_zval_add_ref(&zserv);\n    args[1] = &zfd;\n    args[2] = &zfrom_id;\n#else\n    args[0] = zserv;\n    sw_zval_add_ref(&zserv);\n    args[1] = zfd;\n    args[2] = zfrom_id;\n#endif\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n#ifndef SW_COROUTINE\n    zval *callback = php_swoole_server_get_callback(serv, info->from_fd, SW_SERVER_CB_onConnect);\n    if (!callback)\n    {\n        return;\n    }\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, callback, &retval, 3, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_error(E_WARNING, \"swoole_server: onConnect handler error\");\n    }\n#else\n    int ret;\n    zend_fcall_info_cache *cache = php_swoole_server_get_cache(serv, info->from_fd, SW_SERVER_CB_onConnect);\n    if (serv->enable_delay_receive)\n    {\n        ret = coro_create(cache, args, 3, &retval, php_swoole_onConnect_finish, (void*)info->fd);\n    }\n    else\n    {\n        ret = coro_create(cache, args, 3, &retval, NULL, NULL);\n    }\n\n    if (ret != 0)\n    {\n        sw_zval_ptr_dtor(&zfd);\n        sw_zval_ptr_dtor(&zfrom_id);\n        return;\n    }\n#endif\n\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n\n    sw_zval_ptr_dtor(&zfd);\n    sw_zval_ptr_dtor(&zfrom_id);\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n}\n\nvoid php_swoole_onClose(swServer *serv, swDataHead *info)\n{\n    zval *zserv = (zval *) serv->ptr2;\n    zval *zfd;\n    zval *zfrom_id;\n    zval **args[3];\n    zval *retval = NULL;\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    SW_MAKE_STD_ZVAL(zfd);\n    ZVAL_LONG(zfd, info->fd);\n\n    SW_MAKE_STD_ZVAL(zfrom_id);\n    ZVAL_LONG(zfrom_id, info->from_id);\n\n    args[0] = &zserv;\n    sw_zval_add_ref(&zserv);\n    args[1] = &zfd;\n    args[2] = &zfrom_id;\n\n    zval *callback = php_swoole_server_get_callback(serv, info->from_fd, SW_SERVER_CB_onClose);\n    if (!callback)\n    {\n        return;\n    }\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, callback, &retval, 3, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"onClose handler error\");\n    }\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n\n    sw_zval_ptr_dtor(&zfd);\n    sw_zval_ptr_dtor(&zfrom_id);\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n}\n\nPHP_METHOD(swoole_server, __construct)\n{\n    zend_size_t host_len = 0;\n    char *serv_host;\n    long sock_type = SW_SOCK_TCP;\n    long serv_port;\n    long serv_mode = SW_MODE_PROCESS;\n\n    //only cli env\n    if (strcasecmp(\"cli\", sapi_module.name) != 0)\n    {\n        swoole_php_fatal_error(E_ERROR, \"swoole_server must run at php_cli environment.\");\n        RETURN_FALSE;\n    }\n\n    if (SwooleG.main_reactor != NULL)\n    {\n        swoole_php_fatal_error(E_ERROR, \"eventLoop has been created. Unable to create swoole_server.\");\n        RETURN_FALSE;\n    }\n\n    if (SwooleGS->start > 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"server is already running. Unable to create swoole_server.\");\n        RETURN_FALSE;\n    }\n\n    swServer *serv = sw_malloc(sizeof (swServer));\n    swServer_init(serv);\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"sl|ll\", &serv_host, &host_len, &serv_port, &serv_mode, &sock_type) == FAILURE)\n    {\n        swoole_php_fatal_error(E_ERROR, \"invalid parameters.\");\n        return;\n    }\n\n#ifdef __CYGWIN__\n    serv_mode = SW_MODE_SINGLE;\n#elif !defined(SW_USE_THREAD)\n    if (serv_mode == SW_MODE_THREAD || serv_mode == SW_MODE_BASE)\n    {\n        serv_mode = SW_MODE_SINGLE;\n        swoole_php_fatal_error(E_WARNING, \"PHP can not running at multi-threading. Reset mode to SWOOLE_MODE_BASE\");\n    }\n#endif\n    serv->factory_mode = serv_mode;\n\n    if (serv->factory_mode == SW_MODE_SINGLE)\n    {\n        serv->worker_num = 1;\n        serv->max_request = 0;\n    }\n\n    bzero(php_sw_server_callbacks, sizeof (zval*) * PHP_SERVER_CALLBACK_NUM);\n\n    swListenPort *port = swServer_add_port(serv, sock_type, serv_host, serv_port);\n    if (!port)\n    {\n        swoole_php_fatal_error(E_ERROR, \"listen server port failed.\");\n        return;\n    }\n\n    zval *server_object = getThis();\n\n#ifdef HAVE_PCRE\n    zval *connection_iterator_object;\n    SW_MAKE_STD_ZVAL(connection_iterator_object);\n    object_init_ex(connection_iterator_object, swoole_connection_iterator_class_entry_ptr);\n    zend_update_property(swoole_server_class_entry_ptr, server_object, ZEND_STRL(\"connections\"), connection_iterator_object TSRMLS_CC);\n#endif\n\n    zend_update_property_stringl(swoole_server_class_entry_ptr, server_object, ZEND_STRL(\"host\"), serv_host, host_len TSRMLS_CC);\n    zend_update_property_long(swoole_server_class_entry_ptr, server_object, ZEND_STRL(\"port\"), serv_port TSRMLS_CC);\n    zend_update_property_long(swoole_server_class_entry_ptr, server_object, ZEND_STRL(\"mode\"), serv->factory_mode TSRMLS_CC);\n    zend_update_property_long(swoole_server_class_entry_ptr, server_object, ZEND_STRL(\"type\"), sock_type TSRMLS_CC);\n    swoole_set_object(server_object, serv);\n\n    zval *ports;\n    SW_ALLOC_INIT_ZVAL(ports);\n    array_init(ports);\n    zend_update_property(swoole_server_class_entry_ptr, server_object, ZEND_STRL(\"ports\"), ports TSRMLS_CC);\n    server_port_list.zports = ports;\n\n    php_swoole_server_add_port(port TSRMLS_CC);\n}\n\nPHP_METHOD(swoole_server, set)\n{\n    zval *zset = NULL;\n    zval *zobject = getThis();\n    HashTable *vht;\n\n    zval *v;\n\n    if (SwooleGS->start > 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is running. Unable to execute swoole_server_set now.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z\", &zset) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n\n    vht = Z_ARRVAL_P(zset);\n    //chroot\n    if (php_swoole_array_get_value(vht, \"chroot\", v))\n    {\n        convert_to_string(v);\n        SwooleG.chroot = strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));\n    }\n    //user\n    if (php_swoole_array_get_value(vht, \"user\", v))\n    {\n        convert_to_string(v);\n        SwooleG.user = strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));\n    }\n    //group\n    if (php_swoole_array_get_value(vht, \"group\", v))\n    {\n        convert_to_string(v);\n        SwooleG.group = strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));\n    }\n    //daemonize\n    if (php_swoole_array_get_value(vht, \"daemonize\", v))\n    {\n        convert_to_boolean(v);\n        serv->daemonize = Z_BVAL_P(v);\n    }\n    //reactor thread num\n    if (php_swoole_array_get_value(vht, \"reactor_num\", v))\n    {\n        convert_to_long(v);\n        serv->reactor_num = (int) Z_LVAL_P(v);\n        if (serv->reactor_num <= 0)\n        {\n            serv->reactor_num = SwooleG.cpu_num;\n        }\n    }\n    //worker_num\n    if (php_swoole_array_get_value(vht, \"worker_num\", v))\n    {\n        convert_to_long(v);\n        serv->worker_num = (int) Z_LVAL_P(v);\n        if (serv->worker_num <= 0)\n        {\n            serv->worker_num = SwooleG.cpu_num;\n        }\n    }\n#ifdef SW_COROUTINE\n\tif (php_swoole_array_get_value(vht, \"max_coro_num\", v))\n\t{\n\t\tconvert_to_long(v);\n\t\tCOROG.max_coro_num = (int) Z_LVAL_P(v);\n\t\tif (COROG.max_coro_num <= 0)\n\t\t{\n\t\t\tCOROG.max_coro_num = DEFAULT_MAX_CORO_NUM;\n\t\t}\n\t}\n#endif\n    //dispatch_mode\n    if (php_swoole_array_get_value(vht, \"dispatch_mode\", v))\n    {\n        convert_to_long(v);\n        serv->dispatch_mode = (int) Z_LVAL_P(v);\n    }\n    //log_file\n    if (php_swoole_array_get_value(vht, \"log_file\", v))\n    {\n        convert_to_string(v);\n        SwooleG.log_file = strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));\n    }\n    //log_level\n    if (php_swoole_array_get_value(vht, \"log_level\", v))\n    {\n        convert_to_long(v);\n        SwooleG.log_level = (int) Z_LVAL_P(v);\n    }\n    /**\n     * for dispatch_mode = 1/3\n     */\n    if (php_swoole_array_get_value(vht, \"discard_timeout_request\", v))\n    {\n        convert_to_boolean(v);\n        serv->discard_timeout_request = Z_BVAL_P(v);\n    }\n    //onConnect/onClose event\n    if (php_swoole_array_get_value(vht, \"enable_unsafe_event\", v))\n    {\n        convert_to_boolean(v);\n        serv->enable_unsafe_event = Z_BVAL_P(v);\n    }\n    //port reuse\n    if (php_swoole_array_get_value(vht, \"enable_port_reuse\", v))\n    {\n        convert_to_boolean(v);\n        SwooleG.reuse_port = Z_BVAL_P(v);\n    }\n    //delay receive\n    if (php_swoole_array_get_value(vht, \"enable_delay_receive\", v))\n    {\n        convert_to_boolean(v);\n        serv->enable_delay_receive = Z_BVAL_P(v);\n    }\n    //task_worker_num\n    if (php_swoole_array_get_value(vht, \"task_worker_num\", v))\n    {\n        convert_to_long(v);\n        SwooleG.task_worker_num = (int) Z_LVAL_P(v);\n        task_callbacks = swHashMap_new(1024, NULL);\n    }\n    //task ipc mode, 1,2,3\n    if (php_swoole_array_get_value(vht, \"task_ipc_mode\", v))\n    {\n        convert_to_long(v);\n        SwooleG.task_ipc_mode = (int) Z_LVAL_P(v);\n    }\n    /**\n     * Temporary file directory for task_worker\n     */\n    if (php_swoole_array_get_value(vht, \"task_tmpdir\", v))\n    {\n        convert_to_string(v);\n        SwooleG.task_tmpdir = emalloc(SW_TASK_TMPDIR_SIZE);\n        SwooleG.task_tmpdir_len = snprintf(SwooleG.task_tmpdir, SW_TASK_TMPDIR_SIZE, \"%s/task.XXXXXX\", Z_STRVAL_P(v)) + 1;\n\n        if (SwooleG.task_tmpdir_len > SW_TASK_TMPDIR_SIZE - 1)\n        {\n            swoole_php_fatal_error(E_ERROR, \"task_tmpdir is too long, max size is %d.\", SW_TASK_TMPDIR_SIZE - 1);\n            return;\n        }\n    }\n    else\n    {\n        SwooleG.task_tmpdir = strndup(SW_TASK_TMP_FILE, sizeof (SW_TASK_TMP_FILE));\n        SwooleG.task_tmpdir_len = sizeof (SW_TASK_TMP_FILE);\n    }\n    //task_max_request\n    if (php_swoole_array_get_value(vht, \"task_max_request\", v))\n    {\n        convert_to_long(v);\n        SwooleG.task_max_request = (int) Z_LVAL_P(v);\n    }\n    //max_connection\n    if (php_swoole_array_get_value(vht, \"max_connection\", v) || php_swoole_array_get_value(vht, \"max_conn\", v))\n    {\n        convert_to_long(v);\n        serv->max_connection = (int) Z_LVAL_P(v);\n    }\n    //heartbeat_check_interval\n    if (php_swoole_array_get_value(vht, \"heartbeat_check_interval\", v))\n    {\n        convert_to_long(v);\n        serv->heartbeat_check_interval = (int) Z_LVAL_P(v);\n    }\n    //heartbeat idle time\n    if (php_swoole_array_get_value(vht, \"heartbeat_idle_time\", v))\n    {\n        convert_to_long(v);\n        serv->heartbeat_idle_time = (int) Z_LVAL_P(v);\n\n        if (serv->heartbeat_check_interval > serv->heartbeat_idle_time)\n        {\n            swoole_php_fatal_error(E_WARNING, \"heartbeat_idle_time must be greater than heartbeat_check_interval.\");\n            serv->heartbeat_check_interval = serv->heartbeat_idle_time / 2;\n        }\n    }\n    else if (serv->heartbeat_check_interval > 0)\n    {\n        serv->heartbeat_idle_time = serv->heartbeat_check_interval * 2;\n    }\n    //max_request\n    if (php_swoole_array_get_value(vht, \"max_request\", v))\n    {\n        convert_to_long(v);\n        serv->max_request = (int) Z_LVAL_P(v);\n    }\n    //cpu affinity\n    if (php_swoole_array_get_value(vht, \"open_cpu_affinity\", v))\n    {\n        convert_to_boolean(v);\n        serv->open_cpu_affinity = Z_BVAL_P(v);\n    }\n    //cpu affinity set\n    if (php_swoole_array_get_value(vht, \"cpu_affinity_ignore\", v))\n    {\n        int ignore_num = zend_hash_num_elements(Z_ARRVAL_P(v));\n        if (ignore_num >= SW_CPU_NUM) \n        {\n            swoole_php_fatal_error(E_ERROR, \"cpu_affinity_ignore num must be less than cpu num (%d)\", SW_CPU_NUM);\n            RETURN_FALSE;\n        }\n        int available_num = SW_CPU_NUM - ignore_num;\n        int *available_cpu = (int *) sw_malloc(sizeof(int) * available_num);\n        int flag, i, available_i = 0;\n\n        zval *zval_core = NULL;\n        for (i = 0; i < SW_CPU_NUM; i++)\n        {\n            flag = 1;\n            SW_HASHTABLE_FOREACH_START(Z_ARRVAL_P(v), zval_core)\n                int core = (int) Z_LVAL_P(zval_core);\n                if (i == core)\n                {\n                    flag = 0;\n                    break;\n                }\n            SW_HASHTABLE_FOREACH_END();\n            if (flag)\n            {\n                available_cpu[available_i] = i;\n                available_i++;\n            }\n        }\n        serv->cpu_affinity_available_num = available_num;\n        serv->cpu_affinity_available = available_cpu;\n    }\n    //paser x-www-form-urlencoded form data\n    if (php_swoole_array_get_value(vht, \"http_parse_post\", v))\n    {\n        convert_to_boolean(v);\n        serv->http_parse_post = Z_BVAL_P(v);\n    }\n    /**\n     * buffer input size\n     */\n    if (php_swoole_array_get_value(vht, \"buffer_input_size\", v))\n    {\n        convert_to_long(v);\n        serv->buffer_input_size = (int) Z_LVAL_P(v);\n    }\n    /**\n     * buffer output size\n     */\n    if (php_swoole_array_get_value(vht, \"buffer_output_size\", v))\n    {\n        convert_to_long(v);\n        serv->buffer_output_size = (int) Z_LVAL_P(v);\n    }\n    /**\n     * set pipe memory buffer size\n     */\n    if (php_swoole_array_get_value(vht, \"pipe_buffer_size\", v))\n    {\n        convert_to_long(v);\n        serv->pipe_buffer_size = (int) Z_LVAL_P(v);\n    }\n    //message queue key\n    if (php_swoole_array_get_value(vht, \"message_queue_key\", v))\n    {\n        convert_to_long(v);\n        serv->message_queue_key = (int) Z_LVAL_P(v);\n    }\n\n    zval *retval = NULL;\n    zval *port_object = server_port_list.zobjects[0];\n\n    sw_zval_add_ref(&port_object);\n    sw_zval_add_ref(&zset);\n    sw_zval_add_ref(&zobject);\n\n    sw_zend_call_method_with_1_params(&port_object, swoole_server_port_class_entry_ptr, NULL, \"set\", &retval, zset);\n    zend_update_property(swoole_server_class_entry_ptr, zobject, ZEND_STRL(\"setting\"), zset TSRMLS_CC);\n\n    RETURN_TRUE;\n}\n\nPHP_METHOD(swoole_server, on)\n{\n    zval *name;\n    zval *cb;\n\n    if (SwooleGS->start > 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is running. Unable to set event callback now.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, \"zz\", &name, &cb) == FAILURE)\n    {\n        return;\n    }\n\n#ifdef PHP_SWOOLE_CHECK_CALLBACK\n    char *func_name = NULL;\n#ifdef SW_COROUTINE\n    zend_fcall_info_cache *func_cache = emalloc(sizeof(zend_fcall_info_cache));\n    if (!sw_zend_is_callable_ex(cb, NULL, 0, &func_name, NULL, func_cache, NULL TSRMLS_CC))\n#else\n    if (!sw_zend_is_callable(cb, 0, &func_name TSRMLS_CC))\n#endif\n    {\n        swoole_php_fatal_error(E_ERROR, \"Function '%s' is not callable\", func_name);\n        efree(func_name);\n        return;\n    }\n    efree(func_name);\n#endif\n\n    convert_to_string(name);\n\n    char *callback_name[PHP_SERVER_CALLBACK_NUM] = {\n        \"Connect\",\n        \"Receive\",\n        \"Close\",\n        \"Packet\",\n        \"Start\",\n        \"Shutdown\",\n        \"WorkerStart\",\n        \"WorkerStop\",\n        \"Task\",\n        \"Finish\",\n        \"WorkerError\",\n        \"ManagerStart\",\n        \"ManagerStop\",\n        \"PipeMessage\",\n        NULL,\n        NULL,\n        NULL,\n        NULL,\n    };\n\n    int i;\n    char property_name[128];\n    int l_property_name = 0;\n    memcpy(property_name, \"on\", 2);\n\n    for (i = 0; i < PHP_SERVER_CALLBACK_NUM; i++)\n    {\n        if (callback_name[i] == NULL)\n        {\n            continue;\n        }\n        if (strncasecmp(callback_name[i], Z_STRVAL_P(name), Z_STRLEN_P(name)) == 0)\n        {\n            memcpy(property_name + 2, callback_name[i], Z_STRLEN_P(name));\n            l_property_name = Z_STRLEN_P(name) + 2;\n            property_name[l_property_name] = '\\0';\n            zend_update_property(swoole_server_class_entry_ptr, getThis(), property_name, l_property_name, cb TSRMLS_CC);\n            php_sw_server_callbacks[i] = sw_zend_read_property(swoole_server_class_entry_ptr, getThis(), property_name, l_property_name, 0 TSRMLS_CC);\n            sw_copy_to_stack(php_sw_server_callbacks[i], _php_sw_server_callbacks[i]);\n\n#ifdef SW_COROUTINE\n            php_sw_server_caches[i] = func_cache;\n#endif\n            break;\n        }\n    }\n\n    if (l_property_name == 0)\n    {\n        swoole_php_error(E_WARNING, \"Unknown event types[%s]\", Z_STRVAL_P(name));\n        RETURN_FALSE;\n    }\n\n    if (i < SW_SERVER_CB_onStart)\n    {\n        zval *port_object = server_port_list.zobjects[0];\n        zval *retval = NULL;\n        sw_zval_add_ref(&port_object);\n        sw_zend_call_method_with_2_params(&port_object, swoole_server_port_class_entry_ptr, NULL, \"on\", &retval, name, cb);\n    }\n    else\n    {\n        RETURN_TRUE;\n    }\n}\n\nPHP_METHOD(swoole_server, listen)\n{\n    char *host;\n    zend_size_t host_len;\n    long sock_type;\n    long port;\n\n    if (SwooleGS->start > 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is running. cannot add listener.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"sll\", &host, &host_len, &port, &sock_type) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(getThis());\n    swListenPort *ls = swServer_add_port(serv, (int) sock_type, host, (int) port);\n    if (!ls)\n    {\n        RETURN_FALSE;\n    }\n\n    zval *port_object = php_swoole_server_add_port(ls TSRMLS_CC);\n    RETURN_ZVAL(port_object, 1, NULL);\n}\n\nPHP_METHOD(swoole_server, addProcess)\n{\n    if (SwooleGS->start > 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is running. cannot add process.\");\n        RETURN_FALSE;\n    }\n\n    zval *process = NULL;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z\", &process) == FAILURE)\n    {\n        return;\n    }\n\n    if (ZVAL_IS_NULL(process))\n    {\n        swoole_php_fatal_error(E_WARNING, \"parameter 1 cannot be empty.\");\n        RETURN_FALSE;\n    }\n\n    swServer *serv = swoole_get_object(getThis());\n    if (!instanceof_function(Z_OBJCE_P(process), swoole_process_class_entry_ptr TSRMLS_CC))\n    {\n        swoole_php_fatal_error(E_ERROR, \"object is not instanceof swoole_process.\");\n        RETURN_FALSE;\n    }\n\n    if (serv->onUserWorkerStart == NULL)\n    {\n        serv->onUserWorkerStart = php_swoole_onUserWorkerStart;\n    }\n\n#if PHP_MAJOR_VERSION >= 7\n    zval *tmp_process = emalloc(sizeof(zval));\n    memcpy(tmp_process, process, sizeof(zval));\n    process = tmp_process;\n#endif\n\n    sw_zval_add_ref(&process);\n\n    swWorker *worker = swoole_get_object(process);\n    worker->ptr = process;\n\n    int id = swServer_add_worker(serv, worker);\n    if (id < 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swServer_add_worker failed.\");\n        RETURN_FALSE;\n    }\n    zend_update_property_long(swoole_process_class_entry_ptr, getThis(), ZEND_STRL(\"id\"), id TSRMLS_CC);\n    RETURN_LONG(id);\n}\n\nPHP_METHOD(swoole_server, start)\n{\n    zval *zobject = getThis();\n    int ret;\n\n    if (SwooleGS->start > 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is running. Unable to execute swoole_server::start.\");\n        RETURN_FALSE;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n    php_swoole_register_callback(serv);\n\n    if (php_sw_server_callbacks[SW_SERVER_CB_onReceive] == NULL && php_sw_server_callbacks[SW_SERVER_CB_onPacket] == NULL)\n    {\n        swoole_php_fatal_error(E_ERROR, \"require onReceive/onPacket callback\");\n        RETURN_FALSE;\n    }\n    //-------------------------------------------------------------\n    serv->onReceive = php_swoole_onReceive;\n    serv->ptr2 = zobject;\n\n    php_swoole_server_before_start(serv, zobject TSRMLS_CC);\n\n    ret = swServer_start(serv);\n    if (ret < 0)\n    {\n        swoole_php_fatal_error(E_ERROR, \"start server failed. Error: %s\", sw_error);\n        RETURN_LONG(ret);\n    }\n    RETURN_TRUE;\n}\n\nPHP_METHOD(swoole_server, send)\n{\n    zval *zobject = getThis();\n\n    int ret;\n\n    zval *zfd;\n    zval *zdata;\n    long server_socket = -1;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"zz|l\", &zfd, &zdata, &server_socket) == FAILURE)\n    {\n        return;\n    }\n\n    char *data;\n    int length = php_swoole_get_send_data(zdata, &data TSRMLS_CC);\n\n    if (length < 0)\n    {\n        RETURN_FALSE;\n    }\n    else if (length == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"data is empty.\");\n        RETURN_FALSE;\n    }\n\n   swServer *serv = swoole_get_object(zobject);\n\n    if (serv->have_udp_sock && SW_Z_TYPE_P(zfd) == IS_STRING)\n    {\n        if (server_socket == -1)\n        {\n            server_socket = dgram_server_socket;\n        }\n        //UDP IPv6\n        if (strchr(Z_STRVAL_P(zfd), ':'))\n        {\n            php_swoole_udp_t udp_info;\n            memcpy(&udp_info, &server_socket, sizeof(udp_info));\n            ret = swSocket_udp_sendto6(udp_info.from_fd, Z_STRVAL_P(zfd), udp_info.port, data, length);\n        }\n        //UNIX DGRAM\n        else if (Z_STRVAL_P(zfd)[0] == '/')\n        {\n            struct sockaddr_un addr_un;\n            memcpy(addr_un.sun_path, Z_STRVAL_P(zfd), Z_STRLEN_P(zfd));\n            addr_un.sun_family = AF_UNIX;\n            addr_un.sun_path[Z_STRLEN_P(zfd)] = 0;\n            ret = swSocket_sendto_blocking(server_socket, data, length, 0, (struct sockaddr *) &addr_un, sizeof(addr_un));\n        }\n        else\n        {\n            goto convert;\n        }\n        SW_CHECK_RETURN(ret);\n    }\n\n    convert: convert_to_long(zfd);\n    uint32_t fd = (uint32_t) Z_LVAL_P(zfd);\n    //UDP\n    if (swServer_is_udp(fd))\n    {\n        if (server_socket == -1)\n        {\n            server_socket = udp_server_socket;\n        }\n\n        php_swoole_udp_t udp_info;\n        memcpy(&udp_info, &server_socket, sizeof(udp_info));\n\n        struct sockaddr_in addr_in;\n        addr_in.sin_family = AF_INET;\n        addr_in.sin_port = htons(udp_info.port);\n        addr_in.sin_addr.s_addr = fd;\n        ret = swSocket_sendto_blocking(udp_info.from_fd, data, length, 0, (struct sockaddr *) &addr_in, sizeof(addr_in));\n        SW_CHECK_RETURN(ret);\n    }\n    //TCP\n    else\n    {\n        SW_CHECK_RETURN(swServer_tcp_send(serv, fd, data, length));\n    }\n}\n\nPHP_METHOD(swoole_server, sendto)\n{\n    zval *zobject = getThis();\n\n    char *ip;\n    char *data;\n    zend_size_t len, ip_len;\n\n    long port;\n    long server_socket = -1;\n    zend_bool ipv6 = 0;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"sls|l\", &ip, &ip_len, &port, &data, &len, &server_socket) == FAILURE)\n    {\n        return;\n    }\n\n    if (len <= 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"data is empty.\");\n        RETURN_FALSE;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n\n    if (strchr(ip, ':'))\n    {\n        ipv6 = 1;\n    }\n\n    if (ipv6 == 0 && serv->udp_socket_ipv4 <= 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"You must add an UDP listener to server before using sendto.\");\n        RETURN_FALSE;\n    }\n    else if (ipv6 == 1 && serv->udp_socket_ipv6 <= 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"You must add an UDP6 listener to server before using sendto.\");\n        RETURN_FALSE;\n    }\n\n    if (server_socket < 0)\n    {\n        server_socket = ipv6 ?  serv->udp_socket_ipv6 : serv->udp_socket_ipv4;\n    }\n\n    int ret;\n    if (ipv6)\n    {\n        ret = swSocket_udp_sendto6(server_socket, ip, port, data, len);\n    }\n    else\n    {\n        ret = swSocket_udp_sendto(server_socket, ip, port, data, len);\n    }\n    SW_CHECK_RETURN(ret);\n}\n\nPHP_METHOD(swoole_server, sendfile)\n{\n    zval *zobject = getThis();\n    zend_size_t len;\n\n    char *filename;\n    long fd;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ls\", &fd, &filename, &len) == FAILURE)\n    {\n        return;\n    }\n\n    //check fd\n    if (fd <= 0 || fd > SW_MAX_SOCKET_ID)\n    {\n        swoole_error_log(SW_LOG_WARNING, SW_ERROR_SESSION_INVALID_ID, \"invalid fd[%ld].\", fd);\n        RETURN_FALSE;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n    SW_CHECK_RETURN(swServer_tcp_sendfile(serv, (int) fd, filename, len));\n}\n\nPHP_METHOD(swoole_server, close)\n{\n    zval *zobject = getThis();\n    zend_bool reset = SW_FALSE;\n    long fd;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (swIsMaster())\n    {\n        swoole_php_fatal_error(E_WARNING, \"Cannot close connection in master process.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l|b\", &fd, &reset) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n    swConnection *conn = swServer_connection_verify_no_ssl(serv, fd);\n    if (!conn)\n    {\n        RETURN_FALSE;\n    }\n\n    //Reset send buffer, Immediately close the connection.\n    if (reset)\n    {\n        conn->close_reset = 1;\n    }\n\n    int ret;\n    if (!swIsWorker())\n    {\n        swWorker *worker = swServer_get_worker(serv, conn->fd % serv->worker_num);\n        swDataHead ev;\n        ev.type = SW_EVENT_CLOSE;\n        ev.fd = fd;\n        ev.from_id = conn->from_id;\n        ret = swWorker_send2worker(worker, &ev, sizeof(ev), SW_PIPE_MASTER);\n    }\n    else\n    {\n        ret = serv->factory.end(&serv->factory, fd);\n    }\n    SW_CHECK_RETURN(ret);\n}\n\nPHP_METHOD(swoole_server, confirm)\n{\n    zval *zobject = getThis();\n    long fd;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (swIsMaster())\n    {\n        swoole_php_fatal_error(E_WARNING, \"Cannot confirm connection in master process.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &fd) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n    SW_CHECK_RETURN(swServer_confirm(serv, fd));\n}\n\nPHP_METHOD(swoole_server, stats)\n{\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    array_init(return_value);\n    sw_add_assoc_long_ex(return_value, ZEND_STRS(\"start_time\"), SwooleStats->start_time);\n    sw_add_assoc_long_ex(return_value, ZEND_STRS(\"connection_num\"), SwooleStats->connection_num);\n    sw_add_assoc_long_ex(return_value, ZEND_STRS(\"accept_count\"), SwooleStats->accept_count);\n    sw_add_assoc_long_ex(return_value, ZEND_STRS(\"close_count\"), SwooleStats->close_count);\n    sw_add_assoc_long_ex(return_value, ZEND_STRS(\"tasking_num\"), SwooleStats->tasking_num);\n    sw_add_assoc_long_ex(return_value, ZEND_STRS(\"request_count\"), SwooleStats->request_count);\n    sw_add_assoc_long_ex(return_value, ZEND_STRS(\"worker_request_count\"), SwooleWG.request_count);\n\n    if (SwooleG.task_ipc_mode > SW_IPC_UNSOCK && SwooleGS->task_workers.queue)\n    {\n        int queue_num = -1;\n        int queue_bytes = -1;\n        if (swMsgQueue_stat(SwooleGS->task_workers.queue, &queue_num, &queue_bytes) == 0)\n        {\n            sw_add_assoc_long_ex(return_value, ZEND_STRS(\"task_queue_num\"), queue_num);\n            sw_add_assoc_long_ex(return_value, ZEND_STRS(\"task_queue_bytes\"), queue_bytes);\n        }\n    }\n}\n\nPHP_METHOD(swoole_server, reload)\n{\n    zend_bool only_reload_taskworker = 0;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|b\", &only_reload_taskworker) == FAILURE)\n    {\n        return;\n    }\n\n    int sig = only_reload_taskworker ? SIGUSR2 : SIGUSR1;\n    if (kill(SwooleGS->manager_pid, sig) < 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"kill() failed. Error: %s[%d]\", strerror(errno), errno);\n        RETURN_FALSE;\n    }\n    RETURN_TRUE;\n}\n\nPHP_METHOD(swoole_server, heartbeat)\n{\n    zval *zobject = getThis();\n\n    zend_bool close_connection = 0;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|b\", &close_connection) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n\n    if (serv->heartbeat_idle_time < 1)\n    {\n        RETURN_FALSE;\n    }\n\n    int serv_max_fd = swServer_get_maxfd(serv);\n    int serv_min_fd = swServer_get_minfd(serv);\n\n    array_init(return_value);\n\n    int fd;\n    int checktime = (int) SwooleGS->now - serv->heartbeat_idle_time;\n    swConnection *conn;\n\n    for (fd = serv_min_fd; fd <= serv_max_fd; fd++)\n    {\n        swTrace(\"heartbeat check fd=%d\", fd);\n        conn = &serv->connection_list[fd];\n\n        if (1 == conn->active && conn->last_time < checktime)\n        {\n            conn->close_force = 1;\n            /**\n             * Close the connection\n             */\n            if (close_connection)\n            {\n                serv->factory.end(&serv->factory, fd);\n            }\n#ifdef SW_REACTOR_USE_SESSION\n            add_next_index_long(return_value, conn->session_id);\n#else\n            add_next_index_long(return_value, fd);\n#endif\n        }\n    }\n}\n\nPHP_METHOD(swoole_server, taskwait)\n{\n    swEventData buf;\n    zval *data;\n\n    double timeout = SW_TASKWAIT_TIMEOUT;\n    long dst_worker_id = -1;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z|dl\", &data, &timeout, &dst_worker_id) == FAILURE)\n    {\n        return;\n    }\n\n    if (php_swoole_check_task_param(dst_worker_id TSRMLS_CC) < 0)\n    {\n        RETURN_FALSE;\n    }\n\n    php_swoole_task_pack(&buf, data TSRMLS_CC);\n\n    uint64_t notify;\n    swEventData *task_result = &(SwooleG.task_result[SwooleWG.id]);\n    bzero(task_result, sizeof(swEventData));\n    swPipe *task_notify_pipe = &SwooleG.task_notify[SwooleWG.id];\n    int efd = task_notify_pipe->getFd(task_notify_pipe, 0);\n\n    //clear history task\n    while (read(efd, &notify, sizeof(notify)) > 0);\n\n    if (swProcessPool_dispatch_blocking(&SwooleGS->task_workers, &buf, (int*) &dst_worker_id) >= 0)\n    {\n        sw_atomic_fetch_add(&SwooleStats->tasking_num, 1);\n        task_notify_pipe->timeout = timeout;\n        int ret = task_notify_pipe->read(task_notify_pipe, &notify, sizeof(notify));\n        if (ret > 0)\n        {\n            zval *task_notify_data = php_swoole_get_task_result(task_result TSRMLS_CC);\n            RETURN_ZVAL(task_notify_data, 0, 0);\n        }\n        else\n        {\n            swoole_php_fatal_error(E_WARNING, \"taskwait failed. Error: %s[%d]\", strerror(errno), errno);\n        }\n    }\n    RETURN_FALSE;\n}\n\nPHP_METHOD(swoole_server, taskWaitMulti)\n{\n    swEventData buf;\n    zval *tasks;\n    zval *task;\n    double timeout = SW_TASKWAIT_TIMEOUT;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z|d\", &tasks, &timeout) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(getThis());\n    array_init(return_value);\n\n    int dst_worker_id;\n    int task_id;\n    int i = 0;\n    int n_task = Z_ARRVAL_P(tasks)->nNumOfElements;\n\n    int list_of_id[1024];\n\n    uint64_t notify;\n    swEventData *task_result = &(SwooleG.task_result[SwooleWG.id]);\n    bzero(task_result, sizeof(swEventData));\n    swPipe *task_notify_pipe = &SwooleG.task_notify[SwooleWG.id];\n    swWorker *worker = swServer_get_worker(serv, SwooleWG.id);\n\n    char _tmpfile[sizeof(SW_TASK_TMP_FILE)] = SW_TASK_TMP_FILE;\n    int _tmpfile_fd = swoole_tmpfile(_tmpfile);\n    if (_tmpfile_fd < 0)\n    {\n        swoole_php_sys_error(E_WARNING, \"mktemp(%s) failed.\", SW_TASK_TMP_FILE);\n        RETURN_FALSE;\n    }\n    close(_tmpfile_fd);\n    int *finish_count = (int *) task_result->data;\n\n    worker->lock.lock(&worker->lock);\n    *finish_count = 0;\n    memcpy(task_result->data + 4, _tmpfile, sizeof(_tmpfile));\n    worker->lock.unlock(&worker->lock);\n\n    //clear history task\n    int efd = task_notify_pipe->getFd(task_notify_pipe, 0);\n    while (read(efd, &notify, sizeof(notify)) > 0);\n\n    SW_HASHTABLE_FOREACH_START(Z_ARRVAL_P(tasks), task)\n        task_id = php_swoole_task_pack(&buf, task TSRMLS_CC);\n        if (task_id < 0)\n        {\n            swoole_php_fatal_error(E_WARNING, \"task pack failed.\");\n            goto fail;\n        }\n        swTask_type(&buf) |= SW_TASK_WAITALL;\n        dst_worker_id = -1;\n        if (swProcessPool_dispatch_blocking(&SwooleGS->task_workers, &buf, (int*) &dst_worker_id) >= 0)\n        {\n            sw_atomic_fetch_add(&SwooleStats->tasking_num, 1);\n            list_of_id[i] = task_id;\n        }\n        else\n        {\n            swoole_php_fatal_error(E_WARNING, \"taskwait failed. Error: %s[%d]\", strerror(errno), errno);\n            fail:\n            add_index_bool(return_value, i, 0);\n            n_task --;\n        }\n        i++;\n    SW_HASHTABLE_FOREACH_END();\n\n    while (n_task > 0)\n    {\n        task_notify_pipe->timeout = timeout;\n        int ret = task_notify_pipe->read(task_notify_pipe, &notify, sizeof(notify));\n        if (ret > 0)\n        {\n            if (*finish_count == n_task)\n            {\n                break;\n            }\n        }\n        else\n        {\n            swoole_php_fatal_error(E_WARNING, \"taskwait failed. Error: %s[%d]\", strerror(errno), errno);\n            unlink(_tmpfile);\n            RETURN_FALSE;\n        }\n    }\n\n    swString *content = swoole_file_get_contents(_tmpfile);\n    if (content == NULL)\n    {\n        return;\n    }\n\n    swEventData *result;\n    zval *zdata;\n    int j;\n\n    for (i = 0; i < n_task; i++)\n    {\n        result = (swEventData *) (content->str + content->offset);\n        task_id = result->info.fd;\n        zdata = php_swoole_get_task_result(result TSRMLS_CC);\n        for (j = 0; j < n_task; j++)\n        {\n            if (list_of_id[j] == task_id)\n            {\n                break;\n            }\n        }\n        add_index_zval(return_value, j, zdata);\n        content->offset += sizeof(swDataHead) + result->info.len;\n    }\n    unlink(_tmpfile);\n}\n\nPHP_METHOD(swoole_server, task)\n{\n    swEventData buf;\n    zval *data;\n    zval *callback = NULL;\n\n    long dst_worker_id = -1;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z|lz\", &data, &dst_worker_id, &callback) == FAILURE)\n    {\n        return;\n    }\n\n    if (php_swoole_check_task_param(dst_worker_id TSRMLS_CC) < 0)\n    {\n        RETURN_FALSE;\n    }\n\n    if (php_swoole_task_pack(&buf, data TSRMLS_CC) < 0)\n    {\n        RETURN_FALSE;\n    }\n\n    if (callback && !ZVAL_IS_NULL(callback))\n    {\n#ifdef PHP_SWOOLE_CHECK_CALLBACK\n        char *func_name = NULL;\n        if (!sw_zend_is_callable(callback, 0, &func_name TSRMLS_CC))\n        {\n            swoole_php_fatal_error(E_WARNING, \"Function '%s' is not callable\", func_name);\n            efree(func_name);\n            return;\n        }\n        efree(func_name);\n#endif\n        swTask_type(&buf) |= SW_TASK_CALLBACK;\n        sw_zval_add_ref(&callback);\n        swHashMap_add_int(task_callbacks, buf.info.fd, sw_zval_dup(callback));\n    }\n\n    swTask_type(&buf) |= SW_TASK_NONBLOCK;\n    if (swProcessPool_dispatch(&SwooleGS->task_workers, &buf, (int*) &dst_worker_id) >= 0)\n    {\n        sw_atomic_fetch_add(&SwooleStats->tasking_num, 1);\n        RETURN_LONG(buf.info.fd);\n    }\n    else\n    {\n        RETURN_FALSE;\n    }\n}\n\nPHP_METHOD(swoole_server, sendMessage)\n{\n    zval *zobject = getThis();\n    swEventData buf;\n\n    char *msg;\n    zend_size_t msglen;\n    long worker_id = -1;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"sl\", &msg, &msglen, &worker_id) == FAILURE)\n    {\n        return;\n    }\n\n    if (worker_id == SwooleWG.id)\n    {\n        swoole_php_fatal_error(E_WARNING, \"cannot send message to self.\");\n        RETURN_FALSE;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n    if (worker_id >= serv->worker_num + SwooleG.task_worker_num)\n    {\n        swoole_php_fatal_error(E_WARNING, \"worker_id[%d] is invalid.\", (int) worker_id);\n        RETURN_FALSE;\n    }\n\n    if (!serv->onPipeMessage)\n    {\n        swoole_php_fatal_error(E_WARNING, \"onPipeMessage is null, cannot use sendMessage.\");\n        RETURN_FALSE;\n    }\n\n    buf.info.type = SW_EVENT_PIPE_MESSAGE;\n    buf.info.from_id = SwooleWG.id;\n\n    //write to file\n    if (msglen >= SW_IPC_MAX_SIZE - sizeof(buf.info))\n    {\n        if (swTaskWorker_large_pack(&buf, msg, msglen) < 0)\n        {\n            swoole_php_fatal_error(E_WARNING, \"large task pack failed()\");\n            RETURN_FALSE;\n        }\n    }\n    else\n    {\n        memcpy(buf.data, msg, msglen);\n        buf.info.len = msglen;\n        buf.info.from_fd = 0;\n    }\n\n    swWorker *to_worker = swServer_get_worker(serv, worker_id);\n    SW_CHECK_RETURN(swWorker_send2worker(to_worker, &buf, sizeof(buf.info) + buf.info.len, SW_PIPE_MASTER | SW_PIPE_NONBLOCK));\n}\n\nPHP_METHOD(swoole_server, finish)\n{\n    zval *zobject = getThis();\n    zval *data;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z\", &data) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n    SW_CHECK_RETURN(php_swoole_task_finish(serv, data TSRMLS_CC));\n}\n\nPHP_METHOD(swoole_server, bind)\n{\n    zval *zobject = getThis();\n\n    long fd = 0;\n    long uid = 0;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ll\", &fd, &uid) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n\n    swConnection *conn = swWorker_get_connection(serv, fd);\n\n    //udp client\n    if (conn == NULL)\n    {\n        swTrace(\"%ld conn error\", fd);\n        RETURN_FALSE;\n    }\n\n    //connection is closed\n    if (conn->active == 0)\n    {\n        swTrace(\"fd:%ld a:%d, uid: %ld\", fd, conn->active, conn->uid);\n        RETURN_FALSE;\n    }\n\n    if (conn->uid != 0)\n    {\n        RETURN_FALSE;\n    }\n\n    int ret = 0;\n    SwooleGS->lock.lock(&SwooleGS->lock);\n    if (conn->uid == 0)\n    {\n        conn->uid = uid;\n        ret = 1;\n    }\n    SwooleGS->lock.unlock(&SwooleGS->lock);\n    SW_CHECK_RETURN(ret);\n}\n\n#ifdef SWOOLE_SOCKETS_SUPPORT\nPHP_METHOD(swoole_server, getSocket)\n{\n    long port = 0;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|l\", &port) == FAILURE)\n    {\n        return;\n    }\n\n    zval *zobject = getThis();\n    swServer *serv = swoole_get_object(zobject);\n\n    int sock = swServer_get_socket(serv, port);\n    php_socket *socket_object = swoole_convert_to_socket(sock);\n\n    if (!socket_object)\n    {\n        RETURN_FALSE;\n    }\n    SW_ZEND_REGISTER_RESOURCE(return_value, (void *) socket_object, php_sockets_le_socket());\n}\n#endif\n\nPHP_METHOD(swoole_server, connection_info)\n{\n    zval *zobject = getThis();\n\n    zend_bool noCheckConnection = 0;\n    zval *zfd;\n    long from_id = -1;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z|lb\", &zfd, &from_id, &noCheckConnection) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n\n    long fd = 0;\n    zend_bool ipv6_udp = 0;\n\n    //ipv6 udp\n    if (SW_Z_TYPE_P(zfd) == IS_STRING)\n    {\n        if (is_numeric_string(Z_STRVAL_P(zfd), Z_STRLEN_P(zfd), &fd, NULL, 0))\n        {\n            ipv6_udp = 0;\n        }\n        else\n        {\n            fd = 0;\n            ipv6_udp = 1;\n        }\n    }\n    else\n    {\n        convert_to_long(zfd);\n        fd = Z_LVAL_P(zfd);\n    }\n\n    //udp\n    if (ipv6_udp || swServer_is_udp(fd))\n    {\n        array_init(return_value);\n\n        if (ipv6_udp)\n        {\n            add_assoc_zval(return_value, \"remote_ip\", zfd);\n        }\n        else\n        {\n            struct in_addr sin_addr;\n            sin_addr.s_addr = fd;\n            sw_add_assoc_string(return_value, \"remote_ip\", inet_ntoa(sin_addr), 1);\n        }\n\n        if (from_id == 0)\n        {\n            return;\n        }\n\n        php_swoole_udp_t udp_info;\n        memcpy(&udp_info, &from_id, sizeof(udp_info));\n        //server socket\n        swConnection *from_sock = swServer_connection_get(serv, udp_info.from_fd);\n        if (from_sock)\n        {\n            add_assoc_long(return_value, \"server_fd\", from_sock->fd);\n            add_assoc_long(return_value, \"socket_type\", from_sock->socket_type);\n            add_assoc_long(return_value, \"server_port\", swConnection_get_port(from_sock));\n        }\n        add_assoc_long(return_value, \"remote_port\", udp_info.port);\n        return;\n    }\n\n    swConnection *conn = swServer_connection_verify(serv, fd);\n    if (!conn)\n    {\n        RETURN_FALSE;\n    }\n    //connection is closed\n    if (conn->active == 0 && !noCheckConnection)\n    {\n        RETURN_FALSE;\n    }\n    else\n    {\n        array_init(return_value);\n\n        if (serv->dispatch_mode == SW_DISPATCH_UIDMOD)\n        {\n            add_assoc_long(return_value, \"uid\", conn->uid);\n        }\n\n        swListenPort *port = swServer_get_port(serv, conn->fd);\n        if (port && port->open_websocket_protocol)\n        {\n            add_assoc_long(return_value, \"websocket_status\", conn->websocket_status);\n        }\n\n#ifdef SW_USE_OPENSSL\n        if (conn->ssl_client_cert.length > 0)\n        {\n            sw_add_assoc_stringl(return_value, \"ssl_client_cert\", conn->ssl_client_cert.str, conn->ssl_client_cert.length - 1, 1);\n        }\n#endif\n        //server socket\n        swConnection *from_sock = swServer_connection_get(serv, conn->from_fd);\n        if (from_sock)\n        {\n            add_assoc_long(return_value, \"server_port\", swConnection_get_port(from_sock));\n        }\n        add_assoc_long(return_value, \"server_fd\", conn->from_fd);\n        add_assoc_long(return_value, \"socket_type\", conn->socket_type);\n        add_assoc_long(return_value, \"remote_port\", swConnection_get_port(conn));\n        sw_add_assoc_string(return_value, \"remote_ip\", swConnection_get_ip(conn), 1);\n        add_assoc_long(return_value, \"from_id\", conn->from_id);\n        add_assoc_long(return_value, \"connect_time\", conn->connect_time);\n        add_assoc_long(return_value, \"last_time\", conn->last_time);\n        add_assoc_long(return_value, \"close_errno\", conn->close_errno);\n    }\n}\n\nPHP_METHOD(swoole_server, connection_list)\n{\n    zval *zobject = getThis();\n\n    long start_fd = 0;\n    long find_count = 10;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|ll\", &start_fd, &find_count) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n\n    //\u8d85\u8fc7\u6700\u5927\u67e5\u627e\u6570\u91cf\n    if (find_count > SW_MAX_FIND_COUNT)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_connection_list max_find_count=%d\", SW_MAX_FIND_COUNT);\n        RETURN_FALSE;\n    }\n\n    //\u590d\u5236\u51fa\u6765\u907f\u514d\u88ab\u5176\u4ed6\u8fdb\u7a0b\u6539\u5199\n    int serv_max_fd = swServer_get_maxfd(serv);\n\n    if (start_fd == 0)\n    {\n        start_fd = swServer_get_minfd(serv);\n    }\n#ifdef SW_REACTOR_USE_SESSION\n    else\n    {\n        swConnection *conn = swWorker_get_connection(serv, start_fd);\n        if (!conn)\n        {\n            RETURN_FALSE;\n        }\n        start_fd = conn->fd;\n    }\n#endif\n\n    //\u8fbe\u5230\u6700\u5927\uff0c\u8868\u793a\u5df2\u7ecf\u53d6\u5b8c\u4e86\n    if ((int) start_fd >= serv_max_fd)\n    {\n        RETURN_FALSE;\n    }\n\n    array_init(return_value);\n    int fd = start_fd + 1;\n    swConnection *conn;\n\n    for (; fd <= serv_max_fd; fd++)\n    {\n        swTrace(\"maxfd=%d, fd=%d, find_count=%ld, start_fd=%ld\", serv_max_fd, fd, find_count, start_fd);\n        conn = &serv->connection_list[fd];\n\n        if (conn->active && !conn->closed)\n        {\n#ifdef SW_REACTOR_USE_SESSION\n            add_next_index_long(return_value, conn->session_id);\n#else\n            add_next_index_long(return_value, fd);\n#endif\n            find_count--;\n        }\n        //finish fetch\n        if (find_count <= 0)\n        {\n            break;\n        }\n    }\n}\n\nPHP_METHOD(swoole_server, sendwait)\n{\n    zval *zobject = getThis();\n\n    long fd;\n    zval *zdata;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"lz\", &fd, &zdata) == FAILURE)\n    {\n        return;\n    }\n\n    char *data;\n    int length = php_swoole_get_send_data(zdata, &data TSRMLS_CC);\n\n    if (length < 0)\n    {\n        RETURN_FALSE;\n    }\n    else if (length == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"data is empty.\");\n        RETURN_FALSE;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n\n    if (serv->factory_mode != SW_MODE_SINGLE || swIsTaskWorker())\n    {\n        swoole_php_fatal_error(E_WARNING, \"cannot sendwait.\");\n        RETURN_FALSE;\n    }\n\n    //UDP\n    if (swServer_is_udp(fd))\n    {\n        swoole_php_fatal_error(E_WARNING, \"cannot sendwait.\");\n        RETURN_FALSE;\n    }\n    //TCP\n    else\n    {\n        SW_CHECK_RETURN(swServer_tcp_sendwait(serv, fd, data, length));\n    }\n}\n\nPHP_METHOD(swoole_server, exist)\n{\n    zval *zobject = getThis();\n\n    long fd;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &fd) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n\n    swConnection *conn = swWorker_get_connection(serv, fd);\n    if (!conn)\n    {\n        RETURN_FALSE;\n    }\n    //connection is closed\n    if (conn->active == 0 || conn->closed)\n    {\n        RETURN_FALSE;\n    }\n    else\n    {\n        RETURN_TRUE;\n    }\n}\n\nPHP_METHOD(swoole_server, protect)\n{\n    long fd;\n    zend_bool value = 1;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l|b\", &fd, &value) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(getThis());\n\n    swConnection *conn = swWorker_get_connection(serv, fd);\n    if (!conn)\n    {\n        RETURN_FALSE;\n    }\n    //connection is closed\n    if (conn->active == 0 || conn->closed)\n    {\n        RETURN_FALSE;\n    }\n    else\n    {\n        conn->protect = value;\n        RETURN_TRUE;\n    }\n}\n\nPHP_METHOD(swoole_server, shutdown)\n{\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (kill(SwooleGS->master_pid, SIGTERM) < 0)\n    {\n        swoole_php_sys_error(E_WARNING, \"shutdown failed. kill(%d, SIGTERM) failed.\", SwooleGS->master_pid);\n        RETURN_FALSE;\n    }\n    else\n    {\n        RETURN_TRUE;\n    }\n}\n\nPHP_METHOD(swoole_server, stop)\n{\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    long worker_id = SwooleWG.id;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|l\", &worker_id) == FAILURE)\n    {\n        return;\n    }\n\n    if (worker_id == SwooleWG.id)\n    {\n        SwooleG.main_reactor->running = 0;\n        SwooleG.running = 0;\n    }\n    else\n    {\n        swWorker *worker = swServer_get_worker(SwooleG.serv, worker_id);\n        if (worker == NULL)\n        {\n            RETURN_FALSE;\n        }\n        else if (kill(worker->pid, SIGTERM) < 0)\n        {\n            swoole_php_sys_error(E_WARNING, \"kill(%d, SIGTERM) failed.\", worker->pid);\n            RETURN_FALSE;\n        }\n    }\n    RETURN_TRUE;\n}\n\nPHP_METHOD(swoole_server, getLastError)\n{\n    RETURN_LONG(SwooleG.error);\n}\n\n#ifdef HAVE_PCRE\nstatic struct\n{\n    int current_fd;\n    int max_fd;\n    uint32_t session_id;\n    int end;\n    int index;\n} server_itearator;\n\nPHP_METHOD(swoole_connection_iterator, rewind)\n{\n    bzero(&server_itearator, sizeof(server_itearator));\n    server_itearator.current_fd = swServer_get_minfd(SwooleG.serv);\n}\n\nPHP_METHOD(swoole_connection_iterator, valid)\n{\n    int fd = server_itearator.current_fd;\n    swConnection *conn;\n\n    int max_fd = swServer_get_maxfd(SwooleG.serv);\n    for (; fd <= max_fd; fd++)\n    {\n        conn = &SwooleG.serv->connection_list[fd];\n\n        if (conn->active && !conn->closed)\n        {\n#ifdef SW_USE_OPENSSL\n            if (conn->ssl && conn->ssl_state != SW_SSL_STATE_READY)\n            {\n                continue;\n            }\n#endif\n            server_itearator.session_id = conn->session_id;\n            server_itearator.current_fd = fd;\n            server_itearator.index++;\n            RETURN_TRUE;\n        }\n    }\n\n    RETURN_FALSE;\n}\n\nPHP_METHOD(swoole_connection_iterator, current)\n{\n    RETURN_LONG(server_itearator.session_id);\n}\n\nPHP_METHOD(swoole_connection_iterator, next)\n{\n    server_itearator.current_fd ++;\n}\n\nPHP_METHOD(swoole_connection_iterator, key)\n{\n    RETURN_LONG(server_itearator.index);\n}\n\nPHP_METHOD(swoole_connection_iterator, count)\n{\n    RETURN_LONG(SwooleStats->connection_num);\n}\n#endif\n\n/*\n * Local variables:\n * tab-width: 4\n * c-basic-offset: 4\n * End:\n * vim600: noet sw=4 ts=4 fdm=marker\n * vim<600: noet sw=4 ts=4\n */",
        "base_contents": "/*\n  +----------------------------------------------------------------------+\n  | Swoole                                                               |\n  +----------------------------------------------------------------------+\n  | This source file is subject to version 2.0 of the Apache license,    |\n  | that is bundled with this package in the file LICENSE, and is        |\n  | available through the world-wide-web at the following url:           |\n  | http://www.apache.org/licenses/LICENSE-2.0.html                      |\n  | If you did not receive a copy of the Apache2.0 license and are unable|\n  | to obtain it through the world-wide-web, please send a note to       |\n  | license@swoole.com so we can mail you a copy immediately.            |\n  +----------------------------------------------------------------------+\n  | Author: Tianfeng Han  <mikan.tenny@gmail.com>                        |\n  +----------------------------------------------------------------------+\n */\n\n#include \"php_swoole.h\"\n\n#include \"Connection.h\"\n\n#ifdef SW_COROUTINE\n#include \"swoole_coroutine.h\"\n#endif\n#include \"ext/standard/php_var.h\"\n#if PHP_MAJOR_VERSION < 7\n#include \"ext/standard/php_smart_str.h\"\n#else\n#include \"zend_smart_str.h\"\n#endif\n\nstatic int php_swoole_task_id;\nstatic int udp_server_socket;\nstatic int dgram_server_socket;\n\nstatic struct\n{\n    zval *zobjects[SW_MAX_LISTEN_PORT];\n    zval *zports;\n    uint8_t num;\n} server_port_list;\n\nzval *php_sw_server_callbacks[PHP_SERVER_CALLBACK_NUM];\n#ifdef SW_COROUTINE\nzend_fcall_info_cache *php_sw_server_caches[PHP_SERVER_CALLBACK_NUM];\n#endif\n\nstatic swHashMap *task_callbacks;\n\n#if PHP_MAJOR_VERSION >= 7\nzval _php_sw_server_callbacks[PHP_SERVER_CALLBACK_NUM];\n#endif\n\nstatic int php_swoole_task_finish(swServer *serv, zval *data TSRMLS_DC);\nstatic void php_swoole_onPipeMessage(swServer *serv, swEventData *req);\nstatic void php_swoole_onStart(swServer *);\nstatic void php_swoole_onShutdown(swServer *);\n\nstatic int php_swoole_onPacket(swServer *, swEventData *);\n\nstatic void php_swoole_onWorkerStart(swServer *, int worker_id);\nstatic void php_swoole_onWorkerStop(swServer *, int worker_id);\nstatic void php_swoole_onUserWorkerStart(swServer *serv, swWorker *worker);\nstatic int php_swoole_onTask(swServer *, swEventData *task);\nstatic int php_swoole_onFinish(swServer *, swEventData *task);\nstatic void php_swoole_onWorkerError(swServer *serv, int worker_id, pid_t worker_pid, int exit_code, int signo);\nstatic void php_swoole_onManagerStart(swServer *serv);\nstatic void php_swoole_onManagerStop(swServer *serv);\n\nstatic zval* php_swoole_server_add_port(swListenPort *port TSRMLS_DC);\nstatic zval* php_swoole_get_task_result(swEventData *task_result TSRMLS_DC);\n\nstatic sw_inline int php_swoole_task_pack(swEventData *task, zval *data TSRMLS_DC)\n{\n    smart_str serialized_data = { 0 };\n    php_serialize_data_t var_hash;\n\n    task->info.type = SW_EVENT_TASK;\n    //field fd save task_id\n    task->info.fd = php_swoole_task_id++;\n    //field from_id save the worker_id\n    task->info.from_id = SwooleWG.id;\n    swTask_type(task) = 0;\n\n    char *task_data_str;\n    int task_data_len = 0;\n    //need serialize\n    if (SW_Z_TYPE_P(data) != IS_STRING)\n    {\n        //serialize\n        swTask_type(task) |= SW_TASK_SERIALIZE;\n        PHP_VAR_SERIALIZE_INIT(var_hash);\n        sw_php_var_serialize(&serialized_data, data, &var_hash TSRMLS_CC);\n        PHP_VAR_SERIALIZE_DESTROY(var_hash);\n#if PHP_MAJOR_VERSION<7\n        task_data_str = serialized_data.c;\n        task_data_len = serialized_data.len;\n#else\n        task_data_str = serialized_data.s->val;\n        task_data_len = serialized_data.s->len;\n#endif\n    }\n    else\n    {\n        task_data_str = Z_STRVAL_P(data);\n        task_data_len = Z_STRLEN_P(data);\n    }\n\n    if (task_data_len >= SW_IPC_MAX_SIZE - sizeof(task->info))\n    {\n        if (swTaskWorker_large_pack(task, task_data_str, task_data_len) < 0)\n        {\n            smart_str_free(&serialized_data);\n            swoole_php_fatal_error(E_WARNING, \"large task pack failed()\");\n            return SW_ERR;\n        }\n    }\n    else\n    {\n        memcpy(task->data, task_data_str, task_data_len);\n        task->info.len = task_data_len;\n    }\n    smart_str_free(&serialized_data);\n    return task->info.fd;\n}\n\nvoid php_swoole_get_recv_data(zval *zdata, swEventData *req, char *header, uint32_t header_length)\n{\n    char *data_ptr = NULL;\n    int data_len;\n\n#ifdef SW_USE_RINGBUFFER\n    swPackage package;\n    if (req->info.type == SW_EVENT_PACKAGE)\n    {\n        memcpy(&package, req->data, sizeof (package));\n\n        data_ptr = package.data;\n        data_len = package.length;\n    }\n#else\n    if (req->info.type == SW_EVENT_PACKAGE_END)\n    {\n        swString *worker_buffer = swWorker_get_buffer(SwooleG.serv, req->info.from_id);\n        data_ptr = worker_buffer->str;\n        data_len = worker_buffer->length;\n    }\n#endif\n    else\n    {\n        data_ptr = req->data;\n        data_len = req->info.len;\n    }\n\n    if (header_length >= data_len)\n    {\n        SW_ZVAL_STRING(zdata, \"\", 1);\n    }\n    else\n    {\n        SW_ZVAL_STRINGL(zdata, data_ptr + header_length, data_len - header_length, 1);\n    }\n\n    if (header_length > 0)\n    {\n        memcpy(header, data_ptr, header_length);\n    }\n\n#ifdef SW_USE_RINGBUFFER\n    if (req->info.type == SW_EVENT_PACKAGE)\n    {\n        swReactorThread *thread = swServer_get_thread(SwooleG.serv, req->info.from_id);\n        thread->buffer_input->free(thread->buffer_input, data_ptr);\n    }\n#endif\n}\n\nint php_swoole_get_send_data(zval *zdata, char **str TSRMLS_DC)\n{\n    int length;\n\n    if (SW_Z_TYPE_P(zdata) == IS_OBJECT)\n    {\n        if (!instanceof_function(Z_OBJCE_P(zdata), swoole_buffer_class_entry_ptr TSRMLS_CC))\n        {\n            goto convert;\n        }\n        swString *str_buffer = swoole_get_object(zdata);\n        if (!str_buffer->str)\n        {\n            swoole_php_fatal_error(E_WARNING, \"swoole_buffer object is empty.\");\n            return SW_ERR;\n        }\n        length = str_buffer->length - str_buffer->offset;\n        *str = str_buffer->str + str_buffer->offset;\n    }\n    else\n    {\n        convert:\n        convert_to_string(zdata);\n        length = Z_STRLEN_P(zdata);\n        *str = Z_STRVAL_P(zdata);\n    }\n\n    if (length >= SwooleG.serv->buffer_output_size)\n    {\n        swoole_php_fatal_error(E_WARNING, \"send %d byte data fail, max_size is %d.\", length, SwooleG.serv->buffer_output_size);\n        return SW_ERR;\n    }\n\n    return length;\n}\n\nstatic sw_inline int php_swoole_check_task_param(int dst_worker_id TSRMLS_DC)\n{\n    if (SwooleG.task_worker_num < 1)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Task method cannot use, Please set task_worker_num.\");\n        return SW_ERR;\n    }\n\n    if (dst_worker_id >= SwooleG.task_worker_num)\n    {\n        swoole_php_fatal_error(E_WARNING, \"worker_id must be less than serv->task_worker_num.\");\n        return SW_ERR;\n    }\n\n    if (!swIsWorker())\n    {\n        swoole_php_fatal_error(E_WARNING, \"The method can only be used in the worker process.\");\n        return SW_ERR;\n    }\n\n    return SW_OK;\n}\n\nstatic zval* php_swoole_get_task_result(swEventData *task_result TSRMLS_DC)\n{\n    zval *result_data, *result_unserialized_data;\n    char *result_data_str;\n    int result_data_len = 0;\n    php_unserialize_data_t var_hash;\n\n    int data_len;\n    char *data_str = NULL;\n\n    /**\n     * Large result package\n     */\n    if (swTask_type(task_result) & SW_TASK_TMPFILE)\n    {\n        swTaskWorker_large_unpack(task_result, emalloc, data_str, data_len);\n        /**\n         * unpack failed\n         */\n        if (data_len == -1)\n        {\n            if (data_str)\n            {\n                efree(data_str);\n            }\n            return NULL;\n        }\n        result_data_str = data_str;\n        result_data_len = data_len;\n    }\n    else\n    {\n        result_data_str = task_result->data;\n        result_data_len = task_result->info.len;\n    }\n\n    if (swTask_type(task_result) & SW_TASK_SERIALIZE)\n    {\n        PHP_VAR_UNSERIALIZE_INIT(var_hash);\n        SW_ALLOC_INIT_ZVAL(result_unserialized_data);\n\n        if (sw_php_var_unserialize(&result_unserialized_data, (const unsigned char **) &result_data_str,\n                (const unsigned char *) (result_data_str + result_data_len), &var_hash TSRMLS_CC))\n        {\n            result_data = result_unserialized_data;\n        }\n        else\n        {\n            SW_ALLOC_INIT_ZVAL(result_data);\n            SW_ZVAL_STRINGL(result_data, result_data_str, result_data_len, 1);\n        }\n        PHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n    }\n    else\n    {\n        SW_ALLOC_INIT_ZVAL(result_data);\n        SW_ZVAL_STRINGL(result_data, result_data_str, result_data_len, 1);\n    }\n    if (data_str)\n    {\n        efree(data_str);\n    }\n    return result_data;\n}\n\nstatic zval* php_swoole_server_add_port(swListenPort *port TSRMLS_DC)\n{\n    zval *port_object;\n    SW_ALLOC_INIT_ZVAL(port_object);\n    object_init_ex(port_object, swoole_server_port_class_entry_ptr);\n    server_port_list.zobjects[server_port_list.num++] = port_object;\n\n    swoole_server_port_property *property = emalloc(sizeof(swoole_server_port_property));\n    bzero(property, sizeof(swoole_server_port_property));\n    swoole_set_property(port_object, 0, property);\n    swoole_set_object(port_object, port);\n\n    zend_update_property_string(swoole_server_port_class_entry_ptr, port_object, ZEND_STRL(\"host\"), port->host TSRMLS_CC);\n    zend_update_property_long(swoole_server_port_class_entry_ptr, port_object, ZEND_STRL(\"port\"), port->port TSRMLS_CC);\n    zend_update_property_long(swoole_server_port_class_entry_ptr, port_object, ZEND_STRL(\"type\"), port->type TSRMLS_CC);\n\n    add_next_index_zval(server_port_list.zports, port_object);\n\n    return port_object;\n}\n\nvoid php_swoole_server_before_start(swServer *serv, zval *zobject TSRMLS_DC)\n{\n    /**\n     * create swoole server\n     */\n    if (swServer_create(serv) < 0)\n    {\n        swoole_php_fatal_error(E_ERROR, \"create server failed. Error: %s\", sw_error);\n        return;\n    }\n\n    swTrace(\"Create swoole_server host=%s, port=%d, mode=%d, type=%d\", serv->listen_list->host, (int) serv->listen_list->port, serv->factory_mode, (int) serv->listen_list->type);\n\n#ifdef SW_COROUTINE\n    coro_init(TSRMLS_C);\n#endif\n\n    /**\n     * Master Process ID\n     */\n    zend_update_property_long(swoole_server_class_entry_ptr, zobject, ZEND_STRL(\"master_pid\"), getpid() TSRMLS_CC);\n\n    zval *zsetting = sw_zend_read_property(swoole_server_class_entry_ptr, zobject, ZEND_STRL(\"setting\"), 1 TSRMLS_CC);\n    if (zsetting == NULL || ZVAL_IS_NULL(zsetting))\n    {\n        SW_MAKE_STD_ZVAL(zsetting);\n        array_init(zsetting);\n        zend_update_property(swoole_server_class_entry_ptr, zobject, ZEND_STRL(\"setting\"), zsetting TSRMLS_CC);\n    }\n\n    if (!sw_zend_hash_exists(Z_ARRVAL_P(zsetting), ZEND_STRL(\"worker_num\")))\n    {\n        add_assoc_long(zsetting, \"worker_num\", serv->worker_num);\n    }\n    if (!sw_zend_hash_exists(Z_ARRVAL_P(zsetting), ZEND_STRL(\"task_worker_num\")))\n    {\n        add_assoc_long(zsetting, \"task_worker_num\", SwooleG.task_worker_num);\n    }\n    if (!sw_zend_hash_exists(Z_ARRVAL_P(zsetting), ZEND_STRL(\"pipe_buffer_size\")))\n    {\n        add_assoc_long(zsetting, \"pipe_buffer_size\", serv->pipe_buffer_size);\n    }\n    if (!sw_zend_hash_exists(Z_ARRVAL_P(zsetting), ZEND_STRL(\"buffer_output_size\")))\n    {\n        add_assoc_long(zsetting, \"buffer_output_size\", serv->buffer_output_size);\n    }\n    if (!sw_zend_hash_exists(Z_ARRVAL_P(zsetting), ZEND_STRL(\"max_connection\")))\n    {\n        add_assoc_long(zsetting, \"max_connection\", serv->max_connection);\n    }\n\n    int i;\n    zval *retval = NULL;\n    zval *port_object;\n    zval *port_setting;\n\n    for (i = 1; i < server_port_list.num; i++)\n    {\n        port_object = server_port_list.zobjects[i];\n        port_setting = sw_zend_read_property(swoole_server_port_class_entry_ptr, port_object, ZEND_STRL(\"setting\"), 1 TSRMLS_CC);\n        //use swoole_server->setting\n        if (port_setting == NULL || ZVAL_IS_NULL(port_setting))\n        {\n            sw_zval_add_ref(&port_setting);\n            sw_zval_add_ref(&port_object);\n            sw_zend_call_method_with_1_params(&port_object, swoole_server_port_class_entry_ptr, NULL, \"set\", &retval, zsetting);\n            if (retval != NULL)\n            {\n                sw_zval_ptr_dtor(&retval);\n            }\n        }\n    }\n}\n\nvoid php_swoole_register_callback(swServer *serv)\n{\n    /*\n     * optional callback\n     */\n    if (php_sw_server_callbacks[SW_SERVER_CB_onStart] != NULL)\n    {\n        serv->onStart = php_swoole_onStart;\n    }\n    serv->onShutdown = php_swoole_onShutdown;\n    /**\n     * require callback, set the master/manager/worker PID\n     */\n    serv->onWorkerStart = php_swoole_onWorkerStart;\n\n    if (php_sw_server_callbacks[SW_SERVER_CB_onWorkerStop] != NULL)\n    {\n        serv->onWorkerStop = php_swoole_onWorkerStop;\n    }\n    /**\n     * UDP Packet\n     */\n    if (php_sw_server_callbacks[SW_SERVER_CB_onPacket] != NULL)\n    {\n        serv->onPacket = php_swoole_onPacket;\n    }\n    /**\n     * Task Worker\n     */\n    if (php_sw_server_callbacks[SW_SERVER_CB_onTask] != NULL)\n    {\n        serv->onTask = php_swoole_onTask;\n    }\n    if (php_sw_server_callbacks[SW_SERVER_CB_onFinish] != NULL)\n    {\n        serv->onFinish = php_swoole_onFinish;\n    }\n    if (php_sw_server_callbacks[SW_SERVER_CB_onWorkerError] != NULL)\n    {\n        serv->onWorkerError = php_swoole_onWorkerError;\n    }\n    if (php_sw_server_callbacks[SW_SERVER_CB_onManagerStart] != NULL)\n    {\n        serv->onManagerStart = php_swoole_onManagerStart;\n    }\n    if (php_sw_server_callbacks[SW_SERVER_CB_onManagerStop] != NULL)\n    {\n        serv->onManagerStop = php_swoole_onManagerStop;\n    }\n    if (php_sw_server_callbacks[SW_SERVER_CB_onPipeMessage] != NULL)\n    {\n        serv->onPipeMessage = php_swoole_onPipeMessage;\n    }\n}\n\nstatic int php_swoole_task_finish(swServer *serv, zval *data TSRMLS_DC)\n{\n    int flags = 0;\n    smart_str serialized_data = {0};\n    php_serialize_data_t var_hash;\n    char *data_str;\n    int data_len = 0;\n    int ret;\n\n    //need serialize\n    if (SW_Z_TYPE_P(data) != IS_STRING)\n    {\n        //serialize\n        flags |= SW_TASK_SERIALIZE;\n        PHP_VAR_SERIALIZE_INIT(var_hash);\n        sw_php_var_serialize(&serialized_data, data, &var_hash TSRMLS_CC);\n        PHP_VAR_SERIALIZE_DESTROY(var_hash);\n#if PHP_MAJOR_VERSION<7\n        data_str = serialized_data.c;\n        data_len = serialized_data.len;\n#else\n        data_str = serialized_data.s->val;\n        data_len = serialized_data.s->len;\n#endif\n    }\n    else\n    {\n        data_str = Z_STRVAL_P(data);\n        data_len = Z_STRLEN_P(data);\n    }\n\n    ret = swTaskWorker_finish(serv, data_str, data_len, flags);\n\n    smart_str_free(&serialized_data);\n    return ret;\n}\n\nstatic void php_swoole_onPipeMessage(swServer *serv, swEventData *req)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    zval *zserv = (zval *) serv->ptr2;\n    zval *zworker_id;\n    zval *zdata;\n    zval *retval = NULL;\n\n    SW_MAKE_STD_ZVAL(zworker_id);\n    SW_MAKE_STD_ZVAL(zdata);\n\n    zval **args[3];\n\n    ZVAL_LONG(zworker_id, (long) req->info.from_id);\n\n    if (swTask_type(req) & SW_TASK_TMPFILE)\n    {\n        int data_len;\n        char *buf = NULL;\n        swTaskWorker_large_unpack(req, emalloc, buf, data_len);\n\n        /**\n         * unpack failed\n         */\n        if (data_len == -1)\n        {\n            if (buf)\n            {\n                efree(buf);\n            }\n            return;\n        }\n        SW_ZVAL_STRINGL(zdata, buf, data_len, 0);\n#if PHP_MAJOR_VERSION >= 7\n        efree(buf);\n#endif\n    }\n    else\n    {\n        SW_ZVAL_STRINGL(zdata, req->data, req->info.len, 1);\n    }\n\n    args[0] = &zserv;\n    args[1] = &zworker_id;\n    args[2] = &zdata;\n\n    swTrace(\"PipeMessage: fd=%d|len=%d|from_id=%d|data=%s\\n\", req->info.fd, req->info.len, req->info.from_id, req->data);\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onPipeMessage], &retval, 3, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onPipeMessage handler error\");\n    }\n\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n\n    sw_zval_ptr_dtor(&zworker_id);\n    sw_zval_ptr_dtor(&zdata);\n\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n}\n\nint php_swoole_onReceive(swServer *serv, swEventData *req)\n{\n    swFactory *factory = &serv->factory;\n    zval *zserv = (zval *) serv->ptr2;\n#ifdef SW_COROUTINE\n    zval *args[4];\n#else\n    zval **args[4];\n#endif\n\n    zval *zfd;\n    zval *zfrom_id;\n    zval *zdata;\n    zval *retval = NULL;\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    //UDP\u4f7f\u7528from_id\u4f5c\u4e3aport,fd\u505a\u4e3aip\n    php_swoole_udp_t udp_info;\n    swDgramPacket *packet;\n\n    SW_MAKE_STD_ZVAL(zfd);\n    SW_MAKE_STD_ZVAL(zfrom_id);\n    SW_MAKE_STD_ZVAL(zdata);\n\n    //dgram\n    if (swEventData_is_dgram(req->info.type))\n    {\n        swString *buffer = swWorker_get_buffer(serv, req->info.from_id);\n        packet = (swDgramPacket*) buffer->str;\n\n        //udp ipv4\n        if (req->info.type == SW_EVENT_UDP)\n        {\n            udp_info.from_fd = req->info.from_fd;\n            udp_info.port = packet->port;\n            memcpy(&udp_server_socket, &udp_info, sizeof(udp_server_socket));\n            factory->last_from_id = udp_server_socket;\n            swTrace(\"SendTo: from_id=%d|from_fd=%d\", (uint16_t) req->info.from_id, req->info.from_fd);\n            SW_ZVAL_STRINGL(zdata, packet->data, packet->length, 1);\n            ZVAL_LONG(zfrom_id, (long ) udp_server_socket);\n            ZVAL_LONG(zfd, (long ) packet->addr.v4.s_addr);\n        }\n        //udp ipv6\n        else if (req->info.type == SW_EVENT_UDP6)\n        {\n            udp_info.from_fd = req->info.from_fd;\n            udp_info.port = packet->port;\n            memcpy(&dgram_server_socket, &udp_info, sizeof(udp_server_socket));\n            factory->last_from_id = dgram_server_socket;\n\n            swTrace(\"SendTo: from_id=%d|from_fd=%d\", (uint16_t) req->info.from_id, req->info.from_fd);\n\n            ZVAL_LONG(zfrom_id, (long ) dgram_server_socket);\n            char tmp[INET6_ADDRSTRLEN];\n            inet_ntop(AF_INET6, &packet->addr.v6, tmp, sizeof(tmp));\n            SW_ZVAL_STRING(zfd, tmp, 1);\n            SW_ZVAL_STRINGL(zdata, packet->data, packet->length, 1);\n        }\n        //unix dgram\n        else\n        {\n            SW_ZVAL_STRINGL(zfd, packet->data, packet->addr.un.path_length, 1);\n            SW_ZVAL_STRINGL(zdata, packet->data + packet->addr.un.path_length, packet->length - packet->addr.un.path_length, 1);\n            ZVAL_LONG(zfrom_id, (long ) req->info.from_fd);\n            dgram_server_socket = req->info.from_fd;\n        }\n    }\n    //stream\n    else\n    {\n        ZVAL_LONG(zfrom_id, (long ) req->info.from_id);\n        ZVAL_LONG(zfd, (long ) req->info.fd);\n        php_swoole_get_recv_data(zdata, req, NULL, 0);\n    }\n\n#ifndef SW_COROUTINE\n    zval *callback = php_swoole_server_get_callback(serv, req->info.from_fd, SW_SERVER_CB_onReceive);\n\n    args[0] = &zserv;\n    args[1] = &zfd;\n    args[2] = &zfrom_id;\n    args[3] = &zdata;\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, callback, &retval, 4, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onReceive handler error\");\n    }\n#else\n    args[0] = zserv;\n    args[1] = zfd;\n    args[2] = zfrom_id;\n    args[3] = zdata;\n\n    zend_fcall_info_cache *cache = php_swoole_server_get_cache(serv, req->info.from_fd, SW_SERVER_CB_onReceive);\n    int ret = coro_create(cache, args, 4, &retval);\n    if (ret != 0)\n    {\n        return SW_OK;\n    }\n#endif\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n    sw_zval_ptr_dtor(&zfd);\n    sw_zval_ptr_dtor(&zfrom_id);\n    sw_zval_ptr_dtor(&zdata);\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n    return SW_OK;\n}\n\nstatic int php_swoole_onPacket(swServer *serv, swEventData *req)\n{\n    zval *zserv = (zval *) serv->ptr2;\n    zval **args[3];\n\n    zval *zdata;\n    zval *zaddr;\n    zval *retval = NULL;\n    swDgramPacket *packet;\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    SW_MAKE_STD_ZVAL(zdata);\n    SW_MAKE_STD_ZVAL(zaddr);\n    array_init(zaddr);\n\n    swString *buffer = swWorker_get_buffer(serv, req->info.from_id);\n    packet = (swDgramPacket*) buffer->str;\n\n    add_assoc_long(zaddr, \"server_socket\", req->info.from_fd);\n\n    zval *callback = php_swoole_server_get_callback(serv, req->info.from_fd, SW_SERVER_CB_onPacket);\n\n    //udp ipv4\n    if (req->info.type == SW_EVENT_UDP)\n    {\n        struct in_addr sin_addr;\n        sin_addr.s_addr = packet->addr.v4.s_addr;\n        char *address = inet_ntoa(sin_addr);\n        sw_add_assoc_string(zaddr, \"address\", address, 1);\n        add_assoc_long(zaddr, \"port\", packet->port);\n        SW_ZVAL_STRINGL(zdata, packet->data, packet->length, 1);\n    }\n    //udp ipv6\n    else if (req->info.type == SW_EVENT_UDP6)\n    {\n        char tmp[INET6_ADDRSTRLEN];\n        inet_ntop(AF_INET6, &packet->addr.v6, tmp, sizeof(tmp));\n        sw_add_assoc_string(zaddr, \"address\", tmp, 1);\n        add_assoc_long(zaddr, \"port\", packet->port);\n        SW_ZVAL_STRINGL(zdata, packet->data, packet->length, 1);\n    }\n    //unix dgram\n    else if (req->info.type == SW_EVENT_UNIX_DGRAM)\n    {\n        sw_add_assoc_stringl(zaddr, \"address\", packet->data, packet->addr.un.path_length, 1);\n        SW_ZVAL_STRINGL(zdata, packet->data + packet->addr.un.path_length, packet->length - packet->addr.un.path_length, 1);\n        dgram_server_socket = req->info.from_fd;\n    }\n\n    args[0] = &zserv;\n    args[1] = &zdata;\n    args[2] = &zaddr;\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, callback, &retval, 3, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onPacket handler error\");\n    }\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n    sw_zval_ptr_dtor(&zaddr);\n    sw_zval_ptr_dtor(&zdata);\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n    return SW_OK;\n}\n\nstatic int php_swoole_onTask(swServer *serv, swEventData *req)\n{\n    zval *zserv = (zval *) serv->ptr2;\n    zval **args[4];\n\n    zval *zfd;\n    zval *zfrom_id;\n    zval *zdata;\n\n    sw_atomic_fetch_sub(&SwooleStats->tasking_num, 1);\n\n    char *zdata_str;\n    int zdata_len;\n    zval *unserialized_zdata = NULL;\n    zval *retval = NULL;\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    SW_MAKE_STD_ZVAL(zfd);\n    ZVAL_LONG(zfd, (long) req->info.fd);\n\n    SW_MAKE_STD_ZVAL(zfrom_id);\n    ZVAL_LONG(zfrom_id, (long) req->info.from_id);\n\n    SW_MAKE_STD_ZVAL(zdata);\n\n    if (swTask_type(req) & SW_TASK_TMPFILE)\n    {\n        int data_len;\n        char *buf = NULL;\n\n        swTaskWorker_large_unpack(req, emalloc, buf, data_len);\n\n        /**\n         * unpack failed\n         */\n        if (data_len == -1)\n        {\n            if (buf)\n            {\n                efree(buf);\n            }\n            return SW_OK;\n        }\n        SW_ZVAL_STRINGL(zdata, buf, data_len, 0);\n#if PHP_MAJOR_VERSION >= 7\n        efree(buf);\n#endif\n    }\n    else\n    {\n        SW_ZVAL_STRINGL(zdata, req->data, req->info.len, 1);\n    }\n\n    args[0] = &zserv;\n    args[1] = &zfd;\n    args[2] = &zfrom_id;\n    args[3] = &zdata;\n\n#if PHP_MAJOR_VERSION >= 7\n    zval stack_unserialized_zdata;\n#endif\n\n    if (swTask_type(req) & SW_TASK_SERIALIZE)\n    {\n        php_unserialize_data_t var_hash;\n\n        PHP_VAR_UNSERIALIZE_INIT(var_hash);\n        zdata_str = Z_STRVAL_P(zdata);\n        zdata_len = Z_STRLEN_P(zdata);\n\n#if PHP_MAJOR_VERSION < 7\n        MAKE_STD_ZVAL(unserialized_zdata);\n#else\n        unserialized_zdata = &stack_unserialized_zdata;\n        bzero(unserialized_zdata, sizeof(zval));\n#endif\n\n        if (sw_php_var_unserialize(&unserialized_zdata, (const uchar ** ) &zdata_str,\n                (const uchar * ) (zdata_str + zdata_len), &var_hash TSRMLS_CC))\n        {\n            args[3] = &unserialized_zdata;\n        }\n        else\n        {\n            args[3] = &zdata;\n        }\n        PHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n    }\n    else\n    {\n        args[3] = &zdata;\n    }\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onTask], &retval, 4, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onTask handler error\");\n    }\n\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n\n    sw_zval_ptr_dtor(&zfd);\n    sw_zval_ptr_dtor(&zfrom_id);\n    sw_zval_ptr_dtor(&zdata);\n\n    if (unserialized_zdata)\n    {\n        sw_zval_ptr_dtor(&unserialized_zdata);\n    }\n\n    if (retval)\n    {\n        if (SW_Z_TYPE_P(retval) != IS_NULL)\n        {\n            php_swoole_task_finish(serv, retval TSRMLS_CC);\n        }\n        sw_zval_ptr_dtor(&retval);\n    }\n\n    return SW_OK;\n}\n\nstatic int php_swoole_onFinish(swServer *serv, swEventData *req)\n{\n    zval *zserv = (zval *) serv->ptr2;\n    zval **args[3];\n\n    zval *ztask_id;\n    zval *zdata;\n    zval *retval = NULL;\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    SW_MAKE_STD_ZVAL(ztask_id);\n    ZVAL_LONG(ztask_id, (long) req->info.fd);\n\n    zdata = php_swoole_get_task_result(req TSRMLS_CC);\n\n    args[0] = &zserv;\n    args[1] = &ztask_id;\n    args[2] = &zdata;\n\n    zval *callback;\n    if (swTask_type(req) & SW_TASK_CALLBACK)\n    {\n        callback = swHashMap_find_int(task_callbacks, req->info.fd);\n    }\n    else\n    {\n        callback = php_sw_server_callbacks[SW_SERVER_CB_onFinish];\n    }\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, callback, &retval, 3, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onFinish handler error\");\n    }\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n    sw_zval_ptr_dtor(&ztask_id);\n    sw_zval_ptr_dtor(&zdata);\n#if PHP_MAJOR_VERSION >= 7\n    efree(zdata);\n#endif\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n    if (swTask_type(req) & SW_TASK_CALLBACK)\n    {\n        swHashMap_del_int(task_callbacks, req->info.fd);\n        sw_zval_ptr_dtor(&callback);\n#if PHP_MAJOR_VERSION >= 7\n        efree(callback);\n#endif\n    }\n    return SW_OK;\n}\n\nstatic void php_swoole_onStart(swServer *serv)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    zval *zserv = (zval *) serv->ptr2;\n    zval **args[1];\n    zval *retval = NULL;\n\n    pid_t manager_pid = serv->factory_mode == SW_MODE_PROCESS ? SwooleGS->manager_pid : 0;\n\n    zend_update_property_long(swoole_server_class_entry_ptr, zserv, ZEND_STRL(\"master_pid\"), SwooleGS->master_pid TSRMLS_CC);\n    zend_update_property_long(swoole_server_class_entry_ptr, zserv, ZEND_STRL(\"manager_pid\"), manager_pid TSRMLS_CC);\n\n    args[0] = &zserv;\n    sw_zval_add_ref(&zserv);\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onStart], &retval, 1, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onStart handler error\");\n    }\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n}\n\nstatic void php_swoole_onManagerStart(swServer *serv)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    zval *zserv = (zval *) serv->ptr2;\n    zval **args[1];\n    zval *retval = NULL;\n\n    pid_t manager_pid = serv->factory_mode == SW_MODE_PROCESS ? SwooleGS->manager_pid : 0;\n\n    zend_update_property_long(swoole_server_class_entry_ptr, zserv, ZEND_STRL(\"master_pid\"), SwooleGS->master_pid TSRMLS_CC);\n    zend_update_property_long(swoole_server_class_entry_ptr, zserv, ZEND_STRL(\"manager_pid\"), manager_pid TSRMLS_CC);\n\n    args[0] = &zserv;\n    sw_zval_add_ref(&zserv);\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onManagerStart], &retval, 1, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onManagerStart handler error\");\n    }\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n}\n\nstatic void php_swoole_onManagerStop(swServer *serv)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n    zval *zserv = (zval *) serv->ptr2;\n    zval **args[1];\n    zval *retval = NULL;\n\n    args[0] = &zserv;\n    sw_zval_add_ref(&zserv);\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onManagerStop], &retval, 1, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onManagerStop handler error\");\n    }\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n}\n\nstatic void php_swoole_onShutdown(swServer *serv)\n{\n    zval *zserv = (zval *) serv->ptr2;\n    zval **args[1];\n    zval *retval = NULL;\n\n    args[0] = &zserv;\n    sw_zval_add_ref(&zserv);\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    if (php_sw_server_callbacks[SW_SERVER_CB_onShutdown] != NULL)\n    {\n        if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onShutdown], &retval, 1, args, 0, NULL TSRMLS_CC) == FAILURE)\n        {\n            swoole_php_fatal_error(E_WARNING, \"swoole_server: onShutdown handler error\");\n        }\n        if (EG(exception))\n        {\n            zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n        }\n        if (retval != NULL)\n        {\n            sw_zval_ptr_dtor(&retval);\n        }\n    }\n}\n\nstatic void php_swoole_onWorkerStart(swServer *serv, int worker_id)\n{\n    zval *zserv = (zval *) serv->ptr2;\n    zval *zworker_id;\n    zval **args[2];\n    zval *retval = NULL;\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    SW_MAKE_STD_ZVAL(zworker_id);\n    ZVAL_LONG(zworker_id, worker_id);\n\n    args[0] = &zserv;\n    sw_zval_add_ref(&zserv);\n    args[1] = &zworker_id;\n\n    /**\n     * Manager Process ID\n     */\n    zend_update_property_long(swoole_server_class_entry_ptr, zserv, ZEND_STRL(\"master_pid\"), SwooleGS->master_pid TSRMLS_CC);\n\n    /**\n     * Manager Process ID\n     */\n    zend_update_property_long(swoole_server_class_entry_ptr, zserv, ZEND_STRL(\"manager_pid\"), SwooleGS->manager_pid TSRMLS_CC);\n\n    /**\n     * Worker ID\n     */\n    zend_update_property(swoole_server_class_entry_ptr, zserv, ZEND_STRL(\"worker_id\"), zworker_id TSRMLS_CC);\n\n    /**\n     * Is a task worker?\n     */\n    if (worker_id >= serv->worker_num)\n    {\n        zend_update_property_bool(swoole_server_class_entry_ptr, zserv, ZEND_STRL(\"taskworker\"), 1 TSRMLS_CC);\n    }\n    else\n    {\n        zend_update_property_bool(swoole_server_class_entry_ptr, zserv, ZEND_STRL(\"taskworker\"), 0 TSRMLS_CC);\n    }\n\n    /**\n     * Worker Process ID\n     */\n    zend_update_property_long(swoole_server_class_entry_ptr, zserv, ZEND_STRL(\"worker_pid\"), getpid() TSRMLS_CC);\n\n    sw_zval_ptr_dtor(&zworker_id);\n\n    /**\n     * Have not set the event callback\n     */\n    if (php_sw_server_callbacks[SW_SERVER_CB_onWorkerStart] == NULL)\n    {\n        return;\n    }\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onWorkerStart], &retval, 2, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onWorkerStart handler error\");\n    }\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n    if (retval)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n}\n\nstatic void php_swoole_onWorkerStop(swServer *serv, int worker_id)\n{\n    if (SwooleWG.shutdown)\n    {\n        return;\n    }\n    SwooleWG.shutdown = 1;\n\n    zval *zobject = (zval *) serv->ptr2;\n    zval *zworker_id;\n    zval **args[2]; //\u8fd9\u91cc\u5fc5\u987b\u4e0e\u4e0b\u9762\u7684\u6570\u5b57\u5bf9\u5e94\n    zval *retval = NULL;\n\n    SW_MAKE_STD_ZVAL(zworker_id);\n    ZVAL_LONG(zworker_id, worker_id);\n\n    sw_zval_add_ref(&zobject);\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    args[0] = &zobject;\n    args[1] = &zworker_id;\n    if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onWorkerStop], &retval, 2, args, 0,\n            NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onWorkerStop handler error\");\n    }\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n    sw_zval_ptr_dtor(&zworker_id);\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n\n#if 1\n    shutdown_memory_manager(0, 1 TSRMLS_CC);\n#endif\n}\n\nstatic void php_swoole_onUserWorkerStart(swServer *serv, swWorker *worker)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    zval *object = worker->ptr;\n    zend_update_property_long(swoole_process_class_entry_ptr, object, ZEND_STRL(\"id\"), SwooleWG.id TSRMLS_CC);\n\n    php_swoole_process_start(worker, object TSRMLS_CC);\n}\n\nstatic void php_swoole_onWorkerError(swServer *serv, int worker_id, pid_t worker_pid, int exit_code, int signo)\n{\n    zval *zobject = (zval *) serv->ptr2;\n    zval *zworker_id, *zworker_pid, *zexit_code, *zsigno;\n    zval **args[5];\n    zval *retval = NULL;\n\n    SW_MAKE_STD_ZVAL(zworker_id);\n    ZVAL_LONG(zworker_id, worker_id);\n\n    SW_MAKE_STD_ZVAL(zworker_pid);\n    ZVAL_LONG(zworker_pid, worker_pid);\n\n    SW_MAKE_STD_ZVAL(zexit_code);\n    ZVAL_LONG(zexit_code, exit_code);\n\n    SW_MAKE_STD_ZVAL(zsigno);\n    ZVAL_LONG(zsigno, signo);\n\n    sw_zval_add_ref(&zobject);\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    args[0] = &zobject;\n    args[1] = &zworker_id;\n    args[2] = &zworker_pid;\n    args[3] = &zexit_code;\n    args[4] = &zsigno;\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onWorkerError], &retval, 5, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onWorkerError handler error\");\n    }\n\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n\n    sw_zval_ptr_dtor(&zworker_id);\n    sw_zval_ptr_dtor(&zworker_pid);\n    sw_zval_ptr_dtor(&zexit_code);\n    sw_zval_ptr_dtor(&zsigno);\n\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n}\n\nvoid php_swoole_onConnect(swServer *serv, swDataHead *info)\n{\n    zval *zserv = (zval *) serv->ptr2;\n    zval *zfd;\n    zval *zfrom_id;\n    zval **args[3];\n    zval *retval = NULL;\n\n    SW_MAKE_STD_ZVAL(zfd);\n    ZVAL_LONG(zfd, info->fd);\n\n    SW_MAKE_STD_ZVAL(zfrom_id);\n    ZVAL_LONG(zfrom_id, info->from_id);\n\n    args[0] = &zserv;\n    sw_zval_add_ref(&zserv);\n    args[1] = &zfd;\n    args[2] = &zfrom_id;\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    zval *callback = php_swoole_server_get_callback(serv, info->from_fd, SW_SERVER_CB_onConnect);\n    if (!callback)\n    {\n        return;\n    }\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, callback, &retval, 3, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_error(E_WARNING, \"swoole_server: onConnect handler error\");\n    }\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n\n    sw_zval_ptr_dtor(&zfd);\n    sw_zval_ptr_dtor(&zfrom_id);\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n}\n\nvoid php_swoole_onClose(swServer *serv, swDataHead *info)\n{\n    zval *zserv = (zval *) serv->ptr2;\n    zval *zfd;\n    zval *zfrom_id;\n    zval **args[3];\n    zval *retval = NULL;\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    SW_MAKE_STD_ZVAL(zfd);\n    ZVAL_LONG(zfd, info->fd);\n\n    SW_MAKE_STD_ZVAL(zfrom_id);\n    ZVAL_LONG(zfrom_id, info->from_id);\n\n    args[0] = &zserv;\n    sw_zval_add_ref(&zserv);\n    args[1] = &zfd;\n    args[2] = &zfrom_id;\n\n    zval *callback = php_swoole_server_get_callback(serv, info->from_fd, SW_SERVER_CB_onClose);\n    if (!callback)\n    {\n        return;\n    }\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, callback, &retval, 3, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"onClose handler error\");\n    }\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n\n    sw_zval_ptr_dtor(&zfd);\n    sw_zval_ptr_dtor(&zfrom_id);\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n}\n\nPHP_METHOD(swoole_server, __construct)\n{\n    zend_size_t host_len = 0;\n    char *serv_host;\n    long sock_type = SW_SOCK_TCP;\n    long serv_port;\n    long serv_mode = SW_MODE_PROCESS;\n\n    //only cli env\n    if (strcasecmp(\"cli\", sapi_module.name) != 0)\n    {\n        swoole_php_fatal_error(E_ERROR, \"swoole_server must run at php_cli environment.\");\n        RETURN_FALSE;\n    }\n\n    if (SwooleG.main_reactor != NULL)\n    {\n        swoole_php_fatal_error(E_ERROR, \"eventLoop has been created. Unable to create swoole_server.\");\n        RETURN_FALSE;\n    }\n\n    if (SwooleGS->start > 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"server is already running. Unable to create swoole_server.\");\n        RETURN_FALSE;\n    }\n\n    swServer *serv = sw_malloc(sizeof (swServer));\n    swServer_init(serv);\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"sl|ll\", &serv_host, &host_len, &serv_port, &serv_mode, &sock_type) == FAILURE)\n    {\n        swoole_php_fatal_error(E_ERROR, \"invalid parameters.\");\n        return;\n    }\n\n#ifdef __CYGWIN__\n    serv_mode = SW_MODE_SINGLE;\n#elif !defined(SW_USE_THREAD)\n    if (serv_mode == SW_MODE_THREAD || serv_mode == SW_MODE_BASE)\n    {\n        serv_mode = SW_MODE_SINGLE;\n        swoole_php_fatal_error(E_WARNING, \"PHP can not running at multi-threading. Reset mode to SWOOLE_MODE_BASE\");\n    }\n#endif\n    serv->factory_mode = serv_mode;\n\n    if (serv->factory_mode == SW_MODE_SINGLE)\n    {\n        serv->worker_num = 1;\n        serv->max_request = 0;\n    }\n\n    bzero(php_sw_server_callbacks, sizeof (zval*) * PHP_SERVER_CALLBACK_NUM);\n\n    swListenPort *port = swServer_add_port(serv, sock_type, serv_host, serv_port);\n    if (!port)\n    {\n        swoole_php_fatal_error(E_ERROR, \"listen server port failed.\");\n        return;\n    }\n\n    zval *server_object = getThis();\n\n#ifdef HAVE_PCRE\n    zval *connection_iterator_object;\n    SW_MAKE_STD_ZVAL(connection_iterator_object);\n    object_init_ex(connection_iterator_object, swoole_connection_iterator_class_entry_ptr);\n    zend_update_property(swoole_server_class_entry_ptr, server_object, ZEND_STRL(\"connections\"), connection_iterator_object TSRMLS_CC);\n#endif\n\n    zend_update_property_stringl(swoole_server_class_entry_ptr, server_object, ZEND_STRL(\"host\"), serv_host, host_len TSRMLS_CC);\n    zend_update_property_long(swoole_server_class_entry_ptr, server_object, ZEND_STRL(\"port\"), serv_port TSRMLS_CC);\n    zend_update_property_long(swoole_server_class_entry_ptr, server_object, ZEND_STRL(\"mode\"), serv->factory_mode TSRMLS_CC);\n    zend_update_property_long(swoole_server_class_entry_ptr, server_object, ZEND_STRL(\"type\"), sock_type TSRMLS_CC);\n    swoole_set_object(server_object, serv);\n\n    zval *ports;\n    SW_ALLOC_INIT_ZVAL(ports);\n    array_init(ports);\n    zend_update_property(swoole_server_class_entry_ptr, server_object, ZEND_STRL(\"ports\"), ports TSRMLS_CC);\n    server_port_list.zports = ports;\n\n    php_swoole_server_add_port(port TSRMLS_CC);\n}\n\nPHP_METHOD(swoole_server, set)\n{\n    zval *zset = NULL;\n    zval *zobject = getThis();\n    HashTable *vht;\n\n    zval *v;\n\n    if (SwooleGS->start > 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is running. Unable to execute swoole_server_set now.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z\", &zset) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n\n    vht = Z_ARRVAL_P(zset);\n    //chroot\n    if (php_swoole_array_get_value(vht, \"chroot\", v))\n    {\n        convert_to_string(v);\n        SwooleG.chroot = strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));\n    }\n    //user\n    if (php_swoole_array_get_value(vht, \"user\", v))\n    {\n        convert_to_string(v);\n        SwooleG.user = strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));\n    }\n    //group\n    if (php_swoole_array_get_value(vht, \"group\", v))\n    {\n        convert_to_string(v);\n        SwooleG.group = strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));\n    }\n    //daemonize\n    if (php_swoole_array_get_value(vht, \"daemonize\", v))\n    {\n        convert_to_boolean(v);\n        serv->daemonize = Z_BVAL_P(v);\n    }\n    //reactor thread num\n    if (php_swoole_array_get_value(vht, \"reactor_num\", v))\n    {\n        convert_to_long(v);\n        serv->reactor_num = (int) Z_LVAL_P(v);\n        if (serv->reactor_num <= 0)\n        {\n            serv->reactor_num = SwooleG.cpu_num;\n        }\n    }\n    //worker_num\n    if (php_swoole_array_get_value(vht, \"worker_num\", v))\n    {\n        convert_to_long(v);\n        serv->worker_num = (int) Z_LVAL_P(v);\n        if (serv->worker_num <= 0)\n        {\n            serv->worker_num = SwooleG.cpu_num;\n        }\n    }\n#ifdef SW_COROUTINE\n\tif (php_swoole_array_get_value(vht, \"max_coro_num\", v))\n\t{\n\t\tconvert_to_long(v);\n\t\tCOROG.max_coro_num = (int) Z_LVAL_P(v);\n\t\tif (COROG.max_coro_num <= 0)\n\t\t{\n\t\t\tCOROG.max_coro_num = DEFAULT_MAX_CORO_NUM;\n\t\t}\n\t}\n#endif\n    //dispatch_mode\n    if (php_swoole_array_get_value(vht, \"dispatch_mode\", v))\n    {\n        convert_to_long(v);\n        serv->dispatch_mode = (int) Z_LVAL_P(v);\n    }\n    //log_file\n    if (php_swoole_array_get_value(vht, \"log_file\", v))\n    {\n        convert_to_string(v);\n        SwooleG.log_file = strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));\n    }\n    //log_level\n    if (php_swoole_array_get_value(vht, \"log_level\", v))\n    {\n        convert_to_long(v);\n        SwooleG.log_level = (int) Z_LVAL_P(v);\n    }\n    /**\n     * for dispatch_mode = 1/3\n     */\n    if (php_swoole_array_get_value(vht, \"discard_timeout_request\", v))\n    {\n        convert_to_boolean(v);\n        serv->discard_timeout_request = Z_BVAL_P(v);\n    }\n    //onConnect/onClose event\n    if (php_swoole_array_get_value(vht, \"enable_unsafe_event\", v))\n    {\n        convert_to_boolean(v);\n        serv->enable_unsafe_event = Z_BVAL_P(v);\n    }\n    //port reuse\n    if (php_swoole_array_get_value(vht, \"enable_port_reuse\", v))\n    {\n        convert_to_boolean(v);\n        SwooleG.reuse_port = Z_BVAL_P(v);\n    }\n    //delay receive\n    if (php_swoole_array_get_value(vht, \"enable_delay_receive\", v))\n    {\n        convert_to_boolean(v);\n        serv->enable_delay_receive = Z_BVAL_P(v);\n    }\n    //task_worker_num\n    if (php_swoole_array_get_value(vht, \"task_worker_num\", v))\n    {\n        convert_to_long(v);\n        SwooleG.task_worker_num = (int) Z_LVAL_P(v);\n        task_callbacks = swHashMap_new(1024, NULL);\n    }\n    //task ipc mode, 1,2,3\n    if (php_swoole_array_get_value(vht, \"task_ipc_mode\", v))\n    {\n        convert_to_long(v);\n        SwooleG.task_ipc_mode = (int) Z_LVAL_P(v);\n    }\n    /**\n     * Temporary file directory for task_worker\n     */\n    if (php_swoole_array_get_value(vht, \"task_tmpdir\", v))\n    {\n        convert_to_string(v);\n        SwooleG.task_tmpdir = emalloc(SW_TASK_TMPDIR_SIZE);\n        SwooleG.task_tmpdir_len = snprintf(SwooleG.task_tmpdir, SW_TASK_TMPDIR_SIZE, \"%s/task.XXXXXX\", Z_STRVAL_P(v)) + 1;\n\n        if (SwooleG.task_tmpdir_len > SW_TASK_TMPDIR_SIZE - 1)\n        {\n            swoole_php_fatal_error(E_ERROR, \"task_tmpdir is too long, max size is %d.\", SW_TASK_TMPDIR_SIZE - 1);\n            return;\n        }\n    }\n    else\n    {\n        SwooleG.task_tmpdir = strndup(SW_TASK_TMP_FILE, sizeof (SW_TASK_TMP_FILE));\n        SwooleG.task_tmpdir_len = sizeof (SW_TASK_TMP_FILE);\n    }\n    //task_max_request\n    if (php_swoole_array_get_value(vht, \"task_max_request\", v))\n    {\n        convert_to_long(v);\n        SwooleG.task_max_request = (int) Z_LVAL_P(v);\n    }\n    //max_connection\n    if (php_swoole_array_get_value(vht, \"max_connection\", v) || php_swoole_array_get_value(vht, \"max_conn\", v))\n    {\n        convert_to_long(v);\n        serv->max_connection = (int) Z_LVAL_P(v);\n    }\n    //heartbeat_check_interval\n    if (php_swoole_array_get_value(vht, \"heartbeat_check_interval\", v))\n    {\n        convert_to_long(v);\n        serv->heartbeat_check_interval = (int) Z_LVAL_P(v);\n    }\n    //heartbeat idle time\n    if (php_swoole_array_get_value(vht, \"heartbeat_idle_time\", v))\n    {\n        convert_to_long(v);\n        serv->heartbeat_idle_time = (int) Z_LVAL_P(v);\n\n        if (serv->heartbeat_check_interval > serv->heartbeat_idle_time)\n        {\n            swoole_php_fatal_error(E_WARNING, \"heartbeat_idle_time must be greater than heartbeat_check_interval.\");\n            serv->heartbeat_check_interval = serv->heartbeat_idle_time / 2;\n        }\n    }\n    else if (serv->heartbeat_check_interval > 0)\n    {\n        serv->heartbeat_idle_time = serv->heartbeat_check_interval * 2;\n    }\n    //max_request\n    if (php_swoole_array_get_value(vht, \"max_request\", v))\n    {\n        convert_to_long(v);\n        serv->max_request = (int) Z_LVAL_P(v);\n    }\n    //cpu affinity\n    if (php_swoole_array_get_value(vht, \"open_cpu_affinity\", v))\n    {\n        convert_to_boolean(v);\n        serv->open_cpu_affinity = Z_BVAL_P(v);\n    }\n    //cpu affinity set\n    if (php_swoole_array_get_value(vht, \"cpu_affinity_ignore\", v))\n    {\n        int ignore_num = zend_hash_num_elements(Z_ARRVAL_P(v));\n        if (ignore_num >= SW_CPU_NUM) \n        {\n            swoole_php_fatal_error(E_ERROR, \"cpu_affinity_ignore num must be less than cpu num (%d)\", SW_CPU_NUM);\n            RETURN_FALSE;\n        }\n        int available_num = SW_CPU_NUM - ignore_num;\n        int *available_cpu = (int *) sw_malloc(sizeof(int) * available_num);\n        int flag, i, available_i = 0;\n\n        zval *zval_core = NULL;\n        for (i = 0; i < SW_CPU_NUM; i++)\n        {\n            flag = 1;\n            SW_HASHTABLE_FOREACH_START(Z_ARRVAL_P(v), zval_core)\n                int core = (int) Z_LVAL_P(zval_core);\n                if (i == core)\n                {\n                    flag = 0;\n                    break;\n                }\n            SW_HASHTABLE_FOREACH_END();\n            if (flag)\n            {\n                available_cpu[available_i] = i;\n                available_i++;\n            }\n        }\n        serv->cpu_affinity_available_num = available_num;\n        serv->cpu_affinity_available = available_cpu;\n    }\n    //paser x-www-form-urlencoded form data\n    if (php_swoole_array_get_value(vht, \"http_parse_post\", v))\n    {\n        convert_to_boolean(v);\n        serv->http_parse_post = Z_BVAL_P(v);\n    }\n    /**\n     * buffer input size\n     */\n    if (php_swoole_array_get_value(vht, \"buffer_input_size\", v))\n    {\n        convert_to_long(v);\n        serv->buffer_input_size = (int) Z_LVAL_P(v);\n    }\n    /**\n     * buffer output size\n     */\n    if (php_swoole_array_get_value(vht, \"buffer_output_size\", v))\n    {\n        convert_to_long(v);\n        serv->buffer_output_size = (int) Z_LVAL_P(v);\n    }\n    /**\n     * set pipe memory buffer size\n     */\n    if (php_swoole_array_get_value(vht, \"pipe_buffer_size\", v))\n    {\n        convert_to_long(v);\n        serv->pipe_buffer_size = (int) Z_LVAL_P(v);\n    }\n    //message queue key\n    if (php_swoole_array_get_value(vht, \"message_queue_key\", v))\n    {\n        convert_to_long(v);\n        serv->message_queue_key = (int) Z_LVAL_P(v);\n    }\n\n    zval *retval = NULL;\n    zval *port_object = server_port_list.zobjects[0];\n\n    sw_zval_add_ref(&port_object);\n    sw_zval_add_ref(&zset);\n    sw_zval_add_ref(&zobject);\n\n    sw_zend_call_method_with_1_params(&port_object, swoole_server_port_class_entry_ptr, NULL, \"set\", &retval, zset);\n    zend_update_property(swoole_server_class_entry_ptr, zobject, ZEND_STRL(\"setting\"), zset TSRMLS_CC);\n\n    RETURN_TRUE;\n}\n\nPHP_METHOD(swoole_server, on)\n{\n    zval *name;\n    zval *cb;\n\n    if (SwooleGS->start > 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is running. Unable to set event callback now.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, \"zz\", &name, &cb) == FAILURE)\n    {\n        return;\n    }\n\n#ifdef PHP_SWOOLE_CHECK_CALLBACK\n    char *func_name = NULL;\n#ifdef SW_COROUTINE\n    zend_fcall_info_cache *func_cache = emalloc(sizeof(zend_fcall_info_cache));\n    if (!sw_zend_is_callable_ex(cb, NULL, 0, &func_name, NULL, func_cache, NULL TSRMLS_CC))\n#else\n    if (!sw_zend_is_callable(cb, 0, &func_name TSRMLS_CC))\n#endif\n    {\n        swoole_php_fatal_error(E_ERROR, \"Function '%s' is not callable\", func_name);\n        efree(func_name);\n        return;\n    }\n    efree(func_name);\n#endif\n\n    convert_to_string(name);\n\n    char *callback_name[PHP_SERVER_CALLBACK_NUM] = {\n        \"Connect\",\n        \"Receive\",\n        \"Close\",\n        \"Packet\",\n        \"Start\",\n        \"Shutdown\",\n        \"WorkerStart\",\n        \"WorkerStop\",\n        \"Task\",\n        \"Finish\",\n        \"WorkerError\",\n        \"ManagerStart\",\n        \"ManagerStop\",\n        \"PipeMessage\",\n        NULL,\n        NULL,\n        NULL,\n        NULL,\n    };\n\n    int i;\n    char property_name[128];\n    int l_property_name = 0;\n    memcpy(property_name, \"on\", 2);\n\n    for (i = 0; i < PHP_SERVER_CALLBACK_NUM; i++)\n    {\n        if (callback_name[i] == NULL)\n        {\n            continue;\n        }\n        if (strncasecmp(callback_name[i], Z_STRVAL_P(name), Z_STRLEN_P(name)) == 0)\n        {\n            memcpy(property_name + 2, callback_name[i], Z_STRLEN_P(name));\n            l_property_name = Z_STRLEN_P(name) + 2;\n            property_name[l_property_name] = '\\0';\n            zend_update_property(swoole_server_class_entry_ptr, getThis(), property_name, l_property_name, cb TSRMLS_CC);\n            php_sw_server_callbacks[i] = sw_zend_read_property(swoole_server_class_entry_ptr, getThis(), property_name, l_property_name, 0 TSRMLS_CC);\n            sw_copy_to_stack(php_sw_server_callbacks[i], _php_sw_server_callbacks[i]);\n\n#ifdef SW_COROUTINE\n            php_sw_server_caches[i] = func_cache;\n#endif\n            break;\n        }\n    }\n\n    if (l_property_name == 0)\n    {\n        swoole_php_error(E_WARNING, \"Unknown event types[%s]\", Z_STRVAL_P(name));\n        RETURN_FALSE;\n    }\n\n    if (i < SW_SERVER_CB_onStart)\n    {\n        zval *port_object = server_port_list.zobjects[0];\n        zval *retval = NULL;\n        sw_zval_add_ref(&port_object);\n        sw_zend_call_method_with_2_params(&port_object, swoole_server_port_class_entry_ptr, NULL, \"on\", &retval, name, cb);\n    }\n    else\n    {\n        RETURN_TRUE;\n    }\n}\n\nPHP_METHOD(swoole_server, listen)\n{\n    char *host;\n    zend_size_t host_len;\n    long sock_type;\n    long port;\n\n    if (SwooleGS->start > 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is running. cannot add listener.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"sll\", &host, &host_len, &port, &sock_type) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(getThis());\n    swListenPort *ls = swServer_add_port(serv, (int) sock_type, host, (int) port);\n    if (!ls)\n    {\n        RETURN_FALSE;\n    }\n\n    zval *port_object = php_swoole_server_add_port(ls TSRMLS_CC);\n    RETURN_ZVAL(port_object, 1, NULL);\n}\n\nPHP_METHOD(swoole_server, addProcess)\n{\n    if (SwooleGS->start > 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is running. cannot add process.\");\n        RETURN_FALSE;\n    }\n\n    zval *process = NULL;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z\", &process) == FAILURE)\n    {\n        return;\n    }\n\n    if (ZVAL_IS_NULL(process))\n    {\n        swoole_php_fatal_error(E_WARNING, \"parameter 1 cannot be empty.\");\n        RETURN_FALSE;\n    }\n\n    swServer *serv = swoole_get_object(getThis());\n    if (!instanceof_function(Z_OBJCE_P(process), swoole_process_class_entry_ptr TSRMLS_CC))\n    {\n        swoole_php_fatal_error(E_ERROR, \"object is not instanceof swoole_process.\");\n        RETURN_FALSE;\n    }\n\n    if (serv->onUserWorkerStart == NULL)\n    {\n        serv->onUserWorkerStart = php_swoole_onUserWorkerStart;\n    }\n\n#if PHP_MAJOR_VERSION >= 7\n    zval *tmp_process = emalloc(sizeof(zval));\n    memcpy(tmp_process, process, sizeof(zval));\n    process = tmp_process;\n#endif\n\n    sw_zval_add_ref(&process);\n\n    swWorker *worker = swoole_get_object(process);\n    worker->ptr = process;\n\n    int id = swServer_add_worker(serv, worker);\n    if (id < 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swServer_add_worker failed.\");\n        RETURN_FALSE;\n    }\n    zend_update_property_long(swoole_process_class_entry_ptr, getThis(), ZEND_STRL(\"id\"), id TSRMLS_CC);\n    RETURN_LONG(id);\n}\n\nPHP_METHOD(swoole_server, start)\n{\n    zval *zobject = getThis();\n    int ret;\n\n    if (SwooleGS->start > 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is running. Unable to execute swoole_server::start.\");\n        RETURN_FALSE;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n    php_swoole_register_callback(serv);\n\n    if (php_sw_server_callbacks[SW_SERVER_CB_onReceive] == NULL && php_sw_server_callbacks[SW_SERVER_CB_onPacket] == NULL)\n    {\n        swoole_php_fatal_error(E_ERROR, \"require onReceive/onPacket callback\");\n        RETURN_FALSE;\n    }\n    //-------------------------------------------------------------\n    serv->onReceive = php_swoole_onReceive;\n    serv->ptr2 = zobject;\n\n    php_swoole_server_before_start(serv, zobject TSRMLS_CC);\n\n    ret = swServer_start(serv);\n    if (ret < 0)\n    {\n        swoole_php_fatal_error(E_ERROR, \"start server failed. Error: %s\", sw_error);\n        RETURN_LONG(ret);\n    }\n    RETURN_TRUE;\n}\n\nPHP_METHOD(swoole_server, send)\n{\n    zval *zobject = getThis();\n\n    int ret;\n\n    zval *zfd;\n    zval *zdata;\n    long server_socket = -1;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"zz|l\", &zfd, &zdata, &server_socket) == FAILURE)\n    {\n        return;\n    }\n\n    char *data;\n    int length = php_swoole_get_send_data(zdata, &data TSRMLS_CC);\n\n    if (length < 0)\n    {\n        RETURN_FALSE;\n    }\n    else if (length == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"data is empty.\");\n        RETURN_FALSE;\n    }\n\n   swServer *serv = swoole_get_object(zobject);\n\n    if (serv->have_udp_sock && SW_Z_TYPE_P(zfd) == IS_STRING)\n    {\n        if (server_socket == -1)\n        {\n            server_socket = dgram_server_socket;\n        }\n        //UDP IPv6\n        if (strchr(Z_STRVAL_P(zfd), ':'))\n        {\n            php_swoole_udp_t udp_info;\n            memcpy(&udp_info, &server_socket, sizeof(udp_info));\n            ret = swSocket_udp_sendto6(udp_info.from_fd, Z_STRVAL_P(zfd), udp_info.port, data, length);\n        }\n        //UNIX DGRAM\n        else if (Z_STRVAL_P(zfd)[0] == '/')\n        {\n            struct sockaddr_un addr_un;\n            memcpy(addr_un.sun_path, Z_STRVAL_P(zfd), Z_STRLEN_P(zfd));\n            addr_un.sun_family = AF_UNIX;\n            addr_un.sun_path[Z_STRLEN_P(zfd)] = 0;\n            ret = swSocket_sendto_blocking(server_socket, data, length, 0, (struct sockaddr *) &addr_un, sizeof(addr_un));\n        }\n        else\n        {\n            goto convert;\n        }\n        SW_CHECK_RETURN(ret);\n    }\n\n    convert: convert_to_long(zfd);\n    uint32_t fd = (uint32_t) Z_LVAL_P(zfd);\n    //UDP\n    if (swServer_is_udp(fd))\n    {\n        if (server_socket == -1)\n        {\n            server_socket = udp_server_socket;\n        }\n\n        php_swoole_udp_t udp_info;\n        memcpy(&udp_info, &server_socket, sizeof(udp_info));\n\n        struct sockaddr_in addr_in;\n        addr_in.sin_family = AF_INET;\n        addr_in.sin_port = htons(udp_info.port);\n        addr_in.sin_addr.s_addr = fd;\n        ret = swSocket_sendto_blocking(udp_info.from_fd, data, length, 0, (struct sockaddr *) &addr_in, sizeof(addr_in));\n        SW_CHECK_RETURN(ret);\n    }\n    //TCP\n    else\n    {\n        SW_CHECK_RETURN(swServer_tcp_send(serv, fd, data, length));\n    }\n}\n\nPHP_METHOD(swoole_server, sendto)\n{\n    zval *zobject = getThis();\n\n    char *ip;\n    char *data;\n    zend_size_t len, ip_len;\n\n    long port;\n    long server_socket = -1;\n    zend_bool ipv6 = 0;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"sls|l\", &ip, &ip_len, &port, &data, &len, &server_socket) == FAILURE)\n    {\n        return;\n    }\n\n    if (len <= 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"data is empty.\");\n        RETURN_FALSE;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n\n    if (strchr(ip, ':'))\n    {\n        ipv6 = 1;\n    }\n\n    if (ipv6 == 0 && serv->udp_socket_ipv4 <= 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"You must add an UDP listener to server before using sendto.\");\n        RETURN_FALSE;\n    }\n    else if (ipv6 == 1 && serv->udp_socket_ipv6 <= 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"You must add an UDP6 listener to server before using sendto.\");\n        RETURN_FALSE;\n    }\n\n    if (server_socket < 0)\n    {\n        server_socket = ipv6 ?  serv->udp_socket_ipv6 : serv->udp_socket_ipv4;\n    }\n\n    int ret;\n    if (ipv6)\n    {\n        ret = swSocket_udp_sendto6(server_socket, ip, port, data, len);\n    }\n    else\n    {\n        ret = swSocket_udp_sendto(server_socket, ip, port, data, len);\n    }\n    SW_CHECK_RETURN(ret);\n}\n\nPHP_METHOD(swoole_server, sendfile)\n{\n    zval *zobject = getThis();\n    zend_size_t len;\n\n    char *filename;\n    long fd;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ls\", &fd, &filename, &len) == FAILURE)\n    {\n        return;\n    }\n\n    //check fd\n    if (fd <= 0 || fd > SW_MAX_SOCKET_ID)\n    {\n        swoole_error_log(SW_LOG_WARNING, SW_ERROR_SESSION_INVALID_ID, \"invalid fd[%ld].\", fd);\n        RETURN_FALSE;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n    SW_CHECK_RETURN(swServer_tcp_sendfile(serv, (int) fd, filename, len));\n}\n\nPHP_METHOD(swoole_server, close)\n{\n    zval *zobject = getThis();\n    zend_bool reset = SW_FALSE;\n    long fd;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (swIsMaster())\n    {\n        swoole_php_fatal_error(E_WARNING, \"Cannot close connection in master process.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l|b\", &fd, &reset) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n    swConnection *conn = swServer_connection_verify_no_ssl(serv, fd);\n    if (!conn)\n    {\n        RETURN_FALSE;\n    }\n\n    //Reset send buffer, Immediately close the connection.\n    if (reset)\n    {\n        conn->close_reset = 1;\n    }\n\n    int ret;\n    if (!swIsWorker())\n    {\n        swWorker *worker = swServer_get_worker(serv, conn->fd % serv->worker_num);\n        swDataHead ev;\n        ev.type = SW_EVENT_CLOSE;\n        ev.fd = fd;\n        ev.from_id = conn->from_id;\n        ret = swWorker_send2worker(worker, &ev, sizeof(ev), SW_PIPE_MASTER);\n    }\n    else\n    {\n        ret = serv->factory.end(&serv->factory, fd);\n    }\n    SW_CHECK_RETURN(ret);\n}\n\nPHP_METHOD(swoole_server, confirm)\n{\n    zval *zobject = getThis();\n    long fd;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (swIsMaster())\n    {\n        swoole_php_fatal_error(E_WARNING, \"Cannot confirm connection in master process.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &fd) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n    SW_CHECK_RETURN(swServer_confirm(serv, fd));\n}\n\nPHP_METHOD(swoole_server, stats)\n{\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    array_init(return_value);\n    sw_add_assoc_long_ex(return_value, ZEND_STRS(\"start_time\"), SwooleStats->start_time);\n    sw_add_assoc_long_ex(return_value, ZEND_STRS(\"connection_num\"), SwooleStats->connection_num);\n    sw_add_assoc_long_ex(return_value, ZEND_STRS(\"accept_count\"), SwooleStats->accept_count);\n    sw_add_assoc_long_ex(return_value, ZEND_STRS(\"close_count\"), SwooleStats->close_count);\n    sw_add_assoc_long_ex(return_value, ZEND_STRS(\"tasking_num\"), SwooleStats->tasking_num);\n    sw_add_assoc_long_ex(return_value, ZEND_STRS(\"request_count\"), SwooleStats->request_count);\n    sw_add_assoc_long_ex(return_value, ZEND_STRS(\"worker_request_count\"), SwooleWG.request_count);\n\n    if (SwooleG.task_ipc_mode > SW_IPC_UNSOCK && SwooleGS->task_workers.queue)\n    {\n        int queue_num = -1;\n        int queue_bytes = -1;\n        if (swMsgQueue_stat(SwooleGS->task_workers.queue, &queue_num, &queue_bytes) == 0)\n        {\n            sw_add_assoc_long_ex(return_value, ZEND_STRS(\"task_queue_num\"), queue_num);\n            sw_add_assoc_long_ex(return_value, ZEND_STRS(\"task_queue_bytes\"), queue_bytes);\n        }\n    }\n}\n\nPHP_METHOD(swoole_server, reload)\n{\n    zend_bool only_reload_taskworker = 0;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|b\", &only_reload_taskworker) == FAILURE)\n    {\n        return;\n    }\n\n    int sig = only_reload_taskworker ? SIGUSR2 : SIGUSR1;\n    if (kill(SwooleGS->manager_pid, sig) < 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"kill() failed. Error: %s[%d]\", strerror(errno), errno);\n        RETURN_FALSE;\n    }\n    RETURN_TRUE;\n}\n\nPHP_METHOD(swoole_server, heartbeat)\n{\n    zval *zobject = getThis();\n\n    zend_bool close_connection = 0;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|b\", &close_connection) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n\n    if (serv->heartbeat_idle_time < 1)\n    {\n        RETURN_FALSE;\n    }\n\n    int serv_max_fd = swServer_get_maxfd(serv);\n    int serv_min_fd = swServer_get_minfd(serv);\n\n    array_init(return_value);\n\n    int fd;\n    int checktime = (int) SwooleGS->now - serv->heartbeat_idle_time;\n    swConnection *conn;\n\n    for (fd = serv_min_fd; fd <= serv_max_fd; fd++)\n    {\n        swTrace(\"heartbeat check fd=%d\", fd);\n        conn = &serv->connection_list[fd];\n\n        if (1 == conn->active && conn->last_time < checktime)\n        {\n            conn->close_force = 1;\n            /**\n             * Close the connection\n             */\n            if (close_connection)\n            {\n                serv->factory.end(&serv->factory, fd);\n            }\n#ifdef SW_REACTOR_USE_SESSION\n            add_next_index_long(return_value, conn->session_id);\n#else\n            add_next_index_long(return_value, fd);\n#endif\n        }\n    }\n}\n\nPHP_METHOD(swoole_server, taskwait)\n{\n    swEventData buf;\n    zval *data;\n\n    double timeout = SW_TASKWAIT_TIMEOUT;\n    long dst_worker_id = -1;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z|dl\", &data, &timeout, &dst_worker_id) == FAILURE)\n    {\n        return;\n    }\n\n    if (php_swoole_check_task_param(dst_worker_id TSRMLS_CC) < 0)\n    {\n        RETURN_FALSE;\n    }\n\n    php_swoole_task_pack(&buf, data TSRMLS_CC);\n\n    uint64_t notify;\n    swEventData *task_result = &(SwooleG.task_result[SwooleWG.id]);\n    bzero(task_result, sizeof(swEventData));\n    swPipe *task_notify_pipe = &SwooleG.task_notify[SwooleWG.id];\n    int efd = task_notify_pipe->getFd(task_notify_pipe, 0);\n\n    //clear history task\n    while (read(efd, &notify, sizeof(notify)) > 0);\n\n    if (swProcessPool_dispatch_blocking(&SwooleGS->task_workers, &buf, (int*) &dst_worker_id) >= 0)\n    {\n        sw_atomic_fetch_add(&SwooleStats->tasking_num, 1);\n        task_notify_pipe->timeout = timeout;\n        int ret = task_notify_pipe->read(task_notify_pipe, &notify, sizeof(notify));\n        if (ret > 0)\n        {\n            zval *task_notify_data = php_swoole_get_task_result(task_result TSRMLS_CC);\n            RETURN_ZVAL(task_notify_data, 0, 0);\n        }\n        else\n        {\n            swoole_php_fatal_error(E_WARNING, \"taskwait failed. Error: %s[%d]\", strerror(errno), errno);\n        }\n    }\n    RETURN_FALSE;\n}\n\nPHP_METHOD(swoole_server, taskWaitMulti)\n{\n    swEventData buf;\n    zval *tasks;\n    zval *task;\n    double timeout = SW_TASKWAIT_TIMEOUT;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z|d\", &tasks, &timeout) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(getThis());\n    array_init(return_value);\n\n    int dst_worker_id;\n    int task_id;\n    int i = 0;\n    int n_task = Z_ARRVAL_P(tasks)->nNumOfElements;\n\n    int list_of_id[1024];\n\n    uint64_t notify;\n    swEventData *task_result = &(SwooleG.task_result[SwooleWG.id]);\n    bzero(task_result, sizeof(swEventData));\n    swPipe *task_notify_pipe = &SwooleG.task_notify[SwooleWG.id];\n    swWorker *worker = swServer_get_worker(serv, SwooleWG.id);\n\n    char _tmpfile[sizeof(SW_TASK_TMP_FILE)] = SW_TASK_TMP_FILE;\n    int _tmpfile_fd = swoole_tmpfile(_tmpfile);\n    if (_tmpfile_fd < 0)\n    {\n        swoole_php_sys_error(E_WARNING, \"mktemp(%s) failed.\", SW_TASK_TMP_FILE);\n        RETURN_FALSE;\n    }\n    close(_tmpfile_fd);\n    int *finish_count = (int *) task_result->data;\n\n    worker->lock.lock(&worker->lock);\n    *finish_count = 0;\n    memcpy(task_result->data + 4, _tmpfile, sizeof(_tmpfile));\n    worker->lock.unlock(&worker->lock);\n\n    //clear history task\n    int efd = task_notify_pipe->getFd(task_notify_pipe, 0);\n    while (read(efd, &notify, sizeof(notify)) > 0);\n\n    SW_HASHTABLE_FOREACH_START(Z_ARRVAL_P(tasks), task)\n        task_id = php_swoole_task_pack(&buf, task TSRMLS_CC);\n        if (task_id < 0)\n        {\n            swoole_php_fatal_error(E_WARNING, \"task pack failed.\");\n            goto fail;\n        }\n        swTask_type(&buf) |= SW_TASK_WAITALL;\n        dst_worker_id = -1;\n        if (swProcessPool_dispatch_blocking(&SwooleGS->task_workers, &buf, (int*) &dst_worker_id) >= 0)\n        {\n            sw_atomic_fetch_add(&SwooleStats->tasking_num, 1);\n            list_of_id[i] = task_id;\n        }\n        else\n        {\n            swoole_php_fatal_error(E_WARNING, \"taskwait failed. Error: %s[%d]\", strerror(errno), errno);\n            fail:\n            add_index_bool(return_value, i, 0);\n            n_task --;\n        }\n        i++;\n    SW_HASHTABLE_FOREACH_END();\n\n    while (n_task > 0)\n    {\n        task_notify_pipe->timeout = timeout;\n        int ret = task_notify_pipe->read(task_notify_pipe, &notify, sizeof(notify));\n        if (ret > 0)\n        {\n            if (*finish_count == n_task)\n            {\n                break;\n            }\n        }\n        else\n        {\n            swoole_php_fatal_error(E_WARNING, \"taskwait failed. Error: %s[%d]\", strerror(errno), errno);\n            unlink(_tmpfile);\n            RETURN_FALSE;\n        }\n    }\n\n    swString *content = swoole_file_get_contents(_tmpfile);\n    if (content == NULL)\n    {\n        return;\n    }\n\n    swEventData *result;\n    zval *zdata;\n    int j;\n\n    for (i = 0; i < n_task; i++)\n    {\n        result = (swEventData *) (content->str + content->offset);\n        task_id = result->info.fd;\n        zdata = php_swoole_get_task_result(result TSRMLS_CC);\n        for (j = 0; j < n_task; j++)\n        {\n            if (list_of_id[j] == task_id)\n            {\n                break;\n            }\n        }\n        add_index_zval(return_value, j, zdata);\n        content->offset += sizeof(swDataHead) + result->info.len;\n    }\n    unlink(_tmpfile);\n}\n\nPHP_METHOD(swoole_server, task)\n{\n    swEventData buf;\n    zval *data;\n    zval *callback = NULL;\n\n    long dst_worker_id = -1;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z|lz\", &data, &dst_worker_id, &callback) == FAILURE)\n    {\n        return;\n    }\n\n    if (php_swoole_check_task_param(dst_worker_id TSRMLS_CC) < 0)\n    {\n        RETURN_FALSE;\n    }\n\n    if (php_swoole_task_pack(&buf, data TSRMLS_CC) < 0)\n    {\n        RETURN_FALSE;\n    }\n\n    if (callback && !ZVAL_IS_NULL(callback))\n    {\n#ifdef PHP_SWOOLE_CHECK_CALLBACK\n        char *func_name = NULL;\n        if (!sw_zend_is_callable(callback, 0, &func_name TSRMLS_CC))\n        {\n            swoole_php_fatal_error(E_WARNING, \"Function '%s' is not callable\", func_name);\n            efree(func_name);\n            return;\n        }\n        efree(func_name);\n#endif\n        swTask_type(&buf) |= SW_TASK_CALLBACK;\n        sw_zval_add_ref(&callback);\n        swHashMap_add_int(task_callbacks, buf.info.fd, sw_zval_dup(callback));\n    }\n\n    swTask_type(&buf) |= SW_TASK_NONBLOCK;\n    if (swProcessPool_dispatch(&SwooleGS->task_workers, &buf, (int*) &dst_worker_id) >= 0)\n    {\n        sw_atomic_fetch_add(&SwooleStats->tasking_num, 1);\n        RETURN_LONG(buf.info.fd);\n    }\n    else\n    {\n        RETURN_FALSE;\n    }\n}\n\nPHP_METHOD(swoole_server, sendMessage)\n{\n    zval *zobject = getThis();\n    swEventData buf;\n\n    char *msg;\n    zend_size_t msglen;\n    long worker_id = -1;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"sl\", &msg, &msglen, &worker_id) == FAILURE)\n    {\n        return;\n    }\n\n    if (worker_id == SwooleWG.id)\n    {\n        swoole_php_fatal_error(E_WARNING, \"cannot send message to self.\");\n        RETURN_FALSE;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n    if (worker_id >= serv->worker_num + SwooleG.task_worker_num)\n    {\n        swoole_php_fatal_error(E_WARNING, \"worker_id[%d] is invalid.\", (int) worker_id);\n        RETURN_FALSE;\n    }\n\n    if (!serv->onPipeMessage)\n    {\n        swoole_php_fatal_error(E_WARNING, \"onPipeMessage is null, cannot use sendMessage.\");\n        RETURN_FALSE;\n    }\n\n    buf.info.type = SW_EVENT_PIPE_MESSAGE;\n    buf.info.from_id = SwooleWG.id;\n\n    //write to file\n    if (msglen >= SW_IPC_MAX_SIZE - sizeof(buf.info))\n    {\n        if (swTaskWorker_large_pack(&buf, msg, msglen) < 0)\n        {\n            swoole_php_fatal_error(E_WARNING, \"large task pack failed()\");\n            RETURN_FALSE;\n        }\n    }\n    else\n    {\n        memcpy(buf.data, msg, msglen);\n        buf.info.len = msglen;\n        buf.info.from_fd = 0;\n    }\n\n    swWorker *to_worker = swServer_get_worker(serv, worker_id);\n    SW_CHECK_RETURN(swWorker_send2worker(to_worker, &buf, sizeof(buf.info) + buf.info.len, SW_PIPE_MASTER | SW_PIPE_NONBLOCK));\n}\n\nPHP_METHOD(swoole_server, finish)\n{\n    zval *zobject = getThis();\n    zval *data;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z\", &data) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n    SW_CHECK_RETURN(php_swoole_task_finish(serv, data TSRMLS_CC));\n}\n\nPHP_METHOD(swoole_server, bind)\n{\n    zval *zobject = getThis();\n\n    long fd = 0;\n    long uid = 0;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ll\", &fd, &uid) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n\n    swConnection *conn = swWorker_get_connection(serv, fd);\n\n    //udp client\n    if (conn == NULL)\n    {\n        swTrace(\"%ld conn error\", fd);\n        RETURN_FALSE;\n    }\n\n    //connection is closed\n    if (conn->active == 0)\n    {\n        swTrace(\"fd:%ld a:%d, uid: %ld\", fd, conn->active, conn->uid);\n        RETURN_FALSE;\n    }\n\n    if (conn->uid != 0)\n    {\n        RETURN_FALSE;\n    }\n\n    int ret = 0;\n    SwooleGS->lock.lock(&SwooleGS->lock);\n    if (conn->uid == 0)\n    {\n        conn->uid = uid;\n        ret = 1;\n    }\n    SwooleGS->lock.unlock(&SwooleGS->lock);\n    SW_CHECK_RETURN(ret);\n}\n\n#ifdef SWOOLE_SOCKETS_SUPPORT\nPHP_METHOD(swoole_server, getSocket)\n{\n    long port = 0;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|l\", &port) == FAILURE)\n    {\n        return;\n    }\n\n    zval *zobject = getThis();\n    swServer *serv = swoole_get_object(zobject);\n\n    int sock = swServer_get_socket(serv, port);\n    php_socket *socket_object = swoole_convert_to_socket(sock);\n\n    if (!socket_object)\n    {\n        RETURN_FALSE;\n    }\n    SW_ZEND_REGISTER_RESOURCE(return_value, (void *) socket_object, php_sockets_le_socket());\n}\n#endif\n\nPHP_METHOD(swoole_server, connection_info)\n{\n    zval *zobject = getThis();\n\n    zend_bool noCheckConnection = 0;\n    zval *zfd;\n    long from_id = -1;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z|lb\", &zfd, &from_id, &noCheckConnection) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n\n    long fd = 0;\n    zend_bool ipv6_udp = 0;\n\n    //ipv6 udp\n    if (SW_Z_TYPE_P(zfd) == IS_STRING)\n    {\n        if (is_numeric_string(Z_STRVAL_P(zfd), Z_STRLEN_P(zfd), &fd, NULL, 0))\n        {\n            ipv6_udp = 0;\n        }\n        else\n        {\n            fd = 0;\n            ipv6_udp = 1;\n        }\n    }\n    else\n    {\n        convert_to_long(zfd);\n        fd = Z_LVAL_P(zfd);\n    }\n\n    //udp\n    if (ipv6_udp || swServer_is_udp(fd))\n    {\n        array_init(return_value);\n\n        if (ipv6_udp)\n        {\n            add_assoc_zval(return_value, \"remote_ip\", zfd);\n        }\n        else\n        {\n            struct in_addr sin_addr;\n            sin_addr.s_addr = fd;\n            sw_add_assoc_string(return_value, \"remote_ip\", inet_ntoa(sin_addr), 1);\n        }\n\n        if (from_id == 0)\n        {\n            return;\n        }\n\n        php_swoole_udp_t udp_info;\n        memcpy(&udp_info, &from_id, sizeof(udp_info));\n        //server socket\n        swConnection *from_sock = swServer_connection_get(serv, udp_info.from_fd);\n        if (from_sock)\n        {\n            add_assoc_long(return_value, \"server_fd\", from_sock->fd);\n            add_assoc_long(return_value, \"socket_type\", from_sock->socket_type);\n            add_assoc_long(return_value, \"server_port\", swConnection_get_port(from_sock));\n        }\n        add_assoc_long(return_value, \"remote_port\", udp_info.port);\n        return;\n    }\n\n    swConnection *conn = swServer_connection_verify(serv, fd);\n    if (!conn)\n    {\n        RETURN_FALSE;\n    }\n    //connection is closed\n    if (conn->active == 0 && !noCheckConnection)\n    {\n        RETURN_FALSE;\n    }\n    else\n    {\n        array_init(return_value);\n\n        if (serv->dispatch_mode == SW_DISPATCH_UIDMOD)\n        {\n            add_assoc_long(return_value, \"uid\", conn->uid);\n        }\n\n        swListenPort *port = swServer_get_port(serv, conn->fd);\n        if (port && port->open_websocket_protocol)\n        {\n            add_assoc_long(return_value, \"websocket_status\", conn->websocket_status);\n        }\n\n#ifdef SW_USE_OPENSSL\n        if (conn->ssl_client_cert.length > 0)\n        {\n            sw_add_assoc_stringl(return_value, \"ssl_client_cert\", conn->ssl_client_cert.str, conn->ssl_client_cert.length - 1, 1);\n        }\n#endif\n        //server socket\n        swConnection *from_sock = swServer_connection_get(serv, conn->from_fd);\n        if (from_sock)\n        {\n            add_assoc_long(return_value, \"server_port\", swConnection_get_port(from_sock));\n        }\n        add_assoc_long(return_value, \"server_fd\", conn->from_fd);\n        add_assoc_long(return_value, \"socket_type\", conn->socket_type);\n        add_assoc_long(return_value, \"remote_port\", swConnection_get_port(conn));\n        sw_add_assoc_string(return_value, \"remote_ip\", swConnection_get_ip(conn), 1);\n        add_assoc_long(return_value, \"from_id\", conn->from_id);\n        add_assoc_long(return_value, \"connect_time\", conn->connect_time);\n        add_assoc_long(return_value, \"last_time\", conn->last_time);\n        add_assoc_long(return_value, \"close_errno\", conn->close_errno);\n    }\n}\n\nPHP_METHOD(swoole_server, connection_list)\n{\n    zval *zobject = getThis();\n\n    long start_fd = 0;\n    long find_count = 10;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|ll\", &start_fd, &find_count) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n\n    //\u8d85\u8fc7\u6700\u5927\u67e5\u627e\u6570\u91cf\n    if (find_count > SW_MAX_FIND_COUNT)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_connection_list max_find_count=%d\", SW_MAX_FIND_COUNT);\n        RETURN_FALSE;\n    }\n\n    //\u590d\u5236\u51fa\u6765\u907f\u514d\u88ab\u5176\u4ed6\u8fdb\u7a0b\u6539\u5199\n    int serv_max_fd = swServer_get_maxfd(serv);\n\n    if (start_fd == 0)\n    {\n        start_fd = swServer_get_minfd(serv);\n    }\n#ifdef SW_REACTOR_USE_SESSION\n    else\n    {\n        swConnection *conn = swWorker_get_connection(serv, start_fd);\n        if (!conn)\n        {\n            RETURN_FALSE;\n        }\n        start_fd = conn->fd;\n    }\n#endif\n\n    //\u8fbe\u5230\u6700\u5927\uff0c\u8868\u793a\u5df2\u7ecf\u53d6\u5b8c\u4e86\n    if ((int) start_fd >= serv_max_fd)\n    {\n        RETURN_FALSE;\n    }\n\n    array_init(return_value);\n    int fd = start_fd + 1;\n    swConnection *conn;\n\n    for (; fd <= serv_max_fd; fd++)\n    {\n        swTrace(\"maxfd=%d, fd=%d, find_count=%ld, start_fd=%ld\", serv_max_fd, fd, find_count, start_fd);\n        conn = &serv->connection_list[fd];\n\n        if (conn->active && !conn->closed)\n        {\n#ifdef SW_REACTOR_USE_SESSION\n            add_next_index_long(return_value, conn->session_id);\n#else\n            add_next_index_long(return_value, fd);\n#endif\n            find_count--;\n        }\n        //finish fetch\n        if (find_count <= 0)\n        {\n            break;\n        }\n    }\n}\n\nPHP_METHOD(swoole_server, sendwait)\n{\n    zval *zobject = getThis();\n\n    long fd;\n    zval *zdata;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"lz\", &fd, &zdata) == FAILURE)\n    {\n        return;\n    }\n\n    char *data;\n    int length = php_swoole_get_send_data(zdata, &data TSRMLS_CC);\n\n    if (length < 0)\n    {\n        RETURN_FALSE;\n    }\n    else if (length == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"data is empty.\");\n        RETURN_FALSE;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n\n    if (serv->factory_mode != SW_MODE_SINGLE || swIsTaskWorker())\n    {\n        swoole_php_fatal_error(E_WARNING, \"cannot sendwait.\");\n        RETURN_FALSE;\n    }\n\n    //UDP\n    if (swServer_is_udp(fd))\n    {\n        swoole_php_fatal_error(E_WARNING, \"cannot sendwait.\");\n        RETURN_FALSE;\n    }\n    //TCP\n    else\n    {\n        SW_CHECK_RETURN(swServer_tcp_sendwait(serv, fd, data, length));\n    }\n}\n\nPHP_METHOD(swoole_server, exist)\n{\n    zval *zobject = getThis();\n\n    long fd;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &fd) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n\n    swConnection *conn = swWorker_get_connection(serv, fd);\n    if (!conn)\n    {\n        RETURN_FALSE;\n    }\n    //connection is closed\n    if (conn->active == 0 || conn->closed)\n    {\n        RETURN_FALSE;\n    }\n    else\n    {\n        RETURN_TRUE;\n    }\n}\n\nPHP_METHOD(swoole_server, protect)\n{\n    long fd;\n    zend_bool value = 1;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l|b\", &fd, &value) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(getThis());\n\n    swConnection *conn = swWorker_get_connection(serv, fd);\n    if (!conn)\n    {\n        RETURN_FALSE;\n    }\n    //connection is closed\n    if (conn->active == 0 || conn->closed)\n    {\n        RETURN_FALSE;\n    }\n    else\n    {\n        conn->protect = value;\n        RETURN_TRUE;\n    }\n}\n\nPHP_METHOD(swoole_server, shutdown)\n{\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (kill(SwooleGS->master_pid, SIGTERM) < 0)\n    {\n        swoole_php_sys_error(E_WARNING, \"shutdown failed. kill(%d, SIGTERM) failed.\", SwooleGS->master_pid);\n        RETURN_FALSE;\n    }\n    else\n    {\n        RETURN_TRUE;\n    }\n}\n\nPHP_METHOD(swoole_server, stop)\n{\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    long worker_id = SwooleWG.id;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|l\", &worker_id) == FAILURE)\n    {\n        return;\n    }\n\n    if (worker_id == SwooleWG.id)\n    {\n        SwooleG.main_reactor->running = 0;\n        SwooleG.running = 0;\n    }\n    else\n    {\n        swWorker *worker = swServer_get_worker(SwooleG.serv, worker_id);\n        if (worker == NULL)\n        {\n            RETURN_FALSE;\n        }\n        else if (kill(worker->pid, SIGTERM) < 0)\n        {\n            swoole_php_sys_error(E_WARNING, \"kill(%d, SIGTERM) failed.\", worker->pid);\n            RETURN_FALSE;\n        }\n    }\n    RETURN_TRUE;\n}\n\nPHP_METHOD(swoole_server, getLastError)\n{\n    RETURN_LONG(SwooleG.error);\n}\n\n#ifdef HAVE_PCRE\nstatic struct\n{\n    int current_fd;\n    int max_fd;\n    uint32_t session_id;\n    int end;\n    int index;\n} server_itearator;\n\nPHP_METHOD(swoole_connection_iterator, rewind)\n{\n    bzero(&server_itearator, sizeof(server_itearator));\n    server_itearator.current_fd = swServer_get_minfd(SwooleG.serv);\n}\n\nPHP_METHOD(swoole_connection_iterator, valid)\n{\n    int fd = server_itearator.current_fd;\n    swConnection *conn;\n\n    int max_fd = swServer_get_maxfd(SwooleG.serv);\n    for (; fd <= max_fd; fd++)\n    {\n        conn = &SwooleG.serv->connection_list[fd];\n\n        if (conn->active && !conn->closed)\n        {\n#ifdef SW_USE_OPENSSL\n            if (conn->ssl && conn->ssl_state != SW_SSL_STATE_READY)\n            {\n                continue;\n            }\n#endif\n            server_itearator.session_id = conn->session_id;\n            server_itearator.current_fd = fd;\n            server_itearator.index++;\n            RETURN_TRUE;\n        }\n    }\n\n    RETURN_FALSE;\n}\n\nPHP_METHOD(swoole_connection_iterator, current)\n{\n    RETURN_LONG(server_itearator.session_id);\n}\n\nPHP_METHOD(swoole_connection_iterator, next)\n{\n    server_itearator.current_fd ++;\n}\n\nPHP_METHOD(swoole_connection_iterator, key)\n{\n    RETURN_LONG(server_itearator.index);\n}\n\nPHP_METHOD(swoole_connection_iterator, count)\n{\n    RETURN_LONG(SwooleStats->connection_num);\n}\n#endif\n\n/*\n * Local variables:\n * tab-width: 4\n * c-basic-offset: 4\n * End:\n * vim600: noet sw=4 ts=4 fdm=marker\n * vim<600: noet sw=4 ts=4\n */",
        "res_region": "/*\n  +----------------------------------------------------------------------+\n  | Swoole                                                               |\n  +----------------------------------------------------------------------+\n  | This source file is subject to version 2.0 of the Apache license,    |\n  | that is bundled with this package in the file LICENSE, and is        |\n  | available through the world-wide-web at the following url:           |\n  | http://www.apache.org/licenses/LICENSE-2.0.html                      |\n  | If you did not receive a copy of the Apache2.0 license and are unable|\n  | to obtain it through the world-wide-web, please send a note to       |\n  | license@swoole.com so we can mail you a copy immediately.            |\n  +----------------------------------------------------------------------+\n  | Author: Tianfeng Han  <mikan.tenny@gmail.com>                        |\n  +----------------------------------------------------------------------+\n */\n\n#include \"php_swoole.h\"\n\n#include \"Connection.h\"\n\n#ifdef SW_COROUTINE\n#include \"swoole_coroutine.h\"\n#endif\n#include \"ext/standard/php_var.h\"\n#if PHP_MAJOR_VERSION < 7\n#include \"ext/standard/php_smart_str.h\"\n#else\n#include \"zend_smart_str.h\"\n#endif\n\nstatic int php_swoole_task_id;\nstatic int udp_server_socket;\nstatic int dgram_server_socket;\n\nstatic struct\n{\n    zval *zobjects[SW_MAX_LISTEN_PORT];\n    zval *zports;\n    uint8_t num;\n} server_port_list;\n\nzval *php_sw_server_callbacks[PHP_SERVER_CALLBACK_NUM];\n#ifdef SW_COROUTINE\nzend_fcall_info_cache *php_sw_server_caches[PHP_SERVER_CALLBACK_NUM];\n#endif\n\nstatic swHashMap *task_callbacks;\n\n#if PHP_MAJOR_VERSION >= 7\nzval _php_sw_server_callbacks[PHP_SERVER_CALLBACK_NUM];\n#endif\n\nstatic int php_swoole_task_finish(swServer *serv, zval *data TSRMLS_DC);\nstatic void php_swoole_onPipeMessage(swServer *serv, swEventData *req);\nstatic void php_swoole_onStart(swServer *);\nstatic void php_swoole_onShutdown(swServer *);\n\nstatic int php_swoole_onPacket(swServer *, swEventData *);\n\nstatic void php_swoole_onWorkerStart(swServer *, int worker_id);\nstatic void php_swoole_onWorkerStop(swServer *, int worker_id);\nstatic void php_swoole_onUserWorkerStart(swServer *serv, swWorker *worker);\nstatic int php_swoole_onTask(swServer *, swEventData *task);\nstatic int php_swoole_onFinish(swServer *, swEventData *task);\nstatic void php_swoole_onWorkerError(swServer *serv, int worker_id, pid_t worker_pid, int exit_code, int signo);\nstatic void php_swoole_onManagerStart(swServer *serv);\nstatic void php_swoole_onManagerStop(swServer *serv);\n\nstatic zval* php_swoole_server_add_port(swListenPort *port TSRMLS_DC);\nstatic zval* php_swoole_get_task_result(swEventData *task_result TSRMLS_DC);\n\nstatic sw_inline int php_swoole_task_pack(swEventData *task, zval *data TSRMLS_DC)\n{\n    smart_str serialized_data = { 0 };\n    php_serialize_data_t var_hash;\n\n    task->info.type = SW_EVENT_TASK;\n    //field fd save task_id\n    task->info.fd = php_swoole_task_id++;\n    //field from_id save the worker_id\n    task->info.from_id = SwooleWG.id;\n    swTask_type(task) = 0;\n\n    char *task_data_str;\n    int task_data_len = 0;\n    //need serialize\n    if (SW_Z_TYPE_P(data) != IS_STRING)\n    {\n        //serialize\n        swTask_type(task) |= SW_TASK_SERIALIZE;\n        PHP_VAR_SERIALIZE_INIT(var_hash);\n        sw_php_var_serialize(&serialized_data, data, &var_hash TSRMLS_CC);\n        PHP_VAR_SERIALIZE_DESTROY(var_hash);\n#if PHP_MAJOR_VERSION<7\n        task_data_str = serialized_data.c;\n        task_data_len = serialized_data.len;\n#else\n        task_data_str = serialized_data.s->val;\n        task_data_len = serialized_data.s->len;\n#endif\n    }\n    else\n    {\n        task_data_str = Z_STRVAL_P(data);\n        task_data_len = Z_STRLEN_P(data);\n    }\n\n    if (task_data_len >= SW_IPC_MAX_SIZE - sizeof(task->info))\n    {\n        if (swTaskWorker_large_pack(task, task_data_str, task_data_len) < 0)\n        {\n            smart_str_free(&serialized_data);\n            swoole_php_fatal_error(E_WARNING, \"large task pack failed()\");\n            return SW_ERR;\n        }\n    }\n    else\n    {\n        memcpy(task->data, task_data_str, task_data_len);\n        task->info.len = task_data_len;\n    }\n    smart_str_free(&serialized_data);\n    return task->info.fd;\n}\n\nvoid php_swoole_get_recv_data(zval *zdata, swEventData *req, char *header, uint32_t header_length)\n{\n    char *data_ptr = NULL;\n    int data_len;\n\n#ifdef SW_USE_RINGBUFFER\n    swPackage package;\n    if (req->info.type == SW_EVENT_PACKAGE)\n    {\n        memcpy(&package, req->data, sizeof (package));\n\n        data_ptr = package.data;\n        data_len = package.length;\n    }\n#else\n    if (req->info.type == SW_EVENT_PACKAGE_END)\n    {\n        swString *worker_buffer = swWorker_get_buffer(SwooleG.serv, req->info.from_id);\n        data_ptr = worker_buffer->str;\n        data_len = worker_buffer->length;\n    }\n#endif\n    else\n    {\n        data_ptr = req->data;\n        data_len = req->info.len;\n    }\n\n    if (header_length >= data_len)\n    {\n        SW_ZVAL_STRING(zdata, \"\", 1);\n    }\n    else\n    {\n        SW_ZVAL_STRINGL(zdata, data_ptr + header_length, data_len - header_length, 1);\n    }\n\n    if (header_length > 0)\n    {\n        memcpy(header, data_ptr, header_length);\n    }\n\n#ifdef SW_USE_RINGBUFFER\n    if (req->info.type == SW_EVENT_PACKAGE)\n    {\n        swReactorThread *thread = swServer_get_thread(SwooleG.serv, req->info.from_id);\n        thread->buffer_input->free(thread->buffer_input, data_ptr);\n    }\n#endif\n}\n\nint php_swoole_get_send_data(zval *zdata, char **str TSRMLS_DC)\n{\n    int length;\n\n    if (SW_Z_TYPE_P(zdata) == IS_OBJECT)\n    {\n        if (!instanceof_function(Z_OBJCE_P(zdata), swoole_buffer_class_entry_ptr TSRMLS_CC))\n        {\n            goto convert;\n        }\n        swString *str_buffer = swoole_get_object(zdata);\n        if (!str_buffer->str)\n        {\n            swoole_php_fatal_error(E_WARNING, \"swoole_buffer object is empty.\");\n            return SW_ERR;\n        }\n        length = str_buffer->length - str_buffer->offset;\n        *str = str_buffer->str + str_buffer->offset;\n    }\n    else\n    {\n        convert:\n        convert_to_string(zdata);\n        length = Z_STRLEN_P(zdata);\n        *str = Z_STRVAL_P(zdata);\n    }\n\n    if (length >= SwooleG.serv->buffer_output_size)\n    {\n        swoole_php_fatal_error(E_WARNING, \"send %d byte data fail, max_size is %d.\", length, SwooleG.serv->buffer_output_size);\n        return SW_ERR;\n    }\n\n    return length;\n}\n\nstatic sw_inline int php_swoole_check_task_param(int dst_worker_id TSRMLS_DC)\n{\n    if (SwooleG.task_worker_num < 1)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Task method cannot use, Please set task_worker_num.\");\n        return SW_ERR;\n    }\n\n    if (dst_worker_id >= SwooleG.task_worker_num)\n    {\n        swoole_php_fatal_error(E_WARNING, \"worker_id must be less than serv->task_worker_num.\");\n        return SW_ERR;\n    }\n\n    if (!swIsWorker())\n    {\n        swoole_php_fatal_error(E_WARNING, \"The method can only be used in the worker process.\");\n        return SW_ERR;\n    }\n\n    return SW_OK;\n}\n\nstatic zval* php_swoole_get_task_result(swEventData *task_result TSRMLS_DC)\n{\n    zval *result_data, *result_unserialized_data;\n    char *result_data_str;\n    int result_data_len = 0;\n    php_unserialize_data_t var_hash;\n\n    int data_len;\n    char *data_str = NULL;\n\n    /**\n     * Large result package\n     */\n    if (swTask_type(task_result) & SW_TASK_TMPFILE)\n    {\n        swTaskWorker_large_unpack(task_result, emalloc, data_str, data_len);\n        /**\n         * unpack failed\n         */\n        if (data_len == -1)\n        {\n            if (data_str)\n            {\n                efree(data_str);\n            }\n            return NULL;\n        }\n        result_data_str = data_str;\n        result_data_len = data_len;\n    }\n    else\n    {\n        result_data_str = task_result->data;\n        result_data_len = task_result->info.len;\n    }\n\n    if (swTask_type(task_result) & SW_TASK_SERIALIZE)\n    {\n        PHP_VAR_UNSERIALIZE_INIT(var_hash);\n        SW_ALLOC_INIT_ZVAL(result_unserialized_data);\n\n        if (sw_php_var_unserialize(&result_unserialized_data, (const unsigned char **) &result_data_str,\n                (const unsigned char *) (result_data_str + result_data_len), &var_hash TSRMLS_CC))\n        {\n            result_data = result_unserialized_data;\n        }\n        else\n        {\n            SW_ALLOC_INIT_ZVAL(result_data);\n            SW_ZVAL_STRINGL(result_data, result_data_str, result_data_len, 1);\n        }\n        PHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n    }\n    else\n    {\n        SW_ALLOC_INIT_ZVAL(result_data);\n        SW_ZVAL_STRINGL(result_data, result_data_str, result_data_len, 1);\n    }\n    if (data_str)\n    {\n        efree(data_str);\n    }\n    return result_data;\n}\n\nstatic zval* php_swoole_server_add_port(swListenPort *port TSRMLS_DC)\n{\n    zval *port_object;\n    SW_ALLOC_INIT_ZVAL(port_object);\n    object_init_ex(port_object, swoole_server_port_class_entry_ptr);\n    server_port_list.zobjects[server_port_list.num++] = port_object;\n\n    swoole_server_port_property *property = emalloc(sizeof(swoole_server_port_property));\n    bzero(property, sizeof(swoole_server_port_property));\n    swoole_set_property(port_object, 0, property);\n    swoole_set_object(port_object, port);\n\n    zend_update_property_string(swoole_server_port_class_entry_ptr, port_object, ZEND_STRL(\"host\"), port->host TSRMLS_CC);\n    zend_update_property_long(swoole_server_port_class_entry_ptr, port_object, ZEND_STRL(\"port\"), port->port TSRMLS_CC);\n    zend_update_property_long(swoole_server_port_class_entry_ptr, port_object, ZEND_STRL(\"type\"), port->type TSRMLS_CC);\n\n    add_next_index_zval(server_port_list.zports, port_object);\n\n    return port_object;\n}\n\nvoid php_swoole_server_before_start(swServer *serv, zval *zobject TSRMLS_DC)\n{\n    /**\n     * create swoole server\n     */\n    if (swServer_create(serv) < 0)\n    {\n        swoole_php_fatal_error(E_ERROR, \"create server failed. Error: %s\", sw_error);\n        return;\n    }\n\n    swTrace(\"Create swoole_server host=%s, port=%d, mode=%d, type=%d\", serv->listen_list->host, (int) serv->listen_list->port, serv->factory_mode, (int) serv->listen_list->type);\n\n#ifdef SW_COROUTINE\n    coro_init(TSRMLS_C);\n#endif\n\n    /**\n     * Master Process ID\n     */\n    zend_update_property_long(swoole_server_class_entry_ptr, zobject, ZEND_STRL(\"master_pid\"), getpid() TSRMLS_CC);\n\n    zval *zsetting = sw_zend_read_property(swoole_server_class_entry_ptr, zobject, ZEND_STRL(\"setting\"), 1 TSRMLS_CC);\n    if (zsetting == NULL || ZVAL_IS_NULL(zsetting))\n    {\n        SW_MAKE_STD_ZVAL(zsetting);\n        array_init(zsetting);\n        zend_update_property(swoole_server_class_entry_ptr, zobject, ZEND_STRL(\"setting\"), zsetting TSRMLS_CC);\n    }\n\n    if (!sw_zend_hash_exists(Z_ARRVAL_P(zsetting), ZEND_STRL(\"worker_num\")))\n    {\n        add_assoc_long(zsetting, \"worker_num\", serv->worker_num);\n    }\n    if (!sw_zend_hash_exists(Z_ARRVAL_P(zsetting), ZEND_STRL(\"task_worker_num\")))\n    {\n        add_assoc_long(zsetting, \"task_worker_num\", SwooleG.task_worker_num);\n    }\n    if (!sw_zend_hash_exists(Z_ARRVAL_P(zsetting), ZEND_STRL(\"pipe_buffer_size\")))\n    {\n        add_assoc_long(zsetting, \"pipe_buffer_size\", serv->pipe_buffer_size);\n    }\n    if (!sw_zend_hash_exists(Z_ARRVAL_P(zsetting), ZEND_STRL(\"buffer_output_size\")))\n    {\n        add_assoc_long(zsetting, \"buffer_output_size\", serv->buffer_output_size);\n    }\n    if (!sw_zend_hash_exists(Z_ARRVAL_P(zsetting), ZEND_STRL(\"max_connection\")))\n    {\n        add_assoc_long(zsetting, \"max_connection\", serv->max_connection);\n    }\n\n    int i;\n    zval *retval = NULL;\n    zval *port_object;\n    zval *port_setting;\n\n    for (i = 1; i < server_port_list.num; i++)\n    {\n        port_object = server_port_list.zobjects[i];\n        port_setting = sw_zend_read_property(swoole_server_port_class_entry_ptr, port_object, ZEND_STRL(\"setting\"), 1 TSRMLS_CC);\n        //use swoole_server->setting\n        if (port_setting == NULL || ZVAL_IS_NULL(port_setting))\n        {\n            sw_zval_add_ref(&port_setting);\n            sw_zval_add_ref(&port_object);\n            sw_zend_call_method_with_1_params(&port_object, swoole_server_port_class_entry_ptr, NULL, \"set\", &retval, zsetting);\n            if (retval != NULL)\n            {\n                sw_zval_ptr_dtor(&retval);\n            }\n        }\n    }\n}\n\nvoid php_swoole_register_callback(swServer *serv)\n{\n    /*\n     * optional callback\n     */\n    if (php_sw_server_callbacks[SW_SERVER_CB_onStart] != NULL)\n    {\n        serv->onStart = php_swoole_onStart;\n    }\n    serv->onShutdown = php_swoole_onShutdown;\n    /**\n     * require callback, set the master/manager/worker PID\n     */\n    serv->onWorkerStart = php_swoole_onWorkerStart;\n\n    if (php_sw_server_callbacks[SW_SERVER_CB_onWorkerStop] != NULL)\n    {\n        serv->onWorkerStop = php_swoole_onWorkerStop;\n    }\n    /**\n     * UDP Packet\n     */\n    if (php_sw_server_callbacks[SW_SERVER_CB_onPacket] != NULL)\n    {\n        serv->onPacket = php_swoole_onPacket;\n    }\n    /**\n     * Task Worker\n     */\n    if (php_sw_server_callbacks[SW_SERVER_CB_onTask] != NULL)\n    {\n        serv->onTask = php_swoole_onTask;\n    }\n    if (php_sw_server_callbacks[SW_SERVER_CB_onFinish] != NULL)\n    {\n        serv->onFinish = php_swoole_onFinish;\n    }\n    if (php_sw_server_callbacks[SW_SERVER_CB_onWorkerError] != NULL)\n    {\n        serv->onWorkerError = php_swoole_onWorkerError;\n    }\n    if (php_sw_server_callbacks[SW_SERVER_CB_onManagerStart] != NULL)\n    {\n        serv->onManagerStart = php_swoole_onManagerStart;\n    }\n    if (php_sw_server_callbacks[SW_SERVER_CB_onManagerStop] != NULL)\n    {\n        serv->onManagerStop = php_swoole_onManagerStop;\n    }\n    if (php_sw_server_callbacks[SW_SERVER_CB_onPipeMessage] != NULL)\n    {\n        serv->onPipeMessage = php_swoole_onPipeMessage;\n    }\n}\n\nstatic int php_swoole_task_finish(swServer *serv, zval *data TSRMLS_DC)\n{\n    int flags = 0;\n    smart_str serialized_data = {0};\n    php_serialize_data_t var_hash;\n    char *data_str;\n    int data_len = 0;\n    int ret;\n\n    //need serialize\n    if (SW_Z_TYPE_P(data) != IS_STRING)\n    {\n        //serialize\n        flags |= SW_TASK_SERIALIZE;\n        PHP_VAR_SERIALIZE_INIT(var_hash);\n        sw_php_var_serialize(&serialized_data, data, &var_hash TSRMLS_CC);\n        PHP_VAR_SERIALIZE_DESTROY(var_hash);\n#if PHP_MAJOR_VERSION<7\n        data_str = serialized_data.c;\n        data_len = serialized_data.len;\n#else\n        data_str = serialized_data.s->val;\n        data_len = serialized_data.s->len;\n#endif\n    }\n    else\n    {\n        data_str = Z_STRVAL_P(data);\n        data_len = Z_STRLEN_P(data);\n    }\n\n    ret = swTaskWorker_finish(serv, data_str, data_len, flags);\n\n    smart_str_free(&serialized_data);\n    return ret;\n}\n\nstatic void php_swoole_onPipeMessage(swServer *serv, swEventData *req)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n#ifdef SW_COROUTINE\n\tCOROG.require = 0;\n#endif\n\n    zval *zserv = (zval *) serv->ptr2;\n    zval *zworker_id;\n    zval *zdata;\n    zval *retval = NULL;\n\n    SW_MAKE_STD_ZVAL(zworker_id);\n    SW_MAKE_STD_ZVAL(zdata);\n\n    zval **args[3];\n\n    ZVAL_LONG(zworker_id, (long) req->info.from_id);\n\n    if (swTask_type(req) & SW_TASK_TMPFILE)\n    {\n        int data_len;\n        char *buf = NULL;\n        swTaskWorker_large_unpack(req, emalloc, buf, data_len);\n\n        /**\n         * unpack failed\n         */\n        if (data_len == -1)\n        {\n            if (buf)\n            {\n                efree(buf);\n            }\n            return;\n        }\n        SW_ZVAL_STRINGL(zdata, buf, data_len, 0);\n#if PHP_MAJOR_VERSION >= 7\n        efree(buf);\n#endif\n    }\n    else\n    {\n        SW_ZVAL_STRINGL(zdata, req->data, req->info.len, 1);\n    }\n\n    args[0] = &zserv;\n    args[1] = &zworker_id;\n    args[2] = &zdata;\n\n    swTrace(\"PipeMessage: fd=%d|len=%d|from_id=%d|data=%s\\n\", req->info.fd, req->info.len, req->info.from_id, req->data);\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onPipeMessage], &retval, 3, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onPipeMessage handler error\");\n    }\n\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n\n    sw_zval_ptr_dtor(&zworker_id);\n    sw_zval_ptr_dtor(&zdata);\n\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n}\n\nint php_swoole_onReceive(swServer *serv, swEventData *req)\n{\n    swFactory *factory = &serv->factory;\n    zval *zserv = (zval *) serv->ptr2;\n#ifdef SW_COROUTINE\n    zval *args[4];\n#else\n    zval **args[4];\n#endif\n\n    zval *zfd;\n    zval *zfrom_id;\n    zval *zdata;\n    zval *retval = NULL;\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    //UDP\u4f7f\u7528from_id\u4f5c\u4e3aport,fd\u505a\u4e3aip\n    php_swoole_udp_t udp_info;\n    swDgramPacket *packet;\n\n    SW_MAKE_STD_ZVAL(zfd);\n    SW_MAKE_STD_ZVAL(zfrom_id);\n    SW_MAKE_STD_ZVAL(zdata);\n\n    //dgram\n    if (swEventData_is_dgram(req->info.type))\n    {\n        swString *buffer = swWorker_get_buffer(serv, req->info.from_id);\n        packet = (swDgramPacket*) buffer->str;\n\n        //udp ipv4\n        if (req->info.type == SW_EVENT_UDP)\n        {\n            udp_info.from_fd = req->info.from_fd;\n            udp_info.port = packet->port;\n            memcpy(&udp_server_socket, &udp_info, sizeof(udp_server_socket));\n            factory->last_from_id = udp_server_socket;\n            swTrace(\"SendTo: from_id=%d|from_fd=%d\", (uint16_t) req->info.from_id, req->info.from_fd);\n            SW_ZVAL_STRINGL(zdata, packet->data, packet->length, 1);\n            ZVAL_LONG(zfrom_id, (long ) udp_server_socket);\n            ZVAL_LONG(zfd, (long ) packet->addr.v4.s_addr);\n        }\n        //udp ipv6\n        else if (req->info.type == SW_EVENT_UDP6)\n        {\n            udp_info.from_fd = req->info.from_fd;\n            udp_info.port = packet->port;\n            memcpy(&dgram_server_socket, &udp_info, sizeof(udp_server_socket));\n            factory->last_from_id = dgram_server_socket;\n\n            swTrace(\"SendTo: from_id=%d|from_fd=%d\", (uint16_t) req->info.from_id, req->info.from_fd);\n\n            ZVAL_LONG(zfrom_id, (long ) dgram_server_socket);\n            char tmp[INET6_ADDRSTRLEN];\n            inet_ntop(AF_INET6, &packet->addr.v6, tmp, sizeof(tmp));\n            SW_ZVAL_STRING(zfd, tmp, 1);\n            SW_ZVAL_STRINGL(zdata, packet->data, packet->length, 1);\n        }\n        //unix dgram\n        else\n        {\n            SW_ZVAL_STRINGL(zfd, packet->data, packet->addr.un.path_length, 1);\n            SW_ZVAL_STRINGL(zdata, packet->data + packet->addr.un.path_length, packet->length - packet->addr.un.path_length, 1);\n            ZVAL_LONG(zfrom_id, (long ) req->info.from_fd);\n            dgram_server_socket = req->info.from_fd;\n        }\n    }\n    //stream\n    else\n    {\n        ZVAL_LONG(zfrom_id, (long ) req->info.from_id);\n        ZVAL_LONG(zfd, (long ) req->info.fd);\n        php_swoole_get_recv_data(zdata, req, NULL, 0);\n    }\n\n#ifndef SW_COROUTINE\n    zval *callback = php_swoole_server_get_callback(serv, req->info.from_fd, SW_SERVER_CB_onReceive);\n\n    args[0] = &zserv;\n    args[1] = &zfd;\n    args[2] = &zfrom_id;\n    args[3] = &zdata;\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, callback, &retval, 4, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onReceive handler error\");\n    }\n#else\n    args[0] = zserv;\n    args[1] = zfd;\n    args[2] = zfrom_id;\n    args[3] = zdata;\n\n    zend_fcall_info_cache *cache = php_swoole_server_get_cache(serv, req->info.from_fd, SW_SERVER_CB_onReceive);\n    int ret = coro_create(cache, args, 4, &retval, NULL, NULL);\n    if (ret != 0)\n    {\n        sw_zval_ptr_dtor(&zfd);\n        sw_zval_ptr_dtor(&zfrom_id);\n        sw_zval_ptr_dtor(&zdata);\n        if (ret == CORO_LIMIT)\n        {\n            SwooleG.serv->factory.end(&SwooleG.serv->factory, req->info.fd);\n        }\n        return SW_OK;\n    }\n#endif\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n    sw_zval_ptr_dtor(&zfd);\n    sw_zval_ptr_dtor(&zfrom_id);\n    sw_zval_ptr_dtor(&zdata);\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n    return SW_OK;\n}\n\nstatic int php_swoole_onPacket(swServer *serv, swEventData *req)\n{\n    zval *zserv = (zval *) serv->ptr2;\n    zval **args[3];\n\n    zval *zdata;\n    zval *zaddr;\n    zval *retval = NULL;\n    swDgramPacket *packet;\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n#ifdef SW_COROUTINE\n\tCOROG.require = 0;\n#endif\n\n    SW_MAKE_STD_ZVAL(zdata);\n    SW_MAKE_STD_ZVAL(zaddr);\n    array_init(zaddr);\n\n    swString *buffer = swWorker_get_buffer(serv, req->info.from_id);\n    packet = (swDgramPacket*) buffer->str;\n\n    add_assoc_long(zaddr, \"server_socket\", req->info.from_fd);\n\n    zval *callback = php_swoole_server_get_callback(serv, req->info.from_fd, SW_SERVER_CB_onPacket);\n\n    //udp ipv4\n    if (req->info.type == SW_EVENT_UDP)\n    {\n        struct in_addr sin_addr;\n        sin_addr.s_addr = packet->addr.v4.s_addr;\n        char *address = inet_ntoa(sin_addr);\n        sw_add_assoc_string(zaddr, \"address\", address, 1);\n        add_assoc_long(zaddr, \"port\", packet->port);\n        SW_ZVAL_STRINGL(zdata, packet->data, packet->length, 1);\n    }\n    //udp ipv6\n    else if (req->info.type == SW_EVENT_UDP6)\n    {\n        char tmp[INET6_ADDRSTRLEN];\n        inet_ntop(AF_INET6, &packet->addr.v6, tmp, sizeof(tmp));\n        sw_add_assoc_string(zaddr, \"address\", tmp, 1);\n        add_assoc_long(zaddr, \"port\", packet->port);\n        SW_ZVAL_STRINGL(zdata, packet->data, packet->length, 1);\n    }\n    //unix dgram\n    else if (req->info.type == SW_EVENT_UNIX_DGRAM)\n    {\n        sw_add_assoc_stringl(zaddr, \"address\", packet->data, packet->addr.un.path_length, 1);\n        SW_ZVAL_STRINGL(zdata, packet->data + packet->addr.un.path_length, packet->length - packet->addr.un.path_length, 1);\n        dgram_server_socket = req->info.from_fd;\n    }\n\n    args[0] = &zserv;\n    args[1] = &zdata;\n    args[2] = &zaddr;\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, callback, &retval, 3, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onPacket handler error\");\n    }\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n    sw_zval_ptr_dtor(&zaddr);\n    sw_zval_ptr_dtor(&zdata);\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n    return SW_OK;\n}\n\nstatic int php_swoole_onTask(swServer *serv, swEventData *req)\n{\n    zval *zserv = (zval *) serv->ptr2;\n    zval **args[4];\n\n    zval *zfd;\n    zval *zfrom_id;\n    zval *zdata;\n\n    sw_atomic_fetch_sub(&SwooleStats->tasking_num, 1);\n\n    char *zdata_str;\n    int zdata_len;\n    zval *unserialized_zdata = NULL;\n    zval *retval = NULL;\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    SW_MAKE_STD_ZVAL(zfd);\n    ZVAL_LONG(zfd, (long) req->info.fd);\n\n    SW_MAKE_STD_ZVAL(zfrom_id);\n    ZVAL_LONG(zfrom_id, (long) req->info.from_id);\n\n    SW_MAKE_STD_ZVAL(zdata);\n\n    if (swTask_type(req) & SW_TASK_TMPFILE)\n    {\n        int data_len;\n        char *buf = NULL;\n\n        swTaskWorker_large_unpack(req, emalloc, buf, data_len);\n\n        /**\n         * unpack failed\n         */\n        if (data_len == -1)\n        {\n            if (buf)\n            {\n                efree(buf);\n            }\n            return SW_OK;\n        }\n        SW_ZVAL_STRINGL(zdata, buf, data_len, 0);\n#if PHP_MAJOR_VERSION >= 7\n        efree(buf);\n#endif\n    }\n    else\n    {\n        SW_ZVAL_STRINGL(zdata, req->data, req->info.len, 1);\n    }\n\n    args[0] = &zserv;\n    args[1] = &zfd;\n    args[2] = &zfrom_id;\n    args[3] = &zdata;\n\n#if PHP_MAJOR_VERSION >= 7\n    zval stack_unserialized_zdata;\n#endif\n\n    if (swTask_type(req) & SW_TASK_SERIALIZE)\n    {\n        php_unserialize_data_t var_hash;\n\n        PHP_VAR_UNSERIALIZE_INIT(var_hash);\n        zdata_str = Z_STRVAL_P(zdata);\n        zdata_len = Z_STRLEN_P(zdata);\n\n#if PHP_MAJOR_VERSION < 7\n        MAKE_STD_ZVAL(unserialized_zdata);\n#else\n        unserialized_zdata = &stack_unserialized_zdata;\n        bzero(unserialized_zdata, sizeof(zval));\n#endif\n\n        if (sw_php_var_unserialize(&unserialized_zdata, (const uchar ** ) &zdata_str,\n                (const uchar * ) (zdata_str + zdata_len), &var_hash TSRMLS_CC))\n        {\n            args[3] = &unserialized_zdata;\n        }\n        else\n        {\n            args[3] = &zdata;\n        }\n        PHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n    }\n    else\n    {\n        args[3] = &zdata;\n    }\n\n#ifdef SW_COROUTINE\n\tCOROG.require = 0;\n#endif\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onTask], &retval, 4, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onTask handler error\");\n    }\n\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n\n    sw_zval_ptr_dtor(&zfd);\n    sw_zval_ptr_dtor(&zfrom_id);\n    sw_zval_ptr_dtor(&zdata);\n\n    if (unserialized_zdata)\n    {\n        sw_zval_ptr_dtor(&unserialized_zdata);\n    }\n\n    if (retval)\n    {\n        if (SW_Z_TYPE_P(retval) != IS_NULL)\n        {\n            php_swoole_task_finish(serv, retval TSRMLS_CC);\n        }\n        sw_zval_ptr_dtor(&retval);\n    }\n\n    return SW_OK;\n}\n\nstatic int php_swoole_onFinish(swServer *serv, swEventData *req)\n{\n    zval *zserv = (zval *) serv->ptr2;\n    zval **args[3];\n\n    zval *ztask_id;\n    zval *zdata;\n    zval *retval = NULL;\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n#ifdef SW_COROUTINE\n\tCOROG.require = 0;\n#endif\n\n    SW_MAKE_STD_ZVAL(ztask_id);\n    ZVAL_LONG(ztask_id, (long) req->info.fd);\n\n    zdata = php_swoole_get_task_result(req TSRMLS_CC);\n\n    args[0] = &zserv;\n    args[1] = &ztask_id;\n    args[2] = &zdata;\n\n    zval *callback;\n    if (swTask_type(req) & SW_TASK_CALLBACK)\n    {\n        callback = swHashMap_find_int(task_callbacks, req->info.fd);\n    }\n    else\n    {\n        callback = php_sw_server_callbacks[SW_SERVER_CB_onFinish];\n    }\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, callback, &retval, 3, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onFinish handler error\");\n    }\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n    sw_zval_ptr_dtor(&ztask_id);\n    sw_zval_ptr_dtor(&zdata);\n#if PHP_MAJOR_VERSION >= 7\n    efree(zdata);\n#endif\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n    if (swTask_type(req) & SW_TASK_CALLBACK)\n    {\n        swHashMap_del_int(task_callbacks, req->info.fd);\n        sw_zval_ptr_dtor(&callback);\n#if PHP_MAJOR_VERSION >= 7\n        efree(callback);\n#endif\n    }\n    return SW_OK;\n}\n\nstatic void php_swoole_onStart(swServer *serv)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n#ifdef SW_COROUTINE\n\tCOROG.require = 0;\n#endif\n\n    zval *zserv = (zval *) serv->ptr2;\n    zval **args[1];\n    zval *retval = NULL;\n\n    pid_t manager_pid = serv->factory_mode == SW_MODE_PROCESS ? SwooleGS->manager_pid : 0;\n\n    zend_update_property_long(swoole_server_class_entry_ptr, zserv, ZEND_STRL(\"master_pid\"), SwooleGS->master_pid TSRMLS_CC);\n    zend_update_property_long(swoole_server_class_entry_ptr, zserv, ZEND_STRL(\"manager_pid\"), manager_pid TSRMLS_CC);\n\n    args[0] = &zserv;\n    sw_zval_add_ref(&zserv);\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onStart], &retval, 1, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onStart handler error\");\n    }\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n}\n\nstatic void php_swoole_onManagerStart(swServer *serv)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n#ifdef SW_COROUTINE\n\tCOROG.require = 0;\n#endif\n\n    zval *zserv = (zval *) serv->ptr2;\n    zval **args[1];\n    zval *retval = NULL;\n\n    pid_t manager_pid = serv->factory_mode == SW_MODE_PROCESS ? SwooleGS->manager_pid : 0;\n\n    zend_update_property_long(swoole_server_class_entry_ptr, zserv, ZEND_STRL(\"master_pid\"), SwooleGS->master_pid TSRMLS_CC);\n    zend_update_property_long(swoole_server_class_entry_ptr, zserv, ZEND_STRL(\"manager_pid\"), manager_pid TSRMLS_CC);\n\n    args[0] = &zserv;\n    sw_zval_add_ref(&zserv);\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onManagerStart], &retval, 1, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onManagerStart handler error\");\n    }\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n}\n\nstatic void php_swoole_onManagerStop(swServer *serv)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n#ifdef SW_COROUTINE\n\tCOROG.require = 0;\n#endif\n\n    zval *zserv = (zval *) serv->ptr2;\n    zval **args[1];\n    zval *retval = NULL;\n\n    args[0] = &zserv;\n    sw_zval_add_ref(&zserv);\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onManagerStop], &retval, 1, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onManagerStop handler error\");\n    }\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n}\n\nstatic void php_swoole_onShutdown(swServer *serv)\n{\n    zval *zserv = (zval *) serv->ptr2;\n    zval **args[1];\n    zval *retval = NULL;\n\n    args[0] = &zserv;\n    sw_zval_add_ref(&zserv);\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n#ifdef SW_COROUTINE\n\tCOROG.require = 0;\n#endif\n\n    if (php_sw_server_callbacks[SW_SERVER_CB_onShutdown] != NULL)\n    {\n        if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onShutdown], &retval, 1, args, 0, NULL TSRMLS_CC) == FAILURE)\n        {\n            swoole_php_fatal_error(E_WARNING, \"swoole_server: onShutdown handler error\");\n        }\n        if (EG(exception))\n        {\n            zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n        }\n        if (retval != NULL)\n        {\n            sw_zval_ptr_dtor(&retval);\n        }\n    }\n}\n\nstatic void php_swoole_onWorkerStart(swServer *serv, int worker_id)\n{\n    zval *zserv = (zval *) serv->ptr2;\n    zval *zworker_id;\n    zval **args[2];\n    zval *retval = NULL;\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    SW_MAKE_STD_ZVAL(zworker_id);\n    ZVAL_LONG(zworker_id, worker_id);\n\n    args[0] = &zserv;\n    sw_zval_add_ref(&zserv);\n    args[1] = &zworker_id;\n\n    /**\n     * Manager Process ID\n     */\n    zend_update_property_long(swoole_server_class_entry_ptr, zserv, ZEND_STRL(\"master_pid\"), SwooleGS->master_pid TSRMLS_CC);\n\n    /**\n     * Manager Process ID\n     */\n    zend_update_property_long(swoole_server_class_entry_ptr, zserv, ZEND_STRL(\"manager_pid\"), SwooleGS->manager_pid TSRMLS_CC);\n\n    /**\n     * Worker ID\n     */\n    zend_update_property(swoole_server_class_entry_ptr, zserv, ZEND_STRL(\"worker_id\"), zworker_id TSRMLS_CC);\n\n    /**\n     * Is a task worker?\n     */\n    if (worker_id >= serv->worker_num)\n    {\n        zend_update_property_bool(swoole_server_class_entry_ptr, zserv, ZEND_STRL(\"taskworker\"), 1 TSRMLS_CC);\n    }\n    else\n    {\n        zend_update_property_bool(swoole_server_class_entry_ptr, zserv, ZEND_STRL(\"taskworker\"), 0 TSRMLS_CC);\n    }\n\n    /**\n     * Worker Process ID\n     */\n    zend_update_property_long(swoole_server_class_entry_ptr, zserv, ZEND_STRL(\"worker_pid\"), getpid() TSRMLS_CC);\n\n    sw_zval_ptr_dtor(&zworker_id);\n\n    /**\n     * Have not set the event callback\n     */\n#ifdef SW_COROUTINE\n\tCOROG.require = 0;\n#endif\n    if (php_sw_server_callbacks[SW_SERVER_CB_onWorkerStart] == NULL)\n    {\n        return;\n    }\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onWorkerStart], &retval, 2, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onWorkerStart handler error\");\n    }\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n    if (retval)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n}\n\nstatic void php_swoole_onWorkerStop(swServer *serv, int worker_id)\n{\n    if (SwooleWG.shutdown)\n    {\n        return;\n    }\n    SwooleWG.shutdown = 1;\n\n    zval *zobject = (zval *) serv->ptr2;\n    zval *zworker_id;\n    zval **args[2]; //\u8fd9\u91cc\u5fc5\u987b\u4e0e\u4e0b\u9762\u7684\u6570\u5b57\u5bf9\u5e94\n    zval *retval = NULL;\n\n    SW_MAKE_STD_ZVAL(zworker_id);\n    ZVAL_LONG(zworker_id, worker_id);\n\n    sw_zval_add_ref(&zobject);\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n#ifdef SW_COROUTINE\n\tCOROG.require = 0;\n#endif\n\n    args[0] = &zobject;\n    args[1] = &zworker_id;\n    if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onWorkerStop], &retval, 2, args, 0,\n            NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onWorkerStop handler error\");\n    }\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n    sw_zval_ptr_dtor(&zworker_id);\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n\n#if 1\n    shutdown_memory_manager(0, 1 TSRMLS_CC);\n#endif\n}\n\nstatic void php_swoole_onUserWorkerStart(swServer *serv, swWorker *worker)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    zval *object = worker->ptr;\n    zend_update_property_long(swoole_process_class_entry_ptr, object, ZEND_STRL(\"id\"), SwooleWG.id TSRMLS_CC);\n\n    php_swoole_process_start(worker, object TSRMLS_CC);\n}\n\nstatic void php_swoole_onWorkerError(swServer *serv, int worker_id, pid_t worker_pid, int exit_code, int signo)\n{\n    zval *zobject = (zval *) serv->ptr2;\n    zval *zworker_id, *zworker_pid, *zexit_code, *zsigno;\n    zval **args[5];\n    zval *retval = NULL;\n\n    SW_MAKE_STD_ZVAL(zworker_id);\n    ZVAL_LONG(zworker_id, worker_id);\n\n    SW_MAKE_STD_ZVAL(zworker_pid);\n    ZVAL_LONG(zworker_pid, worker_pid);\n\n    SW_MAKE_STD_ZVAL(zexit_code);\n    ZVAL_LONG(zexit_code, exit_code);\n\n    SW_MAKE_STD_ZVAL(zsigno);\n    ZVAL_LONG(zsigno, signo);\n\n    sw_zval_add_ref(&zobject);\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n#ifdef SW_COROUTINE\n\tCOROG.require = 0;\n#endif\n\n    args[0] = &zobject;\n    args[1] = &zworker_id;\n    args[2] = &zworker_pid;\n    args[3] = &zexit_code;\n    args[4] = &zsigno;\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onWorkerError], &retval, 5, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_server: onWorkerError handler error\");\n    }\n\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n\n    sw_zval_ptr_dtor(&zworker_id);\n    sw_zval_ptr_dtor(&zworker_pid);\n    sw_zval_ptr_dtor(&zexit_code);\n    sw_zval_ptr_dtor(&zsigno);\n\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n}\n\n#ifdef SW_COROUTINE\nvoid php_swoole_onConnect_finish(void *param)\n{\n    swServer *serv = SwooleG.serv;\n    swTrace(\"onConnect finish and send confirm\");\n    swServer_confirm(serv, (uint32_t)param);\n}\n#endif\n\nvoid php_swoole_onConnect(swServer *serv, swDataHead *info)\n{\n    zval *zserv = (zval *) serv->ptr2;\n    zval *zfd;\n    zval *zfrom_id;\n#ifdef SW_COROUTINE\n    zval *args[3];\n#else\n    zval **args[3];\n#endif\n    zval *retval = NULL;\n\n    SW_MAKE_STD_ZVAL(zfd);\n    ZVAL_LONG(zfd, info->fd);\n\n    SW_MAKE_STD_ZVAL(zfrom_id);\n    ZVAL_LONG(zfrom_id, info->from_id);\n\n#ifndef SW_COROUTINE\n    args[0] = &zserv;\n    sw_zval_add_ref(&zserv);\n    args[1] = &zfd;\n    args[2] = &zfrom_id;\n#else\n    args[0] = zserv;\n    sw_zval_add_ref(&zserv);\n    args[1] = zfd;\n    args[2] = zfrom_id;\n#endif\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n#ifndef SW_COROUTINE\n    zval *callback = php_swoole_server_get_callback(serv, info->from_fd, SW_SERVER_CB_onConnect);\n    if (!callback)\n    {\n        return;\n    }\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, callback, &retval, 3, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_error(E_WARNING, \"swoole_server: onConnect handler error\");\n    }\n#else\n    int ret;\n    zend_fcall_info_cache *cache = php_swoole_server_get_cache(serv, info->from_fd, SW_SERVER_CB_onConnect);\n    if (serv->enable_delay_receive)\n    {\n        ret = coro_create(cache, args, 3, &retval, php_swoole_onConnect_finish, (void*)info->fd);\n    }\n    else\n    {\n        ret = coro_create(cache, args, 3, &retval, NULL, NULL);\n    }\n\n    if (ret != 0)\n    {\n        sw_zval_ptr_dtor(&zfd);\n        sw_zval_ptr_dtor(&zfrom_id);\n        return;\n    }\n#endif\n\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n\n    sw_zval_ptr_dtor(&zfd);\n    sw_zval_ptr_dtor(&zfrom_id);\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n}\n\nvoid php_swoole_onClose(swServer *serv, swDataHead *info)\n{\n    zval *zserv = (zval *) serv->ptr2;\n    zval *zfd;\n    zval *zfrom_id;\n    zval **args[3];\n    zval *retval = NULL;\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    SW_MAKE_STD_ZVAL(zfd);\n    ZVAL_LONG(zfd, info->fd);\n\n    SW_MAKE_STD_ZVAL(zfrom_id);\n    ZVAL_LONG(zfrom_id, info->from_id);\n\n    args[0] = &zserv;\n    sw_zval_add_ref(&zserv);\n    args[1] = &zfd;\n    args[2] = &zfrom_id;\n\n    zval *callback = php_swoole_server_get_callback(serv, info->from_fd, SW_SERVER_CB_onClose);\n    if (!callback)\n    {\n        return;\n    }\n\n    if (sw_call_user_function_ex(EG(function_table), NULL, callback, &retval, 3, args, 0, NULL TSRMLS_CC) == FAILURE)\n    {\n        swoole_php_fatal_error(E_WARNING, \"onClose handler error\");\n    }\n    if (EG(exception))\n    {\n        zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n    }\n\n    sw_zval_ptr_dtor(&zfd);\n    sw_zval_ptr_dtor(&zfrom_id);\n    if (retval != NULL)\n    {\n        sw_zval_ptr_dtor(&retval);\n    }\n}\n\nPHP_METHOD(swoole_server, __construct)\n{\n    zend_size_t host_len = 0;\n    char *serv_host;\n    long sock_type = SW_SOCK_TCP;\n    long serv_port;\n    long serv_mode = SW_MODE_PROCESS;\n\n    //only cli env\n    if (strcasecmp(\"cli\", sapi_module.name) != 0)\n    {\n        swoole_php_fatal_error(E_ERROR, \"swoole_server must run at php_cli environment.\");\n        RETURN_FALSE;\n    }\n\n    if (SwooleG.main_reactor != NULL)\n    {\n        swoole_php_fatal_error(E_ERROR, \"eventLoop has been created. Unable to create swoole_server.\");\n        RETURN_FALSE;\n    }\n\n    if (SwooleGS->start > 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"server is already running. Unable to create swoole_server.\");\n        RETURN_FALSE;\n    }\n\n    swServer *serv = sw_malloc(sizeof (swServer));\n    swServer_init(serv);\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"sl|ll\", &serv_host, &host_len, &serv_port, &serv_mode, &sock_type) == FAILURE)\n    {\n        swoole_php_fatal_error(E_ERROR, \"invalid parameters.\");\n        return;\n    }\n\n#ifdef __CYGWIN__\n    serv_mode = SW_MODE_SINGLE;\n#elif !defined(SW_USE_THREAD)\n    if (serv_mode == SW_MODE_THREAD || serv_mode == SW_MODE_BASE)\n    {\n        serv_mode = SW_MODE_SINGLE;\n        swoole_php_fatal_error(E_WARNING, \"PHP can not running at multi-threading. Reset mode to SWOOLE_MODE_BASE\");\n    }\n#endif\n    serv->factory_mode = serv_mode;\n\n    if (serv->factory_mode == SW_MODE_SINGLE)\n    {\n        serv->worker_num = 1;\n        serv->max_request = 0;\n    }\n\n    bzero(php_sw_server_callbacks, sizeof (zval*) * PHP_SERVER_CALLBACK_NUM);\n\n    swListenPort *port = swServer_add_port(serv, sock_type, serv_host, serv_port);\n    if (!port)\n    {\n        swoole_php_fatal_error(E_ERROR, \"listen server port failed.\");\n        return;\n    }\n\n    zval *server_object = getThis();\n\n#ifdef HAVE_PCRE\n    zval *connection_iterator_object;\n    SW_MAKE_STD_ZVAL(connection_iterator_object);\n    object_init_ex(connection_iterator_object, swoole_connection_iterator_class_entry_ptr);\n    zend_update_property(swoole_server_class_entry_ptr, server_object, ZEND_STRL(\"connections\"), connection_iterator_object TSRMLS_CC);\n#endif\n\n    zend_update_property_stringl(swoole_server_class_entry_ptr, server_object, ZEND_STRL(\"host\"), serv_host, host_len TSRMLS_CC);\n    zend_update_property_long(swoole_server_class_entry_ptr, server_object, ZEND_STRL(\"port\"), serv_port TSRMLS_CC);\n    zend_update_property_long(swoole_server_class_entry_ptr, server_object, ZEND_STRL(\"mode\"), serv->factory_mode TSRMLS_CC);\n    zend_update_property_long(swoole_server_class_entry_ptr, server_object, ZEND_STRL(\"type\"), sock_type TSRMLS_CC);\n    swoole_set_object(server_object, serv);\n\n    zval *ports;\n    SW_ALLOC_INIT_ZVAL(ports);\n    array_init(ports);\n    zend_update_property(swoole_server_class_entry_ptr, server_object, ZEND_STRL(\"ports\"), ports TSRMLS_CC);\n    server_port_list.zports = ports;\n\n    php_swoole_server_add_port(port TSRMLS_CC);\n}\n\nPHP_METHOD(swoole_server, set)\n{\n    zval *zset = NULL;\n    zval *zobject = getThis();\n    HashTable *vht;\n\n    zval *v;\n\n    if (SwooleGS->start > 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is running. Unable to execute swoole_server_set now.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z\", &zset) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n\n    vht = Z_ARRVAL_P(zset);\n    //chroot\n    if (php_swoole_array_get_value(vht, \"chroot\", v))\n    {\n        convert_to_string(v);\n        SwooleG.chroot = strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));\n    }\n    //user\n    if (php_swoole_array_get_value(vht, \"user\", v))\n    {\n        convert_to_string(v);\n        SwooleG.user = strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));\n    }\n    //group\n    if (php_swoole_array_get_value(vht, \"group\", v))\n    {\n        convert_to_string(v);\n        SwooleG.group = strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));\n    }\n    //daemonize\n    if (php_swoole_array_get_value(vht, \"daemonize\", v))\n    {\n        convert_to_boolean(v);\n        serv->daemonize = Z_BVAL_P(v);\n    }\n    //reactor thread num\n    if (php_swoole_array_get_value(vht, \"reactor_num\", v))\n    {\n        convert_to_long(v);\n        serv->reactor_num = (int) Z_LVAL_P(v);\n        if (serv->reactor_num <= 0)\n        {\n            serv->reactor_num = SwooleG.cpu_num;\n        }\n    }\n    //worker_num\n    if (php_swoole_array_get_value(vht, \"worker_num\", v))\n    {\n        convert_to_long(v);\n        serv->worker_num = (int) Z_LVAL_P(v);\n        if (serv->worker_num <= 0)\n        {\n            serv->worker_num = SwooleG.cpu_num;\n        }\n    }\n#ifdef SW_COROUTINE\n\tif (php_swoole_array_get_value(vht, \"max_coro_num\", v))\n\t{\n\t\tconvert_to_long(v);\n\t\tCOROG.max_coro_num = (int) Z_LVAL_P(v);\n\t\tif (COROG.max_coro_num <= 0)\n\t\t{\n\t\t\tCOROG.max_coro_num = DEFAULT_MAX_CORO_NUM;\n\t\t}\n\t}\n#endif\n    //dispatch_mode\n    if (php_swoole_array_get_value(vht, \"dispatch_mode\", v))\n    {\n        convert_to_long(v);\n        serv->dispatch_mode = (int) Z_LVAL_P(v);\n    }\n    //log_file\n    if (php_swoole_array_get_value(vht, \"log_file\", v))\n    {\n        convert_to_string(v);\n        SwooleG.log_file = strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));\n    }\n    //log_level\n    if (php_swoole_array_get_value(vht, \"log_level\", v))\n    {\n        convert_to_long(v);\n        SwooleG.log_level = (int) Z_LVAL_P(v);\n    }\n    /**\n     * for dispatch_mode = 1/3\n     */\n    if (php_swoole_array_get_value(vht, \"discard_timeout_request\", v))\n    {\n        convert_to_boolean(v);\n        serv->discard_timeout_request = Z_BVAL_P(v);\n    }\n    //onConnect/onClose event\n    if (php_swoole_array_get_value(vht, \"enable_unsafe_event\", v))\n    {\n        convert_to_boolean(v);\n        serv->enable_unsafe_event = Z_BVAL_P(v);\n    }\n    //port reuse\n    if (php_swoole_array_get_value(vht, \"enable_port_reuse\", v))\n    {\n        convert_to_boolean(v);\n        SwooleG.reuse_port = Z_BVAL_P(v);\n    }\n    //delay receive\n    if (php_swoole_array_get_value(vht, \"enable_delay_receive\", v))\n    {\n        convert_to_boolean(v);\n        serv->enable_delay_receive = Z_BVAL_P(v);\n    }\n    //task_worker_num\n    if (php_swoole_array_get_value(vht, \"task_worker_num\", v))\n    {\n        convert_to_long(v);\n        SwooleG.task_worker_num = (int) Z_LVAL_P(v);\n        task_callbacks = swHashMap_new(1024, NULL);\n    }\n    //task ipc mode, 1,2,3\n    if (php_swoole_array_get_value(vht, \"task_ipc_mode\", v))\n    {\n        convert_to_long(v);\n        SwooleG.task_ipc_mode = (int) Z_LVAL_P(v);\n    }\n    /**\n     * Temporary file directory for task_worker\n     */\n    if (php_swoole_array_get_value(vht, \"task_tmpdir\", v))\n    {\n        convert_to_string(v);\n        SwooleG.task_tmpdir = emalloc(SW_TASK_TMPDIR_SIZE);\n        SwooleG.task_tmpdir_len = snprintf(SwooleG.task_tmpdir, SW_TASK_TMPDIR_SIZE, \"%s/task.XXXXXX\", Z_STRVAL_P(v)) + 1;\n\n        if (SwooleG.task_tmpdir_len > SW_TASK_TMPDIR_SIZE - 1)\n        {\n            swoole_php_fatal_error(E_ERROR, \"task_tmpdir is too long, max size is %d.\", SW_TASK_TMPDIR_SIZE - 1);\n            return;\n        }\n    }\n    else\n    {\n        SwooleG.task_tmpdir = strndup(SW_TASK_TMP_FILE, sizeof (SW_TASK_TMP_FILE));\n        SwooleG.task_tmpdir_len = sizeof (SW_TASK_TMP_FILE);\n    }\n    //task_max_request\n    if (php_swoole_array_get_value(vht, \"task_max_request\", v))\n    {\n        convert_to_long(v);\n        SwooleG.task_max_request = (int) Z_LVAL_P(v);\n    }\n    //max_connection\n    if (php_swoole_array_get_value(vht, \"max_connection\", v) || php_swoole_array_get_value(vht, \"max_conn\", v))\n    {\n        convert_to_long(v);\n        serv->max_connection = (int) Z_LVAL_P(v);\n    }\n    //heartbeat_check_interval\n    if (php_swoole_array_get_value(vht, \"heartbeat_check_interval\", v))\n    {\n        convert_to_long(v);\n        serv->heartbeat_check_interval = (int) Z_LVAL_P(v);\n    }\n    //heartbeat idle time\n    if (php_swoole_array_get_value(vht, \"heartbeat_idle_time\", v))\n    {\n        convert_to_long(v);\n        serv->heartbeat_idle_time = (int) Z_LVAL_P(v);\n\n        if (serv->heartbeat_check_interval > serv->heartbeat_idle_time)\n        {\n            swoole_php_fatal_error(E_WARNING, \"heartbeat_idle_time must be greater than heartbeat_check_interval.\");\n            serv->heartbeat_check_interval = serv->heartbeat_idle_time / 2;\n        }\n    }\n    else if (serv->heartbeat_check_interval > 0)\n    {\n        serv->heartbeat_idle_time = serv->heartbeat_check_interval * 2;\n    }\n    //max_request\n    if (php_swoole_array_get_value(vht, \"max_request\", v))\n    {\n        convert_to_long(v);\n        serv->max_request = (int) Z_LVAL_P(v);\n    }\n    //cpu affinity\n    if (php_swoole_array_get_value(vht, \"open_cpu_affinity\", v))\n    {\n        convert_to_boolean(v);\n        serv->open_cpu_affinity = Z_BVAL_P(v);\n    }\n    //cpu affinity set\n    if (php_swoole_array_get_value(vht, \"cpu_affinity_ignore\", v))\n    {\n        int ignore_num = zend_hash_num_elements(Z_ARRVAL_P(v));\n        if (ignore_num >= SW_CPU_NUM) \n        {\n            swoole_php_fatal_error(E_ERROR, \"cpu_affinity_ignore num must be less than cpu num (%d)\", SW_CPU_NUM);\n            RETURN_FALSE;\n        }\n        int available_num = SW_CPU_NUM - ignore_num;\n        int *available_cpu = (int *) sw_malloc(sizeof(int) * available_num);\n        int flag, i, available_i = 0;\n\n        zval *zval_core = NULL;\n        for (i = 0; i < SW_CPU_NUM; i++)\n        {\n            flag = 1;\n            SW_HASHTABLE_FOREACH_START(Z_ARRVAL_P(v), zval_core)\n                int core = (int) Z_LVAL_P(zval_core);\n                if (i == core)\n                {\n                    flag = 0;\n                    break;\n                }\n            SW_HASHTABLE_FOREACH_END();\n            if (flag)\n            {\n                available_cpu[available_i] = i;\n                available_i++;\n            }\n        }\n        serv->cpu_affinity_available_num = available_num;\n        serv->cpu_affinity_available = available_cpu;\n    }\n    //paser x-www-form-urlencoded form data\n    if (php_swoole_array_get_value(vht, \"http_parse_post\", v))\n    {\n        convert_to_boolean(v);\n        serv->http_parse_post = Z_BVAL_P(v);\n    }\n    /**\n     * buffer input size\n     */\n    if (php_swoole_array_get_value(vht, \"buffer_input_size\", v))\n    {\n        convert_to_long(v);\n        serv->buffer_input_size = (int) Z_LVAL_P(v);\n    }\n    /**\n     * buffer output size\n     */\n    if (php_swoole_array_get_value(vht, \"buffer_output_size\", v))\n    {\n        convert_to_long(v);\n        serv->buffer_output_size = (int) Z_LVAL_P(v);\n    }\n    /**\n     * set pipe memory buffer size\n     */\n    if (php_swoole_array_get_value(vht, \"pipe_buffer_size\", v))\n    {\n        convert_to_long(v);\n        serv->pipe_buffer_size = (int) Z_LVAL_P(v);\n    }\n    //message queue key\n    if (php_swoole_array_get_value(vht, \"message_queue_key\", v))\n    {\n        convert_to_long(v);\n        serv->message_queue_key = (int) Z_LVAL_P(v);\n    }\n\n    zval *retval = NULL;\n    zval *port_object = server_port_list.zobjects[0];\n\n    sw_zval_add_ref(&port_object);\n    sw_zval_add_ref(&zset);\n    sw_zval_add_ref(&zobject);\n\n    sw_zend_call_method_with_1_params(&port_object, swoole_server_port_class_entry_ptr, NULL, \"set\", &retval, zset);\n    zend_update_property(swoole_server_class_entry_ptr, zobject, ZEND_STRL(\"setting\"), zset TSRMLS_CC);\n\n    RETURN_TRUE;\n}\n\nPHP_METHOD(swoole_server, on)\n{\n    zval *name;\n    zval *cb;\n\n    if (SwooleGS->start > 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is running. Unable to set event callback now.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, \"zz\", &name, &cb) == FAILURE)\n    {\n        return;\n    }\n\n#ifdef PHP_SWOOLE_CHECK_CALLBACK\n    char *func_name = NULL;\n#ifdef SW_COROUTINE\n    zend_fcall_info_cache *func_cache = emalloc(sizeof(zend_fcall_info_cache));\n    if (!sw_zend_is_callable_ex(cb, NULL, 0, &func_name, NULL, func_cache, NULL TSRMLS_CC))\n#else\n    if (!sw_zend_is_callable(cb, 0, &func_name TSRMLS_CC))\n#endif\n    {\n        swoole_php_fatal_error(E_ERROR, \"Function '%s' is not callable\", func_name);\n        efree(func_name);\n        return;\n    }\n    efree(func_name);\n#endif\n\n    convert_to_string(name);\n\n    char *callback_name[PHP_SERVER_CALLBACK_NUM] = {\n        \"Connect\",\n        \"Receive\",\n        \"Close\",\n        \"Packet\",\n        \"Start\",\n        \"Shutdown\",\n        \"WorkerStart\",\n        \"WorkerStop\",\n        \"Task\",\n        \"Finish\",\n        \"WorkerError\",\n        \"ManagerStart\",\n        \"ManagerStop\",\n        \"PipeMessage\",\n        NULL,\n        NULL,\n        NULL,\n        NULL,\n    };\n\n    int i;\n    char property_name[128];\n    int l_property_name = 0;\n    memcpy(property_name, \"on\", 2);\n\n    for (i = 0; i < PHP_SERVER_CALLBACK_NUM; i++)\n    {\n        if (callback_name[i] == NULL)\n        {\n            continue;\n        }\n        if (strncasecmp(callback_name[i], Z_STRVAL_P(name), Z_STRLEN_P(name)) == 0)\n        {\n            memcpy(property_name + 2, callback_name[i], Z_STRLEN_P(name));\n            l_property_name = Z_STRLEN_P(name) + 2;\n            property_name[l_property_name] = '\\0';\n            zend_update_property(swoole_server_class_entry_ptr, getThis(), property_name, l_property_name, cb TSRMLS_CC);\n            php_sw_server_callbacks[i] = sw_zend_read_property(swoole_server_class_entry_ptr, getThis(), property_name, l_property_name, 0 TSRMLS_CC);\n            sw_copy_to_stack(php_sw_server_callbacks[i], _php_sw_server_callbacks[i]);\n\n#ifdef SW_COROUTINE\n            php_sw_server_caches[i] = func_cache;\n#endif\n            break;\n        }\n    }\n\n    if (l_property_name == 0)\n    {\n        swoole_php_error(E_WARNING, \"Unknown event types[%s]\", Z_STRVAL_P(name));\n        RETURN_FALSE;\n    }\n\n    if (i < SW_SERVER_CB_onStart)\n    {\n        zval *port_object = server_port_list.zobjects[0];\n        zval *retval = NULL;\n        sw_zval_add_ref(&port_object);\n        sw_zend_call_method_with_2_params(&port_object, swoole_server_port_class_entry_ptr, NULL, \"on\", &retval, name, cb);\n    }\n    else\n    {\n        RETURN_TRUE;\n    }\n}\n\nPHP_METHOD(swoole_server, listen)\n{\n    char *host;\n    zend_size_t host_len;\n    long sock_type;\n    long port;\n\n    if (SwooleGS->start > 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is running. cannot add listener.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"sll\", &host, &host_len, &port, &sock_type) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(getThis());\n    swListenPort *ls = swServer_add_port(serv, (int) sock_type, host, (int) port);\n    if (!ls)\n    {\n        RETURN_FALSE;\n    }\n\n    zval *port_object = php_swoole_server_add_port(ls TSRMLS_CC);\n    RETURN_ZVAL(port_object, 1, NULL);\n}\n\nPHP_METHOD(swoole_server, addProcess)\n{\n    if (SwooleGS->start > 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is running. cannot add process.\");\n        RETURN_FALSE;\n    }\n\n    zval *process = NULL;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z\", &process) == FAILURE)\n    {\n        return;\n    }\n\n    if (ZVAL_IS_NULL(process))\n    {\n        swoole_php_fatal_error(E_WARNING, \"parameter 1 cannot be empty.\");\n        RETURN_FALSE;\n    }\n\n    swServer *serv = swoole_get_object(getThis());\n    if (!instanceof_function(Z_OBJCE_P(process), swoole_process_class_entry_ptr TSRMLS_CC))\n    {\n        swoole_php_fatal_error(E_ERROR, \"object is not instanceof swoole_process.\");\n        RETURN_FALSE;\n    }\n\n    if (serv->onUserWorkerStart == NULL)\n    {\n        serv->onUserWorkerStart = php_swoole_onUserWorkerStart;\n    }\n\n#if PHP_MAJOR_VERSION >= 7\n    zval *tmp_process = emalloc(sizeof(zval));\n    memcpy(tmp_process, process, sizeof(zval));\n    process = tmp_process;\n#endif\n\n    sw_zval_add_ref(&process);\n\n    swWorker *worker = swoole_get_object(process);\n    worker->ptr = process;\n\n    int id = swServer_add_worker(serv, worker);\n    if (id < 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swServer_add_worker failed.\");\n        RETURN_FALSE;\n    }\n    zend_update_property_long(swoole_process_class_entry_ptr, getThis(), ZEND_STRL(\"id\"), id TSRMLS_CC);\n    RETURN_LONG(id);\n}\n\nPHP_METHOD(swoole_server, start)\n{\n    zval *zobject = getThis();\n    int ret;\n\n    if (SwooleGS->start > 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is running. Unable to execute swoole_server::start.\");\n        RETURN_FALSE;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n    php_swoole_register_callback(serv);\n\n    if (php_sw_server_callbacks[SW_SERVER_CB_onReceive] == NULL && php_sw_server_callbacks[SW_SERVER_CB_onPacket] == NULL)\n    {\n        swoole_php_fatal_error(E_ERROR, \"require onReceive/onPacket callback\");\n        RETURN_FALSE;\n    }\n    //-------------------------------------------------------------\n    serv->onReceive = php_swoole_onReceive;\n    serv->ptr2 = zobject;\n\n    php_swoole_server_before_start(serv, zobject TSRMLS_CC);\n\n    ret = swServer_start(serv);\n    if (ret < 0)\n    {\n        swoole_php_fatal_error(E_ERROR, \"start server failed. Error: %s\", sw_error);\n        RETURN_LONG(ret);\n    }\n    RETURN_TRUE;\n}\n\nPHP_METHOD(swoole_server, send)\n{\n    zval *zobject = getThis();\n\n    int ret;\n\n    zval *zfd;\n    zval *zdata;\n    long server_socket = -1;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"zz|l\", &zfd, &zdata, &server_socket) == FAILURE)\n    {\n        return;\n    }\n\n    char *data;\n    int length = php_swoole_get_send_data(zdata, &data TSRMLS_CC);\n\n    if (length < 0)\n    {\n        RETURN_FALSE;\n    }\n    else if (length == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"data is empty.\");\n        RETURN_FALSE;\n    }\n\n   swServer *serv = swoole_get_object(zobject);\n\n    if (serv->have_udp_sock && SW_Z_TYPE_P(zfd) == IS_STRING)\n    {\n        if (server_socket == -1)\n        {\n            server_socket = dgram_server_socket;\n        }\n        //UDP IPv6\n        if (strchr(Z_STRVAL_P(zfd), ':'))\n        {\n            php_swoole_udp_t udp_info;\n            memcpy(&udp_info, &server_socket, sizeof(udp_info));\n            ret = swSocket_udp_sendto6(udp_info.from_fd, Z_STRVAL_P(zfd), udp_info.port, data, length);\n        }\n        //UNIX DGRAM\n        else if (Z_STRVAL_P(zfd)[0] == '/')\n        {\n            struct sockaddr_un addr_un;\n            memcpy(addr_un.sun_path, Z_STRVAL_P(zfd), Z_STRLEN_P(zfd));\n            addr_un.sun_family = AF_UNIX;\n            addr_un.sun_path[Z_STRLEN_P(zfd)] = 0;\n            ret = swSocket_sendto_blocking(server_socket, data, length, 0, (struct sockaddr *) &addr_un, sizeof(addr_un));\n        }\n        else\n        {\n            goto convert;\n        }\n        SW_CHECK_RETURN(ret);\n    }\n\n    convert: convert_to_long(zfd);\n    uint32_t fd = (uint32_t) Z_LVAL_P(zfd);\n    //UDP\n    if (swServer_is_udp(fd))\n    {\n        if (server_socket == -1)\n        {\n            server_socket = udp_server_socket;\n        }\n\n        php_swoole_udp_t udp_info;\n        memcpy(&udp_info, &server_socket, sizeof(udp_info));\n\n        struct sockaddr_in addr_in;\n        addr_in.sin_family = AF_INET;\n        addr_in.sin_port = htons(udp_info.port);\n        addr_in.sin_addr.s_addr = fd;\n        ret = swSocket_sendto_blocking(udp_info.from_fd, data, length, 0, (struct sockaddr *) &addr_in, sizeof(addr_in));\n        SW_CHECK_RETURN(ret);\n    }\n    //TCP\n    else\n    {\n        SW_CHECK_RETURN(swServer_tcp_send(serv, fd, data, length));\n    }\n}\n\nPHP_METHOD(swoole_server, sendto)\n{\n    zval *zobject = getThis();\n\n    char *ip;\n    char *data;\n    zend_size_t len, ip_len;\n\n    long port;\n    long server_socket = -1;\n    zend_bool ipv6 = 0;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"sls|l\", &ip, &ip_len, &port, &data, &len, &server_socket) == FAILURE)\n    {\n        return;\n    }\n\n    if (len <= 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"data is empty.\");\n        RETURN_FALSE;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n\n    if (strchr(ip, ':'))\n    {\n        ipv6 = 1;\n    }\n\n    if (ipv6 == 0 && serv->udp_socket_ipv4 <= 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"You must add an UDP listener to server before using sendto.\");\n        RETURN_FALSE;\n    }\n    else if (ipv6 == 1 && serv->udp_socket_ipv6 <= 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"You must add an UDP6 listener to server before using sendto.\");\n        RETURN_FALSE;\n    }\n\n    if (server_socket < 0)\n    {\n        server_socket = ipv6 ?  serv->udp_socket_ipv6 : serv->udp_socket_ipv4;\n    }\n\n    int ret;\n    if (ipv6)\n    {\n        ret = swSocket_udp_sendto6(server_socket, ip, port, data, len);\n    }\n    else\n    {\n        ret = swSocket_udp_sendto(server_socket, ip, port, data, len);\n    }\n    SW_CHECK_RETURN(ret);\n}\n\nPHP_METHOD(swoole_server, sendfile)\n{\n    zval *zobject = getThis();\n    zend_size_t len;\n\n    char *filename;\n    long fd;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ls\", &fd, &filename, &len) == FAILURE)\n    {\n        return;\n    }\n\n    //check fd\n    if (fd <= 0 || fd > SW_MAX_SOCKET_ID)\n    {\n        swoole_error_log(SW_LOG_WARNING, SW_ERROR_SESSION_INVALID_ID, \"invalid fd[%ld].\", fd);\n        RETURN_FALSE;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n    SW_CHECK_RETURN(swServer_tcp_sendfile(serv, (int) fd, filename, len));\n}\n\nPHP_METHOD(swoole_server, close)\n{\n    zval *zobject = getThis();\n    zend_bool reset = SW_FALSE;\n    long fd;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (swIsMaster())\n    {\n        swoole_php_fatal_error(E_WARNING, \"Cannot close connection in master process.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l|b\", &fd, &reset) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n    swConnection *conn = swServer_connection_verify_no_ssl(serv, fd);\n    if (!conn)\n    {\n        RETURN_FALSE;\n    }\n\n    //Reset send buffer, Immediately close the connection.\n    if (reset)\n    {\n        conn->close_reset = 1;\n    }\n\n    int ret;\n    if (!swIsWorker())\n    {\n        swWorker *worker = swServer_get_worker(serv, conn->fd % serv->worker_num);\n        swDataHead ev;\n        ev.type = SW_EVENT_CLOSE;\n        ev.fd = fd;\n        ev.from_id = conn->from_id;\n        ret = swWorker_send2worker(worker, &ev, sizeof(ev), SW_PIPE_MASTER);\n    }\n    else\n    {\n        ret = serv->factory.end(&serv->factory, fd);\n    }\n    SW_CHECK_RETURN(ret);\n}\n\nPHP_METHOD(swoole_server, confirm)\n{\n    zval *zobject = getThis();\n    long fd;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (swIsMaster())\n    {\n        swoole_php_fatal_error(E_WARNING, \"Cannot confirm connection in master process.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &fd) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n    SW_CHECK_RETURN(swServer_confirm(serv, fd));\n}\n\nPHP_METHOD(swoole_server, stats)\n{\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    array_init(return_value);\n    sw_add_assoc_long_ex(return_value, ZEND_STRS(\"start_time\"), SwooleStats->start_time);\n    sw_add_assoc_long_ex(return_value, ZEND_STRS(\"connection_num\"), SwooleStats->connection_num);\n    sw_add_assoc_long_ex(return_value, ZEND_STRS(\"accept_count\"), SwooleStats->accept_count);\n    sw_add_assoc_long_ex(return_value, ZEND_STRS(\"close_count\"), SwooleStats->close_count);\n    sw_add_assoc_long_ex(return_value, ZEND_STRS(\"tasking_num\"), SwooleStats->tasking_num);\n    sw_add_assoc_long_ex(return_value, ZEND_STRS(\"request_count\"), SwooleStats->request_count);\n    sw_add_assoc_long_ex(return_value, ZEND_STRS(\"worker_request_count\"), SwooleWG.request_count);\n\n    if (SwooleG.task_ipc_mode > SW_IPC_UNSOCK && SwooleGS->task_workers.queue)\n    {\n        int queue_num = -1;\n        int queue_bytes = -1;\n        if (swMsgQueue_stat(SwooleGS->task_workers.queue, &queue_num, &queue_bytes) == 0)\n        {\n            sw_add_assoc_long_ex(return_value, ZEND_STRS(\"task_queue_num\"), queue_num);\n            sw_add_assoc_long_ex(return_value, ZEND_STRS(\"task_queue_bytes\"), queue_bytes);\n        }\n    }\n}\n\nPHP_METHOD(swoole_server, reload)\n{\n    zend_bool only_reload_taskworker = 0;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|b\", &only_reload_taskworker) == FAILURE)\n    {\n        return;\n    }\n\n    int sig = only_reload_taskworker ? SIGUSR2 : SIGUSR1;\n    if (kill(SwooleGS->manager_pid, sig) < 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"kill() failed. Error: %s[%d]\", strerror(errno), errno);\n        RETURN_FALSE;\n    }\n    RETURN_TRUE;\n}\n\nPHP_METHOD(swoole_server, heartbeat)\n{\n    zval *zobject = getThis();\n\n    zend_bool close_connection = 0;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|b\", &close_connection) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n\n    if (serv->heartbeat_idle_time < 1)\n    {\n        RETURN_FALSE;\n    }\n\n    int serv_max_fd = swServer_get_maxfd(serv);\n    int serv_min_fd = swServer_get_minfd(serv);\n\n    array_init(return_value);\n\n    int fd;\n    int checktime = (int) SwooleGS->now - serv->heartbeat_idle_time;\n    swConnection *conn;\n\n    for (fd = serv_min_fd; fd <= serv_max_fd; fd++)\n    {\n        swTrace(\"heartbeat check fd=%d\", fd);\n        conn = &serv->connection_list[fd];\n\n        if (1 == conn->active && conn->last_time < checktime)\n        {\n            conn->close_force = 1;\n            /**\n             * Close the connection\n             */\n            if (close_connection)\n            {\n                serv->factory.end(&serv->factory, fd);\n            }\n#ifdef SW_REACTOR_USE_SESSION\n            add_next_index_long(return_value, conn->session_id);\n#else\n            add_next_index_long(return_value, fd);\n#endif\n        }\n    }\n}\n\nPHP_METHOD(swoole_server, taskwait)\n{\n    swEventData buf;\n    zval *data;\n\n    double timeout = SW_TASKWAIT_TIMEOUT;\n    long dst_worker_id = -1;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z|dl\", &data, &timeout, &dst_worker_id) == FAILURE)\n    {\n        return;\n    }\n\n    if (php_swoole_check_task_param(dst_worker_id TSRMLS_CC) < 0)\n    {\n        RETURN_FALSE;\n    }\n\n    php_swoole_task_pack(&buf, data TSRMLS_CC);\n\n    uint64_t notify;\n    swEventData *task_result = &(SwooleG.task_result[SwooleWG.id]);\n    bzero(task_result, sizeof(swEventData));\n    swPipe *task_notify_pipe = &SwooleG.task_notify[SwooleWG.id];\n    int efd = task_notify_pipe->getFd(task_notify_pipe, 0);\n\n    //clear history task\n    while (read(efd, &notify, sizeof(notify)) > 0);\n\n    if (swProcessPool_dispatch_blocking(&SwooleGS->task_workers, &buf, (int*) &dst_worker_id) >= 0)\n    {\n        sw_atomic_fetch_add(&SwooleStats->tasking_num, 1);\n        task_notify_pipe->timeout = timeout;\n        int ret = task_notify_pipe->read(task_notify_pipe, &notify, sizeof(notify));\n        if (ret > 0)\n        {\n            zval *task_notify_data = php_swoole_get_task_result(task_result TSRMLS_CC);\n            RETURN_ZVAL(task_notify_data, 0, 0);\n        }\n        else\n        {\n            swoole_php_fatal_error(E_WARNING, \"taskwait failed. Error: %s[%d]\", strerror(errno), errno);\n        }\n    }\n    RETURN_FALSE;\n}\n\nPHP_METHOD(swoole_server, taskWaitMulti)\n{\n    swEventData buf;\n    zval *tasks;\n    zval *task;\n    double timeout = SW_TASKWAIT_TIMEOUT;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z|d\", &tasks, &timeout) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(getThis());\n    array_init(return_value);\n\n    int dst_worker_id;\n    int task_id;\n    int i = 0;\n    int n_task = Z_ARRVAL_P(tasks)->nNumOfElements;\n\n    int list_of_id[1024];\n\n    uint64_t notify;\n    swEventData *task_result = &(SwooleG.task_result[SwooleWG.id]);\n    bzero(task_result, sizeof(swEventData));\n    swPipe *task_notify_pipe = &SwooleG.task_notify[SwooleWG.id];\n    swWorker *worker = swServer_get_worker(serv, SwooleWG.id);\n\n    char _tmpfile[sizeof(SW_TASK_TMP_FILE)] = SW_TASK_TMP_FILE;\n    int _tmpfile_fd = swoole_tmpfile(_tmpfile);\n    if (_tmpfile_fd < 0)\n    {\n        swoole_php_sys_error(E_WARNING, \"mktemp(%s) failed.\", SW_TASK_TMP_FILE);\n        RETURN_FALSE;\n    }\n    close(_tmpfile_fd);\n    int *finish_count = (int *) task_result->data;\n\n    worker->lock.lock(&worker->lock);\n    *finish_count = 0;\n    memcpy(task_result->data + 4, _tmpfile, sizeof(_tmpfile));\n    worker->lock.unlock(&worker->lock);\n\n    //clear history task\n    int efd = task_notify_pipe->getFd(task_notify_pipe, 0);\n    while (read(efd, &notify, sizeof(notify)) > 0);\n\n    SW_HASHTABLE_FOREACH_START(Z_ARRVAL_P(tasks), task)\n        task_id = php_swoole_task_pack(&buf, task TSRMLS_CC);\n        if (task_id < 0)\n        {\n            swoole_php_fatal_error(E_WARNING, \"task pack failed.\");\n            goto fail;\n        }\n        swTask_type(&buf) |= SW_TASK_WAITALL;\n        dst_worker_id = -1;\n        if (swProcessPool_dispatch_blocking(&SwooleGS->task_workers, &buf, (int*) &dst_worker_id) >= 0)\n        {\n            sw_atomic_fetch_add(&SwooleStats->tasking_num, 1);\n            list_of_id[i] = task_id;\n        }\n        else\n        {\n            swoole_php_fatal_error(E_WARNING, \"taskwait failed. Error: %s[%d]\", strerror(errno), errno);\n            fail:\n            add_index_bool(return_value, i, 0);\n            n_task --;\n        }\n        i++;\n    SW_HASHTABLE_FOREACH_END();\n\n    while (n_task > 0)\n    {\n        task_notify_pipe->timeout = timeout;\n        int ret = task_notify_pipe->read(task_notify_pipe, &notify, sizeof(notify));\n        if (ret > 0)\n        {\n            if (*finish_count == n_task)\n            {\n                break;\n            }\n        }\n        else\n        {\n            swoole_php_fatal_error(E_WARNING, \"taskwait failed. Error: %s[%d]\", strerror(errno), errno);\n            unlink(_tmpfile);\n            RETURN_FALSE;\n        }\n    }\n\n    swString *content = swoole_file_get_contents(_tmpfile);\n    if (content == NULL)\n    {\n        return;\n    }\n\n    swEventData *result;\n    zval *zdata;\n    int j;\n\n    for (i = 0; i < n_task; i++)\n    {\n        result = (swEventData *) (content->str + content->offset);\n        task_id = result->info.fd;\n        zdata = php_swoole_get_task_result(result TSRMLS_CC);\n        for (j = 0; j < n_task; j++)\n        {\n            if (list_of_id[j] == task_id)\n            {\n                break;\n            }\n        }\n        add_index_zval(return_value, j, zdata);\n        content->offset += sizeof(swDataHead) + result->info.len;\n    }\n    unlink(_tmpfile);\n}\n\nPHP_METHOD(swoole_server, task)\n{\n    swEventData buf;\n    zval *data;\n    zval *callback = NULL;\n\n    long dst_worker_id = -1;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z|lz\", &data, &dst_worker_id, &callback) == FAILURE)\n    {\n        return;\n    }\n\n    if (php_swoole_check_task_param(dst_worker_id TSRMLS_CC) < 0)\n    {\n        RETURN_FALSE;\n    }\n\n    if (php_swoole_task_pack(&buf, data TSRMLS_CC) < 0)\n    {\n        RETURN_FALSE;\n    }\n\n    if (callback && !ZVAL_IS_NULL(callback))\n    {\n#ifdef PHP_SWOOLE_CHECK_CALLBACK\n        char *func_name = NULL;\n        if (!sw_zend_is_callable(callback, 0, &func_name TSRMLS_CC))\n        {\n            swoole_php_fatal_error(E_WARNING, \"Function '%s' is not callable\", func_name);\n            efree(func_name);\n            return;\n        }\n        efree(func_name);\n#endif\n        swTask_type(&buf) |= SW_TASK_CALLBACK;\n        sw_zval_add_ref(&callback);\n        swHashMap_add_int(task_callbacks, buf.info.fd, sw_zval_dup(callback));\n    }\n\n    swTask_type(&buf) |= SW_TASK_NONBLOCK;\n    if (swProcessPool_dispatch(&SwooleGS->task_workers, &buf, (int*) &dst_worker_id) >= 0)\n    {\n        sw_atomic_fetch_add(&SwooleStats->tasking_num, 1);\n        RETURN_LONG(buf.info.fd);\n    }\n    else\n    {\n        RETURN_FALSE;\n    }\n}\n\nPHP_METHOD(swoole_server, sendMessage)\n{\n    zval *zobject = getThis();\n    swEventData buf;\n\n    char *msg;\n    zend_size_t msglen;\n    long worker_id = -1;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"sl\", &msg, &msglen, &worker_id) == FAILURE)\n    {\n        return;\n    }\n\n    if (worker_id == SwooleWG.id)\n    {\n        swoole_php_fatal_error(E_WARNING, \"cannot send message to self.\");\n        RETURN_FALSE;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n    if (worker_id >= serv->worker_num + SwooleG.task_worker_num)\n    {\n        swoole_php_fatal_error(E_WARNING, \"worker_id[%d] is invalid.\", (int) worker_id);\n        RETURN_FALSE;\n    }\n\n    if (!serv->onPipeMessage)\n    {\n        swoole_php_fatal_error(E_WARNING, \"onPipeMessage is null, cannot use sendMessage.\");\n        RETURN_FALSE;\n    }\n\n    buf.info.type = SW_EVENT_PIPE_MESSAGE;\n    buf.info.from_id = SwooleWG.id;\n\n    //write to file\n    if (msglen >= SW_IPC_MAX_SIZE - sizeof(buf.info))\n    {\n        if (swTaskWorker_large_pack(&buf, msg, msglen) < 0)\n        {\n            swoole_php_fatal_error(E_WARNING, \"large task pack failed()\");\n            RETURN_FALSE;\n        }\n    }\n    else\n    {\n        memcpy(buf.data, msg, msglen);\n        buf.info.len = msglen;\n        buf.info.from_fd = 0;\n    }\n\n    swWorker *to_worker = swServer_get_worker(serv, worker_id);\n    SW_CHECK_RETURN(swWorker_send2worker(to_worker, &buf, sizeof(buf.info) + buf.info.len, SW_PIPE_MASTER | SW_PIPE_NONBLOCK));\n}\n\nPHP_METHOD(swoole_server, finish)\n{\n    zval *zobject = getThis();\n    zval *data;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z\", &data) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n    SW_CHECK_RETURN(php_swoole_task_finish(serv, data TSRMLS_CC));\n}\n\nPHP_METHOD(swoole_server, bind)\n{\n    zval *zobject = getThis();\n\n    long fd = 0;\n    long uid = 0;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ll\", &fd, &uid) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n\n    swConnection *conn = swWorker_get_connection(serv, fd);\n\n    //udp client\n    if (conn == NULL)\n    {\n        swTrace(\"%ld conn error\", fd);\n        RETURN_FALSE;\n    }\n\n    //connection is closed\n    if (conn->active == 0)\n    {\n        swTrace(\"fd:%ld a:%d, uid: %ld\", fd, conn->active, conn->uid);\n        RETURN_FALSE;\n    }\n\n    if (conn->uid != 0)\n    {\n        RETURN_FALSE;\n    }\n\n    int ret = 0;\n    SwooleGS->lock.lock(&SwooleGS->lock);\n    if (conn->uid == 0)\n    {\n        conn->uid = uid;\n        ret = 1;\n    }\n    SwooleGS->lock.unlock(&SwooleGS->lock);\n    SW_CHECK_RETURN(ret);\n}\n\n#ifdef SWOOLE_SOCKETS_SUPPORT\nPHP_METHOD(swoole_server, getSocket)\n{\n    long port = 0;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|l\", &port) == FAILURE)\n    {\n        return;\n    }\n\n    zval *zobject = getThis();\n    swServer *serv = swoole_get_object(zobject);\n\n    int sock = swServer_get_socket(serv, port);\n    php_socket *socket_object = swoole_convert_to_socket(sock);\n\n    if (!socket_object)\n    {\n        RETURN_FALSE;\n    }\n    SW_ZEND_REGISTER_RESOURCE(return_value, (void *) socket_object, php_sockets_le_socket());\n}\n#endif\n\nPHP_METHOD(swoole_server, connection_info)\n{\n    zval *zobject = getThis();\n\n    zend_bool noCheckConnection = 0;\n    zval *zfd;\n    long from_id = -1;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z|lb\", &zfd, &from_id, &noCheckConnection) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n\n    long fd = 0;\n    zend_bool ipv6_udp = 0;\n\n    //ipv6 udp\n    if (SW_Z_TYPE_P(zfd) == IS_STRING)\n    {\n        if (is_numeric_string(Z_STRVAL_P(zfd), Z_STRLEN_P(zfd), &fd, NULL, 0))\n        {\n            ipv6_udp = 0;\n        }\n        else\n        {\n            fd = 0;\n            ipv6_udp = 1;\n        }\n    }\n    else\n    {\n        convert_to_long(zfd);\n        fd = Z_LVAL_P(zfd);\n    }\n\n    //udp\n    if (ipv6_udp || swServer_is_udp(fd))\n    {\n        array_init(return_value);\n\n        if (ipv6_udp)\n        {\n            add_assoc_zval(return_value, \"remote_ip\", zfd);\n        }\n        else\n        {\n            struct in_addr sin_addr;\n            sin_addr.s_addr = fd;\n            sw_add_assoc_string(return_value, \"remote_ip\", inet_ntoa(sin_addr), 1);\n        }\n\n        if (from_id == 0)\n        {\n            return;\n        }\n\n        php_swoole_udp_t udp_info;\n        memcpy(&udp_info, &from_id, sizeof(udp_info));\n        //server socket\n        swConnection *from_sock = swServer_connection_get(serv, udp_info.from_fd);\n        if (from_sock)\n        {\n            add_assoc_long(return_value, \"server_fd\", from_sock->fd);\n            add_assoc_long(return_value, \"socket_type\", from_sock->socket_type);\n            add_assoc_long(return_value, \"server_port\", swConnection_get_port(from_sock));\n        }\n        add_assoc_long(return_value, \"remote_port\", udp_info.port);\n        return;\n    }\n\n    swConnection *conn = swServer_connection_verify(serv, fd);\n    if (!conn)\n    {\n        RETURN_FALSE;\n    }\n    //connection is closed\n    if (conn->active == 0 && !noCheckConnection)\n    {\n        RETURN_FALSE;\n    }\n    else\n    {\n        array_init(return_value);\n\n        if (serv->dispatch_mode == SW_DISPATCH_UIDMOD)\n        {\n            add_assoc_long(return_value, \"uid\", conn->uid);\n        }\n\n        swListenPort *port = swServer_get_port(serv, conn->fd);\n        if (port && port->open_websocket_protocol)\n        {\n            add_assoc_long(return_value, \"websocket_status\", conn->websocket_status);\n        }\n\n#ifdef SW_USE_OPENSSL\n        if (conn->ssl_client_cert.length > 0)\n        {\n            sw_add_assoc_stringl(return_value, \"ssl_client_cert\", conn->ssl_client_cert.str, conn->ssl_client_cert.length - 1, 1);\n        }\n#endif\n        //server socket\n        swConnection *from_sock = swServer_connection_get(serv, conn->from_fd);\n        if (from_sock)\n        {\n            add_assoc_long(return_value, \"server_port\", swConnection_get_port(from_sock));\n        }\n        add_assoc_long(return_value, \"server_fd\", conn->from_fd);\n        add_assoc_long(return_value, \"socket_type\", conn->socket_type);\n        add_assoc_long(return_value, \"remote_port\", swConnection_get_port(conn));\n        sw_add_assoc_string(return_value, \"remote_ip\", swConnection_get_ip(conn), 1);\n        add_assoc_long(return_value, \"from_id\", conn->from_id);\n        add_assoc_long(return_value, \"connect_time\", conn->connect_time);\n        add_assoc_long(return_value, \"last_time\", conn->last_time);\n        add_assoc_long(return_value, \"close_errno\", conn->close_errno);\n    }\n}\n\nPHP_METHOD(swoole_server, connection_list)\n{\n    zval *zobject = getThis();\n\n    long start_fd = 0;\n    long find_count = 10;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|ll\", &start_fd, &find_count) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n\n    //\u8d85\u8fc7\u6700\u5927\u67e5\u627e\u6570\u91cf\n    if (find_count > SW_MAX_FIND_COUNT)\n    {\n        swoole_php_fatal_error(E_WARNING, \"swoole_connection_list max_find_count=%d\", SW_MAX_FIND_COUNT);\n        RETURN_FALSE;\n    }\n\n    //\u590d\u5236\u51fa\u6765\u907f\u514d\u88ab\u5176\u4ed6\u8fdb\u7a0b\u6539\u5199\n    int serv_max_fd = swServer_get_maxfd(serv);\n\n    if (start_fd == 0)\n    {\n        start_fd = swServer_get_minfd(serv);\n    }\n#ifdef SW_REACTOR_USE_SESSION\n    else\n    {\n        swConnection *conn = swWorker_get_connection(serv, start_fd);\n        if (!conn)\n        {\n            RETURN_FALSE;\n        }\n        start_fd = conn->fd;\n    }\n#endif\n\n    //\u8fbe\u5230\u6700\u5927\uff0c\u8868\u793a\u5df2\u7ecf\u53d6\u5b8c\u4e86\n    if ((int) start_fd >= serv_max_fd)\n    {\n        RETURN_FALSE;\n    }\n\n    array_init(return_value);\n    int fd = start_fd + 1;\n    swConnection *conn;\n\n    for (; fd <= serv_max_fd; fd++)\n    {\n        swTrace(\"maxfd=%d, fd=%d, find_count=%ld, start_fd=%ld\", serv_max_fd, fd, find_count, start_fd);\n        conn = &serv->connection_list[fd];\n\n        if (conn->active && !conn->closed)\n        {\n#ifdef SW_REACTOR_USE_SESSION\n            add_next_index_long(return_value, conn->session_id);\n#else\n            add_next_index_long(return_value, fd);\n#endif\n            find_count--;\n        }\n        //finish fetch\n        if (find_count <= 0)\n        {\n            break;\n        }\n    }\n}\n\nPHP_METHOD(swoole_server, sendwait)\n{\n    zval *zobject = getThis();\n\n    long fd;\n    zval *zdata;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"lz\", &fd, &zdata) == FAILURE)\n    {\n        return;\n    }\n\n    char *data;\n    int length = php_swoole_get_send_data(zdata, &data TSRMLS_CC);\n\n    if (length < 0)\n    {\n        RETURN_FALSE;\n    }\n    else if (length == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"data is empty.\");\n        RETURN_FALSE;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n\n    if (serv->factory_mode != SW_MODE_SINGLE || swIsTaskWorker())\n    {\n        swoole_php_fatal_error(E_WARNING, \"cannot sendwait.\");\n        RETURN_FALSE;\n    }\n\n    //UDP\n    if (swServer_is_udp(fd))\n    {\n        swoole_php_fatal_error(E_WARNING, \"cannot sendwait.\");\n        RETURN_FALSE;\n    }\n    //TCP\n    else\n    {\n        SW_CHECK_RETURN(swServer_tcp_sendwait(serv, fd, data, length));\n    }\n}\n\nPHP_METHOD(swoole_server, exist)\n{\n    zval *zobject = getThis();\n\n    long fd;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &fd) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(zobject);\n\n    swConnection *conn = swWorker_get_connection(serv, fd);\n    if (!conn)\n    {\n        RETURN_FALSE;\n    }\n    //connection is closed\n    if (conn->active == 0 || conn->closed)\n    {\n        RETURN_FALSE;\n    }\n    else\n    {\n        RETURN_TRUE;\n    }\n}\n\nPHP_METHOD(swoole_server, protect)\n{\n    long fd;\n    zend_bool value = 1;\n\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l|b\", &fd, &value) == FAILURE)\n    {\n        return;\n    }\n\n    swServer *serv = swoole_get_object(getThis());\n\n    swConnection *conn = swWorker_get_connection(serv, fd);\n    if (!conn)\n    {\n        RETURN_FALSE;\n    }\n    //connection is closed\n    if (conn->active == 0 || conn->closed)\n    {\n        RETURN_FALSE;\n    }\n    else\n    {\n        conn->protect = value;\n        RETURN_TRUE;\n    }\n}\n\nPHP_METHOD(swoole_server, shutdown)\n{\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    if (kill(SwooleGS->master_pid, SIGTERM) < 0)\n    {\n        swoole_php_sys_error(E_WARNING, \"shutdown failed. kill(%d, SIGTERM) failed.\", SwooleGS->master_pid);\n        RETURN_FALSE;\n    }\n    else\n    {\n        RETURN_TRUE;\n    }\n}\n\nPHP_METHOD(swoole_server, stop)\n{\n    if (SwooleGS->start == 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Server is not running.\");\n        RETURN_FALSE;\n    }\n\n    long worker_id = SwooleWG.id;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|l\", &worker_id) == FAILURE)\n    {\n        return;\n    }\n\n    if (worker_id == SwooleWG.id)\n    {\n        SwooleG.main_reactor->running = 0;\n        SwooleG.running = 0;\n    }\n    else\n    {\n        swWorker *worker = swServer_get_worker(SwooleG.serv, worker_id);\n        if (worker == NULL)\n        {\n            RETURN_FALSE;\n        }\n        else if (kill(worker->pid, SIGTERM) < 0)\n        {\n            swoole_php_sys_error(E_WARNING, \"kill(%d, SIGTERM) failed.\", worker->pid);\n            RETURN_FALSE;\n        }\n    }\n    RETURN_TRUE;\n}\n\nPHP_METHOD(swoole_server, getLastError)\n{\n    RETURN_LONG(SwooleG.error);\n}\n\n#ifdef HAVE_PCRE\nstatic struct\n{\n    int current_fd;\n    int max_fd;\n    uint32_t session_id;\n    int end;\n    int index;\n} server_itearator;\n\nPHP_METHOD(swoole_connection_iterator, rewind)\n{\n    bzero(&server_itearator, sizeof(server_itearator));\n    server_itearator.current_fd = swServer_get_minfd(SwooleG.serv);\n}\n\nPHP_METHOD(swoole_connection_iterator, valid)\n{\n    int fd = server_itearator.current_fd;\n    swConnection *conn;\n\n    int max_fd = swServer_get_maxfd(SwooleG.serv);\n    for (; fd <= max_fd; fd++)\n    {\n        conn = &SwooleG.serv->connection_list[fd];\n\n        if (conn->active && !conn->closed)\n        {\n#ifdef SW_USE_OPENSSL\n            if (conn->ssl && conn->ssl_state != SW_SSL_STATE_READY)\n            {\n                continue;\n            }\n#endif\n            server_itearator.session_id = conn->session_id;\n            server_itearator.current_fd = fd;\n            server_itearator.index++;\n            RETURN_TRUE;\n        }\n    }\n\n    RETURN_FALSE;\n}\n\nPHP_METHOD(swoole_connection_iterator, current)\n{\n    RETURN_LONG(server_itearator.session_id);\n}\n\nPHP_METHOD(swoole_connection_iterator, next)\n{\n    server_itearator.current_fd ++;\n}\n\nPHP_METHOD(swoole_connection_iterator, key)\n{\n    RETURN_LONG(server_itearator.index);\n}\n\nPHP_METHOD(swoole_connection_iterator, count)\n{\n    RETURN_LONG(SwooleStats->connection_num);\n}\n#endif\n\n/*\n * Local variables:\n * tab-width: 4\n * c-basic-offset: 4\n * End:\n * vim600: noet sw=4 ts=4 fdm=marker\n * vim<600: noet sw=4 ts=4\n */",
        "lookback": "  +----------------------------------------------------------------------+",
        "lookahead": "",
        "label": [
            "base",
            "style_related"
        ],
        "start_line": 0,
        "end_line": 9515,
        "merge_gen_region": null,
        "confidence": 0.685908317565918,
        "hesitated": true
    }
]