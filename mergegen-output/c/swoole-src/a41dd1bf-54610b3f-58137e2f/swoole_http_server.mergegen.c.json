[
    {
        "a_contents": "/*\n  +----------------------------------------------------------------------+\n  | Swoole                                                               |\n  +----------------------------------------------------------------------+\n  | This source file is subject to version 2.0 of the Apache license,    |\n  | that is bundled with this package in the file LICENSE, and is        |\n  | available through the world-wide-web at the following url:           |\n  | http://www.apache.org/licenses/LICENSE-2.0.html                      |\n  | If you did not receive a copy of the Apache2.0 license and are unable|\n  | to obtain it through the world-wide-web, please send a note to       |\n  | license@swoole.com so we can mail you a copy immediately.            |\n  +----------------------------------------------------------------------+\n  | Author: Tianfeng Han  <mikan.tenny@gmail.com>                        |\n  +----------------------------------------------------------------------+\n*/\n\n#include \"php_swoole.h\"\n#include \"swoole_http.h\"\n#ifdef SW_COROUTINE\n#include \"swoole_coroutine.h\"\n#endif\n\n#include <ext/standard/url.h>\n#include <ext/standard/sha1.h>\n#include <ext/standard/php_var.h>\n#include <ext/standard/php_string.h>\n#include <ext/standard/php_math.h>\n#include <ext/standard/php_array.h>\n#include <ext/date/php_date.h>\n#include <ext/standard/md5.h>\n\n#include <main/rfc1867.h>\n#include <main/php_variables.h>\n\n#include \"websocket.h\"\n#include \"Connection.h\"\n#include \"base64.h\"\n\n#ifdef SW_HAVE_ZLIB\n#include <zlib.h>\n#endif\n\n#ifdef SW_USE_HTTP2\n#include \"http2.h\"\n#include <nghttp2/nghttp2.h>\n#endif\n\nstatic swArray *http_client_array;\n\nswString *swoole_http_buffer;\nswString *swoole_zlib_buffer;\nswString *swoole_http_form_data_buffer;\n\nenum http_global_flag\n{\n    HTTP_GLOBAL_GET       = 1u << 1,\n    HTTP_GLOBAL_POST      = 1u << 2,\n    HTTP_GLOBAL_COOKIE    = 1u << 3,\n    HTTP_GLOBAL_REQUEST   = 1u << 4,\n    HTTP_GLOBAL_SERVER    = 1u << 5,\n    HTTP_GLOBAL_FILES     = 1u << 6,\n};\n\nenum http_upload_errno\n{\n    HTTP_UPLOAD_ERR_OK = 0,\n    HTTP_UPLOAD_ERR_INI_SIZE,\n    HTTP_UPLOAD_ERR_FORM_SIZE,\n    HTTP_UPLOAD_ERR_PARTIAL,\n    HTTP_UPLOAD_ERR_NO_FILE,\n    HTTP_UPLOAD_ERR_NO_TMP_DIR = 6,\n    HTTP_UPLOAD_ERR_CANT_WRITE,\n};\n\nzend_class_entry swoole_http_server_ce;\nzend_class_entry *swoole_http_server_class_entry_ptr;\n\nzend_class_entry swoole_http_response_ce;\nzend_class_entry *swoole_http_response_class_entry_ptr;\n\nzend_class_entry swoole_http_request_ce;\nzend_class_entry *swoole_http_request_class_entry_ptr;\n\nstatic int http_onReceive(swServer *serv, swEventData *req);\n\nstatic int http_request_on_path(php_http_parser *parser, const char *at, size_t length);\nstatic int http_request_on_query_string(php_http_parser *parser, const char *at, size_t length);\nstatic int http_request_on_body(php_http_parser *parser, const char *at, size_t length);\nstatic int http_request_on_header_field(php_http_parser *parser, const char *at, size_t length);\nstatic int http_request_on_header_value(php_http_parser *parser, const char *at, size_t length);\nstatic int http_request_on_headers_complete(php_http_parser *parser);\nstatic int http_request_message_complete(php_http_parser *parser);\n\nstatic int multipart_body_on_header_field(multipart_parser* p, const char *at, size_t length);\nstatic int multipart_body_on_header_value(multipart_parser* p, const char *at, size_t length);\nstatic int multipart_body_on_data(multipart_parser* p, const char *at, size_t length);\nstatic int multipart_body_on_header_complete(multipart_parser* p);\nstatic int multipart_body_on_data_end(multipart_parser* p);\nstatic int multipart_body_end(multipart_parser* p);\n\nstatic http_context* http_get_context(zval *object, int check_end TSRMLS_DC);\n\nstatic void http_parse_cookie(zval *array, const char *at, size_t length);\nstatic void http_build_header(http_context *, zval *object, swString *response, int body_length TSRMLS_DC);\nstatic int http_trim_double_quote(zval **value, char **ptr);\n\nstatic inline void http_header_key_format(char *key, int length)\n{\n    int i, state = 0;\n    for (i = 0; i < length; i++)\n    {\n        if (state == 0)\n        {\n            if (key[i] >= 97 && key[i] <= 122)\n            {\n                key[i] -= 32;\n            }\n            state = 1;\n        }\n        else if (key[i] == '-')\n        {\n            state = 0;\n        }\n        else\n        {\n            if (key[i] >= 65 && key[i] <= 90)\n            {\n                key[i] += 32;\n            }\n        }\n    }\n}\n\n#ifdef SW_HAVE_ZLIB\nstatic int http_response_compress(swString *body, int level);\n#endif\n\nstatic PHP_METHOD(swoole_http_server, on);\nstatic PHP_METHOD(swoole_http_server, start);\n\nstatic PHP_METHOD(swoole_http_request, rawcontent);\nstatic PHP_METHOD(swoole_http_request, __destruct);\n\nstatic PHP_METHOD(swoole_http_response, write);\nstatic PHP_METHOD(swoole_http_response, end);\nstatic PHP_METHOD(swoole_http_response, sendfile);\nstatic PHP_METHOD(swoole_http_response, cookie);\nstatic PHP_METHOD(swoole_http_response, rawcookie);\nstatic PHP_METHOD(swoole_http_response, header);\n#ifdef SW_HAVE_ZLIB\nstatic PHP_METHOD(swoole_http_response, gzip);\n#endif\nstatic PHP_METHOD(swoole_http_response, status);\nstatic PHP_METHOD(swoole_http_response, __destruct);\n\nstatic sw_inline char* http_get_method_name(int method)\n{\n    switch (method)\n    {\n    case PHP_HTTP_GET:\n        return \"GET\";\n    case PHP_HTTP_POST:\n        return \"POST\";\n    case PHP_HTTP_HEAD:\n        return \"HEAD\";\n    case PHP_HTTP_PUT:\n        return \"PUT\";\n    case PHP_HTTP_DELETE:\n        return \"DELETE\";\n    case PHP_HTTP_PATCH:\n        return \"PATCH\";\n    case PHP_HTTP_CONNECT:\n        return \"CONNECT\";\n    case PHP_HTTP_OPTIONS:\n        return \"OPTIONS\";\n    case PHP_HTTP_TRACE:\n        return \"TRACE\";\n    case PHP_HTTP_COPY:\n        return \"COPY\";\n    case PHP_HTTP_LOCK:\n        return \"LOCK\";\n    case PHP_HTTP_MKCOL:\n        return \"MKCOL\";\n    case PHP_HTTP_MOVE:\n        return \"MOVE\";\n    case PHP_HTTP_PROPFIND:\n        return \"PROPFIND\";\n    case PHP_HTTP_PROPPATCH:\n        return \"PROPPATCH\";\n    case PHP_HTTP_UNLOCK:\n        return \"UNLOCK\";\n        /* subversion */\n    case PHP_HTTP_REPORT:\n        return \"REPORT\";\n    case PHP_HTTP_MKACTIVITY:\n        return \"MKACTIVITY\";\n    case PHP_HTTP_CHECKOUT:\n        return \"CHECKOUT\";\n    case PHP_HTTP_MERGE:\n        return \"MERGE\";\n        /* upnp */\n    case PHP_HTTP_MSEARCH:\n        return \"MSEARCH\";\n    case PHP_HTTP_NOTIFY:\n        return \"NOTIFY\";\n    case PHP_HTTP_SUBSCRIBE:\n        return \"SUBSCRIBE\";\n    case PHP_HTTP_UNSUBSCRIBE:\n        return \"UNSUBSCRIBE\";\n    case PHP_HTTP_NOT_IMPLEMENTED:\n        return \"IMPLEMENTED\";\n    default:\n        return NULL;\n    }\n}\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_http_server_on, 0, 0, 2)\n    ZEND_ARG_INFO(0, ha_name)\n    ZEND_ARG_INFO(0, cb)\nZEND_END_ARG_INFO()\n\nstatic const php_http_parser_settings http_parser_settings =\n{\n    NULL,\n    http_request_on_path,\n    http_request_on_query_string,\n    NULL,\n    NULL,\n    http_request_on_header_field,\n    http_request_on_header_value,\n    http_request_on_headers_complete,\n    http_request_on_body,\n    http_request_message_complete\n};\n\nstatic const multipart_parser_settings mt_parser_settings = \n{\n    multipart_body_on_header_field,\n    multipart_body_on_header_value,\n    multipart_body_on_data,\n    NULL,\n    multipart_body_on_header_complete,\n    multipart_body_on_data_end,\n    multipart_body_end\n};\n\nconst zend_function_entry swoole_http_server_methods[] =\n{\n    PHP_ME(swoole_http_server, on,         arginfo_swoole_http_server_on, ZEND_ACC_PUBLIC)\n    PHP_ME(swoole_http_server, start,      NULL, ZEND_ACC_PUBLIC)\n    PHP_FE_END\n};\n\nconst zend_function_entry swoole_http_request_methods[] =\n{\n    PHP_ME(swoole_http_request, rawcontent, NULL, ZEND_ACC_PUBLIC)\n    PHP_ME(swoole_http_request, __destruct, NULL, ZEND_ACC_PUBLIC | ZEND_ACC_DTOR)\n    PHP_FE_END\n};\n\nconst zend_function_entry swoole_http_response_methods[] =\n{\n    PHP_ME(swoole_http_response, cookie, NULL, ZEND_ACC_PUBLIC)\n    PHP_ME(swoole_http_response, rawcookie, NULL, ZEND_ACC_PUBLIC)\n    PHP_ME(swoole_http_response, status, NULL, ZEND_ACC_PUBLIC)\n#ifdef SW_HAVE_ZLIB\n    PHP_ME(swoole_http_response, gzip, NULL, ZEND_ACC_PUBLIC)\n#endif\n    PHP_ME(swoole_http_response, header, NULL, ZEND_ACC_PUBLIC)\n    PHP_ME(swoole_http_response, write, NULL, ZEND_ACC_PUBLIC)\n    PHP_ME(swoole_http_response, end, NULL, ZEND_ACC_PUBLIC)\n    PHP_ME(swoole_http_response, sendfile, NULL, ZEND_ACC_PUBLIC)\n    PHP_ME(swoole_http_response, __destruct, NULL, ZEND_ACC_PUBLIC | ZEND_ACC_DTOR)\n    PHP_FE_END\n};\n\nstatic int http_request_on_path(php_http_parser *parser, const char *at, size_t length)\n{\n    http_context *ctx = parser->data;\n    ctx->request.path = estrndup(at, length);\n    ctx->request.path_len = length;\n    return 0;\n}\n\nstatic int http_request_on_query_string(php_http_parser *parser, const char *at, size_t length)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n    http_context *ctx = parser->data;\n\n    //no need free, will free by treat_data\n    char *query = estrndup(at, length);\n    sw_add_assoc_stringl_ex(ctx->request.zserver, ZEND_STRS(\"query_string\"), query, length, 1);\n\n    zval *zrequest_object = ctx->request.zobject;\n    zval *zget;\n    swoole_http_server_array_init(get, request);\n\n    //parse url params\n    sapi_module.treat_data(PARSE_STRING, query, zget TSRMLS_CC);\n\n    return 0;\n}\n\nstatic int http_request_on_header_field(php_http_parser *parser, const char *at, size_t length)\n{\n    http_context *ctx = parser->data;\n    if (ctx->current_header_name_allocated)\n    {\n        efree(ctx->current_header_name);\n        ctx->current_header_name_allocated = 0;\n    }\n    ctx->current_header_name = (char *) at;\n    ctx->current_header_name_len = length;\n    return 0;\n}\n\nint swoole_http_parse_form_data(http_context *ctx, const char *boundary_str, int boundary_len TSRMLS_DC)\n{\n    multipart_parser *mt_parser = multipart_parser_init(boundary_str, boundary_len, &mt_parser_settings);\n    if (!mt_parser)\n    {\n        swoole_php_fatal_error(E_WARNING, \"multipart_parser_init() failed.\");\n        return SW_ERR;\n    }\n\n    ctx->mt_parser = mt_parser;\n    mt_parser->data = ctx;\n\n    return SW_OK;\n}\n\nstatic void http_parse_cookie(zval *array, const char *at, size_t length)\n{\n    char keybuf[SW_HTTP_COOKIE_KEYLEN];\n    char valbuf[SW_HTTP_COOKIE_VALLEN];\n    char *_c = (char *) at;\n\n    int klen = 0;\n    int vlen = 0;\n    int state = -1;\n\t\n    int i = 0, j = 0;\n    while (_c < at + length)\n    {\n        if (state <= 0 && *_c == '=')\n        {\n            klen = i - j + 1;\n            if (klen >= SW_HTTP_COOKIE_KEYLEN)\n            {\n                swWarn(\"cookie key is too large.\");\n                return;\n            }\n            memcpy(keybuf, at + j, klen - 1);\n            keybuf[klen - 1] = 0;\n\n            j = i + 1;\n            state = 1;\n        }\n        else if (state == 1 && *_c == ';')\n        {\n            vlen = i - j;\n            strncpy(valbuf, (char * ) at + j, SW_HTTP_COOKIE_VALLEN);\n            vlen = php_url_decode(valbuf, vlen);\n            if (klen > 1)\n            {\n                sw_add_assoc_stringl_ex(array, keybuf, klen, valbuf, vlen, 1);\n            }\n            j = i + 1;\n            state = -1;\n        }\n        else if (state < 0)\n        {\n            if (isspace(*_c))\n            {\n                //Remove leading spaces from cookie names \n                ++j;\n            } \n            else\n            {\n                state = 0;\n            }\n        }\n        _c++;\n        i++;\n    }\n    if (j < length)\n    {\n        vlen = i - j;\n        keybuf[klen - 1] = 0;\n        strncpy(valbuf, (char * ) at + j, SW_HTTP_COOKIE_VALLEN);\n        vlen = php_url_decode(valbuf, vlen);\n        if (klen > 1)\n        {\n            sw_add_assoc_stringl_ex(array, keybuf, klen, valbuf, vlen, 1);\n        }\n    }\n}\n\nstatic int http_trim_double_quote(zval **value, char **ptr)\n{\n    int len = Z_STRLEN_PP(value);\n    *ptr = Z_STRVAL_PP(value);\n\n    //ltrim('\"')\n    if ((*ptr)[0] == '\"')\n    {\n        (*ptr)++;\n        len--;\n    }\n    //rtrim('\"')\n    if ((*ptr)[len - 1] == '\"')\n    {\n        len--;\n    }\n    return len;\n}\n\nstatic int http_request_on_header_value(php_http_parser *parser, const char *at, size_t length)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    http_context *ctx = parser->data;\n    zval *zrequest_object = ctx->request.zobject;\n    char *header_name = zend_str_tolower_dup(ctx->current_header_name, ctx->current_header_name_len);\n\n    if (strncasecmp(header_name, \"cookie\", ctx->current_header_name_len) == 0)\n    {\n        zval *zcookie;\n        if (length >= SW_HTTP_COOKIE_VALLEN)\n        {\n            swWarn(\"cookie is too large.\");\n        }\n        else\n        {\n            swoole_http_server_array_init(cookie, request);\n            http_parse_cookie(zcookie, at, length);\n        }\n        goto free_memory;\n    }\n    else if (SwooleG.serv->listen_list->open_websocket_protocol && strncasecmp(header_name, ZEND_STRL(\"upgrade\")) == 0 && strncasecmp(at, ZEND_STRL(\"websocket\")) == 0)\n    {\n        swConnection *conn = swWorker_get_connection(SwooleG.serv, ctx->fd);\n        if (!conn)\n        {\n            swWarn(\"connection[%d] is closed.\", ctx->fd);\n            return SW_ERR;\n        }\n        conn->websocket_status = WEBSOCKET_STATUS_CONNECTION;\n    }\n    else if (parser->method == PHP_HTTP_POST || parser->method == PHP_HTTP_PUT || parser->method == PHP_HTTP_DELETE || parser->method == PHP_HTTP_PATCH)\n    {\n        if (memcmp(header_name, ZEND_STRL(\"content-type\")) == 0)\n        {\n            if (strncasecmp(at, ZEND_STRL(\"application/x-www-form-urlencoded\")) == 0)\n            {\n                ctx->request.post_form_urlencoded = 1;\n            }\n            else if (memcmp(header_name, ZEND_STRL(\"content-type\")) == 0 && strncasecmp(at, ZEND_STRL(\"multipart/form-data\")) == 0)\n            {\n                int boundary_len = length - strlen(\"multipart/form-data; boundary=\");\n                if (boundary_len <= 0)\n                {\n                    swWarn(\"invalid multipart/form-data body.\", ctx->fd);\n                    return 0;\n                }\n                swoole_http_parse_form_data(ctx, at + length - boundary_len, boundary_len TSRMLS_CC);\n            }\n        }\n    }\n\n    zval *header = ctx->request.zheader;\n    sw_add_assoc_stringl_ex(header, header_name, ctx->current_header_name_len + 1, (char *) at, length, 1);\n\n    free_memory:\n    if (ctx->current_header_name_allocated)\n    {\n        efree(ctx->current_header_name);\n        ctx->current_header_name_allocated = 0;\n    }\n    efree(header_name);\n\n    return 0;\n}\n\nstatic int http_request_on_headers_complete(php_http_parser *parser)\n{\n    http_context *ctx = parser->data;\n    if (ctx->current_header_name_allocated)\n    {\n        efree(ctx->current_header_name);\n        ctx->current_header_name_allocated = 0;\n    }\n    ctx->current_header_name = NULL;\n\n    return 0;\n}\n\nstatic int multipart_body_on_header_field(multipart_parser* p, const char *at, size_t length)\n{\n    http_context *ctx = p->data;\n    return http_request_on_header_field(&ctx->parser, at, length);\n}\n\nstatic int multipart_body_on_header_value(multipart_parser* p, const char *at, size_t length)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    http_context *ctx = p->data;\n    zval *zrequest_object = ctx->request.zobject;\n    zval *zfiles = ctx->request.zfiles;\n    if (!zfiles)\n    {\n        swoole_http_server_array_init(files, request);\n    }\n\n    char *headername = zend_str_tolower_dup(ctx->current_header_name, ctx->current_header_name_len);\n\n    if (strncasecmp(headername, ZEND_STRL(\"content-disposition\")) == 0)\n    {\n        //not form data\n        if (swoole_strnpos((char *) at, length, ZEND_STRL(\"form-data;\")) < 0)\n        {\n            return SW_OK;\n        }\n\n        zval *tmp_array;\n        SW_MAKE_STD_ZVAL(tmp_array);\n        array_init(tmp_array);\n        http_parse_cookie(tmp_array, (char *) at + sizeof(\"form-data;\"), length - sizeof(\"form-data;\"));\n\n        zval *form_name;\n        if (sw_zend_hash_find(Z_ARRVAL_P(tmp_array), ZEND_STRS(\"name\"), (void **) &form_name) == FAILURE)\n        {\n            return SW_OK;\n        }\n\n        char *str;\n        int len = http_trim_double_quote(&form_name, &str);\n\n        zval *filename;\n        //POST form data\n        if (sw_zend_hash_find(Z_ARRVAL_P(tmp_array), ZEND_STRS(\"filename\"), (void **) &filename) == FAILURE)\n        {\n            ctx->current_form_data_name = estrndup(str, len);\n            ctx->current_form_data_name_len = len;\n        }\n        //upload file\n        else\n        {\n            ctx->current_input_name = estrndup(str, len);\n\n            zval *multipart_header;\n            SW_MAKE_STD_ZVAL(multipart_header);\n            array_init(multipart_header);\n            add_assoc_zval(zfiles, ctx->current_input_name, multipart_header);\n\n            sw_add_assoc_string(multipart_header, \"name\", \"\", 1);\n            sw_add_assoc_string(multipart_header, \"type\", \"\", 1);\n            sw_add_assoc_string(multipart_header, \"tmp_name\", \"\", 1);\n            add_assoc_long(multipart_header, \"error\", HTTP_UPLOAD_ERR_OK);\n            add_assoc_long(multipart_header, \"size\", 0);\n\n            len = http_trim_double_quote(&filename, &str);\n            sw_add_assoc_stringl(multipart_header, \"name\", str, len, 1);\n        }\n        sw_zval_ptr_dtor(&tmp_array);\n    }\n\n    if (strncasecmp(headername, ZEND_STRL(\"content-type\")) == 0)\n    {\n        zval *multipart_header = NULL;\n        sw_zend_hash_find(Z_ARRVAL_P(zfiles), ctx->current_input_name, strlen(ctx->current_input_name) + 1, (void **) &multipart_header);\n        sw_add_assoc_stringl(multipart_header, \"type\", (char * ) at, length, 1);\n    }\n\n    if (ctx->current_header_name_allocated)\n    {\n        efree(ctx->current_header_name);\n        ctx->current_header_name_allocated = 0;\n    }\n    efree(headername);\n\n    return 0;\n}\n\nstatic int multipart_body_on_data(multipart_parser* p, const char *at, size_t length)\n{\n    http_context *ctx = p->data;\n    if (ctx->current_form_data_name)\n    {\n        swString_append_ptr(swoole_http_form_data_buffer, (char*) at, length);\n        return 0;\n    }\n    if (p->fp == NULL)\n    {\n        return 0;\n    }\n    int n = fwrite(at, sizeof(char), length, (FILE *) p->fp);\n    if (n != length)\n    {\n        zval *files = ctx->request.zfiles;\n        zval *multipart_header = NULL;\n        sw_zend_hash_find(Z_ARRVAL_P(files), ctx->current_input_name, strlen(ctx->current_input_name) + 1, (void **) &multipart_header);\n        add_assoc_long(multipart_header, \"error\", HTTP_UPLOAD_ERR_CANT_WRITE);\n\n        fclose((FILE *) p->fp);\n        p->fp = NULL;\n\n        swWarn(\"write upload file failed. Error %s[%d]\", strerror(errno), errno);\n    }\n    return 0;\n}\n\n#if 0\nstatic void get_random_file_name(char *des, const char *src)\n{\n    unsigned char digest[16] = {0};\n    char buf[19] = {0};\n    int n = sprintf(buf, \"%s%d\", src, swoole_system_random(0, 9999));\n\n    PHP_MD5_CTX ctx;\n    PHP_MD5Init(&ctx);\n    PHP_MD5Update(&ctx, buf, n);\n    PHP_MD5Final(digest, &ctx);\n    make_digest_ex(des, digest, 16);\n}\n#endif\n\nstatic int multipart_body_on_header_complete(multipart_parser* p)\n{\n    http_context *ctx = p->data;\n    if (!ctx->current_input_name)\n    {\n        return 0;\n    }\n\n    zval *files = ctx->request.zfiles;\n    zval *multipart_header;\n\n    if (sw_zend_hash_find(Z_ARRVAL_P(files), ctx->current_input_name, strlen(ctx->current_input_name) + 1, (void **) &multipart_header) == FAILURE)\n    {\n        return 0;\n    }\n\n    zval *zerr = NULL;\n    sw_zend_hash_find(Z_ARRVAL_P(multipart_header), ZEND_STRS(\"error\"), (void **) &zerr);\n    if (Z_LVAL_P(zerr) != HTTP_UPLOAD_ERR_OK)\n    {\n        return 0;\n    }\n\n    char file_path[sizeof(SW_HTTP_UPLOAD_TMP_FILE)];\n    memcpy(file_path, SW_HTTP_UPLOAD_TMP_FILE, sizeof(SW_HTTP_UPLOAD_TMP_FILE));\n    int tmpfile = swoole_tmpfile(file_path);\n\n    FILE *fp = fdopen(tmpfile, \"wb+\");\n    if (fp < 0)\n    {\n        add_assoc_long(multipart_header, \"error\", HTTP_UPLOAD_ERR_NO_TMP_DIR);\n        swWarn(\"fopen(%s) failed. Error %s[%d]\", file_path, strerror(errno), errno);\n        return 0;\n    }\n\n    p->fp = fp;\n    sw_add_assoc_string(multipart_header, \"tmp_name\", file_path, 1);\n\n    return 0;\n}\n\nstatic int multipart_body_on_data_end(multipart_parser* p)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    http_context *ctx = p->data;\n    zval *zrequest_object = ctx->request.zobject;\n    if (ctx->current_form_data_name)\n    {\n        zval *zpost = sw_zend_read_property(swoole_http_request_class_entry_ptr, zrequest_object, ZEND_STRL(\"post\"), 1 TSRMLS_CC);\n        if (ZVAL_IS_NULL(zpost))\n        {\n            swoole_http_server_array_init(post, request);\n        }\n\n\t\tchar *name = ctx->current_form_data_name;\n\t\tint len = ctx->current_form_data_name_len;\n\n\t\tif ((name[len-1] == ']') && (name[len-2] == '['))\n\t\t{\n\t\t\tzval *array_value;\n\t\t\tif (sw_zend_hash_find(Z_ARRVAL_P(zpost), name, len + 1, (void **) &array_value) == FAILURE)\n\t\t\t{\n\t\t\t\tSW_MAKE_STD_ZVAL(array_value);\n\t\t\t\tarray_init(array_value);\n\t\t\t\tadd_assoc_zval(zpost, name, array_value);\n\t\t\t}\n            sw_add_next_index_stringl(array_value, swoole_http_form_data_buffer->str, swoole_http_form_data_buffer->length, 1);\n\t\t}\n\t\telse\n\t\t{\n            sw_add_assoc_stringl_ex(zpost, ctx->current_form_data_name, ctx->current_form_data_name_len + 1,\n                    swoole_http_form_data_buffer->str, swoole_http_form_data_buffer->length, 1);\n\t\t}\n\n        efree(ctx->current_form_data_name);\n        ctx->current_form_data_name = NULL;\n        ctx->current_form_data_name_len = 0;\n        swString_clear(swoole_http_form_data_buffer);\n        return 0;\n    }\n\n    if (!ctx->current_input_name)\n    {\n        return 0;\n    }\n\n    zval *files = ctx->request.zfiles;\n    if (ZVAL_IS_NULL(files))\n    {\n        return 0;\n    }\n\n    zval *multipart_header = NULL;\n    sw_zend_hash_find(Z_ARRVAL_P(files), ctx->current_input_name, strlen(ctx->current_input_name) + 1, (void **) &multipart_header);\n\n    if (p->fp != NULL)\n    {\n        long size = swoole_file_get_size((FILE*) p->fp);\n        add_assoc_long(multipart_header, \"size\", size);\n\n        fclose((FILE *)p->fp);\n        p->fp = NULL;\n    }\n\n    efree(ctx->current_input_name);\n\n    return 0;\n}\n\nstatic int multipart_body_end(multipart_parser* p)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    http_context *ctx = p->data;\n    zval *files = ctx->request.zfiles;\n    zval *value;\n\n    SW_HASHTABLE_FOREACH_START(Z_ARRVAL_P(files), value)\n    {\n        zval *file_path;\n        if (sw_zend_hash_find(Z_ARRVAL_P(value), ZEND_STRS(\"tmp_name\"), (void **) &file_path) == SUCCESS)\n        {\n#if PHP_MAJOR_VERSION >= 7\n            zend_string *tmp_name = zval_get_string(file_path);\n            zend_hash_add_ptr(SG(rfc1867_uploaded_files), tmp_name, tmp_name);\n#else\n            char *temp_filename = Z_STRVAL_P(file_path);\n            sw_zend_hash_add(SG(rfc1867_uploaded_files), temp_filename, Z_STRLEN_P(file_path) + 1, &temp_filename, sizeof(char *), NULL);\n#endif\n        }\n    }\n    SW_HASHTABLE_FOREACH_END();\n\n    return 0;\n}\n\nstatic int http_request_on_body(php_http_parser *parser, const char *at, size_t length)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    http_context *ctx = parser->data;\n    zval *zrequest_object = ctx->request.zobject;\n    char *body;\n\n    ctx->request.post_length = length;\n    if (SwooleG.serv->http_parse_post && ctx->request.post_form_urlencoded)\n    {\n        zval *zpost;\n        swoole_http_server_array_init(post, request);\n        body = estrndup(at, length);\n\n        sapi_module.treat_data(PARSE_STRING, body, zpost TSRMLS_CC);\n    }\n    else if (ctx->mt_parser != NULL)\n    {\n        multipart_parser *multipart_parser = ctx->mt_parser;\n        size_t n = multipart_parser_execute(multipart_parser, at, length);\n        if (n != length)\n        {\n            swoole_php_fatal_error(E_WARNING, \"parse multipart body failed.\");\n        }\n    }\n\n    return 0;\n}\n\nstatic int http_request_message_complete(php_http_parser *parser)\n{\n    http_context *ctx = parser->data;\n    ctx->request.version = parser->http_major * 100 + parser->http_minor;\n\n    const char *vpath = ctx->request.path, *end = vpath + ctx->request.path_len, *p = end;\n    ctx->request.ext = end;\n    ctx->request.ext_len = 0;\n    while (p > vpath)\n    {\n        --p;\n        if (*p == '.')\n        {\n            ++p;\n            ctx->request.ext = p;\n            ctx->request.ext_len = end - p;\n            break;\n        }\n    }\n    ctx->request_read = 1;\n\n    if (ctx->mt_parser)\n    {\n        multipart_parser_free(ctx->mt_parser);\n        ctx->mt_parser = NULL;\n    }\n\n    return 0;\n}\n\nstatic int http_onReceive(swServer *serv, swEventData *req)\n{\n    int fd = req->info.fd;\n\n    swConnection *conn = swWorker_get_connection(SwooleG.serv, fd);\n    if (!conn)\n    {\n        swWarn(\"connection[%d] is closed.\", fd);\n        return SW_ERR;\n    }\n    swListenPort *port = serv->connection_list[req->info.from_fd].object;\n    //other server port\n    if (!port->open_http_protocol)\n    {\n        return php_swoole_onReceive(serv, req);\n    }\n    //websocket client\n    if (conn->websocket_status == WEBSOCKET_STATUS_ACTIVE)\n    {\n        return swoole_websocket_onMessage(req);\n    }\n\n    swoole_http_client *client = swArray_fetch(http_client_array, conn->fd);\n    if (!client)\n    {\n        return SW_OK;\n    }\n    client->fd = fd;\n\n#ifdef SW_USE_HTTP2\n    if (conn->http2_stream)\n    {\n        client->http2 = 1;\n        return swoole_http2_onFrame(client, req);\n    }\n#endif\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    http_context *ctx = swoole_http_context_new(client TSRMLS_CC);\n    php_http_parser *parser = &ctx->parser;\n    zval *zserver = ctx->request.zserver;\n\n    parser->data = ctx;\n\n    php_http_parser_init(parser, PHP_HTTP_REQUEST);\n\n    zval *zdata;\n    SW_MAKE_STD_ZVAL(zdata);\n    ctx->request.zdata = zdata;\n    php_swoole_get_recv_data(zdata, req, NULL, 0);\n    sw_copy_to_stack(ctx->request.zdata, ctx->request._zdata);\n\n    swTrace(\"httpRequest %d bytes:\\n---------------------------------------\\n%s\\n\", Z_STRLEN_P(zdata), Z_STRVAL_P(zdata));\n\n    long n = php_http_parser_execute(parser, &http_parser_settings, Z_STRVAL_P(zdata), Z_STRLEN_P(zdata));\n    if (n < 0)\n    {\n        sw_zval_ptr_dtor(&zdata);\n        efree(client);\n        swWarn(\"php_http_parser_execute failed.\");\n\n        if (conn->websocket_status == WEBSOCKET_STATUS_CONNECTION)\n        {\n            return SwooleG.serv->factory.end(&SwooleG.serv->factory, fd);\n        }\n    }\n    else\n    {\n        zval *retval;\n#ifndef SW_COROUTINE\n        zval **args[2];\n#else\n        zval *args[2];\n#endif\n\n        zval *zrequest_object = ctx->request.zobject;\n        zval *zresponse_object = ctx->response.zobject;\n\n        ctx->keepalive = php_http_should_keep_alive(parser);\n        char *method_name = http_get_method_name(parser->method);\n\n        sw_add_assoc_string(zserver, \"request_method\", method_name, 1);\n        sw_add_assoc_stringl(zserver, \"request_uri\", ctx->request.path, ctx->request.path_len, 1);\n        sw_add_assoc_stringl(zserver, \"path_info\", ctx->request.path, ctx->request.path_len, 1);\n        sw_add_assoc_long_ex(zserver, ZEND_STRS(\"request_time\"), SwooleGS->now);\n\n        // Add REQUEST_TIME_FLOAT\n        double now_float = swoole_microtime();\n        sw_add_assoc_double_ex(zserver, ZEND_STRS(\"request_time_float\"), now_float);\n\n        swConnection *conn = swWorker_get_connection(SwooleG.serv, fd);\n        if (!conn)\n        {\n            sw_zval_ptr_dtor(&zdata);\n            swWarn(\"connection[%d] is closed.\", fd);\n            return SW_ERR;\n        }\n\n        add_assoc_long(ctx->request.zserver, \"server_port\", swConnection_get_port(&SwooleG.serv->connection_list[conn->from_fd]));\n        add_assoc_long(ctx->request.zserver, \"remote_port\", swConnection_get_port(conn));\n        sw_add_assoc_string(zserver, \"remote_addr\", swConnection_get_ip(conn), 1);\n\n        if (ctx->request.version == 101)\n        {\n            sw_add_assoc_string(zserver, \"server_protocol\", \"HTTP/1.1\", 1);\n        }\n        else\n        {\n            sw_add_assoc_string(zserver, \"server_protocol\", \"HTTP/1.0\", 1);\n        }\n\n        sw_add_assoc_string(zserver, \"server_software\", SW_HTTP_SERVER_SOFTWARE, 1);\n\n        zval *zcallback = php_swoole_server_get_callback(serv, req->info.from_fd, SW_SERVER_CB_onHandShake);\n        //websocket handshake\n        if (conn->websocket_status == WEBSOCKET_STATUS_CONNECTION && zcallback == NULL)\n        {\n            return swoole_websocket_onHandshake(ctx);\n        }\n        \n#ifndef SW_COROUTINE\n        args[0] = &zrequest_object;\n        args[1] = &zresponse_object;\n#else\n        args[0] = zrequest_object;\n        args[1] = zresponse_object;\n#endif\n\n        int callback_type = 0;\n        if (conn->websocket_status == WEBSOCKET_STATUS_CONNECTION)\n        {\n            callback_type = SW_SERVER_CB_onHandShake;\n            conn->websocket_status = WEBSOCKET_STATUS_HANDSHAKE;\n        }\n        else\n        {\n            callback_type = SW_SERVER_CB_onRequest;\n            zcallback = php_swoole_server_get_callback(serv, req->info.from_fd, SW_SERVER_CB_onRequest);\n            //no have onRequest callback\n            if (zcallback == NULL)\n            {\n                swoole_websocket_onReuqest(ctx);\n                return SW_OK;\n            }\n        }\n\n#ifndef SW_COROUTINE\n        zcallback = php_swoole_server_get_callback(serv, req->info.from_fd, callback_type);\n        if (sw_call_user_function_ex(EG(function_table), NULL, zcallback, &retval, 2, args, 0, NULL TSRMLS_CC) == FAILURE)\n        {\n            swoole_php_error(E_WARNING, \"onRequest handler error\");\n        }\n#else\n        zend_fcall_info_cache *cache = php_swoole_server_get_cache(serv, req->info.from_fd, callback_type);\n        int ret = coro_create(cache, args, 2, &retval);\n        if (ret != 0)\n        {\n            sw_zval_ptr_dtor(&zrequest_object);\n            sw_zval_ptr_dtor(&zresponse_object);\n            if (ret == CORO_LIMIT)\n            {\n                SwooleG.serv->factory.end(&SwooleG.serv->factory, fd);\n            }\n            return SW_OK;\n        }\n#endif\n        if (EG(exception))\n        {\n            zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n        }\n        //websocket user handshake\n        if (conn->websocket_status == WEBSOCKET_STATUS_HANDSHAKE)\n        {\n            //handshake success\n            if (retval && Z_BVAL_P(retval))\n            {\n                conn->websocket_status = WEBSOCKET_STATUS_ACTIVE;\n            }\n        }\n        sw_zval_ptr_dtor(&zrequest_object);\n        sw_zval_ptr_dtor(&zresponse_object);\n        if (retval)\n        {\n            sw_zval_ptr_dtor(&retval);\n        }\n    }\n    return SW_OK;\n}\n\nvoid swoole_http_server_init(int module_number TSRMLS_DC)\n{\n    SWOOLE_INIT_CLASS_ENTRY(swoole_http_server_ce, \"swoole_http_server\", \"Swoole\\\\Http\\\\Server\", swoole_http_server_methods);\n    swoole_http_server_class_entry_ptr = sw_zend_register_internal_class_ex(&swoole_http_server_ce, swoole_server_class_entry_ptr, \"swoole_server\" TSRMLS_CC);\n\n    zend_declare_property_long(swoole_http_server_class_entry_ptr, ZEND_STRL(\"global\"), 0, ZEND_ACC_PRIVATE TSRMLS_CC);\n\n    SWOOLE_INIT_CLASS_ENTRY(swoole_http_response_ce, \"swoole_http_response\", \"Swoole\\\\Http\\\\Response\", swoole_http_response_methods);\n    swoole_http_response_class_entry_ptr = zend_register_internal_class(&swoole_http_response_ce TSRMLS_CC);\n\n    SWOOLE_INIT_CLASS_ENTRY(swoole_http_request_ce, \"swoole_http_request\", \"Swoole\\\\Http\\\\Request\", swoole_http_request_methods);\n    swoole_http_request_class_entry_ptr = zend_register_internal_class(&swoole_http_request_ce TSRMLS_CC);\n}\n\nstatic PHP_METHOD(swoole_http_server, on)\n{\n    zval *callback;\n    zval *event_name;\n\n    if (SwooleGS->start > 0)\n    {\n        swoole_php_error(E_WARNING, \"Server is running. Unable to set event callback now.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"zz\", &event_name, &callback) == FAILURE)\n    {\n        return;\n    }\n\n#ifdef PHP_SWOOLE_CHECK_CALLBACK\n    char *func_name = NULL;\n#ifndef SW_COROUTINE\n    if (!sw_zend_is_callable(callback, 0, &func_name TSRMLS_CC))\n#else\n    zend_fcall_info_cache *func_cache = emalloc(sizeof(zend_fcall_info_cache));\n    if (!zend_is_callable_ex(callback, NULL, 0, &func_name, NULL, func_cache, NULL TSRMLS_CC))\n#endif\n    {\n        swoole_php_fatal_error(E_ERROR, \"Function '%s' is not callable\", func_name);\n        efree(func_name);\n        RETURN_FALSE;\n    }\n    efree(func_name);\n#endif\n\n    if (strncasecmp(\"request\", Z_STRVAL_P(event_name), Z_STRLEN_P(event_name)) == 0)\n    {\n        zend_update_property(swoole_http_server_class_entry_ptr, getThis(), ZEND_STRL(\"onRequest\"), callback TSRMLS_CC);\n        php_sw_server_callbacks[SW_SERVER_CB_onRequest] = sw_zend_read_property(swoole_http_server_class_entry_ptr, getThis(), ZEND_STRL(\"onRequest\"), 0 TSRMLS_CC);\n        sw_copy_to_stack(php_sw_server_callbacks[SW_SERVER_CB_onRequest], _php_sw_server_callbacks[SW_SERVER_CB_onRequest]);\n#ifdef SW_COROUTINE\n        php_sw_server_caches[SW_SERVER_CB_onRequest] = func_cache;\n#endif\n    }\n    else if (strncasecmp(\"handshake\", Z_STRVAL_P(event_name), Z_STRLEN_P(event_name)) == 0)\n    {\n        zend_update_property(swoole_http_server_class_entry_ptr, getThis(), ZEND_STRL(\"onHandshake\"), callback TSRMLS_CC);\n        php_sw_server_callbacks[SW_SERVER_CB_onHandShake] = sw_zend_read_property(swoole_http_server_class_entry_ptr, getThis(), ZEND_STRL(\"onHandshake\"), 0 TSRMLS_CC);\n        sw_copy_to_stack(php_sw_server_callbacks[SW_SERVER_CB_onHandShake], _php_sw_server_callbacks[SW_SERVER_CB_onHandShake]);\n#ifdef SW_COROUTINE\n        php_sw_server_caches[SW_SERVER_CB_onHandShake] = func_cache;\n#endif\n    }\n    else\n    {\n        zval *obj = getThis();\n        sw_zend_call_method_with_2_params(&obj, swoole_server_class_entry_ptr, NULL, \"on\", &return_value, event_name, callback);\n    }\n}\n\nhttp_context* swoole_http_context_new(swoole_http_client* client TSRMLS_DC)\n{\n    http_context *ctx = emalloc(sizeof(http_context));\n    if (!ctx)\n    {\n        swoole_error_log(SW_LOG_ERROR, SW_ERROR_MALLOC_FAIL, \"emalloc(%ld) failed.\", sizeof(http_context));\n        return NULL;\n    }\n    bzero(ctx, sizeof(http_context));\n\n    zval *zrequest_object;\n#if PHP_MAJOR_VERSION >= 7\n    zrequest_object = &ctx->request._zobject;\n#else\n    SW_ALLOC_INIT_ZVAL(zrequest_object);\n#endif\n    ctx->request.zobject = zrequest_object;\n    object_init_ex(zrequest_object, swoole_http_request_class_entry_ptr);\n    swoole_set_object(zrequest_object, ctx);\n\n    zval *zresponse_object;\n#if PHP_MAJOR_VERSION >= 7\n    zresponse_object = &ctx->response._zobject;\n#else\n    SW_ALLOC_INIT_ZVAL(zresponse_object);\n#endif\n    ctx->response.zobject = zresponse_object;\n    object_init_ex(zresponse_object, swoole_http_response_class_entry_ptr);\n    swoole_set_object(zresponse_object, ctx);\n\n    //socket fd\n    zend_update_property_long(swoole_http_response_class_entry_ptr, zresponse_object, ZEND_STRL(\"fd\"), client->fd TSRMLS_CC);\n    zend_update_property_long(swoole_http_request_class_entry_ptr, zrequest_object, ZEND_STRL(\"fd\"), client->fd TSRMLS_CC);\n\n#if PHP_MEMORY_DEBUG\n    php_vmstat.new_http_request ++;\n#endif\n\n    zval *zheader;\n    swoole_http_server_array_init(header, request);\n\n    zval *zserver;\n    swoole_http_server_array_init(server, request);\n\n    ctx->fd = client->fd;\n    ctx->client = client;\n\n    return ctx;\n}\n\nvoid swoole_http_context_free(http_context *ctx TSRMLS_DC)\n{\n    swoole_set_object(ctx->response.zobject, NULL);\n    http_request *req = &ctx->request;\n    if (req->path)\n    {\n        efree(req->path);\n    }\n    if (req->zdata)\n    {\n        sw_zval_ptr_dtor(&req->zdata);\n    }\n#ifdef SW_USE_HTTP2\n    if (req->post_buffer)\n    {\n        swString_free(req->post_buffer);\n    }\n#endif\n    efree(ctx);\n}\n\nstatic char *http_status_message(int code)\n{\n    switch (code)\n    {\n    case 100:\n        return \"100 Continue\";\n    case 101:\n        return \"101 Switching Protocols\";\n    case 201:\n        return \"201 Created\";\n    case 202:\n        return \"202 Accepted\";\n    case 203:\n        return \"203 Non-Authoritative Information\";\n    case 204:\n        return \"204 No Content\";\n    case 205:\n        return \"205 Reset Content\";\n    case 206:\n        return \"206 Partial Content\";\n    case 207:\n        return \"207 Multi-Status\";\n    case 208:\n        return \"208 Already Reported\";\n    case 226:\n        return \"226 IM Used\";\n    case 300:\n        return \"300 Multiple Choices\";\n    case 301:\n        return \"301 Moved Permanently\";\n    case 302:\n        return \"302 Found\";\n    case 303:\n        return \"303 See Other\";\n    case 304:\n        return \"304 Not Modified\";\n    case 305:\n        return \"305 Use Proxy\";\n    case 307:\n        return \"307 Temporary Redirect\";\n    case 400:\n        return \"400 Bad Request\";\n    case 401:\n        return \"401 Unauthorized\";\n    case 402:\n        return \"402 Payment Required\";\n    case 403:\n        return \"403 Forbidden\";\n    case 404:\n        return \"404 Not Found\";\n    case 405:\n        return \"405 Method Not Allowed\";\n    case 406:\n        return \"406 Not Acceptable\";\n    case 407:\n        return \"407 Proxy Authentication Required\";\n    case 408:\n        return \"408 Request Timeout\";\n    case 409:\n        return \"409 Conflict\";\n    case 410:\n        return \"410 Gone\";\n    case 411:\n        return \"411 Length Required\";\n    case 412:\n        return \"412 Precondition Failed\";\n    case 413:\n        return \"413 Request Entity Too Large\";\n    case 414:\n        return \"414 Request URI Too Long\";\n    case 415:\n        return \"415 Unsupported Media Type\";\n    case 416:\n        return \"416 Requested Range Not Satisfiable\";\n    case 417:\n        return \"417 Expectation Failed\";\n    case 418:\n        return \"418 I'm a teapot\";\n    case 421:\n        return \"421 Misdirected Request\";\n    case 422:\n        return \"422 Unprocessable Entity\";\n    case 423:\n        return \"423 Locked\";\n    case 424:\n        return \"424 Failed Dependency\";\n    case 426:\n        return \"426 Upgrade Required\";\n    case 428:\n        return \"428 Precondition Required\";\n    case 429:\n        return \"429 Too Many Requests\";\n    case 431:\n        return \"431 Request Header Fields Too Large\";\n    case 500:\n        return \"500 Internal Server Error\";\n    case 501:\n        return \"501 Method Not Implemented\";\n    case 502:\n        return \"502 Bad Gateway\";\n    case 503:\n        return \"503 Service Unavailable\";\n    case 505:\n        return \"505 HTTP Version Not Supported\";\n    case 506:\n        return \"506 Variant Also Negotiates\";\n    case 507:\n        return \"507 Insufficient Storage\";\n    case 508:\n        return \"508 Loop Detected\";\n    case 510:\n        return \"510 Not Extended\";\n    case 511:\n        return \"511 Network Authentication Required\";\n    case 200:\n    default:\n        return \"200 OK\";\n    }\n}\n\nstatic PHP_METHOD(swoole_http_server, start)\n{\n    int ret;\n\n    if (SwooleGS->start > 0)\n    {\n        swoole_php_error(E_WARNING, \"Server is running. Unable to execute swoole_server::start.\");\n        RETURN_FALSE;\n    }\n\n    swServer *serv = swoole_get_object(getThis());\n    php_swoole_register_callback(serv);\n\n    if (serv->listen_list->open_websocket_protocol)\n    {\n        if (php_sw_server_callbacks[SW_SERVER_CB_onMessage] == NULL)\n        {\n            swoole_php_fatal_error(E_ERROR, \"require onMessage callback\");\n            RETURN_FALSE;\n        }\n        if (serv->listen_list->open_http2_protocol == 1)\n        {\n            swoole_php_fatal_error(E_ERROR, \"cannot use http2 protocol in websocket server\");\n            RETURN_FALSE;\n        }\n    }\n    else if (php_sw_server_callbacks[SW_SERVER_CB_onRequest] == NULL)\n    {\n        swoole_php_fatal_error(E_ERROR, \"require onRequest callback\");\n        RETURN_FALSE;\n    }\n\n    http_client_array = swArray_new(1024, sizeof(swoole_http_client));\n    if (!http_client_array)\n    {\n        swoole_php_fatal_error(E_ERROR, \"swArray_new(1024, %ld) failed.\", sizeof(swoole_http_client));\n        RETURN_FALSE;\n    }\n\n    swoole_http_buffer = swString_new(SW_HTTP_RESPONSE_INIT_SIZE);\n    if (!swoole_http_buffer)\n    {\n        swoole_php_fatal_error(E_ERROR, \"[1] swString_new(%d) failed.\", SW_HTTP_RESPONSE_INIT_SIZE);\n        RETURN_FALSE;\n    }\n\n    swoole_http_form_data_buffer = swString_new(SW_HTTP_RESPONSE_INIT_SIZE);\n    if (!swoole_http_form_data_buffer)\n    {\n        swoole_php_fatal_error(E_ERROR, \"[2] swString_new(%d) failed.\", SW_HTTP_RESPONSE_INIT_SIZE);\n        RETURN_FALSE;\n    }\n\n#ifdef SW_HAVE_ZLIB\n    swoole_zlib_buffer = swString_new(SW_HTTP_RESPONSE_INIT_SIZE);\n    if (!swoole_zlib_buffer)\n    {\n        swoole_php_fatal_error(E_ERROR, \"[3] swString_new(%d) failed.\", SW_HTTP_RESPONSE_INIT_SIZE);\n        RETURN_FALSE;\n    }\n#endif\n\n    serv->onReceive = http_onReceive;\n\n    zval *zsetting = sw_zend_read_property(swoole_server_class_entry_ptr, getThis(), ZEND_STRL(\"setting\"), 1 TSRMLS_CC);\n    if (zsetting == NULL || ZVAL_IS_NULL(zsetting))\n    {\n        SW_MAKE_STD_ZVAL(zsetting);\n        array_init(zsetting);\n        zend_update_property(swoole_server_class_entry_ptr, getThis(), ZEND_STRL(\"setting\"), zsetting TSRMLS_CC);\n        sw_zval_ptr_dtor(&zsetting);\n    }\n\n    add_assoc_bool(zsetting, \"open_http_protocol\", 1);\n    add_assoc_bool(zsetting, \"open_mqtt_protocol\", 0);\n    add_assoc_bool(zsetting, \"open_eof_check\", 0);\n    add_assoc_bool(zsetting, \"open_length_check\", 0);\n\n    if (serv->listen_list->open_websocket_protocol)\n    {\n        add_assoc_bool(zsetting, \"open_websocket_protocol\", 1);\n    }\n\n    serv->listen_list->open_http_protocol = 1;\n    serv->listen_list->open_mqtt_protocol = 0;\n    serv->listen_list->open_eof_check = 0;\n    serv->listen_list->open_length_check = 0;\n\n    serv->ptr2 = getThis();\n\n    //for is_uploaded_file and move_uploaded_file\n    ALLOC_HASHTABLE(SG(rfc1867_uploaded_files));\n    zend_hash_init(SG(rfc1867_uploaded_files), 8, NULL, NULL, 0);\n\n    php_swoole_server_before_start(serv, getThis() TSRMLS_CC);\n\n    ret = swServer_start(serv);\n    if (ret < 0)\n    {\n        swoole_php_fatal_error(E_ERROR, \"start server failed. Error: %s\", sw_error);\n        RETURN_LONG(ret);\n    }\n    RETURN_TRUE;\n}\n\nstatic PHP_METHOD(swoole_http_request, rawcontent)\n{\n    zval *zfd = sw_zend_read_property(swoole_http_request_class_entry_ptr, getThis(), ZEND_STRL(\"fd\"), 0 TSRMLS_CC);\n    if (ZVAL_IS_NULL(zfd))\n    {\n        swoole_php_error(E_WARNING, \"http client not exists.\");\n        RETURN_FALSE;\n    }\n\n    http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);\n    if (!ctx)\n    {\n        RETURN_FALSE;\n    }\n\n    http_request *req = &ctx->request;\n    if (req->post_length > 0)\n    {\n        SW_RETVAL_STRINGL(Z_STRVAL_P(req->zdata) + Z_STRLEN_P(req->zdata) - req->post_length, req->post_length, 1);\n    }\n#ifdef SW_USE_HTTP2\n    else if (req->post_buffer)\n    {\n        SW_RETVAL_STRINGL(req->post_buffer->str, req->post_buffer->length, 1);\n    }\n#endif\n    else\n    {\n        RETURN_FALSE;\n    }\n}\n\nstatic PHP_METHOD(swoole_http_request, __destruct)\n{\n    zval *zfiles = sw_zend_read_property(swoole_http_request_class_entry_ptr, getThis(), ZEND_STRL(\"files\"), 1 TSRMLS_CC);\n    //upload files\n    if (zfiles && Z_TYPE_P(zfiles) == IS_ARRAY)\n    {\n        zval *value;\n        char *key;\n        int keytype;\n        uint32_t keylen;\n\n        SW_HASHTABLE_FOREACH_START2(Z_ARRVAL_P(zfiles), key, keylen, keytype, value)\n        {\n            if (HASH_KEY_IS_STRING != keytype)\n            {\n                continue;\n            }\n            zval *file_path;\n            if (sw_zend_hash_find(Z_ARRVAL_P(value), ZEND_STRS(\"tmp_name\"), (void **) &file_path) == SUCCESS)\n            {\n                unlink(Z_STRVAL_P(file_path));\n                sw_zend_hash_del(SG(rfc1867_uploaded_files), Z_STRVAL_P(file_path), Z_STRLEN_P(file_path) + 1);\n            }\n        }\n        SW_HASHTABLE_FOREACH_END();\n    }\n    swoole_set_object(getThis(), NULL);\n}\n\nstatic PHP_METHOD(swoole_http_response, write)\n{\n    zval *zdata;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z\", &zdata) == FAILURE)\n    {\n        return;\n    }\n\n    http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);\n    if (!ctx)\n    {\n        return;\n    }\n\n    if (!ctx->send_header)\n    {\n        ctx->chunk = 1;\n        swString_clear(swoole_http_buffer);\n        http_build_header(ctx, getThis(), swoole_http_buffer, -1 TSRMLS_CC);\n        if (swServer_tcp_send(SwooleG.serv, ctx->fd, swoole_http_buffer->str, swoole_http_buffer->length) < 0)\n        {\n            ctx->chunk = 0;\n            ctx->send_header = 0;\n            RETURN_FALSE;\n        }\n    }\n\n    swString http_body;\n    int length = php_swoole_get_send_data(zdata, &http_body.str TSRMLS_CC);\n\n    if (length < 0)\n    {\n        RETURN_FALSE;\n    }\n    else if (length == 0)\n    {\n       swoole_php_error(E_WARNING, \"data is empty.\");\n        RETURN_FALSE;\n    }\n    else\n    {\n        http_body.length = length;\n    }\n\n    swString_clear(swoole_http_buffer);\n\n    char *hex_string;\n    int hex_len;\n\n#ifdef SW_HAVE_ZLIB\n    if (ctx->gzip_enable)\n    {\n        http_response_compress(&http_body, ctx->gzip_level);\n\n        hex_string = swoole_dec2hex(swoole_zlib_buffer->length, 16);\n        hex_len = strlen(hex_string);\n\n        //\"%*s\\r\\n%*s\\r\\n\", hex_len, hex_string, body.length, body.str\n        swString_append_ptr(swoole_http_buffer, hex_string, hex_len);\n        swString_append_ptr(swoole_http_buffer, SW_STRL(\"\\r\\n\") - 1);\n        swString_append(swoole_http_buffer, swoole_zlib_buffer);\n        swString_append_ptr(swoole_http_buffer, SW_STRL(\"\\r\\n\") - 1);\n    }\n    else\n#endif\n    {\n        hex_string = swoole_dec2hex(http_body.length, 16);\n        hex_len = strlen(hex_string);\n\n        //\"%*s\\r\\n%*s\\r\\n\", hex_len, hex_string, body.length, body.str\n        swString_append_ptr(swoole_http_buffer, hex_string, hex_len);\n        swString_append_ptr(swoole_http_buffer, SW_STRL(\"\\r\\n\") - 1);\n        swString_append_ptr(swoole_http_buffer, http_body.str, http_body.length);\n        swString_append_ptr(swoole_http_buffer, SW_STRL(\"\\r\\n\") - 1);\n    }\n\n    int ret = swServer_tcp_send(SwooleG.serv, ctx->fd, swoole_http_buffer->str, swoole_http_buffer->length);\n    sw_strdup_free(hex_string);\n    SW_CHECK_RETURN(ret);\n}\n\nstatic http_context* http_get_context(zval *object, int check_end TSRMLS_DC)\n{\n    http_context *ctx = swoole_get_object(object);\n    if (!ctx)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Http request is end.\");\n        return NULL;\n    }\n    if (check_end && ctx->end)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Http request is end.\");\n        return NULL;\n    }\n    return ctx;\n}\n\nstatic void http_build_header(http_context *ctx, zval *object, swString *response, int body_length TSRMLS_DC)\n{\n    assert(ctx->send_header == 0);\n\n    char buf[SW_HTTP_HEADER_MAX_SIZE];\n    int n;\n    char *date_str;\n\n    /**\n     * http status line\n     */\n    n = snprintf(buf, sizeof(buf), \"HTTP/1.1 %s\\r\\n\", http_status_message(ctx->response.status));\n    swString_append_ptr(response, buf, n);\n\n    /**\n     * http header\n     */\n    zval *header = ctx->response.zheader;\n    if (header)\n    {\n        int flag = 0x0;\n        char *key_server = \"Server\";\n        char *key_connection = \"Connection\";\n        char *key_content_length = \"Content-Length\";\n        char *key_content_type = \"Content-Type\";\n        char *key_date = \"Date\";\n\n        HashTable *ht = Z_ARRVAL_P(header);\n        zval *value = NULL;\n        char *key = NULL;\n        uint32_t keylen = 0;\n        int type;\n\n        SW_HASHTABLE_FOREACH_START2(ht, key, keylen, type, value)\n        {\n            if (!key)\n            {\n                break;\n            }\n            if (strcmp(key, key_server) == 0)\n            {\n                flag |= HTTP_RESPONSE_SERVER;\n            }\n            else if (strcmp(key, key_connection) == 0)\n            {\n                flag |= HTTP_RESPONSE_CONNECTION;\n            }\n            else if (strcmp(key, key_content_length) == 0)\n            {\n                flag |= HTTP_RESPONSE_CONTENT_LENGTH;\n            }\n            else if (strcmp(key, key_date) == 0)\n            {\n                flag |= HTTP_RESPONSE_DATE;\n            }\n            else if (strcmp(key, key_content_type) == 0)\n            {\n                flag |= HTTP_RESPONSE_CONTENT_TYPE;\n            }\n            n = snprintf(buf, sizeof(buf), \"%*s: %*s\\r\\n\", keylen - 1, key, Z_STRLEN_P(value), Z_STRVAL_P(value));\n            swString_append_ptr(response, buf, n);\n        }\n        SW_HASHTABLE_FOREACH_END();\n\n        if (!(flag & HTTP_RESPONSE_SERVER))\n        {\n            swString_append_ptr(response, ZEND_STRL(\"Server: \"SW_HTTP_SERVER_SOFTWARE\"\\r\\n\"));\n        }\n        if (!(flag & HTTP_RESPONSE_CONNECTION))\n        {\n            if (ctx->keepalive)\n            {\n                swString_append_ptr(response, ZEND_STRL(\"Connection: keep-alive\\r\\n\"));\n            }\n            else\n            {\n                swString_append_ptr(response, ZEND_STRL(\"Connection: close\\r\\n\"));\n            }\n        }\n        if (ctx->request.method == PHP_HTTP_OPTIONS)\n        {\n            swString_append_ptr(response, ZEND_STRL(\"Allow: GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS\\r\\nContent-Length: 0\\r\\n\"));\n        }\n        else\n        {\n            if (!(flag & HTTP_RESPONSE_CONTENT_LENGTH) && body_length >= 0)\n            {\n#ifdef SW_HAVE_ZLIB\n                if (ctx->gzip_enable)\n                {\n                    body_length = swoole_zlib_buffer->length;\n                }\n#endif\n                n = snprintf(buf, sizeof(buf), \"Content-Length: %d\\r\\n\", body_length);\n                swString_append_ptr(response, buf, n);\n            }\n        }\n        if (!(flag & HTTP_RESPONSE_DATE))\n        {\n            date_str = sw_php_format_date(ZEND_STRL(SW_HTTP_DATE_FORMAT), SwooleGS->now, 0 TSRMLS_CC);\n            n = snprintf(buf, sizeof(buf), \"Date: %s\\r\\n\", date_str);\n            swString_append_ptr(response, buf, n);\n            efree(date_str);\n        }\n        if (!(flag & HTTP_RESPONSE_CONTENT_TYPE))\n        {\n            swString_append_ptr(response, ZEND_STRL(\"Content-Type: text/html\\r\\n\"));\n        }\n    }\n    else\n    {\n        swString_append_ptr(response, ZEND_STRL(\"Server: \"SW_HTTP_SERVER_SOFTWARE\"\\r\\nContent-Type: text/html\\r\\n\"));\n        if (ctx->keepalive)\n        {\n            swString_append_ptr(response, ZEND_STRL(\"Connection: keep-alive\\r\\n\"));\n        }\n        else\n        {\n            swString_append_ptr(response, ZEND_STRL(\"Connection: close\\r\\n\"));\n        }\n\n        date_str = sw_php_format_date(ZEND_STRL(SW_HTTP_DATE_FORMAT), SwooleGS->now, 0 TSRMLS_CC);\n        n = snprintf(buf, sizeof(buf), \"Date: %s\\r\\n\", date_str);\n        efree(date_str);\n        swString_append_ptr(response, buf, n);\n\n        if (ctx->request.method == PHP_HTTP_OPTIONS)\n        {\n            n = snprintf(buf, sizeof(buf), \"Allow: GET, POST, PUT, DELETE, HEAD, OPTIONS\\r\\nContent-Length: %d\\r\\n\", 0);\n            swString_append_ptr(response, buf, n);\n        }\n        else if (body_length >= 0)\n        {\n#ifdef SW_HAVE_ZLIB\n            if (ctx->gzip_enable)\n            {\n                body_length = swoole_zlib_buffer->length;\n            }\n#endif\n            n = snprintf(buf, sizeof(buf), \"Content-Length: %d\\r\\n\", body_length);\n            swString_append_ptr(response, buf, n);\n        }\n    }\n\n    if (ctx->chunk)\n    {\n        swString_append_ptr(response, SW_STRL(\"Transfer-Encoding: chunked\\r\\n\") - 1);\n    }\n    //http cookies\n    if (ctx->response.zcookie)\n    {\n        zval *value;\n        SW_HASHTABLE_FOREACH_START(Z_ARRVAL_P(ctx->response.zcookie), value)\n        {\n            if (Z_TYPE_P(value) != IS_STRING)\n            {\n                continue;\n            }\n            swString_append_ptr(response, SW_STRL(\"Set-Cookie: \") - 1);\n            swString_append_ptr(response, Z_STRVAL_P(value), Z_STRLEN_P(value));\n            swString_append_ptr(response, SW_STRL(\"\\r\\n\") - 1);\n        }\n        SW_HASHTABLE_FOREACH_END();\n    }\n    //http compress\n    if (ctx->gzip_enable)\n    {\n#ifdef SW_HTTP_COMPRESS_GZIP\n        swString_append_ptr(response, SW_STRL(\"Content-Encoding: gzip\\r\\n\") - 1);\n#else\n        swString_append_ptr(response, SW_STRL(\"Content-Encoding: deflate\\r\\n\") - 1);\n#endif\n    }\n    swString_append_ptr(response, ZEND_STRL(\"\\r\\n\"));\n    ctx->send_header = 1;\n}\n\n#ifdef SW_HAVE_ZLIB\nstatic int http_response_compress(swString *body, int level)\n{\n    assert(level > 0 || level < 10);\n\n    size_t memory_size = ((size_t) ((double) body->length * (double) 1.015)) + 10 + 8 + 4 + 1;\n\n    if (memory_size > swoole_zlib_buffer->size)\n    {\n        swString_extend(swoole_zlib_buffer, memory_size);\n    }\n\n    z_stream zstream;\n    memset(&zstream, 0, sizeof(zstream));\n\n    //deflate: -0xf, gzip: 0x1f\n#ifdef SW_HTTP_COMPRESS_GZIP\n    int encoding = 0x1f;\n#else\n    int encoding =  -0xf;\n#endif\n\n    int status;\n    if (Z_OK == deflateInit2(&zstream, level, Z_DEFLATED, encoding, MAX_MEM_LEVEL, Z_DEFAULT_STRATEGY))\n    {\n        zstream.next_in = (Bytef *) body->str;\n        zstream.next_out = (Bytef *) swoole_zlib_buffer->str;\n        zstream.avail_in = body->length;\n        zstream.avail_out = swoole_zlib_buffer->size;\n\n        status = deflate(&zstream, Z_FINISH);\n        deflateEnd(&zstream);\n\n        if (Z_STREAM_END == status)\n        {\n            swoole_zlib_buffer->length = zstream.total_out;\n            return SW_OK;\n        }\n    }\n    else\n    {\n        swWarn(\"deflateInit2() failed.\");\n    }\n    return SW_ERR;\n}\n#endif\n\nstatic PHP_METHOD(swoole_http_response, end)\n{\n    zval *zdata = NULL;\n    int ret;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|z\", &zdata) == FAILURE)\n    {\n        return;\n    }\n\n    swString http_body;\n\n    if (zdata)\n    {\n        int length = php_swoole_get_send_data(zdata, &http_body.str TSRMLS_CC);\n\n        if (length < 0)\n        {\n            RETURN_FALSE;\n        }\n        else\n        {\n            http_body.length = length;\n        }\n    }\n    else\n    {\n        http_body.length = 0;\n        http_body.str = NULL;\n    }\n\n    http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);\n    if (!ctx)\n    {\n        RETURN_FALSE;\n    }\n\n#ifdef SW_USE_HTTP2\n    if (ctx->http2)\n    {\n        swoole_http2_do_response(ctx, &http_body);\n        RETURN_TRUE;\n    }\n#endif\n\n    if (ctx->chunk)\n    {\n        ret = swServer_tcp_send(SwooleG.serv, ctx->fd, SW_STRL(\"0\\r\\n\\r\\n\") - 1);\n        if (ret < 0)\n        {\n            RETURN_FALSE;\n        }\n        ctx->chunk = 0;\n    }\n    //no http chunk\n    else\n    {\n        swString_clear(swoole_http_buffer);\n#ifdef SW_HAVE_ZLIB\n        if (ctx->gzip_enable)\n        {\n            if (http_body.length > 0)\n            {\n                http_response_compress(&http_body, ctx->gzip_level);\n            }\n            else\n            {\n                ctx->gzip_enable = 0;\n            }\n        }\n#endif\n        http_build_header(ctx, getThis(), swoole_http_buffer, http_body.length TSRMLS_CC);\n        if (http_body.length > 0)\n        {\n#ifdef SW_HAVE_ZLIB\n            if (ctx->gzip_enable)\n            {\n                swString_append(swoole_http_buffer, swoole_zlib_buffer);\n            }\n            else\n#endif\n            {\n                swString_append(swoole_http_buffer, &http_body);\n            }\n        }\n\n        ret = swServer_tcp_send(SwooleG.serv, ctx->fd, swoole_http_buffer->str, swoole_http_buffer->length);\n        if (ret < 0)\n        {\n            ctx->send_header = 0;\n            RETURN_FALSE;\n        }\n    }\n    if (!ctx->keepalive)\n    {\n        SwooleG.serv->factory.end(&SwooleG.serv->factory, ctx->fd);\n    }\n    swoole_http_context_free(ctx TSRMLS_CC);\n    RETURN_TRUE;\n}\n\nstatic PHP_METHOD(swoole_http_response, sendfile)\n{\n    char *filename;\n    zend_size_t filename_length;\n    int ret;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &filename, &filename_length) == FAILURE)\n    {\n        return;\n    }\n\n    if (filename_length <= 0)\n    {\n        swoole_php_error(E_WARNING, \"file name is empty.\");\n        RETURN_FALSE;\n    }\n\n    http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);\n    if (!ctx)\n    {\n        RETURN_FALSE;\n    }\n\n    if (ctx->chunk)\n    {\n        swoole_php_error(E_WARNING, \"cannot use HTTP-Chunk.\");\n        RETURN_FALSE;\n    }\n\n    int file_fd = open(filename, O_RDONLY);\n    if (file_fd < 0)\n    {\n        swoole_php_sys_error(E_WARNING, \"open(%s) failed.\", filename);\n        RETURN_FALSE;\n    }\n\n    struct stat file_stat;\n    if (fstat(file_fd, &file_stat) < 0)\n    {\n        swoole_php_sys_error(E_WARNING, \"fstat(%s) failed.\", filename);\n        RETURN_FALSE;\n    }\n\n    if (file_stat.st_size <= 0)\n    {\n        swoole_php_error(E_WARNING, \"file is empty.\");\n        RETURN_FALSE;\n    }\n\n    swString_clear(swoole_http_buffer);\n    http_build_header(ctx, getThis(), swoole_http_buffer, file_stat.st_size TSRMLS_CC);\n\n    ret = swServer_tcp_send(SwooleG.serv, ctx->fd, swoole_http_buffer->str, swoole_http_buffer->length);\n    if (ret < 0)\n    {\n        ctx->send_header = 0;\n        RETURN_FALSE;\n    }\n\n    ret = swServer_tcp_sendfile(SwooleG.serv, ctx->fd, filename, filename_length);\n    if (ret < 0)\n    {\n        ctx->send_header = 0;\n        RETURN_FALSE;\n    }\n    if (!ctx->keepalive)\n    {\n        SwooleG.serv->factory.end(&SwooleG.serv->factory, ctx->fd);\n    }\n    swoole_http_context_free(ctx TSRMLS_CC);\n    RETURN_TRUE;\n}\n\nstatic PHP_METHOD(swoole_http_response, cookie)\n{\n    char *name, *value = NULL, *path = NULL, *domain = NULL;\n    long expires = 0;\n    int encode = 1;\n    zend_bool secure = 0, httponly = 0;\n    zend_size_t name_len, value_len = 0, path_len = 0, domain_len = 0;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|slssbb\", &name, &name_len, &value, &value_len, &expires,\n                &path, &path_len, &domain, &domain_len, &secure, &httponly) == FAILURE)\n    {\n        return;\n    }\n\n    http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);\n    if (!ctx)\n    {\n        RETURN_FALSE;\n    }\n\n    zval *zcookie = ctx->response.zcookie;\n    zval *zresponse_object = ctx->response.zobject;\n    if (!zcookie)\n    {\n        swoole_http_server_array_init(cookie, response);\n    }\n\n    char *cookie, *encoded_value = NULL;\n    int len = 0;\n    char *dt;\n\n    if (name && strpbrk(name, \"=,; \\t\\r\\n\\013\\014\") != NULL)\n    {\n        swoole_php_error(E_WARNING, \"Cookie names cannot contain any of the following '=,; \\\\t\\\\r\\\\n\\\\013\\\\014'\");\n        RETURN_FALSE;\n    }\n\n    len += name_len;\n    if (encode && value)\n    {\n        int encoded_value_len;\n        encoded_value = sw_php_url_encode(value, value_len, &encoded_value_len);\n        len += encoded_value_len;\n    }\n    else if (value)\n    {\n        encoded_value = estrdup(value);\n        len += value_len;\n    }\n    if (path)\n    {\n        len += path_len;\n    }\n    if (domain)\n    {\n        len += domain_len;\n    }\n\n    cookie = emalloc(len + 100);\n\n    if (value && value_len == 0)\n    {\n        dt = sw_php_format_date(\"D, d-M-Y H:i:s T\", sizeof(\"D, d-M-Y H:i:s T\") - 1, 1, 0 TSRMLS_CC);\n        snprintf(cookie, len + 100, \"%s=deleted; expires=%s\", name, dt);\n        efree(dt);\n    }\n    else\n    {\n        snprintf(cookie, len + 100, \"%s=%s\", name, value ? encoded_value : \"\");\n        if (expires > 0)\n        {\n            const char *p;\n            strlcat(cookie, \"; expires=\", len + 100);\n            dt = sw_php_format_date(\"D, d-M-Y H:i:s T\", sizeof(\"D, d-M-Y H:i:s T\") - 1, expires, 0 TSRMLS_CC);\n            p = zend_memrchr(dt, '-', strlen(dt));\n            if (!p || *(p + 5) != ' ')\n            {\n                efree(dt);\n                efree(cookie);\n                efree(encoded_value);\n                swoole_php_error(E_WARNING, \"Expiry date cannot have a year greater than 9999\");\n                RETURN_FALSE;\n            }\n            strlcat(cookie, dt, len + 100);\n            efree(dt);\n        }\n    }\n    if (encoded_value)\n    {\n        efree(encoded_value);\n    }\n    if (path && path_len > 0)\n    {\n        strlcat(cookie, \"; path=\", len + 100);\n        strlcat(cookie, path, len + 100);\n    }\n    if (domain && domain_len > 0)\n    {\n        strlcat(cookie, \"; domain=\", len + 100);\n        strlcat(cookie, domain, len + 100);\n    }\n    if (secure)\n    {\n        strlcat(cookie, \"; secure\", len + 100);\n    }\n    if (httponly)\n    {\n        strlcat(cookie, \"; httponly\", len + 100);\n    }\n    sw_add_next_index_stringl(zcookie, cookie, strlen(cookie), 0);\n#if PHP_MAJOR_VERSION >= 7\n    efree(cookie);\n#endif\n}\n\nstatic PHP_METHOD(swoole_http_response, rawcookie)\n{\n    char *name, *value = NULL, *path = NULL, *domain = NULL;\n    long expires = 0;\n    int encode = 0;\n    zend_bool secure = 0, httponly = 0;\n    zend_size_t name_len, value_len = 0, path_len = 0, domain_len = 0;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|slssbb\", &name, &name_len, &value, &value_len, &expires,\n                &path, &path_len, &domain, &domain_len, &secure, &httponly) == FAILURE)\n    {\n        return;\n    }\n\n    http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);\n    if (!ctx)\n    {\n        RETURN_FALSE;\n    }\n\n    zval *zcookie = ctx->response.zcookie;\n    zval *zresponse_object = ctx->response.zobject;\n    if (!zcookie)\n    {\n        swoole_http_server_array_init(cookie, response);\n    }\n\n    char *cookie, *encoded_value = NULL;\n    int len = 0;\n    char *dt;\n\n    if (name && strpbrk(name, \"=,; \\t\\r\\n\\013\\014\") != NULL)\n    {\n        swoole_php_error(E_WARNING, \"Cookie names cannot contain any of the following '=,; \\\\t\\\\r\\\\n\\\\013\\\\014'\");\n        RETURN_FALSE;\n    }\n\n    len += name_len;\n    if (encode && value)\n    {\n        int encoded_value_len;\n        encoded_value = sw_php_url_encode(value, value_len, &encoded_value_len);\n        len += encoded_value_len;\n    }\n    else if (value)\n    {\n        encoded_value = estrdup(value);\n        len += value_len;\n    }\n    if (path)\n    {\n        len += path_len;\n    }\n    if (domain)\n    {\n        len += domain_len;\n    }\n\n    cookie = emalloc(len + 100);\n\n    if (value && value_len == 0)\n    {\n        dt = sw_php_format_date(\"D, d-M-Y H:i:s T\", sizeof(\"D, d-M-Y H:i:s T\") - 1, 1, 0 TSRMLS_CC);\n        snprintf(cookie, len + 100, \"%s=deleted; expires=%s\", name, dt);\n        efree(dt);\n    }\n    else\n    {\n        snprintf(cookie, len + 100, \"%s=%s\", name, value ? encoded_value : \"\");\n        if (expires > 0)\n        {\n            const char *p;\n            strlcat(cookie, \"; expires=\", len + 100);\n            dt = sw_php_format_date(\"D, d-M-Y H:i:s T\", sizeof(\"D, d-M-Y H:i:s T\") - 1, expires, 0 TSRMLS_CC);\n            p = zend_memrchr(dt, '-', strlen(dt));\n            if (!p || *(p + 5) != ' ')\n            {\n                efree(dt);\n                efree(cookie);\n                efree(encoded_value);\n                swoole_php_error(E_WARNING, \"Expiry date cannot have a year greater than 9999\");\n                RETURN_FALSE;\n            }\n            strlcat(cookie, dt, len + 100);\n            efree(dt);\n        }\n    }\n    if (encoded_value)\n    {\n        efree(encoded_value);\n    }\n    if (path && path_len > 0)\n    {\n        strlcat(cookie, \"; path=\", len + 100);\n        strlcat(cookie, path, len + 100);\n    }\n    if (domain && domain_len > 0)\n    {\n        strlcat(cookie, \"; domain=\", len + 100);\n        strlcat(cookie, domain, len + 100);\n    }\n    if (secure)\n    {\n        strlcat(cookie, \"; secure\", len + 100);\n    }\n    if (httponly)\n    {\n        strlcat(cookie, \"; httponly\", len + 100);\n    }\n    sw_add_next_index_stringl(zcookie, cookie, strlen(cookie), 0);\n#if PHP_MAJOR_VERSION >= 7\n    efree(cookie);\n#endif\n}\n\nstatic PHP_METHOD(swoole_http_response, status)\n{\n    long http_status;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &http_status) == FAILURE)\n    {\n        return;\n    }\n\n    http_context *client = http_get_context(getThis(), 0 TSRMLS_CC);\n    if (!client)\n    {\n        RETURN_FALSE;\n    }\n\n    client->response.status = http_status;\n}\n\nstatic PHP_METHOD(swoole_http_response, header)\n{\n    char *k, *v;\n    zend_size_t klen, vlen;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ss\", &k, &klen, &v, &vlen) == FAILURE)\n    {\n        return;\n    }\n\n    http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);\n    if (!ctx)\n    {\n        RETURN_FALSE;\n    }\n\n    zval *zheader = ctx->response.zheader;\n    zval *zresponse_object = ctx->response.zobject;\n    if (!zheader)\n    {\n        swoole_http_server_array_init(header, response);\n    }\n    if (klen > SW_HTTP_HEADER_KEY_SIZE - 1)\n    {\n        swoole_php_error(E_WARNING, \"header key is too long.\");\n        RETURN_FALSE;\n    }\n    if (vlen > SW_HTTP_HEADER_VALUE_SIZE)\n    {\n        swoole_php_error(E_WARNING, \"header value is too long.\");\n        RETURN_FALSE;\n    }\n    char key_buf[SW_HTTP_HEADER_KEY_SIZE];\n    memcpy(key_buf, k, klen);\n    key_buf[klen] = '\\0';\n    if (ctx->http2)\n    {\n        swoole_strtolower(key_buf, klen);\n    }\n    else\n    {\n        http_header_key_format(key_buf, klen);\n    }\n    sw_add_assoc_stringl_ex(zheader, key_buf, klen + 1, v, vlen, 1);\n}\n\n#ifdef SW_HAVE_ZLIB\nstatic PHP_METHOD(swoole_http_response, gzip)\n{\n    long level = Z_DEFAULT_COMPRESSION;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|l\", &level) == FAILURE)\n    {\n        return;\n    }\n\n    http_context *context = http_get_context(getThis(), 0 TSRMLS_CC);\n    if (!context)\n    {\n        RETURN_FALSE;\n    }\n\n    if (context->send_header)\n    {\n        swoole_php_fatal_error(E_WARNING, \"must use before send header.\");\n        RETURN_FALSE;\n    }\n\n    if (level > 9)\n    {\n        level = 9;\n    }\n    if (level < 0)\n    {\n        level = 0;\n    }\n\n    context->gzip_enable = 1;\n    context->gzip_level = level;\n}\n#endif\n\nstatic PHP_METHOD(swoole_http_response, __destruct)\n{\n    http_context *context = swoole_get_object(getThis());\n    if (context)\n    {\n        zval *zobject = getThis();\n        zval *retval = NULL;\n        sw_zend_call_method_with_0_params(&zobject, swoole_http_response_class_entry_ptr, NULL, \"end\", &retval);\n        if (retval)\n        {\n            sw_zval_ptr_dtor(&retval);\n        }\n    }\n}",
        "b_contents": "/*\n  +----------------------------------------------------------------------+\n  | Swoole                                                               |\n  +----------------------------------------------------------------------+\n  | This source file is subject to version 2.0 of the Apache license,    |\n  | that is bundled with this package in the file LICENSE, and is        |\n  | available through the world-wide-web at the following url:           |\n  | http://www.apache.org/licenses/LICENSE-2.0.html                      |\n  | If you did not receive a copy of the Apache2.0 license and are unable|\n  | to obtain it through the world-wide-web, please send a note to       |\n  | license@swoole.com so we can mail you a copy immediately.            |\n  +----------------------------------------------------------------------+\n  | Author: Tianfeng Han  <mikan.tenny@gmail.com>                        |\n  +----------------------------------------------------------------------+\n*/\n\n#include \"php_swoole.h\"\n#include \"swoole_http.h\"\n#ifdef SW_COROUTINE\n#include \"swoole_coroutine.h\"\n#endif\n\n#include <ext/standard/url.h>\n#include <ext/standard/sha1.h>\n#include <ext/standard/php_var.h>\n#include <ext/standard/php_string.h>\n#include <ext/standard/php_math.h>\n#include <ext/standard/php_array.h>\n#include <ext/date/php_date.h>\n#include <ext/standard/md5.h>\n\n#include <main/rfc1867.h>\n#include <main/php_variables.h>\n\n#include \"websocket.h\"\n#include \"Connection.h\"\n#include \"base64.h\"\n\n#ifdef SW_HAVE_ZLIB\n#include <zlib.h>\n#endif\n\n#ifdef SW_USE_HTTP2\n#include \"http2.h\"\n#include <nghttp2/nghttp2.h>\n#endif\n\nstatic swArray *http_client_array;\n\nswString *swoole_http_buffer;\nswString *swoole_zlib_buffer;\nswString *swoole_http_form_data_buffer;\n\nenum http_global_flag\n{\n    HTTP_GLOBAL_GET       = 1u << 1,\n    HTTP_GLOBAL_POST      = 1u << 2,\n    HTTP_GLOBAL_COOKIE    = 1u << 3,\n    HTTP_GLOBAL_REQUEST   = 1u << 4,\n    HTTP_GLOBAL_SERVER    = 1u << 5,\n    HTTP_GLOBAL_FILES     = 1u << 6,\n};\n\nenum http_upload_errno\n{\n    HTTP_UPLOAD_ERR_OK = 0,\n    HTTP_UPLOAD_ERR_INI_SIZE,\n    HTTP_UPLOAD_ERR_FORM_SIZE,\n    HTTP_UPLOAD_ERR_PARTIAL,\n    HTTP_UPLOAD_ERR_NO_FILE,\n    HTTP_UPLOAD_ERR_NO_TMP_DIR = 6,\n    HTTP_UPLOAD_ERR_CANT_WRITE,\n};\n\nzend_class_entry swoole_http_server_ce;\nzend_class_entry *swoole_http_server_class_entry_ptr;\n\nzend_class_entry swoole_http_response_ce;\nzend_class_entry *swoole_http_response_class_entry_ptr;\n\nzend_class_entry swoole_http_request_ce;\nzend_class_entry *swoole_http_request_class_entry_ptr;\n\nstatic int http_onReceive(swServer *serv, swEventData *req);\n\nstatic int http_request_on_path(php_http_parser *parser, const char *at, size_t length);\nstatic int http_request_on_query_string(php_http_parser *parser, const char *at, size_t length);\nstatic int http_request_on_body(php_http_parser *parser, const char *at, size_t length);\nstatic int http_request_on_header_field(php_http_parser *parser, const char *at, size_t length);\nstatic int http_request_on_header_value(php_http_parser *parser, const char *at, size_t length);\nstatic int http_request_on_headers_complete(php_http_parser *parser);\nstatic int http_request_message_complete(php_http_parser *parser);\n\nstatic int multipart_body_on_header_field(multipart_parser* p, const char *at, size_t length);\nstatic int multipart_body_on_header_value(multipart_parser* p, const char *at, size_t length);\nstatic int multipart_body_on_data(multipart_parser* p, const char *at, size_t length);\nstatic int multipart_body_on_header_complete(multipart_parser* p);\nstatic int multipart_body_on_data_end(multipart_parser* p);\nstatic int multipart_body_end(multipart_parser* p);\n\nstatic http_context* http_get_context(zval *object, int check_end TSRMLS_DC);\n\nstatic void http_parse_cookie(zval *array, const char *at, size_t length);\nstatic void http_build_header(http_context *, zval *object, swString *response, int body_length TSRMLS_DC);\nstatic int http_trim_double_quote(zval **value, char **ptr);\n\nstatic inline void http_header_key_format(char *key, int length)\n{\n    int i, state = 0;\n    for (i = 0; i < length; i++)\n    {\n        if (state == 0)\n        {\n            if (key[i] >= 97 && key[i] <= 122)\n            {\n                key[i] -= 32;\n            }\n            state = 1;\n        }\n        else if (key[i] == '-')\n        {\n            state = 0;\n        }\n        else\n        {\n            if (key[i] >= 65 && key[i] <= 90)\n            {\n                key[i] += 32;\n            }\n        }\n    }\n}\n\n#ifdef SW_HAVE_ZLIB\nstatic int http_response_compress(swString *body, int level);\n#endif\n\nstatic PHP_METHOD(swoole_http_server, on);\nstatic PHP_METHOD(swoole_http_server, start);\n\nstatic PHP_METHOD(swoole_http_request, rawcontent);\nstatic PHP_METHOD(swoole_http_request, __destruct);\n\nstatic PHP_METHOD(swoole_http_response, write);\nstatic PHP_METHOD(swoole_http_response, end);\nstatic PHP_METHOD(swoole_http_response, sendfile);\nstatic PHP_METHOD(swoole_http_response, cookie);\nstatic PHP_METHOD(swoole_http_response, rawcookie);\nstatic PHP_METHOD(swoole_http_response, header);\n#ifdef SW_HAVE_ZLIB\nstatic PHP_METHOD(swoole_http_response, gzip);\n#endif\nstatic PHP_METHOD(swoole_http_response, status);\nstatic PHP_METHOD(swoole_http_response, __destruct);\n\nstatic sw_inline char* http_get_method_name(int method)\n{\n    switch (method)\n    {\n    case PHP_HTTP_GET:\n        return \"GET\";\n    case PHP_HTTP_POST:\n        return \"POST\";\n    case PHP_HTTP_HEAD:\n        return \"HEAD\";\n    case PHP_HTTP_PUT:\n        return \"PUT\";\n    case PHP_HTTP_DELETE:\n        return \"DELETE\";\n    case PHP_HTTP_PATCH:\n        return \"PATCH\";\n    case PHP_HTTP_CONNECT:\n        return \"CONNECT\";\n    case PHP_HTTP_OPTIONS:\n        return \"OPTIONS\";\n    case PHP_HTTP_TRACE:\n        return \"TRACE\";\n    case PHP_HTTP_COPY:\n        return \"COPY\";\n    case PHP_HTTP_LOCK:\n        return \"LOCK\";\n    case PHP_HTTP_MKCOL:\n        return \"MKCOL\";\n    case PHP_HTTP_MOVE:\n        return \"MOVE\";\n    case PHP_HTTP_PROPFIND:\n        return \"PROPFIND\";\n    case PHP_HTTP_PROPPATCH:\n        return \"PROPPATCH\";\n    case PHP_HTTP_UNLOCK:\n        return \"UNLOCK\";\n        /* subversion */\n    case PHP_HTTP_REPORT:\n        return \"REPORT\";\n    case PHP_HTTP_MKACTIVITY:\n        return \"MKACTIVITY\";\n    case PHP_HTTP_CHECKOUT:\n        return \"CHECKOUT\";\n    case PHP_HTTP_MERGE:\n        return \"MERGE\";\n        /* upnp */\n    case PHP_HTTP_MSEARCH:\n        return \"MSEARCH\";\n    case PHP_HTTP_NOTIFY:\n        return \"NOTIFY\";\n    case PHP_HTTP_SUBSCRIBE:\n        return \"SUBSCRIBE\";\n    case PHP_HTTP_UNSUBSCRIBE:\n        return \"UNSUBSCRIBE\";\n    case PHP_HTTP_NOT_IMPLEMENTED:\n        return \"IMPLEMENTED\";\n    default:\n        return NULL;\n    }\n}\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_http_server_on, 0, 0, 2)\n    ZEND_ARG_INFO(0, ha_name)\n    ZEND_ARG_INFO(0, cb)\nZEND_END_ARG_INFO()\n\nstatic const php_http_parser_settings http_parser_settings =\n{\n    NULL,\n    http_request_on_path,\n    http_request_on_query_string,\n    NULL,\n    NULL,\n    http_request_on_header_field,\n    http_request_on_header_value,\n    http_request_on_headers_complete,\n    http_request_on_body,\n    http_request_message_complete\n};\n\nstatic const multipart_parser_settings mt_parser_settings = \n{\n    multipart_body_on_header_field,\n    multipart_body_on_header_value,\n    multipart_body_on_data,\n    NULL,\n    multipart_body_on_header_complete,\n    multipart_body_on_data_end,\n    multipart_body_end\n};\n\nconst zend_function_entry swoole_http_server_methods[] =\n{\n    PHP_ME(swoole_http_server, on,         arginfo_swoole_http_server_on, ZEND_ACC_PUBLIC)\n    PHP_ME(swoole_http_server, start,      NULL, ZEND_ACC_PUBLIC)\n    PHP_FE_END\n};\n\nconst zend_function_entry swoole_http_request_methods[] =\n{\n    PHP_ME(swoole_http_request, rawcontent, NULL, ZEND_ACC_PUBLIC)\n    PHP_ME(swoole_http_request, __destruct, NULL, ZEND_ACC_PUBLIC | ZEND_ACC_DTOR)\n    PHP_FE_END\n};\n\nconst zend_function_entry swoole_http_response_methods[] =\n{\n    PHP_ME(swoole_http_response, cookie, NULL, ZEND_ACC_PUBLIC)\n    PHP_ME(swoole_http_response, rawcookie, NULL, ZEND_ACC_PUBLIC)\n    PHP_ME(swoole_http_response, status, NULL, ZEND_ACC_PUBLIC)\n#ifdef SW_HAVE_ZLIB\n    PHP_ME(swoole_http_response, gzip, NULL, ZEND_ACC_PUBLIC)\n#endif\n    PHP_ME(swoole_http_response, header, NULL, ZEND_ACC_PUBLIC)\n    PHP_ME(swoole_http_response, write, NULL, ZEND_ACC_PUBLIC)\n    PHP_ME(swoole_http_response, end, NULL, ZEND_ACC_PUBLIC)\n    PHP_ME(swoole_http_response, sendfile, NULL, ZEND_ACC_PUBLIC)\n    PHP_ME(swoole_http_response, __destruct, NULL, ZEND_ACC_PUBLIC | ZEND_ACC_DTOR)\n    PHP_FE_END\n};\n\nstatic int http_request_on_path(php_http_parser *parser, const char *at, size_t length)\n{\n    http_context *ctx = parser->data;\n    ctx->request.path = estrndup(at, length);\n    ctx->request.path_len = length;\n    return 0;\n}\n\nstatic int http_request_on_query_string(php_http_parser *parser, const char *at, size_t length)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n    http_context *ctx = parser->data;\n\n    //no need free, will free by treat_data\n    char *query = estrndup(at, length);\n    sw_add_assoc_stringl_ex(ctx->request.zserver, ZEND_STRS(\"query_string\"), query, length, 1);\n\n    zval *zrequest_object = ctx->request.zobject;\n    zval *zget;\n    swoole_http_server_array_init(get, request);\n\n    //parse url params\n    sapi_module.treat_data(PARSE_STRING, query, zget TSRMLS_CC);\n\n    return 0;\n}\n\nstatic int http_request_on_header_field(php_http_parser *parser, const char *at, size_t length)\n{\n    http_context *ctx = parser->data;\n    if (ctx->current_header_name_allocated)\n    {\n        efree(ctx->current_header_name);\n        ctx->current_header_name_allocated = 0;\n    }\n    ctx->current_header_name = (char *) at;\n    ctx->current_header_name_len = length;\n    return 0;\n}\n\nint swoole_http_parse_form_data(http_context *ctx, const char *boundary_str, int boundary_len TSRMLS_DC)\n{\n    multipart_parser *mt_parser = multipart_parser_init(boundary_str, boundary_len, &mt_parser_settings);\n    if (!mt_parser)\n    {\n        swoole_php_fatal_error(E_WARNING, \"multipart_parser_init() failed.\");\n        return SW_ERR;\n    }\n\n    ctx->mt_parser = mt_parser;\n    mt_parser->data = ctx;\n\n    return SW_OK;\n}\n\nstatic void http_parse_cookie(zval *array, const char *at, size_t length)\n{\n    char keybuf[SW_HTTP_COOKIE_KEYLEN];\n    char valbuf[SW_HTTP_COOKIE_VALLEN];\n    char *_c = (char *) at;\n\n    int klen = 0;\n    int vlen = 0;\n    int state = -1;\n\t\n    int i = 0, j = 0;\n    while (_c < at + length)\n    {\n        if (state <= 0 && *_c == '=')\n        {\n            klen = i - j + 1;\n            if (klen >= SW_HTTP_COOKIE_KEYLEN)\n            {\n                swWarn(\"cookie key is too large.\");\n                return;\n            }\n            memcpy(keybuf, at + j, klen - 1);\n            keybuf[klen - 1] = 0;\n\n            j = i + 1;\n            state = 1;\n        }\n        else if (state == 1 && *_c == ';')\n        {\n            vlen = i - j;\n            strncpy(valbuf, (char * ) at + j, SW_HTTP_COOKIE_VALLEN);\n            vlen = php_url_decode(valbuf, vlen);\n            sw_add_assoc_stringl_ex(array, keybuf, klen, valbuf, vlen, 1);\n            j = i + 1;\n            state = -1;\n        }\n        else if (state < 0)\n        {\n            if (isspace(*_c))\n            {\n                //Remove leading spaces from cookie names \n                ++j;\n            } \n            else\n            {\n                state = 0;\n            }\n        }\n        _c++;\n        i++;\n    }\n    if (j < length)\n    {\n        vlen = i - j;\n        keybuf[klen - 1] = 0;\n        strncpy(valbuf, (char * ) at + j, SW_HTTP_COOKIE_VALLEN);\n        vlen = php_url_decode(valbuf, vlen);\n        sw_add_assoc_stringl_ex(array, keybuf, klen, valbuf, vlen, 1);\n    }\n}\n\nstatic int http_trim_double_quote(zval **value, char **ptr)\n{\n    int len = Z_STRLEN_PP(value);\n    *ptr = Z_STRVAL_PP(value);\n\n    //ltrim('\"')\n    if ((*ptr)[0] == '\"')\n    {\n        (*ptr)++;\n        len--;\n    }\n    //rtrim('\"')\n    if ((*ptr)[len - 1] == '\"')\n    {\n        len--;\n    }\n    return len;\n}\n\nstatic int http_request_on_header_value(php_http_parser *parser, const char *at, size_t length)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    http_context *ctx = parser->data;\n    zval *zrequest_object = ctx->request.zobject;\n    char *header_name = zend_str_tolower_dup(ctx->current_header_name, ctx->current_header_name_len);\n\n    if (strncasecmp(header_name, \"cookie\", ctx->current_header_name_len) == 0)\n    {\n        zval *zcookie;\n        if (length >= SW_HTTP_COOKIE_VALLEN)\n        {\n            swWarn(\"cookie is too large.\");\n        }\n        else\n        {\n            swoole_http_server_array_init(cookie, request);\n            http_parse_cookie(zcookie, at, length);\n        }\n        goto free_memory;\n    }\n    else if (SwooleG.serv->listen_list->open_websocket_protocol && strncasecmp(header_name, ZEND_STRL(\"upgrade\")) == 0 && strncasecmp(at, ZEND_STRL(\"websocket\")) == 0)\n    {\n        swConnection *conn = swWorker_get_connection(SwooleG.serv, ctx->fd);\n        if (!conn)\n        {\n            swWarn(\"connection[%d] is closed.\", ctx->fd);\n            return SW_ERR;\n        }\n        conn->websocket_status = WEBSOCKET_STATUS_CONNECTION;\n    }\n    else if (parser->method == PHP_HTTP_POST || parser->method == PHP_HTTP_PUT || parser->method == PHP_HTTP_DELETE || parser->method == PHP_HTTP_PATCH)\n    {\n        if (memcmp(header_name, ZEND_STRL(\"content-type\")) == 0)\n        {\n            if (strncasecmp(at, ZEND_STRL(\"application/x-www-form-urlencoded\")) == 0)\n            {\n                ctx->request.post_form_urlencoded = 1;\n            }\n            else if (memcmp(header_name, ZEND_STRL(\"content-type\")) == 0 && strncasecmp(at, ZEND_STRL(\"multipart/form-data\")) == 0)\n            {\n                int boundary_len = length - strlen(\"multipart/form-data; boundary=\");\n                if (boundary_len <= 0)\n                {\n                    swWarn(\"invalid multipart/form-data body.\", ctx->fd);\n                    return 0;\n                }\n                swoole_http_parse_form_data(ctx, at + length - boundary_len, boundary_len TSRMLS_CC);\n            }\n        }\n    }\n\n    zval *header = ctx->request.zheader;\n    sw_add_assoc_stringl_ex(header, header_name, ctx->current_header_name_len + 1, (char *) at, length, 1);\n\n    free_memory:\n    if (ctx->current_header_name_allocated)\n    {\n        efree(ctx->current_header_name);\n        ctx->current_header_name_allocated = 0;\n    }\n    efree(header_name);\n\n    return 0;\n}\n\nstatic int http_request_on_headers_complete(php_http_parser *parser)\n{\n    http_context *ctx = parser->data;\n    if (ctx->current_header_name_allocated)\n    {\n        efree(ctx->current_header_name);\n        ctx->current_header_name_allocated = 0;\n    }\n    ctx->current_header_name = NULL;\n\n    return 0;\n}\n\nstatic int multipart_body_on_header_field(multipart_parser* p, const char *at, size_t length)\n{\n    http_context *ctx = p->data;\n    return http_request_on_header_field(&ctx->parser, at, length);\n}\n\nstatic int multipart_body_on_header_value(multipart_parser* p, const char *at, size_t length)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    http_context *ctx = p->data;\n    zval *zrequest_object = ctx->request.zobject;\n    zval *zfiles = ctx->request.zfiles;\n    if (!zfiles)\n    {\n        swoole_http_server_array_init(files, request);\n    }\n\n    char *headername = zend_str_tolower_dup(ctx->current_header_name, ctx->current_header_name_len);\n\n    if (strncasecmp(headername, ZEND_STRL(\"content-disposition\")) == 0)\n    {\n        //not form data\n        if (swoole_strnpos((char *) at, length, ZEND_STRL(\"form-data;\")) < 0)\n        {\n            return SW_OK;\n        }\n\n        zval *tmp_array;\n        SW_MAKE_STD_ZVAL(tmp_array);\n        array_init(tmp_array);\n        http_parse_cookie(tmp_array, (char *) at + sizeof(\"form-data;\"), length - sizeof(\"form-data;\"));\n\n        zval *form_name;\n        if (sw_zend_hash_find(Z_ARRVAL_P(tmp_array), ZEND_STRS(\"name\"), (void **) &form_name) == FAILURE)\n        {\n            return SW_OK;\n        }\n\n        char *str;\n        int len = http_trim_double_quote(&form_name, &str);\n\n        zval *filename;\n        //POST form data\n        if (sw_zend_hash_find(Z_ARRVAL_P(tmp_array), ZEND_STRS(\"filename\"), (void **) &filename) == FAILURE)\n        {\n            ctx->current_form_data_name = estrndup(str, len);\n            ctx->current_form_data_name_len = len;\n        }\n        //upload file\n        else\n        {\n            ctx->current_input_name = estrndup(str, len);\n\n            zval *multipart_header;\n            SW_MAKE_STD_ZVAL(multipart_header);\n            array_init(multipart_header);\n            add_assoc_zval(zfiles, ctx->current_input_name, multipart_header);\n\n            sw_add_assoc_string(multipart_header, \"name\", \"\", 1);\n            sw_add_assoc_string(multipart_header, \"type\", \"\", 1);\n            sw_add_assoc_string(multipart_header, \"tmp_name\", \"\", 1);\n            add_assoc_long(multipart_header, \"error\", HTTP_UPLOAD_ERR_OK);\n            add_assoc_long(multipart_header, \"size\", 0);\n\n            len = http_trim_double_quote(&filename, &str);\n            sw_add_assoc_stringl(multipart_header, \"name\", str, len, 1);\n        }\n        sw_zval_ptr_dtor(&tmp_array);\n    }\n\n    if (strncasecmp(headername, ZEND_STRL(\"content-type\")) == 0)\n    {\n        zval *multipart_header = NULL;\n        sw_zend_hash_find(Z_ARRVAL_P(zfiles), ctx->current_input_name, strlen(ctx->current_input_name) + 1, (void **) &multipart_header);\n        sw_add_assoc_stringl(multipart_header, \"type\", (char * ) at, length, 1);\n    }\n\n    if (ctx->current_header_name_allocated)\n    {\n        efree(ctx->current_header_name);\n        ctx->current_header_name_allocated = 0;\n    }\n    efree(headername);\n\n    return 0;\n}\n\nstatic int multipart_body_on_data(multipart_parser* p, const char *at, size_t length)\n{\n    http_context *ctx = p->data;\n    if (ctx->current_form_data_name)\n    {\n        swString_append_ptr(swoole_http_form_data_buffer, (char*) at, length);\n        return 0;\n    }\n    if (p->fp == NULL)\n    {\n        return 0;\n    }\n    int n = fwrite(at, sizeof(char), length, (FILE *) p->fp);\n    if (n != length)\n    {\n        zval *files = ctx->request.zfiles;\n        zval *multipart_header = NULL;\n        sw_zend_hash_find(Z_ARRVAL_P(files), ctx->current_input_name, strlen(ctx->current_input_name) + 1, (void **) &multipart_header);\n        add_assoc_long(multipart_header, \"error\", HTTP_UPLOAD_ERR_CANT_WRITE);\n\n        fclose((FILE *) p->fp);\n        p->fp = NULL;\n\n        swWarn(\"write upload file failed. Error %s[%d]\", strerror(errno), errno);\n    }\n    return 0;\n}\n\n#if 0\nstatic void get_random_file_name(char *des, const char *src)\n{\n    unsigned char digest[16] = {0};\n    char buf[19] = {0};\n    int n = sprintf(buf, \"%s%d\", src, swoole_system_random(0, 9999));\n\n    PHP_MD5_CTX ctx;\n    PHP_MD5Init(&ctx);\n    PHP_MD5Update(&ctx, buf, n);\n    PHP_MD5Final(digest, &ctx);\n    make_digest_ex(des, digest, 16);\n}\n#endif\n\nstatic int multipart_body_on_header_complete(multipart_parser* p)\n{\n    http_context *ctx = p->data;\n    if (!ctx->current_input_name)\n    {\n        return 0;\n    }\n\n    zval *files = ctx->request.zfiles;\n    zval *multipart_header;\n\n    if (sw_zend_hash_find(Z_ARRVAL_P(files), ctx->current_input_name, strlen(ctx->current_input_name) + 1, (void **) &multipart_header) == FAILURE)\n    {\n        return 0;\n    }\n\n    zval *zerr = NULL;\n    sw_zend_hash_find(Z_ARRVAL_P(multipart_header), ZEND_STRS(\"error\"), (void **) &zerr);\n    if (Z_LVAL_P(zerr) != HTTP_UPLOAD_ERR_OK)\n    {\n        return 0;\n    }\n\n    char file_path[sizeof(SW_HTTP_UPLOAD_TMP_FILE)];\n    memcpy(file_path, SW_HTTP_UPLOAD_TMP_FILE, sizeof(SW_HTTP_UPLOAD_TMP_FILE));\n    int tmpfile = swoole_tmpfile(file_path);\n\n    FILE *fp = fdopen(tmpfile, \"wb+\");\n    if (fp < 0)\n    {\n        add_assoc_long(multipart_header, \"error\", HTTP_UPLOAD_ERR_NO_TMP_DIR);\n        swWarn(\"fopen(%s) failed. Error %s[%d]\", file_path, strerror(errno), errno);\n        return 0;\n    }\n\n    p->fp = fp;\n    sw_add_assoc_string(multipart_header, \"tmp_name\", file_path, 1);\n\n    return 0;\n}\n\nstatic int multipart_body_on_data_end(multipart_parser* p)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    http_context *ctx = p->data;\n    zval *zrequest_object = ctx->request.zobject;\n    if (ctx->current_form_data_name)\n    {\n        zval *zpost = sw_zend_read_property(swoole_http_request_class_entry_ptr, zrequest_object, ZEND_STRL(\"post\"), 1 TSRMLS_CC);\n        if (ZVAL_IS_NULL(zpost))\n        {\n            swoole_http_server_array_init(post, request);\n        }\n\n\t\tchar *name = ctx->current_form_data_name;\n\t\tint len = ctx->current_form_data_name_len;\n\n\t\tif ((name[len-1] == ']') && (name[len-2] == '['))\n\t\t{\n\t\t\tzval *array_value;\n\t\t\tif (sw_zend_hash_find(Z_ARRVAL_P(zpost), name, len + 1, (void **) &array_value) == FAILURE)\n\t\t\t{\n\t\t\t\tSW_MAKE_STD_ZVAL(array_value);\n\t\t\t\tarray_init(array_value);\n\t\t\t\tadd_assoc_zval(zpost, name, array_value);\n\t\t\t}\n            sw_add_next_index_stringl(array_value, swoole_http_form_data_buffer->str, swoole_http_form_data_buffer->length, 1);\n\t\t}\n\t\telse\n\t\t{\n            sw_add_assoc_stringl_ex(zpost, ctx->current_form_data_name, ctx->current_form_data_name_len + 1,\n                    swoole_http_form_data_buffer->str, swoole_http_form_data_buffer->length, 1);\n\t\t}\n\n        efree(ctx->current_form_data_name);\n        ctx->current_form_data_name = NULL;\n        ctx->current_form_data_name_len = 0;\n        swString_clear(swoole_http_form_data_buffer);\n        return 0;\n    }\n\n    if (!ctx->current_input_name)\n    {\n        return 0;\n    }\n\n    zval *files = ctx->request.zfiles;\n    if (ZVAL_IS_NULL(files))\n    {\n        return 0;\n    }\n\n    zval *multipart_header = NULL;\n    sw_zend_hash_find(Z_ARRVAL_P(files), ctx->current_input_name, strlen(ctx->current_input_name) + 1, (void **) &multipart_header);\n\n    if (p->fp != NULL)\n    {\n        long size = swoole_file_get_size((FILE*) p->fp);\n        add_assoc_long(multipart_header, \"size\", size);\n\n        fclose((FILE *)p->fp);\n        p->fp = NULL;\n    }\n\n    efree(ctx->current_input_name);\n\n    return 0;\n}\n\nstatic int multipart_body_end(multipart_parser* p)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    http_context *ctx = p->data;\n    zval *files = ctx->request.zfiles;\n    zval *value;\n\n    SW_HASHTABLE_FOREACH_START(Z_ARRVAL_P(files), value)\n    {\n        zval *file_path;\n        if (sw_zend_hash_find(Z_ARRVAL_P(value), ZEND_STRS(\"tmp_name\"), (void **) &file_path) == SUCCESS)\n        {\n#if PHP_MAJOR_VERSION >= 7\n            zend_string *tmp_name = zval_get_string(file_path);\n            zend_hash_add_ptr(SG(rfc1867_uploaded_files), tmp_name, tmp_name);\n#else\n            char *temp_filename = Z_STRVAL_P(file_path);\n            sw_zend_hash_add(SG(rfc1867_uploaded_files), temp_filename, Z_STRLEN_P(file_path) + 1, &temp_filename, sizeof(char *), NULL);\n#endif\n        }\n    }\n    SW_HASHTABLE_FOREACH_END();\n\n    return 0;\n}\n\nstatic int http_request_on_body(php_http_parser *parser, const char *at, size_t length)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    http_context *ctx = parser->data;\n    zval *zrequest_object = ctx->request.zobject;\n    char *body;\n\n    ctx->request.post_length = length;\n    if (SwooleG.serv->http_parse_post && ctx->request.post_form_urlencoded)\n    {\n        zval *zpost;\n        swoole_http_server_array_init(post, request);\n        body = estrndup(at, length);\n\n        sapi_module.treat_data(PARSE_STRING, body, zpost TSRMLS_CC);\n    }\n    else if (ctx->mt_parser != NULL)\n    {\n        multipart_parser *multipart_parser = ctx->mt_parser;\n        size_t n = multipart_parser_execute(multipart_parser, at, length);\n        if (n != length)\n        {\n            swoole_php_fatal_error(E_WARNING, \"parse multipart body failed.\");\n        }\n    }\n\n    return 0;\n}\n\nstatic int http_request_message_complete(php_http_parser *parser)\n{\n    http_context *ctx = parser->data;\n    ctx->request.version = parser->http_major * 100 + parser->http_minor;\n\n    const char *vpath = ctx->request.path, *end = vpath + ctx->request.path_len, *p = end;\n    ctx->request.ext = end;\n    ctx->request.ext_len = 0;\n    while (p > vpath)\n    {\n        --p;\n        if (*p == '.')\n        {\n            ++p;\n            ctx->request.ext = p;\n            ctx->request.ext_len = end - p;\n            break;\n        }\n    }\n    ctx->request_read = 1;\n\n    if (ctx->mt_parser)\n    {\n        multipart_parser_free(ctx->mt_parser);\n        ctx->mt_parser = NULL;\n    }\n\n    return 0;\n}\n\nstatic int http_onReceive(swServer *serv, swEventData *req)\n{\n    int fd = req->info.fd;\n\n    swConnection *conn = swWorker_get_connection(SwooleG.serv, fd);\n    if (!conn)\n    {\n        swWarn(\"connection[%d] is closed.\", fd);\n        return SW_ERR;\n    }\n    swListenPort *port = serv->connection_list[req->info.from_fd].object;\n    //other server port\n    if (!port->open_http_protocol)\n    {\n        return php_swoole_onReceive(serv, req);\n    }\n    //websocket client\n    if (conn->websocket_status == WEBSOCKET_STATUS_ACTIVE)\n    {\n        return swoole_websocket_onMessage(req);\n    }\n\n    swoole_http_client *client = swArray_fetch(http_client_array, conn->fd);\n    if (!client)\n    {\n        return SW_OK;\n    }\n    client->fd = fd;\n\n#ifdef SW_USE_HTTP2\n    if (conn->http2_stream)\n    {\n        client->http2 = 1;\n        return swoole_http2_onFrame(client, req);\n    }\n#endif\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    http_context *ctx = swoole_http_context_new(client TSRMLS_CC);\n    php_http_parser *parser = &ctx->parser;\n    zval *zserver = ctx->request.zserver;\n\n    parser->data = ctx;\n\n    php_http_parser_init(parser, PHP_HTTP_REQUEST);\n\n    zval *zdata;\n    SW_MAKE_STD_ZVAL(zdata);\n    ctx->request.zdata = zdata;\n    php_swoole_get_recv_data(zdata, req, NULL, 0);\n    sw_copy_to_stack(ctx->request.zdata, ctx->request._zdata);\n\n    swTrace(\"httpRequest %d bytes:\\n---------------------------------------\\n%s\\n\", Z_STRLEN_P(zdata), Z_STRVAL_P(zdata));\n\n    long n = php_http_parser_execute(parser, &http_parser_settings, Z_STRVAL_P(zdata), Z_STRLEN_P(zdata));\n    if (n < 0)\n    {\n        sw_zval_ptr_dtor(&zdata);\n        efree(client);\n        swWarn(\"php_http_parser_execute failed.\");\n\n        if (conn->websocket_status == WEBSOCKET_STATUS_CONNECTION)\n        {\n            return SwooleG.serv->factory.end(&SwooleG.serv->factory, fd);\n        }\n    }\n    else\n    {\n        zval *retval;\n#ifndef SW_COROUTINE\n        zval **args[2];\n#else\n        zval *args[2];\n#endif\n\n        zval *zrequest_object = ctx->request.zobject;\n        zval *zresponse_object = ctx->response.zobject;\n\n        ctx->keepalive = php_http_should_keep_alive(parser);\n        char *method_name = http_get_method_name(parser->method);\n\n        sw_add_assoc_string(zserver, \"request_method\", method_name, 1);\n        sw_add_assoc_stringl(zserver, \"request_uri\", ctx->request.path, ctx->request.path_len, 1);\n        sw_add_assoc_stringl(zserver, \"path_info\", ctx->request.path, ctx->request.path_len, 1);\n        sw_add_assoc_long_ex(zserver, ZEND_STRS(\"request_time\"), SwooleGS->now);\n\n        // Add REQUEST_TIME_FLOAT\n        double now_float = swoole_microtime();\n        sw_add_assoc_double_ex(zserver, ZEND_STRS(\"request_time_float\"), now_float);\n\n        swConnection *conn = swWorker_get_connection(SwooleG.serv, fd);\n        if (!conn)\n        {\n            sw_zval_ptr_dtor(&zdata);\n            swWarn(\"connection[%d] is closed.\", fd);\n            return SW_ERR;\n        }\n\n        add_assoc_long(ctx->request.zserver, \"server_port\", swConnection_get_port(&SwooleG.serv->connection_list[conn->from_fd]));\n        add_assoc_long(ctx->request.zserver, \"remote_port\", swConnection_get_port(conn));\n        sw_add_assoc_string(zserver, \"remote_addr\", swConnection_get_ip(conn), 1);\n\n        if (ctx->request.version == 101)\n        {\n            sw_add_assoc_string(zserver, \"server_protocol\", \"HTTP/1.1\", 1);\n        }\n        else\n        {\n            sw_add_assoc_string(zserver, \"server_protocol\", \"HTTP/1.0\", 1);\n        }\n\n        sw_add_assoc_string(zserver, \"server_software\", SW_HTTP_SERVER_SOFTWARE, 1);\n\n        zval *zcallback = php_swoole_server_get_callback(serv, req->info.from_fd, SW_SERVER_CB_onHandShake);\n        //websocket handshake\n        if (conn->websocket_status == WEBSOCKET_STATUS_CONNECTION && zcallback == NULL)\n        {\n            return swoole_websocket_onHandshake(ctx);\n        }\n        \n#ifndef SW_COROUTINE\n        args[0] = &zrequest_object;\n        args[1] = &zresponse_object;\n#else\n        args[0] = zrequest_object;\n        args[1] = zresponse_object;\n#endif\n\n        int callback_type = 0;\n        if (conn->websocket_status == WEBSOCKET_STATUS_CONNECTION)\n        {\n            callback_type = SW_SERVER_CB_onHandShake;\n            conn->websocket_status = WEBSOCKET_STATUS_HANDSHAKE;\n        }\n        else\n        {\n            callback_type = SW_SERVER_CB_onRequest;\n            zcallback = php_swoole_server_get_callback(serv, req->info.from_fd, SW_SERVER_CB_onRequest);\n            //no have onRequest callback\n            if (zcallback == NULL)\n            {\n                swoole_websocket_onReuqest(ctx);\n                return SW_OK;\n            }\n        }\n\n#ifndef SW_COROUTINE\n        zcallback = php_swoole_server_get_callback(serv, req->info.from_fd, callback_type);\n        if (sw_call_user_function_ex(EG(function_table), NULL, zcallback, &retval, 2, args, 0, NULL TSRMLS_CC) == FAILURE)\n        {\n            swoole_php_error(E_WARNING, \"onRequest handler error\");\n        }\n#else\n        zend_fcall_info_cache *cache = php_swoole_server_get_cache(serv, req->info.from_fd, callback_type);\n        int ret = coro_create(cache, args, 2, &retval, NULL, NULL);\n        if (ret != 0)\n        {\n            sw_zval_ptr_dtor(&zrequest_object);\n            sw_zval_ptr_dtor(&zresponse_object);\n            if (ret == CORO_LIMIT)\n            {\n                SwooleG.serv->factory.end(&SwooleG.serv->factory, fd);\n            }\n            return SW_OK;\n        }\n#endif\n        if (EG(exception))\n        {\n            zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n        }\n        //websocket user handshake\n        if (conn->websocket_status == WEBSOCKET_STATUS_HANDSHAKE)\n        {\n            //handshake success\n            if (retval && Z_BVAL_P(retval))\n            {\n                conn->websocket_status = WEBSOCKET_STATUS_ACTIVE;\n            }\n        }\n        sw_zval_ptr_dtor(&zrequest_object);\n        sw_zval_ptr_dtor(&zresponse_object);\n        if (retval)\n        {\n            sw_zval_ptr_dtor(&retval);\n        }\n    }\n    return SW_OK;\n}\n\nvoid swoole_http_server_init(int module_number TSRMLS_DC)\n{\n    SWOOLE_INIT_CLASS_ENTRY(swoole_http_server_ce, \"swoole_http_server\", \"Swoole\\\\Http\\\\Server\", swoole_http_server_methods);\n    swoole_http_server_class_entry_ptr = sw_zend_register_internal_class_ex(&swoole_http_server_ce, swoole_server_class_entry_ptr, \"swoole_server\" TSRMLS_CC);\n\n    zend_declare_property_long(swoole_http_server_class_entry_ptr, ZEND_STRL(\"global\"), 0, ZEND_ACC_PRIVATE TSRMLS_CC);\n\n    SWOOLE_INIT_CLASS_ENTRY(swoole_http_response_ce, \"swoole_http_response\", \"Swoole\\\\Http\\\\Response\", swoole_http_response_methods);\n    swoole_http_response_class_entry_ptr = zend_register_internal_class(&swoole_http_response_ce TSRMLS_CC);\n\n    SWOOLE_INIT_CLASS_ENTRY(swoole_http_request_ce, \"swoole_http_request\", \"Swoole\\\\Http\\\\Request\", swoole_http_request_methods);\n    swoole_http_request_class_entry_ptr = zend_register_internal_class(&swoole_http_request_ce TSRMLS_CC);\n}\n\nstatic PHP_METHOD(swoole_http_server, on)\n{\n    zval *callback;\n    zval *event_name;\n\n    if (SwooleGS->start > 0)\n    {\n        swoole_php_error(E_WARNING, \"Server is running. Unable to set event callback now.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"zz\", &event_name, &callback) == FAILURE)\n    {\n        return;\n    }\n\n#ifdef PHP_SWOOLE_CHECK_CALLBACK\n    char *func_name = NULL;\n#ifndef SW_COROUTINE\n    if (!sw_zend_is_callable(callback, 0, &func_name TSRMLS_CC))\n#else\n    zend_fcall_info_cache *func_cache = emalloc(sizeof(zend_fcall_info_cache));\n    if (!zend_is_callable_ex(callback, NULL, 0, &func_name, NULL, func_cache, NULL TSRMLS_CC))\n#endif\n    {\n        swoole_php_fatal_error(E_ERROR, \"Function '%s' is not callable\", func_name);\n        efree(func_name);\n        RETURN_FALSE;\n    }\n    efree(func_name);\n#endif\n\n    if (strncasecmp(\"request\", Z_STRVAL_P(event_name), Z_STRLEN_P(event_name)) == 0)\n    {\n        zend_update_property(swoole_http_server_class_entry_ptr, getThis(), ZEND_STRL(\"onRequest\"), callback TSRMLS_CC);\n        php_sw_server_callbacks[SW_SERVER_CB_onRequest] = sw_zend_read_property(swoole_http_server_class_entry_ptr, getThis(), ZEND_STRL(\"onRequest\"), 0 TSRMLS_CC);\n        sw_copy_to_stack(php_sw_server_callbacks[SW_SERVER_CB_onRequest], _php_sw_server_callbacks[SW_SERVER_CB_onRequest]);\n#ifdef SW_COROUTINE\n        php_sw_server_caches[SW_SERVER_CB_onRequest] = func_cache;\n#endif\n    }\n    else if (strncasecmp(\"handshake\", Z_STRVAL_P(event_name), Z_STRLEN_P(event_name)) == 0)\n    {\n        zend_update_property(swoole_http_server_class_entry_ptr, getThis(), ZEND_STRL(\"onHandshake\"), callback TSRMLS_CC);\n        php_sw_server_callbacks[SW_SERVER_CB_onHandShake] = sw_zend_read_property(swoole_http_server_class_entry_ptr, getThis(), ZEND_STRL(\"onHandshake\"), 0 TSRMLS_CC);\n        sw_copy_to_stack(php_sw_server_callbacks[SW_SERVER_CB_onHandShake], _php_sw_server_callbacks[SW_SERVER_CB_onHandShake]);\n#ifdef SW_COROUTINE\n        php_sw_server_caches[SW_SERVER_CB_onHandShake] = func_cache;\n#endif\n    }\n    else\n    {\n        zval *obj = getThis();\n        sw_zend_call_method_with_2_params(&obj, swoole_server_class_entry_ptr, NULL, \"on\", &return_value, event_name, callback);\n    }\n}\n\nhttp_context* swoole_http_context_new(swoole_http_client* client TSRMLS_DC)\n{\n    http_context *ctx = emalloc(sizeof(http_context));\n    if (!ctx)\n    {\n        swoole_error_log(SW_LOG_ERROR, SW_ERROR_MALLOC_FAIL, \"emalloc(%ld) failed.\", sizeof(http_context));\n        return NULL;\n    }\n    bzero(ctx, sizeof(http_context));\n\n    zval *zrequest_object;\n#if PHP_MAJOR_VERSION >= 7\n    zrequest_object = &ctx->request._zobject;\n#else\n    SW_ALLOC_INIT_ZVAL(zrequest_object);\n#endif\n    ctx->request.zobject = zrequest_object;\n    object_init_ex(zrequest_object, swoole_http_request_class_entry_ptr);\n    swoole_set_object(zrequest_object, ctx);\n\n    zval *zresponse_object;\n#if PHP_MAJOR_VERSION >= 7\n    zresponse_object = &ctx->response._zobject;\n#else\n    SW_ALLOC_INIT_ZVAL(zresponse_object);\n#endif\n    ctx->response.zobject = zresponse_object;\n    object_init_ex(zresponse_object, swoole_http_response_class_entry_ptr);\n    swoole_set_object(zresponse_object, ctx);\n\n    //socket fd\n    zend_update_property_long(swoole_http_response_class_entry_ptr, zresponse_object, ZEND_STRL(\"fd\"), client->fd TSRMLS_CC);\n    zend_update_property_long(swoole_http_request_class_entry_ptr, zrequest_object, ZEND_STRL(\"fd\"), client->fd TSRMLS_CC);\n\n#if PHP_MEMORY_DEBUG\n    php_vmstat.new_http_request ++;\n#endif\n\n    zval *zheader;\n    swoole_http_server_array_init(header, request);\n\n    zval *zserver;\n    swoole_http_server_array_init(server, request);\n\n    ctx->fd = client->fd;\n    ctx->client = client;\n\n    return ctx;\n}\n\nvoid swoole_http_context_free(http_context *ctx TSRMLS_DC)\n{\n    swoole_set_object(ctx->response.zobject, NULL);\n    http_request *req = &ctx->request;\n    if (req->path)\n    {\n        efree(req->path);\n    }\n    if (req->zdata)\n    {\n        sw_zval_ptr_dtor(&req->zdata);\n    }\n#ifdef SW_USE_HTTP2\n    if (req->post_buffer)\n    {\n        swString_free(req->post_buffer);\n    }\n#endif\n    efree(ctx);\n}\n\nstatic char *http_status_message(int code)\n{\n    switch (code)\n    {\n    case 100:\n        return \"100 Continue\";\n    case 101:\n        return \"101 Switching Protocols\";\n    case 201:\n        return \"201 Created\";\n    case 202:\n        return \"202 Accepted\";\n    case 203:\n        return \"203 Non-Authoritative Information\";\n    case 204:\n        return \"204 No Content\";\n    case 205:\n        return \"205 Reset Content\";\n    case 206:\n        return \"206 Partial Content\";\n    case 207:\n        return \"207 Multi-Status\";\n    case 208:\n        return \"208 Already Reported\";\n    case 226:\n        return \"226 IM Used\";\n    case 300:\n        return \"300 Multiple Choices\";\n    case 301:\n        return \"301 Moved Permanently\";\n    case 302:\n        return \"302 Found\";\n    case 303:\n        return \"303 See Other\";\n    case 304:\n        return \"304 Not Modified\";\n    case 305:\n        return \"305 Use Proxy\";\n    case 307:\n        return \"307 Temporary Redirect\";\n    case 400:\n        return \"400 Bad Request\";\n    case 401:\n        return \"401 Unauthorized\";\n    case 402:\n        return \"402 Payment Required\";\n    case 403:\n        return \"403 Forbidden\";\n    case 404:\n        return \"404 Not Found\";\n    case 405:\n        return \"405 Method Not Allowed\";\n    case 406:\n        return \"406 Not Acceptable\";\n    case 407:\n        return \"407 Proxy Authentication Required\";\n    case 408:\n        return \"408 Request Timeout\";\n    case 409:\n        return \"409 Conflict\";\n    case 410:\n        return \"410 Gone\";\n    case 411:\n        return \"411 Length Required\";\n    case 412:\n        return \"412 Precondition Failed\";\n    case 413:\n        return \"413 Request Entity Too Large\";\n    case 414:\n        return \"414 Request URI Too Long\";\n    case 415:\n        return \"415 Unsupported Media Type\";\n    case 416:\n        return \"416 Requested Range Not Satisfiable\";\n    case 417:\n        return \"417 Expectation Failed\";\n    case 418:\n        return \"418 I'm a teapot\";\n    case 421:\n        return \"421 Misdirected Request\";\n    case 422:\n        return \"422 Unprocessable Entity\";\n    case 423:\n        return \"423 Locked\";\n    case 424:\n        return \"424 Failed Dependency\";\n    case 426:\n        return \"426 Upgrade Required\";\n    case 428:\n        return \"428 Precondition Required\";\n    case 429:\n        return \"429 Too Many Requests\";\n    case 431:\n        return \"431 Request Header Fields Too Large\";\n    case 500:\n        return \"500 Internal Server Error\";\n    case 501:\n        return \"501 Method Not Implemented\";\n    case 502:\n        return \"502 Bad Gateway\";\n    case 503:\n        return \"503 Service Unavailable\";\n    case 505:\n        return \"505 HTTP Version Not Supported\";\n    case 506:\n        return \"506 Variant Also Negotiates\";\n    case 507:\n        return \"507 Insufficient Storage\";\n    case 508:\n        return \"508 Loop Detected\";\n    case 510:\n        return \"510 Not Extended\";\n    case 511:\n        return \"511 Network Authentication Required\";\n    case 200:\n    default:\n        return \"200 OK\";\n    }\n}\n\nstatic PHP_METHOD(swoole_http_server, start)\n{\n    int ret;\n\n    if (SwooleGS->start > 0)\n    {\n        swoole_php_error(E_WARNING, \"Server is running. Unable to execute swoole_server::start.\");\n        RETURN_FALSE;\n    }\n\n    swServer *serv = swoole_get_object(getThis());\n    php_swoole_register_callback(serv);\n\n    if (serv->listen_list->open_websocket_protocol)\n    {\n        if (php_sw_server_callbacks[SW_SERVER_CB_onMessage] == NULL)\n        {\n            swoole_php_fatal_error(E_ERROR, \"require onMessage callback\");\n            RETURN_FALSE;\n        }\n        if (serv->listen_list->open_http2_protocol == 1)\n        {\n            swoole_php_fatal_error(E_ERROR, \"cannot use http2 protocol in websocket server\");\n            RETURN_FALSE;\n        }\n    }\n    else if (php_sw_server_callbacks[SW_SERVER_CB_onRequest] == NULL)\n    {\n        swoole_php_fatal_error(E_ERROR, \"require onRequest callback\");\n        RETURN_FALSE;\n    }\n\n    http_client_array = swArray_new(1024, sizeof(swoole_http_client));\n    if (!http_client_array)\n    {\n        swoole_php_fatal_error(E_ERROR, \"swArray_new(1024, %ld) failed.\", sizeof(swoole_http_client));\n        RETURN_FALSE;\n    }\n\n    swoole_http_buffer = swString_new(SW_HTTP_RESPONSE_INIT_SIZE);\n    if (!swoole_http_buffer)\n    {\n        swoole_php_fatal_error(E_ERROR, \"[1] swString_new(%d) failed.\", SW_HTTP_RESPONSE_INIT_SIZE);\n        RETURN_FALSE;\n    }\n\n    swoole_http_form_data_buffer = swString_new(SW_HTTP_RESPONSE_INIT_SIZE);\n    if (!swoole_http_form_data_buffer)\n    {\n        swoole_php_fatal_error(E_ERROR, \"[2] swString_new(%d) failed.\", SW_HTTP_RESPONSE_INIT_SIZE);\n        RETURN_FALSE;\n    }\n\n#ifdef SW_HAVE_ZLIB\n    swoole_zlib_buffer = swString_new(SW_HTTP_RESPONSE_INIT_SIZE);\n    if (!swoole_zlib_buffer)\n    {\n        swoole_php_fatal_error(E_ERROR, \"[3] swString_new(%d) failed.\", SW_HTTP_RESPONSE_INIT_SIZE);\n        RETURN_FALSE;\n    }\n#endif\n\n    serv->onReceive = http_onReceive;\n\n    zval *zsetting = sw_zend_read_property(swoole_server_class_entry_ptr, getThis(), ZEND_STRL(\"setting\"), 1 TSRMLS_CC);\n    if (zsetting == NULL || ZVAL_IS_NULL(zsetting))\n    {\n        SW_MAKE_STD_ZVAL(zsetting);\n        array_init(zsetting);\n        zend_update_property(swoole_server_class_entry_ptr, getThis(), ZEND_STRL(\"setting\"), zsetting TSRMLS_CC);\n        sw_zval_ptr_dtor(&zsetting);\n    }\n\n    add_assoc_bool(zsetting, \"open_http_protocol\", 1);\n    add_assoc_bool(zsetting, \"open_mqtt_protocol\", 0);\n    add_assoc_bool(zsetting, \"open_eof_check\", 0);\n    add_assoc_bool(zsetting, \"open_length_check\", 0);\n\n    if (serv->listen_list->open_websocket_protocol)\n    {\n        add_assoc_bool(zsetting, \"open_websocket_protocol\", 1);\n    }\n\n    serv->listen_list->open_http_protocol = 1;\n    serv->listen_list->open_mqtt_protocol = 0;\n    serv->listen_list->open_eof_check = 0;\n    serv->listen_list->open_length_check = 0;\n\n    serv->ptr2 = getThis();\n\n    //for is_uploaded_file and move_uploaded_file\n    ALLOC_HASHTABLE(SG(rfc1867_uploaded_files));\n    zend_hash_init(SG(rfc1867_uploaded_files), 8, NULL, NULL, 0);\n\n    php_swoole_server_before_start(serv, getThis() TSRMLS_CC);\n\n    ret = swServer_start(serv);\n    if (ret < 0)\n    {\n        swoole_php_fatal_error(E_ERROR, \"start server failed. Error: %s\", sw_error);\n        RETURN_LONG(ret);\n    }\n    RETURN_TRUE;\n}\n\nstatic PHP_METHOD(swoole_http_request, rawcontent)\n{\n    zval *zfd = sw_zend_read_property(swoole_http_request_class_entry_ptr, getThis(), ZEND_STRL(\"fd\"), 0 TSRMLS_CC);\n    if (ZVAL_IS_NULL(zfd))\n    {\n        swoole_php_error(E_WARNING, \"http client not exists.\");\n        RETURN_FALSE;\n    }\n\n    http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);\n    if (!ctx)\n    {\n        RETURN_FALSE;\n    }\n\n    http_request *req = &ctx->request;\n    if (req->post_length > 0)\n    {\n        SW_RETVAL_STRINGL(Z_STRVAL_P(req->zdata) + Z_STRLEN_P(req->zdata) - req->post_length, req->post_length, 1);\n    }\n#ifdef SW_USE_HTTP2\n    else if (req->post_buffer)\n    {\n        SW_RETVAL_STRINGL(req->post_buffer->str, req->post_buffer->length, 1);\n    }\n#endif\n    else\n    {\n        RETURN_FALSE;\n    }\n}\n\nstatic PHP_METHOD(swoole_http_request, __destruct)\n{\n    zval *zfiles = sw_zend_read_property(swoole_http_request_class_entry_ptr, getThis(), ZEND_STRL(\"files\"), 1 TSRMLS_CC);\n    //upload files\n    if (zfiles && Z_TYPE_P(zfiles) == IS_ARRAY)\n    {\n        zval *value;\n        char *key;\n        int keytype;\n        uint32_t keylen;\n\n        SW_HASHTABLE_FOREACH_START2(Z_ARRVAL_P(zfiles), key, keylen, keytype, value)\n        {\n            if (HASH_KEY_IS_STRING != keytype)\n            {\n                continue;\n            }\n            zval *file_path;\n            if (sw_zend_hash_find(Z_ARRVAL_P(value), ZEND_STRS(\"tmp_name\"), (void **) &file_path) == SUCCESS)\n            {\n                unlink(Z_STRVAL_P(file_path));\n                sw_zend_hash_del(SG(rfc1867_uploaded_files), Z_STRVAL_P(file_path), Z_STRLEN_P(file_path) + 1);\n            }\n        }\n        SW_HASHTABLE_FOREACH_END();\n    }\n    swoole_set_object(getThis(), NULL);\n}\n\nstatic PHP_METHOD(swoole_http_response, write)\n{\n    zval *zdata;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z\", &zdata) == FAILURE)\n    {\n        return;\n    }\n\n    http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);\n    if (!ctx)\n    {\n        return;\n    }\n\n    if (!ctx->send_header)\n    {\n        ctx->chunk = 1;\n        swString_clear(swoole_http_buffer);\n        http_build_header(ctx, getThis(), swoole_http_buffer, -1 TSRMLS_CC);\n        if (swServer_tcp_send(SwooleG.serv, ctx->fd, swoole_http_buffer->str, swoole_http_buffer->length) < 0)\n        {\n            ctx->chunk = 0;\n            ctx->send_header = 0;\n            RETURN_FALSE;\n        }\n    }\n\n    swString http_body;\n    int length = php_swoole_get_send_data(zdata, &http_body.str TSRMLS_CC);\n\n    if (length < 0)\n    {\n        RETURN_FALSE;\n    }\n    else if (length == 0)\n    {\n       swoole_php_error(E_WARNING, \"data is empty.\");\n        RETURN_FALSE;\n    }\n    else\n    {\n        http_body.length = length;\n    }\n\n    swString_clear(swoole_http_buffer);\n\n    char *hex_string;\n    int hex_len;\n\n#ifdef SW_HAVE_ZLIB\n    if (ctx->gzip_enable)\n    {\n        http_response_compress(&http_body, ctx->gzip_level);\n\n        hex_string = swoole_dec2hex(swoole_zlib_buffer->length, 16);\n        hex_len = strlen(hex_string);\n\n        //\"%*s\\r\\n%*s\\r\\n\", hex_len, hex_string, body.length, body.str\n        swString_append_ptr(swoole_http_buffer, hex_string, hex_len);\n        swString_append_ptr(swoole_http_buffer, SW_STRL(\"\\r\\n\") - 1);\n        swString_append(swoole_http_buffer, swoole_zlib_buffer);\n        swString_append_ptr(swoole_http_buffer, SW_STRL(\"\\r\\n\") - 1);\n    }\n    else\n#endif\n    {\n        hex_string = swoole_dec2hex(http_body.length, 16);\n        hex_len = strlen(hex_string);\n\n        //\"%*s\\r\\n%*s\\r\\n\", hex_len, hex_string, body.length, body.str\n        swString_append_ptr(swoole_http_buffer, hex_string, hex_len);\n        swString_append_ptr(swoole_http_buffer, SW_STRL(\"\\r\\n\") - 1);\n        swString_append_ptr(swoole_http_buffer, http_body.str, http_body.length);\n        swString_append_ptr(swoole_http_buffer, SW_STRL(\"\\r\\n\") - 1);\n    }\n\n    int ret = swServer_tcp_send(SwooleG.serv, ctx->fd, swoole_http_buffer->str, swoole_http_buffer->length);\n    sw_strdup_free(hex_string);\n    SW_CHECK_RETURN(ret);\n}\n\nstatic http_context* http_get_context(zval *object, int check_end TSRMLS_DC)\n{\n    http_context *ctx = swoole_get_object(object);\n    if (!ctx)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Http request is end.\");\n        return NULL;\n    }\n    if (check_end && ctx->end)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Http request is end.\");\n        return NULL;\n    }\n    return ctx;\n}\n\nstatic void http_build_header(http_context *ctx, zval *object, swString *response, int body_length TSRMLS_DC)\n{\n    assert(ctx->send_header == 0);\n\n    char buf[SW_HTTP_HEADER_MAX_SIZE];\n    int n;\n    char *date_str;\n\n    /**\n     * http status line\n     */\n    n = snprintf(buf, sizeof(buf), \"HTTP/1.1 %s\\r\\n\", http_status_message(ctx->response.status));\n    swString_append_ptr(response, buf, n);\n\n    /**\n     * http header\n     */\n    zval *header = ctx->response.zheader;\n    if (header)\n    {\n        int flag = 0x0;\n        char *key_server = \"Server\";\n        char *key_connection = \"Connection\";\n        char *key_content_length = \"Content-Length\";\n        char *key_content_type = \"Content-Type\";\n        char *key_date = \"Date\";\n\n        HashTable *ht = Z_ARRVAL_P(header);\n        zval *value = NULL;\n        char *key = NULL;\n        uint32_t keylen = 0;\n        int type;\n\n        SW_HASHTABLE_FOREACH_START2(ht, key, keylen, type, value)\n        {\n            if (!key)\n            {\n                break;\n            }\n            if (strcmp(key, key_server) == 0)\n            {\n                flag |= HTTP_RESPONSE_SERVER;\n            }\n            else if (strcmp(key, key_connection) == 0)\n            {\n                flag |= HTTP_RESPONSE_CONNECTION;\n            }\n            else if (strcmp(key, key_content_length) == 0)\n            {\n                flag |= HTTP_RESPONSE_CONTENT_LENGTH;\n            }\n            else if (strcmp(key, key_date) == 0)\n            {\n                flag |= HTTP_RESPONSE_DATE;\n            }\n            else if (strcmp(key, key_content_type) == 0)\n            {\n                flag |= HTTP_RESPONSE_CONTENT_TYPE;\n            }\n            n = snprintf(buf, sizeof(buf), \"%*s: %*s\\r\\n\", keylen - 1, key, Z_STRLEN_P(value), Z_STRVAL_P(value));\n            swString_append_ptr(response, buf, n);\n        }\n        SW_HASHTABLE_FOREACH_END();\n\n        if (!(flag & HTTP_RESPONSE_SERVER))\n        {\n            swString_append_ptr(response, ZEND_STRL(\"Server: \"SW_HTTP_SERVER_SOFTWARE\"\\r\\n\"));\n        }\n        if (!(flag & HTTP_RESPONSE_CONNECTION))\n        {\n            if (ctx->keepalive)\n            {\n                swString_append_ptr(response, ZEND_STRL(\"Connection: keep-alive\\r\\n\"));\n            }\n            else\n            {\n                swString_append_ptr(response, ZEND_STRL(\"Connection: close\\r\\n\"));\n            }\n        }\n        if (ctx->request.method == PHP_HTTP_OPTIONS)\n        {\n            swString_append_ptr(response, ZEND_STRL(\"Allow: GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS\\r\\nContent-Length: 0\\r\\n\"));\n        }\n        else\n        {\n            if (!(flag & HTTP_RESPONSE_CONTENT_LENGTH) && body_length >= 0)\n            {\n#ifdef SW_HAVE_ZLIB\n                if (ctx->gzip_enable)\n                {\n                    body_length = swoole_zlib_buffer->length;\n                }\n#endif\n                n = snprintf(buf, sizeof(buf), \"Content-Length: %d\\r\\n\", body_length);\n                swString_append_ptr(response, buf, n);\n            }\n        }\n        if (!(flag & HTTP_RESPONSE_DATE))\n        {\n            date_str = sw_php_format_date(ZEND_STRL(SW_HTTP_DATE_FORMAT), SwooleGS->now, 0 TSRMLS_CC);\n            n = snprintf(buf, sizeof(buf), \"Date: %s\\r\\n\", date_str);\n            swString_append_ptr(response, buf, n);\n            efree(date_str);\n        }\n        if (!(flag & HTTP_RESPONSE_CONTENT_TYPE))\n        {\n            swString_append_ptr(response, ZEND_STRL(\"Content-Type: text/html\\r\\n\"));\n        }\n    }\n    else\n    {\n        swString_append_ptr(response, ZEND_STRL(\"Server: \"SW_HTTP_SERVER_SOFTWARE\"\\r\\nContent-Type: text/html\\r\\n\"));\n        if (ctx->keepalive)\n        {\n            swString_append_ptr(response, ZEND_STRL(\"Connection: keep-alive\\r\\n\"));\n        }\n        else\n        {\n            swString_append_ptr(response, ZEND_STRL(\"Connection: close\\r\\n\"));\n        }\n\n        date_str = sw_php_format_date(ZEND_STRL(SW_HTTP_DATE_FORMAT), SwooleGS->now, 0 TSRMLS_CC);\n        n = snprintf(buf, sizeof(buf), \"Date: %s\\r\\n\", date_str);\n        efree(date_str);\n        swString_append_ptr(response, buf, n);\n\n        if (ctx->request.method == PHP_HTTP_OPTIONS)\n        {\n            n = snprintf(buf, sizeof(buf), \"Allow: GET, POST, PUT, DELETE, HEAD, OPTIONS\\r\\nContent-Length: %d\\r\\n\", 0);\n            swString_append_ptr(response, buf, n);\n        }\n        else if (body_length >= 0)\n        {\n#ifdef SW_HAVE_ZLIB\n            if (ctx->gzip_enable)\n            {\n                body_length = swoole_zlib_buffer->length;\n            }\n#endif\n            n = snprintf(buf, sizeof(buf), \"Content-Length: %d\\r\\n\", body_length);\n            swString_append_ptr(response, buf, n);\n        }\n    }\n\n    if (ctx->chunk)\n    {\n        swString_append_ptr(response, SW_STRL(\"Transfer-Encoding: chunked\\r\\n\") - 1);\n    }\n    //http cookies\n    if (ctx->response.zcookie)\n    {\n        zval *value;\n        SW_HASHTABLE_FOREACH_START(Z_ARRVAL_P(ctx->response.zcookie), value)\n        {\n            if (Z_TYPE_P(value) != IS_STRING)\n            {\n                continue;\n            }\n            swString_append_ptr(response, SW_STRL(\"Set-Cookie: \") - 1);\n            swString_append_ptr(response, Z_STRVAL_P(value), Z_STRLEN_P(value));\n            swString_append_ptr(response, SW_STRL(\"\\r\\n\") - 1);\n        }\n        SW_HASHTABLE_FOREACH_END();\n    }\n    //http compress\n    if (ctx->gzip_enable)\n    {\n#ifdef SW_HTTP_COMPRESS_GZIP\n        swString_append_ptr(response, SW_STRL(\"Content-Encoding: gzip\\r\\n\") - 1);\n#else\n        swString_append_ptr(response, SW_STRL(\"Content-Encoding: deflate\\r\\n\") - 1);\n#endif\n    }\n    swString_append_ptr(response, ZEND_STRL(\"\\r\\n\"));\n    ctx->send_header = 1;\n}\n\n#ifdef SW_HAVE_ZLIB\nstatic int http_response_compress(swString *body, int level)\n{\n    assert(level > 0 || level < 10);\n\n    size_t memory_size = ((size_t) ((double) body->length * (double) 1.015)) + 10 + 8 + 4 + 1;\n\n    if (memory_size > swoole_zlib_buffer->size)\n    {\n        swString_extend(swoole_zlib_buffer, memory_size);\n    }\n\n    z_stream zstream;\n    memset(&zstream, 0, sizeof(zstream));\n\n    //deflate: -0xf, gzip: 0x1f\n#ifdef SW_HTTP_COMPRESS_GZIP\n    int encoding = 0x1f;\n#else\n    int encoding =  -0xf;\n#endif\n\n    int status;\n    if (Z_OK == deflateInit2(&zstream, level, Z_DEFLATED, encoding, MAX_MEM_LEVEL, Z_DEFAULT_STRATEGY))\n    {\n        zstream.next_in = (Bytef *) body->str;\n        zstream.next_out = (Bytef *) swoole_zlib_buffer->str;\n        zstream.avail_in = body->length;\n        zstream.avail_out = swoole_zlib_buffer->size;\n\n        status = deflate(&zstream, Z_FINISH);\n        deflateEnd(&zstream);\n\n        if (Z_STREAM_END == status)\n        {\n            swoole_zlib_buffer->length = zstream.total_out;\n            return SW_OK;\n        }\n    }\n    else\n    {\n        swWarn(\"deflateInit2() failed.\");\n    }\n    return SW_ERR;\n}\n#endif\n\nstatic PHP_METHOD(swoole_http_response, end)\n{\n    zval *zdata = NULL;\n    int ret;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|z\", &zdata) == FAILURE)\n    {\n        return;\n    }\n\n    swString http_body;\n\n    if (zdata)\n    {\n        int length = php_swoole_get_send_data(zdata, &http_body.str TSRMLS_CC);\n\n        if (length < 0)\n        {\n            RETURN_FALSE;\n        }\n        else\n        {\n            http_body.length = length;\n        }\n    }\n    else\n    {\n        http_body.length = 0;\n        http_body.str = NULL;\n    }\n\n    http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);\n    if (!ctx)\n    {\n        RETURN_FALSE;\n    }\n\n#ifdef SW_USE_HTTP2\n    if (ctx->http2)\n    {\n        swoole_http2_do_response(ctx, &http_body);\n        RETURN_TRUE;\n    }\n#endif\n\n    if (ctx->chunk)\n    {\n        ret = swServer_tcp_send(SwooleG.serv, ctx->fd, SW_STRL(\"0\\r\\n\\r\\n\") - 1);\n        if (ret < 0)\n        {\n            RETURN_FALSE;\n        }\n        ctx->chunk = 0;\n    }\n    //no http chunk\n    else\n    {\n        swString_clear(swoole_http_buffer);\n#ifdef SW_HAVE_ZLIB\n        if (ctx->gzip_enable)\n        {\n            if (http_body.length > 0)\n            {\n                http_response_compress(&http_body, ctx->gzip_level);\n            }\n            else\n            {\n                ctx->gzip_enable = 0;\n            }\n        }\n#endif\n        http_build_header(ctx, getThis(), swoole_http_buffer, http_body.length TSRMLS_CC);\n        if (http_body.length > 0)\n        {\n#ifdef SW_HAVE_ZLIB\n            if (ctx->gzip_enable)\n            {\n                swString_append(swoole_http_buffer, swoole_zlib_buffer);\n            }\n            else\n#endif\n            {\n                swString_append(swoole_http_buffer, &http_body);\n            }\n        }\n\n        ret = swServer_tcp_send(SwooleG.serv, ctx->fd, swoole_http_buffer->str, swoole_http_buffer->length);\n        if (ret < 0)\n        {\n            ctx->send_header = 0;\n            RETURN_FALSE;\n        }\n    }\n    if (!ctx->keepalive)\n    {\n        SwooleG.serv->factory.end(&SwooleG.serv->factory, ctx->fd);\n    }\n    swoole_http_context_free(ctx TSRMLS_CC);\n    RETURN_TRUE;\n}\n\nstatic PHP_METHOD(swoole_http_response, sendfile)\n{\n    char *filename;\n    zend_size_t filename_length;\n    int ret;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &filename, &filename_length) == FAILURE)\n    {\n        return;\n    }\n\n    if (filename_length <= 0)\n    {\n        swoole_php_error(E_WARNING, \"file name is empty.\");\n        RETURN_FALSE;\n    }\n\n    http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);\n    if (!ctx)\n    {\n        RETURN_FALSE;\n    }\n\n    if (ctx->chunk)\n    {\n        swoole_php_error(E_WARNING, \"cannot use HTTP-Chunk.\");\n        RETURN_FALSE;\n    }\n\n    int file_fd = open(filename, O_RDONLY);\n    if (file_fd < 0)\n    {\n        swoole_php_sys_error(E_WARNING, \"open(%s) failed.\", filename);\n        RETURN_FALSE;\n    }\n\n    struct stat file_stat;\n    if (fstat(file_fd, &file_stat) < 0)\n    {\n        swoole_php_sys_error(E_WARNING, \"fstat(%s) failed.\", filename);\n        RETURN_FALSE;\n    }\n\n    if (file_stat.st_size <= 0)\n    {\n        swoole_php_error(E_WARNING, \"file is empty.\");\n        RETURN_FALSE;\n    }\n\n    swString_clear(swoole_http_buffer);\n    http_build_header(ctx, getThis(), swoole_http_buffer, file_stat.st_size TSRMLS_CC);\n\n    ret = swServer_tcp_send(SwooleG.serv, ctx->fd, swoole_http_buffer->str, swoole_http_buffer->length);\n    if (ret < 0)\n    {\n        ctx->send_header = 0;\n        RETURN_FALSE;\n    }\n\n    ret = swServer_tcp_sendfile(SwooleG.serv, ctx->fd, filename, filename_length);\n    if (ret < 0)\n    {\n        ctx->send_header = 0;\n        RETURN_FALSE;\n    }\n    if (!ctx->keepalive)\n    {\n        SwooleG.serv->factory.end(&SwooleG.serv->factory, ctx->fd);\n    }\n    swoole_http_context_free(ctx TSRMLS_CC);\n    RETURN_TRUE;\n}\n\nstatic PHP_METHOD(swoole_http_response, cookie)\n{\n    char *name, *value = NULL, *path = NULL, *domain = NULL;\n    long expires = 0;\n    int encode = 1;\n    zend_bool secure = 0, httponly = 0;\n    zend_size_t name_len, value_len = 0, path_len = 0, domain_len = 0;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|slssbb\", &name, &name_len, &value, &value_len, &expires,\n                &path, &path_len, &domain, &domain_len, &secure, &httponly) == FAILURE)\n    {\n        return;\n    }\n\n    http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);\n    if (!ctx)\n    {\n        RETURN_FALSE;\n    }\n\n    zval *zcookie = ctx->response.zcookie;\n    zval *zresponse_object = ctx->response.zobject;\n    if (!zcookie)\n    {\n        swoole_http_server_array_init(cookie, response);\n    }\n\n    char *cookie, *encoded_value = NULL;\n    int len = 0;\n    char *dt;\n\n    if (name && strpbrk(name, \"=,; \\t\\r\\n\\013\\014\") != NULL)\n    {\n        swoole_php_error(E_WARNING, \"Cookie names cannot contain any of the following '=,; \\\\t\\\\r\\\\n\\\\013\\\\014'\");\n        RETURN_FALSE;\n    }\n\n    len += name_len;\n    if (encode && value)\n    {\n        int encoded_value_len;\n        encoded_value = sw_php_url_encode(value, value_len, &encoded_value_len);\n        len += encoded_value_len;\n    }\n    else if (value)\n    {\n        encoded_value = estrdup(value);\n        len += value_len;\n    }\n    if (path)\n    {\n        len += path_len;\n    }\n    if (domain)\n    {\n        len += domain_len;\n    }\n\n    cookie = emalloc(len + 100);\n\n    if (value && value_len == 0)\n    {\n        dt = sw_php_format_date(\"D, d-M-Y H:i:s T\", sizeof(\"D, d-M-Y H:i:s T\") - 1, 1, 0 TSRMLS_CC);\n        snprintf(cookie, len + 100, \"%s=deleted; expires=%s\", name, dt);\n        efree(dt);\n    }\n    else\n    {\n        snprintf(cookie, len + 100, \"%s=%s\", name, value ? encoded_value : \"\");\n        if (expires > 0)\n        {\n            const char *p;\n            strlcat(cookie, \"; expires=\", len + 100);\n            dt = sw_php_format_date(\"D, d-M-Y H:i:s T\", sizeof(\"D, d-M-Y H:i:s T\") - 1, expires, 0 TSRMLS_CC);\n            p = zend_memrchr(dt, '-', strlen(dt));\n            if (!p || *(p + 5) != ' ')\n            {\n                efree(dt);\n                efree(cookie);\n                efree(encoded_value);\n                swoole_php_error(E_WARNING, \"Expiry date cannot have a year greater than 9999\");\n                RETURN_FALSE;\n            }\n            strlcat(cookie, dt, len + 100);\n            efree(dt);\n        }\n    }\n    if (encoded_value)\n    {\n        efree(encoded_value);\n    }\n    if (path && path_len > 0)\n    {\n        strlcat(cookie, \"; path=\", len + 100);\n        strlcat(cookie, path, len + 100);\n    }\n    if (domain && domain_len > 0)\n    {\n        strlcat(cookie, \"; domain=\", len + 100);\n        strlcat(cookie, domain, len + 100);\n    }\n    if (secure)\n    {\n        strlcat(cookie, \"; secure\", len + 100);\n    }\n    if (httponly)\n    {\n        strlcat(cookie, \"; httponly\", len + 100);\n    }\n    sw_add_next_index_stringl(zcookie, cookie, strlen(cookie), 0);\n#if PHP_MAJOR_VERSION >= 7\n    efree(cookie);\n#endif\n}\n\nstatic PHP_METHOD(swoole_http_response, rawcookie)\n{\n    char *name, *value = NULL, *path = NULL, *domain = NULL;\n    long expires = 0;\n    int encode = 0;\n    zend_bool secure = 0, httponly = 0;\n    zend_size_t name_len, value_len = 0, path_len = 0, domain_len = 0;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|slssbb\", &name, &name_len, &value, &value_len, &expires,\n                &path, &path_len, &domain, &domain_len, &secure, &httponly) == FAILURE)\n    {\n        return;\n    }\n\n    http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);\n    if (!ctx)\n    {\n        RETURN_FALSE;\n    }\n\n    zval *zcookie = ctx->response.zcookie;\n    zval *zresponse_object = ctx->response.zobject;\n    if (!zcookie)\n    {\n        swoole_http_server_array_init(cookie, response);\n    }\n\n    char *cookie, *encoded_value = NULL;\n    int len = 0;\n    char *dt;\n\n    if (name && strpbrk(name, \"=,; \\t\\r\\n\\013\\014\") != NULL)\n    {\n        swoole_php_error(E_WARNING, \"Cookie names cannot contain any of the following '=,; \\\\t\\\\r\\\\n\\\\013\\\\014'\");\n        RETURN_FALSE;\n    }\n\n    len += name_len;\n    if (encode && value)\n    {\n        int encoded_value_len;\n        encoded_value = sw_php_url_encode(value, value_len, &encoded_value_len);\n        len += encoded_value_len;\n    }\n    else if (value)\n    {\n        encoded_value = estrdup(value);\n        len += value_len;\n    }\n    if (path)\n    {\n        len += path_len;\n    }\n    if (domain)\n    {\n        len += domain_len;\n    }\n\n    cookie = emalloc(len + 100);\n\n    if (value && value_len == 0)\n    {\n        dt = sw_php_format_date(\"D, d-M-Y H:i:s T\", sizeof(\"D, d-M-Y H:i:s T\") - 1, 1, 0 TSRMLS_CC);\n        snprintf(cookie, len + 100, \"%s=deleted; expires=%s\", name, dt);\n        efree(dt);\n    }\n    else\n    {\n        snprintf(cookie, len + 100, \"%s=%s\", name, value ? encoded_value : \"\");\n        if (expires > 0)\n        {\n            const char *p;\n            strlcat(cookie, \"; expires=\", len + 100);\n            dt = sw_php_format_date(\"D, d-M-Y H:i:s T\", sizeof(\"D, d-M-Y H:i:s T\") - 1, expires, 0 TSRMLS_CC);\n            p = zend_memrchr(dt, '-', strlen(dt));\n            if (!p || *(p + 5) != ' ')\n            {\n                efree(dt);\n                efree(cookie);\n                efree(encoded_value);\n                swoole_php_error(E_WARNING, \"Expiry date cannot have a year greater than 9999\");\n                RETURN_FALSE;\n            }\n            strlcat(cookie, dt, len + 100);\n            efree(dt);\n        }\n    }\n    if (encoded_value)\n    {\n        efree(encoded_value);\n    }\n    if (path && path_len > 0)\n    {\n        strlcat(cookie, \"; path=\", len + 100);\n        strlcat(cookie, path, len + 100);\n    }\n    if (domain && domain_len > 0)\n    {\n        strlcat(cookie, \"; domain=\", len + 100);\n        strlcat(cookie, domain, len + 100);\n    }\n    if (secure)\n    {\n        strlcat(cookie, \"; secure\", len + 100);\n    }\n    if (httponly)\n    {\n        strlcat(cookie, \"; httponly\", len + 100);\n    }\n    sw_add_next_index_stringl(zcookie, cookie, strlen(cookie), 0);\n#if PHP_MAJOR_VERSION >= 7\n    efree(cookie);\n#endif\n}\n\nstatic PHP_METHOD(swoole_http_response, status)\n{\n    long http_status;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &http_status) == FAILURE)\n    {\n        return;\n    }\n\n    http_context *client = http_get_context(getThis(), 0 TSRMLS_CC);\n    if (!client)\n    {\n        RETURN_FALSE;\n    }\n\n    client->response.status = http_status;\n}\n\nstatic PHP_METHOD(swoole_http_response, header)\n{\n    char *k, *v;\n    zend_size_t klen, vlen;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ss\", &k, &klen, &v, &vlen) == FAILURE)\n    {\n        return;\n    }\n\n    http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);\n    if (!ctx)\n    {\n        RETURN_FALSE;\n    }\n\n    zval *zheader = ctx->response.zheader;\n    zval *zresponse_object = ctx->response.zobject;\n    if (!zheader)\n    {\n        swoole_http_server_array_init(header, response);\n    }\n    if (klen > SW_HTTP_HEADER_KEY_SIZE - 1)\n    {\n        swoole_php_error(E_WARNING, \"header key is too long.\");\n        RETURN_FALSE;\n    }\n    if (vlen > SW_HTTP_HEADER_VALUE_SIZE)\n    {\n        swoole_php_error(E_WARNING, \"header key is too long.\");\n        RETURN_FALSE;\n    }\n    char key_buf[SW_HTTP_HEADER_KEY_SIZE];\n    memcpy(key_buf, k, klen);\n    key_buf[klen] = '\\0';\n    if (ctx->http2)\n    {\n        swoole_strtolower(key_buf, klen);\n    }\n    else\n    {\n        http_header_key_format(key_buf, klen);\n    }\n    sw_add_assoc_stringl_ex(zheader, key_buf, klen + 1, v, vlen, 1);\n}\n\n#ifdef SW_HAVE_ZLIB\nstatic PHP_METHOD(swoole_http_response, gzip)\n{\n    long level = Z_DEFAULT_COMPRESSION;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|l\", &level) == FAILURE)\n    {\n        return;\n    }\n\n    http_context *context = http_get_context(getThis(), 0 TSRMLS_CC);\n    if (!context)\n    {\n        RETURN_FALSE;\n    }\n\n    if (context->send_header)\n    {\n        swoole_php_fatal_error(E_WARNING, \"must use before send header.\");\n        RETURN_FALSE;\n    }\n\n    if (level > 9)\n    {\n        level = 9;\n    }\n    if (level < 0)\n    {\n        level = 0;\n    }\n\n    context->gzip_enable = 1;\n    context->gzip_level = level;\n}\n#endif\n\nstatic PHP_METHOD(swoole_http_response, __destruct)\n{\n    http_context *context = swoole_get_object(getThis());\n    if (context)\n    {\n        zval *zobject = getThis();\n        zval *retval = NULL;\n        sw_zend_call_method_with_0_params(&zobject, swoole_http_response_class_entry_ptr, NULL, \"end\", &retval);\n        if (retval)\n        {\n            sw_zval_ptr_dtor(&retval);\n        }\n    }\n}",
        "base_contents": "/*\n  +----------------------------------------------------------------------+\n  | Swoole                                                               |\n  +----------------------------------------------------------------------+\n  | This source file is subject to version 2.0 of the Apache license,    |\n  | that is bundled with this package in the file LICENSE, and is        |\n  | available through the world-wide-web at the following url:           |\n  | http://www.apache.org/licenses/LICENSE-2.0.html                      |\n  | If you did not receive a copy of the Apache2.0 license and are unable|\n  | to obtain it through the world-wide-web, please send a note to       |\n  | license@swoole.com so we can mail you a copy immediately.            |\n  +----------------------------------------------------------------------+\n  | Author: Tianfeng Han  <mikan.tenny@gmail.com>                        |\n  +----------------------------------------------------------------------+\n*/\n\n#include \"php_swoole.h\"\n#include \"swoole_http.h\"\n#ifdef SW_COROUTINE\n#include \"swoole_coroutine.h\"\n#endif\n\n#include <ext/standard/url.h>\n#include <ext/standard/sha1.h>\n#include <ext/standard/php_var.h>\n#include <ext/standard/php_string.h>\n#include <ext/standard/php_math.h>\n#include <ext/standard/php_array.h>\n#include <ext/date/php_date.h>\n#include <ext/standard/md5.h>\n\n#include <main/rfc1867.h>\n#include <main/php_variables.h>\n\n#include \"websocket.h\"\n#include \"Connection.h\"\n#include \"base64.h\"\n\n#ifdef SW_HAVE_ZLIB\n#include <zlib.h>\n#endif\n\n#ifdef SW_USE_HTTP2\n#include \"http2.h\"\n#include <nghttp2/nghttp2.h>\n#endif\n\nstatic swArray *http_client_array;\n\nswString *swoole_http_buffer;\nswString *swoole_zlib_buffer;\nswString *swoole_http_form_data_buffer;\n\nenum http_global_flag\n{\n    HTTP_GLOBAL_GET       = 1u << 1,\n    HTTP_GLOBAL_POST      = 1u << 2,\n    HTTP_GLOBAL_COOKIE    = 1u << 3,\n    HTTP_GLOBAL_REQUEST   = 1u << 4,\n    HTTP_GLOBAL_SERVER    = 1u << 5,\n    HTTP_GLOBAL_FILES     = 1u << 6,\n};\n\nenum http_upload_errno\n{\n    HTTP_UPLOAD_ERR_OK = 0,\n    HTTP_UPLOAD_ERR_INI_SIZE,\n    HTTP_UPLOAD_ERR_FORM_SIZE,\n    HTTP_UPLOAD_ERR_PARTIAL,\n    HTTP_UPLOAD_ERR_NO_FILE,\n    HTTP_UPLOAD_ERR_NO_TMP_DIR = 6,\n    HTTP_UPLOAD_ERR_CANT_WRITE,\n};\n\nzend_class_entry swoole_http_server_ce;\nzend_class_entry *swoole_http_server_class_entry_ptr;\n\nzend_class_entry swoole_http_response_ce;\nzend_class_entry *swoole_http_response_class_entry_ptr;\n\nzend_class_entry swoole_http_request_ce;\nzend_class_entry *swoole_http_request_class_entry_ptr;\n\nstatic int http_onReceive(swServer *serv, swEventData *req);\n\nstatic int http_request_on_path(php_http_parser *parser, const char *at, size_t length);\nstatic int http_request_on_query_string(php_http_parser *parser, const char *at, size_t length);\nstatic int http_request_on_body(php_http_parser *parser, const char *at, size_t length);\nstatic int http_request_on_header_field(php_http_parser *parser, const char *at, size_t length);\nstatic int http_request_on_header_value(php_http_parser *parser, const char *at, size_t length);\nstatic int http_request_on_headers_complete(php_http_parser *parser);\nstatic int http_request_message_complete(php_http_parser *parser);\n\nstatic int multipart_body_on_header_field(multipart_parser* p, const char *at, size_t length);\nstatic int multipart_body_on_header_value(multipart_parser* p, const char *at, size_t length);\nstatic int multipart_body_on_data(multipart_parser* p, const char *at, size_t length);\nstatic int multipart_body_on_header_complete(multipart_parser* p);\nstatic int multipart_body_on_data_end(multipart_parser* p);\nstatic int multipart_body_end(multipart_parser* p);\n\nstatic http_context* http_get_context(zval *object, int check_end TSRMLS_DC);\n\nstatic void http_parse_cookie(zval *array, const char *at, size_t length);\nstatic void http_build_header(http_context *, zval *object, swString *response, int body_length TSRMLS_DC);\nstatic int http_trim_double_quote(zval **value, char **ptr);\n\nstatic inline void http_header_key_format(char *key, int length)\n{\n    int i, state = 0;\n    for (i = 0; i < length; i++)\n    {\n        if (state == 0)\n        {\n            if (key[i] >= 97 && key[i] <= 122)\n            {\n                key[i] -= 32;\n            }\n            state = 1;\n        }\n        else if (key[i] == '-')\n        {\n            state = 0;\n        }\n        else\n        {\n            if (key[i] >= 65 && key[i] <= 90)\n            {\n                key[i] += 32;\n            }\n        }\n    }\n}\n\n#ifdef SW_HAVE_ZLIB\nstatic int http_response_compress(swString *body, int level);\n#endif\n\nstatic PHP_METHOD(swoole_http_server, on);\nstatic PHP_METHOD(swoole_http_server, start);\n\nstatic PHP_METHOD(swoole_http_request, rawcontent);\nstatic PHP_METHOD(swoole_http_request, __destruct);\n\nstatic PHP_METHOD(swoole_http_response, write);\nstatic PHP_METHOD(swoole_http_response, end);\nstatic PHP_METHOD(swoole_http_response, sendfile);\nstatic PHP_METHOD(swoole_http_response, cookie);\nstatic PHP_METHOD(swoole_http_response, rawcookie);\nstatic PHP_METHOD(swoole_http_response, header);\n#ifdef SW_HAVE_ZLIB\nstatic PHP_METHOD(swoole_http_response, gzip);\n#endif\nstatic PHP_METHOD(swoole_http_response, status);\nstatic PHP_METHOD(swoole_http_response, __destruct);\n\nstatic sw_inline char* http_get_method_name(int method)\n{\n    switch (method)\n    {\n    case PHP_HTTP_GET:\n        return \"GET\";\n    case PHP_HTTP_POST:\n        return \"POST\";\n    case PHP_HTTP_HEAD:\n        return \"HEAD\";\n    case PHP_HTTP_PUT:\n        return \"PUT\";\n    case PHP_HTTP_DELETE:\n        return \"DELETE\";\n    case PHP_HTTP_PATCH:\n        return \"PATCH\";\n    case PHP_HTTP_CONNECT:\n        return \"CONNECT\";\n    case PHP_HTTP_OPTIONS:\n        return \"OPTIONS\";\n    case PHP_HTTP_TRACE:\n        return \"TRACE\";\n    case PHP_HTTP_COPY:\n        return \"COPY\";\n    case PHP_HTTP_LOCK:\n        return \"LOCK\";\n    case PHP_HTTP_MKCOL:\n        return \"MKCOL\";\n    case PHP_HTTP_MOVE:\n        return \"MOVE\";\n    case PHP_HTTP_PROPFIND:\n        return \"PROPFIND\";\n    case PHP_HTTP_PROPPATCH:\n        return \"PROPPATCH\";\n    case PHP_HTTP_UNLOCK:\n        return \"UNLOCK\";\n        /* subversion */\n    case PHP_HTTP_REPORT:\n        return \"REPORT\";\n    case PHP_HTTP_MKACTIVITY:\n        return \"MKACTIVITY\";\n    case PHP_HTTP_CHECKOUT:\n        return \"CHECKOUT\";\n    case PHP_HTTP_MERGE:\n        return \"MERGE\";\n        /* upnp */\n    case PHP_HTTP_MSEARCH:\n        return \"MSEARCH\";\n    case PHP_HTTP_NOTIFY:\n        return \"NOTIFY\";\n    case PHP_HTTP_SUBSCRIBE:\n        return \"SUBSCRIBE\";\n    case PHP_HTTP_UNSUBSCRIBE:\n        return \"UNSUBSCRIBE\";\n    case PHP_HTTP_NOT_IMPLEMENTED:\n        return \"IMPLEMENTED\";\n    default:\n        return NULL;\n    }\n}\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_http_server_on, 0, 0, 2)\n    ZEND_ARG_INFO(0, ha_name)\n    ZEND_ARG_INFO(0, cb)\nZEND_END_ARG_INFO()\n\nstatic const php_http_parser_settings http_parser_settings =\n{\n    NULL,\n    http_request_on_path,\n    http_request_on_query_string,\n    NULL,\n    NULL,\n    http_request_on_header_field,\n    http_request_on_header_value,\n    http_request_on_headers_complete,\n    http_request_on_body,\n    http_request_message_complete\n};\n\nstatic const multipart_parser_settings mt_parser_settings = \n{\n    multipart_body_on_header_field,\n    multipart_body_on_header_value,\n    multipart_body_on_data,\n    NULL,\n    multipart_body_on_header_complete,\n    multipart_body_on_data_end,\n    multipart_body_end\n};\n\nconst zend_function_entry swoole_http_server_methods[] =\n{\n    PHP_ME(swoole_http_server, on,         arginfo_swoole_http_server_on, ZEND_ACC_PUBLIC)\n    PHP_ME(swoole_http_server, start,      NULL, ZEND_ACC_PUBLIC)\n    PHP_FE_END\n};\n\nconst zend_function_entry swoole_http_request_methods[] =\n{\n    PHP_ME(swoole_http_request, rawcontent, NULL, ZEND_ACC_PUBLIC)\n    PHP_ME(swoole_http_request, __destruct, NULL, ZEND_ACC_PUBLIC | ZEND_ACC_DTOR)\n    PHP_FE_END\n};\n\nconst zend_function_entry swoole_http_response_methods[] =\n{\n    PHP_ME(swoole_http_response, cookie, NULL, ZEND_ACC_PUBLIC)\n    PHP_ME(swoole_http_response, rawcookie, NULL, ZEND_ACC_PUBLIC)\n    PHP_ME(swoole_http_response, status, NULL, ZEND_ACC_PUBLIC)\n#ifdef SW_HAVE_ZLIB\n    PHP_ME(swoole_http_response, gzip, NULL, ZEND_ACC_PUBLIC)\n#endif\n    PHP_ME(swoole_http_response, header, NULL, ZEND_ACC_PUBLIC)\n    PHP_ME(swoole_http_response, write, NULL, ZEND_ACC_PUBLIC)\n    PHP_ME(swoole_http_response, end, NULL, ZEND_ACC_PUBLIC)\n    PHP_ME(swoole_http_response, sendfile, NULL, ZEND_ACC_PUBLIC)\n    PHP_ME(swoole_http_response, __destruct, NULL, ZEND_ACC_PUBLIC | ZEND_ACC_DTOR)\n    PHP_FE_END\n};\n\nstatic int http_request_on_path(php_http_parser *parser, const char *at, size_t length)\n{\n    http_context *ctx = parser->data;\n    ctx->request.path = estrndup(at, length);\n    ctx->request.path_len = length;\n    return 0;\n}\n\nstatic int http_request_on_query_string(php_http_parser *parser, const char *at, size_t length)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n    http_context *ctx = parser->data;\n\n    //no need free, will free by treat_data\n    char *query = estrndup(at, length);\n    sw_add_assoc_stringl_ex(ctx->request.zserver, ZEND_STRS(\"query_string\"), query, length, 1);\n\n    zval *zrequest_object = ctx->request.zobject;\n    zval *zget;\n    swoole_http_server_array_init(get, request);\n\n    //parse url params\n    sapi_module.treat_data(PARSE_STRING, query, zget TSRMLS_CC);\n\n    return 0;\n}\n\nstatic int http_request_on_header_field(php_http_parser *parser, const char *at, size_t length)\n{\n    http_context *ctx = parser->data;\n    if (ctx->current_header_name_allocated)\n    {\n        efree(ctx->current_header_name);\n        ctx->current_header_name_allocated = 0;\n    }\n    ctx->current_header_name = (char *) at;\n    ctx->current_header_name_len = length;\n    return 0;\n}\n\nint swoole_http_parse_form_data(http_context *ctx, const char *boundary_str, int boundary_len TSRMLS_DC)\n{\n    multipart_parser *mt_parser = multipart_parser_init(boundary_str, boundary_len, &mt_parser_settings);\n    if (!mt_parser)\n    {\n        swoole_php_fatal_error(E_WARNING, \"multipart_parser_init() failed.\");\n        return SW_ERR;\n    }\n\n    ctx->mt_parser = mt_parser;\n    mt_parser->data = ctx;\n\n    return SW_OK;\n}\n\nstatic void http_parse_cookie(zval *array, const char *at, size_t length)\n{\n    char keybuf[SW_HTTP_COOKIE_KEYLEN];\n    char valbuf[SW_HTTP_COOKIE_VALLEN];\n    char *_c = (char *) at;\n\n    int klen = 0;\n    int vlen = 0;\n    int state = -1;\n\t\n    int i = 0, j = 0;\n    while (_c < at + length)\n    {\n        if (state <= 0 && *_c == '=')\n        {\n            klen = i - j + 1;\n            if (klen >= SW_HTTP_COOKIE_KEYLEN)\n            {\n                swWarn(\"cookie key is too large.\");\n                return;\n            }\n            memcpy(keybuf, at + j, klen - 1);\n            keybuf[klen - 1] = 0;\n\n            j = i + 1;\n            state = 1;\n        }\n        else if (state == 1 && *_c == ';')\n        {\n            vlen = i - j;\n            strncpy(valbuf, (char * ) at + j, SW_HTTP_COOKIE_VALLEN);\n            vlen = php_url_decode(valbuf, vlen);\n            sw_add_assoc_stringl_ex(array, keybuf, klen, valbuf, vlen, 1);\n            j = i + 1;\n            state = -1;\n        }\n        else if (state < 0)\n        {\n            if (isspace(*_c))\n            {\n                //Remove leading spaces from cookie names \n                ++j;\n            } \n            else\n            {\n                state = 0;\n            }\n        }\n        _c++;\n        i++;\n    }\n    if (j < length)\n    {\n        vlen = i - j;\n        keybuf[klen - 1] = 0;\n        strncpy(valbuf, (char * ) at + j, SW_HTTP_COOKIE_VALLEN);\n        vlen = php_url_decode(valbuf, vlen);\n        sw_add_assoc_stringl_ex(array, keybuf, klen, valbuf, vlen, 1);\n    }\n}\n\nstatic int http_trim_double_quote(zval **value, char **ptr)\n{\n    int len = Z_STRLEN_PP(value);\n    *ptr = Z_STRVAL_PP(value);\n\n    //ltrim('\"')\n    if ((*ptr)[0] == '\"')\n    {\n        (*ptr)++;\n        len--;\n    }\n    //rtrim('\"')\n    if ((*ptr)[len - 1] == '\"')\n    {\n        len--;\n    }\n    return len;\n}\n\nstatic int http_request_on_header_value(php_http_parser *parser, const char *at, size_t length)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    http_context *ctx = parser->data;\n    zval *zrequest_object = ctx->request.zobject;\n    char *header_name = zend_str_tolower_dup(ctx->current_header_name, ctx->current_header_name_len);\n\n    if (strncasecmp(header_name, \"cookie\", ctx->current_header_name_len) == 0)\n    {\n        zval *zcookie;\n        if (length >= SW_HTTP_COOKIE_VALLEN)\n        {\n            swWarn(\"cookie is too large.\");\n        }\n        else\n        {\n            swoole_http_server_array_init(cookie, request);\n            http_parse_cookie(zcookie, at, length);\n        }\n        goto free_memory;\n    }\n    else if (SwooleG.serv->listen_list->open_websocket_protocol && strncasecmp(header_name, ZEND_STRL(\"upgrade\")) == 0 && strncasecmp(at, ZEND_STRL(\"websocket\")) == 0)\n    {\n        swConnection *conn = swWorker_get_connection(SwooleG.serv, ctx->fd);\n        if (!conn)\n        {\n            swWarn(\"connection[%d] is closed.\", ctx->fd);\n            return SW_ERR;\n        }\n        conn->websocket_status = WEBSOCKET_STATUS_CONNECTION;\n    }\n    else if (parser->method == PHP_HTTP_POST || parser->method == PHP_HTTP_PUT || parser->method == PHP_HTTP_DELETE || parser->method == PHP_HTTP_PATCH)\n    {\n        if (memcmp(header_name, ZEND_STRL(\"content-type\")) == 0)\n        {\n            if (strncasecmp(at, ZEND_STRL(\"application/x-www-form-urlencoded\")) == 0)\n            {\n                ctx->request.post_form_urlencoded = 1;\n            }\n            else if (memcmp(header_name, ZEND_STRL(\"content-type\")) == 0 && strncasecmp(at, ZEND_STRL(\"multipart/form-data\")) == 0)\n            {\n                int boundary_len = length - strlen(\"multipart/form-data; boundary=\");\n                if (boundary_len <= 0)\n                {\n                    swWarn(\"invalid multipart/form-data body.\", ctx->fd);\n                    return 0;\n                }\n                swoole_http_parse_form_data(ctx, at + length - boundary_len, boundary_len TSRMLS_CC);\n            }\n        }\n    }\n\n    zval *header = ctx->request.zheader;\n    sw_add_assoc_stringl_ex(header, header_name, ctx->current_header_name_len + 1, (char *) at, length, 1);\n\n    free_memory:\n    if (ctx->current_header_name_allocated)\n    {\n        efree(ctx->current_header_name);\n        ctx->current_header_name_allocated = 0;\n    }\n    efree(header_name);\n\n    return 0;\n}\n\nstatic int http_request_on_headers_complete(php_http_parser *parser)\n{\n    http_context *ctx = parser->data;\n    if (ctx->current_header_name_allocated)\n    {\n        efree(ctx->current_header_name);\n        ctx->current_header_name_allocated = 0;\n    }\n    ctx->current_header_name = NULL;\n\n    return 0;\n}\n\nstatic int multipart_body_on_header_field(multipart_parser* p, const char *at, size_t length)\n{\n    http_context *ctx = p->data;\n    return http_request_on_header_field(&ctx->parser, at, length);\n}\n\nstatic int multipart_body_on_header_value(multipart_parser* p, const char *at, size_t length)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    http_context *ctx = p->data;\n    zval *zrequest_object = ctx->request.zobject;\n    zval *zfiles = ctx->request.zfiles;\n    if (!zfiles)\n    {\n        swoole_http_server_array_init(files, request);\n    }\n\n    char *headername = zend_str_tolower_dup(ctx->current_header_name, ctx->current_header_name_len);\n\n    if (strncasecmp(headername, ZEND_STRL(\"content-disposition\")) == 0)\n    {\n        //not form data\n        if (swoole_strnpos((char *) at, length, ZEND_STRL(\"form-data;\")) < 0)\n        {\n            return SW_OK;\n        }\n\n        zval *tmp_array;\n        SW_MAKE_STD_ZVAL(tmp_array);\n        array_init(tmp_array);\n        http_parse_cookie(tmp_array, (char *) at + sizeof(\"form-data;\"), length - sizeof(\"form-data;\"));\n\n        zval *form_name;\n        if (sw_zend_hash_find(Z_ARRVAL_P(tmp_array), ZEND_STRS(\"name\"), (void **) &form_name) == FAILURE)\n        {\n            return SW_OK;\n        }\n\n        char *str;\n        int len = http_trim_double_quote(&form_name, &str);\n\n        zval *filename;\n        //POST form data\n        if (sw_zend_hash_find(Z_ARRVAL_P(tmp_array), ZEND_STRS(\"filename\"), (void **) &filename) == FAILURE)\n        {\n            ctx->current_form_data_name = estrndup(str, len);\n            ctx->current_form_data_name_len = len;\n        }\n        //upload file\n        else\n        {\n            ctx->current_input_name = estrndup(str, len);\n\n            zval *multipart_header;\n            SW_MAKE_STD_ZVAL(multipart_header);\n            array_init(multipart_header);\n            add_assoc_zval(zfiles, ctx->current_input_name, multipart_header);\n\n            sw_add_assoc_string(multipart_header, \"name\", \"\", 1);\n            sw_add_assoc_string(multipart_header, \"type\", \"\", 1);\n            sw_add_assoc_string(multipart_header, \"tmp_name\", \"\", 1);\n            add_assoc_long(multipart_header, \"error\", HTTP_UPLOAD_ERR_OK);\n            add_assoc_long(multipart_header, \"size\", 0);\n\n            len = http_trim_double_quote(&filename, &str);\n            sw_add_assoc_stringl(multipart_header, \"name\", str, len, 1);\n        }\n        sw_zval_ptr_dtor(&tmp_array);\n    }\n\n    if (strncasecmp(headername, ZEND_STRL(\"content-type\")) == 0)\n    {\n        zval *multipart_header = NULL;\n        sw_zend_hash_find(Z_ARRVAL_P(zfiles), ctx->current_input_name, strlen(ctx->current_input_name) + 1, (void **) &multipart_header);\n        sw_add_assoc_stringl(multipart_header, \"type\", (char * ) at, length, 1);\n    }\n\n    if (ctx->current_header_name_allocated)\n    {\n        efree(ctx->current_header_name);\n        ctx->current_header_name_allocated = 0;\n    }\n    efree(headername);\n\n    return 0;\n}\n\nstatic int multipart_body_on_data(multipart_parser* p, const char *at, size_t length)\n{\n    http_context *ctx = p->data;\n    if (ctx->current_form_data_name)\n    {\n        swString_append_ptr(swoole_http_form_data_buffer, (char*) at, length);\n        return 0;\n    }\n    if (p->fp == NULL)\n    {\n        return 0;\n    }\n    int n = fwrite(at, sizeof(char), length, (FILE *) p->fp);\n    if (n != length)\n    {\n        zval *files = ctx->request.zfiles;\n        zval *multipart_header = NULL;\n        sw_zend_hash_find(Z_ARRVAL_P(files), ctx->current_input_name, strlen(ctx->current_input_name) + 1, (void **) &multipart_header);\n        add_assoc_long(multipart_header, \"error\", HTTP_UPLOAD_ERR_CANT_WRITE);\n\n        fclose((FILE *) p->fp);\n        p->fp = NULL;\n\n        swWarn(\"write upload file failed. Error %s[%d]\", strerror(errno), errno);\n    }\n    return 0;\n}\n\n#if 0\nstatic void get_random_file_name(char *des, const char *src)\n{\n    unsigned char digest[16] = {0};\n    char buf[19] = {0};\n    int n = sprintf(buf, \"%s%d\", src, swoole_system_random(0, 9999));\n\n    PHP_MD5_CTX ctx;\n    PHP_MD5Init(&ctx);\n    PHP_MD5Update(&ctx, buf, n);\n    PHP_MD5Final(digest, &ctx);\n    make_digest_ex(des, digest, 16);\n}\n#endif\n\nstatic int multipart_body_on_header_complete(multipart_parser* p)\n{\n    http_context *ctx = p->data;\n    if (!ctx->current_input_name)\n    {\n        return 0;\n    }\n\n    zval *files = ctx->request.zfiles;\n    zval *multipart_header;\n\n    if (sw_zend_hash_find(Z_ARRVAL_P(files), ctx->current_input_name, strlen(ctx->current_input_name) + 1, (void **) &multipart_header) == FAILURE)\n    {\n        return 0;\n    }\n\n    zval *zerr = NULL;\n    sw_zend_hash_find(Z_ARRVAL_P(multipart_header), ZEND_STRS(\"error\"), (void **) &zerr);\n    if (Z_LVAL_P(zerr) != HTTP_UPLOAD_ERR_OK)\n    {\n        return 0;\n    }\n\n    char file_path[sizeof(SW_HTTP_UPLOAD_TMP_FILE)];\n    memcpy(file_path, SW_HTTP_UPLOAD_TMP_FILE, sizeof(SW_HTTP_UPLOAD_TMP_FILE));\n    int tmpfile = swoole_tmpfile(file_path);\n\n    FILE *fp = fdopen(tmpfile, \"wb+\");\n    if (fp < 0)\n    {\n        add_assoc_long(multipart_header, \"error\", HTTP_UPLOAD_ERR_NO_TMP_DIR);\n        swWarn(\"fopen(%s) failed. Error %s[%d]\", file_path, strerror(errno), errno);\n        return 0;\n    }\n\n    p->fp = fp;\n    sw_add_assoc_string(multipart_header, \"tmp_name\", file_path, 1);\n\n    return 0;\n}\n\nstatic int multipart_body_on_data_end(multipart_parser* p)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    http_context *ctx = p->data;\n    zval *zrequest_object = ctx->request.zobject;\n    if (ctx->current_form_data_name)\n    {\n        zval *zpost = sw_zend_read_property(swoole_http_request_class_entry_ptr, zrequest_object, ZEND_STRL(\"post\"), 1 TSRMLS_CC);\n        if (ZVAL_IS_NULL(zpost))\n        {\n            swoole_http_server_array_init(post, request);\n        }\n\n\t\tchar *name = ctx->current_form_data_name;\n\t\tint len = ctx->current_form_data_name_len;\n\n\t\tif ((name[len-1] == ']') && (name[len-2] == '['))\n\t\t{\n\t\t\tzval *array_value;\n\t\t\tif (sw_zend_hash_find(Z_ARRVAL_P(zpost), name, len + 1, (void **) &array_value) == FAILURE)\n\t\t\t{\n\t\t\t\tSW_MAKE_STD_ZVAL(array_value);\n\t\t\t\tarray_init(array_value);\n\t\t\t\tadd_assoc_zval(zpost, name, array_value);\n\t\t\t}\n            sw_add_next_index_stringl(array_value, swoole_http_form_data_buffer->str, swoole_http_form_data_buffer->length, 1);\n\t\t}\n\t\telse\n\t\t{\n            sw_add_assoc_stringl_ex(zpost, ctx->current_form_data_name, ctx->current_form_data_name_len + 1,\n                    swoole_http_form_data_buffer->str, swoole_http_form_data_buffer->length, 1);\n\t\t}\n\n        efree(ctx->current_form_data_name);\n        ctx->current_form_data_name = NULL;\n        ctx->current_form_data_name_len = 0;\n        swString_clear(swoole_http_form_data_buffer);\n        return 0;\n    }\n\n    if (!ctx->current_input_name)\n    {\n        return 0;\n    }\n\n    zval *files = ctx->request.zfiles;\n    if (ZVAL_IS_NULL(files))\n    {\n        return 0;\n    }\n\n    zval *multipart_header = NULL;\n    sw_zend_hash_find(Z_ARRVAL_P(files), ctx->current_input_name, strlen(ctx->current_input_name) + 1, (void **) &multipart_header);\n\n    if (p->fp != NULL)\n    {\n        long size = swoole_file_get_size((FILE*) p->fp);\n        add_assoc_long(multipart_header, \"size\", size);\n\n        fclose((FILE *)p->fp);\n        p->fp = NULL;\n    }\n\n    efree(ctx->current_input_name);\n\n    return 0;\n}\n\nstatic int multipart_body_end(multipart_parser* p)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    http_context *ctx = p->data;\n    zval *files = ctx->request.zfiles;\n    zval *value;\n\n    SW_HASHTABLE_FOREACH_START(Z_ARRVAL_P(files), value)\n    {\n        zval *file_path;\n        if (sw_zend_hash_find(Z_ARRVAL_P(value), ZEND_STRS(\"tmp_name\"), (void **) &file_path) == SUCCESS)\n        {\n#if PHP_MAJOR_VERSION >= 7\n            zend_string *tmp_name = zval_get_string(file_path);\n            zend_hash_add_ptr(SG(rfc1867_uploaded_files), tmp_name, tmp_name);\n#else\n            char *temp_filename = Z_STRVAL_P(file_path);\n            sw_zend_hash_add(SG(rfc1867_uploaded_files), temp_filename, Z_STRLEN_P(file_path) + 1, &temp_filename, sizeof(char *), NULL);\n#endif\n        }\n    }\n    SW_HASHTABLE_FOREACH_END();\n\n    return 0;\n}\n\nstatic int http_request_on_body(php_http_parser *parser, const char *at, size_t length)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    http_context *ctx = parser->data;\n    zval *zrequest_object = ctx->request.zobject;\n    char *body;\n\n    ctx->request.post_length = length;\n    if (SwooleG.serv->http_parse_post && ctx->request.post_form_urlencoded)\n    {\n        zval *zpost;\n        swoole_http_server_array_init(post, request);\n        body = estrndup(at, length);\n\n        sapi_module.treat_data(PARSE_STRING, body, zpost TSRMLS_CC);\n    }\n    else if (ctx->mt_parser != NULL)\n    {\n        multipart_parser *multipart_parser = ctx->mt_parser;\n        size_t n = multipart_parser_execute(multipart_parser, at, length);\n        if (n != length)\n        {\n            swoole_php_fatal_error(E_WARNING, \"parse multipart body failed.\");\n        }\n    }\n\n    return 0;\n}\n\nstatic int http_request_message_complete(php_http_parser *parser)\n{\n    http_context *ctx = parser->data;\n    ctx->request.version = parser->http_major * 100 + parser->http_minor;\n\n    const char *vpath = ctx->request.path, *end = vpath + ctx->request.path_len, *p = end;\n    ctx->request.ext = end;\n    ctx->request.ext_len = 0;\n    while (p > vpath)\n    {\n        --p;\n        if (*p == '.')\n        {\n            ++p;\n            ctx->request.ext = p;\n            ctx->request.ext_len = end - p;\n            break;\n        }\n    }\n    ctx->request_read = 1;\n\n    if (ctx->mt_parser)\n    {\n        multipart_parser_free(ctx->mt_parser);\n        ctx->mt_parser = NULL;\n    }\n\n    return 0;\n}\n\nstatic int http_onReceive(swServer *serv, swEventData *req)\n{\n    int fd = req->info.fd;\n\n    swConnection *conn = swWorker_get_connection(SwooleG.serv, fd);\n    if (!conn)\n    {\n        swWarn(\"connection[%d] is closed.\", fd);\n        return SW_ERR;\n    }\n    swListenPort *port = serv->connection_list[req->info.from_fd].object;\n    //other server port\n    if (!port->open_http_protocol)\n    {\n        return php_swoole_onReceive(serv, req);\n    }\n    //websocket client\n    if (conn->websocket_status == WEBSOCKET_STATUS_ACTIVE)\n    {\n        return swoole_websocket_onMessage(req);\n    }\n\n    swoole_http_client *client = swArray_fetch(http_client_array, conn->fd);\n    if (!client)\n    {\n        return SW_OK;\n    }\n    client->fd = fd;\n\n#ifdef SW_USE_HTTP2\n    if (conn->http2_stream)\n    {\n        client->http2 = 1;\n        return swoole_http2_onFrame(client, req);\n    }\n#endif\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    http_context *ctx = swoole_http_context_new(client TSRMLS_CC);\n    php_http_parser *parser = &ctx->parser;\n    zval *zserver = ctx->request.zserver;\n\n    parser->data = ctx;\n\n    php_http_parser_init(parser, PHP_HTTP_REQUEST);\n\n    zval *zdata;\n    SW_MAKE_STD_ZVAL(zdata);\n    ctx->request.zdata = zdata;\n    php_swoole_get_recv_data(zdata, req, NULL, 0);\n    sw_copy_to_stack(ctx->request.zdata, ctx->request._zdata);\n\n    swTrace(\"httpRequest %d bytes:\\n---------------------------------------\\n%s\\n\", Z_STRLEN_P(zdata), Z_STRVAL_P(zdata));\n\n    long n = php_http_parser_execute(parser, &http_parser_settings, Z_STRVAL_P(zdata), Z_STRLEN_P(zdata));\n    if (n < 0)\n    {\n        sw_zval_ptr_dtor(&zdata);\n        efree(client);\n        swWarn(\"php_http_parser_execute failed.\");\n\n        if (conn->websocket_status == WEBSOCKET_STATUS_CONNECTION)\n        {\n            return SwooleG.serv->factory.end(&SwooleG.serv->factory, fd);\n        }\n    }\n    else\n    {\n        zval *retval;\n#ifndef SW_COROUTINE\n        zval **args[2];\n#else\n        zval *args[2];\n#endif\n\n        zval *zrequest_object = ctx->request.zobject;\n        zval *zresponse_object = ctx->response.zobject;\n\n        ctx->keepalive = php_http_should_keep_alive(parser);\n        char *method_name = http_get_method_name(parser->method);\n\n        sw_add_assoc_string(zserver, \"request_method\", method_name, 1);\n        sw_add_assoc_stringl(zserver, \"request_uri\", ctx->request.path, ctx->request.path_len, 1);\n        sw_add_assoc_stringl(zserver, \"path_info\", ctx->request.path, ctx->request.path_len, 1);\n        sw_add_assoc_long_ex(zserver, ZEND_STRS(\"request_time\"), SwooleGS->now);\n\n        // Add REQUEST_TIME_FLOAT\n        double now_float = swoole_microtime();\n        sw_add_assoc_double_ex(zserver, ZEND_STRS(\"request_time_float\"), now_float);\n\n        swConnection *conn = swWorker_get_connection(SwooleG.serv, fd);\n        if (!conn)\n        {\n            sw_zval_ptr_dtor(&zdata);\n            swWarn(\"connection[%d] is closed.\", fd);\n            return SW_ERR;\n        }\n\n        add_assoc_long(ctx->request.zserver, \"server_port\", swConnection_get_port(&SwooleG.serv->connection_list[conn->from_fd]));\n        add_assoc_long(ctx->request.zserver, \"remote_port\", swConnection_get_port(conn));\n        sw_add_assoc_string(zserver, \"remote_addr\", swConnection_get_ip(conn), 1);\n\n        if (ctx->request.version == 101)\n        {\n            sw_add_assoc_string(zserver, \"server_protocol\", \"HTTP/1.1\", 1);\n        }\n        else\n        {\n            sw_add_assoc_string(zserver, \"server_protocol\", \"HTTP/1.0\", 1);\n        }\n\n        sw_add_assoc_string(zserver, \"server_software\", SW_HTTP_SERVER_SOFTWARE, 1);\n\n        zval *zcallback = php_swoole_server_get_callback(serv, req->info.from_fd, SW_SERVER_CB_onHandShake);\n        //websocket handshake\n        if (conn->websocket_status == WEBSOCKET_STATUS_CONNECTION && zcallback == NULL)\n        {\n            return swoole_websocket_onHandshake(ctx);\n        }\n        \n#ifndef SW_COROUTINE\n        args[0] = &zrequest_object;\n        args[1] = &zresponse_object;\n#else\n        args[0] = zrequest_object;\n        args[1] = zresponse_object;\n#endif\n\n        int callback_type = 0;\n        if (conn->websocket_status == WEBSOCKET_STATUS_CONNECTION)\n        {\n            callback_type = SW_SERVER_CB_onHandShake;\n            conn->websocket_status = WEBSOCKET_STATUS_HANDSHAKE;\n        }\n        else\n        {\n            callback_type = SW_SERVER_CB_onRequest;\n            zcallback = php_swoole_server_get_callback(serv, req->info.from_fd, SW_SERVER_CB_onRequest);\n            //no have onRequest callback\n            if (zcallback == NULL)\n            {\n                swoole_websocket_onReuqest(ctx);\n                return SW_OK;\n            }\n        }\n\n#ifndef SW_COROUTINE\n        zcallback = php_swoole_server_get_callback(serv, req->info.from_fd, callback_type);\n        if (sw_call_user_function_ex(EG(function_table), NULL, zcallback, &retval, 2, args, 0, NULL TSRMLS_CC) == FAILURE)\n        {\n            swoole_php_error(E_WARNING, \"onRequest handler error\");\n        }\n#else\n        zend_fcall_info_cache *cache = php_swoole_server_get_cache(serv, req->info.from_fd, callback_type);\n        int ret = coro_create(cache, args, 2, &retval);\n        if (ret != 0)\n        {\n            sw_zval_ptr_dtor(&zrequest_object);\n            sw_zval_ptr_dtor(&zresponse_object);\n            if (ret == CORO_LIMIT)\n            {\n                SwooleG.serv->factory.end(&SwooleG.serv->factory, fd);\n            }\n            return SW_OK;\n        }\n#endif\n        if (EG(exception))\n        {\n            zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n        }\n        //websocket user handshake\n        if (conn->websocket_status == WEBSOCKET_STATUS_HANDSHAKE)\n        {\n            //handshake success\n            if (retval && Z_BVAL_P(retval))\n            {\n                conn->websocket_status = WEBSOCKET_STATUS_ACTIVE;\n            }\n        }\n        sw_zval_ptr_dtor(&zrequest_object);\n        sw_zval_ptr_dtor(&zresponse_object);\n        if (retval)\n        {\n            sw_zval_ptr_dtor(&retval);\n        }\n    }\n    return SW_OK;\n}\n\nvoid swoole_http_server_init(int module_number TSRMLS_DC)\n{\n    SWOOLE_INIT_CLASS_ENTRY(swoole_http_server_ce, \"swoole_http_server\", \"Swoole\\\\Http\\\\Server\", swoole_http_server_methods);\n    swoole_http_server_class_entry_ptr = sw_zend_register_internal_class_ex(&swoole_http_server_ce, swoole_server_class_entry_ptr, \"swoole_server\" TSRMLS_CC);\n\n    zend_declare_property_long(swoole_http_server_class_entry_ptr, ZEND_STRL(\"global\"), 0, ZEND_ACC_PRIVATE TSRMLS_CC);\n\n    SWOOLE_INIT_CLASS_ENTRY(swoole_http_response_ce, \"swoole_http_response\", \"Swoole\\\\Http\\\\Response\", swoole_http_response_methods);\n    swoole_http_response_class_entry_ptr = zend_register_internal_class(&swoole_http_response_ce TSRMLS_CC);\n\n    SWOOLE_INIT_CLASS_ENTRY(swoole_http_request_ce, \"swoole_http_request\", \"Swoole\\\\Http\\\\Request\", swoole_http_request_methods);\n    swoole_http_request_class_entry_ptr = zend_register_internal_class(&swoole_http_request_ce TSRMLS_CC);\n}\n\nstatic PHP_METHOD(swoole_http_server, on)\n{\n    zval *callback;\n    zval *event_name;\n\n    if (SwooleGS->start > 0)\n    {\n        swoole_php_error(E_WARNING, \"Server is running. Unable to set event callback now.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"zz\", &event_name, &callback) == FAILURE)\n    {\n        return;\n    }\n\n#ifdef PHP_SWOOLE_CHECK_CALLBACK\n    char *func_name = NULL;\n#ifndef SW_COROUTINE\n    if (!sw_zend_is_callable(callback, 0, &func_name TSRMLS_CC))\n#else\n    zend_fcall_info_cache *func_cache = emalloc(sizeof(zend_fcall_info_cache));\n    if (!zend_is_callable_ex(callback, NULL, 0, &func_name, NULL, func_cache, NULL TSRMLS_CC))\n#endif\n    {\n        swoole_php_fatal_error(E_ERROR, \"Function '%s' is not callable\", func_name);\n        efree(func_name);\n        RETURN_FALSE;\n    }\n    efree(func_name);\n#endif\n\n    if (strncasecmp(\"request\", Z_STRVAL_P(event_name), Z_STRLEN_P(event_name)) == 0)\n    {\n        zend_update_property(swoole_http_server_class_entry_ptr, getThis(), ZEND_STRL(\"onRequest\"), callback TSRMLS_CC);\n        php_sw_server_callbacks[SW_SERVER_CB_onRequest] = sw_zend_read_property(swoole_http_server_class_entry_ptr, getThis(), ZEND_STRL(\"onRequest\"), 0 TSRMLS_CC);\n        sw_copy_to_stack(php_sw_server_callbacks[SW_SERVER_CB_onRequest], _php_sw_server_callbacks[SW_SERVER_CB_onRequest]);\n#ifdef SW_COROUTINE\n        php_sw_server_caches[SW_SERVER_CB_onRequest] = func_cache;\n#endif\n    }\n    else if (strncasecmp(\"handshake\", Z_STRVAL_P(event_name), Z_STRLEN_P(event_name)) == 0)\n    {\n        zend_update_property(swoole_http_server_class_entry_ptr, getThis(), ZEND_STRL(\"onHandshake\"), callback TSRMLS_CC);\n        php_sw_server_callbacks[SW_SERVER_CB_onHandShake] = sw_zend_read_property(swoole_http_server_class_entry_ptr, getThis(), ZEND_STRL(\"onHandshake\"), 0 TSRMLS_CC);\n        sw_copy_to_stack(php_sw_server_callbacks[SW_SERVER_CB_onHandShake], _php_sw_server_callbacks[SW_SERVER_CB_onHandShake]);\n#ifdef SW_COROUTINE\n        php_sw_server_caches[SW_SERVER_CB_onHandShake] = func_cache;\n#endif\n    }\n    else\n    {\n        zval *obj = getThis();\n        sw_zend_call_method_with_2_params(&obj, swoole_server_class_entry_ptr, NULL, \"on\", &return_value, event_name, callback);\n    }\n}\n\nhttp_context* swoole_http_context_new(swoole_http_client* client TSRMLS_DC)\n{\n    http_context *ctx = emalloc(sizeof(http_context));\n    if (!ctx)\n    {\n        swoole_error_log(SW_LOG_ERROR, SW_ERROR_MALLOC_FAIL, \"emalloc(%ld) failed.\", sizeof(http_context));\n        return NULL;\n    }\n    bzero(ctx, sizeof(http_context));\n\n    zval *zrequest_object;\n#if PHP_MAJOR_VERSION >= 7\n    zrequest_object = &ctx->request._zobject;\n#else\n    SW_ALLOC_INIT_ZVAL(zrequest_object);\n#endif\n    ctx->request.zobject = zrequest_object;\n    object_init_ex(zrequest_object, swoole_http_request_class_entry_ptr);\n    swoole_set_object(zrequest_object, ctx);\n\n    zval *zresponse_object;\n#if PHP_MAJOR_VERSION >= 7\n    zresponse_object = &ctx->response._zobject;\n#else\n    SW_ALLOC_INIT_ZVAL(zresponse_object);\n#endif\n    ctx->response.zobject = zresponse_object;\n    object_init_ex(zresponse_object, swoole_http_response_class_entry_ptr);\n    swoole_set_object(zresponse_object, ctx);\n\n    //socket fd\n    zend_update_property_long(swoole_http_response_class_entry_ptr, zresponse_object, ZEND_STRL(\"fd\"), client->fd TSRMLS_CC);\n    zend_update_property_long(swoole_http_request_class_entry_ptr, zrequest_object, ZEND_STRL(\"fd\"), client->fd TSRMLS_CC);\n\n#if PHP_MEMORY_DEBUG\n    php_vmstat.new_http_request ++;\n#endif\n\n    zval *zheader;\n    swoole_http_server_array_init(header, request);\n\n    zval *zserver;\n    swoole_http_server_array_init(server, request);\n\n    ctx->fd = client->fd;\n    ctx->client = client;\n\n    return ctx;\n}\n\nvoid swoole_http_context_free(http_context *ctx TSRMLS_DC)\n{\n    swoole_set_object(ctx->response.zobject, NULL);\n    http_request *req = &ctx->request;\n    if (req->path)\n    {\n        efree(req->path);\n    }\n    if (req->zdata)\n    {\n        sw_zval_ptr_dtor(&req->zdata);\n    }\n#ifdef SW_USE_HTTP2\n    if (req->post_buffer)\n    {\n        swString_free(req->post_buffer);\n    }\n#endif\n    efree(ctx);\n}\n\nstatic char *http_status_message(int code)\n{\n    switch (code)\n    {\n    case 100:\n        return \"100 Continue\";\n    case 101:\n        return \"101 Switching Protocols\";\n    case 201:\n        return \"201 Created\";\n    case 202:\n        return \"202 Accepted\";\n    case 203:\n        return \"203 Non-Authoritative Information\";\n    case 204:\n        return \"204 No Content\";\n    case 205:\n        return \"205 Reset Content\";\n    case 206:\n        return \"206 Partial Content\";\n    case 207:\n        return \"207 Multi-Status\";\n    case 208:\n        return \"208 Already Reported\";\n    case 226:\n        return \"226 IM Used\";\n    case 300:\n        return \"300 Multiple Choices\";\n    case 301:\n        return \"301 Moved Permanently\";\n    case 302:\n        return \"302 Found\";\n    case 303:\n        return \"303 See Other\";\n    case 304:\n        return \"304 Not Modified\";\n    case 305:\n        return \"305 Use Proxy\";\n    case 307:\n        return \"307 Temporary Redirect\";\n    case 400:\n        return \"400 Bad Request\";\n    case 401:\n        return \"401 Unauthorized\";\n    case 402:\n        return \"402 Payment Required\";\n    case 403:\n        return \"403 Forbidden\";\n    case 404:\n        return \"404 Not Found\";\n    case 405:\n        return \"405 Method Not Allowed\";\n    case 406:\n        return \"406 Not Acceptable\";\n    case 407:\n        return \"407 Proxy Authentication Required\";\n    case 408:\n        return \"408 Request Timeout\";\n    case 409:\n        return \"409 Conflict\";\n    case 410:\n        return \"410 Gone\";\n    case 411:\n        return \"411 Length Required\";\n    case 412:\n        return \"412 Precondition Failed\";\n    case 413:\n        return \"413 Request Entity Too Large\";\n    case 414:\n        return \"414 Request URI Too Long\";\n    case 415:\n        return \"415 Unsupported Media Type\";\n    case 416:\n        return \"416 Requested Range Not Satisfiable\";\n    case 417:\n        return \"417 Expectation Failed\";\n    case 418:\n        return \"418 I'm a teapot\";\n    case 421:\n        return \"421 Misdirected Request\";\n    case 422:\n        return \"422 Unprocessable Entity\";\n    case 423:\n        return \"423 Locked\";\n    case 424:\n        return \"424 Failed Dependency\";\n    case 426:\n        return \"426 Upgrade Required\";\n    case 428:\n        return \"428 Precondition Required\";\n    case 429:\n        return \"429 Too Many Requests\";\n    case 431:\n        return \"431 Request Header Fields Too Large\";\n    case 500:\n        return \"500 Internal Server Error\";\n    case 501:\n        return \"501 Method Not Implemented\";\n    case 502:\n        return \"502 Bad Gateway\";\n    case 503:\n        return \"503 Service Unavailable\";\n    case 505:\n        return \"505 HTTP Version Not Supported\";\n    case 506:\n        return \"506 Variant Also Negotiates\";\n    case 507:\n        return \"507 Insufficient Storage\";\n    case 508:\n        return \"508 Loop Detected\";\n    case 510:\n        return \"510 Not Extended\";\n    case 511:\n        return \"511 Network Authentication Required\";\n    case 200:\n    default:\n        return \"200 OK\";\n    }\n}\n\nstatic PHP_METHOD(swoole_http_server, start)\n{\n    int ret;\n\n    if (SwooleGS->start > 0)\n    {\n        swoole_php_error(E_WARNING, \"Server is running. Unable to execute swoole_server::start.\");\n        RETURN_FALSE;\n    }\n\n    swServer *serv = swoole_get_object(getThis());\n    php_swoole_register_callback(serv);\n\n    if (serv->listen_list->open_websocket_protocol)\n    {\n        if (php_sw_server_callbacks[SW_SERVER_CB_onMessage] == NULL)\n        {\n            swoole_php_fatal_error(E_ERROR, \"require onMessage callback\");\n            RETURN_FALSE;\n        }\n        if (serv->listen_list->open_http2_protocol == 1)\n        {\n            swoole_php_fatal_error(E_ERROR, \"cannot use http2 protocol in websocket server\");\n            RETURN_FALSE;\n        }\n    }\n    else if (php_sw_server_callbacks[SW_SERVER_CB_onRequest] == NULL)\n    {\n        swoole_php_fatal_error(E_ERROR, \"require onRequest callback\");\n        RETURN_FALSE;\n    }\n\n    http_client_array = swArray_new(1024, sizeof(swoole_http_client));\n    if (!http_client_array)\n    {\n        swoole_php_fatal_error(E_ERROR, \"swArray_new(1024, %ld) failed.\", sizeof(swoole_http_client));\n        RETURN_FALSE;\n    }\n\n    swoole_http_buffer = swString_new(SW_HTTP_RESPONSE_INIT_SIZE);\n    if (!swoole_http_buffer)\n    {\n        swoole_php_fatal_error(E_ERROR, \"[1] swString_new(%d) failed.\", SW_HTTP_RESPONSE_INIT_SIZE);\n        RETURN_FALSE;\n    }\n\n    swoole_http_form_data_buffer = swString_new(SW_HTTP_RESPONSE_INIT_SIZE);\n    if (!swoole_http_form_data_buffer)\n    {\n        swoole_php_fatal_error(E_ERROR, \"[2] swString_new(%d) failed.\", SW_HTTP_RESPONSE_INIT_SIZE);\n        RETURN_FALSE;\n    }\n\n#ifdef SW_HAVE_ZLIB\n    swoole_zlib_buffer = swString_new(SW_HTTP_RESPONSE_INIT_SIZE);\n    if (!swoole_zlib_buffer)\n    {\n        swoole_php_fatal_error(E_ERROR, \"[3] swString_new(%d) failed.\", SW_HTTP_RESPONSE_INIT_SIZE);\n        RETURN_FALSE;\n    }\n#endif\n\n    serv->onReceive = http_onReceive;\n\n    zval *zsetting = sw_zend_read_property(swoole_server_class_entry_ptr, getThis(), ZEND_STRL(\"setting\"), 1 TSRMLS_CC);\n    if (zsetting == NULL || ZVAL_IS_NULL(zsetting))\n    {\n        SW_MAKE_STD_ZVAL(zsetting);\n        array_init(zsetting);\n        zend_update_property(swoole_server_class_entry_ptr, getThis(), ZEND_STRL(\"setting\"), zsetting TSRMLS_CC);\n        sw_zval_ptr_dtor(&zsetting);\n    }\n\n    add_assoc_bool(zsetting, \"open_http_protocol\", 1);\n    add_assoc_bool(zsetting, \"open_mqtt_protocol\", 0);\n    add_assoc_bool(zsetting, \"open_eof_check\", 0);\n    add_assoc_bool(zsetting, \"open_length_check\", 0);\n\n    if (serv->listen_list->open_websocket_protocol)\n    {\n        add_assoc_bool(zsetting, \"open_websocket_protocol\", 1);\n    }\n\n    serv->listen_list->open_http_protocol = 1;\n    serv->listen_list->open_mqtt_protocol = 0;\n    serv->listen_list->open_eof_check = 0;\n    serv->listen_list->open_length_check = 0;\n\n    serv->ptr2 = getThis();\n\n    //for is_uploaded_file and move_uploaded_file\n    ALLOC_HASHTABLE(SG(rfc1867_uploaded_files));\n    zend_hash_init(SG(rfc1867_uploaded_files), 8, NULL, NULL, 0);\n\n    php_swoole_server_before_start(serv, getThis() TSRMLS_CC);\n\n    ret = swServer_start(serv);\n    if (ret < 0)\n    {\n        swoole_php_fatal_error(E_ERROR, \"start server failed. Error: %s\", sw_error);\n        RETURN_LONG(ret);\n    }\n    RETURN_TRUE;\n}\n\nstatic PHP_METHOD(swoole_http_request, rawcontent)\n{\n    zval *zfd = sw_zend_read_property(swoole_http_request_class_entry_ptr, getThis(), ZEND_STRL(\"fd\"), 0 TSRMLS_CC);\n    if (ZVAL_IS_NULL(zfd))\n    {\n        swoole_php_error(E_WARNING, \"http client not exists.\");\n        RETURN_FALSE;\n    }\n\n    http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);\n    if (!ctx)\n    {\n        RETURN_FALSE;\n    }\n\n    http_request *req = &ctx->request;\n    if (req->post_length > 0)\n    {\n        SW_RETVAL_STRINGL(Z_STRVAL_P(req->zdata) + Z_STRLEN_P(req->zdata) - req->post_length, req->post_length, 1);\n    }\n#ifdef SW_USE_HTTP2\n    else if (req->post_buffer)\n    {\n        SW_RETVAL_STRINGL(req->post_buffer->str, req->post_buffer->length, 1);\n    }\n#endif\n    else\n    {\n        RETURN_FALSE;\n    }\n}\n\nstatic PHP_METHOD(swoole_http_request, __destruct)\n{\n    zval *zfiles = sw_zend_read_property(swoole_http_request_class_entry_ptr, getThis(), ZEND_STRL(\"files\"), 1 TSRMLS_CC);\n    //upload files\n    if (zfiles && Z_TYPE_P(zfiles) == IS_ARRAY)\n    {\n        zval *value;\n        char *key;\n        int keytype;\n        uint32_t keylen;\n\n        SW_HASHTABLE_FOREACH_START2(Z_ARRVAL_P(zfiles), key, keylen, keytype, value)\n        {\n            if (HASH_KEY_IS_STRING != keytype)\n            {\n                continue;\n            }\n            zval *file_path;\n            if (sw_zend_hash_find(Z_ARRVAL_P(value), ZEND_STRS(\"tmp_name\"), (void **) &file_path) == SUCCESS)\n            {\n                unlink(Z_STRVAL_P(file_path));\n                sw_zend_hash_del(SG(rfc1867_uploaded_files), Z_STRVAL_P(file_path), Z_STRLEN_P(file_path) + 1);\n            }\n        }\n        SW_HASHTABLE_FOREACH_END();\n    }\n    swoole_set_object(getThis(), NULL);\n}\n\nstatic PHP_METHOD(swoole_http_response, write)\n{\n    zval *zdata;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z\", &zdata) == FAILURE)\n    {\n        return;\n    }\n\n    http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);\n    if (!ctx)\n    {\n        return;\n    }\n\n    if (!ctx->send_header)\n    {\n        ctx->chunk = 1;\n        swString_clear(swoole_http_buffer);\n        http_build_header(ctx, getThis(), swoole_http_buffer, -1 TSRMLS_CC);\n        if (swServer_tcp_send(SwooleG.serv, ctx->fd, swoole_http_buffer->str, swoole_http_buffer->length) < 0)\n        {\n            ctx->chunk = 0;\n            ctx->send_header = 0;\n            RETURN_FALSE;\n        }\n    }\n\n    swString http_body;\n    int length = php_swoole_get_send_data(zdata, &http_body.str TSRMLS_CC);\n\n    if (length < 0)\n    {\n        RETURN_FALSE;\n    }\n    else if (length == 0)\n    {\n       swoole_php_error(E_WARNING, \"data is empty.\");\n        RETURN_FALSE;\n    }\n    else\n    {\n        http_body.length = length;\n    }\n\n    swString_clear(swoole_http_buffer);\n\n    char *hex_string;\n    int hex_len;\n\n#ifdef SW_HAVE_ZLIB\n    if (ctx->gzip_enable)\n    {\n        http_response_compress(&http_body, ctx->gzip_level);\n\n        hex_string = swoole_dec2hex(swoole_zlib_buffer->length, 16);\n        hex_len = strlen(hex_string);\n\n        //\"%*s\\r\\n%*s\\r\\n\", hex_len, hex_string, body.length, body.str\n        swString_append_ptr(swoole_http_buffer, hex_string, hex_len);\n        swString_append_ptr(swoole_http_buffer, SW_STRL(\"\\r\\n\") - 1);\n        swString_append(swoole_http_buffer, swoole_zlib_buffer);\n        swString_append_ptr(swoole_http_buffer, SW_STRL(\"\\r\\n\") - 1);\n    }\n    else\n#endif\n    {\n        hex_string = swoole_dec2hex(http_body.length, 16);\n        hex_len = strlen(hex_string);\n\n        //\"%*s\\r\\n%*s\\r\\n\", hex_len, hex_string, body.length, body.str\n        swString_append_ptr(swoole_http_buffer, hex_string, hex_len);\n        swString_append_ptr(swoole_http_buffer, SW_STRL(\"\\r\\n\") - 1);\n        swString_append_ptr(swoole_http_buffer, http_body.str, http_body.length);\n        swString_append_ptr(swoole_http_buffer, SW_STRL(\"\\r\\n\") - 1);\n    }\n\n    int ret = swServer_tcp_send(SwooleG.serv, ctx->fd, swoole_http_buffer->str, swoole_http_buffer->length);\n    sw_strdup_free(hex_string);\n    SW_CHECK_RETURN(ret);\n}\n\nstatic http_context* http_get_context(zval *object, int check_end TSRMLS_DC)\n{\n    http_context *ctx = swoole_get_object(object);\n    if (!ctx)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Http request is end.\");\n        return NULL;\n    }\n    if (check_end && ctx->end)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Http request is end.\");\n        return NULL;\n    }\n    return ctx;\n}\n\nstatic void http_build_header(http_context *ctx, zval *object, swString *response, int body_length TSRMLS_DC)\n{\n    assert(ctx->send_header == 0);\n\n    char buf[SW_HTTP_HEADER_MAX_SIZE];\n    int n;\n    char *date_str;\n\n    /**\n     * http status line\n     */\n    n = snprintf(buf, sizeof(buf), \"HTTP/1.1 %s\\r\\n\", http_status_message(ctx->response.status));\n    swString_append_ptr(response, buf, n);\n\n    /**\n     * http header\n     */\n    zval *header = ctx->response.zheader;\n    if (header)\n    {\n        int flag = 0x0;\n        char *key_server = \"Server\";\n        char *key_connection = \"Connection\";\n        char *key_content_length = \"Content-Length\";\n        char *key_content_type = \"Content-Type\";\n        char *key_date = \"Date\";\n\n        HashTable *ht = Z_ARRVAL_P(header);\n        zval *value = NULL;\n        char *key = NULL;\n        uint32_t keylen = 0;\n        int type;\n\n        SW_HASHTABLE_FOREACH_START2(ht, key, keylen, type, value)\n        {\n            if (!key)\n            {\n                break;\n            }\n            if (strcmp(key, key_server) == 0)\n            {\n                flag |= HTTP_RESPONSE_SERVER;\n            }\n            else if (strcmp(key, key_connection) == 0)\n            {\n                flag |= HTTP_RESPONSE_CONNECTION;\n            }\n            else if (strcmp(key, key_content_length) == 0)\n            {\n                flag |= HTTP_RESPONSE_CONTENT_LENGTH;\n            }\n            else if (strcmp(key, key_date) == 0)\n            {\n                flag |= HTTP_RESPONSE_DATE;\n            }\n            else if (strcmp(key, key_content_type) == 0)\n            {\n                flag |= HTTP_RESPONSE_CONTENT_TYPE;\n            }\n            n = snprintf(buf, sizeof(buf), \"%*s: %*s\\r\\n\", keylen - 1, key, Z_STRLEN_P(value), Z_STRVAL_P(value));\n            swString_append_ptr(response, buf, n);\n        }\n        SW_HASHTABLE_FOREACH_END();\n\n        if (!(flag & HTTP_RESPONSE_SERVER))\n        {\n            swString_append_ptr(response, ZEND_STRL(\"Server: \"SW_HTTP_SERVER_SOFTWARE\"\\r\\n\"));\n        }\n        if (!(flag & HTTP_RESPONSE_CONNECTION))\n        {\n            if (ctx->keepalive)\n            {\n                swString_append_ptr(response, ZEND_STRL(\"Connection: keep-alive\\r\\n\"));\n            }\n            else\n            {\n                swString_append_ptr(response, ZEND_STRL(\"Connection: close\\r\\n\"));\n            }\n        }\n        if (ctx->request.method == PHP_HTTP_OPTIONS)\n        {\n            swString_append_ptr(response, ZEND_STRL(\"Allow: GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS\\r\\nContent-Length: 0\\r\\n\"));\n        }\n        else\n        {\n            if (!(flag & HTTP_RESPONSE_CONTENT_LENGTH) && body_length >= 0)\n            {\n#ifdef SW_HAVE_ZLIB\n                if (ctx->gzip_enable)\n                {\n                    body_length = swoole_zlib_buffer->length;\n                }\n#endif\n                n = snprintf(buf, sizeof(buf), \"Content-Length: %d\\r\\n\", body_length);\n                swString_append_ptr(response, buf, n);\n            }\n        }\n        if (!(flag & HTTP_RESPONSE_DATE))\n        {\n            date_str = sw_php_format_date(ZEND_STRL(SW_HTTP_DATE_FORMAT), SwooleGS->now, 0 TSRMLS_CC);\n            n = snprintf(buf, sizeof(buf), \"Date: %s\\r\\n\", date_str);\n            swString_append_ptr(response, buf, n);\n            efree(date_str);\n        }\n        if (!(flag & HTTP_RESPONSE_CONTENT_TYPE))\n        {\n            swString_append_ptr(response, ZEND_STRL(\"Content-Type: text/html\\r\\n\"));\n        }\n    }\n    else\n    {\n        swString_append_ptr(response, ZEND_STRL(\"Server: \"SW_HTTP_SERVER_SOFTWARE\"\\r\\nContent-Type: text/html\\r\\n\"));\n        if (ctx->keepalive)\n        {\n            swString_append_ptr(response, ZEND_STRL(\"Connection: keep-alive\\r\\n\"));\n        }\n        else\n        {\n            swString_append_ptr(response, ZEND_STRL(\"Connection: close\\r\\n\"));\n        }\n\n        date_str = sw_php_format_date(ZEND_STRL(SW_HTTP_DATE_FORMAT), SwooleGS->now, 0 TSRMLS_CC);\n        n = snprintf(buf, sizeof(buf), \"Date: %s\\r\\n\", date_str);\n        efree(date_str);\n        swString_append_ptr(response, buf, n);\n\n        if (ctx->request.method == PHP_HTTP_OPTIONS)\n        {\n            n = snprintf(buf, sizeof(buf), \"Allow: GET, POST, PUT, DELETE, HEAD, OPTIONS\\r\\nContent-Length: %d\\r\\n\", 0);\n            swString_append_ptr(response, buf, n);\n        }\n        else if (body_length >= 0)\n        {\n#ifdef SW_HAVE_ZLIB\n            if (ctx->gzip_enable)\n            {\n                body_length = swoole_zlib_buffer->length;\n            }\n#endif\n            n = snprintf(buf, sizeof(buf), \"Content-Length: %d\\r\\n\", body_length);\n            swString_append_ptr(response, buf, n);\n        }\n    }\n\n    if (ctx->chunk)\n    {\n        swString_append_ptr(response, SW_STRL(\"Transfer-Encoding: chunked\\r\\n\") - 1);\n    }\n    //http cookies\n    if (ctx->response.zcookie)\n    {\n        zval *value;\n        SW_HASHTABLE_FOREACH_START(Z_ARRVAL_P(ctx->response.zcookie), value)\n        {\n            if (Z_TYPE_P(value) != IS_STRING)\n            {\n                continue;\n            }\n            swString_append_ptr(response, SW_STRL(\"Set-Cookie: \") - 1);\n            swString_append_ptr(response, Z_STRVAL_P(value), Z_STRLEN_P(value));\n            swString_append_ptr(response, SW_STRL(\"\\r\\n\") - 1);\n        }\n        SW_HASHTABLE_FOREACH_END();\n    }\n    //http compress\n    if (ctx->gzip_enable)\n    {\n#ifdef SW_HTTP_COMPRESS_GZIP\n        swString_append_ptr(response, SW_STRL(\"Content-Encoding: gzip\\r\\n\") - 1);\n#else\n        swString_append_ptr(response, SW_STRL(\"Content-Encoding: deflate\\r\\n\") - 1);\n#endif\n    }\n    swString_append_ptr(response, ZEND_STRL(\"\\r\\n\"));\n    ctx->send_header = 1;\n}\n\n#ifdef SW_HAVE_ZLIB\nstatic int http_response_compress(swString *body, int level)\n{\n    assert(level > 0 || level < 10);\n\n    size_t memory_size = ((size_t) ((double) body->length * (double) 1.015)) + 10 + 8 + 4 + 1;\n\n    if (memory_size > swoole_zlib_buffer->size)\n    {\n        swString_extend(swoole_zlib_buffer, memory_size);\n    }\n\n    z_stream zstream;\n    memset(&zstream, 0, sizeof(zstream));\n\n    //deflate: -0xf, gzip: 0x1f\n#ifdef SW_HTTP_COMPRESS_GZIP\n    int encoding = 0x1f;\n#else\n    int encoding =  -0xf;\n#endif\n\n    int status;\n    if (Z_OK == deflateInit2(&zstream, level, Z_DEFLATED, encoding, MAX_MEM_LEVEL, Z_DEFAULT_STRATEGY))\n    {\n        zstream.next_in = (Bytef *) body->str;\n        zstream.next_out = (Bytef *) swoole_zlib_buffer->str;\n        zstream.avail_in = body->length;\n        zstream.avail_out = swoole_zlib_buffer->size;\n\n        status = deflate(&zstream, Z_FINISH);\n        deflateEnd(&zstream);\n\n        if (Z_STREAM_END == status)\n        {\n            swoole_zlib_buffer->length = zstream.total_out;\n            return SW_OK;\n        }\n    }\n    else\n    {\n        swWarn(\"deflateInit2() failed.\");\n    }\n    return SW_ERR;\n}\n#endif\n\nstatic PHP_METHOD(swoole_http_response, end)\n{\n    zval *zdata = NULL;\n    int ret;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|z\", &zdata) == FAILURE)\n    {\n        return;\n    }\n\n    swString http_body;\n\n    if (zdata)\n    {\n        int length = php_swoole_get_send_data(zdata, &http_body.str TSRMLS_CC);\n\n        if (length < 0)\n        {\n            RETURN_FALSE;\n        }\n        else\n        {\n            http_body.length = length;\n        }\n    }\n    else\n    {\n        http_body.length = 0;\n        http_body.str = NULL;\n    }\n\n    http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);\n    if (!ctx)\n    {\n        RETURN_FALSE;\n    }\n\n#ifdef SW_USE_HTTP2\n    if (ctx->http2)\n    {\n        swoole_http2_do_response(ctx, &http_body);\n        RETURN_TRUE;\n    }\n#endif\n\n    if (ctx->chunk)\n    {\n        ret = swServer_tcp_send(SwooleG.serv, ctx->fd, SW_STRL(\"0\\r\\n\\r\\n\") - 1);\n        if (ret < 0)\n        {\n            RETURN_FALSE;\n        }\n        ctx->chunk = 0;\n    }\n    //no http chunk\n    else\n    {\n        swString_clear(swoole_http_buffer);\n#ifdef SW_HAVE_ZLIB\n        if (ctx->gzip_enable)\n        {\n            if (http_body.length > 0)\n            {\n                http_response_compress(&http_body, ctx->gzip_level);\n            }\n            else\n            {\n                ctx->gzip_enable = 0;\n            }\n        }\n#endif\n        http_build_header(ctx, getThis(), swoole_http_buffer, http_body.length TSRMLS_CC);\n        if (http_body.length > 0)\n        {\n#ifdef SW_HAVE_ZLIB\n            if (ctx->gzip_enable)\n            {\n                swString_append(swoole_http_buffer, swoole_zlib_buffer);\n            }\n            else\n#endif\n            {\n                swString_append(swoole_http_buffer, &http_body);\n            }\n        }\n\n        ret = swServer_tcp_send(SwooleG.serv, ctx->fd, swoole_http_buffer->str, swoole_http_buffer->length);\n        if (ret < 0)\n        {\n            ctx->send_header = 0;\n            RETURN_FALSE;\n        }\n    }\n    if (!ctx->keepalive)\n    {\n        SwooleG.serv->factory.end(&SwooleG.serv->factory, ctx->fd);\n    }\n    swoole_http_context_free(ctx TSRMLS_CC);\n    RETURN_TRUE;\n}\n\nstatic PHP_METHOD(swoole_http_response, sendfile)\n{\n    char *filename;\n    zend_size_t filename_length;\n    int ret;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &filename, &filename_length) == FAILURE)\n    {\n        return;\n    }\n\n    if (filename_length <= 0)\n    {\n        swoole_php_error(E_WARNING, \"file name is empty.\");\n        RETURN_FALSE;\n    }\n\n    http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);\n    if (!ctx)\n    {\n        RETURN_FALSE;\n    }\n\n    if (ctx->chunk)\n    {\n        swoole_php_error(E_WARNING, \"cannot use HTTP-Chunk.\");\n        RETURN_FALSE;\n    }\n\n    int file_fd = open(filename, O_RDONLY);\n    if (file_fd < 0)\n    {\n        swoole_php_sys_error(E_WARNING, \"open(%s) failed.\", filename);\n        RETURN_FALSE;\n    }\n\n    struct stat file_stat;\n    if (fstat(file_fd, &file_stat) < 0)\n    {\n        swoole_php_sys_error(E_WARNING, \"fstat(%s) failed.\", filename);\n        RETURN_FALSE;\n    }\n\n    if (file_stat.st_size <= 0)\n    {\n        swoole_php_error(E_WARNING, \"file is empty.\");\n        RETURN_FALSE;\n    }\n\n    swString_clear(swoole_http_buffer);\n    http_build_header(ctx, getThis(), swoole_http_buffer, file_stat.st_size TSRMLS_CC);\n\n    ret = swServer_tcp_send(SwooleG.serv, ctx->fd, swoole_http_buffer->str, swoole_http_buffer->length);\n    if (ret < 0)\n    {\n        ctx->send_header = 0;\n        RETURN_FALSE;\n    }\n\n    ret = swServer_tcp_sendfile(SwooleG.serv, ctx->fd, filename, filename_length);\n    if (ret < 0)\n    {\n        ctx->send_header = 0;\n        RETURN_FALSE;\n    }\n    if (!ctx->keepalive)\n    {\n        SwooleG.serv->factory.end(&SwooleG.serv->factory, ctx->fd);\n    }\n    swoole_http_context_free(ctx TSRMLS_CC);\n    RETURN_TRUE;\n}\n\nstatic PHP_METHOD(swoole_http_response, cookie)\n{\n    char *name, *value = NULL, *path = NULL, *domain = NULL;\n    long expires = 0;\n    int encode = 1;\n    zend_bool secure = 0, httponly = 0;\n    zend_size_t name_len, value_len = 0, path_len = 0, domain_len = 0;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|slssbb\", &name, &name_len, &value, &value_len, &expires,\n                &path, &path_len, &domain, &domain_len, &secure, &httponly) == FAILURE)\n    {\n        return;\n    }\n\n    http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);\n    if (!ctx)\n    {\n        RETURN_FALSE;\n    }\n\n    zval *zcookie = ctx->response.zcookie;\n    zval *zresponse_object = ctx->response.zobject;\n    if (!zcookie)\n    {\n        swoole_http_server_array_init(cookie, response);\n    }\n\n    char *cookie, *encoded_value = NULL;\n    int len = 0;\n    char *dt;\n\n    if (name && strpbrk(name, \"=,; \\t\\r\\n\\013\\014\") != NULL)\n    {\n        swoole_php_error(E_WARNING, \"Cookie names cannot contain any of the following '=,; \\\\t\\\\r\\\\n\\\\013\\\\014'\");\n        RETURN_FALSE;\n    }\n\n    len += name_len;\n    if (encode && value)\n    {\n        int encoded_value_len;\n        encoded_value = sw_php_url_encode(value, value_len, &encoded_value_len);\n        len += encoded_value_len;\n    }\n    else if (value)\n    {\n        encoded_value = estrdup(value);\n        len += value_len;\n    }\n    if (path)\n    {\n        len += path_len;\n    }\n    if (domain)\n    {\n        len += domain_len;\n    }\n\n    cookie = emalloc(len + 100);\n\n    if (value && value_len == 0)\n    {\n        dt = sw_php_format_date(\"D, d-M-Y H:i:s T\", sizeof(\"D, d-M-Y H:i:s T\") - 1, 1, 0 TSRMLS_CC);\n        snprintf(cookie, len + 100, \"%s=deleted; expires=%s\", name, dt);\n        efree(dt);\n    }\n    else\n    {\n        snprintf(cookie, len + 100, \"%s=%s\", name, value ? encoded_value : \"\");\n        if (expires > 0)\n        {\n            const char *p;\n            strlcat(cookie, \"; expires=\", len + 100);\n            dt = sw_php_format_date(\"D, d-M-Y H:i:s T\", sizeof(\"D, d-M-Y H:i:s T\") - 1, expires, 0 TSRMLS_CC);\n            p = zend_memrchr(dt, '-', strlen(dt));\n            if (!p || *(p + 5) != ' ')\n            {\n                efree(dt);\n                efree(cookie);\n                efree(encoded_value);\n                swoole_php_error(E_WARNING, \"Expiry date cannot have a year greater than 9999\");\n                RETURN_FALSE;\n            }\n            strlcat(cookie, dt, len + 100);\n            efree(dt);\n        }\n    }\n    if (encoded_value)\n    {\n        efree(encoded_value);\n    }\n    if (path && path_len > 0)\n    {\n        strlcat(cookie, \"; path=\", len + 100);\n        strlcat(cookie, path, len + 100);\n    }\n    if (domain && domain_len > 0)\n    {\n        strlcat(cookie, \"; domain=\", len + 100);\n        strlcat(cookie, domain, len + 100);\n    }\n    if (secure)\n    {\n        strlcat(cookie, \"; secure\", len + 100);\n    }\n    if (httponly)\n    {\n        strlcat(cookie, \"; httponly\", len + 100);\n    }\n    sw_add_next_index_stringl(zcookie, cookie, strlen(cookie), 0);\n#if PHP_MAJOR_VERSION >= 7\n    efree(cookie);\n#endif\n}\n\nstatic PHP_METHOD(swoole_http_response, rawcookie)\n{\n    char *name, *value = NULL, *path = NULL, *domain = NULL;\n    long expires = 0;\n    int encode = 0;\n    zend_bool secure = 0, httponly = 0;\n    zend_size_t name_len, value_len = 0, path_len = 0, domain_len = 0;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|slssbb\", &name, &name_len, &value, &value_len, &expires,\n                &path, &path_len, &domain, &domain_len, &secure, &httponly) == FAILURE)\n    {\n        return;\n    }\n\n    http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);\n    if (!ctx)\n    {\n        RETURN_FALSE;\n    }\n\n    zval *zcookie = ctx->response.zcookie;\n    zval *zresponse_object = ctx->response.zobject;\n    if (!zcookie)\n    {\n        swoole_http_server_array_init(cookie, response);\n    }\n\n    char *cookie, *encoded_value = NULL;\n    int len = 0;\n    char *dt;\n\n    if (name && strpbrk(name, \"=,; \\t\\r\\n\\013\\014\") != NULL)\n    {\n        swoole_php_error(E_WARNING, \"Cookie names cannot contain any of the following '=,; \\\\t\\\\r\\\\n\\\\013\\\\014'\");\n        RETURN_FALSE;\n    }\n\n    len += name_len;\n    if (encode && value)\n    {\n        int encoded_value_len;\n        encoded_value = sw_php_url_encode(value, value_len, &encoded_value_len);\n        len += encoded_value_len;\n    }\n    else if (value)\n    {\n        encoded_value = estrdup(value);\n        len += value_len;\n    }\n    if (path)\n    {\n        len += path_len;\n    }\n    if (domain)\n    {\n        len += domain_len;\n    }\n\n    cookie = emalloc(len + 100);\n\n    if (value && value_len == 0)\n    {\n        dt = sw_php_format_date(\"D, d-M-Y H:i:s T\", sizeof(\"D, d-M-Y H:i:s T\") - 1, 1, 0 TSRMLS_CC);\n        snprintf(cookie, len + 100, \"%s=deleted; expires=%s\", name, dt);\n        efree(dt);\n    }\n    else\n    {\n        snprintf(cookie, len + 100, \"%s=%s\", name, value ? encoded_value : \"\");\n        if (expires > 0)\n        {\n            const char *p;\n            strlcat(cookie, \"; expires=\", len + 100);\n            dt = sw_php_format_date(\"D, d-M-Y H:i:s T\", sizeof(\"D, d-M-Y H:i:s T\") - 1, expires, 0 TSRMLS_CC);\n            p = zend_memrchr(dt, '-', strlen(dt));\n            if (!p || *(p + 5) != ' ')\n            {\n                efree(dt);\n                efree(cookie);\n                efree(encoded_value);\n                swoole_php_error(E_WARNING, \"Expiry date cannot have a year greater than 9999\");\n                RETURN_FALSE;\n            }\n            strlcat(cookie, dt, len + 100);\n            efree(dt);\n        }\n    }\n    if (encoded_value)\n    {\n        efree(encoded_value);\n    }\n    if (path && path_len > 0)\n    {\n        strlcat(cookie, \"; path=\", len + 100);\n        strlcat(cookie, path, len + 100);\n    }\n    if (domain && domain_len > 0)\n    {\n        strlcat(cookie, \"; domain=\", len + 100);\n        strlcat(cookie, domain, len + 100);\n    }\n    if (secure)\n    {\n        strlcat(cookie, \"; secure\", len + 100);\n    }\n    if (httponly)\n    {\n        strlcat(cookie, \"; httponly\", len + 100);\n    }\n    sw_add_next_index_stringl(zcookie, cookie, strlen(cookie), 0);\n#if PHP_MAJOR_VERSION >= 7\n    efree(cookie);\n#endif\n}\n\nstatic PHP_METHOD(swoole_http_response, status)\n{\n    long http_status;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &http_status) == FAILURE)\n    {\n        return;\n    }\n\n    http_context *client = http_get_context(getThis(), 0 TSRMLS_CC);\n    if (!client)\n    {\n        RETURN_FALSE;\n    }\n\n    client->response.status = http_status;\n}\n\nstatic PHP_METHOD(swoole_http_response, header)\n{\n    char *k, *v;\n    zend_size_t klen, vlen;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ss\", &k, &klen, &v, &vlen) == FAILURE)\n    {\n        return;\n    }\n\n    http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);\n    if (!ctx)\n    {\n        RETURN_FALSE;\n    }\n\n    zval *zheader = ctx->response.zheader;\n    zval *zresponse_object = ctx->response.zobject;\n    if (!zheader)\n    {\n        swoole_http_server_array_init(header, response);\n    }\n    if (klen > SW_HTTP_HEADER_KEY_SIZE - 1)\n    {\n        swoole_php_error(E_WARNING, \"header key is too long.\");\n        RETURN_FALSE;\n    }\n    if (vlen > SW_HTTP_HEADER_VALUE_SIZE)\n    {\n        swoole_php_error(E_WARNING, \"header key is too long.\");\n        RETURN_FALSE;\n    }\n    char key_buf[SW_HTTP_HEADER_KEY_SIZE];\n    memcpy(key_buf, k, klen);\n    key_buf[klen] = '\\0';\n    if (ctx->http2)\n    {\n        swoole_strtolower(key_buf, klen);\n    }\n    else\n    {\n        http_header_key_format(key_buf, klen);\n    }\n    sw_add_assoc_stringl_ex(zheader, key_buf, klen + 1, v, vlen, 1);\n}\n\n#ifdef SW_HAVE_ZLIB\nstatic PHP_METHOD(swoole_http_response, gzip)\n{\n    long level = Z_DEFAULT_COMPRESSION;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|l\", &level) == FAILURE)\n    {\n        return;\n    }\n\n    http_context *context = http_get_context(getThis(), 0 TSRMLS_CC);\n    if (!context)\n    {\n        RETURN_FALSE;\n    }\n\n    if (context->send_header)\n    {\n        swoole_php_fatal_error(E_WARNING, \"must use before send header.\");\n        RETURN_FALSE;\n    }\n\n    if (level > 9)\n    {\n        level = 9;\n    }\n    if (level < 0)\n    {\n        level = 0;\n    }\n\n    context->gzip_enable = 1;\n    context->gzip_level = level;\n}\n#endif\n\nstatic PHP_METHOD(swoole_http_response, __destruct)\n{\n    http_context *context = swoole_get_object(getThis());\n    if (context)\n    {\n        zval *zobject = getThis();\n        zval *retval = NULL;\n        sw_zend_call_method_with_0_params(&zobject, swoole_http_response_class_entry_ptr, NULL, \"end\", &retval);\n        if (retval)\n        {\n            sw_zval_ptr_dtor(&retval);\n        }\n    }\n}",
        "res_region": "/*\n  +----------------------------------------------------------------------+\n  | Swoole                                                               |\n  +----------------------------------------------------------------------+\n  | This source file is subject to version 2.0 of the Apache license,    |\n  | that is bundled with this package in the file LICENSE, and is        |\n  | available through the world-wide-web at the following url:           |\n  | http://www.apache.org/licenses/LICENSE-2.0.html                      |\n  | If you did not receive a copy of the Apache2.0 license and are unable|\n  | to obtain it through the world-wide-web, please send a note to       |\n  | license@swoole.com so we can mail you a copy immediately.            |\n  +----------------------------------------------------------------------+\n  | Author: Tianfeng Han  <mikan.tenny@gmail.com>                        |\n  +----------------------------------------------------------------------+\n*/\n\n#include \"php_swoole.h\"\n#include \"swoole_http.h\"\n#ifdef SW_COROUTINE\n#include \"swoole_coroutine.h\"\n#endif\n\n#include <ext/standard/url.h>\n#include <ext/standard/sha1.h>\n#include <ext/standard/php_var.h>\n#include <ext/standard/php_string.h>\n#include <ext/standard/php_math.h>\n#include <ext/standard/php_array.h>\n#include <ext/date/php_date.h>\n#include <ext/standard/md5.h>\n\n#include <main/rfc1867.h>\n#include <main/php_variables.h>\n\n#include \"websocket.h\"\n#include \"Connection.h\"\n#include \"base64.h\"\n\n#ifdef SW_HAVE_ZLIB\n#include <zlib.h>\n#endif\n\n#ifdef SW_USE_HTTP2\n#include \"http2.h\"\n#include <nghttp2/nghttp2.h>\n#endif\n\nstatic swArray *http_client_array;\n\nswString *swoole_http_buffer;\nswString *swoole_zlib_buffer;\nswString *swoole_http_form_data_buffer;\n\nenum http_global_flag\n{\n    HTTP_GLOBAL_GET       = 1u << 1,\n    HTTP_GLOBAL_POST      = 1u << 2,\n    HTTP_GLOBAL_COOKIE    = 1u << 3,\n    HTTP_GLOBAL_REQUEST   = 1u << 4,\n    HTTP_GLOBAL_SERVER    = 1u << 5,\n    HTTP_GLOBAL_FILES     = 1u << 6,\n};\n\nenum http_upload_errno\n{\n    HTTP_UPLOAD_ERR_OK = 0,\n    HTTP_UPLOAD_ERR_INI_SIZE,\n    HTTP_UPLOAD_ERR_FORM_SIZE,\n    HTTP_UPLOAD_ERR_PARTIAL,\n    HTTP_UPLOAD_ERR_NO_FILE,\n    HTTP_UPLOAD_ERR_NO_TMP_DIR = 6,\n    HTTP_UPLOAD_ERR_CANT_WRITE,\n};\n\nzend_class_entry swoole_http_server_ce;\nzend_class_entry *swoole_http_server_class_entry_ptr;\n\nzend_class_entry swoole_http_response_ce;\nzend_class_entry *swoole_http_response_class_entry_ptr;\n\nzend_class_entry swoole_http_request_ce;\nzend_class_entry *swoole_http_request_class_entry_ptr;\n\nstatic int http_onReceive(swServer *serv, swEventData *req);\n\nstatic int http_request_on_path(php_http_parser *parser, const char *at, size_t length);\nstatic int http_request_on_query_string(php_http_parser *parser, const char *at, size_t length);\nstatic int http_request_on_body(php_http_parser *parser, const char *at, size_t length);\nstatic int http_request_on_header_field(php_http_parser *parser, const char *at, size_t length);\nstatic int http_request_on_header_value(php_http_parser *parser, const char *at, size_t length);\nstatic int http_request_on_headers_complete(php_http_parser *parser);\nstatic int http_request_message_complete(php_http_parser *parser);\n\nstatic int multipart_body_on_header_field(multipart_parser* p, const char *at, size_t length);\nstatic int multipart_body_on_header_value(multipart_parser* p, const char *at, size_t length);\nstatic int multipart_body_on_data(multipart_parser* p, const char *at, size_t length);\nstatic int multipart_body_on_header_complete(multipart_parser* p);\nstatic int multipart_body_on_data_end(multipart_parser* p);\nstatic int multipart_body_end(multipart_parser* p);\n\nstatic http_context* http_get_context(zval *object, int check_end TSRMLS_DC);\n\nstatic void http_parse_cookie(zval *array, const char *at, size_t length);\nstatic void http_build_header(http_context *, zval *object, swString *response, int body_length TSRMLS_DC);\nstatic int http_trim_double_quote(zval **value, char **ptr);\n\nstatic inline void http_header_key_format(char *key, int length)\n{\n    int i, state = 0;\n    for (i = 0; i < length; i++)\n    {\n        if (state == 0)\n        {\n            if (key[i] >= 97 && key[i] <= 122)\n            {\n                key[i] -= 32;\n            }\n            state = 1;\n        }\n        else if (key[i] == '-')\n        {\n            state = 0;\n        }\n        else\n        {\n            if (key[i] >= 65 && key[i] <= 90)\n            {\n                key[i] += 32;\n            }\n        }\n    }\n}\n\n#ifdef SW_HAVE_ZLIB\nstatic int http_response_compress(swString *body, int level);\n#endif\n\nstatic PHP_METHOD(swoole_http_server, on);\nstatic PHP_METHOD(swoole_http_server, start);\n\nstatic PHP_METHOD(swoole_http_request, rawcontent);\nstatic PHP_METHOD(swoole_http_request, __destruct);\n\nstatic PHP_METHOD(swoole_http_response, write);\nstatic PHP_METHOD(swoole_http_response, end);\nstatic PHP_METHOD(swoole_http_response, sendfile);\nstatic PHP_METHOD(swoole_http_response, cookie);\nstatic PHP_METHOD(swoole_http_response, rawcookie);\nstatic PHP_METHOD(swoole_http_response, header);\n#ifdef SW_HAVE_ZLIB\nstatic PHP_METHOD(swoole_http_response, gzip);\n#endif\nstatic PHP_METHOD(swoole_http_response, status);\nstatic PHP_METHOD(swoole_http_response, __destruct);\n\nstatic sw_inline char* http_get_method_name(int method)\n{\n    switch (method)\n    {\n    case PHP_HTTP_GET:\n        return \"GET\";\n    case PHP_HTTP_POST:\n        return \"POST\";\n    case PHP_HTTP_HEAD:\n        return \"HEAD\";\n    case PHP_HTTP_PUT:\n        return \"PUT\";\n    case PHP_HTTP_DELETE:\n        return \"DELETE\";\n    case PHP_HTTP_PATCH:\n        return \"PATCH\";\n    case PHP_HTTP_CONNECT:\n        return \"CONNECT\";\n    case PHP_HTTP_OPTIONS:\n        return \"OPTIONS\";\n    case PHP_HTTP_TRACE:\n        return \"TRACE\";\n    case PHP_HTTP_COPY:\n        return \"COPY\";\n    case PHP_HTTP_LOCK:\n        return \"LOCK\";\n    case PHP_HTTP_MKCOL:\n        return \"MKCOL\";\n    case PHP_HTTP_MOVE:\n        return \"MOVE\";\n    case PHP_HTTP_PROPFIND:\n        return \"PROPFIND\";\n    case PHP_HTTP_PROPPATCH:\n        return \"PROPPATCH\";\n    case PHP_HTTP_UNLOCK:\n        return \"UNLOCK\";\n        /* subversion */\n    case PHP_HTTP_REPORT:\n        return \"REPORT\";\n    case PHP_HTTP_MKACTIVITY:\n        return \"MKACTIVITY\";\n    case PHP_HTTP_CHECKOUT:\n        return \"CHECKOUT\";\n    case PHP_HTTP_MERGE:\n        return \"MERGE\";\n        /* upnp */\n    case PHP_HTTP_MSEARCH:\n        return \"MSEARCH\";\n    case PHP_HTTP_NOTIFY:\n        return \"NOTIFY\";\n    case PHP_HTTP_SUBSCRIBE:\n        return \"SUBSCRIBE\";\n    case PHP_HTTP_UNSUBSCRIBE:\n        return \"UNSUBSCRIBE\";\n    case PHP_HTTP_NOT_IMPLEMENTED:\n        return \"IMPLEMENTED\";\n    default:\n        return NULL;\n    }\n}\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_http_server_on, 0, 0, 2)\n    ZEND_ARG_INFO(0, ha_name)\n    ZEND_ARG_INFO(0, cb)\nZEND_END_ARG_INFO()\n\nstatic const php_http_parser_settings http_parser_settings =\n{\n    NULL,\n    http_request_on_path,\n    http_request_on_query_string,\n    NULL,\n    NULL,\n    http_request_on_header_field,\n    http_request_on_header_value,\n    http_request_on_headers_complete,\n    http_request_on_body,\n    http_request_message_complete\n};\n\nstatic const multipart_parser_settings mt_parser_settings = \n{\n    multipart_body_on_header_field,\n    multipart_body_on_header_value,\n    multipart_body_on_data,\n    NULL,\n    multipart_body_on_header_complete,\n    multipart_body_on_data_end,\n    multipart_body_end\n};\n\nconst zend_function_entry swoole_http_server_methods[] =\n{\n    PHP_ME(swoole_http_server, on,         arginfo_swoole_http_server_on, ZEND_ACC_PUBLIC)\n    PHP_ME(swoole_http_server, start,      NULL, ZEND_ACC_PUBLIC)\n    PHP_FE_END\n};\n\nconst zend_function_entry swoole_http_request_methods[] =\n{\n    PHP_ME(swoole_http_request, rawcontent, NULL, ZEND_ACC_PUBLIC)\n    PHP_ME(swoole_http_request, __destruct, NULL, ZEND_ACC_PUBLIC | ZEND_ACC_DTOR)\n    PHP_FE_END\n};\n\nconst zend_function_entry swoole_http_response_methods[] =\n{\n    PHP_ME(swoole_http_response, cookie, NULL, ZEND_ACC_PUBLIC)\n    PHP_ME(swoole_http_response, rawcookie, NULL, ZEND_ACC_PUBLIC)\n    PHP_ME(swoole_http_response, status, NULL, ZEND_ACC_PUBLIC)\n#ifdef SW_HAVE_ZLIB\n    PHP_ME(swoole_http_response, gzip, NULL, ZEND_ACC_PUBLIC)\n#endif\n    PHP_ME(swoole_http_response, header, NULL, ZEND_ACC_PUBLIC)\n    PHP_ME(swoole_http_response, write, NULL, ZEND_ACC_PUBLIC)\n    PHP_ME(swoole_http_response, end, NULL, ZEND_ACC_PUBLIC)\n    PHP_ME(swoole_http_response, sendfile, NULL, ZEND_ACC_PUBLIC)\n    PHP_ME(swoole_http_response, __destruct, NULL, ZEND_ACC_PUBLIC | ZEND_ACC_DTOR)\n    PHP_FE_END\n};\n\nstatic int http_request_on_path(php_http_parser *parser, const char *at, size_t length)\n{\n    http_context *ctx = parser->data;\n    ctx->request.path = estrndup(at, length);\n    ctx->request.path_len = length;\n    return 0;\n}\n\nstatic int http_request_on_query_string(php_http_parser *parser, const char *at, size_t length)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n    http_context *ctx = parser->data;\n\n    //no need free, will free by treat_data\n    char *query = estrndup(at, length);\n    sw_add_assoc_stringl_ex(ctx->request.zserver, ZEND_STRS(\"query_string\"), query, length, 1);\n\n    zval *zrequest_object = ctx->request.zobject;\n    zval *zget;\n    swoole_http_server_array_init(get, request);\n\n    //parse url params\n    sapi_module.treat_data(PARSE_STRING, query, zget TSRMLS_CC);\n\n    return 0;\n}\n\nstatic int http_request_on_header_field(php_http_parser *parser, const char *at, size_t length)\n{\n    http_context *ctx = parser->data;\n    if (ctx->current_header_name_allocated)\n    {\n        efree(ctx->current_header_name);\n        ctx->current_header_name_allocated = 0;\n    }\n    ctx->current_header_name = (char *) at;\n    ctx->current_header_name_len = length;\n    return 0;\n}\n\nint swoole_http_parse_form_data(http_context *ctx, const char *boundary_str, int boundary_len TSRMLS_DC)\n{\n    multipart_parser *mt_parser = multipart_parser_init(boundary_str, boundary_len, &mt_parser_settings);\n    if (!mt_parser)\n    {\n        swoole_php_fatal_error(E_WARNING, \"multipart_parser_init() failed.\");\n        return SW_ERR;\n    }\n\n    ctx->mt_parser = mt_parser;\n    mt_parser->data = ctx;\n\n    return SW_OK;\n}\n\nstatic void http_parse_cookie(zval *array, const char *at, size_t length)\n{\n    char keybuf[SW_HTTP_COOKIE_KEYLEN];\n    char valbuf[SW_HTTP_COOKIE_VALLEN];\n    char *_c = (char *) at;\n\n    int klen = 0;\n    int vlen = 0;\n    int state = -1;\n\t\n    int i = 0, j = 0;\n    while (_c < at + length)\n    {\n        if (state <= 0 && *_c == '=')\n        {\n            klen = i - j + 1;\n            if (klen >= SW_HTTP_COOKIE_KEYLEN)\n            {\n                swWarn(\"cookie key is too large.\");\n                return;\n            }\n            memcpy(keybuf, at + j, klen - 1);\n            keybuf[klen - 1] = 0;\n\n            j = i + 1;\n            state = 1;\n        }\n        else if (state == 1 && *_c == ';')\n        {\n            vlen = i - j;\n            strncpy(valbuf, (char * ) at + j, SW_HTTP_COOKIE_VALLEN);\n            vlen = php_url_decode(valbuf, vlen);\n            if (klen > 1)\n            {\n                sw_add_assoc_stringl_ex(array, keybuf, klen, valbuf, vlen, 1);\n            }\n            j = i + 1;\n            state = -1;\n        }\n        else if (state < 0)\n        {\n            if (isspace(*_c))\n            {\n                //Remove leading spaces from cookie names \n                ++j;\n            } \n            else\n            {\n                state = 0;\n            }\n        }\n        _c++;\n        i++;\n    }\n    if (j < length)\n    {\n        vlen = i - j;\n        keybuf[klen - 1] = 0;\n        strncpy(valbuf, (char * ) at + j, SW_HTTP_COOKIE_VALLEN);\n        vlen = php_url_decode(valbuf, vlen);\n        if (klen > 1)\n        {\n            sw_add_assoc_stringl_ex(array, keybuf, klen, valbuf, vlen, 1);\n        }\n    }\n}\n\nstatic int http_trim_double_quote(zval **value, char **ptr)\n{\n    int len = Z_STRLEN_PP(value);\n    *ptr = Z_STRVAL_PP(value);\n\n    //ltrim('\"')\n    if ((*ptr)[0] == '\"')\n    {\n        (*ptr)++;\n        len--;\n    }\n    //rtrim('\"')\n    if ((*ptr)[len - 1] == '\"')\n    {\n        len--;\n    }\n    return len;\n}\n\nstatic int http_request_on_header_value(php_http_parser *parser, const char *at, size_t length)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    http_context *ctx = parser->data;\n    zval *zrequest_object = ctx->request.zobject;\n    char *header_name = zend_str_tolower_dup(ctx->current_header_name, ctx->current_header_name_len);\n\n    if (strncasecmp(header_name, \"cookie\", ctx->current_header_name_len) == 0)\n    {\n        zval *zcookie;\n        if (length >= SW_HTTP_COOKIE_VALLEN)\n        {\n            swWarn(\"cookie is too large.\");\n        }\n        else\n        {\n            swoole_http_server_array_init(cookie, request);\n            http_parse_cookie(zcookie, at, length);\n        }\n        goto free_memory;\n    }\n    else if (SwooleG.serv->listen_list->open_websocket_protocol && strncasecmp(header_name, ZEND_STRL(\"upgrade\")) == 0 && strncasecmp(at, ZEND_STRL(\"websocket\")) == 0)\n    {\n        swConnection *conn = swWorker_get_connection(SwooleG.serv, ctx->fd);\n        if (!conn)\n        {\n            swWarn(\"connection[%d] is closed.\", ctx->fd);\n            return SW_ERR;\n        }\n        conn->websocket_status = WEBSOCKET_STATUS_CONNECTION;\n    }\n    else if (parser->method == PHP_HTTP_POST || parser->method == PHP_HTTP_PUT || parser->method == PHP_HTTP_DELETE || parser->method == PHP_HTTP_PATCH)\n    {\n        if (memcmp(header_name, ZEND_STRL(\"content-type\")) == 0)\n        {\n            if (strncasecmp(at, ZEND_STRL(\"application/x-www-form-urlencoded\")) == 0)\n            {\n                ctx->request.post_form_urlencoded = 1;\n            }\n            else if (memcmp(header_name, ZEND_STRL(\"content-type\")) == 0 && strncasecmp(at, ZEND_STRL(\"multipart/form-data\")) == 0)\n            {\n                int boundary_len = length - strlen(\"multipart/form-data; boundary=\");\n                if (boundary_len <= 0)\n                {\n                    swWarn(\"invalid multipart/form-data body.\", ctx->fd);\n                    return 0;\n                }\n                swoole_http_parse_form_data(ctx, at + length - boundary_len, boundary_len TSRMLS_CC);\n            }\n        }\n    }\n\n    zval *header = ctx->request.zheader;\n    sw_add_assoc_stringl_ex(header, header_name, ctx->current_header_name_len + 1, (char *) at, length, 1);\n\n    free_memory:\n    if (ctx->current_header_name_allocated)\n    {\n        efree(ctx->current_header_name);\n        ctx->current_header_name_allocated = 0;\n    }\n    efree(header_name);\n\n    return 0;\n}\n\nstatic int http_request_on_headers_complete(php_http_parser *parser)\n{\n    http_context *ctx = parser->data;\n    if (ctx->current_header_name_allocated)\n    {\n        efree(ctx->current_header_name);\n        ctx->current_header_name_allocated = 0;\n    }\n    ctx->current_header_name = NULL;\n\n    return 0;\n}\n\nstatic int multipart_body_on_header_field(multipart_parser* p, const char *at, size_t length)\n{\n    http_context *ctx = p->data;\n    return http_request_on_header_field(&ctx->parser, at, length);\n}\n\nstatic int multipart_body_on_header_value(multipart_parser* p, const char *at, size_t length)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    http_context *ctx = p->data;\n    zval *zrequest_object = ctx->request.zobject;\n    zval *zfiles = ctx->request.zfiles;\n    if (!zfiles)\n    {\n        swoole_http_server_array_init(files, request);\n    }\n\n    char *headername = zend_str_tolower_dup(ctx->current_header_name, ctx->current_header_name_len);\n\n    if (strncasecmp(headername, ZEND_STRL(\"content-disposition\")) == 0)\n    {\n        //not form data\n        if (swoole_strnpos((char *) at, length, ZEND_STRL(\"form-data;\")) < 0)\n        {\n            return SW_OK;\n        }\n\n        zval *tmp_array;\n        SW_MAKE_STD_ZVAL(tmp_array);\n        array_init(tmp_array);\n        http_parse_cookie(tmp_array, (char *) at + sizeof(\"form-data;\"), length - sizeof(\"form-data;\"));\n\n        zval *form_name;\n        if (sw_zend_hash_find(Z_ARRVAL_P(tmp_array), ZEND_STRS(\"name\"), (void **) &form_name) == FAILURE)\n        {\n            return SW_OK;\n        }\n\n        char *str;\n        int len = http_trim_double_quote(&form_name, &str);\n\n        zval *filename;\n        //POST form data\n        if (sw_zend_hash_find(Z_ARRVAL_P(tmp_array), ZEND_STRS(\"filename\"), (void **) &filename) == FAILURE)\n        {\n            ctx->current_form_data_name = estrndup(str, len);\n            ctx->current_form_data_name_len = len;\n        }\n        //upload file\n        else\n        {\n            ctx->current_input_name = estrndup(str, len);\n\n            zval *multipart_header;\n            SW_MAKE_STD_ZVAL(multipart_header);\n            array_init(multipart_header);\n            add_assoc_zval(zfiles, ctx->current_input_name, multipart_header);\n\n            sw_add_assoc_string(multipart_header, \"name\", \"\", 1);\n            sw_add_assoc_string(multipart_header, \"type\", \"\", 1);\n            sw_add_assoc_string(multipart_header, \"tmp_name\", \"\", 1);\n            add_assoc_long(multipart_header, \"error\", HTTP_UPLOAD_ERR_OK);\n            add_assoc_long(multipart_header, \"size\", 0);\n\n            len = http_trim_double_quote(&filename, &str);\n            sw_add_assoc_stringl(multipart_header, \"name\", str, len, 1);\n        }\n        sw_zval_ptr_dtor(&tmp_array);\n    }\n\n    if (strncasecmp(headername, ZEND_STRL(\"content-type\")) == 0)\n    {\n        zval *multipart_header = NULL;\n        sw_zend_hash_find(Z_ARRVAL_P(zfiles), ctx->current_input_name, strlen(ctx->current_input_name) + 1, (void **) &multipart_header);\n        sw_add_assoc_stringl(multipart_header, \"type\", (char * ) at, length, 1);\n    }\n\n    if (ctx->current_header_name_allocated)\n    {\n        efree(ctx->current_header_name);\n        ctx->current_header_name_allocated = 0;\n    }\n    efree(headername);\n\n    return 0;\n}\n\nstatic int multipart_body_on_data(multipart_parser* p, const char *at, size_t length)\n{\n    http_context *ctx = p->data;\n    if (ctx->current_form_data_name)\n    {\n        swString_append_ptr(swoole_http_form_data_buffer, (char*) at, length);\n        return 0;\n    }\n    if (p->fp == NULL)\n    {\n        return 0;\n    }\n    int n = fwrite(at, sizeof(char), length, (FILE *) p->fp);\n    if (n != length)\n    {\n        zval *files = ctx->request.zfiles;\n        zval *multipart_header = NULL;\n        sw_zend_hash_find(Z_ARRVAL_P(files), ctx->current_input_name, strlen(ctx->current_input_name) + 1, (void **) &multipart_header);\n        add_assoc_long(multipart_header, \"error\", HTTP_UPLOAD_ERR_CANT_WRITE);\n\n        fclose((FILE *) p->fp);\n        p->fp = NULL;\n\n        swWarn(\"write upload file failed. Error %s[%d]\", strerror(errno), errno);\n    }\n    return 0;\n}\n\n#if 0\nstatic void get_random_file_name(char *des, const char *src)\n{\n    unsigned char digest[16] = {0};\n    char buf[19] = {0};\n    int n = sprintf(buf, \"%s%d\", src, swoole_system_random(0, 9999));\n\n    PHP_MD5_CTX ctx;\n    PHP_MD5Init(&ctx);\n    PHP_MD5Update(&ctx, buf, n);\n    PHP_MD5Final(digest, &ctx);\n    make_digest_ex(des, digest, 16);\n}\n#endif\n\nstatic int multipart_body_on_header_complete(multipart_parser* p)\n{\n    http_context *ctx = p->data;\n    if (!ctx->current_input_name)\n    {\n        return 0;\n    }\n\n    zval *files = ctx->request.zfiles;\n    zval *multipart_header;\n\n    if (sw_zend_hash_find(Z_ARRVAL_P(files), ctx->current_input_name, strlen(ctx->current_input_name) + 1, (void **) &multipart_header) == FAILURE)\n    {\n        return 0;\n    }\n\n    zval *zerr = NULL;\n    sw_zend_hash_find(Z_ARRVAL_P(multipart_header), ZEND_STRS(\"error\"), (void **) &zerr);\n    if (Z_LVAL_P(zerr) != HTTP_UPLOAD_ERR_OK)\n    {\n        return 0;\n    }\n\n    char file_path[sizeof(SW_HTTP_UPLOAD_TMP_FILE)];\n    memcpy(file_path, SW_HTTP_UPLOAD_TMP_FILE, sizeof(SW_HTTP_UPLOAD_TMP_FILE));\n    int tmpfile = swoole_tmpfile(file_path);\n\n    FILE *fp = fdopen(tmpfile, \"wb+\");\n    if (fp < 0)\n    {\n        add_assoc_long(multipart_header, \"error\", HTTP_UPLOAD_ERR_NO_TMP_DIR);\n        swWarn(\"fopen(%s) failed. Error %s[%d]\", file_path, strerror(errno), errno);\n        return 0;\n    }\n\n    p->fp = fp;\n    sw_add_assoc_string(multipart_header, \"tmp_name\", file_path, 1);\n\n    return 0;\n}\n\nstatic int multipart_body_on_data_end(multipart_parser* p)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    http_context *ctx = p->data;\n    zval *zrequest_object = ctx->request.zobject;\n    if (ctx->current_form_data_name)\n    {\n        zval *zpost = sw_zend_read_property(swoole_http_request_class_entry_ptr, zrequest_object, ZEND_STRL(\"post\"), 1 TSRMLS_CC);\n        if (ZVAL_IS_NULL(zpost))\n        {\n            swoole_http_server_array_init(post, request);\n        }\n\n\t\tchar *name = ctx->current_form_data_name;\n\t\tint len = ctx->current_form_data_name_len;\n\n\t\tif ((name[len-1] == ']') && (name[len-2] == '['))\n\t\t{\n\t\t\tzval *array_value;\n\t\t\tif (sw_zend_hash_find(Z_ARRVAL_P(zpost), name, len + 1, (void **) &array_value) == FAILURE)\n\t\t\t{\n\t\t\t\tSW_MAKE_STD_ZVAL(array_value);\n\t\t\t\tarray_init(array_value);\n\t\t\t\tadd_assoc_zval(zpost, name, array_value);\n\t\t\t}\n            sw_add_next_index_stringl(array_value, swoole_http_form_data_buffer->str, swoole_http_form_data_buffer->length, 1);\n\t\t}\n\t\telse\n\t\t{\n            sw_add_assoc_stringl_ex(zpost, ctx->current_form_data_name, ctx->current_form_data_name_len + 1,\n                    swoole_http_form_data_buffer->str, swoole_http_form_data_buffer->length, 1);\n\t\t}\n\n        efree(ctx->current_form_data_name);\n        ctx->current_form_data_name = NULL;\n        ctx->current_form_data_name_len = 0;\n        swString_clear(swoole_http_form_data_buffer);\n        return 0;\n    }\n\n    if (!ctx->current_input_name)\n    {\n        return 0;\n    }\n\n    zval *files = ctx->request.zfiles;\n    if (ZVAL_IS_NULL(files))\n    {\n        return 0;\n    }\n\n    zval *multipart_header = NULL;\n    sw_zend_hash_find(Z_ARRVAL_P(files), ctx->current_input_name, strlen(ctx->current_input_name) + 1, (void **) &multipart_header);\n\n    if (p->fp != NULL)\n    {\n        long size = swoole_file_get_size((FILE*) p->fp);\n        add_assoc_long(multipart_header, \"size\", size);\n\n        fclose((FILE *)p->fp);\n        p->fp = NULL;\n    }\n\n    efree(ctx->current_input_name);\n\n    return 0;\n}\n\nstatic int multipart_body_end(multipart_parser* p)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    http_context *ctx = p->data;\n    zval *files = ctx->request.zfiles;\n    zval *value;\n\n    SW_HASHTABLE_FOREACH_START(Z_ARRVAL_P(files), value)\n    {\n        zval *file_path;\n        if (sw_zend_hash_find(Z_ARRVAL_P(value), ZEND_STRS(\"tmp_name\"), (void **) &file_path) == SUCCESS)\n        {\n#if PHP_MAJOR_VERSION >= 7\n            zend_string *tmp_name = zval_get_string(file_path);\n            zend_hash_add_ptr(SG(rfc1867_uploaded_files), tmp_name, tmp_name);\n#else\n            char *temp_filename = Z_STRVAL_P(file_path);\n            sw_zend_hash_add(SG(rfc1867_uploaded_files), temp_filename, Z_STRLEN_P(file_path) + 1, &temp_filename, sizeof(char *), NULL);\n#endif\n        }\n    }\n    SW_HASHTABLE_FOREACH_END();\n\n    return 0;\n}\n\nstatic int http_request_on_body(php_http_parser *parser, const char *at, size_t length)\n{\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    http_context *ctx = parser->data;\n    zval *zrequest_object = ctx->request.zobject;\n    char *body;\n\n    ctx->request.post_length = length;\n    if (SwooleG.serv->http_parse_post && ctx->request.post_form_urlencoded)\n    {\n        zval *zpost;\n        swoole_http_server_array_init(post, request);\n        body = estrndup(at, length);\n\n        sapi_module.treat_data(PARSE_STRING, body, zpost TSRMLS_CC);\n    }\n    else if (ctx->mt_parser != NULL)\n    {\n        multipart_parser *multipart_parser = ctx->mt_parser;\n        size_t n = multipart_parser_execute(multipart_parser, at, length);\n        if (n != length)\n        {\n            swoole_php_fatal_error(E_WARNING, \"parse multipart body failed.\");\n        }\n    }\n\n    return 0;\n}\n\nstatic int http_request_message_complete(php_http_parser *parser)\n{\n    http_context *ctx = parser->data;\n    ctx->request.version = parser->http_major * 100 + parser->http_minor;\n\n    const char *vpath = ctx->request.path, *end = vpath + ctx->request.path_len, *p = end;\n    ctx->request.ext = end;\n    ctx->request.ext_len = 0;\n    while (p > vpath)\n    {\n        --p;\n        if (*p == '.')\n        {\n            ++p;\n            ctx->request.ext = p;\n            ctx->request.ext_len = end - p;\n            break;\n        }\n    }\n    ctx->request_read = 1;\n\n    if (ctx->mt_parser)\n    {\n        multipart_parser_free(ctx->mt_parser);\n        ctx->mt_parser = NULL;\n    }\n\n    return 0;\n}\n\nstatic int http_onReceive(swServer *serv, swEventData *req)\n{\n    int fd = req->info.fd;\n\n    swConnection *conn = swWorker_get_connection(SwooleG.serv, fd);\n    if (!conn)\n    {\n        swWarn(\"connection[%d] is closed.\", fd);\n        return SW_ERR;\n    }\n    swListenPort *port = serv->connection_list[req->info.from_fd].object;\n    //other server port\n    if (!port->open_http_protocol)\n    {\n        return php_swoole_onReceive(serv, req);\n    }\n    //websocket client\n    if (conn->websocket_status == WEBSOCKET_STATUS_ACTIVE)\n    {\n        return swoole_websocket_onMessage(req);\n    }\n\n    swoole_http_client *client = swArray_fetch(http_client_array, conn->fd);\n    if (!client)\n    {\n        return SW_OK;\n    }\n    client->fd = fd;\n\n#ifdef SW_USE_HTTP2\n    if (conn->http2_stream)\n    {\n        client->http2 = 1;\n        return swoole_http2_onFrame(client, req);\n    }\n#endif\n\n#if PHP_MAJOR_VERSION < 7\n    TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);\n#endif\n\n    http_context *ctx = swoole_http_context_new(client TSRMLS_CC);\n    php_http_parser *parser = &ctx->parser;\n    zval *zserver = ctx->request.zserver;\n\n    parser->data = ctx;\n\n    php_http_parser_init(parser, PHP_HTTP_REQUEST);\n\n    zval *zdata;\n    SW_MAKE_STD_ZVAL(zdata);\n    ctx->request.zdata = zdata;\n    php_swoole_get_recv_data(zdata, req, NULL, 0);\n    sw_copy_to_stack(ctx->request.zdata, ctx->request._zdata);\n\n    swTrace(\"httpRequest %d bytes:\\n---------------------------------------\\n%s\\n\", Z_STRLEN_P(zdata), Z_STRVAL_P(zdata));\n\n    long n = php_http_parser_execute(parser, &http_parser_settings, Z_STRVAL_P(zdata), Z_STRLEN_P(zdata));\n    if (n < 0)\n    {\n        sw_zval_ptr_dtor(&zdata);\n        efree(client);\n        swWarn(\"php_http_parser_execute failed.\");\n\n        if (conn->websocket_status == WEBSOCKET_STATUS_CONNECTION)\n        {\n            return SwooleG.serv->factory.end(&SwooleG.serv->factory, fd);\n        }\n    }\n    else\n    {\n        zval *retval;\n#ifndef SW_COROUTINE\n        zval **args[2];\n#else\n        zval *args[2];\n#endif\n\n        zval *zrequest_object = ctx->request.zobject;\n        zval *zresponse_object = ctx->response.zobject;\n\n        ctx->keepalive = php_http_should_keep_alive(parser);\n        char *method_name = http_get_method_name(parser->method);\n\n        sw_add_assoc_string(zserver, \"request_method\", method_name, 1);\n        sw_add_assoc_stringl(zserver, \"request_uri\", ctx->request.path, ctx->request.path_len, 1);\n        sw_add_assoc_stringl(zserver, \"path_info\", ctx->request.path, ctx->request.path_len, 1);\n        sw_add_assoc_long_ex(zserver, ZEND_STRS(\"request_time\"), SwooleGS->now);\n\n        // Add REQUEST_TIME_FLOAT\n        double now_float = swoole_microtime();\n        sw_add_assoc_double_ex(zserver, ZEND_STRS(\"request_time_float\"), now_float);\n\n        swConnection *conn = swWorker_get_connection(SwooleG.serv, fd);\n        if (!conn)\n        {\n            sw_zval_ptr_dtor(&zdata);\n            swWarn(\"connection[%d] is closed.\", fd);\n            return SW_ERR;\n        }\n\n        add_assoc_long(ctx->request.zserver, \"server_port\", swConnection_get_port(&SwooleG.serv->connection_list[conn->from_fd]));\n        add_assoc_long(ctx->request.zserver, \"remote_port\", swConnection_get_port(conn));\n        sw_add_assoc_string(zserver, \"remote_addr\", swConnection_get_ip(conn), 1);\n\n        if (ctx->request.version == 101)\n        {\n            sw_add_assoc_string(zserver, \"server_protocol\", \"HTTP/1.1\", 1);\n        }\n        else\n        {\n            sw_add_assoc_string(zserver, \"server_protocol\", \"HTTP/1.0\", 1);\n        }\n\n        sw_add_assoc_string(zserver, \"server_software\", SW_HTTP_SERVER_SOFTWARE, 1);\n\n        zval *zcallback = php_swoole_server_get_callback(serv, req->info.from_fd, SW_SERVER_CB_onHandShake);\n        //websocket handshake\n        if (conn->websocket_status == WEBSOCKET_STATUS_CONNECTION && zcallback == NULL)\n        {\n            return swoole_websocket_onHandshake(ctx);\n        }\n        \n#ifndef SW_COROUTINE\n        args[0] = &zrequest_object;\n        args[1] = &zresponse_object;\n#else\n        args[0] = zrequest_object;\n        args[1] = zresponse_object;\n#endif\n\n        int callback_type = 0;\n        if (conn->websocket_status == WEBSOCKET_STATUS_CONNECTION)\n        {\n            callback_type = SW_SERVER_CB_onHandShake;\n            conn->websocket_status = WEBSOCKET_STATUS_HANDSHAKE;\n        }\n        else\n        {\n            callback_type = SW_SERVER_CB_onRequest;\n            zcallback = php_swoole_server_get_callback(serv, req->info.from_fd, SW_SERVER_CB_onRequest);\n            //no have onRequest callback\n            if (zcallback == NULL)\n            {\n                swoole_websocket_onReuqest(ctx);\n                return SW_OK;\n            }\n        }\n\n#ifndef SW_COROUTINE\n        zcallback = php_swoole_server_get_callback(serv, req->info.from_fd, callback_type);\n        if (sw_call_user_function_ex(EG(function_table), NULL, zcallback, &retval, 2, args, 0, NULL TSRMLS_CC) == FAILURE)\n        {\n            swoole_php_error(E_WARNING, \"onRequest handler error\");\n        }\n#else\n        zend_fcall_info_cache *cache = php_swoole_server_get_cache(serv, req->info.from_fd, callback_type);\n        int ret = coro_create(cache, args, 2, &retval, NULL, NULL);\n        if (ret != 0)\n        {\n            sw_zval_ptr_dtor(&zrequest_object);\n            sw_zval_ptr_dtor(&zresponse_object);\n            if (ret == CORO_LIMIT)\n            {\n                SwooleG.serv->factory.end(&SwooleG.serv->factory, fd);\n            }\n            return SW_OK;\n        }\n#endif\n        if (EG(exception))\n        {\n            zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n        }\n        //websocket user handshake\n        if (conn->websocket_status == WEBSOCKET_STATUS_HANDSHAKE)\n        {\n            //handshake success\n            if (retval && Z_BVAL_P(retval))\n            {\n                conn->websocket_status = WEBSOCKET_STATUS_ACTIVE;\n            }\n        }\n        sw_zval_ptr_dtor(&zrequest_object);\n        sw_zval_ptr_dtor(&zresponse_object);\n        if (retval)\n        {\n            sw_zval_ptr_dtor(&retval);\n        }\n    }\n    return SW_OK;\n}\n\nvoid swoole_http_server_init(int module_number TSRMLS_DC)\n{\n    SWOOLE_INIT_CLASS_ENTRY(swoole_http_server_ce, \"swoole_http_server\", \"Swoole\\\\Http\\\\Server\", swoole_http_server_methods);\n    swoole_http_server_class_entry_ptr = sw_zend_register_internal_class_ex(&swoole_http_server_ce, swoole_server_class_entry_ptr, \"swoole_server\" TSRMLS_CC);\n\n    zend_declare_property_long(swoole_http_server_class_entry_ptr, ZEND_STRL(\"global\"), 0, ZEND_ACC_PRIVATE TSRMLS_CC);\n\n    SWOOLE_INIT_CLASS_ENTRY(swoole_http_response_ce, \"swoole_http_response\", \"Swoole\\\\Http\\\\Response\", swoole_http_response_methods);\n    swoole_http_response_class_entry_ptr = zend_register_internal_class(&swoole_http_response_ce TSRMLS_CC);\n\n    SWOOLE_INIT_CLASS_ENTRY(swoole_http_request_ce, \"swoole_http_request\", \"Swoole\\\\Http\\\\Request\", swoole_http_request_methods);\n    swoole_http_request_class_entry_ptr = zend_register_internal_class(&swoole_http_request_ce TSRMLS_CC);\n}\n\nstatic PHP_METHOD(swoole_http_server, on)\n{\n    zval *callback;\n    zval *event_name;\n\n    if (SwooleGS->start > 0)\n    {\n        swoole_php_error(E_WARNING, \"Server is running. Unable to set event callback now.\");\n        RETURN_FALSE;\n    }\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"zz\", &event_name, &callback) == FAILURE)\n    {\n        return;\n    }\n\n#ifdef PHP_SWOOLE_CHECK_CALLBACK\n    char *func_name = NULL;\n#ifndef SW_COROUTINE\n    if (!sw_zend_is_callable(callback, 0, &func_name TSRMLS_CC))\n#else\n    zend_fcall_info_cache *func_cache = emalloc(sizeof(zend_fcall_info_cache));\n    if (!zend_is_callable_ex(callback, NULL, 0, &func_name, NULL, func_cache, NULL TSRMLS_CC))\n#endif\n    {\n        swoole_php_fatal_error(E_ERROR, \"Function '%s' is not callable\", func_name);\n        efree(func_name);\n        RETURN_FALSE;\n    }\n    efree(func_name);\n#endif\n\n    if (strncasecmp(\"request\", Z_STRVAL_P(event_name), Z_STRLEN_P(event_name)) == 0)\n    {\n        zend_update_property(swoole_http_server_class_entry_ptr, getThis(), ZEND_STRL(\"onRequest\"), callback TSRMLS_CC);\n        php_sw_server_callbacks[SW_SERVER_CB_onRequest] = sw_zend_read_property(swoole_http_server_class_entry_ptr, getThis(), ZEND_STRL(\"onRequest\"), 0 TSRMLS_CC);\n        sw_copy_to_stack(php_sw_server_callbacks[SW_SERVER_CB_onRequest], _php_sw_server_callbacks[SW_SERVER_CB_onRequest]);\n#ifdef SW_COROUTINE\n        php_sw_server_caches[SW_SERVER_CB_onRequest] = func_cache;\n#endif\n    }\n    else if (strncasecmp(\"handshake\", Z_STRVAL_P(event_name), Z_STRLEN_P(event_name)) == 0)\n    {\n        zend_update_property(swoole_http_server_class_entry_ptr, getThis(), ZEND_STRL(\"onHandshake\"), callback TSRMLS_CC);\n        php_sw_server_callbacks[SW_SERVER_CB_onHandShake] = sw_zend_read_property(swoole_http_server_class_entry_ptr, getThis(), ZEND_STRL(\"onHandshake\"), 0 TSRMLS_CC);\n        sw_copy_to_stack(php_sw_server_callbacks[SW_SERVER_CB_onHandShake], _php_sw_server_callbacks[SW_SERVER_CB_onHandShake]);\n#ifdef SW_COROUTINE\n        php_sw_server_caches[SW_SERVER_CB_onHandShake] = func_cache;\n#endif\n    }\n    else\n    {\n        zval *obj = getThis();\n        sw_zend_call_method_with_2_params(&obj, swoole_server_class_entry_ptr, NULL, \"on\", &return_value, event_name, callback);\n    }\n}\n\nhttp_context* swoole_http_context_new(swoole_http_client* client TSRMLS_DC)\n{\n    http_context *ctx = emalloc(sizeof(http_context));\n    if (!ctx)\n    {\n        swoole_error_log(SW_LOG_ERROR, SW_ERROR_MALLOC_FAIL, \"emalloc(%ld) failed.\", sizeof(http_context));\n        return NULL;\n    }\n    bzero(ctx, sizeof(http_context));\n\n    zval *zrequest_object;\n#if PHP_MAJOR_VERSION >= 7\n    zrequest_object = &ctx->request._zobject;\n#else\n    SW_ALLOC_INIT_ZVAL(zrequest_object);\n#endif\n    ctx->request.zobject = zrequest_object;\n    object_init_ex(zrequest_object, swoole_http_request_class_entry_ptr);\n    swoole_set_object(zrequest_object, ctx);\n\n    zval *zresponse_object;\n#if PHP_MAJOR_VERSION >= 7\n    zresponse_object = &ctx->response._zobject;\n#else\n    SW_ALLOC_INIT_ZVAL(zresponse_object);\n#endif\n    ctx->response.zobject = zresponse_object;\n    object_init_ex(zresponse_object, swoole_http_response_class_entry_ptr);\n    swoole_set_object(zresponse_object, ctx);\n\n    //socket fd\n    zend_update_property_long(swoole_http_response_class_entry_ptr, zresponse_object, ZEND_STRL(\"fd\"), client->fd TSRMLS_CC);\n    zend_update_property_long(swoole_http_request_class_entry_ptr, zrequest_object, ZEND_STRL(\"fd\"), client->fd TSRMLS_CC);\n\n#if PHP_MEMORY_DEBUG\n    php_vmstat.new_http_request ++;\n#endif\n\n    zval *zheader;\n    swoole_http_server_array_init(header, request);\n\n    zval *zserver;\n    swoole_http_server_array_init(server, request);\n\n    ctx->fd = client->fd;\n    ctx->client = client;\n\n    return ctx;\n}\n\nvoid swoole_http_context_free(http_context *ctx TSRMLS_DC)\n{\n    swoole_set_object(ctx->response.zobject, NULL);\n    http_request *req = &ctx->request;\n    if (req->path)\n    {\n        efree(req->path);\n    }\n    if (req->zdata)\n    {\n        sw_zval_ptr_dtor(&req->zdata);\n    }\n#ifdef SW_USE_HTTP2\n    if (req->post_buffer)\n    {\n        swString_free(req->post_buffer);\n    }\n#endif\n    efree(ctx);\n}\n\nstatic char *http_status_message(int code)\n{\n    switch (code)\n    {\n    case 100:\n        return \"100 Continue\";\n    case 101:\n        return \"101 Switching Protocols\";\n    case 201:\n        return \"201 Created\";\n    case 202:\n        return \"202 Accepted\";\n    case 203:\n        return \"203 Non-Authoritative Information\";\n    case 204:\n        return \"204 No Content\";\n    case 205:\n        return \"205 Reset Content\";\n    case 206:\n        return \"206 Partial Content\";\n    case 207:\n        return \"207 Multi-Status\";\n    case 208:\n        return \"208 Already Reported\";\n    case 226:\n        return \"226 IM Used\";\n    case 300:\n        return \"300 Multiple Choices\";\n    case 301:\n        return \"301 Moved Permanently\";\n    case 302:\n        return \"302 Found\";\n    case 303:\n        return \"303 See Other\";\n    case 304:\n        return \"304 Not Modified\";\n    case 305:\n        return \"305 Use Proxy\";\n    case 307:\n        return \"307 Temporary Redirect\";\n    case 400:\n        return \"400 Bad Request\";\n    case 401:\n        return \"401 Unauthorized\";\n    case 402:\n        return \"402 Payment Required\";\n    case 403:\n        return \"403 Forbidden\";\n    case 404:\n        return \"404 Not Found\";\n    case 405:\n        return \"405 Method Not Allowed\";\n    case 406:\n        return \"406 Not Acceptable\";\n    case 407:\n        return \"407 Proxy Authentication Required\";\n    case 408:\n        return \"408 Request Timeout\";\n    case 409:\n        return \"409 Conflict\";\n    case 410:\n        return \"410 Gone\";\n    case 411:\n        return \"411 Length Required\";\n    case 412:\n        return \"412 Precondition Failed\";\n    case 413:\n        return \"413 Request Entity Too Large\";\n    case 414:\n        return \"414 Request URI Too Long\";\n    case 415:\n        return \"415 Unsupported Media Type\";\n    case 416:\n        return \"416 Requested Range Not Satisfiable\";\n    case 417:\n        return \"417 Expectation Failed\";\n    case 418:\n        return \"418 I'm a teapot\";\n    case 421:\n        return \"421 Misdirected Request\";\n    case 422:\n        return \"422 Unprocessable Entity\";\n    case 423:\n        return \"423 Locked\";\n    case 424:\n        return \"424 Failed Dependency\";\n    case 426:\n        return \"426 Upgrade Required\";\n    case 428:\n        return \"428 Precondition Required\";\n    case 429:\n        return \"429 Too Many Requests\";\n    case 431:\n        return \"431 Request Header Fields Too Large\";\n    case 500:\n        return \"500 Internal Server Error\";\n    case 501:\n        return \"501 Method Not Implemented\";\n    case 502:\n        return \"502 Bad Gateway\";\n    case 503:\n        return \"503 Service Unavailable\";\n    case 505:\n        return \"505 HTTP Version Not Supported\";\n    case 506:\n        return \"506 Variant Also Negotiates\";\n    case 507:\n        return \"507 Insufficient Storage\";\n    case 508:\n        return \"508 Loop Detected\";\n    case 510:\n        return \"510 Not Extended\";\n    case 511:\n        return \"511 Network Authentication Required\";\n    case 200:\n    default:\n        return \"200 OK\";\n    }\n}\n\nstatic PHP_METHOD(swoole_http_server, start)\n{\n    int ret;\n\n    if (SwooleGS->start > 0)\n    {\n        swoole_php_error(E_WARNING, \"Server is running. Unable to execute swoole_server::start.\");\n        RETURN_FALSE;\n    }\n\n    swServer *serv = swoole_get_object(getThis());\n    php_swoole_register_callback(serv);\n\n    if (serv->listen_list->open_websocket_protocol)\n    {\n        if (php_sw_server_callbacks[SW_SERVER_CB_onMessage] == NULL)\n        {\n            swoole_php_fatal_error(E_ERROR, \"require onMessage callback\");\n            RETURN_FALSE;\n        }\n        if (serv->listen_list->open_http2_protocol == 1)\n        {\n            swoole_php_fatal_error(E_ERROR, \"cannot use http2 protocol in websocket server\");\n            RETURN_FALSE;\n        }\n    }\n    else if (php_sw_server_callbacks[SW_SERVER_CB_onRequest] == NULL)\n    {\n        swoole_php_fatal_error(E_ERROR, \"require onRequest callback\");\n        RETURN_FALSE;\n    }\n\n    http_client_array = swArray_new(1024, sizeof(swoole_http_client));\n    if (!http_client_array)\n    {\n        swoole_php_fatal_error(E_ERROR, \"swArray_new(1024, %ld) failed.\", sizeof(swoole_http_client));\n        RETURN_FALSE;\n    }\n\n    swoole_http_buffer = swString_new(SW_HTTP_RESPONSE_INIT_SIZE);\n    if (!swoole_http_buffer)\n    {\n        swoole_php_fatal_error(E_ERROR, \"[1] swString_new(%d) failed.\", SW_HTTP_RESPONSE_INIT_SIZE);\n        RETURN_FALSE;\n    }\n\n    swoole_http_form_data_buffer = swString_new(SW_HTTP_RESPONSE_INIT_SIZE);\n    if (!swoole_http_form_data_buffer)\n    {\n        swoole_php_fatal_error(E_ERROR, \"[2] swString_new(%d) failed.\", SW_HTTP_RESPONSE_INIT_SIZE);\n        RETURN_FALSE;\n    }\n\n#ifdef SW_HAVE_ZLIB\n    swoole_zlib_buffer = swString_new(SW_HTTP_RESPONSE_INIT_SIZE);\n    if (!swoole_zlib_buffer)\n    {\n        swoole_php_fatal_error(E_ERROR, \"[3] swString_new(%d) failed.\", SW_HTTP_RESPONSE_INIT_SIZE);\n        RETURN_FALSE;\n    }\n#endif\n\n    serv->onReceive = http_onReceive;\n\n    zval *zsetting = sw_zend_read_property(swoole_server_class_entry_ptr, getThis(), ZEND_STRL(\"setting\"), 1 TSRMLS_CC);\n    if (zsetting == NULL || ZVAL_IS_NULL(zsetting))\n    {\n        SW_MAKE_STD_ZVAL(zsetting);\n        array_init(zsetting);\n        zend_update_property(swoole_server_class_entry_ptr, getThis(), ZEND_STRL(\"setting\"), zsetting TSRMLS_CC);\n        sw_zval_ptr_dtor(&zsetting);\n    }\n\n    add_assoc_bool(zsetting, \"open_http_protocol\", 1);\n    add_assoc_bool(zsetting, \"open_mqtt_protocol\", 0);\n    add_assoc_bool(zsetting, \"open_eof_check\", 0);\n    add_assoc_bool(zsetting, \"open_length_check\", 0);\n\n    if (serv->listen_list->open_websocket_protocol)\n    {\n        add_assoc_bool(zsetting, \"open_websocket_protocol\", 1);\n    }\n\n    serv->listen_list->open_http_protocol = 1;\n    serv->listen_list->open_mqtt_protocol = 0;\n    serv->listen_list->open_eof_check = 0;\n    serv->listen_list->open_length_check = 0;\n\n    serv->ptr2 = getThis();\n\n    //for is_uploaded_file and move_uploaded_file\n    ALLOC_HASHTABLE(SG(rfc1867_uploaded_files));\n    zend_hash_init(SG(rfc1867_uploaded_files), 8, NULL, NULL, 0);\n\n    php_swoole_server_before_start(serv, getThis() TSRMLS_CC);\n\n    ret = swServer_start(serv);\n    if (ret < 0)\n    {\n        swoole_php_fatal_error(E_ERROR, \"start server failed. Error: %s\", sw_error);\n        RETURN_LONG(ret);\n    }\n    RETURN_TRUE;\n}\n\nstatic PHP_METHOD(swoole_http_request, rawcontent)\n{\n    zval *zfd = sw_zend_read_property(swoole_http_request_class_entry_ptr, getThis(), ZEND_STRL(\"fd\"), 0 TSRMLS_CC);\n    if (ZVAL_IS_NULL(zfd))\n    {\n        swoole_php_error(E_WARNING, \"http client not exists.\");\n        RETURN_FALSE;\n    }\n\n    http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);\n    if (!ctx)\n    {\n        RETURN_FALSE;\n    }\n\n    http_request *req = &ctx->request;\n    if (req->post_length > 0)\n    {\n        SW_RETVAL_STRINGL(Z_STRVAL_P(req->zdata) + Z_STRLEN_P(req->zdata) - req->post_length, req->post_length, 1);\n    }\n#ifdef SW_USE_HTTP2\n    else if (req->post_buffer)\n    {\n        SW_RETVAL_STRINGL(req->post_buffer->str, req->post_buffer->length, 1);\n    }\n#endif\n    else\n    {\n        RETURN_FALSE;\n    }\n}\n\nstatic PHP_METHOD(swoole_http_request, __destruct)\n{\n    zval *zfiles = sw_zend_read_property(swoole_http_request_class_entry_ptr, getThis(), ZEND_STRL(\"files\"), 1 TSRMLS_CC);\n    //upload files\n    if (zfiles && Z_TYPE_P(zfiles) == IS_ARRAY)\n    {\n        zval *value;\n        char *key;\n        int keytype;\n        uint32_t keylen;\n\n        SW_HASHTABLE_FOREACH_START2(Z_ARRVAL_P(zfiles), key, keylen, keytype, value)\n        {\n            if (HASH_KEY_IS_STRING != keytype)\n            {\n                continue;\n            }\n            zval *file_path;\n            if (sw_zend_hash_find(Z_ARRVAL_P(value), ZEND_STRS(\"tmp_name\"), (void **) &file_path) == SUCCESS)\n            {\n                unlink(Z_STRVAL_P(file_path));\n                sw_zend_hash_del(SG(rfc1867_uploaded_files), Z_STRVAL_P(file_path), Z_STRLEN_P(file_path) + 1);\n            }\n        }\n        SW_HASHTABLE_FOREACH_END();\n    }\n    swoole_set_object(getThis(), NULL);\n}\n\nstatic PHP_METHOD(swoole_http_response, write)\n{\n    zval *zdata;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z\", &zdata) == FAILURE)\n    {\n        return;\n    }\n\n    http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);\n    if (!ctx)\n    {\n        return;\n    }\n\n    if (!ctx->send_header)\n    {\n        ctx->chunk = 1;\n        swString_clear(swoole_http_buffer);\n        http_build_header(ctx, getThis(), swoole_http_buffer, -1 TSRMLS_CC);\n        if (swServer_tcp_send(SwooleG.serv, ctx->fd, swoole_http_buffer->str, swoole_http_buffer->length) < 0)\n        {\n            ctx->chunk = 0;\n            ctx->send_header = 0;\n            RETURN_FALSE;\n        }\n    }\n\n    swString http_body;\n    int length = php_swoole_get_send_data(zdata, &http_body.str TSRMLS_CC);\n\n    if (length < 0)\n    {\n        RETURN_FALSE;\n    }\n    else if (length == 0)\n    {\n       swoole_php_error(E_WARNING, \"data is empty.\");\n        RETURN_FALSE;\n    }\n    else\n    {\n        http_body.length = length;\n    }\n\n    swString_clear(swoole_http_buffer);\n\n    char *hex_string;\n    int hex_len;\n\n#ifdef SW_HAVE_ZLIB\n    if (ctx->gzip_enable)\n    {\n        http_response_compress(&http_body, ctx->gzip_level);\n\n        hex_string = swoole_dec2hex(swoole_zlib_buffer->length, 16);\n        hex_len = strlen(hex_string);\n\n        //\"%*s\\r\\n%*s\\r\\n\", hex_len, hex_string, body.length, body.str\n        swString_append_ptr(swoole_http_buffer, hex_string, hex_len);\n        swString_append_ptr(swoole_http_buffer, SW_STRL(\"\\r\\n\") - 1);\n        swString_append(swoole_http_buffer, swoole_zlib_buffer);\n        swString_append_ptr(swoole_http_buffer, SW_STRL(\"\\r\\n\") - 1);\n    }\n    else\n#endif\n    {\n        hex_string = swoole_dec2hex(http_body.length, 16);\n        hex_len = strlen(hex_string);\n\n        //\"%*s\\r\\n%*s\\r\\n\", hex_len, hex_string, body.length, body.str\n        swString_append_ptr(swoole_http_buffer, hex_string, hex_len);\n        swString_append_ptr(swoole_http_buffer, SW_STRL(\"\\r\\n\") - 1);\n        swString_append_ptr(swoole_http_buffer, http_body.str, http_body.length);\n        swString_append_ptr(swoole_http_buffer, SW_STRL(\"\\r\\n\") - 1);\n    }\n\n    int ret = swServer_tcp_send(SwooleG.serv, ctx->fd, swoole_http_buffer->str, swoole_http_buffer->length);\n    sw_strdup_free(hex_string);\n    SW_CHECK_RETURN(ret);\n}\n\nstatic http_context* http_get_context(zval *object, int check_end TSRMLS_DC)\n{\n    http_context *ctx = swoole_get_object(object);\n    if (!ctx)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Http request is end.\");\n        return NULL;\n    }\n    if (check_end && ctx->end)\n    {\n        swoole_php_fatal_error(E_WARNING, \"Http request is end.\");\n        return NULL;\n    }\n    return ctx;\n}\n\nstatic void http_build_header(http_context *ctx, zval *object, swString *response, int body_length TSRMLS_DC)\n{\n    assert(ctx->send_header == 0);\n\n    char buf[SW_HTTP_HEADER_MAX_SIZE];\n    int n;\n    char *date_str;\n\n    /**\n     * http status line\n     */\n    n = snprintf(buf, sizeof(buf), \"HTTP/1.1 %s\\r\\n\", http_status_message(ctx->response.status));\n    swString_append_ptr(response, buf, n);\n\n    /**\n     * http header\n     */\n    zval *header = ctx->response.zheader;\n    if (header)\n    {\n        int flag = 0x0;\n        char *key_server = \"Server\";\n        char *key_connection = \"Connection\";\n        char *key_content_length = \"Content-Length\";\n        char *key_content_type = \"Content-Type\";\n        char *key_date = \"Date\";\n\n        HashTable *ht = Z_ARRVAL_P(header);\n        zval *value = NULL;\n        char *key = NULL;\n        uint32_t keylen = 0;\n        int type;\n\n        SW_HASHTABLE_FOREACH_START2(ht, key, keylen, type, value)\n        {\n            if (!key)\n            {\n                break;\n            }\n            if (strcmp(key, key_server) == 0)\n            {\n                flag |= HTTP_RESPONSE_SERVER;\n            }\n            else if (strcmp(key, key_connection) == 0)\n            {\n                flag |= HTTP_RESPONSE_CONNECTION;\n            }\n            else if (strcmp(key, key_content_length) == 0)\n            {\n                flag |= HTTP_RESPONSE_CONTENT_LENGTH;\n            }\n            else if (strcmp(key, key_date) == 0)\n            {\n                flag |= HTTP_RESPONSE_DATE;\n            }\n            else if (strcmp(key, key_content_type) == 0)\n            {\n                flag |= HTTP_RESPONSE_CONTENT_TYPE;\n            }\n            n = snprintf(buf, sizeof(buf), \"%*s: %*s\\r\\n\", keylen - 1, key, Z_STRLEN_P(value), Z_STRVAL_P(value));\n            swString_append_ptr(response, buf, n);\n        }\n        SW_HASHTABLE_FOREACH_END();\n\n        if (!(flag & HTTP_RESPONSE_SERVER))\n        {\n            swString_append_ptr(response, ZEND_STRL(\"Server: \"SW_HTTP_SERVER_SOFTWARE\"\\r\\n\"));\n        }\n        if (!(flag & HTTP_RESPONSE_CONNECTION))\n        {\n            if (ctx->keepalive)\n            {\n                swString_append_ptr(response, ZEND_STRL(\"Connection: keep-alive\\r\\n\"));\n            }\n            else\n            {\n                swString_append_ptr(response, ZEND_STRL(\"Connection: close\\r\\n\"));\n            }\n        }\n        if (ctx->request.method == PHP_HTTP_OPTIONS)\n        {\n            swString_append_ptr(response, ZEND_STRL(\"Allow: GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS\\r\\nContent-Length: 0\\r\\n\"));\n        }\n        else\n        {\n            if (!(flag & HTTP_RESPONSE_CONTENT_LENGTH) && body_length >= 0)\n            {\n#ifdef SW_HAVE_ZLIB\n                if (ctx->gzip_enable)\n                {\n                    body_length = swoole_zlib_buffer->length;\n                }\n#endif\n                n = snprintf(buf, sizeof(buf), \"Content-Length: %d\\r\\n\", body_length);\n                swString_append_ptr(response, buf, n);\n            }\n        }\n        if (!(flag & HTTP_RESPONSE_DATE))\n        {\n            date_str = sw_php_format_date(ZEND_STRL(SW_HTTP_DATE_FORMAT), SwooleGS->now, 0 TSRMLS_CC);\n            n = snprintf(buf, sizeof(buf), \"Date: %s\\r\\n\", date_str);\n            swString_append_ptr(response, buf, n);\n            efree(date_str);\n        }\n        if (!(flag & HTTP_RESPONSE_CONTENT_TYPE))\n        {\n            swString_append_ptr(response, ZEND_STRL(\"Content-Type: text/html\\r\\n\"));\n        }\n    }\n    else\n    {\n        swString_append_ptr(response, ZEND_STRL(\"Server: \"SW_HTTP_SERVER_SOFTWARE\"\\r\\nContent-Type: text/html\\r\\n\"));\n        if (ctx->keepalive)\n        {\n            swString_append_ptr(response, ZEND_STRL(\"Connection: keep-alive\\r\\n\"));\n        }\n        else\n        {\n            swString_append_ptr(response, ZEND_STRL(\"Connection: close\\r\\n\"));\n        }\n\n        date_str = sw_php_format_date(ZEND_STRL(SW_HTTP_DATE_FORMAT), SwooleGS->now, 0 TSRMLS_CC);\n        n = snprintf(buf, sizeof(buf), \"Date: %s\\r\\n\", date_str);\n        efree(date_str);\n        swString_append_ptr(response, buf, n);\n\n        if (ctx->request.method == PHP_HTTP_OPTIONS)\n        {\n            n = snprintf(buf, sizeof(buf), \"Allow: GET, POST, PUT, DELETE, HEAD, OPTIONS\\r\\nContent-Length: %d\\r\\n\", 0);\n            swString_append_ptr(response, buf, n);\n        }\n        else if (body_length >= 0)\n        {\n#ifdef SW_HAVE_ZLIB\n            if (ctx->gzip_enable)\n            {\n                body_length = swoole_zlib_buffer->length;\n            }\n#endif\n            n = snprintf(buf, sizeof(buf), \"Content-Length: %d\\r\\n\", body_length);\n            swString_append_ptr(response, buf, n);\n        }\n    }\n\n    if (ctx->chunk)\n    {\n        swString_append_ptr(response, SW_STRL(\"Transfer-Encoding: chunked\\r\\n\") - 1);\n    }\n    //http cookies\n    if (ctx->response.zcookie)\n    {\n        zval *value;\n        SW_HASHTABLE_FOREACH_START(Z_ARRVAL_P(ctx->response.zcookie), value)\n        {\n            if (Z_TYPE_P(value) != IS_STRING)\n            {\n                continue;\n            }\n            swString_append_ptr(response, SW_STRL(\"Set-Cookie: \") - 1);\n            swString_append_ptr(response, Z_STRVAL_P(value), Z_STRLEN_P(value));\n            swString_append_ptr(response, SW_STRL(\"\\r\\n\") - 1);\n        }\n        SW_HASHTABLE_FOREACH_END();\n    }\n    //http compress\n    if (ctx->gzip_enable)\n    {\n#ifdef SW_HTTP_COMPRESS_GZIP\n        swString_append_ptr(response, SW_STRL(\"Content-Encoding: gzip\\r\\n\") - 1);\n#else\n        swString_append_ptr(response, SW_STRL(\"Content-Encoding: deflate\\r\\n\") - 1);\n#endif\n    }\n    swString_append_ptr(response, ZEND_STRL(\"\\r\\n\"));\n    ctx->send_header = 1;\n}\n\n#ifdef SW_HAVE_ZLIB\nstatic int http_response_compress(swString *body, int level)\n{\n    assert(level > 0 || level < 10);\n\n    size_t memory_size = ((size_t) ((double) body->length * (double) 1.015)) + 10 + 8 + 4 + 1;\n\n    if (memory_size > swoole_zlib_buffer->size)\n    {\n        swString_extend(swoole_zlib_buffer, memory_size);\n    }\n\n    z_stream zstream;\n    memset(&zstream, 0, sizeof(zstream));\n\n    //deflate: -0xf, gzip: 0x1f\n#ifdef SW_HTTP_COMPRESS_GZIP\n    int encoding = 0x1f;\n#else\n    int encoding =  -0xf;\n#endif\n\n    int status;\n    if (Z_OK == deflateInit2(&zstream, level, Z_DEFLATED, encoding, MAX_MEM_LEVEL, Z_DEFAULT_STRATEGY))\n    {\n        zstream.next_in = (Bytef *) body->str;\n        zstream.next_out = (Bytef *) swoole_zlib_buffer->str;\n        zstream.avail_in = body->length;\n        zstream.avail_out = swoole_zlib_buffer->size;\n\n        status = deflate(&zstream, Z_FINISH);\n        deflateEnd(&zstream);\n\n        if (Z_STREAM_END == status)\n        {\n            swoole_zlib_buffer->length = zstream.total_out;\n            return SW_OK;\n        }\n    }\n    else\n    {\n        swWarn(\"deflateInit2() failed.\");\n    }\n    return SW_ERR;\n}\n#endif\n\nstatic PHP_METHOD(swoole_http_response, end)\n{\n    zval *zdata = NULL;\n    int ret;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|z\", &zdata) == FAILURE)\n    {\n        return;\n    }\n\n    swString http_body;\n\n    if (zdata)\n    {\n        int length = php_swoole_get_send_data(zdata, &http_body.str TSRMLS_CC);\n\n        if (length < 0)\n        {\n            RETURN_FALSE;\n        }\n        else\n        {\n            http_body.length = length;\n        }\n    }\n    else\n    {\n        http_body.length = 0;\n        http_body.str = NULL;\n    }\n\n    http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);\n    if (!ctx)\n    {\n        RETURN_FALSE;\n    }\n\n#ifdef SW_USE_HTTP2\n    if (ctx->http2)\n    {\n        swoole_http2_do_response(ctx, &http_body);\n        RETURN_TRUE;\n    }\n#endif\n\n    if (ctx->chunk)\n    {\n        ret = swServer_tcp_send(SwooleG.serv, ctx->fd, SW_STRL(\"0\\r\\n\\r\\n\") - 1);\n        if (ret < 0)\n        {\n            RETURN_FALSE;\n        }\n        ctx->chunk = 0;\n    }\n    //no http chunk\n    else\n    {\n        swString_clear(swoole_http_buffer);\n#ifdef SW_HAVE_ZLIB\n        if (ctx->gzip_enable)\n        {\n            if (http_body.length > 0)\n            {\n                http_response_compress(&http_body, ctx->gzip_level);\n            }\n            else\n            {\n                ctx->gzip_enable = 0;\n            }\n        }\n#endif\n        http_build_header(ctx, getThis(), swoole_http_buffer, http_body.length TSRMLS_CC);\n        if (http_body.length > 0)\n        {\n#ifdef SW_HAVE_ZLIB\n            if (ctx->gzip_enable)\n            {\n                swString_append(swoole_http_buffer, swoole_zlib_buffer);\n            }\n            else\n#endif\n            {\n                swString_append(swoole_http_buffer, &http_body);\n            }\n        }\n\n        ret = swServer_tcp_send(SwooleG.serv, ctx->fd, swoole_http_buffer->str, swoole_http_buffer->length);\n        if (ret < 0)\n        {\n            ctx->send_header = 0;\n            RETURN_FALSE;\n        }\n    }\n    if (!ctx->keepalive)\n    {\n        SwooleG.serv->factory.end(&SwooleG.serv->factory, ctx->fd);\n    }\n    swoole_http_context_free(ctx TSRMLS_CC);\n    RETURN_TRUE;\n}\n\nstatic PHP_METHOD(swoole_http_response, sendfile)\n{\n    char *filename;\n    zend_size_t filename_length;\n    int ret;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &filename, &filename_length) == FAILURE)\n    {\n        return;\n    }\n\n    if (filename_length <= 0)\n    {\n        swoole_php_error(E_WARNING, \"file name is empty.\");\n        RETURN_FALSE;\n    }\n\n    http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);\n    if (!ctx)\n    {\n        RETURN_FALSE;\n    }\n\n    if (ctx->chunk)\n    {\n        swoole_php_error(E_WARNING, \"cannot use HTTP-Chunk.\");\n        RETURN_FALSE;\n    }\n\n    int file_fd = open(filename, O_RDONLY);\n    if (file_fd < 0)\n    {\n        swoole_php_sys_error(E_WARNING, \"open(%s) failed.\", filename);\n        RETURN_FALSE;\n    }\n\n    struct stat file_stat;\n    if (fstat(file_fd, &file_stat) < 0)\n    {\n        swoole_php_sys_error(E_WARNING, \"fstat(%s) failed.\", filename);\n        RETURN_FALSE;\n    }\n\n    if (file_stat.st_size <= 0)\n    {\n        swoole_php_error(E_WARNING, \"file is empty.\");\n        RETURN_FALSE;\n    }\n\n    swString_clear(swoole_http_buffer);\n    http_build_header(ctx, getThis(), swoole_http_buffer, file_stat.st_size TSRMLS_CC);\n\n    ret = swServer_tcp_send(SwooleG.serv, ctx->fd, swoole_http_buffer->str, swoole_http_buffer->length);\n    if (ret < 0)\n    {\n        ctx->send_header = 0;\n        RETURN_FALSE;\n    }\n\n    ret = swServer_tcp_sendfile(SwooleG.serv, ctx->fd, filename, filename_length);\n    if (ret < 0)\n    {\n        ctx->send_header = 0;\n        RETURN_FALSE;\n    }\n    if (!ctx->keepalive)\n    {\n        SwooleG.serv->factory.end(&SwooleG.serv->factory, ctx->fd);\n    }\n    swoole_http_context_free(ctx TSRMLS_CC);\n    RETURN_TRUE;\n}\n\nstatic PHP_METHOD(swoole_http_response, cookie)\n{\n    char *name, *value = NULL, *path = NULL, *domain = NULL;\n    long expires = 0;\n    int encode = 1;\n    zend_bool secure = 0, httponly = 0;\n    zend_size_t name_len, value_len = 0, path_len = 0, domain_len = 0;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|slssbb\", &name, &name_len, &value, &value_len, &expires,\n                &path, &path_len, &domain, &domain_len, &secure, &httponly) == FAILURE)\n    {\n        return;\n    }\n\n    http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);\n    if (!ctx)\n    {\n        RETURN_FALSE;\n    }\n\n    zval *zcookie = ctx->response.zcookie;\n    zval *zresponse_object = ctx->response.zobject;\n    if (!zcookie)\n    {\n        swoole_http_server_array_init(cookie, response);\n    }\n\n    char *cookie, *encoded_value = NULL;\n    int len = 0;\n    char *dt;\n\n    if (name && strpbrk(name, \"=,; \\t\\r\\n\\013\\014\") != NULL)\n    {\n        swoole_php_error(E_WARNING, \"Cookie names cannot contain any of the following '=,; \\\\t\\\\r\\\\n\\\\013\\\\014'\");\n        RETURN_FALSE;\n    }\n\n    len += name_len;\n    if (encode && value)\n    {\n        int encoded_value_len;\n        encoded_value = sw_php_url_encode(value, value_len, &encoded_value_len);\n        len += encoded_value_len;\n    }\n    else if (value)\n    {\n        encoded_value = estrdup(value);\n        len += value_len;\n    }\n    if (path)\n    {\n        len += path_len;\n    }\n    if (domain)\n    {\n        len += domain_len;\n    }\n\n    cookie = emalloc(len + 100);\n\n    if (value && value_len == 0)\n    {\n        dt = sw_php_format_date(\"D, d-M-Y H:i:s T\", sizeof(\"D, d-M-Y H:i:s T\") - 1, 1, 0 TSRMLS_CC);\n        snprintf(cookie, len + 100, \"%s=deleted; expires=%s\", name, dt);\n        efree(dt);\n    }\n    else\n    {\n        snprintf(cookie, len + 100, \"%s=%s\", name, value ? encoded_value : \"\");\n        if (expires > 0)\n        {\n            const char *p;\n            strlcat(cookie, \"; expires=\", len + 100);\n            dt = sw_php_format_date(\"D, d-M-Y H:i:s T\", sizeof(\"D, d-M-Y H:i:s T\") - 1, expires, 0 TSRMLS_CC);\n            p = zend_memrchr(dt, '-', strlen(dt));\n            if (!p || *(p + 5) != ' ')\n            {\n                efree(dt);\n                efree(cookie);\n                efree(encoded_value);\n                swoole_php_error(E_WARNING, \"Expiry date cannot have a year greater than 9999\");\n                RETURN_FALSE;\n            }\n            strlcat(cookie, dt, len + 100);\n            efree(dt);\n        }\n    }\n    if (encoded_value)\n    {\n        efree(encoded_value);\n    }\n    if (path && path_len > 0)\n    {\n        strlcat(cookie, \"; path=\", len + 100);\n        strlcat(cookie, path, len + 100);\n    }\n    if (domain && domain_len > 0)\n    {\n        strlcat(cookie, \"; domain=\", len + 100);\n        strlcat(cookie, domain, len + 100);\n    }\n    if (secure)\n    {\n        strlcat(cookie, \"; secure\", len + 100);\n    }\n    if (httponly)\n    {\n        strlcat(cookie, \"; httponly\", len + 100);\n    }\n    sw_add_next_index_stringl(zcookie, cookie, strlen(cookie), 0);\n#if PHP_MAJOR_VERSION >= 7\n    efree(cookie);\n#endif\n}\n\nstatic PHP_METHOD(swoole_http_response, rawcookie)\n{\n    char *name, *value = NULL, *path = NULL, *domain = NULL;\n    long expires = 0;\n    int encode = 0;\n    zend_bool secure = 0, httponly = 0;\n    zend_size_t name_len, value_len = 0, path_len = 0, domain_len = 0;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|slssbb\", &name, &name_len, &value, &value_len, &expires,\n                &path, &path_len, &domain, &domain_len, &secure, &httponly) == FAILURE)\n    {\n        return;\n    }\n\n    http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);\n    if (!ctx)\n    {\n        RETURN_FALSE;\n    }\n\n    zval *zcookie = ctx->response.zcookie;\n    zval *zresponse_object = ctx->response.zobject;\n    if (!zcookie)\n    {\n        swoole_http_server_array_init(cookie, response);\n    }\n\n    char *cookie, *encoded_value = NULL;\n    int len = 0;\n    char *dt;\n\n    if (name && strpbrk(name, \"=,; \\t\\r\\n\\013\\014\") != NULL)\n    {\n        swoole_php_error(E_WARNING, \"Cookie names cannot contain any of the following '=,; \\\\t\\\\r\\\\n\\\\013\\\\014'\");\n        RETURN_FALSE;\n    }\n\n    len += name_len;\n    if (encode && value)\n    {\n        int encoded_value_len;\n        encoded_value = sw_php_url_encode(value, value_len, &encoded_value_len);\n        len += encoded_value_len;\n    }\n    else if (value)\n    {\n        encoded_value = estrdup(value);\n        len += value_len;\n    }\n    if (path)\n    {\n        len += path_len;\n    }\n    if (domain)\n    {\n        len += domain_len;\n    }\n\n    cookie = emalloc(len + 100);\n\n    if (value && value_len == 0)\n    {\n        dt = sw_php_format_date(\"D, d-M-Y H:i:s T\", sizeof(\"D, d-M-Y H:i:s T\") - 1, 1, 0 TSRMLS_CC);\n        snprintf(cookie, len + 100, \"%s=deleted; expires=%s\", name, dt);\n        efree(dt);\n    }\n    else\n    {\n        snprintf(cookie, len + 100, \"%s=%s\", name, value ? encoded_value : \"\");\n        if (expires > 0)\n        {\n            const char *p;\n            strlcat(cookie, \"; expires=\", len + 100);\n            dt = sw_php_format_date(\"D, d-M-Y H:i:s T\", sizeof(\"D, d-M-Y H:i:s T\") - 1, expires, 0 TSRMLS_CC);\n            p = zend_memrchr(dt, '-', strlen(dt));\n            if (!p || *(p + 5) != ' ')\n            {\n                efree(dt);\n                efree(cookie);\n                efree(encoded_value);\n                swoole_php_error(E_WARNING, \"Expiry date cannot have a year greater than 9999\");\n                RETURN_FALSE;\n            }\n            strlcat(cookie, dt, len + 100);\n            efree(dt);\n        }\n    }\n    if (encoded_value)\n    {\n        efree(encoded_value);\n    }\n    if (path && path_len > 0)\n    {\n        strlcat(cookie, \"; path=\", len + 100);\n        strlcat(cookie, path, len + 100);\n    }\n    if (domain && domain_len > 0)\n    {\n        strlcat(cookie, \"; domain=\", len + 100);\n        strlcat(cookie, domain, len + 100);\n    }\n    if (secure)\n    {\n        strlcat(cookie, \"; secure\", len + 100);\n    }\n    if (httponly)\n    {\n        strlcat(cookie, \"; httponly\", len + 100);\n    }\n    sw_add_next_index_stringl(zcookie, cookie, strlen(cookie), 0);\n#if PHP_MAJOR_VERSION >= 7\n    efree(cookie);\n#endif\n}\n\nstatic PHP_METHOD(swoole_http_response, status)\n{\n    long http_status;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &http_status) == FAILURE)\n    {\n        return;\n    }\n\n    http_context *client = http_get_context(getThis(), 0 TSRMLS_CC);\n    if (!client)\n    {\n        RETURN_FALSE;\n    }\n\n    client->response.status = http_status;\n}\n\nstatic PHP_METHOD(swoole_http_response, header)\n{\n    char *k, *v;\n    zend_size_t klen, vlen;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ss\", &k, &klen, &v, &vlen) == FAILURE)\n    {\n        return;\n    }\n\n    http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);\n    if (!ctx)\n    {\n        RETURN_FALSE;\n    }\n\n    zval *zheader = ctx->response.zheader;\n    zval *zresponse_object = ctx->response.zobject;\n    if (!zheader)\n    {\n        swoole_http_server_array_init(header, response);\n    }\n    if (klen > SW_HTTP_HEADER_KEY_SIZE - 1)\n    {\n        swoole_php_error(E_WARNING, \"header key is too long.\");\n        RETURN_FALSE;\n    }\n    if (vlen > SW_HTTP_HEADER_VALUE_SIZE)\n    {\n        swoole_php_error(E_WARNING, \"header value is too long.\");\n        RETURN_FALSE;\n    }\n    char key_buf[SW_HTTP_HEADER_KEY_SIZE];\n    memcpy(key_buf, k, klen);\n    key_buf[klen] = '\\0';\n    if (ctx->http2)\n    {\n        swoole_strtolower(key_buf, klen);\n    }\n    else\n    {\n        http_header_key_format(key_buf, klen);\n    }\n    sw_add_assoc_stringl_ex(zheader, key_buf, klen + 1, v, vlen, 1);\n}\n\n#ifdef SW_HAVE_ZLIB\nstatic PHP_METHOD(swoole_http_response, gzip)\n{\n    long level = Z_DEFAULT_COMPRESSION;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|l\", &level) == FAILURE)\n    {\n        return;\n    }\n\n    http_context *context = http_get_context(getThis(), 0 TSRMLS_CC);\n    if (!context)\n    {\n        RETURN_FALSE;\n    }\n\n    if (context->send_header)\n    {\n        swoole_php_fatal_error(E_WARNING, \"must use before send header.\");\n        RETURN_FALSE;\n    }\n\n    if (level > 9)\n    {\n        level = 9;\n    }\n    if (level < 0)\n    {\n        level = 0;\n    }\n\n    context->gzip_enable = 1;\n    context->gzip_level = level;\n}\n#endif\n\nstatic PHP_METHOD(swoole_http_response, __destruct)\n{\n    http_context *context = swoole_get_object(getThis());\n    if (context)\n    {\n        zval *zobject = getThis();\n        zval *retval = NULL;\n        sw_zend_call_method_with_0_params(&zobject, swoole_http_response_class_entry_ptr, NULL, \"end\", &retval);\n        if (retval)\n        {\n            sw_zval_ptr_dtor(&retval);\n        }\n    }\n}",
        "lookback": "  +----------------------------------------------------------------------+",
        "lookahead": "",
        "label": [
            "interleave",
            "complex_conflict"
        ],
        "start_line": 0,
        "end_line": 6873,
        "merge_gen_region": null,
        "confidence": 0.7366800308227539,
        "hesitated": true
    }
]