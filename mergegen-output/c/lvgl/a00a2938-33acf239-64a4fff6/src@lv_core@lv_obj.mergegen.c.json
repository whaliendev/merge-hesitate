[
    {
        "a_contents": "",
        "b_contents": "typedef struct {\n    lv_obj_t * obj;\n    lv_style_property_t prop;\n    uint8_t part;\n    union {\n        lv_color_t _color;\n        lv_style_int_t _int;\n        lv_opa_t _opa;\n        const void * _ptr;\n    } start_value;\n    union {\n        lv_color_t _color;\n        lv_style_int_t _int;\n        lv_opa_t _opa;\n        const void * _ptr;\n    } end_value;\n} lv_style_trans_t;\n\ntypedef struct {\n    lv_draw_rect_dsc_t rect;\n    lv_draw_label_dsc_t label;\n    lv_draw_line_dsc_t line;\n    lv_draw_img_dsc_t img;\n    lv_style_int_t pad_top;\n    lv_style_int_t pad_bottom;\n    lv_style_int_t pad_right;\n    lv_style_int_t pad_left;\n    lv_style_int_t pad_inner;\n    lv_style_int_t margin_top;\n    lv_style_int_t margin_bottom;\n    lv_style_int_t margin_left;\n    lv_style_int_t margin_right;\n    lv_style_int_t size;\n    lv_style_int_t transform_width;\n    lv_style_int_t transform_height;\n    lv_style_int_t transform_angle;\n    lv_style_int_t transform_zoom;\n    lv_style_int_t scale_width;\n    lv_style_int_t scale_border_width;\n    lv_style_int_t scale_end_border_width;\n    lv_style_int_t scale_end_line_width;\n    lv_color_t scale_grad_color;\n    lv_color_t scale_end_color;\n    lv_opa_t opa_scale;\n    uint32_t clip_corder : 1;\n    uint32_t border_post : 1;\n} style_snapshot_t;\n\ntypedef enum {\n    STYLE_COMPARE_SAME,\n    STYLE_COMPARE_VISUAL_DIFF,\n    STYLE_COMPARE_DIFF,\n} style_snapshot_res_t;\n",
        "base_contents": "typedef struct {\n    lv_obj_t * obj;\n    lv_style_property_t prop;\n    uint8_t part;\n    union {\n        lv_color_t _color;\n        lv_style_int_t _int;\n        lv_opa_t _opa;\n        const void * _ptr;\n    } start_value;\n    union {\n        lv_color_t _color;\n        lv_style_int_t _int;\n        lv_opa_t _opa;\n        const void * _ptr;\n    } end_value;\n} lv_style_trans_t;\n\ntypedef struct {\n    lv_draw_rect_dsc_t rect;\n    lv_draw_label_dsc_t label;\n    lv_draw_line_dsc_t line;\n    lv_draw_img_dsc_t img;\n    lv_style_int_t pad_top;\n    lv_style_int_t pad_bottom;\n    lv_style_int_t pad_right;\n    lv_style_int_t pad_left;\n    lv_style_int_t pad_inner;\n    lv_style_int_t margin_top;\n    lv_style_int_t margin_bottom;\n    lv_style_int_t margin_left;\n    lv_style_int_t margin_right;\n    lv_style_int_t size;\n    lv_style_int_t transform_width;\n    lv_style_int_t transform_height;\n    lv_style_int_t transform_angle;\n    lv_style_int_t transform_zoom;\n    lv_style_int_t scale_width;\n    lv_style_int_t scale_border_width;\n    lv_style_int_t scale_end_border_width;\n    lv_style_int_t scale_end_line_width;\n    lv_color_t scale_grad_color;\n    lv_color_t scale_end_color;\n    lv_opa_t opa_scale;\n    uint32_t clip_corder :1;\n    uint32_t border_post :1;\n}style_snapshot_t;\n\ntypedef enum {\n    STYLE_COMPARE_SAME,\n    STYLE_COMPARE_VISUAL_DIFF,\n    STYLE_COMPARE_DIFF,\n} style_snapshot_res_t;\n",
        "res_region": "",
        "lookback": " *  STATIC PROTOTYPES",
        "lookahead": "/**********************",
        "label": [
            "ours",
            "base_underutilized"
        ],
        "start_line": 61,
        "end_line": 172,
        "merge_gen_region": null,
        "confidence": 0.7724653482437134,
        "hesitated": true
    },
    {
        "a_contents": "static void base_dir_refr_children(lv_obj_t * obj);",
        "b_contents": "static void update_style_cache(lv_obj_t * obj, uint8_t part, uint16_t prop);\nstatic void update_style_cache_children(lv_obj_t * obj);\nstatic void invalidate_style_cache(lv_obj_t * obj, uint8_t part, lv_style_property_t prop);\nstatic void style_snapshot(lv_obj_t * obj, uint8_t part, style_snapshot_t * shot);\nstatic style_snapshot_res_t style_snapshot_compare(style_snapshot_t * shot1, style_snapshot_t * shot2);",
        "base_contents": "static void update_style_cache(lv_obj_t * obj, uint8_t part, uint16_t prop);\nstatic void update_style_cache_children(lv_obj_t * obj);\nstatic void invalidate_style_cache(lv_obj_t * obj, uint8_t part, lv_style_property_t prop);\n#if LV_USE_ANIMATION\nstatic void style_snapshot(lv_obj_t * obj, uint8_t part, style_snapshot_t * shot);\nstatic style_snapshot_res_t style_snapshot_compare(style_snapshot_t * shot1, style_snapshot_t * shot2);\n#endif",
        "res_region": "static void base_dir_refr_children(lv_obj_t * obj);",
        "lookback": "",
        "lookahead": "",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 182,
        "end_line": 198,
        "merge_gen_region": null,
        "confidence": 0.6803661584854126,
        "hesitated": true
    },
    {
        "a_contents": "",
        "b_contents": "    obj_align_core(obj, base, align, false, true, 0, y_ofs);",
        "base_contents": "    obj_align_core(obj, base, align, true, false, 0, y_ofs);",
        "res_region": "",
        "lookback": "",
        "lookahead": "}",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 916,
        "end_line": 921,
        "merge_gen_region": null,
        "confidence": 0.7442963719367981,
        "hesitated": true
    },
    {
        "a_contents": "    obj->event_cb = event_cb;",
        "b_contents": "    if(base == NULL) {\n        base = lv_obj_get_parent(obj);\n    }\n\n    LV_ASSERT_OBJ(base, LV_OBJX_NAME);\n\n\n    obj_align_mid_core(obj, base, align, false, true, 0, y_ofs);",
        "base_contents": "    if(base == NULL) {\n        base = lv_obj_get_parent(obj);\n    }\n\n    LV_ASSERT_OBJ(base, LV_OBJX_NAME);\n\n\n    obj_align_mid_core(obj, base, align, true, false, 0, y_ofs);",
        "res_region": "    obj->event_cb = event_cb;",
        "lookback": "}",
        "lookahead": "}",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 970,
        "end_line": 990,
        "merge_gen_region": null,
        "confidence": 0.5897398591041565,
        "hesitated": true
    },
    {
        "a_contents": "    _LV_LL_READ(obj->child_ll, i) {\n        cnt++;                                     /*Count the child*/\n        cnt += lv_obj_count_children_recursive(i); /*recursively count children's children*/",
        "b_contents": "/**\n * Set the directions an object can be dragged in\n * @param obj pointer to an object\n * @param drag_dir bitwise OR of allowed directions an object can be dragged in\n */\nvoid lv_obj_set_drag_dir(lv_obj_t * obj, lv_drag_dir_t drag_dir)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->drag_dir = drag_dir;\n\n    if(obj->drag_dir != 0) lv_obj_set_drag(obj, true); /*Drag direction requires drag*/\n}\n\n/**\n * Enable the throwing of an object after is is dragged\n * @param obj pointer to an object\n * @param en true: enable the drag throw\n */\nvoid lv_obj_set_drag_throw(lv_obj_t * obj, bool en)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->drag_throw = (en == true ? 1 : 0);\n}\n\n/**\n * Enable to use parent for drag related operations.\n * If trying to drag the object the parent will be moved instead\n * @param obj pointer to an object\n * @param en true: enable the 'drag parent' for the object\n */\nvoid lv_obj_set_drag_parent(lv_obj_t * obj, bool en)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->drag_parent = (en == true ? 1 : 0);\n}\n\n/**\n* Enable to use parent for gesture related operations.\n* If trying to gesture the object the parent will be moved instead\n* @param obj pointer to an object\n* @param en true: enable the 'gesture parent' for the object\n*/\nvoid lv_obj_set_gesture_parent(lv_obj_t * obj, bool en)\n{\n    obj->gesture_parent = (en == true ? 1 : 0);\n}\n\n/**\n* Enable to use parent for focus state.\n* When object is focused the parent will get the state instead (visual only)\n* @param obj pointer to an object\n* @param en true: enable the 'focus parent' for the object\n*/\nvoid lv_obj_set_focus_parent(lv_obj_t * obj, bool en)\n{\n    if(lv_obj_is_focused(obj)) {\n        if(en) {\n            obj->focus_parent = 1;\n            lv_obj_clear_state(obj, LV_STATE_FOCUSED | LV_STATE_EDITED);\n            lv_obj_set_state(lv_obj_get_focused_obj(obj), LV_STATE_FOCUSED);\n        }\n        else {\n            lv_obj_clear_state(lv_obj_get_focused_obj(obj), LV_STATE_FOCUSED | LV_STATE_EDITED);\n            lv_obj_set_state(obj, LV_STATE_FOCUSED);\n            obj->focus_parent = 0;\n        }\n    }\n    else {\n        obj->focus_parent = (en == true ? 1 : 0);\n    }\n}\n\n/**\n * Propagate the events to the parent too\n * @param obj pointer to an object\n * @param en true: enable the event propagation\n */\nvoid lv_obj_set_parent_event(lv_obj_t * obj, bool en)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->parent_event = (en == true ? 1 : 0);\n}\n\n/**\n * Set the base direction of the object\n * @param obj pointer to an object\n * @param dir the new base direction. `LV_BIDI_DIR_LTR/RTL/AUTO/INHERIT`\n */\nvoid lv_obj_set_base_dir(lv_obj_t * obj, lv_bidi_dir_t dir)\n{\n    if(dir != LV_BIDI_DIR_LTR && dir != LV_BIDI_DIR_RTL &&\n       dir != LV_BIDI_DIR_AUTO && dir != LV_BIDI_DIR_INHERIT) {\n\n        LV_LOG_WARN(\"lv_obj_set_base_dir: invalid base dir\");\n        return;\n    }\n\n    obj->base_dir = dir;\n    lv_signal_send(obj, LV_SIGNAL_BASE_DIR_CHG, NULL);\n\n    /* Notify the children about the parent base dir has changed.\n     * (The children might have `LV_BIDI_DIR_INHERIT`)*/\n    base_dir_refr_children(obj);\n}\n\n/**\n * Set a bit or bits in the protect filed\n * @param obj pointer to an object\n * @param prot 'OR'-ed values from `lv_protect_t`\n */\nvoid lv_obj_add_protect(lv_obj_t * obj, uint8_t prot)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->protect |= prot;\n}\n\n/**\n * Clear a bit or bits in the protect filed\n * @param obj pointer to an object\n * @param prot 'OR'-ed values from `lv_protect_t`\n */\nvoid lv_obj_clear_protect(lv_obj_t * obj, uint8_t prot)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    prot = (~prot) & 0xFF;\n    obj->protect &= prot;\n}\n\n/**\n * Set the state (fully overwrite) of an object.\n * If specified in the styles a transition animation will be started\n * from the previous state to the current\n * @param obj pointer to an object\n * @param state the new state\n */\nvoid lv_obj_set_state(lv_obj_t * obj, lv_state_t new_state)\n{\n    if(obj->state == new_state) return;\n\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_state_t prev_state = obj->state;\n    style_snapshot_res_t cmp_res = STYLE_COMPARE_SAME;\n    uint8_t part;\n    for(part = 0; part < _LV_OBJ_PART_REAL_FIRST; part++) {\n        lv_style_list_t * style_list = lv_obj_get_style_list(obj, part);\n        if(style_list == NULL) break;   /*No more style lists*/\n        obj->state = prev_state;\n        style_snapshot_t shot_pre;\n        style_snapshot(obj, part, &shot_pre);\n        obj->state = new_state;\n        style_snapshot_t shot_post;\n        style_snapshot(obj, part, &shot_post);\n\n        style_snapshot_res_t r = style_snapshot_compare(&shot_pre, &shot_post);\n        if(r == STYLE_COMPARE_DIFF) {\n            cmp_res = STYLE_COMPARE_DIFF;\n            break;\n        }\n        if(r == STYLE_COMPARE_VISUAL_DIFF) {\n            cmp_res = STYLE_COMPARE_VISUAL_DIFF;\n        }\n    }\n\n    obj->state = new_state;\n\n    if(cmp_res == STYLE_COMPARE_SAME) return;\n\n#if LV_USE_ANIMATION == 0\n    if(cmp_res == STYLE_COMPARE_DIFF) lv_obj_refresh_style(obj, part, LV_STYLE_PROP_ALL);\n    else if(cmp_res == STYLE_COMPARE_VISUAL_DIFF) lv_obj_refresh_style(obj, LV_OBJ_PART_ALL, LV_STYLE_PROP_ALL);\n#else\n\n    for(part = 0; part < _LV_OBJ_PART_REAL_LAST; part++) {\n        lv_style_list_t * style_list = lv_obj_get_style_list(obj, part);\n        if(style_list == NULL) break;   /*No more style lists*/\n        if(style_list->ignore_trans) continue;\n\n        lv_style_int_t time = lv_obj_get_style_transition_time(obj, part);\n        lv_style_property_t props[LV_STYLE_TRANS_NUM_MAX];\n        lv_style_int_t delay = lv_obj_get_style_transition_delay(obj, part);\n        lv_anim_path_t * path = lv_obj_get_style_transition_path(obj, part);\n        props[0] = lv_obj_get_style_transition_prop_1(obj, part);\n        props[1] = lv_obj_get_style_transition_prop_2(obj, part);\n        props[2] = lv_obj_get_style_transition_prop_3(obj, part);\n        props[3] = lv_obj_get_style_transition_prop_4(obj, part);\n        props[4] = lv_obj_get_style_transition_prop_5(obj, part);\n        props[5] = lv_obj_get_style_transition_prop_6(obj, part);\n\n        uint8_t i;\n        for(i = 0; i < LV_STYLE_TRANS_NUM_MAX; i++) {\n            if(props[i] != 0) {\n                _lv_style_list_add_trans_style(style_list);\n\n                lv_style_trans_t * tr = trans_create(obj, props[i], part, prev_state, new_state);\n\n                /*If there is a pending anim for this property remove it*/\n                if(tr) {\n                    tr->obj = obj;\n                    tr->prop = props[i];\n                    tr->part = part;\n\n                    lv_anim_t a;\n                    lv_anim_init(&a);\n                    lv_anim_set_var(&a, tr);\n                    lv_anim_set_exec_cb(&a, (lv_anim_exec_xcb_t)trans_anim_cb);\n                    lv_anim_set_start_cb(&a, trans_anim_start_cb);\n                    lv_anim_set_ready_cb(&a, trans_anim_ready_cb);\n                    lv_anim_set_values(&a, 0x00, 0xFF);\n                    lv_anim_set_time(&a, time);\n                    lv_anim_set_delay(&a, delay);\n                    lv_anim_set_path(&a, path);\n                    a.early_apply = 0;\n                    lv_anim_start(&a);\n                }\n\n            }\n        }\n        if(cmp_res == STYLE_COMPARE_DIFF) lv_obj_refresh_style(obj, part, LV_STYLE_PROP_ALL);\n    }\n    if(cmp_res == STYLE_COMPARE_VISUAL_DIFF) lv_obj_invalidate(obj);\n#endif\n\n}\n\n/**\n * Add a given state or states to the object. The other state bits will remain unchanged.\n * If specified in the styles a transition animation will be started\n * from the previous state to the current\n * @param obj pointer to an object\n * @param state the state bits to add. E.g `LV_STATE_PRESSED | LV_STATE_FOCUSED`\n */\nvoid lv_obj_add_state(lv_obj_t * obj, lv_state_t state)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_state_t new_state = obj->state | state;\n    if(obj->state != new_state) {\n        lv_obj_set_state(obj, new_state);\n    }\n}\n\n/**\n * Remove a given state or states to the object. The other state bits will remain unchanged.\n * If specified in the styles a transition animation will be started\n * from the previous state to the current\n * @param obj pointer to an object\n * @param state the state bits to remove. E.g `LV_STATE_PRESSED | LV_STATE_FOCUSED`\n */\nvoid lv_obj_clear_state(lv_obj_t * obj, lv_state_t state)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_state_t new_state = obj->state & (~state);\n    if(obj->state != new_state) {\n        lv_obj_set_state(obj, new_state);\n    }\n}\n\n#if LV_USE_ANIMATION\n/**\n * Finish all pending transitions on a part of an object\n * @param obj pointer to an object\n * @param part part of the object, e.g `LV_BRN_PART_MAIN` or `LV_OBJ_PART_ALL` for all parts\n */\nvoid lv_obj_finish_transitions(lv_obj_t * obj, uint8_t part)\n{\n    /*Animate all related transition to the end value*/\n    lv_style_trans_t * tr;\n    _LV_LL_READ_BACK(LV_GC_ROOT(_lv_obj_style_trans_ll), tr) {\n        if(tr->obj == obj && (part == tr->part || part == LV_OBJ_PART_ALL)) {\n            trans_anim_cb(tr, 255);\n        }\n    }\n\n    /*Free all related transition data*/\n    trans_del(obj, part, 0xFF, NULL);\n}\n#endif\n\n/**\n * Set a an event handler function for an object.\n * Used by the user to react on event which happens with the object.\n * @param obj pointer to an object\n * @param event_cb the new event function\n */\nvoid lv_obj_set_event_cb(lv_obj_t * obj, lv_event_cb_t event_cb)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->event_cb = event_cb;\n}\n\n/**\n * Send an event to the object\n * @param obj pointer to an object\n * @param event the type of the event from `lv_event_t`\n * @param data arbitrary data depending on the object type and the event. (Usually `NULL`)\n * @return LV_RES_OK: `obj` was not deleted in the event; LV_RES_INV: `obj` was deleted in the event\n */\nlv_res_t lv_event_send(lv_obj_t * obj, lv_event_t event, const void * data)\n{\n    if(obj == NULL) return LV_RES_OK;\n\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_res_t res;\n    res = lv_event_send_func(obj->event_cb, obj, event, data);\n    return res;\n}\n\n/**\n * Send LV_EVENT_REFRESH event to an object\n * @param obj point to an obejct. (Can NOT be NULL)\n * @return LV_RES_OK: success, LV_RES_INV: to object become invalid (e.g. deleted) due to this event.\n */\nlv_res_t lv_event_send_refresh(lv_obj_t * obj)\n{\n    return lv_event_send(obj, LV_EVENT_REFRESH, NULL);\n}\n\n/**\n * Send LV_EVENT_REFRESH event to an object and all of its children.\n * @param obj pointer to an object or NULL to refresh all objects of all displays\n */\nvoid lv_event_send_refresh_recursive(lv_obj_t * obj)\n{\n    if(obj == NULL) {\n        /*If no obj specified refresh all screen of all displays */\n        lv_disp_t * d = lv_disp_get_next(NULL);\n        while(d) {\n            lv_obj_t * scr = _lv_ll_get_head(&d->scr_ll);\n            while(scr) {\n                lv_event_send_refresh_recursive(scr);\n                scr = _lv_ll_get_next(&d->scr_ll, scr);\n            }\n            lv_event_send_refresh_recursive(d->top_layer);\n            lv_event_send_refresh_recursive(d->sys_layer);\n\n            d = lv_disp_get_next(d);\n        }\n    }\n    else {\n\n        lv_res_t res = lv_event_send_refresh(obj);\n        if(res != LV_RES_OK) return; /*If invalid returned do not check the children*/\n\n        lv_obj_t * child = lv_obj_get_child(obj, NULL);\n        while(child) {\n            lv_event_send_refresh_recursive(child);\n\n            child = lv_obj_get_child(obj, child);\n        }\n    }\n}\n\n\n/**\n * Call an event function with an object, event, and data.\n * @param event_xcb an event callback function. If `NULL` `LV_RES_OK` will return without any actions.\n *        (the 'x' in the argument name indicates that its not a fully generic function because it not follows\n *         the `func_name(object, callback, ...)` convention)\n * @param obj pointer to an object to associate with the event (can be `NULL` to simply call the `event_cb`)\n * @param event an event\n * @param data pointer to a custom data\n * @return LV_RES_OK: `obj` was not deleted in the event; LV_RES_INV: `obj` was deleted in the event\n */\nlv_res_t lv_event_send_func(lv_event_cb_t event_xcb, lv_obj_t * obj, lv_event_t event, const void * data)\n{\n    if(obj != NULL) {\n        LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n    }\n\n    /* Build a simple linked list from the objects used in the events\n     * It's important to know if an this object was deleted by a nested event\n     * called from this `even_cb`. */\n    lv_event_temp_data_t event_temp_data;\n    event_temp_data.obj     = obj;\n    event_temp_data.deleted = false;\n    event_temp_data.prev    = NULL;\n\n    if(event_temp_data_head) {\n        event_temp_data.prev = event_temp_data_head;\n    }\n    event_temp_data_head = &event_temp_data;\n\n    const void * event_act_data_save = event_act_data;\n    event_act_data                   = data;\n\n    /*Call the input device's feedback callback if set*/\n    lv_indev_t * indev_act = lv_indev_get_act();\n    if(indev_act) {\n        if(indev_act->driver.feedback_cb) indev_act->driver.feedback_cb(&indev_act->driver, event);\n    }\n\n    /*Call the event callback itself*/\n    if(event_xcb) event_xcb(obj, event);\n\n    /*Restore the event data*/\n    event_act_data = event_act_data_save;\n\n    /*Remove this element from the list*/\n    event_temp_data_head = event_temp_data_head->prev;\n\n    if(event_temp_data.deleted) {\n        return LV_RES_INV;\n    }\n\n    if(obj) {\n        if(obj->parent_event && obj->parent) {\n            lv_res_t res = lv_event_send(obj->parent, event, data);\n            if(res != LV_RES_OK) {\n                return LV_RES_INV;\n            }\n        }\n    }\n\n    return LV_RES_OK;\n}\n\n/**\n * Get the `data` parameter of the current event\n * @return the `data` parameter\n */\nconst void * lv_event_get_data(void)\n{\n    return event_act_data;\n}\n\n/**\n * Set the a signal function of an object. Used internally by the library.\n * Always call the previous signal function in the new.\n * @param obj pointer to an object\n * @param cb the new signal function\n */\nvoid lv_obj_set_signal_cb(lv_obj_t * obj, lv_signal_cb_t signal_cb)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->signal_cb = signal_cb;\n}\n\n/**\n * Send an event to the object\n * @param obj pointer to an object\n * @param event the type of the event from `lv_event_t`.\n * @return LV_RES_OK or LV_RES_INV\n */\nlv_res_t lv_signal_send(lv_obj_t * obj, lv_signal_t signal, void * param)\n{\n    if(obj == NULL) return LV_RES_OK;\n\n    lv_res_t res = LV_RES_OK;\n    if(obj->signal_cb) res = obj->signal_cb(obj, signal, param);\n\n    return res;\n}\n\n/**\n * Set a new design function for an object\n * @param obj pointer to an object\n * @param design_cb the new design function\n */\nvoid lv_obj_set_design_cb(lv_obj_t * obj, lv_design_cb_t design_cb)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->design_cb = design_cb;\n}\n\n/*----------------\n * Other set\n *--------------*/\n\n/**\n * Allocate a new ext. data for an object\n * @param obj pointer to an object\n * @param ext_size the size of the new ext. data\n * @return pointer to the allocated ext.\n * If out of memory NULL is returned and the original ext is preserved\n */\nvoid * lv_obj_allocate_ext_attr(lv_obj_t * obj, uint16_t ext_size)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    void * new_ext = lv_mem_realloc(obj->ext_attr, ext_size);\n    if(new_ext == NULL) return NULL;\n\n    obj->ext_attr = new_ext;\n    return (void *)obj->ext_attr;\n}\n\n/**\n * Send a 'LV_SIGNAL_REFR_EXT_SIZE' signal to the object to refresh the extended draw area.\n * he object needs to be invalidated by `lv_obj_invalidate(obj)` manually after this function.\n * @param obj pointer to an object\n */\nvoid lv_obj_refresh_ext_draw_pad(lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->ext_draw_pad = 0;\n    obj->signal_cb(obj, LV_SIGNAL_REFR_EXT_DRAW_PAD, NULL);\n\n}\n\n/*=======================\n * Getter functions\n *======================*/\n\n/**\n * Return with the screen of an object\n * @param obj pointer to an object\n * @return pointer to a screen\n */\nlv_obj_t * lv_obj_get_screen(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    const lv_obj_t * par = obj;\n    const lv_obj_t * act_p;\n\n    do {\n        act_p = par;\n        par   = lv_obj_get_parent(act_p);\n    } while(par != NULL);\n\n    return (lv_obj_t *)act_p;\n}\n\n/**\n * Get the display of an object\n * @param scr pointer to an object\n * @return pointer the object's display\n */\nlv_disp_t * lv_obj_get_disp(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    const lv_obj_t * scr;\n\n    if(obj->parent == NULL)\n        scr = obj; /*`obj` is a screen*/\n    else\n        scr = lv_obj_get_screen(obj); /*get the screen of `obj`*/\n\n    lv_disp_t * d;\n    _LV_LL_READ(LV_GC_ROOT(_lv_disp_ll), d) {\n        lv_obj_t * s;\n        _LV_LL_READ(d->scr_ll, s) {\n            if(s == scr) return d;\n        }\n    }\n\n    LV_LOG_WARN(\"lv_scr_get_disp: screen not found\")\n    return NULL;\n}\n\n/*---------------------\n * Parent/children get\n *--------------------*/\n\n/**\n * Returns with the parent of an object\n * @param obj pointer to an object\n * @return pointer to the parent of  'obj'\n */\nlv_obj_t * lv_obj_get_parent(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return obj->parent;\n}\n\n/**\n * Iterate through the children of an object (start from the \"youngest\")\n * @param obj pointer to an object\n * @param child NULL at first call to get the next children\n *                  and the previous return value later\n * @return the child after 'act_child' or NULL if no more child\n */\nlv_obj_t * lv_obj_get_child(const lv_obj_t * obj, const lv_obj_t * child)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_obj_t * result = NULL;\n\n    if(child == NULL) {\n        result = _lv_ll_get_head(&obj->child_ll);\n    }\n    else {\n        result = _lv_ll_get_next(&obj->child_ll, child);\n    }\n\n    return result;\n}\n\n/**\n * Iterate through the children of an object (start from the \"oldest\")\n * @param obj pointer to an object\n * @param child NULL at first call to get the next children\n *                  and the previous return value later\n * @return the child after 'act_child' or NULL if no more child\n */\nlv_obj_t * lv_obj_get_child_back(const lv_obj_t * obj, const lv_obj_t * child)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_obj_t * result = NULL;\n\n    if(child == NULL) {\n        result = _lv_ll_get_tail(&obj->child_ll);\n    }\n    else {\n        result = _lv_ll_get_prev(&obj->child_ll, child);\n    }\n\n    return result;\n}\n\n/**\n * Count the children of an object (only children directly on 'obj')\n * @param obj pointer to an object\n * @return children number of 'obj'\n */\nuint16_t lv_obj_count_children(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_obj_t * i;\n    uint16_t cnt = 0;\n\n    _LV_LL_READ(obj->child_ll, i) cnt++;\n\n    return cnt;\n}\n\n/** Recursively count the children of an object\n * @param obj pointer to an object\n * @return children number of 'obj'\n */\nuint16_t lv_obj_count_children_recursive(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_obj_t * i;\n    uint16_t cnt = 0;\n\n    _LV_LL_READ(obj->child_ll, i) {\n        cnt++;                                     /*Count the child*/\n        cnt += lv_obj_count_children_recursive(i); /*recursively count children's children*/\n    }\n\n    return cnt;\n}\n\n/*---------------------\n * Coordinate get\n *--------------------*/\n\n/**\n * Copy the coordinates of an object to an area\n * @param obj pointer to an object\n * @param cords_p pointer to an area to store the coordinates\n */\nvoid lv_obj_get_coords(const lv_obj_t * obj, lv_area_t * cords_p)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_area_copy(cords_p, &obj->coords);\n}\n\n/**\n * Reduce area retried by `lv_obj_get_coords()` the get graphically usable area of an object.\n * (Without the size of the border or other extra graphical elements)\n * @param coords_p store the result area here\n */\nvoid lv_obj_get_inner_coords(const lv_obj_t * obj, lv_area_t * coords_p)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_border_side_t part = lv_obj_get_style_border_side(obj, LV_OBJ_PART_MAIN);\n    lv_coord_t w = lv_obj_get_style_border_width(obj, LV_OBJ_PART_MAIN);\n\n    if(part & LV_BORDER_SIDE_LEFT) coords_p->x1 += w;\n\n    if(part & LV_BORDER_SIDE_RIGHT) coords_p->x2 -= w;\n\n    if(part & LV_BORDER_SIDE_TOP) coords_p->y1 += w;\n\n    if(part & LV_BORDER_SIDE_BOTTOM) coords_p->y2 -= w;\n}\n\n/**\n * Get the x coordinate of object\n * @param obj pointer to an object\n * @return distance of 'obj' from the left side of its parent\n */\nlv_coord_t lv_obj_get_x(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_coord_t rel_x;\n    lv_obj_t * parent = lv_obj_get_parent(obj);\n    if(parent) {\n        rel_x             = obj->coords.x1 - parent->coords.x1;\n    }\n    else {\n        rel_x = obj->coords.x1;\n    }\n    return rel_x;\n}\n\n/**\n * Get the y coordinate of object\n * @param obj pointer to an object\n * @return distance of 'obj' from the top of its parent\n */\nlv_coord_t lv_obj_get_y(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_coord_t rel_y;\n    lv_obj_t * parent = lv_obj_get_parent(obj);\n    if(parent) {\n        rel_y             = obj->coords.y1 - parent->coords.y1;\n    }\n    else {\n        rel_y = obj->coords.y1;\n    }\n    return rel_y;\n}\n\n/**\n * Get the width of an object\n * @param obj pointer to an object\n * @return the width\n */\nlv_coord_t lv_obj_get_width(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return lv_area_get_width(&obj->coords);\n}\n\n/**\n * Get the height of an object\n * @param obj pointer to an object\n * @return the height\n */\nlv_coord_t lv_obj_get_height(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return lv_area_get_height(&obj->coords);\n}\n\n/**\n * Get that width reduced by the left and right padding.\n * @param obj pointer to an object\n * @return the width which still fits into the container\n */\nlv_coord_t lv_obj_get_width_fit(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_style_int_t left = lv_obj_get_style_pad_left(obj, LV_OBJ_PART_MAIN);\n    lv_style_int_t right = lv_obj_get_style_pad_right(obj, LV_OBJ_PART_MAIN);\n\n    return lv_obj_get_width(obj) - left - right;\n}\n\n/**\n * Get that height reduced by the top an bottom padding.\n * @param obj pointer to an object\n * @return the height which still fits into the container\n */\nlv_coord_t lv_obj_get_height_fit(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_style_int_t top = lv_obj_get_style_pad_top((lv_obj_t *)obj, LV_OBJ_PART_MAIN);\n    lv_style_int_t bottom =  lv_obj_get_style_pad_bottom((lv_obj_t *)obj, LV_OBJ_PART_MAIN);\n\n    return lv_obj_get_height(obj) - top - bottom;\n}\n\n/**\n * Get the height of an object by taking the top and bottom margin into account.\n * The returned height will be `obj_h + margin_top + margin_bottom`\n * @param obj pointer to an object\n * @return the height including thee margins\n */\nlv_coord_t lv_obj_get_height_margin(lv_obj_t * obj)\n{\n    lv_style_int_t mtop = lv_obj_get_style_margin_top(obj, LV_OBJ_PART_MAIN);\n    lv_style_int_t mbottom = lv_obj_get_style_margin_bottom(obj, LV_OBJ_PART_MAIN);\n\n    return lv_obj_get_height(obj) + mtop + mbottom;\n}\n\n/**\n * Get the width of an object by taking the left and right margin into account.\n * The returned width will be `obj_w + margin_left + margin_right`\n * @param obj pointer to an object\n * @return the height including thee margins\n */\nlv_coord_t lv_obj_get_width_margin(lv_obj_t * obj)\n{\n    lv_style_int_t mleft = lv_obj_get_style_margin_left(obj, LV_OBJ_PART_MAIN);\n    lv_style_int_t mright = lv_obj_get_style_margin_right(obj, LV_OBJ_PART_MAIN);\n\n    return lv_obj_get_width(obj) + mleft + mright;\n}\n\n/**\n * Set that width reduced by the left and right padding of the parent.\n * @param obj pointer to an object\n * @param div indicates how many columns are assumed.\n * If 1 the width will be set the the parent's width\n * If 2 only half parent width - inner padding of the parent\n * If 3 only third parent width - 2 * inner padding of the parent\n * @param span how many columns are combined\n * @return the width according to the given parameters\n */\nlv_coord_t lv_obj_get_width_grid(lv_obj_t * obj, uint8_t div, uint8_t span)\n{\n    lv_coord_t obj_w = lv_obj_get_width_fit(obj);\n    lv_style_int_t pinner = lv_obj_get_style_pad_inner(obj, LV_OBJ_PART_MAIN);\n\n    lv_coord_t r = (obj_w - (div - 1) * pinner) / div;\n\n    r = r * span + (span - 1) * pinner;\n    return r;\n}\n\n/**\n * Get that height reduced by the top and bottom padding of the parent.\n * @param obj pointer to an object\n * @param div indicates how many rows are assumed.\n * If 1 the height will be set the the parent's height\n * If 2 only half parent height - inner padding of the parent\n * If 3 only third parent height - 2 * inner padding of the parent\n * @param span how many rows are combined\n * @return the height according to the given parameters\n */\nlv_coord_t lv_obj_get_height_grid(lv_obj_t * obj, uint8_t div, uint8_t span)\n{\n    lv_coord_t obj_h = lv_obj_get_height_fit(obj);\n    lv_style_int_t pinner = lv_obj_get_style_pad_inner(obj, LV_OBJ_PART_MAIN);\n\n    lv_coord_t r = (obj_h - (div - 1) * pinner) / div;\n\n    r = r * span + (span - 1) * pinner;\n    return r;\n}\n\n/**\n * Get the automatic realign property of the object.\n * @param obj pointer to an object\n * @return  true: auto realign is enabled; false: auto realign is disabled\n */\nbool lv_obj_get_auto_realign(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_OBJ_REALIGN\n    return obj->realign.auto_realign ? true : false;\n#else\n    (void)obj;\n    return false;\n#endif\n}\n\n/**\n * Get the left padding of extended clickable area\n * @param obj pointer to an object\n * @return the extended left padding\n */\nlv_coord_t lv_obj_get_ext_click_pad_left(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_TINY\n    return obj->ext_click_pad_hor;\n#elif LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_FULL\n    return obj->ext_click_pad.x1;\n#else\n    (void)obj;    /*Unused*/\n    return 0;\n#endif\n}\n\n/**\n * Get the right padding of extended clickable area\n * @param obj pointer to an object\n * @return the extended right padding\n */\nlv_coord_t lv_obj_get_ext_click_pad_right(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_TINY\n    return obj->ext_click_pad_hor;\n#elif LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_FULL\n    return obj->ext_click_pad.x2;\n#else\n    (void)obj; /*Unused*/\n    return 0;\n#endif\n}\n\n/**\n * Get the top padding of extended clickable area\n * @param obj pointer to an object\n * @return the extended top padding\n */\nlv_coord_t lv_obj_get_ext_click_pad_top(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_TINY\n    return obj->ext_click_pad_ver;\n#elif LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_FULL\n    return obj->ext_click_pad.y1;\n#else\n    (void)obj; /*Unused*/\n    return 0;\n#endif\n}\n\n/**\n * Get the bottom padding of extended clickable area\n * @param obj pointer to an object\n * @return the extended bottom padding\n */\nlv_coord_t lv_obj_get_ext_click_pad_bottom(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_TINY\n    return obj->ext_click_pad_ver;\n#elif LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_FULL\n    return obj->ext_click_pad.y2;\n#else\n    (void)obj; /*Unused*/\n    return 0;\n#endif\n}\n\n/**\n * Get the extended size attribute of an object\n * @param obj pointer to an object\n * @return the extended size attribute\n */\nlv_coord_t lv_obj_get_ext_draw_pad(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return obj->ext_draw_pad;\n}\n\n/*-----------------\n * Appearance get\n *---------------*/\n\nlv_style_list_t * lv_obj_get_style_list(const lv_obj_t * obj, uint8_t part)\n{\n    if(part == LV_OBJ_PART_MAIN) return &((lv_obj_t *)obj)->style_list;\n\n    lv_get_style_info_t info;\n    info.part = part;\n    info.result = NULL;\n\n    lv_res_t res;\n    res = lv_signal_send((lv_obj_t *)obj, LV_SIGNAL_GET_STYLE, &info);\n\n    if(res != LV_RES_OK) return NULL;\n\n    return info.result;\n}\n\n/**\n * Get a style property of a part of an object in the object's current state.\n * If there is a running transitions it is taken into account\n * @param obj pointer to an object\n * @param part the part of the object which style property should be get.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop the property to get. E.g. `LV_STYLE_BORDER_WIDTH`.\n *  The state of the object will be added internally\n * @return the value of the property of the given part in the current state.\n * If the property is not found a default value will be returned.\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_width()`\n * @note for performance reasons it's not checked if the property really has integer type\n */\nlv_style_int_t _lv_obj_get_style_int(const lv_obj_t * obj, uint8_t part, lv_style_property_t prop)\n{\n    lv_style_property_t prop_ori = prop;\n\n    lv_style_attr_t attr;\n    attr = prop_ori >> 8;\n\n    lv_style_int_t value_act;\n    lv_res_t res = LV_RES_INV;\n    const lv_obj_t * parent = obj;\n    while(parent) {\n        lv_style_list_t * list = lv_obj_get_style_list(parent, part);\n        if(!list->ignore_cache && list->style_cnt > 0) {\n            if(!list->valid_cache) update_style_cache((lv_obj_t *)parent, part, prop  & (~LV_STYLE_STATE_MASK));\n\n            bool def = false;\n            switch(prop  & (~LV_STYLE_STATE_MASK)) {\n                case LV_STYLE_BG_GRAD_DIR:\n                    if(list->bg_grad_dir_none) def = true;\n                    break;\n                case LV_STYLE_CLIP_CORNER:\n                    if(list->clip_corner_off) def = true;\n                    break;\n                case LV_STYLE_TEXT_LETTER_SPACE:\n                case LV_STYLE_TEXT_LINE_SPACE:\n                    if(list->text_space_zero) def = true;\n                    break;\n                case LV_STYLE_TRANSFORM_ANGLE:\n                case LV_STYLE_TRANSFORM_WIDTH:\n                case LV_STYLE_TRANSFORM_HEIGHT:\n                case LV_STYLE_TRANSFORM_ZOOM:\n                    if(list->transform_all_zero) def = true;\n                    break;\n                case LV_STYLE_BORDER_WIDTH:\n                    if(list->border_width_zero) def = true;\n                    break;\n                case LV_STYLE_BORDER_SIDE:\n                    if(list->border_side_full) def = true;\n                    break;\n                case LV_STYLE_BORDER_POST:\n                    if(list->border_post_off) def = true;\n                    break;\n                case LV_STYLE_OUTLINE_WIDTH:\n                    if(list->outline_width_zero) def = true;\n                    break;\n                case LV_STYLE_RADIUS:\n                    if(list->radius_zero) def = true;\n                    break;\n                case LV_STYLE_SHADOW_WIDTH:\n                    if(list->shadow_width_zero) def = true;\n                    break;\n                case LV_STYLE_PAD_TOP:\n                case LV_STYLE_PAD_BOTTOM:\n                case LV_STYLE_PAD_LEFT:\n                case LV_STYLE_PAD_RIGHT:\n                    if(list->pad_all_zero) def = true;\n                    break;\n                case LV_STYLE_BG_BLEND_MODE:\n                case LV_STYLE_BORDER_BLEND_MODE:\n                case LV_STYLE_IMAGE_BLEND_MODE:\n                case LV_STYLE_LINE_BLEND_MODE:\n                case LV_STYLE_OUTLINE_BLEND_MODE:\n                case LV_STYLE_PATTERN_BLEND_MODE:\n                case LV_STYLE_SHADOW_BLEND_MODE:\n                case LV_STYLE_TEXT_BLEND_MODE:\n                case LV_STYLE_VALUE_BLEND_MODE:\n                    if(list->blend_mode_all_normal) def = true;\n                    break;\n            }\n\n            if(def) {\n                break;\n            }\n        }\n\n        lv_state_t state = lv_obj_get_state(parent, part);\n        prop = (uint16_t)prop_ori + ((uint16_t)state << LV_STYLE_STATE_POS);\n\n        res = _lv_style_list_get_int(list, prop, &value_act);\n        if(res == LV_RES_OK) return value_act;\n\n        if(LV_STYLE_ATTR_GET_INHERIT(attr) == 0) break;\n\n        /*If not found, check the `MAIN` style first*/\n        if(part != LV_OBJ_PART_MAIN) {\n            part = LV_OBJ_PART_MAIN;\n            continue;\n        }\n\n        /*Check the parent too.*/\n        parent = lv_obj_get_parent(parent);\n    }\n\n    /*Handle unset values*/\n    prop = prop & (~LV_STYLE_STATE_MASK);\n    switch(prop) {\n        case LV_STYLE_BORDER_SIDE:\n            return LV_BORDER_SIDE_FULL;\n        case LV_STYLE_SIZE:\n            return LV_DPI / 20;\n        case LV_STYLE_SCALE_WIDTH:\n            return LV_DPI / 8;\n        case LV_STYLE_BG_GRAD_STOP:\n            return 255;\n        case LV_STYLE_TRANSFORM_ZOOM:\n            return LV_IMG_ZOOM_NONE;\n    }\n\n    return 0;\n}\n\n/**\n * Get a style property of a part of an object in the object's current state.\n * If there is a running transitions it is taken into account\n * @param obj pointer to an object\n * @param part the part of the object which style property should be get.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop the property to get. E.g. `LV_STYLE_BORDER_COLOR`.\n *  The state of the object will be added internally\n * @return the value of the property of the given part in the current state.\n * If the property is not found a default value will be returned.\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_color()`\n * @note for performance reasons it's not checked if the property really has color type\n */\nlv_color_t _lv_obj_get_style_color(const lv_obj_t * obj, uint8_t part, lv_style_property_t prop)\n{\n    lv_style_property_t prop_ori = prop;\n\n    lv_style_attr_t attr;\n    attr = prop_ori >> 8;\n\n    lv_color_t value_act;\n    lv_res_t res = LV_RES_INV;\n    const lv_obj_t * parent = obj;\n    while(parent) {\n        lv_style_list_t * list = lv_obj_get_style_list(parent, part);\n\n        lv_state_t state = lv_obj_get_state(parent, part);\n        prop = (uint16_t)prop_ori + ((uint16_t)state << LV_STYLE_STATE_POS);\n\n        res = _lv_style_list_get_color(list, prop, &value_act);\n        if(res == LV_RES_OK) return value_act;\n\n        if(LV_STYLE_ATTR_GET_INHERIT(attr) == 0) break;\n\n        /*If not found, check the `MAIN` style first*/\n        if(part != LV_OBJ_PART_MAIN) {\n            part = LV_OBJ_PART_MAIN;\n            continue;\n        }\n\n        /*Check the parent too.*/\n        parent = lv_obj_get_parent(parent);\n    }\n\n    /*Handle unset values*/\n    prop = prop & (~LV_STYLE_STATE_MASK);\n    switch(prop) {\n        case LV_STYLE_BG_COLOR:\n        case LV_STYLE_BG_GRAD_COLOR:\n            return LV_COLOR_WHITE;\n    }\n\n    return LV_COLOR_BLACK;\n}\n\n/**\n * Get a style property of a part of an object in the object's current state.\n * If there is a running transitions it is taken into account\n * @param obj pointer to an object\n * @param part the part of the object which style property should be get.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop the property to get. E.g. `LV_STYLE_BORDER_OPA`.\n *  The state of the object will be added internally\n * @return the value of the property of the given part in the current state.\n * If the property is not found a default value will be returned.\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_opa()`\n * @note for performance reasons it's not checked if the property really has opacity type\n */\nlv_opa_t _lv_obj_get_style_opa(const lv_obj_t * obj, uint8_t part, lv_style_property_t prop)\n{\n    lv_style_property_t prop_ori = prop;\n\n    lv_style_attr_t attr;\n    attr = prop_ori >> 8;\n\n    lv_opa_t value_act;\n    lv_res_t res = LV_RES_INV;\n    const lv_obj_t * parent = obj;\n    while(parent) {\n        lv_style_list_t * list = lv_obj_get_style_list(parent, part);\n\n        if(!list->ignore_cache && list->style_cnt > 0) {\n            if(!list->valid_cache) update_style_cache((lv_obj_t *)parent, part, prop  & (~LV_STYLE_STATE_MASK));\n            bool def = false;\n            switch(prop & (~LV_STYLE_STATE_MASK)) {\n                case LV_STYLE_OPA_SCALE:\n                    if(list->opa_scale_cover) def = true;\n                    break;\n                case LV_STYLE_BG_OPA:\n                    if(list->bg_opa_cover) return LV_OPA_COVER;     /*Special case, not the default value is used*/\n                    if(list->bg_opa_transp) def = true;\n                    break;\n                case LV_STYLE_IMAGE_RECOLOR_OPA:\n                    if(list->img_recolor_opa_transp) def = true;\n                    break;\n            }\n\n            if(def) {\n                break;\n            }\n        }\n\n\n        lv_state_t state = lv_obj_get_state(parent, part);\n        prop = (uint16_t)prop_ori + ((uint16_t)state << LV_STYLE_STATE_POS);\n\n        res = _lv_style_list_get_opa(list, prop, &value_act);\n        if(res == LV_RES_OK) return value_act;\n\n        if(LV_STYLE_ATTR_GET_INHERIT(attr) == 0) break;\n\n        /*If not found, check the `MAIN` style first*/\n        if(part != LV_OBJ_PART_MAIN) {\n            part = LV_OBJ_PART_MAIN;\n            continue;\n        }\n\n        /*Check the parent too.*/\n        parent = lv_obj_get_parent(parent);\n    }\n\n    /*Handle unset values*/\n    prop = prop & (~LV_STYLE_STATE_MASK);\n    switch(prop) {\n        case LV_STYLE_BG_OPA:\n        case LV_STYLE_IMAGE_RECOLOR_OPA:\n        case LV_STYLE_PATTERN_RECOLOR_OPA:\n            return LV_OPA_TRANSP;\n    }\n\n    return LV_OPA_COVER;\n}\n\n/**\n * Get a style property of a part of an object in the object's current state.\n * If there is a running transitions it is taken into account\n * @param obj pointer to an object\n * @param part the part of the object which style property should be get.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop the property to get. E.g. `LV_STYLE_TEXT_FONT`.\n *  The state of the object will be added internally\n * @return the value of the property of the given part in the current state.\n * If the property is not found a default value will be returned.\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_opa()`\n * @note for performance reasons it's not checked if the property really has pointer type\n */\nconst void * _lv_obj_get_style_ptr(const lv_obj_t * obj, uint8_t part, lv_style_property_t prop)\n{\n    lv_style_property_t prop_ori = prop;\n\n    lv_style_attr_t attr;\n    attr = prop_ori >> 8;\n\n    const void * value_act;\n    lv_res_t res = LV_RES_INV;\n    const lv_obj_t * parent = obj;\n    while(parent) {\n        lv_style_list_t * list = lv_obj_get_style_list(parent, part);\n\n        if(!list->ignore_cache && list->style_cnt > 0) {\n            if(!list->valid_cache) update_style_cache((lv_obj_t *)parent, part, prop  & (~LV_STYLE_STATE_MASK));\n            bool def = false;\n            switch(prop  & (~LV_STYLE_STATE_MASK)) {\n                case LV_STYLE_VALUE_STR:\n                    if(list->value_txt_str) def = true;\n                    break;\n                case LV_STYLE_PATTERN_IMAGE:\n                    if(list->pattern_img_null) def = true;\n                    break;\n                case LV_STYLE_TEXT_FONT:\n                    if(list->text_font_normal) def = true;\n                    break;\n            }\n\n            if(def) {\n                break;\n            }\n        }\n\n        lv_state_t state = lv_obj_get_state(parent, part);\n        prop = (uint16_t)prop_ori + ((uint16_t)state << LV_STYLE_STATE_POS);\n\n        res = _lv_style_list_get_ptr(list, prop, &value_act);\n        if(res == LV_RES_OK)  return value_act;\n\n        if(LV_STYLE_ATTR_GET_INHERIT(attr) == 0) break;\n\n        /*If not found, check the `MAIN` style first*/\n        if(part != LV_OBJ_PART_MAIN) {\n            part = LV_OBJ_PART_MAIN;\n            continue;\n        }\n\n        /*Check the parent too.*/\n        parent = lv_obj_get_parent(parent);\n    }\n\n    /*Handle unset values*/\n    prop = prop & (~LV_STYLE_STATE_MASK);\n    switch(prop) {\n        case LV_STYLE_TEXT_FONT:\n        case LV_STYLE_VALUE_FONT:\n            return lv_theme_get_font_normal();\n#if LV_USE_ANIMATION\n        case LV_STYLE_TRANSITION_PATH:\n            return &lv_anim_path_def;\n#endif",
        "base_contents": "/**\n * Set the directions an object can be dragged in\n * @param obj pointer to an object\n * @param drag_dir bitwise OR of allowed directions an object can be dragged in\n */\nvoid lv_obj_set_drag_dir(lv_obj_t * obj, lv_drag_dir_t drag_dir)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->drag_dir = drag_dir;\n\n    if(obj->drag_dir != 0) lv_obj_set_drag(obj, true); /*Drag direction requires drag*/\n}\n\n/**\n * Enable the throwing of an object after is is dragged\n * @param obj pointer to an object\n * @param en true: enable the drag throw\n */\nvoid lv_obj_set_drag_throw(lv_obj_t * obj, bool en)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->drag_throw = (en == true ? 1 : 0);\n}\n\n/**\n * Enable to use parent for drag related operations.\n * If trying to drag the object the parent will be moved instead\n * @param obj pointer to an object\n * @param en true: enable the 'drag parent' for the object\n */\nvoid lv_obj_set_drag_parent(lv_obj_t * obj, bool en)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->drag_parent = (en == true ? 1 : 0);\n}\n\n/**\n* Enable to use parent for gesture related operations.\n* If trying to gesture the object the parent will be moved instead\n* @param obj pointer to an object\n* @param en true: enable the 'gesture parent' for the object\n*/\nvoid lv_obj_set_gesture_parent(lv_obj_t * obj, bool en)\n{\n    obj->gesture_parent = (en == true ? 1 : 0);\n}\n\n/**\n* Enable to use parent for focus state.\n* When object is focused the parent will get the state instead (visual only)\n* @param obj pointer to an object\n* @param en true: enable the 'focus parent' for the object\n*/\nvoid lv_obj_set_focus_parent(lv_obj_t * obj, bool en)\n{\n    if(lv_obj_is_focused(obj)) {\n        if(en) {\n            obj->focus_parent = 1;\n            lv_obj_clear_state(obj, LV_STATE_FOCUSED | LV_STATE_EDITED);\n            lv_obj_set_state(lv_obj_get_focused_obj(obj), LV_STATE_FOCUSED);\n        }\n        else {\n            lv_obj_clear_state(lv_obj_get_focused_obj(obj), LV_STATE_FOCUSED | LV_STATE_EDITED);\n            lv_obj_set_state(obj, LV_STATE_FOCUSED);\n            obj->focus_parent = 0;\n        }\n    }\n    else {\n        obj->focus_parent = (en == true ? 1 : 0);\n    }\n}\n\n/**\n * Propagate the events to the parent too\n * @param obj pointer to an object\n * @param en true: enable the event propagation\n */\nvoid lv_obj_set_parent_event(lv_obj_t * obj, bool en)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->parent_event = (en == true ? 1 : 0);\n}\n\n/**\n * Set the base direction of the object\n * @param obj pointer to an object\n * @param dir the new base direction. `LV_BIDI_DIR_LTR/RTL/AUTO/INHERIT`\n */\nvoid lv_obj_set_base_dir(lv_obj_t * obj, lv_bidi_dir_t dir)\n{\n    if(dir != LV_BIDI_DIR_LTR && dir != LV_BIDI_DIR_RTL &&\n       dir != LV_BIDI_DIR_AUTO && dir != LV_BIDI_DIR_INHERIT) {\n\n        LV_LOG_WARN(\"lv_obj_set_base_dir: invalid base dir\");\n        return;\n    }\n\n    obj->base_dir = dir;\n    lv_signal_send(obj, LV_SIGNAL_BASE_DIR_CHG, NULL);\n\n    /* Notify the children about the parent base dir has changed.\n     * (The children might have `LV_BIDI_DIR_INHERIT`)*/\n    base_dir_refr_children(obj);\n}\n\n/**\n * Set a bit or bits in the protect filed\n * @param obj pointer to an object\n * @param prot 'OR'-ed values from `lv_protect_t`\n */\nvoid lv_obj_add_protect(lv_obj_t * obj, uint8_t prot)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->protect |= prot;\n}\n\n/**\n * Clear a bit or bits in the protect filed\n * @param obj pointer to an object\n * @param prot 'OR'-ed values from `lv_protect_t`\n */\nvoid lv_obj_clear_protect(lv_obj_t * obj, uint8_t prot)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    prot = (~prot) & 0xFF;\n    obj->protect &= prot;\n}\n\n/**\n * Set the state (fully overwrite) of an object.\n * If specified in the styles a transition animation will be started\n * from the previous state to the current\n * @param obj pointer to an object\n * @param state the new state\n */\nvoid lv_obj_set_state(lv_obj_t * obj, lv_state_t new_state)\n{\n    if(obj->state == new_state) return;\n\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_ANIMATION == 0\n    obj->state = new_state;\n    lv_obj_refresh_style(obj, LV_OBJ_PART_ALL, LV_STYLE_PROP_ALL);\n#else\n    lv_state_t prev_state = obj->state;\n    style_snapshot_res_t cmp_res = STYLE_COMPARE_SAME;\n    uint8_t part;\n    for(part = 0; part < _LV_OBJ_PART_REAL_FIRST; part++) {\n        lv_style_list_t * style_list = lv_obj_get_style_list(obj, part);\n        if(style_list == NULL) break;   /*No more style lists*/\n        obj->state = prev_state;\n        style_snapshot_t shot_pre;\n        style_snapshot(obj, part, &shot_pre);\n        obj->state = new_state;\n        style_snapshot_t shot_post;\n        style_snapshot(obj, part, &shot_post);\n\n        style_snapshot_res_t r = style_snapshot_compare(&shot_pre, &shot_post);\n        if(r == STYLE_COMPARE_DIFF) {\n            cmp_res = STYLE_COMPARE_DIFF;\n            break;\n        }\n        if(r == STYLE_COMPARE_VISUAL_DIFF) {\n            cmp_res = STYLE_COMPARE_VISUAL_DIFF;\n        }\n    }\n\n    if(cmp_res == STYLE_COMPARE_SAME) return;\n\n    for(part = 0; part < _LV_OBJ_PART_REAL_LAST; part++) {\n        lv_style_list_t * style_list = lv_obj_get_style_list(obj, part);\n        if(style_list == NULL) break;   /*No more style lists*/\n        if(style_list->ignore_trans) continue;\n\n        lv_style_int_t time = lv_obj_get_style_transition_time(obj, part);\n        lv_style_property_t props[LV_STYLE_TRANS_NUM_MAX];\n        lv_style_int_t delay = lv_obj_get_style_transition_delay(obj, part);\n        lv_anim_path_t * path = lv_obj_get_style_transition_path(obj, part);\n        props[0] = lv_obj_get_style_transition_prop_1(obj, part);\n        props[1] = lv_obj_get_style_transition_prop_2(obj, part);\n        props[2] = lv_obj_get_style_transition_prop_3(obj, part);\n        props[3] = lv_obj_get_style_transition_prop_4(obj, part);\n        props[4] = lv_obj_get_style_transition_prop_5(obj, part);\n        props[5] = lv_obj_get_style_transition_prop_6(obj, part);\n\n        uint8_t i;\n        for(i = 0; i < LV_STYLE_TRANS_NUM_MAX; i++) {\n            if(props[i] != 0) {\n                _lv_style_list_add_trans_style(style_list);\n\n                lv_style_trans_t * tr = trans_create(obj, props[i], part, prev_state, new_state);\n\n                /*If there is a pending anim for this property remove it*/\n                if(tr) {\n                    tr->obj = obj;\n                    tr->prop = props[i];\n                    tr->part = part;\n\n                    lv_anim_t a;\n                    lv_anim_init(&a);\n                    lv_anim_set_var(&a, tr);\n                    lv_anim_set_exec_cb(&a, (lv_anim_exec_xcb_t)trans_anim_cb);\n                    lv_anim_set_start_cb(&a, trans_anim_start_cb);\n                    lv_anim_set_ready_cb(&a, trans_anim_ready_cb);\n                    lv_anim_set_values(&a, 0x00, 0xFF);\n                    lv_anim_set_time(&a, time);\n                    lv_anim_set_delay(&a, delay);\n                    lv_anim_set_path(&a, path);\n                    a.early_apply = 0;\n                    lv_anim_start(&a);\n                }\n\n            }\n        }\n        if(cmp_res == STYLE_COMPARE_DIFF) lv_obj_refresh_style(obj, part, LV_STYLE_PROP_ALL);\n    }\n    if(cmp_res == STYLE_COMPARE_VISUAL_DIFF) lv_obj_invalidate(obj);\n#endif\n\n\n}\n\n/**\n * Add a given state or states to the object. The other state bits will remain unchanged.\n * If specified in the styles a transition animation will be started\n * from the previous state to the current\n * @param obj pointer to an object\n * @param state the state bits to add. E.g `LV_STATE_PRESSED | LV_STATE_FOCUSED`\n */\nvoid lv_obj_add_state(lv_obj_t * obj, lv_state_t state)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_state_t new_state = obj->state | state;\n    if(obj->state != new_state) {\n        lv_obj_set_state(obj, new_state);\n    }\n}\n\n/**\n * Remove a given state or states to the object. The other state bits will remain unchanged.\n * If specified in the styles a transition animation will be started\n * from the previous state to the current\n * @param obj pointer to an object\n * @param state the state bits to remove. E.g `LV_STATE_PRESSED | LV_STATE_FOCUSED`\n */\nvoid lv_obj_clear_state(lv_obj_t * obj, lv_state_t state)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_state_t new_state = obj->state & (~state);\n    if(obj->state != new_state) {\n        lv_obj_set_state(obj, new_state);\n    }\n}\n\n#if LV_USE_ANIMATION\n/**\n * Finish all pending transitions on a part of an object\n * @param obj pointer to an object\n * @param part part of the object, e.g `LV_BRN_PART_MAIN` or `LV_OBJ_PART_ALL` for all parts\n */\nvoid lv_obj_finish_transitions(lv_obj_t * obj, uint8_t part)\n{\n    /*Animate all related transition to the end value*/\n    lv_style_trans_t * tr;\n    _LV_LL_READ_BACK(LV_GC_ROOT(_lv_obj_style_trans_ll), tr) {\n        if(tr->obj == obj && (part == tr->part || part == LV_OBJ_PART_ALL)) {\n            trans_anim_cb(tr, 255);\n        }\n    }\n\n    /*Free all related transition data*/\n    trans_del(obj, part, 0xFF, NULL);\n}\n#endif\n\n/**\n * Set a an event handler function for an object.\n * Used by the user to react on event which happens with the object.\n * @param obj pointer to an object\n * @param event_cb the new event function\n */\nvoid lv_obj_set_event_cb(lv_obj_t * obj, lv_event_cb_t event_cb)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->event_cb = event_cb;\n}\n\n/**\n * Send an event to the object\n * @param obj pointer to an object\n * @param event the type of the event from `lv_event_t`\n * @param data arbitrary data depending on the object type and the event. (Usually `NULL`)\n * @return LV_RES_OK: `obj` was not deleted in the event; LV_RES_INV: `obj` was deleted in the event\n */\nlv_res_t lv_event_send(lv_obj_t * obj, lv_event_t event, const void * data)\n{\n    if(obj == NULL) return LV_RES_OK;\n\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_res_t res;\n    res = lv_event_send_func(obj->event_cb, obj, event, data);\n    return res;\n}\n\n/**\n * Send LV_EVENT_REFRESH event to an object\n * @param obj point to an obejct. (Can NOT be NULL)\n * @return LV_RES_OK: success, LV_RES_INV: to object become invalid (e.g. deleted) due to this event.\n */\nlv_res_t lv_event_send_refresh(lv_obj_t * obj)\n{\n    return lv_event_send(obj, LV_EVENT_REFRESH, NULL);\n}\n\n/**\n * Send LV_EVENT_REFRESH event to an object and all of its children.\n * @param obj pointer to an object or NULL to refresh all objects of all displays\n */\nvoid lv_event_send_refresh_recursive(lv_obj_t * obj)\n{\n    if(obj == NULL) {\n        /*If no obj specified refresh all screen of all displays */\n        lv_disp_t * d = lv_disp_get_next(NULL);\n        while(d) {\n            lv_obj_t * scr = _lv_ll_get_head(&d->scr_ll);\n            while(scr) {\n                lv_event_send_refresh_recursive(scr);\n                scr = _lv_ll_get_next(&d->scr_ll, scr);\n            }\n            lv_event_send_refresh_recursive(d->top_layer);\n            lv_event_send_refresh_recursive(d->sys_layer);\n\n            d = lv_disp_get_next(d);\n        }\n    }\n    else {\n\n        lv_res_t res = lv_event_send_refresh(obj);\n        if(res != LV_RES_OK) return; /*If invalid returned do not check the children*/\n\n        lv_obj_t * child = lv_obj_get_child(obj, NULL);\n        while(child) {\n            lv_event_send_refresh_recursive(child);\n\n            child = lv_obj_get_child(obj, child);\n        }\n    }\n}\n\n\n/**\n * Call an event function with an object, event, and data.\n * @param event_xcb an event callback function. If `NULL` `LV_RES_OK` will return without any actions.\n *        (the 'x' in the argument name indicates that its not a fully generic function because it not follows\n *         the `func_name(object, callback, ...)` convention)\n * @param obj pointer to an object to associate with the event (can be `NULL` to simply call the `event_cb`)\n * @param event an event\n * @param data pointer to a custom data\n * @return LV_RES_OK: `obj` was not deleted in the event; LV_RES_INV: `obj` was deleted in the event\n */\nlv_res_t lv_event_send_func(lv_event_cb_t event_xcb, lv_obj_t * obj, lv_event_t event, const void * data)\n{\n    if(obj != NULL) {\n        LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n    }\n\n    /* Build a simple linked list from the objects used in the events\n     * It's important to know if an this object was deleted by a nested event\n     * called from this `even_cb`. */\n    lv_event_temp_data_t event_temp_data;\n    event_temp_data.obj     = obj;\n    event_temp_data.deleted = false;\n    event_temp_data.prev    = NULL;\n\n    if(event_temp_data_head) {\n        event_temp_data.prev = event_temp_data_head;\n    }\n    event_temp_data_head = &event_temp_data;\n\n    const void * event_act_data_save = event_act_data;\n    event_act_data                   = data;\n\n    /*Call the input device's feedback callback if set*/\n    lv_indev_t * indev_act = lv_indev_get_act();\n    if(indev_act) {\n        if(indev_act->driver.feedback_cb) indev_act->driver.feedback_cb(&indev_act->driver, event);\n    }\n\n    /*Call the event callback itself*/\n    if(event_xcb) event_xcb(obj, event);\n\n    /*Restore the event data*/\n    event_act_data = event_act_data_save;\n\n    /*Remove this element from the list*/\n    event_temp_data_head = event_temp_data_head->prev;\n\n    if(event_temp_data.deleted) {\n        return LV_RES_INV;\n    }\n\n    if(obj) {\n        if(obj->parent_event && obj->parent) {\n            lv_res_t res = lv_event_send(obj->parent, event, data);\n            if(res != LV_RES_OK) {\n                return LV_RES_INV;\n            }\n        }\n    }\n\n    return LV_RES_OK;\n}\n\n/**\n * Get the `data` parameter of the current event\n * @return the `data` parameter\n */\nconst void * lv_event_get_data(void)\n{\n    return event_act_data;\n}\n\n/**\n * Set the a signal function of an object. Used internally by the library.\n * Always call the previous signal function in the new.\n * @param obj pointer to an object\n * @param cb the new signal function\n */\nvoid lv_obj_set_signal_cb(lv_obj_t * obj, lv_signal_cb_t signal_cb)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->signal_cb = signal_cb;\n}\n\n/**\n * Send an event to the object\n * @param obj pointer to an object\n * @param event the type of the event from `lv_event_t`.\n * @return LV_RES_OK or LV_RES_INV\n */\nlv_res_t lv_signal_send(lv_obj_t * obj, lv_signal_t signal, void * param)\n{\n    if(obj == NULL) return LV_RES_OK;\n\n    lv_res_t res = LV_RES_OK;\n    if(obj->signal_cb) res = obj->signal_cb(obj, signal, param);\n\n    return res;\n}\n\n/**\n * Set a new design function for an object\n * @param obj pointer to an object\n * @param design_cb the new design function\n */\nvoid lv_obj_set_design_cb(lv_obj_t * obj, lv_design_cb_t design_cb)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->design_cb = design_cb;\n}\n\n/*----------------\n * Other set\n *--------------*/\n\n/**\n * Allocate a new ext. data for an object\n * @param obj pointer to an object\n * @param ext_size the size of the new ext. data\n * @return pointer to the allocated ext.\n * If out of memory NULL is returned and the original ext is preserved\n */\nvoid * lv_obj_allocate_ext_attr(lv_obj_t * obj, uint16_t ext_size)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    void * new_ext = lv_mem_realloc(obj->ext_attr, ext_size);\n    if(new_ext == NULL) return NULL;\n\n    obj->ext_attr = new_ext;\n    return (void *)obj->ext_attr;\n}\n\n/**\n * Send a 'LV_SIGNAL_REFR_EXT_SIZE' signal to the object to refresh the extended draw area.\n * he object needs to be invalidated by `lv_obj_invalidate(obj)` manually after this function.\n * @param obj pointer to an object\n */\nvoid lv_obj_refresh_ext_draw_pad(lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->ext_draw_pad = 0;\n    obj->signal_cb(obj, LV_SIGNAL_REFR_EXT_DRAW_PAD, NULL);\n\n}\n\n/*=======================\n * Getter functions\n *======================*/\n\n/**\n * Return with the screen of an object\n * @param obj pointer to an object\n * @return pointer to a screen\n */\nlv_obj_t * lv_obj_get_screen(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    const lv_obj_t * par = obj;\n    const lv_obj_t * act_p;\n\n    do {\n        act_p = par;\n        par   = lv_obj_get_parent(act_p);\n    } while(par != NULL);\n\n    return (lv_obj_t *)act_p;\n}\n\n/**\n * Get the display of an object\n * @param scr pointer to an object\n * @return pointer the object's display\n */\nlv_disp_t * lv_obj_get_disp(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    const lv_obj_t * scr;\n\n    if(obj->parent == NULL)\n        scr = obj; /*`obj` is a screen*/\n    else\n        scr = lv_obj_get_screen(obj); /*get the screen of `obj`*/\n\n    lv_disp_t * d;\n    _LV_LL_READ(LV_GC_ROOT(_lv_disp_ll), d) {\n        lv_obj_t * s;\n        _LV_LL_READ(d->scr_ll, s) {\n            if(s == scr) return d;\n        }\n    }\n\n    LV_LOG_WARN(\"lv_scr_get_disp: screen not found\")\n    return NULL;\n}\n\n/*---------------------\n * Parent/children get\n *--------------------*/\n\n/**\n * Returns with the parent of an object\n * @param obj pointer to an object\n * @return pointer to the parent of  'obj'\n */\nlv_obj_t * lv_obj_get_parent(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return obj->parent;\n}\n\n/**\n * Iterate through the children of an object (start from the \"youngest\")\n * @param obj pointer to an object\n * @param child NULL at first call to get the next children\n *                  and the previous return value later\n * @return the child after 'act_child' or NULL if no more child\n */\nlv_obj_t * lv_obj_get_child(const lv_obj_t * obj, const lv_obj_t * child)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_obj_t * result = NULL;\n\n    if(child == NULL) {\n        result = _lv_ll_get_head(&obj->child_ll);\n    }\n    else {\n        result = _lv_ll_get_next(&obj->child_ll, child);\n    }\n\n    return result;\n}\n\n/**\n * Iterate through the children of an object (start from the \"oldest\")\n * @param obj pointer to an object\n * @param child NULL at first call to get the next children\n *                  and the previous return value later\n * @return the child after 'act_child' or NULL if no more child\n */\nlv_obj_t * lv_obj_get_child_back(const lv_obj_t * obj, const lv_obj_t * child)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_obj_t * result = NULL;\n\n    if(child == NULL) {\n        result = _lv_ll_get_tail(&obj->child_ll);\n    }\n    else {\n        result = _lv_ll_get_prev(&obj->child_ll, child);\n    }\n\n    return result;\n}\n\n/**\n * Count the children of an object (only children directly on 'obj')\n * @param obj pointer to an object\n * @return children number of 'obj'\n */\nuint16_t lv_obj_count_children(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_obj_t * i;\n    uint16_t cnt = 0;\n\n    _LV_LL_READ(obj->child_ll, i) cnt++;\n\n    return cnt;\n}\n\n/** Recursively count the children of an object\n * @param obj pointer to an object\n * @return children number of 'obj'\n */\nuint16_t lv_obj_count_children_recursive(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_obj_t * i;\n    uint16_t cnt = 0;\n\n    _LV_LL_READ(obj->child_ll, i) {\n        cnt++;                                     /*Count the child*/\n        cnt += lv_obj_count_children_recursive(i); /*recursively count children's children*/\n    }\n\n    return cnt;\n}\n\n/*---------------------\n * Coordinate get\n *--------------------*/\n\n/**\n * Copy the coordinates of an object to an area\n * @param obj pointer to an object\n * @param cords_p pointer to an area to store the coordinates\n */\nvoid lv_obj_get_coords(const lv_obj_t * obj, lv_area_t * cords_p)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_area_copy(cords_p, &obj->coords);\n}\n\n/**\n * Reduce area retried by `lv_obj_get_coords()` the get graphically usable area of an object.\n * (Without the size of the border or other extra graphical elements)\n * @param coords_p store the result area here\n */\nvoid lv_obj_get_inner_coords(const lv_obj_t * obj, lv_area_t * coords_p)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_border_side_t part = lv_obj_get_style_border_side(obj, LV_OBJ_PART_MAIN);\n    lv_coord_t w = lv_obj_get_style_border_width(obj, LV_OBJ_PART_MAIN);\n\n    if(part & LV_BORDER_SIDE_LEFT) coords_p->x1 += w;\n\n    if(part & LV_BORDER_SIDE_RIGHT) coords_p->x2 -= w;\n\n    if(part & LV_BORDER_SIDE_TOP) coords_p->y1 += w;\n\n    if(part & LV_BORDER_SIDE_BOTTOM) coords_p->y2 -= w;\n}\n\n/**\n * Get the x coordinate of object\n * @param obj pointer to an object\n * @return distance of 'obj' from the left side of its parent\n */\nlv_coord_t lv_obj_get_x(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_coord_t rel_x;\n    lv_obj_t * parent = lv_obj_get_parent(obj);\n    if(parent) {\n        rel_x             = obj->coords.x1 - parent->coords.x1;\n    }\n    else {\n        rel_x = obj->coords.x1;\n    }\n    return rel_x;\n}\n\n/**\n * Get the y coordinate of object\n * @param obj pointer to an object\n * @return distance of 'obj' from the top of its parent\n */\nlv_coord_t lv_obj_get_y(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_coord_t rel_y;\n    lv_obj_t * parent = lv_obj_get_parent(obj);\n    if(parent) {\n        rel_y             = obj->coords.y1 - parent->coords.y1;\n    }\n    else {\n        rel_y = obj->coords.y1;\n    }\n    return rel_y;\n}\n\n/**\n * Get the width of an object\n * @param obj pointer to an object\n * @return the width\n */\nlv_coord_t lv_obj_get_width(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return lv_area_get_width(&obj->coords);\n}\n\n/**\n * Get the height of an object\n * @param obj pointer to an object\n * @return the height\n */\nlv_coord_t lv_obj_get_height(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return lv_area_get_height(&obj->coords);\n}\n\n/**\n * Get that width reduced by the left and right padding.\n * @param obj pointer to an object\n * @return the width which still fits into the container\n */\nlv_coord_t lv_obj_get_width_fit(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_style_int_t left = lv_obj_get_style_pad_left(obj, LV_OBJ_PART_MAIN);\n    lv_style_int_t right = lv_obj_get_style_pad_right(obj, LV_OBJ_PART_MAIN);\n\n    return lv_obj_get_width(obj) - left - right;\n}\n\n/**\n * Get that height reduced by the top an bottom padding.\n * @param obj pointer to an object\n * @return the height which still fits into the container\n */\nlv_coord_t lv_obj_get_height_fit(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_style_int_t top = lv_obj_get_style_pad_top((lv_obj_t *)obj, LV_OBJ_PART_MAIN);\n    lv_style_int_t bottom =  lv_obj_get_style_pad_bottom((lv_obj_t *)obj, LV_OBJ_PART_MAIN);\n\n    return lv_obj_get_height(obj) - top - bottom;\n}\n\n/**\n * Get the height of an object by taking the top and bottom margin into account.\n * The returned height will be `obj_h + margin_top + margin_bottom`\n * @param obj pointer to an object\n * @return the height including thee margins\n */\nlv_coord_t lv_obj_get_height_margin(lv_obj_t * obj)\n{\n    lv_style_int_t mtop = lv_obj_get_style_margin_top(obj, LV_OBJ_PART_MAIN);\n    lv_style_int_t mbottom = lv_obj_get_style_margin_bottom(obj, LV_OBJ_PART_MAIN);\n\n    return lv_obj_get_height(obj) + mtop + mbottom;\n}\n\n/**\n * Get the width of an object by taking the left and right margin into account.\n * The returned width will be `obj_w + margin_left + margin_right`\n * @param obj pointer to an object\n * @return the height including thee margins\n */\nlv_coord_t lv_obj_get_width_margin(lv_obj_t * obj)\n{\n    lv_style_int_t mleft = lv_obj_get_style_margin_left(obj, LV_OBJ_PART_MAIN);\n    lv_style_int_t mright = lv_obj_get_style_margin_right(obj, LV_OBJ_PART_MAIN);\n\n    return lv_obj_get_width(obj) + mleft + mright;\n}\n\n/**\n * Set that width reduced by the left and right padding of the parent.\n * @param obj pointer to an object\n * @param div indicates how many columns are assumed.\n * If 1 the width will be set the the parent's width\n * If 2 only half parent width - inner padding of the parent\n * If 3 only third parent width - 2 * inner padding of the parent\n * @param span how many columns are combined\n * @return the width according to the given parameters\n */\nlv_coord_t lv_obj_get_width_grid(lv_obj_t * obj, uint8_t div, uint8_t span)\n{\n    lv_coord_t obj_w = lv_obj_get_width_fit(obj);\n    lv_style_int_t pinner = lv_obj_get_style_pad_inner(obj, LV_OBJ_PART_MAIN);\n\n    lv_coord_t r = (obj_w - (div - 1) * pinner) / div;\n\n    r = r * span + (span - 1) * pinner;\n    return r;\n}\n\n/**\n * Get that height reduced by the top and bottom padding of the parent.\n * @param obj pointer to an object\n * @param div indicates how many rows are assumed.\n * If 1 the height will be set the the parent's height\n * If 2 only half parent height - inner padding of the parent\n * If 3 only third parent height - 2 * inner padding of the parent\n * @param span how many rows are combined\n * @return the height according to the given parameters\n */\nlv_coord_t lv_obj_get_height_grid(lv_obj_t * obj, uint8_t div, uint8_t span)\n{\n    lv_coord_t obj_h = lv_obj_get_height_fit(obj);\n    lv_style_int_t pinner = lv_obj_get_style_pad_inner(obj, LV_OBJ_PART_MAIN);\n\n    lv_coord_t r = (obj_h - (div - 1) * pinner) / div;\n\n    r = r * span + (span - 1) * pinner;\n    return r;\n}\n\n/**\n * Get the automatic realign property of the object.\n * @param obj pointer to an object\n * @return  true: auto realign is enabled; false: auto realign is disabled\n */\nbool lv_obj_get_auto_realign(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_OBJ_REALIGN\n    return obj->realign.auto_realign ? true : false;\n#else\n    (void)obj;\n    return false;\n#endif\n}\n\n/**\n * Get the left padding of extended clickable area\n * @param obj pointer to an object\n * @return the extended left padding\n */\nlv_coord_t lv_obj_get_ext_click_pad_left(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_TINY\n    return obj->ext_click_pad_hor;\n#elif LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_FULL\n    return obj->ext_click_pad.x1;\n#else\n    (void)obj;    /*Unused*/\n    return 0;\n#endif\n}\n\n/**\n * Get the right padding of extended clickable area\n * @param obj pointer to an object\n * @return the extended right padding\n */\nlv_coord_t lv_obj_get_ext_click_pad_right(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_TINY\n    return obj->ext_click_pad_hor;\n#elif LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_FULL\n    return obj->ext_click_pad.x2;\n#else\n    (void)obj; /*Unused*/\n    return 0;\n#endif\n}\n\n/**\n * Get the top padding of extended clickable area\n * @param obj pointer to an object\n * @return the extended top padding\n */\nlv_coord_t lv_obj_get_ext_click_pad_top(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_TINY\n    return obj->ext_click_pad_ver;\n#elif LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_FULL\n    return obj->ext_click_pad.y1;\n#else\n    (void)obj; /*Unused*/\n    return 0;\n#endif\n}\n\n/**\n * Get the bottom padding of extended clickable area\n * @param obj pointer to an object\n * @return the extended bottom padding\n */\nlv_coord_t lv_obj_get_ext_click_pad_bottom(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_TINY\n    return obj->ext_click_pad_ver;\n#elif LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_FULL\n    return obj->ext_click_pad.y2;\n#else\n    (void)obj; /*Unused*/\n    return 0;\n#endif\n}\n\n/**\n * Get the extended size attribute of an object\n * @param obj pointer to an object\n * @return the extended size attribute\n */\nlv_coord_t lv_obj_get_ext_draw_pad(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return obj->ext_draw_pad;\n}\n\n/*-----------------\n * Appearance get\n *---------------*/\n\nlv_style_list_t * lv_obj_get_style_list(const lv_obj_t * obj, uint8_t part)\n{\n    if(part == LV_OBJ_PART_MAIN) return &((lv_obj_t *)obj)->style_list;\n\n    lv_get_style_info_t info;\n    info.part = part;\n    info.result = NULL;\n\n    lv_res_t res;\n    res = lv_signal_send((lv_obj_t *)obj, LV_SIGNAL_GET_STYLE, &info);\n\n    if(res != LV_RES_OK) return NULL;\n\n    return info.result;\n}\n\n/**\n * Get a style property of a part of an object in the object's current state.\n * If there is a running transitions it is taken into account\n * @param obj pointer to an object\n * @param part the part of the object which style property should be get.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop the property to get. E.g. `LV_STYLE_BORDER_WIDTH`.\n *  The state of the object will be added internally\n * @return the value of the property of the given part in the current state.\n * If the property is not found a default value will be returned.\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_width()`\n * @note for performance reasons it's not checked if the property really has integer type\n */\nlv_style_int_t _lv_obj_get_style_int(const lv_obj_t * obj, uint8_t part, lv_style_property_t prop)\n{\n    lv_style_property_t prop_ori = prop;\n\n    lv_style_attr_t attr;\n    attr = prop_ori >> 8;\n\n    lv_style_int_t value_act;\n    lv_res_t res = LV_RES_INV;\n    const lv_obj_t * parent = obj;\n    while(parent) {\n        lv_style_list_t * list = lv_obj_get_style_list(parent, part);\n        if(!list->ignore_cache && list->style_cnt > 0) {\n            if(!list->valid_cache) update_style_cache((lv_obj_t *)parent, part, prop  & (~LV_STYLE_STATE_MASK));\n\n            bool def = false;\n            switch(prop  & (~LV_STYLE_STATE_MASK)) {\n                case LV_STYLE_BG_GRAD_DIR:\n                    if(list->bg_grad_dir_none) def = true;\n                    break;\n                case LV_STYLE_CLIP_CORNER:\n                    if(list->clip_corner_off) def = true;\n                    break;\n                case LV_STYLE_TEXT_LETTER_SPACE:\n                case LV_STYLE_TEXT_LINE_SPACE:\n                    if(list->text_space_zero) def = true;\n                    break;\n                case LV_STYLE_TRANSFORM_ANGLE:\n                case LV_STYLE_TRANSFORM_WIDTH:\n                case LV_STYLE_TRANSFORM_HEIGHT:\n                case LV_STYLE_TRANSFORM_ZOOM:\n                    if(list->transform_all_zero) def = true;\n                    break;\n                case LV_STYLE_BORDER_WIDTH:\n                    if(list->border_width_zero) def = true;\n                    break;\n                case LV_STYLE_BORDER_SIDE:\n                    if(list->border_side_full) def = true;\n                    break;\n                case LV_STYLE_BORDER_POST:\n                    if(list->border_post_off) def = true;\n                    break;\n                case LV_STYLE_OUTLINE_WIDTH:\n                    if(list->outline_width_zero) def = true;\n                    break;\n                case LV_STYLE_RADIUS:\n                    if(list->radius_zero) def = true;\n                    break;\n                case LV_STYLE_SHADOW_WIDTH:\n                    if(list->shadow_width_zero) def = true;\n                    break;\n                case LV_STYLE_PAD_TOP:\n                case LV_STYLE_PAD_BOTTOM:\n                case LV_STYLE_PAD_LEFT:\n                case LV_STYLE_PAD_RIGHT:\n                    if(list->pad_all_zero) def = true;\n                    break;\n                case LV_STYLE_BG_BLEND_MODE:\n                case LV_STYLE_BORDER_BLEND_MODE:\n                case LV_STYLE_IMAGE_BLEND_MODE:\n                case LV_STYLE_LINE_BLEND_MODE:\n                case LV_STYLE_OUTLINE_BLEND_MODE:\n                case LV_STYLE_PATTERN_BLEND_MODE:\n                case LV_STYLE_SHADOW_BLEND_MODE:\n                case LV_STYLE_TEXT_BLEND_MODE:\n                case LV_STYLE_VALUE_BLEND_MODE:\n                    if(list->blend_mode_all_normal) def = true;\n                    break;\n            }\n\n            if(def) {\n                break;\n            }\n        }\n\n        lv_state_t state = lv_obj_get_state(parent, part);\n        prop = (uint16_t)prop_ori + ((uint16_t)state << LV_STYLE_STATE_POS);\n\n        res = _lv_style_list_get_int(list, prop, &value_act);\n        if(res == LV_RES_OK) return value_act;\n\n        if(LV_STYLE_ATTR_GET_INHERIT(attr) == 0) break;\n\n        /*If not found, check the `MAIN` style first*/\n        if(part != LV_OBJ_PART_MAIN) {\n            part = LV_OBJ_PART_MAIN;\n            continue;\n        }\n\n        /*Check the parent too.*/\n        parent = lv_obj_get_parent(parent);\n    }\n\n    /*Handle unset values*/\n    prop = prop & (~LV_STYLE_STATE_MASK);\n    switch(prop) {\n        case LV_STYLE_BORDER_SIDE:\n            return LV_BORDER_SIDE_FULL;\n        case LV_STYLE_SIZE:\n            return LV_DPI / 20;\n        case LV_STYLE_SCALE_WIDTH:\n            return LV_DPI / 8;\n        case LV_STYLE_BG_GRAD_STOP:\n            return 255;\n        case LV_STYLE_TRANSFORM_ZOOM:\n            return LV_IMG_ZOOM_NONE;\n    }\n\n    return 0;\n}\n\n/**\n * Get a style property of a part of an object in the object's current state.\n * If there is a running transitions it is taken into account\n * @param obj pointer to an object\n * @param part the part of the object which style property should be get.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop the property to get. E.g. `LV_STYLE_BORDER_COLOR`.\n *  The state of the object will be added internally\n * @return the value of the property of the given part in the current state.\n * If the property is not found a default value will be returned.\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_color()`\n * @note for performance reasons it's not checked if the property really has color type\n */\nlv_color_t _lv_obj_get_style_color(const lv_obj_t * obj, uint8_t part, lv_style_property_t prop)\n{\n    lv_style_property_t prop_ori = prop;\n\n    lv_style_attr_t attr;\n    attr = prop_ori >> 8;\n\n    lv_color_t value_act;\n    lv_res_t res = LV_RES_INV;\n    const lv_obj_t * parent = obj;\n    while(parent) {\n        lv_style_list_t * list = lv_obj_get_style_list(parent, part);\n\n        lv_state_t state = lv_obj_get_state(parent, part);\n        prop = (uint16_t)prop_ori + ((uint16_t)state << LV_STYLE_STATE_POS);\n\n        res = _lv_style_list_get_color(list, prop, &value_act);\n        if(res == LV_RES_OK) return value_act;\n\n        if(LV_STYLE_ATTR_GET_INHERIT(attr) == 0) break;\n\n        /*If not found, check the `MAIN` style first*/\n        if(part != LV_OBJ_PART_MAIN) {\n            part = LV_OBJ_PART_MAIN;\n            continue;\n        }\n\n        /*Check the parent too.*/\n        parent = lv_obj_get_parent(parent);\n    }\n\n    /*Handle unset values*/\n    prop = prop & (~LV_STYLE_STATE_MASK);\n    switch(prop) {\n        case LV_STYLE_BG_COLOR:\n        case LV_STYLE_BG_GRAD_COLOR:\n            return LV_COLOR_WHITE;\n    }\n\n    return LV_COLOR_BLACK;\n}\n\n/**\n * Get a style property of a part of an object in the object's current state.\n * If there is a running transitions it is taken into account\n * @param obj pointer to an object\n * @param part the part of the object which style property should be get.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop the property to get. E.g. `LV_STYLE_BORDER_OPA`.\n *  The state of the object will be added internally\n * @return the value of the property of the given part in the current state.\n * If the property is not found a default value will be returned.\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_opa()`\n * @note for performance reasons it's not checked if the property really has opacity type\n */\nlv_opa_t _lv_obj_get_style_opa(const lv_obj_t * obj, uint8_t part, lv_style_property_t prop)\n{\n    lv_style_property_t prop_ori = prop;\n\n    lv_style_attr_t attr;\n    attr = prop_ori >> 8;\n\n    lv_opa_t value_act;\n    lv_res_t res = LV_RES_INV;\n    const lv_obj_t * parent = obj;\n    while(parent) {\n        lv_style_list_t * list = lv_obj_get_style_list(parent, part);\n\n        if(!list->ignore_cache && list->style_cnt > 0) {\n            if(!list->valid_cache) update_style_cache((lv_obj_t *)parent, part, prop  & (~LV_STYLE_STATE_MASK));\n            bool def = false;\n            switch(prop & (~LV_STYLE_STATE_MASK)) {\n                case LV_STYLE_OPA_SCALE:\n                    if(list->opa_scale_cover) def = true;\n                    break;\n                case LV_STYLE_BG_OPA:\n                    if(list->bg_opa_cover) return LV_OPA_COVER;     /*Special case, not the default value is used*/\n                    if(list->bg_opa_transp) def = true;\n                    break;\n                case LV_STYLE_IMAGE_RECOLOR_OPA:\n                    if(list->img_recolor_opa_transp) def = true;\n                    break;\n            }\n\n            if(def) {\n                break;\n            }\n        }\n\n\n        lv_state_t state = lv_obj_get_state(parent, part);\n        prop = (uint16_t)prop_ori + ((uint16_t)state << LV_STYLE_STATE_POS);\n\n        res = _lv_style_list_get_opa(list, prop, &value_act);\n        if(res == LV_RES_OK) return value_act;\n\n        if(LV_STYLE_ATTR_GET_INHERIT(attr) == 0) break;\n\n        /*If not found, check the `MAIN` style first*/\n        if(part != LV_OBJ_PART_MAIN) {\n            part = LV_OBJ_PART_MAIN;\n            continue;\n        }\n\n        /*Check the parent too.*/\n        parent = lv_obj_get_parent(parent);\n    }\n\n    /*Handle unset values*/\n    prop = prop & (~LV_STYLE_STATE_MASK);\n    switch(prop) {\n        case LV_STYLE_BG_OPA:\n        case LV_STYLE_IMAGE_RECOLOR_OPA:\n        case LV_STYLE_PATTERN_RECOLOR_OPA:\n            return LV_OPA_TRANSP;\n    }\n\n    return LV_OPA_COVER;\n}\n\n/**\n * Get a style property of a part of an object in the object's current state.\n * If there is a running transitions it is taken into account\n * @param obj pointer to an object\n * @param part the part of the object which style property should be get.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop the property to get. E.g. `LV_STYLE_TEXT_FONT`.\n *  The state of the object will be added internally\n * @return the value of the property of the given part in the current state.\n * If the property is not found a default value will be returned.\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_opa()`\n * @note for performance reasons it's not checked if the property really has pointer type\n */\nconst void * _lv_obj_get_style_ptr(const lv_obj_t * obj, uint8_t part, lv_style_property_t prop)\n{\n    lv_style_property_t prop_ori = prop;\n\n    lv_style_attr_t attr;\n    attr = prop_ori >> 8;\n\n    const void * value_act;\n    lv_res_t res = LV_RES_INV;\n    const lv_obj_t * parent = obj;\n    while(parent) {\n        lv_style_list_t * list = lv_obj_get_style_list(parent, part);\n\n        if(!list->ignore_cache && list->style_cnt > 0) {\n            if(!list->valid_cache) update_style_cache((lv_obj_t *)parent, part, prop  & (~LV_STYLE_STATE_MASK));\n            bool def = false;\n            switch(prop  & (~LV_STYLE_STATE_MASK)) {\n                case LV_STYLE_VALUE_STR:\n                    if(list->value_txt_str) def = true;\n                    break;\n                case LV_STYLE_PATTERN_IMAGE:\n                    if(list->pattern_img_null) def = true;\n                    break;\n                case LV_STYLE_TEXT_FONT:\n                    if(list->text_font_normal) def = true;\n                    break;\n            }\n\n            if(def) {\n                break;\n            }\n        }\n\n        lv_state_t state = lv_obj_get_state(parent, part);\n        prop = (uint16_t)prop_ori + ((uint16_t)state << LV_STYLE_STATE_POS);\n\n        res = _lv_style_list_get_ptr(list, prop, &value_act);\n        if(res == LV_RES_OK)  return value_act;\n\n        if(LV_STYLE_ATTR_GET_INHERIT(attr) == 0) break;\n\n        /*If not found, check the `MAIN` style first*/\n        if(part != LV_OBJ_PART_MAIN) {\n            part = LV_OBJ_PART_MAIN;\n            continue;\n        }\n\n        /*Check the parent too.*/\n        parent = lv_obj_get_parent(parent);\n    }\n\n    /*Handle unset values*/\n    prop = prop & (~LV_STYLE_STATE_MASK);\n    switch(prop) {\n        case LV_STYLE_TEXT_FONT:\n        case LV_STYLE_VALUE_FONT:\n            return lv_theme_get_font_normal();\n#if LV_USE_ANIMATION\n        case LV_STYLE_TRANSITION_PATH:\n            return &lv_anim_path_def;\n#endif",
        "res_region": "    _LV_LL_READ(obj->child_ll, i) {\n        cnt++;                                     /*Count the child*/\n        cnt += lv_obj_count_children_recursive(i); /*recursively count children's children*/",
        "lookback": "        cnt++;                                     /*Count the child*/",
        "lookahead": "    }",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 1318,
        "end_line": 3968,
        "merge_gen_region": null,
        "confidence": 0.7421460151672363,
        "hesitated": true
    },
    {
        "a_contents": "    else if(sign == LV_SIGNAL_COORD_CHG) {\n            bool col_fr =   _lv_grid_has_fr_col(obj);\n            bool col_fill = _lv_grid_has_fill_col(obj);\n            bool row_fr =   _lv_grid_has_fr_row(obj);\n            bool row_fill = _lv_grid_has_fill_row(obj);\n\n            if(param == NULL ||\n              (lv_area_get_width(param) != lv_obj_get_width(obj) && (col_fr || col_fill)) ||\n              (lv_area_get_height(param) != lv_obj_get_height(obj) && (row_fr || row_fill)))\n        {\n            _lv_grid_full_refresh(obj);",
        "b_contents": "    else if(sign == LV_SIGNAL_CLEANUP) {\n        lv_obj_clean_style_list(obj, LV_OBJ_PART_MAIN);\n    }\n\n    return res;\n}\n\n/**\n * Reposition the children of an object. (Called recursively)\n * @param obj pointer to an object which children will be repositioned\n * @param x_diff x coordinate shift\n * @param y_diff y coordinate shift\n */\nstatic void refresh_children_position(lv_obj_t * obj, lv_coord_t x_diff, lv_coord_t y_diff)\n{\n    lv_obj_t * i;\n    _LV_LL_READ(obj->child_ll, i) {\n        i->coords.x1 += x_diff;\n        i->coords.y1 += y_diff;\n        i->coords.x2 += x_diff;\n        i->coords.y2 += y_diff;\n\n        refresh_children_position(i, x_diff, y_diff);\n    }\n}\n\n/**\n * Refresh the style of all children of an object. (Called recursively)\n * @param style refresh objects only with this style_list.\n * @param obj pointer to an object\n */\nstatic void report_style_mod_core(void * style, lv_obj_t * obj)\n{\n    uint8_t part;\n    for(part = 0; part != _LV_OBJ_PART_REAL_LAST; part++) {\n        lv_style_list_t * list = lv_obj_get_style_list(obj, part);\n        if(list == NULL) break;\n\n        uint8_t ci;\n        for(ci = 0; ci < list->style_cnt; ci++) {\n            /* changed class to _class to allow compilation as c++ */\n            lv_style_t * _class = lv_style_list_get_style(list, ci);\n            if(_class == style || style == NULL) { \n                lv_obj_refresh_style(obj, part, LV_STYLE_PROP_ALL);\n                break;\n            }",
        "base_contents": "    else if(sign == LV_SIGNAL_CLEANUP) {\n        lv_obj_clean_style_list(obj, LV_OBJ_PART_MAIN);\n    }\n\n    return res;\n}\n\n/**\n * Reposition the children of an object. (Called recursively)\n * @param obj pointer to an object which children will be repositioned\n * @param x_diff x coordinate shift\n * @param y_diff y coordinate shift\n */\nstatic void refresh_children_position(lv_obj_t * obj, lv_coord_t x_diff, lv_coord_t y_diff)\n{\n    lv_obj_t * i;\n    _LV_LL_READ(obj->child_ll, i) {\n        i->coords.x1 += x_diff;\n        i->coords.y1 += y_diff;\n        i->coords.x2 += x_diff;\n        i->coords.y2 += y_diff;\n\n        refresh_children_position(i, x_diff, y_diff);\n    }\n}\n\n/**\n * Refresh the style of all children of an object. (Called recursively)\n * @param style refresh objects only with this style_list.\n * @param obj pointer to an object\n */\nstatic void report_style_mod_core(void * style, lv_obj_t * obj)\n{\n    uint8_t part;\n    for(part = 0; part != _LV_OBJ_PART_REAL_LAST; part++) {\n        lv_style_list_t * list = lv_obj_get_style_list(obj, part);\n        if(list == NULL) break;\n\n        uint8_t ci;\n        for(ci = 0; ci < list->style_cnt; ci++) {\n            lv_style_t * class = lv_style_list_get_style(list, ci);\n            if(class == style || style == NULL) {\n                lv_obj_refresh_style(obj, part, LV_STYLE_PROP_ALL);\n                break;\n            }",
        "res_region": "    else if(sign == LV_SIGNAL_COORD_CHG) {\n            bool col_fr =   _lv_grid_has_fr_col(obj);\n            bool col_fill = _lv_grid_has_fill_col(obj);\n            bool row_fr =   _lv_grid_has_fr_row(obj);\n            bool row_fill = _lv_grid_has_fill_row(obj);\n\n            if(param == NULL ||\n              (lv_area_get_width(param) != lv_obj_get_width(obj) && (col_fr || col_fill)) ||\n              (lv_area_get_height(param) != lv_obj_get_height(obj) && (row_fr || row_fill)))\n        {\n            _lv_grid_full_refresh(obj);",
        "lookback": "            bool col_fr =   _lv_grid_has_fr_col(obj);",
        "lookahead": "        }",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 4699,
        "end_line": 4804,
        "merge_gen_region": "outputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutputoutput",
        "confidence": 0.8906324505805969,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "",
        "b_contents": "\nstatic bool style_prop_is_cacheble(lv_style_property_t prop)\n{\n\n    switch(prop) {\n        case LV_STYLE_PROP_ALL:\n        case LV_STYLE_BG_GRAD_DIR:\n        case LV_STYLE_CLIP_CORNER:\n        case LV_STYLE_TEXT_LETTER_SPACE:\n        case LV_STYLE_TEXT_LINE_SPACE:\n        case LV_STYLE_TEXT_FONT:\n        case LV_STYLE_TRANSFORM_ANGLE:\n        case LV_STYLE_TRANSFORM_WIDTH:\n        case LV_STYLE_TRANSFORM_HEIGHT:\n        case LV_STYLE_TRANSFORM_ZOOM:\n        case LV_STYLE_BORDER_WIDTH:\n        case LV_STYLE_OUTLINE_WIDTH:\n        case LV_STYLE_RADIUS:\n        case LV_STYLE_SHADOW_WIDTH:\n        case LV_STYLE_OPA_SCALE:\n        case LV_STYLE_BG_OPA:\n        case LV_STYLE_BORDER_SIDE:\n        case LV_STYLE_BORDER_POST:\n        case LV_STYLE_IMAGE_RECOLOR_OPA:\n        case LV_STYLE_VALUE_STR:\n        case LV_STYLE_PATTERN_IMAGE:\n        case LV_STYLE_PAD_TOP:\n        case LV_STYLE_PAD_BOTTOM:\n        case LV_STYLE_PAD_LEFT:\n        case LV_STYLE_PAD_RIGHT:\n        case LV_STYLE_BG_BLEND_MODE:\n        case LV_STYLE_BORDER_BLEND_MODE:\n        case LV_STYLE_IMAGE_BLEND_MODE:\n        case LV_STYLE_LINE_BLEND_MODE:\n        case LV_STYLE_OUTLINE_BLEND_MODE:\n        case LV_STYLE_PATTERN_BLEND_MODE:\n        case LV_STYLE_SHADOW_BLEND_MODE:\n        case LV_STYLE_TEXT_BLEND_MODE:\n        case LV_STYLE_VALUE_BLEND_MODE:\n            return true;\n            break;\n        default:\n            return false;\n    }\n}\n\n/**\n * Update the cache of style list\n * @param obj pointer to an obejct\n * @param part the part of the object\n * @param prop the property which triggered the update\n */\nstatic void update_style_cache(lv_obj_t * obj, uint8_t part, uint16_t prop)\n{\n    if(style_prop_is_cacheble(prop) == false) return;\n\n    lv_style_list_t * list = lv_obj_get_style_list(obj, part);\n\n    bool ignore_cache_ori = list->ignore_cache;\n    list->ignore_cache = 1;\n\n#if LV_USE_OPA_SCALE\n    list->opa_scale_cover    = lv_obj_get_style_opa_scale(obj, part) == LV_OPA_COVER ? 1 : 0;\n#else\n    list->opa_scale_cover    = 1;\n#endif\n    list->text_decor_none    = lv_obj_get_style_text_decor(obj, part) == LV_TEXT_DECOR_NONE ? 1 : 0;\n    list->text_font_normal    = lv_obj_get_style_text_font(obj, part) == LV_THEME_DEFAULT_FONT_NORMAL ? 1 : 0;\n\n    list->text_space_zero = 1;\n    if(lv_obj_get_style_text_letter_space(obj, part) != 0 ||\n       lv_obj_get_style_text_line_space(obj, part) != 0) {\n        list->text_space_zero = 0;\n    }\n\n\n    lv_opa_t bg_opa = lv_obj_get_style_bg_opa(obj, part);\n    list->bg_opa_transp    = bg_opa == LV_OPA_TRANSP ? 1 : 0;\n    list->bg_opa_cover     = bg_opa == LV_OPA_COVER ? 1 : 0;\n\n    list->bg_grad_dir_none  = lv_obj_get_style_bg_grad_dir(obj, part) == LV_GRAD_DIR_NONE ? 1 : 0;\n    list->border_width_zero = lv_obj_get_style_border_width(obj, part) == 0 ? 1 : 0;\n    list->border_side_full = lv_obj_get_style_border_side(obj, part) == LV_BORDER_SIDE_FULL ? 1 : 0;\n    list->border_post_off = lv_obj_get_style_border_post(obj, part) == 0 ? 1 : 0;\n    list->clip_corner_off   = lv_obj_get_style_clip_corner(obj, part) == false ? 1 : 0;\n    list->img_recolor_opa_transp    = lv_obj_get_style_image_recolor_opa(obj, part) == LV_OPA_TRANSP ? 1 : 0;\n    list->outline_width_zero    = lv_obj_get_style_outline_width(obj, part) == 0 ? 1 : 0;\n    list->pattern_img_null    = lv_obj_get_style_pattern_image(obj, part) == NULL ? 1 : 0;\n    list->radius_zero    = lv_obj_get_style_radius(obj, part) == 0 ? 1 : 0;\n    list->shadow_width_zero    = lv_obj_get_style_shadow_width(obj, part) == 0 ? 1 : 0;\n    list->value_txt_str    = lv_obj_get_style_value_str(obj, part) == NULL ? 1 : 0;\n\n\n    list->transform_all_zero  = 1;\n    if(lv_obj_get_style_transform_angle(obj, part) != 0 ||\n       lv_obj_get_style_transform_width(obj, part) != 0 ||\n       lv_obj_get_style_transform_height(obj, part) != 0 ||\n       lv_obj_get_style_transform_zoom(obj, part) != LV_IMG_ZOOM_NONE) {\n        list->transform_all_zero  = 0;\n    }\n\n    list->pad_all_zero  = 1;\n    if(lv_obj_get_style_pad_top(obj, part) != 0 ||\n       lv_obj_get_style_pad_bottom(obj, part) != 0 ||\n       lv_obj_get_style_pad_left(obj, part) != 0 ||\n       lv_obj_get_style_pad_right(obj, part) != 0) {\n        list->pad_all_zero  = 0;\n    }\n\n    list->blend_mode_all_normal = 1;\n#if LV_USE_BLEND_MODES\n    if(lv_obj_get_style_bg_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||\n       lv_obj_get_style_border_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||\n       lv_obj_get_style_pattern_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||\n       lv_obj_get_style_outline_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||\n       lv_obj_get_style_value_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||\n       lv_obj_get_style_text_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||\n       lv_obj_get_style_line_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||\n       lv_obj_get_style_image_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||\n       lv_obj_get_style_shadow_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL) {\n        list->blend_mode_all_normal = 0;\n    }\n#endif\n    list->ignore_cache = ignore_cache_ori;\n    list->valid_cache = 1;\n}\n\n/**\n * Update the cache of style list\n * @param obj pointer to an object\n * @param part the part of the object\n */\nstatic void update_style_cache_children(lv_obj_t * obj)\n{\n    uint8_t part;\n    for(part = 0; part != _LV_OBJ_PART_REAL_LAST; part++) {\n        lv_style_list_t * list = lv_obj_get_style_list(obj, part);\n        if(list == NULL) break;\n\n        bool ignore_cache_ori = list->ignore_cache;\n        list->ignore_cache = 1;\n\n        list->opa_scale_cover    = lv_obj_get_style_opa_scale(obj, part) == LV_OPA_COVER ? 1 : 0;\n        list->text_decor_none    = lv_obj_get_style_text_decor(obj, part) == LV_TEXT_DECOR_NONE ? 1 : 0;\n        list->text_font_normal    = lv_obj_get_style_text_font(obj, part) == lv_theme_get_font_normal() ? 1 : 0;\n        list->img_recolor_opa_transp    = lv_obj_get_style_image_recolor_opa(obj, part) == LV_OPA_TRANSP ? 1 : 0;\n\n        list->text_space_zero = 1;\n        if(lv_obj_get_style_text_letter_space(obj, part) != 0 ||\n           lv_obj_get_style_text_line_space(obj, part) != 0) {\n            list->text_space_zero = 0;\n        }\n\n        list->ignore_cache = ignore_cache_ori;\n    }\n\n    lv_obj_t * child = lv_obj_get_child(obj, NULL);\n    while(child) {\n        update_style_cache_children(child);\n        child = lv_obj_get_child(obj, child);\n    }\n\n}\n\n/**\n * Mark the object and all of it's children's style lists as invalid.\n * The cache will be updated when a cached property asked nest time\n * @param obj pointer to an object\n */\nstatic void invalidate_style_cache(lv_obj_t * obj, uint8_t part, lv_style_property_t prop)\n{\n    if(style_prop_is_cacheble(prop) == false) return;\n\n    if(part != LV_OBJ_PART_ALL) {\n        lv_style_list_t * list = lv_obj_get_style_list(obj, part);\n        if(list == NULL) return;\n        list->valid_cache = 0;\n    }\n    else {\n\n        for(part = 0; part < _LV_OBJ_PART_REAL_FIRST; part++) {\n            lv_style_list_t * list = lv_obj_get_style_list(obj, part);\n            if(list == NULL) break;\n            list->valid_cache = 0;\n        }\n        for(part = _LV_OBJ_PART_REAL_FIRST; part < 0xFF; part++) {\n            lv_style_list_t * list = lv_obj_get_style_list(obj, part);\n            if(list == NULL) break;\n            list->valid_cache = 0;\n        }\n    }\n\n    lv_obj_t * child = lv_obj_get_child(obj, NULL);\n    while(child) {\n        update_style_cache_children(child);\n        child = lv_obj_get_child(obj, child);\n    }\n}\n\nstatic void style_snapshot(lv_obj_t * obj, uint8_t part, style_snapshot_t * shot)\n{\n    _lv_obj_disable_style_caching(obj, true);\n    _lv_memset_00(shot, sizeof(style_snapshot_t));\n    lv_draw_rect_dsc_init(&shot->rect);\n    lv_draw_label_dsc_init(&shot->label);\n    lv_draw_img_dsc_init(&shot->img);\n    lv_draw_line_dsc_init(&shot->line);\n\n    lv_obj_init_draw_rect_dsc(obj, part, &shot->rect);\n    lv_obj_init_draw_label_dsc(obj, part, &shot->label);\n    lv_obj_init_draw_img_dsc(obj, part, &shot->img);\n    lv_obj_init_draw_line_dsc(obj, part, &shot->line);\n\n\n    shot->pad_top = lv_obj_get_style_pad_top(obj, part);\n    shot->pad_bottom = lv_obj_get_style_pad_bottom(obj, part);\n    shot->pad_right = lv_obj_get_style_pad_right(obj, part);\n    shot->pad_left = lv_obj_get_style_pad_left(obj, part);\n    shot->pad_inner = lv_obj_get_style_pad_inner(obj, part);\n    shot->margin_top = lv_obj_get_style_margin_top(obj, part);\n    shot->margin_bottom = lv_obj_get_style_margin_bottom(obj, part);\n    shot->margin_left = lv_obj_get_style_margin_left(obj, part);\n    shot->margin_right = lv_obj_get_style_margin_right(obj, part);\n    shot->size = lv_obj_get_style_size(obj, part);\n    shot->transform_width = lv_obj_get_style_transform_width(obj, part);\n    shot->transform_height = lv_obj_get_style_transform_height(obj, part);\n    shot->transform_angle = lv_obj_get_style_transform_angle(obj, part);\n    shot->transform_zoom = lv_obj_get_style_transform_zoom(obj, part);\n    shot->scale_width = lv_obj_get_style_scale_width(obj, part);\n    shot->scale_border_width = lv_obj_get_style_scale_border_width(obj, part);\n    shot->scale_end_border_width = lv_obj_get_style_scale_end_border_width(obj, part);\n    shot->scale_end_line_width = lv_obj_get_style_scale_end_line_width(obj, part);\n    shot->scale_grad_color = lv_obj_get_style_scale_grad_color(obj, part);\n    shot->scale_end_color = lv_obj_get_style_scale_end_color(obj, part);\n    shot->opa_scale = lv_obj_get_style_opa_scale(obj, part);\n    shot->clip_corder = lv_obj_get_style_clip_corner(obj, part);\n    shot->border_post  = lv_obj_get_style_border_post(obj, part);\n\n    _lv_obj_disable_style_caching(obj, false);\n}\n\nstatic style_snapshot_res_t style_snapshot_compare(style_snapshot_t * shot1, style_snapshot_t * shot2)\n{\n    if(memcmp(shot1, shot2, sizeof(style_snapshot_t)) == 0) return STYLE_COMPARE_SAME;\n\n\n    if(shot1->pad_top != shot2->pad_top) return STYLE_COMPARE_DIFF;\n    if(shot1->pad_bottom != shot2->pad_bottom) return STYLE_COMPARE_DIFF;\n    if(shot1->pad_left != shot2->pad_right) return STYLE_COMPARE_DIFF;\n    if(shot1->pad_right != shot2->pad_right) return STYLE_COMPARE_DIFF;\n    if(shot1->pad_top != shot2->pad_top) return STYLE_COMPARE_DIFF;\n    if(shot1->pad_inner != shot2->pad_inner) return STYLE_COMPARE_DIFF;\n    if(shot1->margin_top != shot2->margin_top) return STYLE_COMPARE_DIFF;\n    if(shot1->margin_bottom != shot2->margin_bottom) return STYLE_COMPARE_DIFF;\n    if(shot1->margin_left != shot2->margin_right) return STYLE_COMPARE_DIFF;\n    if(shot1->margin_right != shot2->margin_right) return STYLE_COMPARE_DIFF;\n    if(shot1->margin_top != shot2->margin_top) return STYLE_COMPARE_DIFF;\n    if(shot1->transform_width != shot2->transform_width) return STYLE_COMPARE_DIFF;\n    if(shot1->transform_height != shot2->transform_height) return STYLE_COMPARE_DIFF;\n    if(shot1->transform_angle != shot2->transform_angle) return STYLE_COMPARE_DIFF;\n    if(shot1->transform_zoom != shot2->transform_zoom) return STYLE_COMPARE_DIFF;\n    if(shot1->rect.outline_width != shot2->rect.outline_width) return STYLE_COMPARE_DIFF;\n    if(shot1->rect.outline_pad != shot2->rect.outline_pad) return STYLE_COMPARE_DIFF;\n    if(shot1->rect.value_font != shot2->rect.value_font) return STYLE_COMPARE_DIFF;\n    if(shot1->rect.value_align != shot2->rect.value_align) return STYLE_COMPARE_DIFF;\n    if(shot1->rect.value_font != shot2->rect.value_font) return STYLE_COMPARE_DIFF;\n    if(shot1->rect.shadow_spread != shot2->rect.shadow_spread) return STYLE_COMPARE_DIFF;\n    if(shot1->rect.shadow_width != shot2->rect.shadow_width) return STYLE_COMPARE_DIFF;\n    if(shot1->rect.shadow_ofs_x != shot2->rect.shadow_ofs_x) return STYLE_COMPARE_DIFF;\n    if(shot1->rect.shadow_ofs_y != shot2->rect.shadow_ofs_y) return STYLE_COMPARE_DIFF;\n\n    /*If not returned earlier its just a visual difference, a simple redraw is enough*/\n    return STYLE_COMPARE_VISUAL_DIFF;\n}",
        "base_contents": "\nstatic bool style_prop_is_cacheble(lv_style_property_t prop)\n{\n\n    switch(prop) {\n        case LV_STYLE_PROP_ALL:\n        case LV_STYLE_BG_GRAD_DIR:\n        case LV_STYLE_CLIP_CORNER:\n        case LV_STYLE_TEXT_LETTER_SPACE:\n        case LV_STYLE_TEXT_LINE_SPACE:\n        case LV_STYLE_TEXT_FONT:\n        case LV_STYLE_TRANSFORM_ANGLE:\n        case LV_STYLE_TRANSFORM_WIDTH:\n        case LV_STYLE_TRANSFORM_HEIGHT:\n        case LV_STYLE_TRANSFORM_ZOOM:\n        case LV_STYLE_BORDER_WIDTH:\n        case LV_STYLE_OUTLINE_WIDTH:\n        case LV_STYLE_RADIUS:\n        case LV_STYLE_SHADOW_WIDTH:\n        case LV_STYLE_OPA_SCALE:\n        case LV_STYLE_BG_OPA:\n        case LV_STYLE_BORDER_SIDE:\n        case LV_STYLE_BORDER_POST:\n        case LV_STYLE_IMAGE_RECOLOR_OPA:\n        case LV_STYLE_VALUE_STR:\n        case LV_STYLE_PATTERN_IMAGE:\n        case LV_STYLE_PAD_TOP:\n        case LV_STYLE_PAD_BOTTOM:\n        case LV_STYLE_PAD_LEFT:\n        case LV_STYLE_PAD_RIGHT:\n        case LV_STYLE_BG_BLEND_MODE:\n        case LV_STYLE_BORDER_BLEND_MODE:\n        case LV_STYLE_IMAGE_BLEND_MODE:\n        case LV_STYLE_LINE_BLEND_MODE:\n        case LV_STYLE_OUTLINE_BLEND_MODE:\n        case LV_STYLE_PATTERN_BLEND_MODE:\n        case LV_STYLE_SHADOW_BLEND_MODE:\n        case LV_STYLE_TEXT_BLEND_MODE:\n        case LV_STYLE_VALUE_BLEND_MODE:\n            return true;\n            break;\n        default:\n            return false;\n    }\n}\n\n/**\n * Update the cache of style list\n * @param obj pointer to an obejct\n * @param part the part of the object\n * @param prop the property which triggered the update\n */\nstatic void update_style_cache(lv_obj_t * obj, uint8_t part, uint16_t prop)\n{\n    if(style_prop_is_cacheble(prop) == false) return;\n\n    lv_style_list_t * list = lv_obj_get_style_list(obj, part);\n\n    bool ignore_cache_ori = list->ignore_cache;\n    list->ignore_cache = 1;\n\n#if LV_USE_OPA_SCALE\n    list->opa_scale_cover    = lv_obj_get_style_opa_scale(obj, part) == LV_OPA_COVER ? 1 : 0;\n#else\n    list->opa_scale_cover    = 1;\n#endif\n    list->text_decor_none    = lv_obj_get_style_text_decor(obj, part) == LV_TEXT_DECOR_NONE ? 1 : 0;\n    list->text_font_normal    = lv_obj_get_style_text_font(obj, part) == LV_THEME_DEFAULT_FONT_NORMAL ? 1 : 0;\n\n    list->text_space_zero = 1;\n    if(lv_obj_get_style_text_letter_space(obj, part) != 0 ||\n       lv_obj_get_style_text_line_space(obj, part) != 0) {\n        list->text_space_zero = 0;\n    }\n\n\n    lv_opa_t bg_opa = lv_obj_get_style_bg_opa(obj, part);\n    list->bg_opa_transp    = bg_opa == LV_OPA_TRANSP ? 1 : 0;\n    list->bg_opa_cover     = bg_opa == LV_OPA_COVER ? 1 : 0;\n\n    list->bg_grad_dir_none  = lv_obj_get_style_bg_grad_dir(obj, part) == LV_GRAD_DIR_NONE ? 1 : 0;\n    list->border_width_zero = lv_obj_get_style_border_width(obj, part) == 0 ? 1 : 0;\n    list->border_side_full = lv_obj_get_style_border_side(obj, part) == LV_BORDER_SIDE_FULL ? 1 : 0;\n    list->border_post_off = lv_obj_get_style_border_post(obj, part) == 0 ? 1 : 0;\n    list->clip_corner_off   = lv_obj_get_style_clip_corner(obj, part) == false ? 1 : 0;\n    list->img_recolor_opa_transp    = lv_obj_get_style_image_recolor_opa(obj, part) == LV_OPA_TRANSP ? 1 : 0;\n    list->outline_width_zero    = lv_obj_get_style_outline_width(obj, part) == 0 ? 1 : 0;\n    list->pattern_img_null    = lv_obj_get_style_pattern_image(obj, part) == NULL ? 1 : 0;\n    list->radius_zero    = lv_obj_get_style_radius(obj, part) == 0 ? 1 : 0;\n    list->shadow_width_zero    = lv_obj_get_style_shadow_width(obj, part) == 0 ? 1 : 0;\n    list->value_txt_str    = lv_obj_get_style_value_str(obj, part) == NULL ? 1 : 0;\n\n\n    list->transform_all_zero  = 1;\n    if(lv_obj_get_style_transform_angle(obj, part) != 0 ||\n       lv_obj_get_style_transform_width(obj, part) != 0 ||\n       lv_obj_get_style_transform_height(obj, part) != 0 ||\n       lv_obj_get_style_transform_zoom(obj, part) != LV_IMG_ZOOM_NONE) {\n        list->transform_all_zero  = 0;\n    }\n\n    list->pad_all_zero  = 1;\n    if(lv_obj_get_style_pad_top(obj, part) != 0 ||\n       lv_obj_get_style_pad_bottom(obj, part) != 0 ||\n       lv_obj_get_style_pad_left(obj, part) != 0 ||\n       lv_obj_get_style_pad_right(obj, part) != 0) {\n        list->pad_all_zero  = 0;\n    }\n\n    list->blend_mode_all_normal = 1;\n#if LV_USE_BLEND_MODES\n    if(lv_obj_get_style_bg_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||\n       lv_obj_get_style_border_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||\n       lv_obj_get_style_pattern_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||\n       lv_obj_get_style_outline_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||\n       lv_obj_get_style_value_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||\n       lv_obj_get_style_text_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||\n       lv_obj_get_style_line_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||\n       lv_obj_get_style_image_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||\n       lv_obj_get_style_shadow_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL) {\n        list->blend_mode_all_normal = 0;\n    }\n#endif\n    list->ignore_cache = ignore_cache_ori;\n    list->valid_cache = 1;\n}\n\n/**\n * Update the cache of style list\n * @param obj pointer to an object\n * @param part the part of the object\n */\nstatic void update_style_cache_children(lv_obj_t * obj)\n{\n    uint8_t part;\n    for(part = 0; part != _LV_OBJ_PART_REAL_LAST; part++) {\n        lv_style_list_t * list = lv_obj_get_style_list(obj, part);\n        if(list == NULL) break;\n\n        bool ignore_cache_ori = list->ignore_cache;\n        list->ignore_cache = 1;\n\n        list->opa_scale_cover    = lv_obj_get_style_opa_scale(obj, part) == LV_OPA_COVER ? 1 : 0;\n        list->text_decor_none    = lv_obj_get_style_text_decor(obj, part) == LV_TEXT_DECOR_NONE ? 1 : 0;\n        list->text_font_normal    = lv_obj_get_style_text_font(obj, part) == lv_theme_get_font_normal() ? 1 : 0;\n        list->img_recolor_opa_transp    = lv_obj_get_style_image_recolor_opa(obj, part) == LV_OPA_TRANSP ? 1 : 0;\n\n        list->text_space_zero = 1;\n        if(lv_obj_get_style_text_letter_space(obj, part) != 0 ||\n           lv_obj_get_style_text_line_space(obj, part) != 0) {\n            list->text_space_zero = 0;\n        }\n\n        list->ignore_cache = ignore_cache_ori;\n    }\n\n    lv_obj_t * child = lv_obj_get_child(obj, NULL);\n    while(child) {\n        update_style_cache_children(child);\n        child = lv_obj_get_child(obj, child);\n    }\n\n}\n\n/**\n * Mark the object and all of it's children's style lists as invalid.\n * The cache will be updated when a cached property asked nest time\n * @param obj pointer to an object\n */\nstatic void invalidate_style_cache(lv_obj_t * obj, uint8_t part, lv_style_property_t prop)\n{\n    if(style_prop_is_cacheble(prop) == false) return;\n\n    if(part != LV_OBJ_PART_ALL) {\n        lv_style_list_t * list = lv_obj_get_style_list(obj, part);\n        if(list == NULL) return;\n        list->valid_cache = 0;\n    }\n    else {\n\n        for(part = 0; part < _LV_OBJ_PART_REAL_FIRST; part++) {\n            lv_style_list_t * list = lv_obj_get_style_list(obj, part);\n            if(list == NULL) break;\n            list->valid_cache = 0;\n        }\n        for(part = _LV_OBJ_PART_REAL_FIRST; part < 0xFF; part++) {\n            lv_style_list_t * list = lv_obj_get_style_list(obj, part);\n            if(list == NULL) break;\n            list->valid_cache = 0;\n        }\n    }\n\n    lv_obj_t * child = lv_obj_get_child(obj, NULL);\n    while(child) {\n        update_style_cache_children(child);\n        child = lv_obj_get_child(obj, child);\n    }\n}\n\n#if LV_USE_ANIMATION\nstatic void style_snapshot(lv_obj_t * obj, uint8_t part, style_snapshot_t * shot)\n{\n    _lv_obj_disable_style_caching(obj, true);\n    _lv_memset_00(shot, sizeof(style_snapshot_t));\n    lv_draw_rect_dsc_init(&shot->rect);\n    lv_draw_label_dsc_init(&shot->label);\n    lv_draw_img_dsc_init(&shot->img);\n    lv_draw_line_dsc_init(&shot->line);\n\n    lv_obj_init_draw_rect_dsc(obj, part, &shot->rect);\n    lv_obj_init_draw_label_dsc(obj, part, &shot->label);\n    lv_obj_init_draw_img_dsc(obj, part, &shot->img);\n    lv_obj_init_draw_line_dsc(obj, part, &shot->line);\n\n\n    shot->pad_top = lv_obj_get_style_pad_top(obj, part);\n    shot->pad_bottom = lv_obj_get_style_pad_bottom(obj, part);\n    shot->pad_right = lv_obj_get_style_pad_right(obj, part);\n    shot->pad_left = lv_obj_get_style_pad_left(obj, part);\n    shot->pad_inner = lv_obj_get_style_pad_inner(obj, part);\n    shot->margin_top = lv_obj_get_style_margin_top(obj, part);\n    shot->margin_bottom = lv_obj_get_style_margin_bottom(obj, part);\n    shot->margin_left = lv_obj_get_style_margin_left(obj, part);\n    shot->margin_right = lv_obj_get_style_margin_right(obj, part);\n    shot->size = lv_obj_get_style_size(obj, part);\n    shot->transform_width = lv_obj_get_style_transform_width(obj, part);\n    shot->transform_height = lv_obj_get_style_transform_height(obj, part);\n    shot->transform_angle = lv_obj_get_style_transform_angle(obj, part);\n    shot->transform_zoom = lv_obj_get_style_transform_zoom(obj, part);\n    shot->scale_width = lv_obj_get_style_scale_width(obj, part);\n    shot->scale_border_width = lv_obj_get_style_scale_border_width(obj, part);\n    shot->scale_end_border_width = lv_obj_get_style_scale_end_border_width(obj, part);\n    shot->scale_end_line_width = lv_obj_get_style_scale_end_line_width(obj, part);\n    shot->scale_grad_color = lv_obj_get_style_scale_grad_color(obj, part);\n    shot->scale_end_color = lv_obj_get_style_scale_end_color(obj, part);\n    shot->opa_scale = lv_obj_get_style_opa_scale(obj, part);\n    shot->clip_corder = lv_obj_get_style_clip_corner(obj, part);\n    shot->border_post  = lv_obj_get_style_border_post(obj, part);\n\n    _lv_obj_disable_style_caching(obj, false);\n}\n\nstatic style_snapshot_res_t style_snapshot_compare(style_snapshot_t * shot1, style_snapshot_t * shot2)\n{\n    if(memcmp(shot1, shot2, sizeof(style_snapshot_t)) == 0) return STYLE_COMPARE_SAME;\n\n\n    if(shot1->pad_top != shot2->pad_top) return STYLE_COMPARE_DIFF;\n    if(shot1->pad_bottom != shot2->pad_bottom) return STYLE_COMPARE_DIFF;\n    if(shot1->pad_left != shot2->pad_right) return STYLE_COMPARE_DIFF;\n    if(shot1->pad_right != shot2->pad_right) return STYLE_COMPARE_DIFF;\n    if(shot1->pad_top != shot2->pad_top) return STYLE_COMPARE_DIFF;\n    if(shot1->pad_inner != shot2->pad_inner) return STYLE_COMPARE_DIFF;\n    if(shot1->margin_top != shot2->margin_top) return STYLE_COMPARE_DIFF;\n    if(shot1->margin_bottom != shot2->margin_bottom) return STYLE_COMPARE_DIFF;\n    if(shot1->margin_left != shot2->margin_right) return STYLE_COMPARE_DIFF;\n    if(shot1->margin_right != shot2->margin_right) return STYLE_COMPARE_DIFF;\n    if(shot1->margin_top != shot2->margin_top) return STYLE_COMPARE_DIFF;\n    if(shot1->transform_width != shot2->transform_width) return STYLE_COMPARE_DIFF;\n    if(shot1->transform_height != shot2->transform_height) return STYLE_COMPARE_DIFF;\n    if(shot1->transform_angle != shot2->transform_angle) return STYLE_COMPARE_DIFF;\n    if(shot1->transform_zoom != shot2->transform_zoom) return STYLE_COMPARE_DIFF;\n    if(shot1->rect.outline_width != shot2->rect.outline_width) return STYLE_COMPARE_DIFF;\n    if(shot1->rect.outline_pad != shot2->rect.outline_pad) return STYLE_COMPARE_DIFF;\n    if(shot1->rect.value_font != shot2->rect.value_font) return STYLE_COMPARE_DIFF;\n    if(shot1->rect.value_align != shot2->rect.value_align) return STYLE_COMPARE_DIFF;\n    if(shot1->rect.value_font != shot2->rect.value_font) return STYLE_COMPARE_DIFF;\n    if(shot1->rect.shadow_spread != shot2->rect.shadow_spread) return STYLE_COMPARE_DIFF;\n    if(shot1->rect.shadow_width != shot2->rect.shadow_width) return STYLE_COMPARE_DIFF;\n    if(shot1->rect.shadow_ofs_x != shot2->rect.shadow_ofs_x) return STYLE_COMPARE_DIFF;\n    if(shot1->rect.shadow_ofs_y != shot2->rect.shadow_ofs_y) return STYLE_COMPARE_DIFF;\n\n    /*If not returned earlier its just a visual difference, a simple redraw is enough*/\n    return STYLE_COMPARE_VISUAL_DIFF;\n}\n#endif",
        "res_region": "",
        "lookback": "",
        "lookahead": "",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 4886,
        "end_line": 5439,
        "merge_gen_region": "",
        "confidence": 0.995654821395874,
        "hesitated": false,
        "resolved": true
    }
]