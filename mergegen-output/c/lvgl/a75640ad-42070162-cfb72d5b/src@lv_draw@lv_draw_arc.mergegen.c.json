[
    {
        "a_contents": "    lv_draw_mask_param_t mask_angle_param;\n    lv_draw_mask_angle_init(&mask_angle_param, center_x, center_y, start_angle, end_angle);",
        "b_contents": "#if LV_ANTIALIAS\n    thickness--;\n    radius--;\n#endif\n\n    lv_coord_t r_out = radius;\n    lv_coord_t r_in  = r_out - thickness;\n    int16_t deg_base;\n    int16_t deg;\n    lv_coord_t x_start[4];\n    lv_coord_t x_end[4];",
        "base_contents": "    lv_coord_t r_out = radius;\n    lv_coord_t r_in  = r_out - thickness;\n    int16_t deg_base;\n    int16_t deg;\n    lv_coord_t x_start[4];\n    lv_coord_t x_end[4];",
        "res_region": "    lv_draw_mask_param_t mask_angle_param;\n    lv_draw_mask_angle_init(&mask_angle_param, center_x, center_y, start_angle, end_angle);",
        "lookback": "    lv_draw_mask_angle_init(&mask_angle_param, center_x, center_y, start_angle, end_angle);",
        "lookahead": "",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 56,
        "end_line": 78,
        "merge_gen_region": null,
        "confidence": 0.8679417967796326,
        "hesitated": true
    },
    {
        "a_contents": "    lv_area_t area;\n    area.x1 = center_x - radius;\n    area.y1 = center_y - radius;\n    area.x2 = center_x + radius;\n    area.y2 = center_y + radius;",
        "b_contents": "    bool (*deg_test)(uint16_t, uint16_t, uint16_t);\n    if(start_angle <= end_angle)\n        deg_test = deg_test_norm;\n    else\n        deg_test = deg_test_inv;\n\n    int middle_r_out = r_out;\n#if !LV_ANTIALIAS\n    thickness--;\n    middle_r_out = r_out - 1;\n#endif\n    if(deg_test(270, start_angle, end_angle))\n        hor_line(center_x - middle_r_out, center_y, mask, thickness, color, opa); /*Left Middle*/\n    if(deg_test(90, start_angle, end_angle))\n        hor_line(center_x + r_in, center_y, mask, thickness, color, opa); /*Right Middle*/\n    if(deg_test(180, start_angle, end_angle))\n        ver_line(center_x, center_y - middle_r_out, mask, thickness, color, opa); /*Top Middle*/\n    if(deg_test(0, start_angle, end_angle))\n        ver_line(center_x, center_y + r_in, mask, thickness, color, opa); /*Bottom middle*/\n\n    uint32_t r_out_sqr = r_out * r_out;\n    uint32_t r_in_sqr  = r_in * r_in;\n#if LV_ANTIALIAS\n    uint32_t r_out_aa_sqr = (r_out + 1) * (r_out + 1);\n    uint32_t r_in_aa_sqr  = (r_in - 1) * (r_in - 1);\n#endif\n    int16_t xi;\n    int16_t yi;\n    for(yi = -r_out; yi < 0; yi++) {\n        x_start[0] = LV_COORD_MIN;\n        x_start[1] = LV_COORD_MIN;\n        x_start[2] = LV_COORD_MIN;\n        x_start[3] = LV_COORD_MIN;\n        x_end[0]   = LV_COORD_MIN;\n        x_end[1]   = LV_COORD_MIN;\n        x_end[2]   = LV_COORD_MIN;\n        x_end[3]   = LV_COORD_MIN;\n        int xe     = 0;\n        for(xi = -r_out; xi < 0; xi++) {\n\n            uint32_t r_act_sqr = xi * xi + yi * yi;\n#if LV_ANTIALIAS\n            if(r_act_sqr > r_out_aa_sqr) {\n                continue;\n            }\n#else\n            if(r_act_sqr > r_out_sqr) continue;\n#endif\n\n            deg_base = fast_atan2(xi, yi) - 180;\n\n#if LV_ANTIALIAS\n            int opa = -1;\n            if(r_act_sqr > r_out_sqr) {\n                opa = LV_OPA_100 * (r_out + 1) - lv_sqrt(LV_OPA_100 * LV_OPA_100 * r_act_sqr);\n                if(opa < LV_OPA_0)\n                    opa = LV_OPA_0;\n                else if(opa > LV_OPA_100)\n                    opa = LV_OPA_100;\n            } else if(r_act_sqr < r_in_sqr) {\n                if(xe == 0) xe = xi;\n                opa = lv_sqrt(LV_OPA_100 * LV_OPA_100 * r_act_sqr) - LV_OPA_100 * (r_in - 1);\n                if(opa < LV_OPA_0)\n                    opa = LV_OPA_0;\n                else if(opa > LV_OPA_100)\n                    opa = LV_OPA_100;\n                if(r_act_sqr < r_in_aa_sqr)\n                    break; /*No need to continue the iteration in x once we found the inner edge of the\n                              arc*/\n            }\n            if(opa != -1) {\n                if(deg_test(180 + deg_base, start_angle, end_angle)) {\n                    lv_draw_px(center_x + xi, center_y + yi, mask, color, opa);\n                }\n                if(deg_test(360 - deg_base, start_angle, end_angle)) {\n                    lv_draw_px(center_x + xi, center_y - yi, mask, color, opa);\n                }\n                if(deg_test(180 - deg_base, start_angle, end_angle)) {\n                    lv_draw_px(center_x - xi, center_y + yi, mask, color, opa);\n                }\n                if(deg_test(deg_base, start_angle, end_angle)) {\n                    lv_draw_px(center_x - xi, center_y - yi, mask, color, opa);\n                }\n                continue;\n            }\n#endif\n\n            deg = 180 + deg_base;\n            if(deg_test(deg, start_angle, end_angle)) {\n                if(x_start[0] == LV_COORD_MIN) x_start[0] = xi;\n            } else if(x_start[0] != LV_COORD_MIN && x_end[0] == LV_COORD_MIN) {\n                x_end[0] = xi - 1;\n            }\n\n            deg = 360 - deg_base;\n            if(deg_test(deg, start_angle, end_angle)) {\n                if(x_start[1] == LV_COORD_MIN) x_start[1] = xi;\n            } else if(x_start[1] != LV_COORD_MIN && x_end[1] == LV_COORD_MIN) {\n                x_end[1] = xi - 1;\n            }\n\n            deg = 180 - deg_base;\n            if(deg_test(deg, start_angle, end_angle)) {\n                if(x_start[2] == LV_COORD_MIN) x_start[2] = xi;\n            } else if(x_start[2] != LV_COORD_MIN && x_end[2] == LV_COORD_MIN) {\n                x_end[2] = xi - 1;\n            }\n\n            deg = deg_base;\n            if(deg_test(deg, start_angle, end_angle)) {\n                if(x_start[3] == LV_COORD_MIN) x_start[3] = xi;\n            } else if(x_start[3] != LV_COORD_MIN && x_end[3] == LV_COORD_MIN) {\n                x_end[3] = xi - 1;\n            }\n\n            if(r_act_sqr < r_in_sqr) {\n                xe = xi;\n                break; /*No need to continue the iteration in x once we found the inner edge of the\n                          arc*/\n            }\n        }\n\n        if(x_start[0] != LV_COORD_MIN) {\n            if(x_end[0] == LV_COORD_MIN) x_end[0] = xe - 1;\n            hor_line(center_x + x_start[0], center_y + yi, mask, x_end[0] - x_start[0], color, opa);\n        }\n\n        if(x_start[1] != LV_COORD_MIN) {\n            if(x_end[1] == LV_COORD_MIN) x_end[1] = xe - 1;\n            hor_line(center_x + x_start[1], center_y - yi, mask, x_end[1] - x_start[1], color, opa);\n        }",
        "base_contents": "    bool (*deg_test)(uint16_t, uint16_t, uint16_t);\n    if(start_angle <= end_angle)\n        deg_test = deg_test_norm;\n    else\n        deg_test = deg_test_inv;\n\n    if(deg_test(270, start_angle, end_angle))\n        hor_line(center_x - r_out + 1, center_y, mask, thickness - 1, color, opa); /*Left Middle*/\n    if(deg_test(90, start_angle, end_angle))\n        hor_line(center_x + r_in, center_y, mask, thickness - 1, color, opa); /*Right Middle*/\n    if(deg_test(180, start_angle, end_angle))\n        ver_line(center_x, center_y - r_out + 1, mask, thickness - 1, color, opa); /*Top Middle*/\n    if(deg_test(0, start_angle, end_angle))\n        ver_line(center_x, center_y + r_in, mask, thickness - 1, color, opa); /*Bottom middle*/\n\n    uint32_t r_out_sqr = r_out * r_out;\n    uint32_t r_in_sqr  = r_in * r_in;\n    int16_t xi;\n    int16_t yi;\n    for(yi = -r_out; yi < 0; yi++) {\n        x_start[0] = LV_COORD_MIN;\n        x_start[1] = LV_COORD_MIN;\n        x_start[2] = LV_COORD_MIN;\n        x_start[3] = LV_COORD_MIN;\n        x_end[0]   = LV_COORD_MIN;\n        x_end[1]   = LV_COORD_MIN;\n        x_end[2]   = LV_COORD_MIN;\n        x_end[3]   = LV_COORD_MIN;\n        for(xi = -r_out; xi < 0; xi++) {\n\n            uint32_t r_act_sqr = xi * xi + yi * yi;\n            if(r_act_sqr > r_out_sqr) continue;\n\n            deg_base = fast_atan2(xi, yi) - 180;\n\n            deg = 180 + deg_base;\n            if(deg_test(deg, start_angle, end_angle)) {\n                if(x_start[0] == LV_COORD_MIN) x_start[0] = xi;\n            } else if(x_start[0] != LV_COORD_MIN && x_end[0] == LV_COORD_MIN) {\n                x_end[0] = xi - 1;\n            }\n\n            deg = 360 - deg_base;\n            if(deg_test(deg, start_angle, end_angle)) {\n                if(x_start[1] == LV_COORD_MIN) x_start[1] = xi;\n            } else if(x_start[1] != LV_COORD_MIN && x_end[1] == LV_COORD_MIN) {\n                x_end[1] = xi - 1;\n            }\n\n            deg = 180 - deg_base;\n            if(deg_test(deg, start_angle, end_angle)) {\n                if(x_start[2] == LV_COORD_MIN) x_start[2] = xi;\n            } else if(x_start[2] != LV_COORD_MIN && x_end[2] == LV_COORD_MIN) {\n                x_end[2] = xi - 1;\n            }\n\n            deg = deg_base;\n            if(deg_test(deg, start_angle, end_angle)) {\n                if(x_start[3] == LV_COORD_MIN) x_start[3] = xi;\n            } else if(x_start[3] != LV_COORD_MIN && x_end[3] == LV_COORD_MIN) {\n                x_end[3] = xi - 1;\n            }\n\n            if(r_act_sqr < r_in_sqr)\n                break; /*No need to continue the iteration in x once we found the inner edge of the\n                          arc*/\n        }\n\n        if(x_start[0] != LV_COORD_MIN) {\n            if(x_end[0] == LV_COORD_MIN) x_end[0] = xi - 1;\n            hor_line(center_x + x_start[0], center_y + yi, mask, x_end[0] - x_start[0], color, opa);\n        }\n\n        if(x_start[1] != LV_COORD_MIN) {\n            if(x_end[1] == LV_COORD_MIN) x_end[1] = xi - 1;\n            hor_line(center_x + x_start[1], center_y - yi, mask, x_end[1] - x_start[1], color, opa);\n        }",
        "res_region": "    lv_area_t area;\n    area.x1 = center_x - radius;\n    area.y1 = center_y - radius;\n    area.x2 = center_x + radius;\n    area.y2 = center_y + radius;\n\n    lv_draw_rect(&area, clip_area, &circle_style, LV_OPA_COVER);\n",
        "lookback": "    area.x1 = center_x - radius;",
        "lookahead": "    lv_draw_mask_remove_id(mask_angle_id);",
        "label": [
            "newcode",
            "complex_conflict"
        ],
        "start_line": 82,
        "end_line": 298,
        "merge_gen_region": null,
        "confidence": 0.6311135292053223,
        "hesitated": true
    },
    {
        "a_contents": "    lv_draw_rect(&area, clip_area, &circle_style, LV_OPA_COVER);",
        "b_contents": "        if(x_start[2] != LV_COORD_MIN) {\n            if(x_end[2] == LV_COORD_MIN) x_end[2] = xe - 1;\n            hor_line(center_x - x_end[2], center_y + yi, mask, LV_MATH_ABS(x_end[2] - x_start[2]), color, opa);\n        }",
        "base_contents": "        if(x_start[2] != LV_COORD_MIN) {\n            if(x_end[2] == LV_COORD_MIN) x_end[2] = xi - 1;\n            hor_line(center_x - x_end[2], center_y + yi, mask, LV_MATH_ABS(x_end[2] - x_start[2]), color, opa);\n        }",
        "res_region": "",
        "lookback": "",
        "lookahead": "    lv_draw_mask_remove_id(mask_angle_id);",
        "label": [
            "deletion",
            "complex_conflict"
        ],
        "start_line": 300,
        "end_line": 312,
        "merge_gen_region": null,
        "confidence": 0.8054591417312622,
        "hesitated": true
    },
    {
        "a_contents": "    lv_draw_mask_remove_id(mask_angle_id);\n\n    if(style->line.rounded) {\n        /*TODO*/",
        "b_contents": "        if(x_start[3] != LV_COORD_MIN) {\n            if(x_end[3] == LV_COORD_MIN) x_end[3] = xe - 1;\n            hor_line(center_x - x_end[3], center_y - yi, mask, LV_MATH_ABS(x_end[3] - x_start[3]), color, opa);\n        }\n    }\n}\n\nstatic uint16_t fast_atan2(int x, int y)\n{\n    // Fast XY vector to integer degree algorithm - Jan 2011 www.RomanBlack.com\n    // Converts any XY values including 0 to a degree value that should be\n    // within +/- 1 degree of the accurate value without needing\n    // large slow trig functions like ArcTan() or ArcCos().\n    // NOTE! at least one of the X or Y values must be non-zero!\n    // This is the full version, for all 4 quadrants and will generate\n    // the angle in integer degrees from 0-360.\n    // Any values of X and Y are usable including negative values provided\n    // they are between -1456 and 1456 so the 16bit multiply does not overflow.\n\n    unsigned char negflag;\n    unsigned char tempdegree;\n    unsigned char comp;\n    unsigned int degree; /*this will hold the result*/\n    unsigned int ux;\n    unsigned int uy;\n\n    /*Save the sign flags then remove signs and get XY as unsigned ints*/\n    negflag = 0;\n    if(x < 0) {\n        negflag += 0x01; /*x flag bit*/\n        x = (0 - x);     /*is now +*/",
        "base_contents": "        if(x_start[3] != LV_COORD_MIN) {\n            if(x_end[3] == LV_COORD_MIN) x_end[3] = xi - 1;\n            hor_line(center_x - x_end[3], center_y - yi, mask, LV_MATH_ABS(x_end[3] - x_start[3]), color, opa);\n        }\n\n#if LV_ANTIALIAS\n        /*TODO*/\n\n#endif\n    }\n}\n\nstatic uint16_t fast_atan2(int x, int y)\n{\n    // Fast XY vector to integer degree algorithm - Jan 2011 www.RomanBlack.com\n    // Converts any XY values including 0 to a degree value that should be\n    // within +/- 1 degree of the accurate value without needing\n    // large slow trig functions like ArcTan() or ArcCos().\n    // NOTE! at least one of the X or Y values must be non-zero!\n    // This is the full version, for all 4 quadrants and will generate\n    // the angle in integer degrees from 0-360.\n    // Any values of X and Y are usable including negative values provided\n    // they are between -1456 and 1456 so the 16bit multiply does not overflow.\n\n    unsigned char negflag;\n    unsigned char tempdegree;\n    unsigned char comp;\n    unsigned int degree; /*this will hold the result*/\n    unsigned int ux;\n    unsigned int uy;\n\n    /*Save the sign flags then remove signs and get XY as unsigned ints*/\n    negflag = 0;\n    if(x < 0) {\n        negflag += 0x01; /*x flag bit*/\n        x = (0 - x);     /*is now +*/",
        "res_region": "    lv_draw_mask_remove_id(mask_angle_id);\n\n    if(style->line.rounded) {\n        /*TODO*/",
        "lookback": "",
        "lookahead": "    }",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 314,
        "end_line": 388,
        "merge_gen_region": null,
        "confidence": 0.8279301524162292,
        "hesitated": true
    }
]