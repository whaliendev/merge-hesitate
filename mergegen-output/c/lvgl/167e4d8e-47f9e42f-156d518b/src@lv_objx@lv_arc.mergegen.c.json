[
    {
        "a_contents": "static lv_style_list_t * lv_arc_get_style(lv_obj_t * arc, uint8_t part);",
        "b_contents": "static void inv_arc_area(lv_obj_t * arc, uint16_t start_angle, uint16_t end_angle);",
        "base_contents": "",
        "res_region": "static lv_style_list_t * lv_arc_get_style(lv_obj_t * arc, uint8_t part);\nstatic void inv_arc_area(lv_obj_t * arc, uint16_t start_angle, uint16_t end_angle);",
        "lookback": "static void inv_arc_area(lv_obj_t * arc, uint16_t start_angle, uint16_t end_angle);",
        "lookahead": "",
        "label": [
            "interleave",
            "one_side_deletion"
        ],
        "start_line": 30,
        "end_line": 35,
        "merge_gen_region": null,
        "confidence": 0.8788933157920837,
        "hesitated": true
    },
    {
        "a_contents": "    ext->arc_angle_start = start;",
        "b_contents": "    /*Too large move, the whole arc need to be invalidated anyway*/\n    if(LV_MATH_ABS(start - ext->angle_start) >= 180) {\n        lv_obj_invalidate(arc);\n    }\n    /*Only a smaller incremental move*/\n    else if(ext->angle_start > ext->angle_end && start > ext->angle_end) {\n        inv_arc_area(arc, LV_MATH_MIN(ext->angle_start, start), LV_MATH_MAX(ext->angle_start, start));\n    }\n    /*Only a smaller incremental move*/\n    else  if(ext->angle_start < ext->angle_end && start < ext->angle_end) {\n        inv_arc_area(arc, LV_MATH_MIN(ext->angle_start, start), LV_MATH_MAX(ext->angle_start, start));\n    }\n    /*Crossing the start angle makes the whole arc change*/\n    else {\n        lv_obj_invalidate(arc);\n    }",
        "base_contents": "    ext->angle_start = start;",
        "res_region": "    /*Too large move, the whole arc need to be invalidated anyway*/\n    if(LV_MATH_ABS(start - ext->arc_angle_start) >= 180) {\n        lv_obj_invalidate(arc);\n    }\n    /*Only a smaller incremental move*/\n    else if(ext->arc_angle_start > ext->arc_angle_end && start > ext->arc_angle_end) {\n        inv_arc_area(arc, LV_MATH_MIN(ext->arc_angle_start, start), LV_MATH_MAX(ext->arc_angle_start, start));\n    }\n    /*Only a smaller incremental move*/\n    else  if(ext->arc_angle_start < ext->arc_angle_end && start < ext->arc_angle_end) {\n        inv_arc_area(arc, LV_MATH_MIN(ext->arc_angle_start, start), LV_MATH_MAX(ext->arc_angle_start, start));\n    }\n    /*Crossing the start angle makes the whole arc change*/\n    else {\n        lv_obj_invalidate(arc);\n    }",
        "lookback": "    if(LV_MATH_ABS(start - ext->arc_angle_start) >= 180) {",
        "lookahead": "",
        "label": [
            "newcode",
            "complex_conflict"
        ],
        "start_line": 136,
        "end_line": 157,
        "merge_gen_region": null,
        "confidence": 0.8516197800636292,
        "hesitated": true
    },
    {
        "a_contents": "    ext->arc_angle_end= end;",
        "b_contents": "    ext->angle_end= end;\n}\n\n\n/**\n * Set the start and end angles\n * @param arc pointer to an arc object\n * @param start the start angle\n * @param end the end angle\n */\nvoid lv_arc_set_angles(lv_obj_t * arc, uint16_t start, uint16_t end)\n{\n    LV_ASSERT_OBJ(arc, LV_OBJX_NAME);\n\n    lv_arc_ext_t * ext = lv_obj_get_ext_attr(arc);\n\n    if(end > 360) end -= 360;\n    if(start > 360) start -= 360;\n\n    inv_arc_area(arc, ext->angle_start, ext->angle_end);",
        "base_contents": "    ext->angle_end= end;",
        "res_region": "    ext->arc_angle_end= end;\n}\n\n\n/**\n * Set the start and end angles\n * @param arc pointer to an arc object\n * @param start the start angle\n * @param end the end angle\n */\nvoid lv_arc_set_angles(lv_obj_t * arc, uint16_t start, uint16_t end)\n{\n    LV_ASSERT_OBJ(arc, LV_OBJX_NAME);\n\n    lv_arc_ext_t * ext = lv_obj_get_ext_attr(arc);\n\n    if(end > 360) end -= 360;\n    if(start > 360) start -= 360;\n\n    inv_arc_area(arc, ext->arc_angle_start, ext->arc_angle_end);",
        "lookback": "}",
        "lookahead": "",
        "label": [
            "newcode",
            "complex_conflict"
        ],
        "start_line": 192,
        "end_line": 217,
        "merge_gen_region": null,
        "confidence": 0.8275795578956604,
        "hesitated": true
    },
    {
        "a_contents": "/**\n * Get the style descriptor of a part of the object\n * @param arc pointer the object\n * @param part the part of the object. (LV_ARC_PART_...)\n * @return pointer to the style descriptor of the specified part\n */\nstatic lv_style_list_t * lv_arc_get_style(lv_obj_t * arc, uint8_t part)\n{\n    LV_ASSERT_OBJ(arc, LV_OBJX_NAME);\n\n    lv_arc_ext_t * ext = lv_obj_get_ext_attr(arc);\n\n    lv_style_list_t * style_dsc_p;\n\n    switch(part) {\n    case LV_ARC_PART_BG:\n        style_dsc_p = &arc->style_list;\n        break;\n    case LV_ARC_PART_ARC:\n        style_dsc_p = &ext->style_arc;\n        break;\n    default:\n        style_dsc_p = NULL;\n    }\n\n    return style_dsc_p;\n}",
        "b_contents": "\nstatic void inv_arc_area(lv_obj_t * arc, uint16_t start_angle, uint16_t end_angle)\n{\n    uint8_t start_quarter = start_angle / 90;\n    uint8_t end_quarter = end_angle / 90;\n    lv_coord_t x       = arc->coords.x1 + lv_obj_get_width(arc) / 2;\n    lv_coord_t y       = arc->coords.y1 + lv_obj_get_height(arc) / 2;\n    lv_coord_t rout       = (LV_MATH_MIN(lv_obj_get_width(arc), lv_obj_get_height(arc))) / 2;\n    const lv_style_t * style = lv_arc_get_style(arc, LV_ARC_STYLE_MAIN);\n    lv_coord_t rin       = rout - style->line.width;\n\n    lv_area_t inv_area;\n\n    if(start_quarter == end_quarter && start_angle <= end_angle) {\n        if(start_quarter == 0) {\n            inv_area.y1 = y + ((lv_trigo_sin(start_angle) * rin) >> LV_TRIGO_SHIFT);\n            inv_area.x2 = x + ((lv_trigo_sin(start_angle + 90) * rout) >> LV_TRIGO_SHIFT);\n\n            inv_area.y2 = y + ((lv_trigo_sin(end_angle) * rout) >> LV_TRIGO_SHIFT);\n            inv_area.x1 = x + ((lv_trigo_sin(end_angle + 90) * rin) >> LV_TRIGO_SHIFT);\n\n            lv_obj_invalidate_area(arc, &inv_area);\n        }\n        else if(start_quarter == 1) {\n            inv_area.y2 = y + ((lv_trigo_sin(start_angle) * rout) >> LV_TRIGO_SHIFT);\n            inv_area.x2 = x + ((lv_trigo_sin(start_angle + 90) * rin) >> LV_TRIGO_SHIFT);\n\n            inv_area.y1 = y + ((lv_trigo_sin(end_angle) * rin) >> LV_TRIGO_SHIFT);\n            inv_area.x1 = x + ((lv_trigo_sin(end_angle + 90) * rout) >> LV_TRIGO_SHIFT);\n\n            lv_obj_invalidate_area(arc, &inv_area);\n        }\n        else if(start_quarter == 2) {\n            inv_area.x1 = x + ((lv_trigo_sin(start_angle + 90) * rout) >> LV_TRIGO_SHIFT);\n            inv_area.y2 = y + ((lv_trigo_sin(start_angle) * rin) >> LV_TRIGO_SHIFT);\n\n            inv_area.y1 = y + ((lv_trigo_sin(end_angle) * rout) >> LV_TRIGO_SHIFT);\n            inv_area.x2 = x + ((lv_trigo_sin(end_angle + 90) * rin) >> LV_TRIGO_SHIFT);\n\n            lv_obj_invalidate_area(arc, &inv_area);\n        }\n        else if(start_quarter == 3) {\n            /*Small arc here*/\n            inv_area.x1 = x + ((lv_trigo_sin(start_angle + 90) * rin) >> LV_TRIGO_SHIFT);\n            inv_area.y1 = y + ((lv_trigo_sin(start_angle) * rout) >> LV_TRIGO_SHIFT);\n\n            inv_area.x2 = x + ((lv_trigo_sin(end_angle + 90) * rout) >> LV_TRIGO_SHIFT);\n            inv_area.y2 = y + ((lv_trigo_sin(end_angle) * rin) >> LV_TRIGO_SHIFT);\n\n            lv_obj_invalidate_area(arc, &inv_area);\n        }\n\n    } else if(start_quarter == 0 && end_quarter == 1) {\n        inv_area.x1 = x + ((lv_trigo_sin(end_angle + 90) * rout) >> LV_TRIGO_SHIFT);\n        inv_area.y1 = y + ((LV_MATH_MIN(lv_trigo_sin(end_angle), lv_trigo_sin(start_angle))  * rin) >> LV_TRIGO_SHIFT);\n        inv_area.x2 = x + ((lv_trigo_sin(start_angle + 90) * rout) >> LV_TRIGO_SHIFT);\n        inv_area.y2 = y + rout;\n        lv_obj_invalidate_area(arc, &inv_area);\n    } else if(start_quarter == 1 && end_quarter == 2) {\n        inv_area.x1 = x - rout;\n        inv_area.y1 = y + ((lv_trigo_sin(end_angle) * rout) >> LV_TRIGO_SHIFT);\n        inv_area.x2 = x + ((LV_MATH_MAX(lv_trigo_sin(start_angle + 90) , lv_trigo_sin(end_angle + 90)) * rin) >> LV_TRIGO_SHIFT);\n        inv_area.y2 = y + ((lv_trigo_sin(start_angle) * rout) >> LV_TRIGO_SHIFT);\n        lv_obj_invalidate_area(arc, &inv_area);\n    }  else if(start_quarter == 2 && end_quarter == 3) {\n        inv_area.x1 = x + ((lv_trigo_sin(start_angle + 90) * rout) >> LV_TRIGO_SHIFT);\n        inv_area.y1 = y - rout;\n        inv_area.x2 = x + ((lv_trigo_sin(end_angle + 90) * rout) >> LV_TRIGO_SHIFT);\n        inv_area.y2 = y + (LV_MATH_MAX(lv_trigo_sin(end_angle) * rin, lv_trigo_sin(start_angle) * rin) >> LV_TRIGO_SHIFT);\n        lv_obj_invalidate_area(arc, &inv_area);\n    } else if(start_quarter == 3 && end_quarter == 0) {\n        inv_area.x1 = x + ((LV_MATH_MIN(lv_trigo_sin(end_angle + 90), lv_trigo_sin(start_angle + 90)) * rin) >> LV_TRIGO_SHIFT);\n        inv_area.y1 = y + ((lv_trigo_sin(start_angle) * rout) >> LV_TRIGO_SHIFT);\n        inv_area.x2 = x + rout;\n        inv_area.y2 = y + ((lv_trigo_sin(end_angle) * rout) >> LV_TRIGO_SHIFT);\n\n        lv_obj_invalidate_area(arc, &inv_area);\n    } else {\n        lv_obj_invalidate(arc);\n    }\n}",
        "base_contents": "",
        "res_region": "/**\n * Get the style descriptor of a part of the object\n * @param arc pointer the object\n * @param part the part of the object. (LV_ARC_PART_...)\n * @return pointer to the style descriptor of the specified part\n */\nstatic lv_style_list_t * lv_arc_get_style(lv_obj_t * arc, uint8_t part)\n{\n    LV_ASSERT_OBJ(arc, LV_OBJX_NAME);\n\n    lv_arc_ext_t * ext = lv_obj_get_ext_attr(arc);\n\n    lv_style_list_t * style_dsc_p;\n\n    switch(part) {\n    case LV_ARC_PART_BG:\n        style_dsc_p = &arc->style_list;\n        break;\n    case LV_ARC_PART_ARC:\n        style_dsc_p = &ext->style_arc;\n        break;\n    default:\n        style_dsc_p = NULL;\n    }\n\n    return style_dsc_p;\n}\n\nstatic void inv_arc_area(lv_obj_t * arc, uint16_t start_angle, uint16_t end_angle)\n{\n    uint8_t start_quarter = start_angle / 90;\n    uint8_t end_quarter = end_angle / 90;\n    lv_coord_t x       = arc->coords.x1 + lv_obj_get_width(arc) / 2;\n    lv_coord_t y       = arc->coords.y1 + lv_obj_get_height(arc) / 2;\n    lv_coord_t rout       = (LV_MATH_MIN(lv_obj_get_width(arc), lv_obj_get_height(arc))) / 2;\n    lv_style_int_t w = lv_obj_get_style_line_width(arc, LV_ARC_PART_ARC);\n    lv_coord_t rin       = rout - w;\n\n    lv_area_t inv_area;\n\n    if(start_quarter == end_quarter && start_angle <= end_angle) {\n        if(start_quarter == 0) {\n            inv_area.y1 = y + ((lv_trigo_sin(start_angle) * rin) >> LV_TRIGO_SHIFT);\n            inv_area.x2 = x + ((lv_trigo_sin(start_angle + 90) * rout) >> LV_TRIGO_SHIFT);\n\n            inv_area.y2 = y + ((lv_trigo_sin(end_angle) * rout) >> LV_TRIGO_SHIFT);\n            inv_area.x1 = x + ((lv_trigo_sin(end_angle + 90) * rin) >> LV_TRIGO_SHIFT);\n\n            lv_obj_invalidate_area(arc, &inv_area);\n        }\n        else if(start_quarter == 1) {\n            inv_area.y2 = y + ((lv_trigo_sin(start_angle) * rout) >> LV_TRIGO_SHIFT);\n            inv_area.x2 = x + ((lv_trigo_sin(start_angle + 90) * rin) >> LV_TRIGO_SHIFT);\n\n            inv_area.y1 = y + ((lv_trigo_sin(end_angle) * rin) >> LV_TRIGO_SHIFT);\n            inv_area.x1 = x + ((lv_trigo_sin(end_angle + 90) * rout) >> LV_TRIGO_SHIFT);\n\n            lv_obj_invalidate_area(arc, &inv_area);\n        }\n        else if(start_quarter == 2) {\n            inv_area.x1 = x + ((lv_trigo_sin(start_angle + 90) * rout) >> LV_TRIGO_SHIFT);\n            inv_area.y2 = y + ((lv_trigo_sin(start_angle) * rin) >> LV_TRIGO_SHIFT);\n\n            inv_area.y1 = y + ((lv_trigo_sin(end_angle) * rout) >> LV_TRIGO_SHIFT);\n            inv_area.x2 = x + ((lv_trigo_sin(end_angle + 90) * rin) >> LV_TRIGO_SHIFT);\n\n            lv_obj_invalidate_area(arc, &inv_area);\n        }\n        else if(start_quarter == 3) {\n            /*Small arc here*/\n            inv_area.x1 = x + ((lv_trigo_sin(start_angle + 90) * rin) >> LV_TRIGO_SHIFT);\n            inv_area.y1 = y + ((lv_trigo_sin(start_angle) * rout) >> LV_TRIGO_SHIFT);\n\n            inv_area.x2 = x + ((lv_trigo_sin(end_angle + 90) * rout) >> LV_TRIGO_SHIFT);\n            inv_area.y2 = y + ((lv_trigo_sin(end_angle) * rin) >> LV_TRIGO_SHIFT);\n\n            lv_obj_invalidate_area(arc, &inv_area);\n        }\n\n    } else if(start_quarter == 0 && end_quarter == 1) {\n        inv_area.x1 = x + ((lv_trigo_sin(end_angle + 90) * rout) >> LV_TRIGO_SHIFT);\n        inv_area.y1 = y + ((LV_MATH_MIN(lv_trigo_sin(end_angle), lv_trigo_sin(start_angle))  * rin) >> LV_TRIGO_SHIFT);\n        inv_area.x2 = x + ((lv_trigo_sin(start_angle + 90) * rout) >> LV_TRIGO_SHIFT);\n        inv_area.y2 = y + rout;\n        lv_obj_invalidate_area(arc, &inv_area);\n    } else if(start_quarter == 1 && end_quarter == 2) {\n        inv_area.x1 = x - rout;\n        inv_area.y1 = y + ((lv_trigo_sin(end_angle) * rout) >> LV_TRIGO_SHIFT);\n        inv_area.x2 = x + ((LV_MATH_MAX(lv_trigo_sin(start_angle + 90) , lv_trigo_sin(end_angle + 90)) * rin) >> LV_TRIGO_SHIFT);\n        inv_area.y2 = y + ((lv_trigo_sin(start_angle) * rout) >> LV_TRIGO_SHIFT);\n        lv_obj_invalidate_area(arc, &inv_area);\n    }  else if(start_quarter == 2 && end_quarter == 3) {\n        inv_area.x1 = x + ((lv_trigo_sin(start_angle + 90) * rout) >> LV_TRIGO_SHIFT);\n        inv_area.y1 = y - rout;\n        inv_area.x2 = x + ((lv_trigo_sin(end_angle + 90) * rout) >> LV_TRIGO_SHIFT);\n        inv_area.y2 = y + (LV_MATH_MAX(lv_trigo_sin(end_angle) * rin, lv_trigo_sin(start_angle) * rin) >> LV_TRIGO_SHIFT);\n        lv_obj_invalidate_area(arc, &inv_area);\n    } else if(start_quarter == 3 && end_quarter == 0) {\n        inv_area.x1 = x + ((LV_MATH_MIN(lv_trigo_sin(end_angle + 90), lv_trigo_sin(start_angle + 90)) * rin) >> LV_TRIGO_SHIFT);\n        inv_area.y1 = y + ((lv_trigo_sin(start_angle) * rout) >> LV_TRIGO_SHIFT);\n        inv_area.x2 = x + rout;\n        inv_area.y2 = y + ((lv_trigo_sin(end_angle) * rout) >> LV_TRIGO_SHIFT);\n\n        lv_obj_invalidate_area(arc, &inv_area);\n    } else {\n        lv_obj_invalidate(arc);\n    }\n}",
        "lookback": " * Get the style descriptor of a part of the object",
        "lookahead": "#endif",
        "label": [
            "newcode",
            "one_side_deletion"
        ],
        "start_line": 341,
        "end_line": 452,
        "merge_gen_region": " Get style of part the/** Get style of a of part the *param pointer object @param the the of.LVARCPART...) @ pointer the descriptor the part static____ *____(__(__ *,8t) LVASSERTOBJarc LVOBJ_XNAME lvarcextt ext lvobjgetextattrarc lvobjgetextattrarc lvstylelistt styledscp switchpart { LVARCPARTBG styledscp &->_list break case___:_p &->_;; default styledscp NULL } styledscp } void___(___ *_(___ *,16t_ startangle uint_ startqu =_ /;8t__arter endqu =_ /;___ x arccoordsx +____() 2 lvcoordt =____(,_______;;___ =extstylearc LVARCSTYLEMAIN lvcoordtn rout stylelinewidth lvareat__ invarea ifstartqu ==_arter startangle uint__ <= endangle {(__) ifstartqu ==) invareay = +lvtrig",
        "confidence": 0.9208409786224365,
        "hesitated": false,
        "resolved": false
    }
]