[
    {
        "a_contents": "/**\n * Set the x coordinate of a object\n * @param obj pointer to an object\n * @param x new distance from the left side from the parent\n */\nvoid lv_obj_set_x(lv_obj_t * obj, lv_coord_t x)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_obj_set_pos(obj, x, lv_obj_get_y(obj));\n}\n\n/**\n * Set the y coordinate of a object\n * @param obj pointer to an object\n * @param y new distance from the top of the parent\n */\nvoid lv_obj_set_y(lv_obj_t * obj, lv_coord_t y)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_obj_set_pos(obj, lv_obj_get_x(obj), y);\n}\n\n/**\n * Set the size of an object\n * @param obj pointer to an object\n * @param w new width\n * @param h new height\n */\nvoid lv_obj_set_size(lv_obj_t * obj, lv_coord_t w, lv_coord_t h)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    /* Do nothing if the size is not changed */\n    /* It is very important else recursive resizing can\n     * occur without size change*/\n    if(lv_obj_get_width(obj) == w && lv_obj_get_height(obj) == h) {\n        return;\n    }\n\n    /*Invalidate the original area*/\n    lv_obj_invalidate(obj);\n\n    /*Save the original coordinates*/\n    lv_area_t ori;\n    lv_obj_get_coords(obj, &ori);\n\n    /*Set the length and height*/\n    obj->coords.y2 = obj->coords.y1 + h - 1;\n    if(lv_obj_get_base_dir(obj) == LV_BIDI_DIR_RTL) {\n        obj->coords.x1 = obj->coords.x2 - w + 1;\n    }\n    else {\n        obj->coords.x2 = obj->coords.x1 + w - 1;\n    }\n\n    /*Send a signal to the object with its new coordinates*/\n    obj->signal_cb(obj, LV_SIGNAL_COORD_CHG, &ori);\n\n    /*Send a signal to the parent too*/\n    lv_obj_t * par = lv_obj_get_parent(obj);\n    if(par != NULL) par->signal_cb(par, LV_SIGNAL_CHILD_CHG, obj);\n\n    /*Tell the children the parent's size has changed*/\n    lv_obj_t * i;\n    _LV_LL_READ(obj->child_ll, i) {\n        i->signal_cb(i, LV_SIGNAL_PARENT_SIZE_CHG,  &ori);\n    }\n\n    /*Invalidate the new area*/\n    lv_obj_invalidate(obj);\n\n    /*Automatically realign the object if required*/\n#if LV_USE_OBJ_REALIGN\n    if(obj->realign.auto_realign) lv_obj_realign(obj);\n#endif\n}\n\n/**\n * Set the width of an object\n * @param obj pointer to an object\n * @param w new width\n */\nvoid lv_obj_set_width(lv_obj_t * obj, lv_coord_t w)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_obj_set_size(obj, w, lv_obj_get_height(obj));\n}\n\n/**\n * Set the height of an object\n * @param obj pointer to an object\n * @param h new height\n */\nvoid lv_obj_set_height(lv_obj_t * obj, lv_coord_t h)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_obj_set_size(obj, lv_obj_get_width(obj), h);\n}\n\n/**\n * Set the width reduced by the left and right padding.\n * @param obj pointer to an object\n * @param w the width without paddings\n */\nvoid lv_obj_set_width_fit(lv_obj_t * obj, lv_coord_t w)\n{\n    lv_style_int_t pleft = lv_obj_get_style_pad_left(obj, LV_OBJ_PART_MAIN);\n    lv_style_int_t pright = lv_obj_get_style_pad_right(obj, LV_OBJ_PART_MAIN);\n\n    lv_obj_set_width(obj, w - pleft - pright);\n}\n\n/**\n * Set the height reduced by the top and bottom padding.\n * @param obj pointer to an object\n * @param h the height without paddings\n */\nvoid lv_obj_set_height_fit(lv_obj_t * obj, lv_coord_t h)\n{\n    lv_style_int_t ptop = lv_obj_get_style_pad_top(obj, LV_OBJ_PART_MAIN);\n    lv_style_int_t pbottom = lv_obj_get_style_pad_bottom(obj, LV_OBJ_PART_MAIN);\n\n    lv_obj_set_height(obj, h - ptop - pbottom);\n}\n\n/**\n * Set the width of an object by taking the left and right margin into account.\n * The object width will be `obj_w = w - margin_left - margin_right`\n * @param obj pointer to an object\n * @param w new height including margins\n */\nvoid lv_obj_set_width_margin(lv_obj_t * obj, lv_coord_t w)\n{\n    lv_style_int_t mleft = lv_obj_get_style_margin_left(obj, LV_OBJ_PART_MAIN);\n    lv_style_int_t mright = lv_obj_get_style_margin_right(obj, LV_OBJ_PART_MAIN);\n\n    lv_obj_set_width(obj, w - mleft - mright);\n}\n\n/**\n * Set the height of an object by taking the top and bottom margin into account.\n * The object height will be `obj_h = h - margin_top - margin_bottom`\n * @param obj pointer to an object\n * @param h new height including margins\n */\nvoid lv_obj_set_height_margin(lv_obj_t * obj, lv_coord_t h)\n{\n    lv_style_int_t mtop = lv_obj_get_style_margin_top(obj, LV_OBJ_PART_MAIN);\n    lv_style_int_t mbottom = lv_obj_get_style_margin_bottom(obj, LV_OBJ_PART_MAIN);\n\n    lv_obj_set_height(obj, h - mtop - mbottom);\n}\n\n/**\n * Align an object to an other object.\n * @param obj pointer to an object to align\n * @param base pointer to an object (if NULL the parent is used). 'obj' will be aligned to it.\n * @param align type of alignment (see 'lv_align_t' enum)\n * @param x_ofs x coordinate offset after alignment\n * @param y_ofs y coordinate offset after alignment\n */\nvoid lv_obj_align(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t x_ofs, lv_coord_t y_ofs)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    if(base == NULL) base = lv_obj_get_parent(obj);\n\n    LV_ASSERT_OBJ(base, LV_OBJX_NAME);\n\n    obj_align_core(obj, base, align, true, true, x_ofs, y_ofs);\n\n#if LV_USE_OBJ_REALIGN\n    /*Save the last align parameters to use them in `lv_obj_realign`*/\n    obj->realign.align       = align;\n    obj->realign.xofs        = x_ofs;\n    obj->realign.yofs        = y_ofs;\n    obj->realign.base        = base;\n    obj->realign.mid_align = 0;\n#endif\n}\n\n/**\n * Align an object to an other object horizontally.\n * @param obj pointer to an object to align\n * @param base pointer to an object (if NULL the parent is used). 'obj' will be aligned to it.\n * @param align type of alignment (see 'lv_align_t' enum)\n * @param x_ofs x coordinate offset after alignment\n */\nvoid lv_obj_align_x(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t x_ofs)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    if(base == NULL) base = lv_obj_get_parent(obj);\n\n    LV_ASSERT_OBJ(base, LV_OBJX_NAME);\n\n    obj_align_core(obj, base, align, true, false, x_ofs, 0);\n}\n\n/**\n * Align an object to an other object vertically.\n * @param obj pointer to an object to align\n * @param base pointer to an object (if NULL the parent is used). 'obj' will be aligned to it.\n * @param align type of alignment (see 'lv_align_t' enum)\n * @param y_ofs y coordinate offset after alignment\n */\nvoid lv_obj_align_y(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t y_ofs)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    if(base == NULL) base = lv_obj_get_parent(obj);\n\n    LV_ASSERT_OBJ(base, LV_OBJX_NAME);\n\n    obj_align_core(obj, base, align, false, true, 0, y_ofs);\n}\n\n/**\n * Align an object's middle point to an other object.\n * @param obj pointer to an object to align\n * @param base pointer to an object (if NULL the parent is used). 'obj' will be aligned to it.\n * @param align type of alignment (see 'lv_align_t' enum)\n * @param x_ofs x coordinate offset after alignment\n * @param y_ofs y coordinate offset after alignment\n */\nvoid lv_obj_align_mid(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t x_ofs, lv_coord_t y_ofs)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    if(base == NULL) {\n        base = lv_obj_get_parent(obj);\n    }\n\n    LV_ASSERT_OBJ(base, LV_OBJX_NAME);\n\n    obj_align_mid_core(obj, base, align, true, true, x_ofs, y_ofs);\n\n#if LV_USE_OBJ_REALIGN\n    /*Save the last align parameters to use them in `lv_obj_realign`*/\n    obj->realign.align       = align;\n    obj->realign.xofs        = x_ofs;\n    obj->realign.yofs        = y_ofs;\n    obj->realign.base        = base;\n    obj->realign.mid_align = 1;\n#endif\n}\n\n/**\n * Align an object's middle point to an other object horizontally.\n * @param obj pointer to an object to align\n * @param base pointer to an object (if NULL the parent is used). 'obj' will be aligned to it.\n * @param align type of alignment (see 'lv_align_t' enum)\n * @param x_ofs x coordinate offset after alignment\n */\nvoid lv_obj_align_mid_x(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t x_ofs)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    if(base == NULL) {\n        base = lv_obj_get_parent(obj);\n    }\n\n    LV_ASSERT_OBJ(base, LV_OBJX_NAME);\n\n    obj_align_mid_core(obj, base, align, true, false, x_ofs, 0);\n}\n\n/**\n * Align an object's middle point to an other object vertically.\n * @param obj pointer to an object to align\n * @param base pointer to an object (if NULL the parent is used). 'obj' will be aligned to it.\n * @param align type of alignment (see 'lv_align_t' enum)\n * @param y_ofs y coordinate offset after alignment\n */\nvoid lv_obj_align_mid_y(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t y_ofs)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    if(base == NULL) {\n        base = lv_obj_get_parent(obj);\n    }\n\n    LV_ASSERT_OBJ(base, LV_OBJX_NAME);\n\n    obj_align_mid_core(obj, base, align, false, true, 0, y_ofs);\n}\n\n/**\n * Realign the object based on the last `lv_obj_align` parameters.\n * @param obj pointer to an object\n */\nvoid lv_obj_realign(lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_OBJ_REALIGN\n    if(obj->realign.mid_align)\n        lv_obj_align_mid(obj, obj->realign.base, obj->realign.align, obj->realign.xofs, obj->realign.yofs);\n    else\n        lv_obj_align(obj, obj->realign.base, obj->realign.align, obj->realign.xofs, obj->realign.yofs);\n#else\n    (void)obj;\n    LV_LOG_WARN(\"lv_obj_realign: no effect because LV_USE_OBJ_REALIGN = 0\");\n#endif\n}\n\n/**\n * Enable the automatic realign of the object when its size has changed based on the last\n * `lv_obj_align` parameters.\n * @param obj pointer to an object\n * @param en true: enable auto realign; false: disable auto realign\n */\nvoid lv_obj_set_auto_realign(lv_obj_t * obj, bool en)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_OBJ_REALIGN\n    obj->realign.auto_realign = en ? 1 : 0;\n#else\n    (void)obj;\n    (void)en;\n    LV_LOG_WARN(\"lv_obj_set_auto_realign: no effect because LV_USE_OBJ_REALIGN = 0\");\n#endif\n}\n\n/**\n * Set the size of an extended clickable area\n * If TINY mode is used, only the largest of the horizontal and vertical padding\n * values are considered.\n * @param obj pointer to an object\n * @param left extended clickable are on the left [px]\n * @param right extended clickable are on the right [px]\n * @param top extended clickable are on the top [px]\n * @param bottom extended clickable are on the bottom [px]\n */\nvoid lv_obj_set_ext_click_area(lv_obj_t * obj, lv_coord_t left, lv_coord_t right, lv_coord_t top, lv_coord_t bottom)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_FULL\n    obj->ext_click_pad.x1 = left;\n    obj->ext_click_pad.x2 = right;\n    obj->ext_click_pad.y1 = top;\n    obj->ext_click_pad.y2 = bottom;\n#elif LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_TINY\n    obj->ext_click_pad_hor = LV_MATH_MAX(left, right);\n    obj->ext_click_pad_ver = LV_MATH_MAX(top, bottom);\n#else\n    (void)obj;    /*Unused*/\n    (void)left;   /*Unused*/\n    (void)right;  /*Unused*/\n    (void)top;    /*Unused*/\n    (void)bottom; /*Unused*/\n#endif\n}\n\n/*---------------------\n * Appearance set\n *--------------------*/\n\n/**\n * Add a new style to the style list of an object.\n * @param obj pointer to an object\n * @param part the part of the object which style property should be set.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param style pointer to a style to add (Only its pointer will be saved)\n */\nvoid lv_obj_add_style(lv_obj_t * obj, uint8_t part, lv_style_t * style)\n{\n    if(style == NULL) return;\n\n    lv_style_list_t * style_dsc = lv_obj_get_style_list(obj, part);\n    if(style_dsc == NULL) {\n        LV_LOG_WARN(\"Can't find style with part: %d\", part);\n        return;\n    }\n\n    _lv_style_list_add_style(style_dsc, style);\n#if LV_USE_ANIMATION\n    trans_del(obj, part, 0xFF, NULL);\n#endif\n    lv_obj_refresh_style(obj, part, LV_STYLE_PROP_ALL);\n}\n\n/**\n * Remove a style from the style list of an object.\n * @param obj pointer to an object\n * @param part the part of the object which style property should be set.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param style pointer to a style to remove\n */\nvoid lv_obj_remove_style(lv_obj_t * obj, uint8_t part, lv_style_t * style)\n{\n    if(style == NULL) return;\n\n    lv_style_list_t * style_dsc = lv_obj_get_style_list(obj, part);\n    if(style_dsc == NULL) {\n        LV_LOG_WARN(\"Can't find style with part: %d\", part);\n        return;\n    }\n\n    _lv_style_list_remove_style(style_dsc, style);\n#if LV_USE_ANIMATION\n    trans_del(obj, part, 0xFF, NULL);\n#endif\n    lv_obj_refresh_style(obj, part, LV_STYLE_PROP_ALL);\n}\n\n/**\n * Reset a style to the default (empty) state.\n * Release all used memories and cancel pending related transitions.\n * Typically used in `LV_SIGN_CLEAN_UP.\n * @param obj pointer to an object\n * @param part the part of the object which style list should be reset.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n */\nvoid lv_obj_clean_style_list(lv_obj_t * obj, uint8_t part)\n{\n    lv_style_list_t * style_dsc = lv_obj_get_style_list(obj, part);\n    if(style_dsc == NULL) {\n        LV_LOG_WARN(\"lv_obj_clean_style_list: can't find style with `part`\");\n        return;\n    }\n\n    _lv_style_list_reset(style_dsc);\n#if LV_USE_ANIMATION\n    trans_del(obj, part, 0xFF, NULL);\n#endif\n}\n\n/**\n * Reset a style to the default (empty) state.\n * Release all used memories and cancel pending related transitions.\n * Also notifies the object about the style change.\n * @param obj pointer to an object\n * @param part the part of the object which style list should be reset.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n */\nvoid lv_obj_reset_style_list(lv_obj_t * obj, uint8_t part)\n{\n    lv_obj_clean_style_list(obj, part);\n\n    lv_obj_refresh_style(obj, part, LV_STYLE_PROP_ALL);\n}\n\n/**\n * Set a local style property of a part of an object in a given state.\n * @param obj pointer to an object\n * @param part the part of the object which style property should be set.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_BORDER_WIDTH | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @param the value to set\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_opa()`\n * @note for performance reasons it's not checked if the property really has integer type\n */\nvoid _lv_obj_set_style_local_int(lv_obj_t * obj, uint8_t part, lv_style_property_t prop, lv_style_int_t value)\n{\n    lv_style_list_t * style_dsc = lv_obj_get_style_list(obj, part);\n    _lv_style_list_set_local_int(style_dsc, prop, value);\n#if LV_USE_ANIMATION\n    trans_del(obj, part, prop, NULL);\n#endif\n    lv_obj_refresh_style(obj, part, prop & (~LV_STYLE_STATE_MASK));\n}\n\n/**\n * Set a local style property of a part of an object in a given state.\n * @param obj pointer to an object\n * @param part the part of the object which style property should be set.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_BORDER_COLOR | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @param the value to set\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_opa()`\n * @note for performance reasons it's not checked if the property really has color type\n */\nvoid _lv_obj_set_style_local_color(lv_obj_t * obj, uint8_t part, lv_style_property_t prop, lv_color_t color)\n{\n    lv_style_list_t * style_dsc = lv_obj_get_style_list(obj, part);\n    _lv_style_list_set_local_color(style_dsc, prop, color);\n#if LV_USE_ANIMATION\n    trans_del(obj, part, prop, NULL);\n#endif\n    lv_obj_refresh_style(obj, part, prop & (~LV_STYLE_STATE_MASK));\n}\n\n/**\n * Set a local style property of a part of an object in a given state.\n * @param obj pointer to an object\n * @param part the part of the object which style property should be set.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_BORDER_OPA | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @param the value to set\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_opa()`\n * @note for performance reasons it's not checked if the property really has opacity type\n */\nvoid _lv_obj_set_style_local_opa(lv_obj_t * obj, uint8_t part, lv_style_property_t prop, lv_opa_t opa)\n{\n    lv_style_list_t * style_dsc = lv_obj_get_style_list(obj, part);\n    _lv_style_list_set_local_opa(style_dsc, prop, opa);\n#if LV_USE_ANIMATION\n    trans_del(obj, part, prop, NULL);\n#endif\n    lv_obj_refresh_style(obj, part, prop & (~LV_STYLE_STATE_MASK));\n}\n\n/**\n * Set a local style property of a part of an object in a given state.\n * @param obj pointer to an object\n * @param part the part of the object which style property should be set.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_TEXT_FONT | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @param value the value to set\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_opa()`\n * @note for performance reasons it's not checked if the property really has pointer type\n */\nvoid _lv_obj_set_style_local_ptr(lv_obj_t * obj, uint8_t part, lv_style_property_t prop, const void * value)\n{\n    lv_style_list_t * style_dsc = lv_obj_get_style_list(obj, part);\n    _lv_style_list_set_local_ptr(style_dsc, prop, value);\n#if LV_USE_ANIMATION\n    trans_del(obj, part, prop, NULL);\n#endif\n    lv_obj_refresh_style(obj, part, prop & (~LV_STYLE_STATE_MASK));\n}\n\n/**\n * Remove a local style property from a part of an object with a given state.\n * @param obj pointer to an object\n * @param part the part of the object which style property should be removed.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_TEXT_FONT | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @note shouldn't be used directly. Use the specific property remove functions instead.\n *       For example: `lv_obj_style_remove_border_opa()`\n * @return true: the property was found and removed; false: the property was not found\n */\nbool lv_obj_remove_style_local_prop(lv_obj_t * obj, uint8_t part, lv_style_property_t prop)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n    lv_style_t * style = lv_obj_get_local_style(obj, part);\n    if(style) return lv_style_remove_prop(style, prop);\n    else return false;\n}\n\n/**\n * Notify an object (and its children) about its style is modified\n * @param obj pointer to an object\n * @param part the part of the object which style property should be refreshed.\n * @param prop `LV_STYLE_PROP_ALL` or an `LV_STYLE_...` property. It is used to optimize what needs to be refreshed.\n */\nvoid lv_obj_refresh_style(lv_obj_t * obj, uint8_t part, lv_style_property_t prop)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    invalidate_style_cache(obj, part, prop);\n\n    /*If a real style refresh is required*/\n    bool real_refr = false;\n    switch(prop) {\n        case LV_STYLE_PROP_ALL:\n        case LV_STYLE_CLIP_CORNER:\n        case LV_STYLE_SIZE:\n        case LV_STYLE_TRANSFORM_WIDTH:\n        case LV_STYLE_TRANSFORM_HEIGHT:\n        case LV_STYLE_TRANSFORM_ANGLE:\n        case LV_STYLE_TRANSFORM_ZOOM:\n        case LV_STYLE_PAD_TOP:\n        case LV_STYLE_PAD_BOTTOM:\n        case LV_STYLE_PAD_LEFT:\n        case LV_STYLE_PAD_RIGHT:\n        case LV_STYLE_PAD_INNER:\n        case LV_STYLE_MARGIN_TOP:\n        case LV_STYLE_MARGIN_BOTTOM:\n        case LV_STYLE_MARGIN_LEFT:\n        case LV_STYLE_MARGIN_RIGHT:\n        case LV_STYLE_OUTLINE_WIDTH:\n        case LV_STYLE_OUTLINE_PAD:\n        case LV_STYLE_OUTLINE_OPA:\n        case LV_STYLE_SHADOW_WIDTH:\n        case LV_STYLE_SHADOW_OPA:\n        case LV_STYLE_SHADOW_OFS_X:\n        case LV_STYLE_SHADOW_OFS_Y:\n        case LV_STYLE_SHADOW_SPREAD:\n        case LV_STYLE_VALUE_LETTER_SPACE:\n        case LV_STYLE_VALUE_LINE_SPACE:\n        case LV_STYLE_VALUE_OFS_X:\n        case LV_STYLE_VALUE_OFS_Y:\n        case LV_STYLE_VALUE_ALIGN:\n        case LV_STYLE_VALUE_STR:\n        case LV_STYLE_VALUE_FONT:\n        case LV_STYLE_VALUE_OPA:\n        case LV_STYLE_TEXT_LETTER_SPACE:\n        case LV_STYLE_TEXT_LINE_SPACE:\n        case LV_STYLE_TEXT_FONT:\n        case LV_STYLE_LINE_WIDTH:\n            real_refr = true;\n            break;\n        default:\n            real_refr = false;\n    }\n\n    if(real_refr) {\n        lv_obj_invalidate(obj);\n        obj->signal_cb(obj, LV_SIGNAL_STYLE_CHG, NULL);\n\n        switch(prop) {\n            case LV_STYLE_PROP_ALL:\n            case LV_STYLE_MARGIN_TOP:\n            case LV_STYLE_MARGIN_BOTTOM:\n            case LV_STYLE_MARGIN_LEFT:\n            case LV_STYLE_MARGIN_RIGHT:\n                if(obj->parent) obj->parent->signal_cb(obj->parent, LV_SIGNAL_CHILD_CHG, NULL);\n                break;\n        }\n\n        lv_obj_invalidate(obj);\n\n        /*Send style change signals*/\n        if(prop == LV_STYLE_PROP_ALL || (prop & LV_STYLE_INHERIT_MASK)) refresh_children_style(obj);\n    }\n    else {\n        lv_obj_invalidate(obj);\n    }\n}\n\n/**\n * Notify all object if a style is modified\n * @param style pointer to a style. Only the objects with this style will be notified\n *               (NULL to notify all objects)\n */\nvoid lv_obj_report_style_mod(lv_style_t * style)\n{\n    lv_disp_t * d = lv_disp_get_next(NULL);\n\n    while(d) {\n        lv_obj_t * i;\n        _LV_LL_READ(d->scr_ll, i) {\n            report_style_mod_core(style, i);\n        }\n        d = lv_disp_get_next(d);\n    }\n}\n\n/**\n * Enable/disable the use of style cache for an object\n * @param obj pointer to an object\n * @param dis true: disable; false: enable (re-enable)\n */\nvoid _lv_obj_disable_style_caching(lv_obj_t * obj, bool dis)\n{\n    uint8_t part;\n    for(part = 0; part < _LV_OBJ_PART_REAL_FIRST; part++) {\n        lv_style_list_t * list = lv_obj_get_style_list(obj, part);\n        if(list == NULL) break;\n        list->ignore_cache = dis;\n    }\n    for(part = _LV_OBJ_PART_REAL_FIRST; part < 0xFF; part++) {\n        lv_style_list_t * list = lv_obj_get_style_list(obj, part);\n        if(list == NULL) break;\n        list->ignore_cache = dis;\n    }\n}\n\n/*-----------------\n * Attribute set\n *----------------*/\n\n/**\n * Hide an object. It won't be visible and clickable.\n * @param obj pointer to an object\n * @param en true: hide the object\n */\nvoid lv_obj_set_hidden(lv_obj_t * obj, bool en)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    if(!obj->hidden) lv_obj_invalidate(obj); /*Invalidate when not hidden (hidden objects are ignored) */\n\n    obj->hidden = en == false ? 0 : 1;\n\n    if(!obj->hidden) lv_obj_invalidate(obj); /*Invalidate when not hidden (hidden objects are ignored) */\n\n    lv_obj_t * par = lv_obj_get_parent(obj);\n    if(par) par->signal_cb(par, LV_SIGNAL_CHILD_CHG, obj);\n}\n\n/**\n * Set whether advanced hit-testing is enabled on an object\n * @param obj pointer to an object\n * @param en true: advanced hit-testing is enabled\n */\nvoid lv_obj_set_adv_hittest(lv_obj_t * obj, bool en)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->adv_hittest = en == false ? 0 : 1;\n}\n\n/**\n * Enable or disable the clicking of an object\n * @param obj pointer to an object\n * @param en true: make the object clickable\n */\nvoid lv_obj_set_click(lv_obj_t * obj, bool en)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->click = (en == true ? 1 : 0);\n}\n\n/**\n * Enable to bring this object to the foreground if it\n * or any of its children is clicked\n * @param obj pointer to an object\n * @param en true: enable the auto top feature\n */\nvoid lv_obj_set_top(lv_obj_t * obj, bool en)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->top = (en == true ? 1 : 0);\n}\n\n/**\n * Enable the dragging of an object\n * @param obj pointer to an object\n * @param en true: make the object draggable\n */\nvoid lv_obj_set_drag(lv_obj_t * obj, bool en)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    if(en == true) lv_obj_set_click(obj, true); /*Drag is useless without enabled clicking*/\n    obj->drag = (en == true ? 1 : 0);\n}\n\n/**\n * Set the directions an object can be dragged in\n * @param obj pointer to an object\n * @param drag_dir bitwise OR of allowed directions an object can be dragged in\n */\nvoid lv_obj_set_drag_dir(lv_obj_t * obj, lv_drag_dir_t drag_dir)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->drag_dir = drag_dir;\n\n    if(obj->drag_dir != 0) lv_obj_set_drag(obj, true); /*Drag direction requires drag*/\n}\n\n/**\n * Enable the throwing of an object after is is dragged\n * @param obj pointer to an object\n * @param en true: enable the drag throw\n */\nvoid lv_obj_set_drag_throw(lv_obj_t * obj, bool en)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->drag_throw = (en == true ? 1 : 0);\n}\n\n/**\n * Enable to use parent for drag related operations.\n * If trying to drag the object the parent will be moved instead\n * @param obj pointer to an object\n * @param en true: enable the 'drag parent' for the object\n */\nvoid lv_obj_set_drag_parent(lv_obj_t * obj, bool en)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->drag_parent = (en == true ? 1 : 0);\n}\n\n/**\n* Enable to use parent for gesture related operations.\n* If trying to gesture the object the parent will be moved instead\n* @param obj pointer to an object\n* @param en true: enable the 'gesture parent' for the object\n*/\nvoid lv_obj_set_gesture_parent(lv_obj_t * obj, bool en)\n{\n    obj->gesture_parent = (en == true ? 1 : 0);\n}\n\n/**\n* Enable to use parent for focus state.\n* When object is focused the parent will get the state instead (visual only)\n* @param obj pointer to an object\n* @param en true: enable the 'focus parent' for the object\n*/\nvoid lv_obj_set_focus_parent(lv_obj_t * obj, bool en)\n{\n    if(lv_obj_is_focused(obj)) {\n        if(en) {\n            obj->focus_parent = 1;\n            lv_obj_clear_state(obj, LV_STATE_FOCUSED | LV_STATE_EDITED);\n            lv_obj_set_state(lv_obj_get_focused_obj(obj), LV_STATE_FOCUSED);\n        }\n        else {\n            lv_obj_clear_state(lv_obj_get_focused_obj(obj), LV_STATE_FOCUSED | LV_STATE_EDITED);\n            lv_obj_set_state(obj, LV_STATE_FOCUSED);\n            obj->focus_parent = 0;\n        }\n    }\n    else {\n        obj->focus_parent = (en == true ? 1 : 0);\n    }\n}\n\n/**\n * Propagate the events to the parent too\n * @param obj pointer to an object\n * @param en true: enable the event propagation\n */\nvoid lv_obj_set_parent_event(lv_obj_t * obj, bool en)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->parent_event = (en == true ? 1 : 0);\n}\n\n/**\n * Set the base direction of the object.\n * @note This only works if LV_USE_BIDI is enabled.\n * @param obj pointer to an object\n * @param dir the new base direction. `LV_BIDI_DIR_LTR/RTL/AUTO/INHERIT`\n */\nvoid lv_obj_set_base_dir(lv_obj_t * obj, lv_bidi_dir_t dir)\n{\n    if(dir != LV_BIDI_DIR_LTR && dir != LV_BIDI_DIR_RTL &&\n       dir != LV_BIDI_DIR_AUTO && dir != LV_BIDI_DIR_INHERIT) {\n\n        LV_LOG_WARN(\"lv_obj_set_base_dir: invalid base dir\");\n        return;\n    }\n\n    obj->base_dir = dir;\n    lv_signal_send(obj, LV_SIGNAL_BASE_DIR_CHG, NULL);\n\n    /* Notify the children about the parent base dir has changed.\n     * (The children might have `LV_BIDI_DIR_INHERIT`)*/\n    base_dir_refr_children(obj);\n}\n\n/**\n * Set a bit or bits in the protect filed\n * @param obj pointer to an object\n * @param prot 'OR'-ed values from `lv_protect_t`\n */\nvoid lv_obj_add_protect(lv_obj_t * obj, uint8_t prot)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->protect |= prot;\n}\n\n/**\n * Clear a bit or bits in the protect filed\n * @param obj pointer to an object\n * @param prot 'OR'-ed values from `lv_protect_t`\n */\nvoid lv_obj_clear_protect(lv_obj_t * obj, uint8_t prot)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    prot = (~prot) & 0xFF;\n    obj->protect &= prot;\n}\n\n/**\n * Set the state (fully overwrite) of an object.\n * If specified in the styles a transition animation will be started\n * from the previous state to the current\n * @param obj pointer to an object\n * @param state the new state\n */\nvoid lv_obj_set_state(lv_obj_t * obj, lv_state_t new_state)\n{\n    if(obj->state == new_state) return;\n\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_state_t prev_state = obj->state;\n    style_snapshot_res_t cmp_res = STYLE_COMPARE_SAME;\n    uint8_t part;\n    for(part = 0; part < _LV_OBJ_PART_REAL_FIRST; part++) {\n        lv_style_list_t * style_list = lv_obj_get_style_list(obj, part);\n        if(style_list == NULL) break;   /*No more style lists*/\n        obj->state = prev_state;\n        style_snapshot_t shot_pre;\n        style_snapshot(obj, part, &shot_pre);\n        obj->state = new_state;\n        style_snapshot_t shot_post;\n        style_snapshot(obj, part, &shot_post);\n\n        style_snapshot_res_t r = style_snapshot_compare(&shot_pre, &shot_post);\n        if(r == STYLE_COMPARE_DIFF) {\n            cmp_res = STYLE_COMPARE_DIFF;\n            break;\n        }\n        if(r == STYLE_COMPARE_VISUAL_DIFF) {\n            cmp_res = STYLE_COMPARE_VISUAL_DIFF;\n        }\n    }\n\n    obj->state = new_state;\n\n    if(cmp_res == STYLE_COMPARE_SAME) {\n        return;\n    }\n\n#if LV_USE_ANIMATION == 0\n    if(cmp_res == STYLE_COMPARE_DIFF) lv_obj_refresh_style(obj, part, LV_STYLE_PROP_ALL);\n    else if(cmp_res == STYLE_COMPARE_VISUAL_DIFF) lv_obj_refresh_style(obj, LV_OBJ_PART_ALL, LV_STYLE_PROP_ALL);\n#else\n\n    for(part = 0; part < _LV_OBJ_PART_REAL_LAST; part++) {\n        lv_style_list_t * style_list = lv_obj_get_style_list(obj, part);\n        if(style_list == NULL) break;   /*No more style lists*/\n        if(style_list->ignore_trans) continue;\n\n        lv_style_int_t time = lv_obj_get_style_transition_time(obj, part);\n        lv_style_property_t props[LV_STYLE_TRANS_NUM_MAX];\n        lv_style_int_t delay = lv_obj_get_style_transition_delay(obj, part);\n        const lv_anim_path_t * path = lv_obj_get_style_transition_path(obj, part);\n        props[0] = lv_obj_get_style_transition_prop_1(obj, part);\n        props[1] = lv_obj_get_style_transition_prop_2(obj, part);\n        props[2] = lv_obj_get_style_transition_prop_3(obj, part);\n        props[3] = lv_obj_get_style_transition_prop_4(obj, part);\n        props[4] = lv_obj_get_style_transition_prop_5(obj, part);\n        props[5] = lv_obj_get_style_transition_prop_6(obj, part);\n\n        uint8_t i;\n        for(i = 0; i < LV_STYLE_TRANS_NUM_MAX; i++) {\n            if(props[i] != 0) {\n                _lv_style_list_add_trans_style(style_list);\n\n                lv_style_trans_t * tr = trans_create(obj, props[i], part, prev_state, new_state);\n\n                /*If there is a pending anim for this property remove it*/\n                if(tr) {\n                    tr->obj = obj;\n                    tr->prop = props[i];\n                    tr->part = part;\n\n                    lv_anim_t a;\n                    lv_anim_init(&a);\n                    lv_anim_set_var(&a, tr);\n                    lv_anim_set_exec_cb(&a, (lv_anim_exec_xcb_t)trans_anim_cb);\n                    lv_anim_set_start_cb(&a, trans_anim_start_cb);\n                    lv_anim_set_ready_cb(&a, trans_anim_ready_cb);\n                    lv_anim_set_values(&a, 0x00, 0xFF);\n                    lv_anim_set_time(&a, time);\n                    lv_anim_set_delay(&a, delay);\n                    lv_anim_set_path(&a, path);\n                    a.early_apply = 0;\n                    lv_anim_start(&a);\n                }\n\n            }\n        }\n        if(cmp_res == STYLE_COMPARE_DIFF) lv_obj_refresh_style(obj, part, LV_STYLE_PROP_ALL);\n\n        if(cmp_res == STYLE_COMPARE_VISUAL_DIFF) {\n            invalidate_style_cache(obj, part, LV_STYLE_PROP_ALL);\n        }\n    }\n\n    if(cmp_res == STYLE_COMPARE_VISUAL_DIFF) {\n        lv_obj_invalidate(obj);\n    }\n\n#endif\n\n}\n\n/**\n * Add a given state or states to the object. The other state bits will remain unchanged.\n * If specified in the styles a transition animation will be started\n * from the previous state to the current\n * @param obj pointer to an object\n * @param state the state bits to add. E.g `LV_STATE_PRESSED | LV_STATE_FOCUSED`\n */\nvoid lv_obj_add_state(lv_obj_t * obj, lv_state_t state)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_state_t new_state = obj->state | state;\n    if(obj->state != new_state) {\n        lv_obj_set_state(obj, new_state);\n    }\n}\n\n/**\n * Remove a given state or states to the object. The other state bits will remain unchanged.\n * If specified in the styles a transition animation will be started\n * from the previous state to the current\n * @param obj pointer to an object\n * @param state the state bits to remove. E.g `LV_STATE_PRESSED | LV_STATE_FOCUSED`\n */\nvoid lv_obj_clear_state(lv_obj_t * obj, lv_state_t state)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_state_t new_state = obj->state & (~state);\n    if(obj->state != new_state) {\n        lv_obj_set_state(obj, new_state);\n    }\n}\n\n#if LV_USE_ANIMATION\n/**\n * Finish all pending transitions on a part of an object\n * @param obj pointer to an object\n * @param part part of the object, e.g `LV_BRN_PART_MAIN` or `LV_OBJ_PART_ALL` for all parts\n */\nvoid lv_obj_finish_transitions(lv_obj_t * obj, uint8_t part)\n{\n    /*Animate all related transition to the end value*/\n    lv_style_trans_t * tr;\n    _LV_LL_READ_BACK(LV_GC_ROOT(_lv_obj_style_trans_ll), tr) {\n        if(tr->obj == obj && (part == tr->part || part == LV_OBJ_PART_ALL)) {\n            trans_anim_cb(tr, 255);\n        }\n    }\n\n    /*Free all related transition data*/\n    trans_del(obj, part, 0xFF, NULL);\n}\n#endif\n\n/**\n * Set a an event handler function for an object.\n * Used by the user to react on event which happens with the object.\n * @param obj pointer to an object\n * @param event_cb the new event function\n */\nvoid lv_obj_set_event_cb(lv_obj_t * obj, lv_event_cb_t event_cb)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->event_cb = event_cb;\n}\n\n/**\n * Send an event to the object\n * @param obj pointer to an object\n * @param event the type of the event from `lv_event_t`\n * @param data arbitrary data depending on the object type and the event. (Usually `NULL`)\n * @return LV_RES_OK: `obj` was not deleted in the event; LV_RES_INV: `obj` was deleted in the event\n */\nlv_res_t lv_event_send(lv_obj_t * obj, lv_event_t event, const void * data)\n{\n    if(obj == NULL) return LV_RES_OK;\n\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_res_t res;\n    res = lv_event_send_func(obj->event_cb, obj, event, data);\n    return res;\n}\n\n/**\n * Send LV_EVENT_REFRESH event to an object\n * @param obj point to an object. (Can NOT be NULL)\n * @return LV_RES_OK: success, LV_RES_INV: to object become invalid (e.g. deleted) due to this event.\n */\nlv_res_t lv_event_send_refresh(lv_obj_t * obj)\n{\n    return lv_event_send(obj, LV_EVENT_REFRESH, NULL);\n}\n\n/**\n * Send LV_EVENT_REFRESH event to an object and all of its children.\n * @param obj pointer to an object or NULL to refresh all objects of all displays\n */\nvoid lv_event_send_refresh_recursive(lv_obj_t * obj)\n{\n    if(obj == NULL) {\n        /*If no obj specified refresh all screen of all displays */\n        lv_disp_t * d = lv_disp_get_next(NULL);\n        while(d) {\n            lv_obj_t * scr = _lv_ll_get_head(&d->scr_ll);\n            while(scr) {\n                lv_event_send_refresh_recursive(scr);\n                scr = _lv_ll_get_next(&d->scr_ll, scr);\n            }\n            lv_event_send_refresh_recursive(d->top_layer);\n            lv_event_send_refresh_recursive(d->sys_layer);\n\n            d = lv_disp_get_next(d);\n        }\n    }\n    else {\n\n        lv_res_t res = lv_event_send_refresh(obj);\n        if(res != LV_RES_OK) return; /*If invalid returned do not check the children*/\n\n        lv_obj_t * child = lv_obj_get_child(obj, NULL);\n        while(child) {\n            lv_event_send_refresh_recursive(child);\n\n            child = lv_obj_get_child(obj, child);\n        }\n    }\n}\n\n/**\n * Call an event function with an object, event, and data.\n * @param event_xcb an event callback function. If `NULL` `LV_RES_OK` will return without any actions.\n *        (the 'x' in the argument name indicates that its not a fully generic function because it not follows\n *         the `func_name(object, callback, ...)` convention)\n * @param obj pointer to an object to associate with the event (can be `NULL` to simply call the `event_cb`)\n * @param event an event\n * @param data pointer to a custom data\n * @return LV_RES_OK: `obj` was not deleted in the event; LV_RES_INV: `obj` was deleted in the event\n */\nlv_res_t lv_event_send_func(lv_event_cb_t event_xcb, lv_obj_t * obj, lv_event_t event, const void * data)\n{\n    if(obj != NULL) {\n        LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n    }\n\n    /* Build a simple linked list from the objects used in the events\n     * It's important to know if an this object was deleted by a nested event\n     * called from this `even_cb`. */\n    lv_event_temp_data_t event_temp_data;\n    event_temp_data.obj     = obj;\n    event_temp_data.deleted = false;\n    event_temp_data.prev    = NULL;\n\n    if(event_temp_data_head) {\n        event_temp_data.prev = event_temp_data_head;\n    }\n    event_temp_data_head = &event_temp_data;\n\n    const void * event_act_data_save = event_act_data;\n    event_act_data                   = data;\n\n    /*Call the input device's feedback callback if set*/\n    lv_indev_t * indev_act = lv_indev_get_act();\n    if(indev_act) {\n        if(indev_act->driver.feedback_cb) indev_act->driver.feedback_cb(&indev_act->driver, event);\n    }\n\n    /*Call the event callback itself*/\n    if(event_xcb) event_xcb(obj, event);\n\n    /*Restore the event data*/\n    event_act_data = event_act_data_save;\n\n    /*Remove this element from the list*/\n    event_temp_data_head = event_temp_data_head->prev;\n\n    if(event_temp_data.deleted) {\n        return LV_RES_INV;\n    }\n\n    if(obj) {\n        if(obj->parent_event && obj->parent) {\n            lv_res_t res = lv_event_send(obj->parent, event, data);\n            if(res != LV_RES_OK) {\n                return LV_RES_INV;\n            }\n        }\n    }\n\n    return LV_RES_OK;\n}\n\n/**\n * Get the `data` parameter of the current event\n * @return the `data` parameter\n */\nconst void * lv_event_get_data(void)\n{\n    return event_act_data;\n}\n\n/**\n * Set the a signal function of an object. Used internally by the library.\n * Always call the previous signal function in the new.\n * @param obj pointer to an object\n * @param cb the new signal function\n */\nvoid lv_obj_set_signal_cb(lv_obj_t * obj, lv_signal_cb_t signal_cb)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->signal_cb = signal_cb;\n}\n\n/**\n * Send an event to the object\n * @param obj pointer to an object\n * @param event the type of the event from `lv_event_t`.\n * @return LV_RES_OK or LV_RES_INV\n */\nlv_res_t lv_signal_send(lv_obj_t * obj, lv_signal_t signal, void * param)\n{\n    if(obj == NULL) return LV_RES_OK;\n\n    lv_res_t res = LV_RES_OK;\n    if(obj->signal_cb) res = obj->signal_cb(obj, signal, param);\n\n    return res;\n}\n\n/**\n * Set a new design function for an object\n * @param obj pointer to an object\n * @param design_cb the new design function\n */\nvoid lv_obj_set_design_cb(lv_obj_t * obj, lv_design_cb_t design_cb)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->design_cb = design_cb;\n}\n\n/*----------------\n * Other set\n *--------------*/\n\n/**\n * Allocate a new ext. data for an object\n * @param obj pointer to an object\n * @param ext_size the size of the new ext. data\n * @return pointer to the allocated ext.\n * If out of memory NULL is returned and the original ext is preserved\n */\nvoid * lv_obj_allocate_ext_attr(lv_obj_t * obj, uint16_t ext_size)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    void * new_ext = lv_mem_realloc(obj->ext_attr, ext_size);\n    if(new_ext == NULL) return NULL;\n\n    obj->ext_attr = new_ext;\n    return (void *)obj->ext_attr;\n}\n\n/**\n * Send a 'LV_SIGNAL_REFR_EXT_SIZE' signal to the object to refresh the extended draw area.\n * he object needs to be invalidated by `lv_obj_invalidate(obj)` manually after this function.\n * @param obj pointer to an object\n */\nvoid lv_obj_refresh_ext_draw_pad(lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->ext_draw_pad = 0;\n    obj->signal_cb(obj, LV_SIGNAL_REFR_EXT_DRAW_PAD, NULL);\n\n}\n\n/*=======================\n * Getter functions\n *======================*/\n\n/**\n * Return with the screen of an object\n * @param obj pointer to an object\n * @return pointer to a screen\n */\nlv_obj_t * lv_obj_get_screen(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    const lv_obj_t * par = obj;\n    const lv_obj_t * act_p;\n\n    do {\n        act_p = par;\n        par   = lv_obj_get_parent(act_p);\n    } while(par != NULL);\n\n    return (lv_obj_t *)act_p;\n}\n\n/**\n * Get the display of an object\n * @param scr pointer to an object\n * @return pointer the object's display\n */\nlv_disp_t * lv_obj_get_disp(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    const lv_obj_t * scr;\n\n    if(obj->parent == NULL)\n        scr = obj; /*`obj` is a screen*/\n    else\n        scr = lv_obj_get_screen(obj); /*get the screen of `obj`*/\n\n    lv_disp_t * d;\n    _LV_LL_READ(LV_GC_ROOT(_lv_disp_ll), d) {\n        lv_obj_t * s;\n        _LV_LL_READ(d->scr_ll, s) {\n            if(s == scr) return d;\n        }\n    }\n\n    LV_LOG_WARN(\"lv_scr_get_disp: screen not found\")\n    return NULL;\n}\n\n/*---------------------\n * Parent/children get\n *--------------------*/\n\n/**\n * Returns with the parent of an object\n * @param obj pointer to an object\n * @return pointer to the parent of  'obj'\n */\nlv_obj_t * lv_obj_get_parent(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return obj->parent;\n}\n\n/**\n * Iterate through the children of an object (start from the \"youngest\")\n * @param obj pointer to an object\n * @param child NULL at first call to get the next children\n *                  and the previous return value later\n * @return the child after 'act_child' or NULL if no more child\n */\nlv_obj_t * lv_obj_get_child(const lv_obj_t * obj, const lv_obj_t * child)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_obj_t * result = NULL;\n\n    if(child == NULL) {\n        result = _lv_ll_get_head(&obj->child_ll);\n    }\n    else {\n        result = _lv_ll_get_next(&obj->child_ll, child);\n    }\n\n    return result;\n}\n\n/**\n * Iterate through the children of an object (start from the \"oldest\")\n * @param obj pointer to an object\n * @param child NULL at first call to get the next children\n *                  and the previous return value later\n * @return the child after 'act_child' or NULL if no more child\n */\nlv_obj_t * lv_obj_get_child_back(const lv_obj_t * obj, const lv_obj_t * child)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_obj_t * result = NULL;\n\n    if(child == NULL) {\n        result = _lv_ll_get_tail(&obj->child_ll);\n    }\n    else {\n        result = _lv_ll_get_prev(&obj->child_ll, child);\n    }\n\n    return result;\n}\n\n/**\n * Count the children of an object (only children directly on 'obj')\n * @param obj pointer to an object\n * @return children number of 'obj'\n */\nuint16_t lv_obj_count_children(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_obj_t * i;\n    uint16_t cnt = 0;\n\n    _LV_LL_READ(obj->child_ll, i) cnt++;\n\n    return cnt;\n}\n\n/** Recursively count the children of an object\n * @param obj pointer to an object\n * @return children number of 'obj'\n */\nuint16_t lv_obj_count_children_recursive(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_obj_t * i;\n    uint16_t cnt = 0;\n\n    _LV_LL_READ(obj->child_ll, i) {\n        cnt++;                                     /*Count the child*/\n        cnt += lv_obj_count_children_recursive(i); /*recursively count children's children*/\n    }\n\n    return cnt;\n}\n\n/*---------------------\n * Coordinate get\n *--------------------*/\n\n/**\n * Copy the coordinates of an object to an area\n * @param obj pointer to an object\n * @param cords_p pointer to an area to store the coordinates\n */\nvoid lv_obj_get_coords(const lv_obj_t * obj, lv_area_t * cords_p)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_area_copy(cords_p, &obj->coords);\n}\n\n/**\n * Reduce area retried by `lv_obj_get_coords()` the get graphically usable area of an object.\n * (Without the size of the border or other extra graphical elements)\n * @param coords_p store the result area here\n */\nvoid lv_obj_get_inner_coords(const lv_obj_t * obj, lv_area_t * coords_p)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_border_side_t part = lv_obj_get_style_border_side(obj, LV_OBJ_PART_MAIN);\n    lv_coord_t w = lv_obj_get_style_border_width(obj, LV_OBJ_PART_MAIN);\n\n    if(part & LV_BORDER_SIDE_LEFT) coords_p->x1 += w;\n\n    if(part & LV_BORDER_SIDE_RIGHT) coords_p->x2 -= w;\n\n    if(part & LV_BORDER_SIDE_TOP) coords_p->y1 += w;\n\n    if(part & LV_BORDER_SIDE_BOTTOM) coords_p->y2 -= w;\n}\n\n/**\n * Get the x coordinate of object\n * @param obj pointer to an object\n * @return distance of 'obj' from the left side of its parent\n */\nlv_coord_t lv_obj_get_x(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_coord_t rel_x;\n    lv_obj_t * parent = lv_obj_get_parent(obj);\n    if(parent) {\n        rel_x             = obj->coords.x1 - parent->coords.x1;\n    }\n    else {\n        rel_x = obj->coords.x1;\n    }\n    return rel_x;\n}\n\n/**\n * Get the y coordinate of object\n * @param obj pointer to an object\n * @return distance of 'obj' from the top of its parent\n */\nlv_coord_t lv_obj_get_y(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_coord_t rel_y;\n    lv_obj_t * parent = lv_obj_get_parent(obj);\n    if(parent) {\n        rel_y             = obj->coords.y1 - parent->coords.y1;\n    }\n    else {\n        rel_y = obj->coords.y1;\n    }\n    return rel_y;\n}\n\n/**\n * Get the width of an object\n * @param obj pointer to an object\n * @return the width\n */\nlv_coord_t lv_obj_get_width(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return lv_area_get_width(&obj->coords);\n}\n\n/**\n * Get the height of an object\n * @param obj pointer to an object\n * @return the height\n */\nlv_coord_t lv_obj_get_height(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return lv_area_get_height(&obj->coords);\n}\n\n/**\n * Get that width reduced by the left and right padding.\n * @param obj pointer to an object\n * @return the width which still fits into the container\n */\nlv_coord_t lv_obj_get_width_fit(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_style_int_t left = lv_obj_get_style_pad_left(obj, LV_OBJ_PART_MAIN);\n    lv_style_int_t right = lv_obj_get_style_pad_right(obj, LV_OBJ_PART_MAIN);\n\n    return lv_obj_get_width(obj) - left - right;\n}\n\n/**\n * Get that height reduced by the top an bottom padding.\n * @param obj pointer to an object\n * @return the height which still fits into the container\n */\nlv_coord_t lv_obj_get_height_fit(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_style_int_t top = lv_obj_get_style_pad_top((lv_obj_t *)obj, LV_OBJ_PART_MAIN);\n    lv_style_int_t bottom =  lv_obj_get_style_pad_bottom((lv_obj_t *)obj, LV_OBJ_PART_MAIN);\n\n    return lv_obj_get_height(obj) - top - bottom;\n}\n\n/**\n * Get the height of an object by taking the top and bottom margin into account.\n * The returned height will be `obj_h + margin_top + margin_bottom`\n * @param obj pointer to an object\n * @return the height including thee margins\n */\nlv_coord_t lv_obj_get_height_margin(lv_obj_t * obj)\n{\n    lv_style_int_t mtop = lv_obj_get_style_margin_top(obj, LV_OBJ_PART_MAIN);\n    lv_style_int_t mbottom = lv_obj_get_style_margin_bottom(obj, LV_OBJ_PART_MAIN);\n\n    return lv_obj_get_height(obj) + mtop + mbottom;\n}\n\n/**\n * Get the width of an object by taking the left and right margin into account.\n * The returned width will be `obj_w + margin_left + margin_right`\n * @param obj pointer to an object\n * @return the height including thee margins\n */\nlv_coord_t lv_obj_get_width_margin(lv_obj_t * obj)\n{\n    lv_style_int_t mleft = lv_obj_get_style_margin_left(obj, LV_OBJ_PART_MAIN);\n    lv_style_int_t mright = lv_obj_get_style_margin_right(obj, LV_OBJ_PART_MAIN);\n\n    return lv_obj_get_width(obj) + mleft + mright;\n}\n\n/**\n * Set that width reduced by the left and right padding of the parent.\n * @param obj pointer to an object\n * @param div indicates how many columns are assumed.\n * If 1 the width will be set the parent's width\n * If 2 only half parent width - inner padding of the parent\n * If 3 only third parent width - 2 * inner padding of the parent\n * @param span how many columns are combined\n * @return the width according to the given parameters\n */\nlv_coord_t lv_obj_get_width_grid(lv_obj_t * obj, uint8_t div, uint8_t span)\n{\n    lv_coord_t obj_w = lv_obj_get_width_fit(obj);\n    lv_style_int_t pinner = lv_obj_get_style_pad_inner(obj, LV_OBJ_PART_MAIN);\n\n    lv_coord_t r = (obj_w - (div - 1) * pinner) / div;\n\n    r = r * span + (span - 1) * pinner;\n    return r;\n}\n\n/**\n * Get that height reduced by the top and bottom padding of the parent.\n * @param obj pointer to an object\n * @param div indicates how many rows are assumed.\n * If 1 the height will be set the parent's height\n * If 2 only half parent height - inner padding of the parent\n * If 3 only third parent height - 2 * inner padding of the parent\n * @param span how many rows are combined\n * @return the height according to the given parameters\n */\nlv_coord_t lv_obj_get_height_grid(lv_obj_t * obj, uint8_t div, uint8_t span)\n{\n    lv_coord_t obj_h = lv_obj_get_height_fit(obj);\n    lv_style_int_t pinner = lv_obj_get_style_pad_inner(obj, LV_OBJ_PART_MAIN);\n\n    lv_coord_t r = (obj_h - (div - 1) * pinner) / div;\n\n    r = r * span + (span - 1) * pinner;\n    return r;\n}\n\n/**\n * Get the automatic realign property of the object.\n * @param obj pointer to an object\n * @return true: auto realign is enabled; false: auto realign is disabled\n */\nbool lv_obj_get_auto_realign(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_OBJ_REALIGN\n    return obj->realign.auto_realign ? true : false;\n#else\n    (void)obj;\n    return false;\n#endif\n}\n\n/**\n * Get the left padding of extended clickable area\n * @param obj pointer to an object\n * @return the extended left padding\n */\nlv_coord_t lv_obj_get_ext_click_pad_left(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_TINY\n    return obj->ext_click_pad_hor;\n#elif LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_FULL\n    return obj->ext_click_pad.x1;\n#else\n    (void)obj;    /*Unused*/\n    return 0;\n#endif\n}\n\n/**\n * Get the right padding of extended clickable area\n * @param obj pointer to an object\n * @return the extended right padding\n */\nlv_coord_t lv_obj_get_ext_click_pad_right(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_TINY\n    return obj->ext_click_pad_hor;\n#elif LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_FULL\n    return obj->ext_click_pad.x2;\n#else\n    (void)obj; /*Unused*/\n    return 0;\n#endif\n}\n\n/**\n * Get the top padding of extended clickable area\n * @param obj pointer to an object\n * @return the extended top padding\n */\nlv_coord_t lv_obj_get_ext_click_pad_top(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_TINY\n    return obj->ext_click_pad_ver;\n#elif LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_FULL\n    return obj->ext_click_pad.y1;\n#else\n    (void)obj; /*Unused*/\n    return 0;\n#endif\n}\n\n/**\n * Get the bottom padding of extended clickable area\n * @param obj pointer to an object\n * @return the extended bottom padding\n */\nlv_coord_t lv_obj_get_ext_click_pad_bottom(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_TINY\n    return obj->ext_click_pad_ver;\n#elif LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_FULL\n    return obj->ext_click_pad.y2;\n#else\n    (void)obj; /*Unused*/\n    return 0;\n#endif\n}\n\n/**\n * Get the extended size attribute of an object\n * @param obj pointer to an object\n * @return the extended size attribute\n */\nlv_coord_t lv_obj_get_ext_draw_pad(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return obj->ext_draw_pad;\n}\n\n/*-----------------\n * Appearance get\n *---------------*/\n\nlv_style_list_t * lv_obj_get_style_list(const lv_obj_t * obj, uint8_t part)\n{\n    if(part == LV_OBJ_PART_MAIN) return &((lv_obj_t *)obj)->style_list;\n\n    lv_get_style_info_t info;\n    info.part = part;\n    info.result = NULL;\n\n    lv_res_t res;\n    res = lv_signal_send((lv_obj_t *)obj, LV_SIGNAL_GET_STYLE, &info);\n\n    if(res != LV_RES_OK) return NULL;\n\n    return info.result;\n}\n\n/**\n * Get a style property of a part of an object in the object's current state.\n * If there is a running transitions it is taken into account\n * @param obj pointer to an object\n * @param part the part of the object which style property should be get.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop the property to get. E.g. `LV_STYLE_BORDER_WIDTH`.\n *  The state of the object will be added internally\n * @return the value of the property of the given part in the current state.\n * If the property is not found a default value will be returned.\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_width()`\n * @note for performance reasons it's not checked if the property really has integer type\n */\nlv_style_int_t _lv_obj_get_style_int(const lv_obj_t * obj, uint8_t part, lv_style_property_t prop)\n{\n    lv_style_property_t prop_ori = prop;\n\n    lv_style_attr_t attr;\n    attr = prop_ori >> 8;\n\n    lv_style_int_t value_act;\n    lv_res_t res = LV_RES_INV;\n    const lv_obj_t * parent = obj;\n    while(parent) {\n        lv_style_list_t * list = lv_obj_get_style_list(parent, part);\n        if(!list->ignore_cache && list->style_cnt > 0) {\n            if(!list->valid_cache) update_style_cache((lv_obj_t *)parent, part, prop  & (~LV_STYLE_STATE_MASK));\n\n            bool def = false;\n            switch(prop  & (~LV_STYLE_STATE_MASK)) {\n                case LV_STYLE_CLIP_CORNER:\n                    if(list->clip_corner_off) def = true;\n                    break;\n                case LV_STYLE_TEXT_LETTER_SPACE:\n                case LV_STYLE_TEXT_LINE_SPACE:\n                    if(list->text_space_zero) def = true;\n                    break;\n                case LV_STYLE_TRANSFORM_ANGLE:\n                case LV_STYLE_TRANSFORM_WIDTH:\n                case LV_STYLE_TRANSFORM_HEIGHT:\n                case LV_STYLE_TRANSFORM_ZOOM:\n                    if(list->transform_all_zero) def = true;\n                    break;\n                case LV_STYLE_BORDER_WIDTH:\n                    if(list->border_width_zero) def = true;\n                    break;\n                case LV_STYLE_BORDER_SIDE:\n                    if(list->border_side_full) def = true;\n                    break;\n                case LV_STYLE_BORDER_POST:\n                    if(list->border_post_off) def = true;\n                    break;\n                case LV_STYLE_OUTLINE_WIDTH:\n                    if(list->outline_width_zero) def = true;\n                    break;\n                case LV_STYLE_RADIUS:\n                    if(list->radius_zero) def = true;\n                    break;\n                case LV_STYLE_SHADOW_WIDTH:\n                    if(list->shadow_width_zero) def = true;\n                    break;\n                case LV_STYLE_PAD_TOP:\n                case LV_STYLE_PAD_BOTTOM:\n                case LV_STYLE_PAD_LEFT:\n                case LV_STYLE_PAD_RIGHT:\n                    if(list->pad_all_zero) def = true;\n                    break;\n                case LV_STYLE_MARGIN_TOP:\n                case LV_STYLE_MARGIN_BOTTOM:\n                case LV_STYLE_MARGIN_LEFT:\n                case LV_STYLE_MARGIN_RIGHT:\n                    if(list->margin_all_zero) def = true;\n                    break;\n                case LV_STYLE_BG_BLEND_MODE:\n                case LV_STYLE_BORDER_BLEND_MODE:\n                case LV_STYLE_IMAGE_BLEND_MODE:\n                case LV_STYLE_LINE_BLEND_MODE:\n                case LV_STYLE_OUTLINE_BLEND_MODE:\n                case LV_STYLE_PATTERN_BLEND_MODE:\n                case LV_STYLE_SHADOW_BLEND_MODE:\n                case LV_STYLE_TEXT_BLEND_MODE:\n                case LV_STYLE_VALUE_BLEND_MODE:\n                    if(list->blend_mode_all_normal) def = true;\n                    break;\n                case LV_STYLE_TEXT_DECOR:\n                    if(list->text_decor_none) def = true;\n                    break;\n            }\n\n            if(def) {\n                break;\n            }\n        }\n\n        lv_state_t state = lv_obj_get_state(parent, part);\n        prop = (uint16_t)prop_ori + ((uint16_t)state << LV_STYLE_STATE_POS);\n\n        res = _lv_style_list_get_int(list, prop, &value_act);\n        if(res == LV_RES_OK) return value_act;\n\n        if(LV_STYLE_ATTR_GET_INHERIT(attr) == 0) break;\n\n        /*If not found, check the `MAIN` style first*/\n        if(part != LV_OBJ_PART_MAIN) {\n            part = LV_OBJ_PART_MAIN;\n            continue;\n        }\n\n        /*Check the parent too.*/\n        parent = lv_obj_get_parent(parent);\n    }\n\n    /*Handle unset values*/\n    prop = prop & (~LV_STYLE_STATE_MASK);\n    switch(prop) {\n        case LV_STYLE_BORDER_SIDE:\n            return LV_BORDER_SIDE_FULL;\n        case LV_STYLE_SIZE:\n            return LV_DPI / 20;\n        case LV_STYLE_SCALE_WIDTH:\n            return LV_DPI / 8;\n        case LV_STYLE_BG_GRAD_STOP:\n            return 255;\n        case LV_STYLE_TRANSFORM_ZOOM:\n            return LV_IMG_ZOOM_NONE;\n    }\n\n    return 0;\n}\n\n/**\n * Get a style property of a part of an object in the object's current state.\n * If there is a running transitions it is taken into account\n * @param obj pointer to an object\n * @param part the part of the object which style property should be get.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop the property to get. E.g. `LV_STYLE_BORDER_COLOR`.\n *  The state of the object will be added internally\n * @return the value of the property of the given part in the current state.\n * If the property is not found a default value will be returned.\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_color()`\n * @note for performance reasons it's not checked if the property really has color type\n */\nlv_color_t _lv_obj_get_style_color(const lv_obj_t * obj, uint8_t part, lv_style_property_t prop)\n{\n    lv_style_property_t prop_ori = prop;\n\n    lv_style_attr_t attr;\n    attr = prop_ori >> 8;\n\n    lv_color_t value_act;\n    lv_res_t res = LV_RES_INV;\n    const lv_obj_t * parent = obj;\n    while(parent) {\n        lv_style_list_t * list = lv_obj_get_style_list(parent, part);\n\n        lv_state_t state = lv_obj_get_state(parent, part);\n        prop = (uint16_t)prop_ori + ((uint16_t)state << LV_STYLE_STATE_POS);\n\n        res = _lv_style_list_get_color(list, prop, &value_act);\n        if(res == LV_RES_OK) return value_act;\n\n        if(LV_STYLE_ATTR_GET_INHERIT(attr) == 0) break;\n\n        /*If not found, check the `MAIN` style first*/\n        if(part != LV_OBJ_PART_MAIN) {\n            part = LV_OBJ_PART_MAIN;\n            continue;\n        }\n\n        /*Check the parent too.*/\n        parent = lv_obj_get_parent(parent);\n    }\n\n    /*Handle unset values*/\n    prop = prop & (~LV_STYLE_STATE_MASK);\n    switch(prop) {\n        case LV_STYLE_BG_COLOR:\n        case LV_STYLE_BG_GRAD_COLOR:\n            return LV_COLOR_WHITE;\n    }\n\n    return LV_COLOR_BLACK;\n}\n\n/**\n * Get a style property of a part of an object in the object's current state.\n * If there is a running transitions it is taken into account\n * @param obj pointer to an object\n * @param part the part of the object which style property should be get.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop the property to get. E.g. `LV_STYLE_BORDER_OPA`.\n *  The state of the object will be added internally\n * @return the value of the property of the given part in the current state.\n * If the property is not found a default value will be returned.\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_opa()`\n * @note for performance reasons it's not checked if the property really has opacity type\n */\nlv_opa_t _lv_obj_get_style_opa(const lv_obj_t * obj, uint8_t part, lv_style_property_t prop)\n{\n    lv_style_property_t prop_ori = prop;\n\n    lv_style_attr_t attr;\n    attr = prop_ori >> 8;\n\n    lv_opa_t value_act;\n    lv_res_t res = LV_RES_INV;\n    const lv_obj_t * parent = obj;\n    while(parent) {\n        lv_style_list_t * list = lv_obj_get_style_list(parent, part);\n\n        if(!list->ignore_cache && list->style_cnt > 0) {\n            if(!list->valid_cache) update_style_cache((lv_obj_t *)parent, part, prop  & (~LV_STYLE_STATE_MASK));\n            bool def = false;\n            switch(prop & (~LV_STYLE_STATE_MASK)) {\n                case LV_STYLE_OPA_SCALE:\n                    if(list->opa_scale_cover) def = true;\n                    break;\n                case LV_STYLE_BG_OPA:\n                    if(list->bg_opa_cover) return LV_OPA_COVER;     /*Special case, not the default value is used*/\n                    if(list->bg_opa_transp) def = true;\n                    break;\n                case LV_STYLE_IMAGE_RECOLOR_OPA:\n                    if(list->img_recolor_opa_transp) def = true;\n                    break;\n            }\n\n            if(def) {\n                break;\n            }\n        }\n\n        lv_state_t state = lv_obj_get_state(parent, part);\n        prop = (uint16_t)prop_ori + ((uint16_t)state << LV_STYLE_STATE_POS);\n\n        res = _lv_style_list_get_opa(list, prop, &value_act);\n        if(res == LV_RES_OK) return value_act;\n\n        if(LV_STYLE_ATTR_GET_INHERIT(attr) == 0) break;\n\n        /*If not found, check the `MAIN` style first*/\n        if(part != LV_OBJ_PART_MAIN) {\n            part = LV_OBJ_PART_MAIN;\n            continue;\n        }\n\n        /*Check the parent too.*/\n        parent = lv_obj_get_parent(parent);\n    }\n\n    /*Handle unset values*/\n    prop = prop & (~LV_STYLE_STATE_MASK);\n    switch(prop) {\n        case LV_STYLE_BG_OPA:\n        case LV_STYLE_IMAGE_RECOLOR_OPA:\n        case LV_STYLE_PATTERN_RECOLOR_OPA:\n            return LV_OPA_TRANSP;\n    }\n\n    return LV_OPA_COVER;\n}\n\n/**\n * Get a style property of a part of an object in the object's current state.\n * If there is a running transitions it is taken into account\n * @param obj pointer to an object\n * @param part the part of the object which style property should be get.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop the property to get. E.g. `LV_STYLE_TEXT_FONT`.\n *  The state of the object will be added internally\n * @return the value of the property of the given part in the current state.\n * If the property is not found a default value will be returned.\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_opa()`\n * @note for performance reasons it's not checked if the property really has pointer type\n */\nconst void * _lv_obj_get_style_ptr(const lv_obj_t * obj, uint8_t part, lv_style_property_t prop)\n{\n    lv_style_property_t prop_ori = prop;\n\n    lv_style_attr_t attr;\n    attr = prop_ori >> 8;\n\n    const void * value_act;\n    lv_res_t res = LV_RES_INV;\n    const lv_obj_t * parent = obj;\n    while(parent) {\n        lv_style_list_t * list = lv_obj_get_style_list(parent, part);\n\n        if(!list->ignore_cache && list->style_cnt > 0) {\n            if(!list->valid_cache) update_style_cache((lv_obj_t *)parent, part, prop  & (~LV_STYLE_STATE_MASK));\n            bool def = false;\n            switch(prop  & (~LV_STYLE_STATE_MASK)) {\n                case LV_STYLE_VALUE_STR:\n                    if(list->value_txt_str) def = true;\n                    break;\n                case LV_STYLE_PATTERN_IMAGE:\n                    if(list->pattern_img_null) def = true;\n                    break;\n                case LV_STYLE_TEXT_FONT:\n                    if(list->text_font_normal) def = true;\n                    break;\n            }\n\n            if(def) {\n                break;\n            }\n        }\n\n        lv_state_t state = lv_obj_get_state(parent, part);\n        prop = (uint16_t)prop_ori + ((uint16_t)state << LV_STYLE_STATE_POS);\n\n        res = _lv_style_list_get_ptr(list, prop, &value_act);\n        if(res == LV_RES_OK)  return value_act;\n\n        if(LV_STYLE_ATTR_GET_INHERIT(attr) == 0) break;\n\n        /*If not found, check the `MAIN` style first*/\n        if(part != LV_OBJ_PART_MAIN) {\n            part = LV_OBJ_PART_MAIN;\n            continue;\n        }\n\n        /*Check the parent too.*/\n        parent = lv_obj_get_parent(parent);\n    }\n\n    /*Handle unset values*/\n    prop = prop & (~LV_STYLE_STATE_MASK);\n    switch(prop) {\n        case LV_STYLE_TEXT_FONT:\n        case LV_STYLE_VALUE_FONT:\n            return lv_theme_get_font_normal();\n#if LV_USE_ANIMATION\n        case LV_STYLE_TRANSITION_PATH:\n            return &lv_anim_path_def;\n#endif\n    }\n\n    return NULL;\n}\n\n/**\n * Get the local style of a part of an object.\n * @param obj pointer to an object\n * @param part the part of the object which style property should be set.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @return pointer to the local style if exists else `NULL`.\n */\nlv_style_t * lv_obj_get_local_style(lv_obj_t * obj, uint8_t part)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n    lv_style_list_t * style_list = lv_obj_get_style_list(obj, part);\n    return lv_style_list_get_local_style(style_list);\n}\n\n/*-----------------\n * Attribute get\n *----------------*/\n\n/**\n * Get the hidden attribute of an object\n * @param obj pointer to an object\n * @return true: the object is hidden\n */\nbool lv_obj_get_hidden(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return obj->hidden == 0 ? false : true;\n}\n\n/**\n * Get whether advanced hit-testing is enabled on an object\n * @param obj pointer to an object\n * @return true: advanced hit-testing is enabled\n */\nbool lv_obj_get_adv_hittest(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return obj->adv_hittest == 0 ? false : true;\n}\n\n/**\n * Get the click enable attribute of an object\n * @param obj pointer to an object\n * @return true: the object is clickable\n */\nbool lv_obj_get_click(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return obj->click == 0 ? false : true;\n}\n\n/**\n * Get the top enable attribute of an object\n * @param obj pointer to an object\n * @return true: the auto top feature is enabled\n */\nbool lv_obj_get_top(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return obj->top == 0 ? false : true;\n}\n\n/**\n * Get the drag enable attribute of an object\n * @param obj pointer to an object\n * @return true: the object is draggable\n */\nbool lv_obj_get_drag(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return obj->drag == 0 ? false : true;\n}\n\n/**\n * Get the directions an object can be dragged\n * @param obj pointer to an object\n * @return bitwise OR of allowed directions an object can be dragged in\n */\nlv_drag_dir_t lv_obj_get_drag_dir(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return obj->drag_dir;\n}\n\n/**\n * Get the drag throw enable attribute of an object\n * @param obj pointer to an object\n * @return true: drag throw is enabled\n */\nbool lv_obj_get_drag_throw(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return obj->drag_throw == 0 ? false : true;\n}\n\n/**\n * Get the drag parent attribute of an object\n * @param obj pointer to an object\n * @return true: drag parent is enabled\n */\nbool lv_obj_get_drag_parent(const lv_obj_t * obj)\n{\n    return obj->drag_parent == 0 ? false : true;\n}\n\n/**\n* Get the gesture parent attribute of an object\n* @param obj pointer to an object\n* @return true: gesture parent is enabled\n*/\nbool lv_obj_get_gesture_parent(const lv_obj_t * obj)\n{\n    return obj->gesture_parent == 0 ? false : true;\n}\n\n/**\n* Get the focus parent attribute of an object\n* @param obj pointer to an object\n* @return true: focus parent is enabled\n*/\nbool lv_obj_get_focus_parent(const lv_obj_t * obj)\n{\n    return obj->focus_parent == 0 ? false : true;\n}\n\n/**\n * Get the drag parent attribute of an object\n * @param obj pointer to an object\n * @return true: drag parent is enabled\n */\nbool lv_obj_get_parent_event(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return obj->parent_event == 0 ? false : true;\n}\n\nlv_bidi_dir_t lv_obj_get_base_dir(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_BIDI\n    const lv_obj_t * parent = obj;\n\n    while(parent) {\n        if(parent->base_dir != LV_BIDI_DIR_INHERIT) return parent->base_dir;\n\n        parent = lv_obj_get_parent(parent);\n    }\n\n    return LV_BIDI_BASE_DIR_DEF;\n#else\n    (void) obj;  /*Unused*/\n    return LV_BIDI_DIR_LTR;\n#endif\n}\n\n/**\n * Get the protect field of an object\n * @param obj pointer to an object\n * @return protect field ('OR'ed values of `lv_protect_t`)\n */\nuint8_t lv_obj_get_protect(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return obj->protect;\n}\n\n/**\n * Check at least one bit of a given protect bitfield is set\n * @param obj pointer to an object\n * @param prot protect bits to test ('OR'ed values of `lv_protect_t`)\n * @return false: none of the given bits are set, true: at least one bit is set\n */\nbool lv_obj_is_protected(const lv_obj_t * obj, uint8_t prot)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return (obj->protect & prot) == 0 ? false : true;\n}\n\nlv_state_t lv_obj_get_state(const lv_obj_t * obj, uint8_t part)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    if(part < _LV_OBJ_PART_REAL_LAST) return ((lv_obj_t *)obj)->state;\n\n    /*If a real part is asked, then use the object's signal to get its state.\n     * A real object can be in different state then the main part\n     * and only the object itself knows who to get it's state. */\n    lv_get_state_info_t info;\n    info.part = part;\n    info.result = LV_STATE_DEFAULT;\n    lv_signal_send((lv_obj_t *)obj, LV_SIGNAL_GET_STATE_DSC, &info);\n\n    return info.result;\n\n}\n\n/**\n * Get the signal function of an object\n * @param obj pointer to an object\n * @return the signal function\n */\nlv_signal_cb_t lv_obj_get_signal_cb(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return obj->signal_cb;\n}\n\n/**\n * Get the design function of an object\n * @param obj pointer to an object\n * @return the design function\n */\nlv_design_cb_t lv_obj_get_design_cb(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return obj->design_cb;\n}\n\n/**\n * Get the event function of an object\n * @param obj pointer to an object\n * @return the event function\n */\nlv_event_cb_t lv_obj_get_event_cb(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return obj->event_cb;\n}\n\n/*------------------\n * Other get\n *-----------------*/\n\n/**\n * Get the ext pointer\n * @param obj pointer to an object\n * @return the ext pointer but not the dynamic version\n *         Use it as ext->data1, and NOT da(ext)->data1\n */\nvoid * lv_obj_get_ext_attr(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return obj->ext_attr;\n}\n\n/**\n * Get object's and its ancestors type. Put their name in `type_buf` starting with the current type.\n * E.g. buf.type[0]=\"lv_btn\", buf.type[1]=\"lv_cont\", buf.type[2]=\"lv_obj\"\n * @param obj pointer to an object which type should be get\n * @param buf pointer to an `lv_obj_type_t` buffer to store the types\n */\nvoid lv_obj_get_type(const lv_obj_t * obj, lv_obj_type_t * buf)\n{\n    LV_ASSERT_NULL(buf);\n    LV_ASSERT_NULL(obj);\n\n    lv_obj_type_t tmp;\n\n    _lv_memset_00(buf, sizeof(lv_obj_type_t));\n    _lv_memset_00(&tmp, sizeof(lv_obj_type_t));\n\n    obj->signal_cb((lv_obj_t *)obj, LV_SIGNAL_GET_TYPE, &tmp);\n\n    uint8_t cnt;\n    for(cnt = 0; cnt < LV_MAX_ANCESTOR_NUM; cnt++) {\n        if(tmp.type[cnt] == NULL) break;\n    }\n\n    /*Swap the order. The real type comes first*/\n    uint8_t i;\n    for(i = 0; i < cnt; i++) {\n        buf->type[i] = tmp.type[cnt - 1 - i];\n    }\n}\n\n#if LV_USE_USER_DATA\n\n/**\n * Get the object's user data\n * @param obj pointer to an object\n * @return user data\n */\nlv_obj_user_data_t lv_obj_get_user_data(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return obj->user_data;\n}\n\n/**\n * Get a pointer to the object's user data\n * @param obj pointer to an object\n * @return pointer to the user data\n */\nlv_obj_user_data_t * lv_obj_get_user_data_ptr(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return (lv_obj_user_data_t *)&obj->user_data;\n}\n\n/**\n * Set the object's user data. The data will be copied.\n * @param obj pointer to an object\n * @param data user data\n */\nvoid lv_obj_set_user_data(lv_obj_t * obj, lv_obj_user_data_t data)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    _lv_memcpy(&obj->user_data, &data, sizeof(lv_obj_user_data_t));\n}\n#endif\n\n/**\n * Get the group of the object\n * @param obj pointer to an object\n * @return the pointer to group of the object\n */\nvoid * lv_obj_get_group(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_GROUP\n    return obj->group_p;\n#else\n    LV_UNUSED(obj);\n    return NULL;\n#endif\n}\n\n/**\n * Tell whether the object is the focused object of a group or not.\n * @param obj pointer to an object\n * @return true: the object is focused, false: the object is not focused or not in a group\n */\nbool lv_obj_is_focused(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_GROUP\n    if(obj->group_p) {\n        if(lv_group_get_focused(obj->group_p) == obj) return true;\n    }\n    return false;\n#else\n    LV_UNUSED(obj);\n    return false;\n#endif\n}\n\n/*-------------------\n * OTHER FUNCTIONS\n *------------------*/\n\n/**\n * Check if a given screen-space point is on an object's coordinates.\n *\n * This method is intended to be used mainly by advanced hit testing algorithms to check\n * whether the point is even within the object (as an optimization).\n * @param obj object to check\n * @param point screen-space point\n */\nbool lv_obj_is_point_on_coords(lv_obj_t * obj, const lv_point_t * point)\n{\n#if LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_TINY\n    lv_area_t ext_area;\n    ext_area.x1 = obj->coords.x1 - obj->ext_click_pad_hor;\n    ext_area.x2 = obj->coords.x2 + obj->ext_click_pad_hor;\n    ext_area.y1 = obj->coords.y1 - obj->ext_click_pad_ver;\n    ext_area.y2 = obj->coords.y2 + obj->ext_click_pad_ver;\n\n    if(!_lv_area_is_point_on(&ext_area, point, 0)) {\n#elif LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_FULL\n    lv_area_t ext_area;\n    ext_area.x1 = obj->coords.x1 - obj->ext_click_pad.x1;\n    ext_area.x2 = obj->coords.x2 + obj->ext_click_pad.x2;\n    ext_area.y1 = obj->coords.y1 - obj->ext_click_pad.y1;\n    ext_area.y2 = obj->coords.y2 + obj->ext_click_pad.y2;\n\n    if(!_lv_area_is_point_on(&ext_area, point, 0)) {\n#else\n    if(!_lv_area_is_point_on(&obj->coords, point, 0)) {\n#endif\n        return false;\n    }\n    return true;\n}\n\n/**\n * Hit-test an object given a particular point in screen space.\n * @param obj object to hit-test\n * @param point screen-space point\n * @return true if the object is considered under the point\n */\nbool lv_obj_hittest(lv_obj_t * obj, lv_point_t * point)\n{\n    if(obj->adv_hittest) {\n        lv_hit_test_info_t hit_info;\n        hit_info.point = point;\n        hit_info.result = true;\n        obj->signal_cb(obj, LV_SIGNAL_HIT_TEST, &hit_info);\n        return hit_info.result;\n    }\n    else\n        return lv_obj_is_point_on_coords(obj, point);\n}\n\n/**\n * Used in the signal callback to handle `LV_SIGNAL_GET_TYPE` signal\n * @param obj pointer to an object\n * @param buf pointer to `lv_obj_type_t`. (`param` in the signal callback)\n * @param name name of the object. E.g. \"lv_btn\". (Only the pointer is saved)\n * @return LV_RES_OK\n */\nlv_res_t lv_obj_handle_get_type_signal(lv_obj_type_t * buf, const char * name)\n{\n    uint8_t i;\n    for(i = 0; i < LV_MAX_ANCESTOR_NUM - 1; i++) { /*Find the last set data*/\n        if(buf->type[i] == NULL) break;\n    }\n    buf->type[i] = name;\n\n    return LV_RES_OK;\n}\n\n/**\n * Initialize a rectangle descriptor from an object's styles\n * @param obj pointer to an object\n * @param type type of style. E.g.  `LV_OBJ_PART_MAIN`, `LV_BTN_STYLE_REL` or `LV_PAGE_STYLE_SCRL`\n * @param draw_dsc the descriptor the initialize\n * @note Only the relevant fields will be set.\n * E.g. if `border width == 0` the other border properties won't be evaluated.\n */\nvoid lv_obj_init_draw_rect_dsc(lv_obj_t * obj, uint8_t part, lv_draw_rect_dsc_t * draw_dsc)\n{\n    draw_dsc->radius = lv_obj_get_style_radius(obj, part);\n\n#if LV_USE_OPA_SCALE\n    lv_opa_t opa_scale = lv_obj_get_style_opa_scale(obj, part);\n    if(opa_scale <= LV_OPA_MIN) {\n        draw_dsc->bg_opa = LV_OPA_TRANSP;\n        draw_dsc->border_opa = LV_OPA_TRANSP;\n        draw_dsc->shadow_opa = LV_OPA_TRANSP;\n        draw_dsc->pattern_opa = LV_OPA_TRANSP;\n        draw_dsc->value_opa = LV_OPA_TRANSP;\n        return;\n    }\n#endif\n\n    if(draw_dsc->bg_opa != LV_OPA_TRANSP) {\n        draw_dsc->bg_opa = lv_obj_get_style_bg_opa(obj, part);\n        if(draw_dsc->bg_opa > LV_OPA_MIN) {\n            draw_dsc->bg_color = lv_obj_get_style_bg_color(obj, part);\n            draw_dsc->bg_grad_dir =  lv_obj_get_style_bg_grad_dir(obj, part);\n            if(draw_dsc->bg_grad_dir != LV_GRAD_DIR_NONE) {\n                draw_dsc->bg_grad_color = lv_obj_get_style_bg_grad_color(obj, part);\n                draw_dsc->bg_main_color_stop =  lv_obj_get_style_bg_main_stop(obj, part);\n                draw_dsc->bg_grad_color_stop =  lv_obj_get_style_bg_grad_stop(obj, part);\n            }\n\n#if LV_USE_BLEND_MODES\n            draw_dsc->bg_blend_mode = lv_obj_get_style_bg_blend_mode(obj, part);\n#endif\n        }\n    }\n\n    draw_dsc->border_width = lv_obj_get_style_border_width(obj, part);\n    if(draw_dsc->border_width) {\n        if(draw_dsc->border_opa != LV_OPA_TRANSP) {\n            draw_dsc->border_opa = lv_obj_get_style_border_opa(obj, part);\n            if(draw_dsc->border_opa > LV_OPA_MIN) {\n                draw_dsc->border_side = lv_obj_get_style_border_side(obj, part);\n                draw_dsc->border_color = lv_obj_get_style_border_color(obj, part);\n            }\n#if LV_USE_BLEND_MODES\n            draw_dsc->border_blend_mode = lv_obj_get_style_border_blend_mode(obj, part);\n#endif\n        }\n    }\n\n#if LV_USE_OUTLINE\n    draw_dsc->outline_width = lv_obj_get_style_outline_width(obj, part);\n    if(draw_dsc->outline_width) {\n        if(draw_dsc->outline_opa != LV_OPA_TRANSP) {\n            draw_dsc->outline_opa = lv_obj_get_style_outline_opa(obj, part);\n            if(draw_dsc->outline_opa > LV_OPA_MIN) {\n                draw_dsc->outline_pad = lv_obj_get_style_outline_pad(obj, part);\n                draw_dsc->outline_color = lv_obj_get_style_outline_color(obj, part);\n            }\n#if LV_USE_BLEND_MODES\n            draw_dsc->outline_blend_mode = lv_obj_get_style_outline_blend_mode(obj, part);\n#endif\n        }\n    }\n#endif\n\n#if LV_USE_PATTERN\n    draw_dsc->pattern_image = lv_obj_get_style_pattern_image(obj, part);\n    if(draw_dsc->pattern_image) {\n        if(draw_dsc->pattern_opa != LV_OPA_TRANSP) {\n            draw_dsc->pattern_opa = lv_obj_get_style_pattern_opa(obj, part);\n            if(draw_dsc->pattern_opa > LV_OPA_MIN) {\n                draw_dsc->pattern_recolor_opa = lv_obj_get_style_pattern_recolor_opa(obj, part);\n                draw_dsc->pattern_repeat = lv_obj_get_style_pattern_repeat(obj, part);\n                if(lv_img_src_get_type(draw_dsc->pattern_image) == LV_IMG_SRC_SYMBOL) {\n                    draw_dsc->pattern_recolor = lv_obj_get_style_pattern_recolor(obj, part);\n                    draw_dsc->pattern_font = lv_obj_get_style_text_font(obj, part);\n                }\n                else if(draw_dsc->pattern_recolor_opa > LV_OPA_MIN) {\n                    draw_dsc->pattern_recolor = lv_obj_get_style_pattern_recolor(obj, part);\n                }\n#if LV_USE_BLEND_MODES\n                draw_dsc->pattern_blend_mode = lv_obj_get_style_pattern_blend_mode(obj, part);\n#endif\n            }\n        }\n    }\n#endif\n\n#if LV_USE_SHADOW\n    draw_dsc->shadow_width = lv_obj_get_style_shadow_width(obj, part);\n    if(draw_dsc->shadow_width) {\n        if(draw_dsc->shadow_opa > LV_OPA_MIN) {\n            draw_dsc->shadow_opa = lv_obj_get_style_shadow_opa(obj, part);\n            if(draw_dsc->shadow_opa > LV_OPA_MIN) {\n                draw_dsc->shadow_ofs_x = lv_obj_get_style_shadow_ofs_x(obj, part);\n                draw_dsc->shadow_ofs_y = lv_obj_get_style_shadow_ofs_y(obj, part);\n                draw_dsc->shadow_spread = lv_obj_get_style_shadow_spread(obj, part);\n                draw_dsc->shadow_color = lv_obj_get_style_shadow_color(obj, part);\n#if LV_USE_BLEND_MODES\n                draw_dsc->shadow_blend_mode = lv_obj_get_style_shadow_blend_mode(obj, part);\n#endif\n            }\n        }\n    }\n#endif\n\n#if LV_USE_VALUE_STR\n    draw_dsc->value_str = lv_obj_get_style_value_str(obj, part);\n    if(draw_dsc->value_str) {\n        if(draw_dsc->value_opa > LV_OPA_MIN) {\n            draw_dsc->value_opa = lv_obj_get_style_value_opa(obj, part);\n            if(draw_dsc->value_opa > LV_OPA_MIN) {\n                draw_dsc->value_ofs_x = lv_obj_get_style_value_ofs_x(obj, part);\n                draw_dsc->value_ofs_y = lv_obj_get_style_value_ofs_y(obj, part);\n                draw_dsc->value_color = lv_obj_get_style_value_color(obj, part);\n                draw_dsc->value_font = lv_obj_get_style_value_font(obj, part);\n                draw_dsc->value_letter_space = lv_obj_get_style_value_letter_space(obj, part);\n                draw_dsc->value_line_space = lv_obj_get_style_value_line_space(obj, part);\n                draw_dsc->value_align = lv_obj_get_style_value_align(obj, part);\n#if LV_USE_BLEND_MODES\n                draw_dsc->value_blend_mode = lv_obj_get_style_value_blend_mode(obj, part);\n#endif\n            }\n        }\n    }\n#endif\n\n#if LV_USE_OPA_SCALE\n    if(opa_scale < LV_OPA_MAX) {\n        draw_dsc->bg_opa = (uint16_t)((uint16_t)draw_dsc->bg_opa * opa_scale) >> 8;\n        draw_dsc->border_opa = (uint16_t)((uint16_t)draw_dsc->border_opa * opa_scale) >> 8;\n        draw_dsc->shadow_opa = (uint16_t)((uint16_t)draw_dsc->shadow_opa * opa_scale) >> 8;\n        draw_dsc->pattern_opa = (uint16_t)((uint16_t)draw_dsc->pattern_opa * opa_scale) >> 8;\n        draw_dsc->value_opa = (uint16_t)((uint16_t)draw_dsc->value_opa * opa_scale) >> 8;\n    }\n#endif\n}\n\nvoid lv_obj_init_draw_label_dsc(lv_obj_t * obj, uint8_t part, lv_draw_label_dsc_t * draw_dsc)\n{\n    draw_dsc->opa = lv_obj_get_style_text_opa(obj, part);\n    if(draw_dsc->opa <= LV_OPA_MIN) return;\n\n#if LV_USE_OPA_SCALE\n    lv_opa_t opa_scale = lv_obj_get_style_opa_scale(obj, part);\n    if(opa_scale < LV_OPA_MAX) {\n        draw_dsc->opa = (uint16_t)((uint16_t)draw_dsc->opa * opa_scale) >> 8;\n    }\n    if(draw_dsc->opa <= LV_OPA_MIN) return;\n#endif\n\n    draw_dsc->color = lv_obj_get_style_text_color(obj, part);\n    draw_dsc->letter_space = lv_obj_get_style_text_letter_space(obj, part);\n    draw_dsc->line_space = lv_obj_get_style_text_line_space(obj, part);\n    draw_dsc->decor = lv_obj_get_style_text_decor(obj, part);\n#if LV_USE_BLEND_MODES\n    draw_dsc->blend_mode = lv_obj_get_style_text_blend_mode(obj, part);\n#endif\n\n    draw_dsc->font = lv_obj_get_style_text_font(obj, part);\n\n    if(draw_dsc->sel_start != LV_DRAW_LABEL_NO_TXT_SEL && draw_dsc->sel_end != LV_DRAW_LABEL_NO_TXT_SEL) {\n        draw_dsc->sel_color = lv_obj_get_style_text_sel_color(obj, part);\n        draw_dsc->sel_bg_color = lv_obj_get_style_text_sel_bg_color(obj, part);\n    }\n\n#if LV_USE_BIDI\n    draw_dsc->bidi_dir = lv_obj_get_base_dir(obj);\n#endif\n}\n\nvoid lv_obj_init_draw_img_dsc(lv_obj_t * obj, uint8_t part, lv_draw_img_dsc_t * draw_dsc)\n{\n    draw_dsc->opa = lv_obj_get_style_image_opa(obj, part);\n    if(draw_dsc->opa <= LV_OPA_MIN)  return;\n\n#if LV_USE_OPA_SCALE\n    lv_opa_t opa_scale = lv_obj_get_style_opa_scale(obj, part);\n    if(opa_scale < LV_OPA_MAX) {\n        draw_dsc->opa = (uint16_t)((uint16_t)draw_dsc->opa * opa_scale) >> 8;\n    }\n    if(draw_dsc->opa <= LV_OPA_MIN)  return;\n#endif\n\n    draw_dsc->angle = 0;\n    draw_dsc->zoom = LV_IMG_ZOOM_NONE;\n    draw_dsc->pivot.x = lv_area_get_width(&obj->coords) / 2;\n    draw_dsc->pivot.y = lv_area_get_height(&obj->coords) / 2;\n\n    draw_dsc->recolor_opa = lv_obj_get_style_image_recolor_opa(obj, part);\n    if(draw_dsc->recolor_opa > 0) {\n        draw_dsc->recolor = lv_obj_get_style_image_recolor(obj, part);\n    }\n#if LV_USE_BLEND_MODES\n    draw_dsc->blend_mode = lv_obj_get_style_image_blend_mode(obj, part);\n#endif\n}\n\nvoid lv_obj_init_draw_line_dsc(lv_obj_t * obj, uint8_t part, lv_draw_line_dsc_t * draw_dsc)\n{\n    draw_dsc->width = lv_obj_get_style_line_width(obj, part);\n    if(draw_dsc->width == 0) return;\n\n    draw_dsc->opa = lv_obj_get_style_line_opa(obj, part);\n    if(draw_dsc->opa <= LV_OPA_MIN)  return;\n\n#if LV_USE_OPA_SCALE\n    lv_opa_t opa_scale = lv_obj_get_style_opa_scale(obj, part);\n    if(opa_scale < LV_OPA_MAX) {\n        draw_dsc->opa = (uint16_t)((uint16_t)draw_dsc->opa * opa_scale) >> 8;\n    }\n    if(draw_dsc->opa <= LV_OPA_MIN)  return;\n#endif\n\n    draw_dsc->color = lv_obj_get_style_line_color(obj, part);\n\n    draw_dsc->dash_width = lv_obj_get_style_line_dash_width(obj, part);\n    if(draw_dsc->dash_width) {\n        draw_dsc->dash_gap = lv_obj_get_style_line_dash_gap(obj, part);\n    }\n\n    draw_dsc->round_start = lv_obj_get_style_line_rounded(obj, part);\n    draw_dsc->round_end = draw_dsc->round_start;\n\n#if LV_USE_BLEND_MODES\n    draw_dsc->blend_mode = lv_obj_get_style_line_blend_mode(obj, part);\n#endif\n}\n\n/**\n * Get the required extra size (around the object's part) to draw shadow, outline, value etc.\n * @param obj pointer to an object\n * @param part part of the object\n */\nlv_coord_t lv_obj_get_draw_rect_ext_pad_size(lv_obj_t * obj, uint8_t part)",
        "b_contents": "lv_obj_t * lv_obj_get_focused_obj(const lv_obj_t * obj)",
        "base_contents": "/**\n * Set the x coordinate of a object\n * @param obj pointer to an object\n * @param x new distance from the left side from the parent\n */\nvoid lv_obj_set_x(lv_obj_t * obj, lv_coord_t x)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_obj_set_pos(obj, x, lv_obj_get_y(obj));\n}\n\n/**\n * Set the y coordinate of a object\n * @param obj pointer to an object\n * @param y new distance from the top of the parent\n */\nvoid lv_obj_set_y(lv_obj_t * obj, lv_coord_t y)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_obj_set_pos(obj, lv_obj_get_x(obj), y);\n}\n\n/**\n * Set the size of an object\n * @param obj pointer to an object\n * @param w new width\n * @param h new height\n */\nvoid lv_obj_set_size(lv_obj_t * obj, lv_coord_t w, lv_coord_t h)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    /* Do nothing if the size is not changed */\n    /* It is very important else recursive resizing can\n     * occur without size change*/\n    if(lv_obj_get_width(obj) == w && lv_obj_get_height(obj) == h) {\n        return;\n    }\n\n    /*Invalidate the original area*/\n    lv_obj_invalidate(obj);\n\n    /*Save the original coordinates*/\n    lv_area_t ori;\n    lv_obj_get_coords(obj, &ori);\n\n    /*Set the length and height*/\n    obj->coords.y2 = obj->coords.y1 + h - 1;\n    if(lv_obj_get_base_dir(obj) == LV_BIDI_DIR_RTL) {\n        obj->coords.x1 = obj->coords.x2 - w + 1;\n    }\n    else {\n        obj->coords.x2 = obj->coords.x1 + w - 1;\n    }\n\n    /*Send a signal to the object with its new coordinates*/\n    obj->signal_cb(obj, LV_SIGNAL_COORD_CHG, &ori);\n\n    /*Send a signal to the parent too*/\n    lv_obj_t * par = lv_obj_get_parent(obj);\n    if(par != NULL) par->signal_cb(par, LV_SIGNAL_CHILD_CHG, obj);\n\n    /*Tell the children the parent's size has changed*/\n    lv_obj_t * i;\n    _LV_LL_READ(obj->child_ll, i) {\n        i->signal_cb(i, LV_SIGNAL_PARENT_SIZE_CHG,  &ori);\n    }\n\n    /*Invalidate the new area*/\n    lv_obj_invalidate(obj);\n\n    /*Automatically realign the object if required*/\n#if LV_USE_OBJ_REALIGN\n    if(obj->realign.auto_realign) lv_obj_realign(obj);\n#endif\n}\n\n/**\n * Set the width of an object\n * @param obj pointer to an object\n * @param w new width\n */\nvoid lv_obj_set_width(lv_obj_t * obj, lv_coord_t w)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_obj_set_size(obj, w, lv_obj_get_height(obj));\n}\n\n/**\n * Set the height of an object\n * @param obj pointer to an object\n * @param h new height\n */\nvoid lv_obj_set_height(lv_obj_t * obj, lv_coord_t h)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_obj_set_size(obj, lv_obj_get_width(obj), h);\n}\n\n/**\n * Set the width reduced by the left and right padding.\n * @param obj pointer to an object\n * @param w the width without paddings\n */\nvoid lv_obj_set_width_fit(lv_obj_t * obj, lv_coord_t w)\n{\n    lv_style_int_t pleft = lv_obj_get_style_pad_left(obj, LV_OBJ_PART_MAIN);\n    lv_style_int_t pright = lv_obj_get_style_pad_right(obj, LV_OBJ_PART_MAIN);\n\n    lv_obj_set_width(obj, w - pleft - pright);\n}\n\n/**\n * Set the height reduced by the top and bottom padding.\n * @param obj pointer to an object\n * @param h the height without paddings\n */\nvoid lv_obj_set_height_fit(lv_obj_t * obj, lv_coord_t h)\n{\n    lv_style_int_t ptop = lv_obj_get_style_pad_top(obj, LV_OBJ_PART_MAIN);\n    lv_style_int_t pbottom = lv_obj_get_style_pad_bottom(obj, LV_OBJ_PART_MAIN);\n\n    lv_obj_set_height(obj, h - ptop - pbottom);\n}\n\n/**\n * Set the width of an object by taking the left and right margin into account.\n * The object width will be `obj_w = w - margin_left - margin_right`\n * @param obj pointer to an object\n * @param w new height including margins\n */\nvoid lv_obj_set_width_margin(lv_obj_t * obj, lv_coord_t w)\n{\n    lv_style_int_t mleft = lv_obj_get_style_margin_left(obj, LV_OBJ_PART_MAIN);\n    lv_style_int_t mright = lv_obj_get_style_margin_right(obj, LV_OBJ_PART_MAIN);\n\n    lv_obj_set_width(obj, w - mleft - mright);\n}\n\n/**\n * Set the height of an object by taking the top and bottom margin into account.\n * The object height will be `obj_h = h - margin_top - margin_bottom`\n * @param obj pointer to an object\n * @param h new height including margins\n */\nvoid lv_obj_set_height_margin(lv_obj_t * obj, lv_coord_t h)\n{\n    lv_style_int_t mtop = lv_obj_get_style_margin_top(obj, LV_OBJ_PART_MAIN);\n    lv_style_int_t mbottom = lv_obj_get_style_margin_bottom(obj, LV_OBJ_PART_MAIN);\n\n    lv_obj_set_height(obj, h - mtop - mbottom);\n}\n\n/**\n * Align an object to an other object.\n * @param obj pointer to an object to align\n * @param base pointer to an object (if NULL the parent is used). 'obj' will be aligned to it.\n * @param align type of alignment (see 'lv_align_t' enum)\n * @param x_ofs x coordinate offset after alignment\n * @param y_ofs y coordinate offset after alignment\n */\nvoid lv_obj_align(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t x_ofs, lv_coord_t y_ofs)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    if(base == NULL) base = lv_obj_get_parent(obj);\n\n    LV_ASSERT_OBJ(base, LV_OBJX_NAME);\n\n    obj_align_core(obj, base, align, true, true, x_ofs, y_ofs);\n\n#if LV_USE_OBJ_REALIGN\n    /*Save the last align parameters to use them in `lv_obj_realign`*/\n    obj->realign.align       = align;\n    obj->realign.xofs        = x_ofs;\n    obj->realign.yofs        = y_ofs;\n    obj->realign.base        = base;\n    obj->realign.mid_align = 0;\n#endif\n}\n\n/**\n * Align an object to an other object horizontally.\n * @param obj pointer to an object to align\n * @param base pointer to an object (if NULL the parent is used). 'obj' will be aligned to it.\n * @param align type of alignment (see 'lv_align_t' enum)\n * @param x_ofs x coordinate offset after alignment\n */\nvoid lv_obj_align_x(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t x_ofs)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    if(base == NULL) base = lv_obj_get_parent(obj);\n\n    LV_ASSERT_OBJ(base, LV_OBJX_NAME);\n\n    obj_align_core(obj, base, align, true, false, x_ofs, 0);\n}\n\n/**\n * Align an object to an other object vertically.\n * @param obj pointer to an object to align\n * @param base pointer to an object (if NULL the parent is used). 'obj' will be aligned to it.\n * @param align type of alignment (see 'lv_align_t' enum)\n * @param y_ofs y coordinate offset after alignment\n */\nvoid lv_obj_align_y(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t y_ofs)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    if(base == NULL) base = lv_obj_get_parent(obj);\n\n    LV_ASSERT_OBJ(base, LV_OBJX_NAME);\n\n    obj_align_core(obj, base, align, false, true, 0, y_ofs);\n}\n\n/**\n * Align an object's middle point to an other object.\n * @param obj pointer to an object to align\n * @param base pointer to an object (if NULL the parent is used). 'obj' will be aligned to it.\n * @param align type of alignment (see 'lv_align_t' enum)\n * @param x_ofs x coordinate offset after alignment\n * @param y_ofs y coordinate offset after alignment\n */\nvoid lv_obj_align_mid(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t x_ofs, lv_coord_t y_ofs)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    if(base == NULL) {\n        base = lv_obj_get_parent(obj);\n    }\n\n    LV_ASSERT_OBJ(base, LV_OBJX_NAME);\n\n    obj_align_mid_core(obj, base, align, true, true, x_ofs, y_ofs);\n\n#if LV_USE_OBJ_REALIGN\n    /*Save the last align parameters to use them in `lv_obj_realign`*/\n    obj->realign.align       = align;\n    obj->realign.xofs        = x_ofs;\n    obj->realign.yofs        = y_ofs;\n    obj->realign.base        = base;\n    obj->realign.mid_align = 1;\n#endif\n}\n\n/**\n * Align an object's middle point to an other object horizontally.\n * @param obj pointer to an object to align\n * @param base pointer to an object (if NULL the parent is used). 'obj' will be aligned to it.\n * @param align type of alignment (see 'lv_align_t' enum)\n * @param x_ofs x coordinate offset after alignment\n */\nvoid lv_obj_align_mid_x(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t x_ofs)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    if(base == NULL) {\n        base = lv_obj_get_parent(obj);\n    }\n\n    LV_ASSERT_OBJ(base, LV_OBJX_NAME);\n\n    obj_align_mid_core(obj, base, align, true, false, x_ofs, 0);\n}\n\n/**\n * Align an object's middle point to an other object vertically.\n * @param obj pointer to an object to align\n * @param base pointer to an object (if NULL the parent is used). 'obj' will be aligned to it.\n * @param align type of alignment (see 'lv_align_t' enum)\n * @param y_ofs y coordinate offset after alignment\n */\nvoid lv_obj_align_mid_y(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t y_ofs)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    if(base == NULL) {\n        base = lv_obj_get_parent(obj);\n    }\n\n    LV_ASSERT_OBJ(base, LV_OBJX_NAME);\n\n    obj_align_mid_core(obj, base, align, false, true, 0, y_ofs);\n}\n\n/**\n * Realign the object based on the last `lv_obj_align` parameters.\n * @param obj pointer to an object\n */\nvoid lv_obj_realign(lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_OBJ_REALIGN\n    if(obj->realign.mid_align)\n        lv_obj_align_mid(obj, obj->realign.base, obj->realign.align, obj->realign.xofs, obj->realign.yofs);\n    else\n        lv_obj_align(obj, obj->realign.base, obj->realign.align, obj->realign.xofs, obj->realign.yofs);\n#else\n    (void)obj;\n    LV_LOG_WARN(\"lv_obj_realign: no effect because LV_USE_OBJ_REALIGN = 0\");\n#endif\n}\n\n/**\n * Enable the automatic realign of the object when its size has changed based on the last\n * `lv_obj_align` parameters.\n * @param obj pointer to an object\n * @param en true: enable auto realign; false: disable auto realign\n */\nvoid lv_obj_set_auto_realign(lv_obj_t * obj, bool en)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_OBJ_REALIGN\n    obj->realign.auto_realign = en ? 1 : 0;\n#else\n    (void)obj;\n    (void)en;\n    LV_LOG_WARN(\"lv_obj_set_auto_realign: no effect because LV_USE_OBJ_REALIGN = 0\");\n#endif\n}\n\n/**\n * Set the size of an extended clickable area\n * If TINY mode is used, only the largest of the horizontal and vertical padding\n * values are considered.\n * @param obj pointer to an object\n * @param left extended clickable are on the left [px]\n * @param right extended clickable are on the right [px]\n * @param top extended clickable are on the top [px]\n * @param bottom extended clickable are on the bottom [px]\n */\nvoid lv_obj_set_ext_click_area(lv_obj_t * obj, lv_coord_t left, lv_coord_t right, lv_coord_t top, lv_coord_t bottom)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_FULL\n    obj->ext_click_pad.x1 = left;\n    obj->ext_click_pad.x2 = right;\n    obj->ext_click_pad.y1 = top;\n    obj->ext_click_pad.y2 = bottom;\n#elif LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_TINY\n    obj->ext_click_pad_hor = LV_MATH_MAX(left, right);\n    obj->ext_click_pad_ver = LV_MATH_MAX(top, bottom);\n#else\n    (void)obj;    /*Unused*/\n    (void)left;   /*Unused*/\n    (void)right;  /*Unused*/\n    (void)top;    /*Unused*/\n    (void)bottom; /*Unused*/\n#endif\n}\n\n/*---------------------\n * Appearance set\n *--------------------*/\n\n/**\n * Add a new style to the style list of an object.\n * @param obj pointer to an object\n * @param part the part of the object which style property should be set.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param style pointer to a style to add (Only its pointer will be saved)\n */\nvoid lv_obj_add_style(lv_obj_t * obj, uint8_t part, lv_style_t * style)\n{\n    if(style == NULL) return;\n\n    lv_style_list_t * style_dsc = lv_obj_get_style_list(obj, part);\n    if(style_dsc == NULL) {\n        LV_LOG_WARN(\"Can't find style with part: %d\", part);\n        return;\n    }\n\n    _lv_style_list_add_style(style_dsc, style);\n#if LV_USE_ANIMATION\n    trans_del(obj, part, 0xFF, NULL);\n#endif\n    lv_obj_refresh_style(obj, part, LV_STYLE_PROP_ALL);\n}\n\n/**\n * Remove a style from the style list of an object.\n * @param obj pointer to an object\n * @param part the part of the object which style property should be set.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param style pointer to a style to remove\n */\nvoid lv_obj_remove_style(lv_obj_t * obj, uint8_t part, lv_style_t * style)\n{\n    if(style == NULL) return;\n\n    lv_style_list_t * style_dsc = lv_obj_get_style_list(obj, part);\n    if(style_dsc == NULL) {\n        LV_LOG_WARN(\"Can't find style with part: %d\", part);\n        return;\n    }\n\n    _lv_style_list_remove_style(style_dsc, style);\n#if LV_USE_ANIMATION\n    trans_del(obj, part, 0xFF, NULL);\n#endif\n    lv_obj_refresh_style(obj, part, LV_STYLE_PROP_ALL);\n}\n\n/**\n * Reset a style to the default (empty) state.\n * Release all used memories and cancel pending related transitions.\n * Typically used in `LV_SIGN_CLEAN_UP.\n * @param obj pointer to an object\n * @param part the part of the object which style list should be reset.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n */\nvoid lv_obj_clean_style_list(lv_obj_t * obj, uint8_t part)\n{\n    lv_style_list_t * style_dsc = lv_obj_get_style_list(obj, part);\n    if(style_dsc == NULL) {\n        LV_LOG_WARN(\"lv_obj_clean_style_list: can't find style with `part`\");\n        return;\n    }\n\n    _lv_style_list_reset(style_dsc);\n#if LV_USE_ANIMATION\n    trans_del(obj, part, 0xFF, NULL);\n#endif\n}\n\n/**\n * Reset a style to the default (empty) state.\n * Release all used memories and cancel pending related transitions.\n * Also notifies the object about the style change.\n * @param obj pointer to an object\n * @param part the part of the object which style list should be reset.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n */\nvoid lv_obj_reset_style_list(lv_obj_t * obj, uint8_t part)\n{\n    lv_obj_clean_style_list(obj, part);\n\n    lv_obj_refresh_style(obj, part, LV_STYLE_PROP_ALL);\n}\n\n/**\n * Set a local style property of a part of an object in a given state.\n * @param obj pointer to an object\n * @param part the part of the object which style property should be set.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_BORDER_WIDTH | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @param the value to set\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_opa()`\n * @note for performance reasons it's not checked if the property really has integer type\n */\nvoid _lv_obj_set_style_local_int(lv_obj_t * obj, uint8_t part, lv_style_property_t prop, lv_style_int_t value)\n{\n    lv_style_list_t * style_dsc = lv_obj_get_style_list(obj, part);\n    _lv_style_list_set_local_int(style_dsc, prop, value);\n#if LV_USE_ANIMATION\n    trans_del(obj, part, prop, NULL);\n#endif\n    lv_obj_refresh_style(obj, part, prop & (~LV_STYLE_STATE_MASK));\n}\n\n/**\n * Set a local style property of a part of an object in a given state.\n * @param obj pointer to an object\n * @param part the part of the object which style property should be set.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_BORDER_COLOR | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @param the value to set\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_opa()`\n * @note for performance reasons it's not checked if the property really has color type\n */\nvoid _lv_obj_set_style_local_color(lv_obj_t * obj, uint8_t part, lv_style_property_t prop, lv_color_t color)\n{\n    lv_style_list_t * style_dsc = lv_obj_get_style_list(obj, part);\n    _lv_style_list_set_local_color(style_dsc, prop, color);\n#if LV_USE_ANIMATION\n    trans_del(obj, part, prop, NULL);\n#endif\n    lv_obj_refresh_style(obj, part, prop & (~LV_STYLE_STATE_MASK));\n}\n\n/**\n * Set a local style property of a part of an object in a given state.\n * @param obj pointer to an object\n * @param part the part of the object which style property should be set.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_BORDER_OPA | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @param the value to set\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_opa()`\n * @note for performance reasons it's not checked if the property really has opacity type\n */\nvoid _lv_obj_set_style_local_opa(lv_obj_t * obj, uint8_t part, lv_style_property_t prop, lv_opa_t opa)\n{\n    lv_style_list_t * style_dsc = lv_obj_get_style_list(obj, part);\n    _lv_style_list_set_local_opa(style_dsc, prop, opa);\n#if LV_USE_ANIMATION\n    trans_del(obj, part, prop, NULL);\n#endif\n    lv_obj_refresh_style(obj, part, prop & (~LV_STYLE_STATE_MASK));\n}\n\n/**\n * Set a local style property of a part of an object in a given state.\n * @param obj pointer to an object\n * @param part the part of the object which style property should be set.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_TEXT_FONT | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @param value the value to set\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_opa()`\n * @note for performance reasons it's not checked if the property really has pointer type\n */\nvoid _lv_obj_set_style_local_ptr(lv_obj_t * obj, uint8_t part, lv_style_property_t prop, const void * value)\n{\n    lv_style_list_t * style_dsc = lv_obj_get_style_list(obj, part);\n    _lv_style_list_set_local_ptr(style_dsc, prop, value);\n#if LV_USE_ANIMATION\n    trans_del(obj, part, prop, NULL);\n#endif\n    lv_obj_refresh_style(obj, part, prop & (~LV_STYLE_STATE_MASK));\n}\n\n/**\n * Remove a local style property from a part of an object with a given state.\n * @param obj pointer to an object\n * @param part the part of the object which style property should be removed.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_TEXT_FONT | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @note shouldn't be used directly. Use the specific property remove functions instead.\n *       For example: `lv_obj_style_remove_border_opa()`\n * @return true: the property was found and removed; false: the property was not found\n */\nbool lv_obj_remove_style_local_prop(lv_obj_t * obj, uint8_t part, lv_style_property_t prop)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n    lv_style_t * style = lv_obj_get_local_style(obj, part);\n    if(style) return lv_style_remove_prop(style, prop);\n    else return false;\n}\n\n/**\n * Notify an object (and its children) about its style is modified\n * @param obj pointer to an object\n * @param part the part of the object which style property should be refreshed.\n * @param prop `LV_STYLE_PROP_ALL` or an `LV_STYLE_...` property. It is used to optimize what needs to be refreshed.\n */\nvoid lv_obj_refresh_style(lv_obj_t * obj, uint8_t part, lv_style_property_t prop)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    invalidate_style_cache(obj, part, prop);\n\n    /*If a real style refresh is required*/\n    bool real_refr = false;\n    switch(prop) {\n        case LV_STYLE_PROP_ALL:\n        case LV_STYLE_CLIP_CORNER:\n        case LV_STYLE_SIZE:\n        case LV_STYLE_TRANSFORM_WIDTH:\n        case LV_STYLE_TRANSFORM_HEIGHT:\n        case LV_STYLE_TRANSFORM_ANGLE:\n        case LV_STYLE_TRANSFORM_ZOOM:\n        case LV_STYLE_PAD_TOP:\n        case LV_STYLE_PAD_BOTTOM:\n        case LV_STYLE_PAD_LEFT:\n        case LV_STYLE_PAD_RIGHT:\n        case LV_STYLE_PAD_INNER:\n        case LV_STYLE_MARGIN_TOP:\n        case LV_STYLE_MARGIN_BOTTOM:\n        case LV_STYLE_MARGIN_LEFT:\n        case LV_STYLE_MARGIN_RIGHT:\n        case LV_STYLE_OUTLINE_WIDTH:\n        case LV_STYLE_OUTLINE_PAD:\n        case LV_STYLE_OUTLINE_OPA:\n        case LV_STYLE_SHADOW_WIDTH:\n        case LV_STYLE_SHADOW_OPA:\n        case LV_STYLE_SHADOW_OFS_X:\n        case LV_STYLE_SHADOW_OFS_Y:\n        case LV_STYLE_SHADOW_SPREAD:\n        case LV_STYLE_VALUE_LETTER_SPACE:\n        case LV_STYLE_VALUE_LINE_SPACE:\n        case LV_STYLE_VALUE_OFS_X:\n        case LV_STYLE_VALUE_OFS_Y:\n        case LV_STYLE_VALUE_ALIGN:\n        case LV_STYLE_VALUE_STR:\n        case LV_STYLE_VALUE_FONT:\n        case LV_STYLE_VALUE_OPA:\n        case LV_STYLE_TEXT_LETTER_SPACE:\n        case LV_STYLE_TEXT_LINE_SPACE:\n        case LV_STYLE_TEXT_FONT:\n        case LV_STYLE_LINE_WIDTH:\n            real_refr = true;\n            break;\n        default:\n            real_refr = false;\n    }\n\n    if(real_refr) {\n        lv_obj_invalidate(obj);\n        obj->signal_cb(obj, LV_SIGNAL_STYLE_CHG, NULL);\n\n        switch(prop) {\n            case LV_STYLE_PROP_ALL:\n            case LV_STYLE_MARGIN_TOP:\n            case LV_STYLE_MARGIN_BOTTOM:\n            case LV_STYLE_MARGIN_LEFT:\n            case LV_STYLE_MARGIN_RIGHT:\n                if(obj->parent) obj->parent->signal_cb(obj->parent, LV_SIGNAL_CHILD_CHG, NULL);\n                break;\n        }\n\n        lv_obj_invalidate(obj);\n\n        /*Send style change signals*/\n        if(prop == LV_STYLE_PROP_ALL || (prop & LV_STYLE_INHERIT_MASK)) refresh_children_style(obj);\n    }\n    else {\n        lv_obj_invalidate(obj);\n    }\n}\n\n/**\n * Notify all object if a style is modified\n * @param style pointer to a style. Only the objects with this style will be notified\n *               (NULL to notify all objects)\n */\nvoid lv_obj_report_style_mod(lv_style_t * style)\n{\n    lv_disp_t * d = lv_disp_get_next(NULL);\n\n    while(d) {\n        lv_obj_t * i;\n        _LV_LL_READ(d->scr_ll, i) {\n            report_style_mod_core(style, i);\n        }\n        d = lv_disp_get_next(d);\n    }\n}\n\n/**\n * Enable/disable the use of style cache for an object\n * @param obj pointer to an object\n * @param dis true: disable; false: enable (re-enable)\n */\nvoid _lv_obj_disable_style_caching(lv_obj_t * obj, bool dis)\n{\n    uint8_t part;\n    for(part = 0; part < _LV_OBJ_PART_REAL_FIRST; part++) {\n        lv_style_list_t * list = lv_obj_get_style_list(obj, part);\n        if(list == NULL) break;\n        list->ignore_cache = dis;\n    }\n    for(part = _LV_OBJ_PART_REAL_FIRST; part < 0xFF; part++) {\n        lv_style_list_t * list = lv_obj_get_style_list(obj, part);\n        if(list == NULL) break;\n        list->ignore_cache = dis;\n    }\n}\n\n/*-----------------\n * Attribute set\n *----------------*/\n\n/**\n * Hide an object. It won't be visible and clickable.\n * @param obj pointer to an object\n * @param en true: hide the object\n */\nvoid lv_obj_set_hidden(lv_obj_t * obj, bool en)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    if(!obj->hidden) lv_obj_invalidate(obj); /*Invalidate when not hidden (hidden objects are ignored) */\n\n    obj->hidden = en == false ? 0 : 1;\n\n    if(!obj->hidden) lv_obj_invalidate(obj); /*Invalidate when not hidden (hidden objects are ignored) */\n\n    lv_obj_t * par = lv_obj_get_parent(obj);\n    if(par) par->signal_cb(par, LV_SIGNAL_CHILD_CHG, obj);\n}\n\n/**\n * Set whether advanced hit-testing is enabled on an object\n * @param obj pointer to an object\n * @param en true: advanced hit-testing is enabled\n */\nvoid lv_obj_set_adv_hittest(lv_obj_t * obj, bool en)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->adv_hittest = en == false ? 0 : 1;\n}\n\n/**\n * Enable or disable the clicking of an object\n * @param obj pointer to an object\n * @param en true: make the object clickable\n */\nvoid lv_obj_set_click(lv_obj_t * obj, bool en)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->click = (en == true ? 1 : 0);\n}\n\n/**\n * Enable to bring this object to the foreground if it\n * or any of its children is clicked\n * @param obj pointer to an object\n * @param en true: enable the auto top feature\n */\nvoid lv_obj_set_top(lv_obj_t * obj, bool en)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->top = (en == true ? 1 : 0);\n}\n\n/**\n * Enable the dragging of an object\n * @param obj pointer to an object\n * @param en true: make the object draggable\n */\nvoid lv_obj_set_drag(lv_obj_t * obj, bool en)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    if(en == true) lv_obj_set_click(obj, true); /*Drag is useless without enabled clicking*/\n    obj->drag = (en == true ? 1 : 0);\n}\n\n/**\n * Set the directions an object can be dragged in\n * @param obj pointer to an object\n * @param drag_dir bitwise OR of allowed directions an object can be dragged in\n */\nvoid lv_obj_set_drag_dir(lv_obj_t * obj, lv_drag_dir_t drag_dir)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->drag_dir = drag_dir;\n\n    if(obj->drag_dir != 0) lv_obj_set_drag(obj, true); /*Drag direction requires drag*/\n}\n\n/**\n * Enable the throwing of an object after is is dragged\n * @param obj pointer to an object\n * @param en true: enable the drag throw\n */\nvoid lv_obj_set_drag_throw(lv_obj_t * obj, bool en)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->drag_throw = (en == true ? 1 : 0);\n}\n\n/**\n * Enable to use parent for drag related operations.\n * If trying to drag the object the parent will be moved instead\n * @param obj pointer to an object\n * @param en true: enable the 'drag parent' for the object\n */\nvoid lv_obj_set_drag_parent(lv_obj_t * obj, bool en)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->drag_parent = (en == true ? 1 : 0);\n}\n\n/**\n* Enable to use parent for gesture related operations.\n* If trying to gesture the object the parent will be moved instead\n* @param obj pointer to an object\n* @param en true: enable the 'gesture parent' for the object\n*/\nvoid lv_obj_set_gesture_parent(lv_obj_t * obj, bool en)\n{\n    obj->gesture_parent = (en == true ? 1 : 0);\n}\n\n/**\n* Enable to use parent for focus state.\n* When object is focused the parent will get the state instead (visual only)\n* @param obj pointer to an object\n* @param en true: enable the 'focus parent' for the object\n*/\nvoid lv_obj_set_focus_parent(lv_obj_t * obj, bool en)\n{\n    if(lv_obj_is_focused(obj)) {\n        if(en) {\n            obj->focus_parent = 1;\n            lv_obj_clear_state(obj, LV_STATE_FOCUSED | LV_STATE_EDITED);\n            lv_obj_set_state(lv_obj_get_focused_obj(obj), LV_STATE_FOCUSED);\n        }\n        else {\n            lv_obj_clear_state(lv_obj_get_focused_obj(obj), LV_STATE_FOCUSED | LV_STATE_EDITED);\n            lv_obj_set_state(obj, LV_STATE_FOCUSED);\n            obj->focus_parent = 0;\n        }\n    }\n    else {\n        obj->focus_parent = (en == true ? 1 : 0);\n    }\n}\n\n/**\n * Propagate the events to the parent too\n * @param obj pointer to an object\n * @param en true: enable the event propagation\n */\nvoid lv_obj_set_parent_event(lv_obj_t * obj, bool en)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->parent_event = (en == true ? 1 : 0);\n}\n\n/**\n * Set the base direction of the object.\n * @note This only works if LV_USE_BIDI is enabled.\n * @param obj pointer to an object\n * @param dir the new base direction. `LV_BIDI_DIR_LTR/RTL/AUTO/INHERIT`\n */\nvoid lv_obj_set_base_dir(lv_obj_t * obj, lv_bidi_dir_t dir)\n{\n    if(dir != LV_BIDI_DIR_LTR && dir != LV_BIDI_DIR_RTL &&\n       dir != LV_BIDI_DIR_AUTO && dir != LV_BIDI_DIR_INHERIT) {\n\n        LV_LOG_WARN(\"lv_obj_set_base_dir: invalid base dir\");\n        return;\n    }\n\n    obj->base_dir = dir;\n    lv_signal_send(obj, LV_SIGNAL_BASE_DIR_CHG, NULL);\n\n    /* Notify the children about the parent base dir has changed.\n     * (The children might have `LV_BIDI_DIR_INHERIT`)*/\n    base_dir_refr_children(obj);\n}\n\n/**\n * Set a bit or bits in the protect filed\n * @param obj pointer to an object\n * @param prot 'OR'-ed values from `lv_protect_t`\n */\nvoid lv_obj_add_protect(lv_obj_t * obj, uint8_t prot)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->protect |= prot;\n}\n\n/**\n * Clear a bit or bits in the protect filed\n * @param obj pointer to an object\n * @param prot 'OR'-ed values from `lv_protect_t`\n */\nvoid lv_obj_clear_protect(lv_obj_t * obj, uint8_t prot)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    prot = (~prot) & 0xFF;\n    obj->protect &= prot;\n}\n\n/**\n * Set the state (fully overwrite) of an object.\n * If specified in the styles a transition animation will be started\n * from the previous state to the current\n * @param obj pointer to an object\n * @param state the new state\n */\nvoid lv_obj_set_state(lv_obj_t * obj, lv_state_t new_state)\n{\n    if(obj->state == new_state) return;\n\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_state_t prev_state = obj->state;\n    style_snapshot_res_t cmp_res = STYLE_COMPARE_SAME;\n    uint8_t part;\n    for(part = 0; part < _LV_OBJ_PART_REAL_FIRST; part++) {\n        lv_style_list_t * style_list = lv_obj_get_style_list(obj, part);\n        if(style_list == NULL) break;   /*No more style lists*/\n        obj->state = prev_state;\n        style_snapshot_t shot_pre;\n        style_snapshot(obj, part, &shot_pre);\n        obj->state = new_state;\n        style_snapshot_t shot_post;\n        style_snapshot(obj, part, &shot_post);\n\n        style_snapshot_res_t r = style_snapshot_compare(&shot_pre, &shot_post);\n        if(r == STYLE_COMPARE_DIFF) {\n            cmp_res = STYLE_COMPARE_DIFF;\n            break;\n        }\n        if(r == STYLE_COMPARE_VISUAL_DIFF) {\n            cmp_res = STYLE_COMPARE_VISUAL_DIFF;\n        }\n    }\n\n    obj->state = new_state;\n\n    if(cmp_res == STYLE_COMPARE_SAME) {\n        return;\n    }\n\n#if LV_USE_ANIMATION == 0\n    if(cmp_res == STYLE_COMPARE_DIFF) lv_obj_refresh_style(obj, part, LV_STYLE_PROP_ALL);\n    else if(cmp_res == STYLE_COMPARE_VISUAL_DIFF) lv_obj_refresh_style(obj, LV_OBJ_PART_ALL, LV_STYLE_PROP_ALL);\n#else\n\n    for(part = 0; part < _LV_OBJ_PART_REAL_LAST; part++) {\n        lv_style_list_t * style_list = lv_obj_get_style_list(obj, part);\n        if(style_list == NULL) break;   /*No more style lists*/\n        if(style_list->ignore_trans) continue;\n\n        lv_style_int_t time = lv_obj_get_style_transition_time(obj, part);\n        lv_style_property_t props[LV_STYLE_TRANS_NUM_MAX];\n        lv_style_int_t delay = lv_obj_get_style_transition_delay(obj, part);\n        lv_anim_path_t * path = lv_obj_get_style_transition_path(obj, part);\n        props[0] = lv_obj_get_style_transition_prop_1(obj, part);\n        props[1] = lv_obj_get_style_transition_prop_2(obj, part);\n        props[2] = lv_obj_get_style_transition_prop_3(obj, part);\n        props[3] = lv_obj_get_style_transition_prop_4(obj, part);\n        props[4] = lv_obj_get_style_transition_prop_5(obj, part);\n        props[5] = lv_obj_get_style_transition_prop_6(obj, part);\n\n        uint8_t i;\n        for(i = 0; i < LV_STYLE_TRANS_NUM_MAX; i++) {\n            if(props[i] != 0) {\n                _lv_style_list_add_trans_style(style_list);\n\n                lv_style_trans_t * tr = trans_create(obj, props[i], part, prev_state, new_state);\n\n                /*If there is a pending anim for this property remove it*/\n                if(tr) {\n                    tr->obj = obj;\n                    tr->prop = props[i];\n                    tr->part = part;\n\n                    lv_anim_t a;\n                    lv_anim_init(&a);\n                    lv_anim_set_var(&a, tr);\n                    lv_anim_set_exec_cb(&a, (lv_anim_exec_xcb_t)trans_anim_cb);\n                    lv_anim_set_start_cb(&a, trans_anim_start_cb);\n                    lv_anim_set_ready_cb(&a, trans_anim_ready_cb);\n                    lv_anim_set_values(&a, 0x00, 0xFF);\n                    lv_anim_set_time(&a, time);\n                    lv_anim_set_delay(&a, delay);\n                    lv_anim_set_path(&a, path);\n                    a.early_apply = 0;\n                    lv_anim_start(&a);\n                }\n\n            }\n        }\n        if(cmp_res == STYLE_COMPARE_DIFF) lv_obj_refresh_style(obj, part, LV_STYLE_PROP_ALL);\n\n        if(cmp_res == STYLE_COMPARE_VISUAL_DIFF) {\n            invalidate_style_cache(obj, part, LV_STYLE_PROP_ALL);\n        }\n    }\n\n    if(cmp_res == STYLE_COMPARE_VISUAL_DIFF) {\n        lv_obj_invalidate(obj);\n    }\n\n#endif\n\n}\n\n/**\n * Add a given state or states to the object. The other state bits will remain unchanged.\n * If specified in the styles a transition animation will be started\n * from the previous state to the current\n * @param obj pointer to an object\n * @param state the state bits to add. E.g `LV_STATE_PRESSED | LV_STATE_FOCUSED`\n */\nvoid lv_obj_add_state(lv_obj_t * obj, lv_state_t state)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_state_t new_state = obj->state | state;\n    if(obj->state != new_state) {\n        lv_obj_set_state(obj, new_state);\n    }\n}\n\n/**\n * Remove a given state or states to the object. The other state bits will remain unchanged.\n * If specified in the styles a transition animation will be started\n * from the previous state to the current\n * @param obj pointer to an object\n * @param state the state bits to remove. E.g `LV_STATE_PRESSED | LV_STATE_FOCUSED`\n */\nvoid lv_obj_clear_state(lv_obj_t * obj, lv_state_t state)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_state_t new_state = obj->state & (~state);\n    if(obj->state != new_state) {\n        lv_obj_set_state(obj, new_state);\n    }\n}\n\n#if LV_USE_ANIMATION\n/**\n * Finish all pending transitions on a part of an object\n * @param obj pointer to an object\n * @param part part of the object, e.g `LV_BRN_PART_MAIN` or `LV_OBJ_PART_ALL` for all parts\n */\nvoid lv_obj_finish_transitions(lv_obj_t * obj, uint8_t part)\n{\n    /*Animate all related transition to the end value*/\n    lv_style_trans_t * tr;\n    _LV_LL_READ_BACK(LV_GC_ROOT(_lv_obj_style_trans_ll), tr) {\n        if(tr->obj == obj && (part == tr->part || part == LV_OBJ_PART_ALL)) {\n            trans_anim_cb(tr, 255);\n        }\n    }\n\n    /*Free all related transition data*/\n    trans_del(obj, part, 0xFF, NULL);\n}\n#endif\n\n/**\n * Set a an event handler function for an object.\n * Used by the user to react on event which happens with the object.\n * @param obj pointer to an object\n * @param event_cb the new event function\n */\nvoid lv_obj_set_event_cb(lv_obj_t * obj, lv_event_cb_t event_cb)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->event_cb = event_cb;\n}\n\n/**\n * Send an event to the object\n * @param obj pointer to an object\n * @param event the type of the event from `lv_event_t`\n * @param data arbitrary data depending on the object type and the event. (Usually `NULL`)\n * @return LV_RES_OK: `obj` was not deleted in the event; LV_RES_INV: `obj` was deleted in the event\n */\nlv_res_t lv_event_send(lv_obj_t * obj, lv_event_t event, const void * data)\n{\n    if(obj == NULL) return LV_RES_OK;\n\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_res_t res;\n    res = lv_event_send_func(obj->event_cb, obj, event, data);\n    return res;\n}\n\n/**\n * Send LV_EVENT_REFRESH event to an object\n * @param obj point to an object. (Can NOT be NULL)\n * @return LV_RES_OK: success, LV_RES_INV: to object become invalid (e.g. deleted) due to this event.\n */\nlv_res_t lv_event_send_refresh(lv_obj_t * obj)\n{\n    return lv_event_send(obj, LV_EVENT_REFRESH, NULL);\n}\n\n/**\n * Send LV_EVENT_REFRESH event to an object and all of its children.\n * @param obj pointer to an object or NULL to refresh all objects of all displays\n */\nvoid lv_event_send_refresh_recursive(lv_obj_t * obj)\n{\n    if(obj == NULL) {\n        /*If no obj specified refresh all screen of all displays */\n        lv_disp_t * d = lv_disp_get_next(NULL);\n        while(d) {\n            lv_obj_t * scr = _lv_ll_get_head(&d->scr_ll);\n            while(scr) {\n                lv_event_send_refresh_recursive(scr);\n                scr = _lv_ll_get_next(&d->scr_ll, scr);\n            }\n            lv_event_send_refresh_recursive(d->top_layer);\n            lv_event_send_refresh_recursive(d->sys_layer);\n\n            d = lv_disp_get_next(d);\n        }\n    }\n    else {\n\n        lv_res_t res = lv_event_send_refresh(obj);\n        if(res != LV_RES_OK) return; /*If invalid returned do not check the children*/\n\n        lv_obj_t * child = lv_obj_get_child(obj, NULL);\n        while(child) {\n            lv_event_send_refresh_recursive(child);\n\n            child = lv_obj_get_child(obj, child);\n        }\n    }\n}\n\n/**\n * Call an event function with an object, event, and data.\n * @param event_xcb an event callback function. If `NULL` `LV_RES_OK` will return without any actions.\n *        (the 'x' in the argument name indicates that its not a fully generic function because it not follows\n *         the `func_name(object, callback, ...)` convention)\n * @param obj pointer to an object to associate with the event (can be `NULL` to simply call the `event_cb`)\n * @param event an event\n * @param data pointer to a custom data\n * @return LV_RES_OK: `obj` was not deleted in the event; LV_RES_INV: `obj` was deleted in the event\n */\nlv_res_t lv_event_send_func(lv_event_cb_t event_xcb, lv_obj_t * obj, lv_event_t event, const void * data)\n{\n    if(obj != NULL) {\n        LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n    }\n\n    /* Build a simple linked list from the objects used in the events\n     * It's important to know if an this object was deleted by a nested event\n     * called from this `even_cb`. */\n    lv_event_temp_data_t event_temp_data;\n    event_temp_data.obj     = obj;\n    event_temp_data.deleted = false;\n    event_temp_data.prev    = NULL;\n\n    if(event_temp_data_head) {\n        event_temp_data.prev = event_temp_data_head;\n    }\n    event_temp_data_head = &event_temp_data;\n\n    const void * event_act_data_save = event_act_data;\n    event_act_data                   = data;\n\n    /*Call the input device's feedback callback if set*/\n    lv_indev_t * indev_act = lv_indev_get_act();\n    if(indev_act) {\n        if(indev_act->driver.feedback_cb) indev_act->driver.feedback_cb(&indev_act->driver, event);\n    }\n\n    /*Call the event callback itself*/\n    if(event_xcb) event_xcb(obj, event);\n\n    /*Restore the event data*/\n    event_act_data = event_act_data_save;\n\n    /*Remove this element from the list*/\n    event_temp_data_head = event_temp_data_head->prev;\n\n    if(event_temp_data.deleted) {\n        return LV_RES_INV;\n    }\n\n    if(obj) {\n        if(obj->parent_event && obj->parent) {\n            lv_res_t res = lv_event_send(obj->parent, event, data);\n            if(res != LV_RES_OK) {\n                return LV_RES_INV;\n            }\n        }\n    }\n\n    return LV_RES_OK;\n}\n\n/**\n * Get the `data` parameter of the current event\n * @return the `data` parameter\n */\nconst void * lv_event_get_data(void)\n{\n    return event_act_data;\n}\n\n/**\n * Set the a signal function of an object. Used internally by the library.\n * Always call the previous signal function in the new.\n * @param obj pointer to an object\n * @param cb the new signal function\n */\nvoid lv_obj_set_signal_cb(lv_obj_t * obj, lv_signal_cb_t signal_cb)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->signal_cb = signal_cb;\n}\n\n/**\n * Send an event to the object\n * @param obj pointer to an object\n * @param event the type of the event from `lv_event_t`.\n * @return LV_RES_OK or LV_RES_INV\n */\nlv_res_t lv_signal_send(lv_obj_t * obj, lv_signal_t signal, void * param)\n{\n    if(obj == NULL) return LV_RES_OK;\n\n    lv_res_t res = LV_RES_OK;\n    if(obj->signal_cb) res = obj->signal_cb(obj, signal, param);\n\n    return res;\n}\n\n/**\n * Set a new design function for an object\n * @param obj pointer to an object\n * @param design_cb the new design function\n */\nvoid lv_obj_set_design_cb(lv_obj_t * obj, lv_design_cb_t design_cb)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->design_cb = design_cb;\n}\n\n/*----------------\n * Other set\n *--------------*/\n\n/**\n * Allocate a new ext. data for an object\n * @param obj pointer to an object\n * @param ext_size the size of the new ext. data\n * @return pointer to the allocated ext.\n * If out of memory NULL is returned and the original ext is preserved\n */\nvoid * lv_obj_allocate_ext_attr(lv_obj_t * obj, uint16_t ext_size)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    void * new_ext = lv_mem_realloc(obj->ext_attr, ext_size);\n    if(new_ext == NULL) return NULL;\n\n    obj->ext_attr = new_ext;\n    return (void *)obj->ext_attr;\n}\n\n/**\n * Send a 'LV_SIGNAL_REFR_EXT_SIZE' signal to the object to refresh the extended draw area.\n * he object needs to be invalidated by `lv_obj_invalidate(obj)` manually after this function.\n * @param obj pointer to an object\n */\nvoid lv_obj_refresh_ext_draw_pad(lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->ext_draw_pad = 0;\n    obj->signal_cb(obj, LV_SIGNAL_REFR_EXT_DRAW_PAD, NULL);\n\n}\n\n/*=======================\n * Getter functions\n *======================*/\n\n/**\n * Return with the screen of an object\n * @param obj pointer to an object\n * @return pointer to a screen\n */\nlv_obj_t * lv_obj_get_screen(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    const lv_obj_t * par = obj;\n    const lv_obj_t * act_p;\n\n    do {\n        act_p = par;\n        par   = lv_obj_get_parent(act_p);\n    } while(par != NULL);\n\n    return (lv_obj_t *)act_p;\n}\n\n/**\n * Get the display of an object\n * @param scr pointer to an object\n * @return pointer the object's display\n */\nlv_disp_t * lv_obj_get_disp(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    const lv_obj_t * scr;\n\n    if(obj->parent == NULL)\n        scr = obj; /*`obj` is a screen*/\n    else\n        scr = lv_obj_get_screen(obj); /*get the screen of `obj`*/\n\n    lv_disp_t * d;\n    _LV_LL_READ(LV_GC_ROOT(_lv_disp_ll), d) {\n        lv_obj_t * s;\n        _LV_LL_READ(d->scr_ll, s) {\n            if(s == scr) return d;\n        }\n    }\n\n    LV_LOG_WARN(\"lv_scr_get_disp: screen not found\")\n    return NULL;\n}\n\n/*---------------------\n * Parent/children get\n *--------------------*/\n\n/**\n * Returns with the parent of an object\n * @param obj pointer to an object\n * @return pointer to the parent of  'obj'\n */\nlv_obj_t * lv_obj_get_parent(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return obj->parent;\n}\n\n/**\n * Iterate through the children of an object (start from the \"youngest\")\n * @param obj pointer to an object\n * @param child NULL at first call to get the next children\n *                  and the previous return value later\n * @return the child after 'act_child' or NULL if no more child\n */\nlv_obj_t * lv_obj_get_child(const lv_obj_t * obj, const lv_obj_t * child)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_obj_t * result = NULL;\n\n    if(child == NULL) {\n        result = _lv_ll_get_head(&obj->child_ll);\n    }\n    else {\n        result = _lv_ll_get_next(&obj->child_ll, child);\n    }\n\n    return result;\n}\n\n/**\n * Iterate through the children of an object (start from the \"oldest\")\n * @param obj pointer to an object\n * @param child NULL at first call to get the next children\n *                  and the previous return value later\n * @return the child after 'act_child' or NULL if no more child\n */\nlv_obj_t * lv_obj_get_child_back(const lv_obj_t * obj, const lv_obj_t * child)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_obj_t * result = NULL;\n\n    if(child == NULL) {\n        result = _lv_ll_get_tail(&obj->child_ll);\n    }\n    else {\n        result = _lv_ll_get_prev(&obj->child_ll, child);\n    }\n\n    return result;\n}\n\n/**\n * Count the children of an object (only children directly on 'obj')\n * @param obj pointer to an object\n * @return children number of 'obj'\n */\nuint16_t lv_obj_count_children(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_obj_t * i;\n    uint16_t cnt = 0;\n\n    _LV_LL_READ(obj->child_ll, i) cnt++;\n\n    return cnt;\n}\n\n/** Recursively count the children of an object\n * @param obj pointer to an object\n * @return children number of 'obj'\n */\nuint16_t lv_obj_count_children_recursive(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_obj_t * i;\n    uint16_t cnt = 0;\n\n    _LV_LL_READ(obj->child_ll, i) {\n        cnt++;                                     /*Count the child*/\n        cnt += lv_obj_count_children_recursive(i); /*recursively count children's children*/\n    }\n\n    return cnt;\n}\n\n/*---------------------\n * Coordinate get\n *--------------------*/\n\n/**\n * Copy the coordinates of an object to an area\n * @param obj pointer to an object\n * @param cords_p pointer to an area to store the coordinates\n */\nvoid lv_obj_get_coords(const lv_obj_t * obj, lv_area_t * cords_p)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_area_copy(cords_p, &obj->coords);\n}\n\n/**\n * Reduce area retried by `lv_obj_get_coords()` the get graphically usable area of an object.\n * (Without the size of the border or other extra graphical elements)\n * @param coords_p store the result area here\n */\nvoid lv_obj_get_inner_coords(const lv_obj_t * obj, lv_area_t * coords_p)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_border_side_t part = lv_obj_get_style_border_side(obj, LV_OBJ_PART_MAIN);\n    lv_coord_t w = lv_obj_get_style_border_width(obj, LV_OBJ_PART_MAIN);\n\n    if(part & LV_BORDER_SIDE_LEFT) coords_p->x1 += w;\n\n    if(part & LV_BORDER_SIDE_RIGHT) coords_p->x2 -= w;\n\n    if(part & LV_BORDER_SIDE_TOP) coords_p->y1 += w;\n\n    if(part & LV_BORDER_SIDE_BOTTOM) coords_p->y2 -= w;\n}\n\n/**\n * Get the x coordinate of object\n * @param obj pointer to an object\n * @return distance of 'obj' from the left side of its parent\n */\nlv_coord_t lv_obj_get_x(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_coord_t rel_x;\n    lv_obj_t * parent = lv_obj_get_parent(obj);\n    if(parent) {\n        rel_x             = obj->coords.x1 - parent->coords.x1;\n    }\n    else {\n        rel_x = obj->coords.x1;\n    }\n    return rel_x;\n}\n\n/**\n * Get the y coordinate of object\n * @param obj pointer to an object\n * @return distance of 'obj' from the top of its parent\n */\nlv_coord_t lv_obj_get_y(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_coord_t rel_y;\n    lv_obj_t * parent = lv_obj_get_parent(obj);\n    if(parent) {\n        rel_y             = obj->coords.y1 - parent->coords.y1;\n    }\n    else {\n        rel_y = obj->coords.y1;\n    }\n    return rel_y;\n}\n\n/**\n * Get the width of an object\n * @param obj pointer to an object\n * @return the width\n */\nlv_coord_t lv_obj_get_width(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return lv_area_get_width(&obj->coords);\n}\n\n/**\n * Get the height of an object\n * @param obj pointer to an object\n * @return the height\n */\nlv_coord_t lv_obj_get_height(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return lv_area_get_height(&obj->coords);\n}\n\n/**\n * Get that width reduced by the left and right padding.\n * @param obj pointer to an object\n * @return the width which still fits into the container\n */\nlv_coord_t lv_obj_get_width_fit(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_style_int_t left = lv_obj_get_style_pad_left(obj, LV_OBJ_PART_MAIN);\n    lv_style_int_t right = lv_obj_get_style_pad_right(obj, LV_OBJ_PART_MAIN);\n\n    return lv_obj_get_width(obj) - left - right;\n}\n\n/**\n * Get that height reduced by the top an bottom padding.\n * @param obj pointer to an object\n * @return the height which still fits into the container\n */\nlv_coord_t lv_obj_get_height_fit(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_style_int_t top = lv_obj_get_style_pad_top((lv_obj_t *)obj, LV_OBJ_PART_MAIN);\n    lv_style_int_t bottom =  lv_obj_get_style_pad_bottom((lv_obj_t *)obj, LV_OBJ_PART_MAIN);\n\n    return lv_obj_get_height(obj) - top - bottom;\n}\n\n/**\n * Get the height of an object by taking the top and bottom margin into account.\n * The returned height will be `obj_h + margin_top + margin_bottom`\n * @param obj pointer to an object\n * @return the height including thee margins\n */\nlv_coord_t lv_obj_get_height_margin(lv_obj_t * obj)\n{\n    lv_style_int_t mtop = lv_obj_get_style_margin_top(obj, LV_OBJ_PART_MAIN);\n    lv_style_int_t mbottom = lv_obj_get_style_margin_bottom(obj, LV_OBJ_PART_MAIN);\n\n    return lv_obj_get_height(obj) + mtop + mbottom;\n}\n\n/**\n * Get the width of an object by taking the left and right margin into account.\n * The returned width will be `obj_w + margin_left + margin_right`\n * @param obj pointer to an object\n * @return the height including thee margins\n */\nlv_coord_t lv_obj_get_width_margin(lv_obj_t * obj)\n{\n    lv_style_int_t mleft = lv_obj_get_style_margin_left(obj, LV_OBJ_PART_MAIN);\n    lv_style_int_t mright = lv_obj_get_style_margin_right(obj, LV_OBJ_PART_MAIN);\n\n    return lv_obj_get_width(obj) + mleft + mright;\n}\n\n/**\n * Set that width reduced by the left and right padding of the parent.\n * @param obj pointer to an object\n * @param div indicates how many columns are assumed.\n * If 1 the width will be set the parent's width\n * If 2 only half parent width - inner padding of the parent\n * If 3 only third parent width - 2 * inner padding of the parent\n * @param span how many columns are combined\n * @return the width according to the given parameters\n */\nlv_coord_t lv_obj_get_width_grid(lv_obj_t * obj, uint8_t div, uint8_t span)\n{\n    lv_coord_t obj_w = lv_obj_get_width_fit(obj);\n    lv_style_int_t pinner = lv_obj_get_style_pad_inner(obj, LV_OBJ_PART_MAIN);\n\n    lv_coord_t r = (obj_w - (div - 1) * pinner) / div;\n\n    r = r * span + (span - 1) * pinner;\n    return r;\n}\n\n/**\n * Get that height reduced by the top and bottom padding of the parent.\n * @param obj pointer to an object\n * @param div indicates how many rows are assumed.\n * If 1 the height will be set the parent's height\n * If 2 only half parent height - inner padding of the parent\n * If 3 only third parent height - 2 * inner padding of the parent\n * @param span how many rows are combined\n * @return the height according to the given parameters\n */\nlv_coord_t lv_obj_get_height_grid(lv_obj_t * obj, uint8_t div, uint8_t span)\n{\n    lv_coord_t obj_h = lv_obj_get_height_fit(obj);\n    lv_style_int_t pinner = lv_obj_get_style_pad_inner(obj, LV_OBJ_PART_MAIN);\n\n    lv_coord_t r = (obj_h - (div - 1) * pinner) / div;\n\n    r = r * span + (span - 1) * pinner;\n    return r;\n}\n\n/**\n * Get the automatic realign property of the object.\n * @param obj pointer to an object\n * @return true: auto realign is enabled; false: auto realign is disabled\n */\nbool lv_obj_get_auto_realign(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_OBJ_REALIGN\n    return obj->realign.auto_realign ? true : false;\n#else\n    (void)obj;\n    return false;\n#endif\n}\n\n/**\n * Get the left padding of extended clickable area\n * @param obj pointer to an object\n * @return the extended left padding\n */\nlv_coord_t lv_obj_get_ext_click_pad_left(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_TINY\n    return obj->ext_click_pad_hor;\n#elif LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_FULL\n    return obj->ext_click_pad.x1;\n#else\n    (void)obj;    /*Unused*/\n    return 0;\n#endif\n}\n\n/**\n * Get the right padding of extended clickable area\n * @param obj pointer to an object\n * @return the extended right padding\n */\nlv_coord_t lv_obj_get_ext_click_pad_right(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_TINY\n    return obj->ext_click_pad_hor;\n#elif LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_FULL\n    return obj->ext_click_pad.x2;\n#else\n    (void)obj; /*Unused*/\n    return 0;\n#endif\n}\n\n/**\n * Get the top padding of extended clickable area\n * @param obj pointer to an object\n * @return the extended top padding\n */\nlv_coord_t lv_obj_get_ext_click_pad_top(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_TINY\n    return obj->ext_click_pad_ver;\n#elif LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_FULL\n    return obj->ext_click_pad.y1;\n#else\n    (void)obj; /*Unused*/\n    return 0;\n#endif\n}\n\n/**\n * Get the bottom padding of extended clickable area\n * @param obj pointer to an object\n * @return the extended bottom padding\n */\nlv_coord_t lv_obj_get_ext_click_pad_bottom(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_TINY\n    return obj->ext_click_pad_ver;\n#elif LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_FULL\n    return obj->ext_click_pad.y2;\n#else\n    (void)obj; /*Unused*/\n    return 0;\n#endif\n}\n\n/**\n * Get the extended size attribute of an object\n * @param obj pointer to an object\n * @return the extended size attribute\n */\nlv_coord_t lv_obj_get_ext_draw_pad(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return obj->ext_draw_pad;\n}\n\n/*-----------------\n * Appearance get\n *---------------*/\n\nlv_style_list_t * lv_obj_get_style_list(const lv_obj_t * obj, uint8_t part)\n{\n    if(part == LV_OBJ_PART_MAIN) return &((lv_obj_t *)obj)->style_list;\n\n    lv_get_style_info_t info;\n    info.part = part;\n    info.result = NULL;\n\n    lv_res_t res;\n    res = lv_signal_send((lv_obj_t *)obj, LV_SIGNAL_GET_STYLE, &info);\n\n    if(res != LV_RES_OK) return NULL;\n\n    return info.result;\n}\n\n/**\n * Get a style property of a part of an object in the object's current state.\n * If there is a running transitions it is taken into account\n * @param obj pointer to an object\n * @param part the part of the object which style property should be get.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop the property to get. E.g. `LV_STYLE_BORDER_WIDTH`.\n *  The state of the object will be added internally\n * @return the value of the property of the given part in the current state.\n * If the property is not found a default value will be returned.\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_width()`\n * @note for performance reasons it's not checked if the property really has integer type\n */\nlv_style_int_t _lv_obj_get_style_int(const lv_obj_t * obj, uint8_t part, lv_style_property_t prop)\n{\n    lv_style_property_t prop_ori = prop;\n\n    lv_style_attr_t attr;\n    attr = prop_ori >> 8;\n\n    lv_style_int_t value_act;\n    lv_res_t res = LV_RES_INV;\n    const lv_obj_t * parent = obj;\n    while(parent) {\n        lv_style_list_t * list = lv_obj_get_style_list(parent, part);\n        if(!list->ignore_cache && list->style_cnt > 0) {\n            if(!list->valid_cache) update_style_cache((lv_obj_t *)parent, part, prop  & (~LV_STYLE_STATE_MASK));\n\n            bool def = false;\n            switch(prop  & (~LV_STYLE_STATE_MASK)) {\n                case LV_STYLE_CLIP_CORNER:\n                    if(list->clip_corner_off) def = true;\n                    break;\n                case LV_STYLE_TEXT_LETTER_SPACE:\n                case LV_STYLE_TEXT_LINE_SPACE:\n                    if(list->text_space_zero) def = true;\n                    break;\n                case LV_STYLE_TRANSFORM_ANGLE:\n                case LV_STYLE_TRANSFORM_WIDTH:\n                case LV_STYLE_TRANSFORM_HEIGHT:\n                case LV_STYLE_TRANSFORM_ZOOM:\n                    if(list->transform_all_zero) def = true;\n                    break;\n                case LV_STYLE_BORDER_WIDTH:\n                    if(list->border_width_zero) def = true;\n                    break;\n                case LV_STYLE_BORDER_SIDE:\n                    if(list->border_side_full) def = true;\n                    break;\n                case LV_STYLE_BORDER_POST:\n                    if(list->border_post_off) def = true;\n                    break;\n                case LV_STYLE_OUTLINE_WIDTH:\n                    if(list->outline_width_zero) def = true;\n                    break;\n                case LV_STYLE_RADIUS:\n                    if(list->radius_zero) def = true;\n                    break;\n                case LV_STYLE_SHADOW_WIDTH:\n                    if(list->shadow_width_zero) def = true;\n                    break;\n                case LV_STYLE_PAD_TOP:\n                case LV_STYLE_PAD_BOTTOM:\n                case LV_STYLE_PAD_LEFT:\n                case LV_STYLE_PAD_RIGHT:\n                    if(list->pad_all_zero) def = true;\n                    break;\n                case LV_STYLE_MARGIN_TOP:\n                case LV_STYLE_MARGIN_BOTTOM:\n                case LV_STYLE_MARGIN_LEFT:\n                case LV_STYLE_MARGIN_RIGHT:\n                    if(list->margin_all_zero) def = true;\n                    break;\n                case LV_STYLE_BG_BLEND_MODE:\n                case LV_STYLE_BORDER_BLEND_MODE:\n                case LV_STYLE_IMAGE_BLEND_MODE:\n                case LV_STYLE_LINE_BLEND_MODE:\n                case LV_STYLE_OUTLINE_BLEND_MODE:\n                case LV_STYLE_PATTERN_BLEND_MODE:\n                case LV_STYLE_SHADOW_BLEND_MODE:\n                case LV_STYLE_TEXT_BLEND_MODE:\n                case LV_STYLE_VALUE_BLEND_MODE:\n                    if(list->blend_mode_all_normal) def = true;\n                    break;\n                case LV_STYLE_TEXT_DECOR:\n                    if(list->text_decor_none) def = true;\n                    break;\n            }\n\n            if(def) {\n                break;\n            }\n        }\n\n        lv_state_t state = lv_obj_get_state(parent, part);\n        prop = (uint16_t)prop_ori + ((uint16_t)state << LV_STYLE_STATE_POS);\n\n        res = _lv_style_list_get_int(list, prop, &value_act);\n        if(res == LV_RES_OK) return value_act;\n\n        if(LV_STYLE_ATTR_GET_INHERIT(attr) == 0) break;\n\n        /*If not found, check the `MAIN` style first*/\n        if(part != LV_OBJ_PART_MAIN) {\n            part = LV_OBJ_PART_MAIN;\n            continue;\n        }\n\n        /*Check the parent too.*/\n        parent = lv_obj_get_parent(parent);\n    }\n\n    /*Handle unset values*/\n    prop = prop & (~LV_STYLE_STATE_MASK);\n    switch(prop) {\n        case LV_STYLE_BORDER_SIDE:\n            return LV_BORDER_SIDE_FULL;\n        case LV_STYLE_SIZE:\n            return LV_DPI / 20;\n        case LV_STYLE_SCALE_WIDTH:\n            return LV_DPI / 8;\n        case LV_STYLE_BG_GRAD_STOP:\n            return 255;\n        case LV_STYLE_TRANSFORM_ZOOM:\n            return LV_IMG_ZOOM_NONE;\n    }\n\n    return 0;\n}\n\n/**\n * Get a style property of a part of an object in the object's current state.\n * If there is a running transitions it is taken into account\n * @param obj pointer to an object\n * @param part the part of the object which style property should be get.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop the property to get. E.g. `LV_STYLE_BORDER_COLOR`.\n *  The state of the object will be added internally\n * @return the value of the property of the given part in the current state.\n * If the property is not found a default value will be returned.\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_color()`\n * @note for performance reasons it's not checked if the property really has color type\n */\nlv_color_t _lv_obj_get_style_color(const lv_obj_t * obj, uint8_t part, lv_style_property_t prop)\n{\n    lv_style_property_t prop_ori = prop;\n\n    lv_style_attr_t attr;\n    attr = prop_ori >> 8;\n\n    lv_color_t value_act;\n    lv_res_t res = LV_RES_INV;\n    const lv_obj_t * parent = obj;\n    while(parent) {\n        lv_style_list_t * list = lv_obj_get_style_list(parent, part);\n\n        lv_state_t state = lv_obj_get_state(parent, part);\n        prop = (uint16_t)prop_ori + ((uint16_t)state << LV_STYLE_STATE_POS);\n\n        res = _lv_style_list_get_color(list, prop, &value_act);\n        if(res == LV_RES_OK) return value_act;\n\n        if(LV_STYLE_ATTR_GET_INHERIT(attr) == 0) break;\n\n        /*If not found, check the `MAIN` style first*/\n        if(part != LV_OBJ_PART_MAIN) {\n            part = LV_OBJ_PART_MAIN;\n            continue;\n        }\n\n        /*Check the parent too.*/\n        parent = lv_obj_get_parent(parent);\n    }\n\n    /*Handle unset values*/\n    prop = prop & (~LV_STYLE_STATE_MASK);\n    switch(prop) {\n        case LV_STYLE_BG_COLOR:\n        case LV_STYLE_BG_GRAD_COLOR:\n            return LV_COLOR_WHITE;\n    }\n\n    return LV_COLOR_BLACK;\n}\n\n/**\n * Get a style property of a part of an object in the object's current state.\n * If there is a running transitions it is taken into account\n * @param obj pointer to an object\n * @param part the part of the object which style property should be get.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop the property to get. E.g. `LV_STYLE_BORDER_OPA`.\n *  The state of the object will be added internally\n * @return the value of the property of the given part in the current state.\n * If the property is not found a default value will be returned.\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_opa()`\n * @note for performance reasons it's not checked if the property really has opacity type\n */\nlv_opa_t _lv_obj_get_style_opa(const lv_obj_t * obj, uint8_t part, lv_style_property_t prop)\n{\n    lv_style_property_t prop_ori = prop;\n\n    lv_style_attr_t attr;\n    attr = prop_ori >> 8;\n\n    lv_opa_t value_act;\n    lv_res_t res = LV_RES_INV;\n    const lv_obj_t * parent = obj;\n    while(parent) {\n        lv_style_list_t * list = lv_obj_get_style_list(parent, part);\n\n        if(!list->ignore_cache && list->style_cnt > 0) {\n            if(!list->valid_cache) update_style_cache((lv_obj_t *)parent, part, prop  & (~LV_STYLE_STATE_MASK));\n            bool def = false;\n            switch(prop & (~LV_STYLE_STATE_MASK)) {\n                case LV_STYLE_OPA_SCALE:\n                    if(list->opa_scale_cover) def = true;\n                    break;\n                case LV_STYLE_BG_OPA:\n                    if(list->bg_opa_cover) return LV_OPA_COVER;     /*Special case, not the default value is used*/\n                    if(list->bg_opa_transp) def = true;\n                    break;\n                case LV_STYLE_IMAGE_RECOLOR_OPA:\n                    if(list->img_recolor_opa_transp) def = true;\n                    break;\n            }\n\n            if(def) {\n                break;\n            }\n        }\n\n        lv_state_t state = lv_obj_get_state(parent, part);\n        prop = (uint16_t)prop_ori + ((uint16_t)state << LV_STYLE_STATE_POS);\n\n        res = _lv_style_list_get_opa(list, prop, &value_act);\n        if(res == LV_RES_OK) return value_act;\n\n        if(LV_STYLE_ATTR_GET_INHERIT(attr) == 0) break;\n\n        /*If not found, check the `MAIN` style first*/\n        if(part != LV_OBJ_PART_MAIN) {\n            part = LV_OBJ_PART_MAIN;\n            continue;\n        }\n\n        /*Check the parent too.*/\n        parent = lv_obj_get_parent(parent);\n    }\n\n    /*Handle unset values*/\n    prop = prop & (~LV_STYLE_STATE_MASK);\n    switch(prop) {\n        case LV_STYLE_BG_OPA:\n        case LV_STYLE_IMAGE_RECOLOR_OPA:\n        case LV_STYLE_PATTERN_RECOLOR_OPA:\n            return LV_OPA_TRANSP;\n    }\n\n    return LV_OPA_COVER;\n}\n\n/**\n * Get a style property of a part of an object in the object's current state.\n * If there is a running transitions it is taken into account\n * @param obj pointer to an object\n * @param part the part of the object which style property should be get.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop the property to get. E.g. `LV_STYLE_TEXT_FONT`.\n *  The state of the object will be added internally\n * @return the value of the property of the given part in the current state.\n * If the property is not found a default value will be returned.\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_opa()`\n * @note for performance reasons it's not checked if the property really has pointer type\n */\nconst void * _lv_obj_get_style_ptr(const lv_obj_t * obj, uint8_t part, lv_style_property_t prop)\n{\n    lv_style_property_t prop_ori = prop;\n\n    lv_style_attr_t attr;\n    attr = prop_ori >> 8;\n\n    const void * value_act;\n    lv_res_t res = LV_RES_INV;\n    const lv_obj_t * parent = obj;\n    while(parent) {\n        lv_style_list_t * list = lv_obj_get_style_list(parent, part);\n\n        if(!list->ignore_cache && list->style_cnt > 0) {\n            if(!list->valid_cache) update_style_cache((lv_obj_t *)parent, part, prop  & (~LV_STYLE_STATE_MASK));\n            bool def = false;\n            switch(prop  & (~LV_STYLE_STATE_MASK)) {\n                case LV_STYLE_VALUE_STR:\n                    if(list->value_txt_str) def = true;\n                    break;\n                case LV_STYLE_PATTERN_IMAGE:\n                    if(list->pattern_img_null) def = true;\n                    break;\n                case LV_STYLE_TEXT_FONT:\n                    if(list->text_font_normal) def = true;\n                    break;\n            }\n\n            if(def) {\n                break;\n            }\n        }\n\n        lv_state_t state = lv_obj_get_state(parent, part);\n        prop = (uint16_t)prop_ori + ((uint16_t)state << LV_STYLE_STATE_POS);\n\n        res = _lv_style_list_get_ptr(list, prop, &value_act);\n        if(res == LV_RES_OK)  return value_act;\n\n        if(LV_STYLE_ATTR_GET_INHERIT(attr) == 0) break;\n\n        /*If not found, check the `MAIN` style first*/\n        if(part != LV_OBJ_PART_MAIN) {\n            part = LV_OBJ_PART_MAIN;\n            continue;\n        }\n\n        /*Check the parent too.*/\n        parent = lv_obj_get_parent(parent);\n    }\n\n    /*Handle unset values*/\n    prop = prop & (~LV_STYLE_STATE_MASK);\n    switch(prop) {\n        case LV_STYLE_TEXT_FONT:\n        case LV_STYLE_VALUE_FONT:\n            return lv_theme_get_font_normal();\n#if LV_USE_ANIMATION\n        case LV_STYLE_TRANSITION_PATH:\n            return &lv_anim_path_def;\n#endif\n    }\n\n    return NULL;\n}\n\n/**\n * Get the local style of a part of an object.\n * @param obj pointer to an object\n * @param part the part of the object which style property should be set.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @return pointer to the local style if exists else `NULL`.\n */\nlv_style_t * lv_obj_get_local_style(lv_obj_t * obj, uint8_t part)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n    lv_style_list_t * style_list = lv_obj_get_style_list(obj, part);\n    return lv_style_list_get_local_style(style_list);\n}\n\n/*-----------------\n * Attribute get\n *----------------*/\n\n/**\n * Get the hidden attribute of an object\n * @param obj pointer to an object\n * @return true: the object is hidden\n */\nbool lv_obj_get_hidden(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return obj->hidden == 0 ? false : true;\n}\n\n/**\n * Get whether advanced hit-testing is enabled on an object\n * @param obj pointer to an object\n * @return true: advanced hit-testing is enabled\n */\nbool lv_obj_get_adv_hittest(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return obj->adv_hittest == 0 ? false : true;\n}\n\n/**\n * Get the click enable attribute of an object\n * @param obj pointer to an object\n * @return true: the object is clickable\n */\nbool lv_obj_get_click(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return obj->click == 0 ? false : true;\n}\n\n/**\n * Get the top enable attribute of an object\n * @param obj pointer to an object\n * @return true: the auto top feature is enabled\n */\nbool lv_obj_get_top(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return obj->top == 0 ? false : true;\n}\n\n/**\n * Get the drag enable attribute of an object\n * @param obj pointer to an object\n * @return true: the object is draggable\n */\nbool lv_obj_get_drag(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return obj->drag == 0 ? false : true;\n}\n\n/**\n * Get the directions an object can be dragged\n * @param obj pointer to an object\n * @return bitwise OR of allowed directions an object can be dragged in\n */\nlv_drag_dir_t lv_obj_get_drag_dir(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return obj->drag_dir;\n}\n\n/**\n * Get the drag throw enable attribute of an object\n * @param obj pointer to an object\n * @return true: drag throw is enabled\n */\nbool lv_obj_get_drag_throw(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return obj->drag_throw == 0 ? false : true;\n}\n\n/**\n * Get the drag parent attribute of an object\n * @param obj pointer to an object\n * @return true: drag parent is enabled\n */\nbool lv_obj_get_drag_parent(const lv_obj_t * obj)\n{\n    return obj->drag_parent == 0 ? false : true;\n}\n\n/**\n* Get the gesture parent attribute of an object\n* @param obj pointer to an object\n* @return true: gesture parent is enabled\n*/\nbool lv_obj_get_gesture_parent(const lv_obj_t * obj)\n{\n    return obj->gesture_parent == 0 ? false : true;\n}\n\n/**\n* Get the focus parent attribute of an object\n* @param obj pointer to an object\n* @return true: focus parent is enabled\n*/\nbool lv_obj_get_focus_parent(const lv_obj_t * obj)\n{\n    return obj->focus_parent == 0 ? false : true;\n}\n\n/**\n * Get the drag parent attribute of an object\n * @param obj pointer to an object\n * @return true: drag parent is enabled\n */\nbool lv_obj_get_parent_event(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return obj->parent_event == 0 ? false : true;\n}\n\nlv_bidi_dir_t lv_obj_get_base_dir(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_BIDI\n    const lv_obj_t * parent = obj;\n\n    while(parent) {\n        if(parent->base_dir != LV_BIDI_DIR_INHERIT) return parent->base_dir;\n\n        parent = lv_obj_get_parent(parent);\n    }\n\n    return LV_BIDI_BASE_DIR_DEF;\n#else\n    (void) obj;  /*Unused*/\n    return LV_BIDI_DIR_LTR;\n#endif\n}\n\n/**\n * Get the protect field of an object\n * @param obj pointer to an object\n * @return protect field ('OR'ed values of `lv_protect_t`)\n */\nuint8_t lv_obj_get_protect(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return obj->protect;\n}\n\n/**\n * Check at least one bit of a given protect bitfield is set\n * @param obj pointer to an object\n * @param prot protect bits to test ('OR'ed values of `lv_protect_t`)\n * @return false: none of the given bits are set, true: at least one bit is set\n */\nbool lv_obj_is_protected(const lv_obj_t * obj, uint8_t prot)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return (obj->protect & prot) == 0 ? false : true;\n}\n\nlv_state_t lv_obj_get_state(const lv_obj_t * obj, uint8_t part)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    if(part < _LV_OBJ_PART_REAL_LAST) return ((lv_obj_t *)obj)->state;\n\n    /*If a real part is asked, then use the object's signal to get its state.\n     * A real object can be in different state then the main part\n     * and only the object itself knows who to get it's state. */\n    lv_get_state_info_t info;\n    info.part = part;\n    info.result = LV_STATE_DEFAULT;\n    lv_signal_send((lv_obj_t *)obj, LV_SIGNAL_GET_STATE_DSC, &info);\n\n    return info.result;\n\n}\n\n/**\n * Get the signal function of an object\n * @param obj pointer to an object\n * @return the signal function\n */\nlv_signal_cb_t lv_obj_get_signal_cb(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return obj->signal_cb;\n}\n\n/**\n * Get the design function of an object\n * @param obj pointer to an object\n * @return the design function\n */\nlv_design_cb_t lv_obj_get_design_cb(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return obj->design_cb;\n}\n\n/**\n * Get the event function of an object\n * @param obj pointer to an object\n * @return the event function\n */\nlv_event_cb_t lv_obj_get_event_cb(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return obj->event_cb;\n}\n\n/*------------------\n * Other get\n *-----------------*/\n\n/**\n * Get the ext pointer\n * @param obj pointer to an object\n * @return the ext pointer but not the dynamic version\n *         Use it as ext->data1, and NOT da(ext)->data1\n */\nvoid * lv_obj_get_ext_attr(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return obj->ext_attr;\n}\n\n/**\n * Get object's and its ancestors type. Put their name in `type_buf` starting with the current type.\n * E.g. buf.type[0]=\"lv_btn\", buf.type[1]=\"lv_cont\", buf.type[2]=\"lv_obj\"\n * @param obj pointer to an object which type should be get\n * @param buf pointer to an `lv_obj_type_t` buffer to store the types\n */\nvoid lv_obj_get_type(const lv_obj_t * obj, lv_obj_type_t * buf)\n{\n    LV_ASSERT_NULL(buf);\n    LV_ASSERT_NULL(obj);\n\n    lv_obj_type_t tmp;\n\n    _lv_memset_00(buf, sizeof(lv_obj_type_t));\n    _lv_memset_00(&tmp, sizeof(lv_obj_type_t));\n\n    obj->signal_cb((lv_obj_t *)obj, LV_SIGNAL_GET_TYPE, &tmp);\n\n    uint8_t cnt;\n    for(cnt = 0; cnt < LV_MAX_ANCESTOR_NUM; cnt++) {\n        if(tmp.type[cnt] == NULL) break;\n    }\n\n    /*Swap the order. The real type comes first*/\n    uint8_t i;\n    for(i = 0; i < cnt; i++) {\n        buf->type[i] = tmp.type[cnt - 1 - i];\n    }\n}\n\n#if LV_USE_USER_DATA\n\n/**\n * Get the object's user data\n * @param obj pointer to an object\n * @return user data\n */\nlv_obj_user_data_t lv_obj_get_user_data(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return obj->user_data;\n}\n\n/**\n * Get a pointer to the object's user data\n * @param obj pointer to an object\n * @return pointer to the user data\n */\nlv_obj_user_data_t * lv_obj_get_user_data_ptr(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return (lv_obj_user_data_t *)&obj->user_data;\n}\n\n/**\n * Set the object's user data. The data will be copied.\n * @param obj pointer to an object\n * @param data user data\n */\nvoid lv_obj_set_user_data(lv_obj_t * obj, lv_obj_user_data_t data)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    _lv_memcpy(&obj->user_data, &data, sizeof(lv_obj_user_data_t));\n}\n#endif\n\n/**\n * Get the group of the object\n * @param obj pointer to an object\n * @return the pointer to group of the object\n */\nvoid * lv_obj_get_group(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_GROUP\n    return obj->group_p;\n#else\n    LV_UNUSED(obj);\n    return NULL;\n#endif\n}\n\n/**\n * Tell whether the object is the focused object of a group or not.\n * @param obj pointer to an object\n * @return true: the object is focused, false: the object is not focused or not in a group\n */\nbool lv_obj_is_focused(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_GROUP\n    if(obj->group_p) {\n        if(lv_group_get_focused(obj->group_p) == obj) return true;\n    }\n    return false;\n#else\n    LV_UNUSED(obj);\n    return false;\n#endif\n}\n\n/*-------------------\n * OTHER FUNCTIONS\n *------------------*/\n\n/**\n * Check if a given screen-space point is on an object's coordinates.\n *\n * This method is intended to be used mainly by advanced hit testing algorithms to check\n * whether the point is even within the object (as an optimization).\n * @param obj object to check\n * @param point screen-space point\n */\nbool lv_obj_is_point_on_coords(lv_obj_t * obj, const lv_point_t * point)\n{\n#if LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_TINY\n    lv_area_t ext_area;\n    ext_area.x1 = obj->coords.x1 - obj->ext_click_pad_hor;\n    ext_area.x2 = obj->coords.x2 + obj->ext_click_pad_hor;\n    ext_area.y1 = obj->coords.y1 - obj->ext_click_pad_ver;\n    ext_area.y2 = obj->coords.y2 + obj->ext_click_pad_ver;\n\n    if(!_lv_area_is_point_on(&ext_area, point, 0)) {\n#elif LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_FULL\n    lv_area_t ext_area;\n    ext_area.x1 = obj->coords.x1 - obj->ext_click_pad.x1;\n    ext_area.x2 = obj->coords.x2 + obj->ext_click_pad.x2;\n    ext_area.y1 = obj->coords.y1 - obj->ext_click_pad.y1;\n    ext_area.y2 = obj->coords.y2 + obj->ext_click_pad.y2;\n\n    if(!_lv_area_is_point_on(&ext_area, point, 0)) {\n#else\n    if(!_lv_area_is_point_on(&obj->coords, point, 0)) {\n#endif\n        return false;\n    }\n    return true;\n}\n\n/**\n * Hit-test an object given a particular point in screen space.\n * @param obj object to hit-test\n * @param point screen-space point\n * @return true if the object is considered under the point\n */\nbool lv_obj_hittest(lv_obj_t * obj, lv_point_t * point)\n{\n    if(obj->adv_hittest) {\n        lv_hit_test_info_t hit_info;\n        hit_info.point = point;\n        hit_info.result = true;\n        obj->signal_cb(obj, LV_SIGNAL_HIT_TEST, &hit_info);\n        return hit_info.result;\n    }\n    else\n        return lv_obj_is_point_on_coords(obj, point);\n}\n\n/**\n * Used in the signal callback to handle `LV_SIGNAL_GET_TYPE` signal\n * @param obj pointer to an object\n * @param buf pointer to `lv_obj_type_t`. (`param` in the signal callback)\n * @param name name of the object. E.g. \"lv_btn\". (Only the pointer is saved)\n * @return LV_RES_OK\n */\nlv_res_t lv_obj_handle_get_type_signal(lv_obj_type_t * buf, const char * name)\n{\n    uint8_t i;\n    for(i = 0; i < LV_MAX_ANCESTOR_NUM - 1; i++) { /*Find the last set data*/\n        if(buf->type[i] == NULL) break;\n    }\n    buf->type[i] = name;\n\n    return LV_RES_OK;\n}\n\n/**\n * Initialize a rectangle descriptor from an object's styles\n * @param obj pointer to an object\n * @param type type of style. E.g.  `LV_OBJ_PART_MAIN`, `LV_BTN_STYLE_REL` or `LV_PAGE_STYLE_SCRL`\n * @param draw_dsc the descriptor the initialize\n * @note Only the relevant fields will be set.\n * E.g. if `border width == 0` the other border properties won't be evaluated.\n */\nvoid lv_obj_init_draw_rect_dsc(lv_obj_t * obj, uint8_t part, lv_draw_rect_dsc_t * draw_dsc)\n{\n    draw_dsc->radius = lv_obj_get_style_radius(obj, part);\n\n#if LV_USE_OPA_SCALE\n    lv_opa_t opa_scale = lv_obj_get_style_opa_scale(obj, part);\n    if(opa_scale <= LV_OPA_MIN) {\n        draw_dsc->bg_opa = LV_OPA_TRANSP;\n        draw_dsc->border_opa = LV_OPA_TRANSP;\n        draw_dsc->shadow_opa = LV_OPA_TRANSP;\n        draw_dsc->pattern_opa = LV_OPA_TRANSP;\n        draw_dsc->value_opa = LV_OPA_TRANSP;\n        return;\n    }\n#endif\n\n    if(draw_dsc->bg_opa != LV_OPA_TRANSP) {\n        draw_dsc->bg_opa = lv_obj_get_style_bg_opa(obj, part);\n        if(draw_dsc->bg_opa > LV_OPA_MIN) {\n            draw_dsc->bg_color = lv_obj_get_style_bg_color(obj, part);\n            draw_dsc->bg_grad_dir =  lv_obj_get_style_bg_grad_dir(obj, part);\n            if(draw_dsc->bg_grad_dir != LV_GRAD_DIR_NONE) {\n                draw_dsc->bg_grad_color = lv_obj_get_style_bg_grad_color(obj, part);\n                draw_dsc->bg_main_color_stop =  lv_obj_get_style_bg_main_stop(obj, part);\n                draw_dsc->bg_grad_color_stop =  lv_obj_get_style_bg_grad_stop(obj, part);\n            }\n\n#if LV_USE_BLEND_MODES\n            draw_dsc->bg_blend_mode = lv_obj_get_style_bg_blend_mode(obj, part);\n#endif\n        }\n    }\n\n    draw_dsc->border_width = lv_obj_get_style_border_width(obj, part);\n    if(draw_dsc->border_width) {\n        if(draw_dsc->border_opa != LV_OPA_TRANSP) {\n            draw_dsc->border_opa = lv_obj_get_style_border_opa(obj, part);\n            if(draw_dsc->border_opa > LV_OPA_MIN) {\n                draw_dsc->border_side = lv_obj_get_style_border_side(obj, part);\n                draw_dsc->border_color = lv_obj_get_style_border_color(obj, part);\n            }\n#if LV_USE_BLEND_MODES\n            draw_dsc->border_blend_mode = lv_obj_get_style_border_blend_mode(obj, part);\n#endif\n        }\n    }\n\n#if LV_USE_OUTLINE\n    draw_dsc->outline_width = lv_obj_get_style_outline_width(obj, part);\n    if(draw_dsc->outline_width) {\n        if(draw_dsc->outline_opa != LV_OPA_TRANSP) {\n            draw_dsc->outline_opa = lv_obj_get_style_outline_opa(obj, part);\n            if(draw_dsc->outline_opa > LV_OPA_MIN) {\n                draw_dsc->outline_pad = lv_obj_get_style_outline_pad(obj, part);\n                draw_dsc->outline_color = lv_obj_get_style_outline_color(obj, part);\n            }\n#if LV_USE_BLEND_MODES\n            draw_dsc->outline_blend_mode = lv_obj_get_style_outline_blend_mode(obj, part);\n#endif\n        }\n    }\n#endif\n\n#if LV_USE_PATTERN\n    draw_dsc->pattern_image = lv_obj_get_style_pattern_image(obj, part);\n    if(draw_dsc->pattern_image) {\n        if(draw_dsc->pattern_opa != LV_OPA_TRANSP) {\n            draw_dsc->pattern_opa = lv_obj_get_style_pattern_opa(obj, part);\n            if(draw_dsc->pattern_opa > LV_OPA_MIN) {\n                draw_dsc->pattern_recolor_opa = lv_obj_get_style_pattern_recolor_opa(obj, part);\n                draw_dsc->pattern_repeat = lv_obj_get_style_pattern_repeat(obj, part);\n                if(lv_img_src_get_type(draw_dsc->pattern_image) == LV_IMG_SRC_SYMBOL) {\n                    draw_dsc->pattern_recolor = lv_obj_get_style_pattern_recolor(obj, part);\n                    draw_dsc->pattern_font = lv_obj_get_style_text_font(obj, part);\n                }\n                else if(draw_dsc->pattern_recolor_opa > LV_OPA_MIN) {\n                    draw_dsc->pattern_recolor = lv_obj_get_style_pattern_recolor(obj, part);\n                }\n#if LV_USE_BLEND_MODES\n                draw_dsc->pattern_blend_mode = lv_obj_get_style_pattern_blend_mode(obj, part);\n#endif\n            }\n        }\n    }\n#endif\n\n#if LV_USE_SHADOW\n    draw_dsc->shadow_width = lv_obj_get_style_shadow_width(obj, part);\n    if(draw_dsc->shadow_width) {\n        if(draw_dsc->shadow_opa > LV_OPA_MIN) {\n            draw_dsc->shadow_opa = lv_obj_get_style_shadow_opa(obj, part);\n            if(draw_dsc->shadow_opa > LV_OPA_MIN) {\n                draw_dsc->shadow_ofs_x = lv_obj_get_style_shadow_ofs_x(obj, part);\n                draw_dsc->shadow_ofs_y = lv_obj_get_style_shadow_ofs_y(obj, part);\n                draw_dsc->shadow_spread = lv_obj_get_style_shadow_spread(obj, part);\n                draw_dsc->shadow_color = lv_obj_get_style_shadow_color(obj, part);\n#if LV_USE_BLEND_MODES\n                draw_dsc->shadow_blend_mode = lv_obj_get_style_shadow_blend_mode(obj, part);\n#endif\n            }\n        }\n    }\n#endif\n\n#if LV_USE_VALUE_STR\n    draw_dsc->value_str = lv_obj_get_style_value_str(obj, part);\n    if(draw_dsc->value_str) {\n        if(draw_dsc->value_opa > LV_OPA_MIN) {\n            draw_dsc->value_opa = lv_obj_get_style_value_opa(obj, part);\n            if(draw_dsc->value_opa > LV_OPA_MIN) {\n                draw_dsc->value_ofs_x = lv_obj_get_style_value_ofs_x(obj, part);\n                draw_dsc->value_ofs_y = lv_obj_get_style_value_ofs_y(obj, part);\n                draw_dsc->value_color = lv_obj_get_style_value_color(obj, part);\n                draw_dsc->value_font = lv_obj_get_style_value_font(obj, part);\n                draw_dsc->value_letter_space = lv_obj_get_style_value_letter_space(obj, part);\n                draw_dsc->value_line_space = lv_obj_get_style_value_line_space(obj, part);\n                draw_dsc->value_align = lv_obj_get_style_value_align(obj, part);\n#if LV_USE_BLEND_MODES\n                draw_dsc->value_blend_mode = lv_obj_get_style_value_blend_mode(obj, part);\n#endif\n            }\n        }\n    }\n#endif\n\n#if LV_USE_OPA_SCALE\n    if(opa_scale < LV_OPA_MAX) {\n        draw_dsc->bg_opa = (uint16_t)((uint16_t)draw_dsc->bg_opa * opa_scale) >> 8;\n        draw_dsc->border_opa = (uint16_t)((uint16_t)draw_dsc->border_opa * opa_scale) >> 8;\n        draw_dsc->shadow_opa = (uint16_t)((uint16_t)draw_dsc->shadow_opa * opa_scale) >> 8;\n        draw_dsc->pattern_opa = (uint16_t)((uint16_t)draw_dsc->pattern_opa * opa_scale) >> 8;\n        draw_dsc->value_opa = (uint16_t)((uint16_t)draw_dsc->value_opa * opa_scale) >> 8;\n    }\n#endif\n}\n\nvoid lv_obj_init_draw_label_dsc(lv_obj_t * obj, uint8_t part, lv_draw_label_dsc_t * draw_dsc)\n{\n    draw_dsc->opa = lv_obj_get_style_text_opa(obj, part);\n    if(draw_dsc->opa <= LV_OPA_MIN) return;\n\n#if LV_USE_OPA_SCALE\n    lv_opa_t opa_scale = lv_obj_get_style_opa_scale(obj, part);\n    if(opa_scale < LV_OPA_MAX) {\n        draw_dsc->opa = (uint16_t)((uint16_t)draw_dsc->opa * opa_scale) >> 8;\n    }\n    if(draw_dsc->opa <= LV_OPA_MIN) return;\n#endif\n\n    draw_dsc->color = lv_obj_get_style_text_color(obj, part);\n    draw_dsc->letter_space = lv_obj_get_style_text_letter_space(obj, part);\n    draw_dsc->line_space = lv_obj_get_style_text_line_space(obj, part);\n    draw_dsc->decor = lv_obj_get_style_text_decor(obj, part);\n#if LV_USE_BLEND_MODES\n    draw_dsc->blend_mode = lv_obj_get_style_text_blend_mode(obj, part);\n#endif\n\n    draw_dsc->font = lv_obj_get_style_text_font(obj, part);\n\n    if(draw_dsc->sel_start != LV_DRAW_LABEL_NO_TXT_SEL && draw_dsc->sel_end != LV_DRAW_LABEL_NO_TXT_SEL) {\n        draw_dsc->sel_color = lv_obj_get_style_text_sel_color(obj, part);\n        draw_dsc->sel_bg_color = lv_obj_get_style_text_sel_bg_color(obj, part);\n    }\n\n#if LV_USE_BIDI\n    draw_dsc->bidi_dir = lv_obj_get_base_dir(obj);\n#endif\n}\n\nvoid lv_obj_init_draw_img_dsc(lv_obj_t * obj, uint8_t part, lv_draw_img_dsc_t * draw_dsc)\n{\n    draw_dsc->opa = lv_obj_get_style_image_opa(obj, part);\n    if(draw_dsc->opa <= LV_OPA_MIN)  return;\n\n#if LV_USE_OPA_SCALE\n    lv_opa_t opa_scale = lv_obj_get_style_opa_scale(obj, part);\n    if(opa_scale < LV_OPA_MAX) {\n        draw_dsc->opa = (uint16_t)((uint16_t)draw_dsc->opa * opa_scale) >> 8;\n    }\n    if(draw_dsc->opa <= LV_OPA_MIN)  return;\n#endif\n\n    draw_dsc->angle = 0;\n    draw_dsc->zoom = LV_IMG_ZOOM_NONE;\n    draw_dsc->pivot.x = lv_area_get_width(&obj->coords) / 2;\n    draw_dsc->pivot.y = lv_area_get_height(&obj->coords) / 2;\n\n    draw_dsc->recolor_opa = lv_obj_get_style_image_recolor_opa(obj, part);\n    if(draw_dsc->recolor_opa > 0) {\n        draw_dsc->recolor = lv_obj_get_style_image_recolor(obj, part);\n    }\n#if LV_USE_BLEND_MODES\n    draw_dsc->blend_mode = lv_obj_get_style_image_blend_mode(obj, part);\n#endif\n}\n\nvoid lv_obj_init_draw_line_dsc(lv_obj_t * obj, uint8_t part, lv_draw_line_dsc_t * draw_dsc)\n{\n    draw_dsc->width = lv_obj_get_style_line_width(obj, part);\n    if(draw_dsc->width == 0) return;\n\n    draw_dsc->opa = lv_obj_get_style_line_opa(obj, part);\n    if(draw_dsc->opa <= LV_OPA_MIN)  return;\n\n#if LV_USE_OPA_SCALE\n    lv_opa_t opa_scale = lv_obj_get_style_opa_scale(obj, part);\n    if(opa_scale < LV_OPA_MAX) {\n        draw_dsc->opa = (uint16_t)((uint16_t)draw_dsc->opa * opa_scale) >> 8;\n    }\n    if(draw_dsc->opa <= LV_OPA_MIN)  return;\n#endif\n\n    draw_dsc->color = lv_obj_get_style_line_color(obj, part);\n\n    draw_dsc->dash_width = lv_obj_get_style_line_dash_width(obj, part);\n    if(draw_dsc->dash_width) {\n        draw_dsc->dash_gap = lv_obj_get_style_line_dash_gap(obj, part);\n    }\n\n    draw_dsc->round_start = lv_obj_get_style_line_rounded(obj, part);\n    draw_dsc->round_end = draw_dsc->round_start;\n\n#if LV_USE_BLEND_MODES\n    draw_dsc->blend_mode = lv_obj_get_style_line_blend_mode(obj, part);\n#endif\n}\n\n/**\n * Get the required extra size (around the object's part) to draw shadow, outline, value etc.\n * @param obj pointer to an object\n * @param part part of the object\n */\nlv_coord_t lv_obj_get_draw_rect_ext_pad_size(lv_obj_t * obj, uint8_t part)",
        "res_region": "lv_obj_t * lv_obj_get_focused_obj(const lv_obj_t * obj)",
        "lookback": "{",
        "lookahead": "{",
        "label": [
            "base",
            "complex_conflict"
        ],
        "start_line": 550,
        "end_line": 6100,
        "merge_gen_region": null,
        "confidence": 0.46324244141578674,
        "hesitated": true
    },
    {
        "a_contents": "    /*Delete the user data*/\n#if LV_USE_USER_DATA\n#if LV_USE_USER_DATA_FREE\n    LV_USER_DATA_FREE(obj);\n#endif\n#endif",
        "b_contents": "        if(parent->spec_attr->children == NULL) {\n            parent->spec_attr->children = lv_mem_alloc(sizeof(lv_obj_t *));\n            parent->spec_attr->children[0] = obj;\n            parent->spec_attr->child_cnt = 1;\n        } else {\n            parent->spec_attr->child_cnt++;\n            parent->spec_attr->children = lv_mem_realloc(parent->spec_attr->children, sizeof(lv_obj_t *) * parent->spec_attr->child_cnt);\n            parent->spec_attr->children[parent->spec_attr->child_cnt - 1] = obj;\n        }\n\n        obj->parent = parent;",
        "base_contents": "    /*Remove the animations from this object*/\n#if LV_USE_ANIMATION\n    lv_anim_del(obj, NULL);\n    trans_del(obj, 0xFF, 0xFF, NULL);\n#endif\n\n    /*Delete the user data*/\n#if LV_USE_USER_DATA\n#if LV_USE_USER_DATA_FREE\n    LV_USER_DATA_FREE(obj);\n#endif\n#endif",
        "res_region": "        if(parent->spec_attr->children == NULL) {\n            parent->spec_attr->children = lv_mem_alloc(sizeof(lv_obj_t *));\n            parent->spec_attr->children[0] = obj;\n            parent->spec_attr->child_cnt = 1;\n        } else {\n            parent->spec_attr->child_cnt++;\n            parent->spec_attr->children = lv_mem_realloc(parent->spec_attr->children, sizeof(lv_obj_t *) * parent->spec_attr->child_cnt);\n            parent->spec_attr->children[parent->spec_attr->child_cnt - 1] = obj;\n        }\n\n        obj->parent = parent;",
        "lookback": "            parent->spec_attr->children = lv_mem_alloc(sizeof(lv_obj_t *));",
        "lookahead": "",
        "label": [
            "base",
            "complex_conflict"
        ],
        "start_line": 6185,
        "end_line": 6217,
        "merge_gen_region": null,
        "confidence": 0.4700813889503479,
        "hesitated": true
    },
    {
        "a_contents": "    /*Remove the animations from this object*/\n#if LV_USE_ANIMATION\n    lv_anim_del(obj, NULL);\n    trans_del(obj, 0xFF, 0xFF, NULL);\n#endif\n\n    lv_event_mark_deleted(obj);",
        "b_contents": "    /*Set attributes*/\n    obj->flags = LV_OBJ_FLAG_CLICKABLE;\n    obj->flags |= LV_OBJ_FLAG_SNAPABLE;\n    if(parent) obj->flags |= LV_OBJ_FLAG_PRESS_LOCK;\n    if(parent) obj->flags |= LV_OBJ_FLAG_SCROLL_CHAIN;\n    if(parent) obj->flags |= LV_OBJ_FLAG_LAYOUTABLE;\n    obj->flags |= LV_OBJ_FLAG_CLICK_FOCUSABLE;\n    obj->flags |= LV_OBJ_FLAG_SCROLLABLE;\n    obj->flags |= LV_OBJ_FLAG_SCROLL_ELASTIC;\n    obj->flags |= LV_OBJ_FLAG_SCROLL_MOMENTUM;\n    obj->flags |= LV_OBJ_FLAG_SCROLL_ON_FOCUS;\n    if(parent) obj->flags |= LV_OBJ_FLAG_GESTURE_BUBBLE;\n\n    obj->style_list.cache_state = LV_OBJ_STYLE_CACHE_STATE_INVALID;\n\n    /*Copy the attributes if required*/\n    if(copy != NULL) {\n        lv_area_copy(&obj->coords, &copy->coords);",
        "base_contents": "    lv_event_mark_deleted(obj);",
        "res_region": "    /*Set attributes*/\n    obj->flags = LV_OBJ_FLAG_CLICKABLE;\n    obj->flags |= LV_OBJ_FLAG_SNAPABLE;\n    if(parent) obj->flags |= LV_OBJ_FLAG_PRESS_LOCK;\n    if(parent) obj->flags |= LV_OBJ_FLAG_SCROLL_CHAIN;\n    if(parent) obj->flags |= LV_OBJ_FLAG_LAYOUTABLE;\n    obj->flags |= LV_OBJ_FLAG_CLICK_FOCUSABLE;\n    obj->flags |= LV_OBJ_FLAG_SCROLLABLE;\n    obj->flags |= LV_OBJ_FLAG_SCROLL_ELASTIC;\n    obj->flags |= LV_OBJ_FLAG_SCROLL_MOMENTUM;\n    obj->flags |= LV_OBJ_FLAG_SCROLL_ON_FOCUS;\n    if(parent) obj->flags |= LV_OBJ_FLAG_GESTURE_BUBBLE;\n\n    obj->style_list.cache_state = LV_OBJ_STYLE_CACHE_STATE_INVALID;\n\n    /*Copy the attributes if required*/\n    if(copy != NULL) {\n        lv_area_copy(&obj->coords, &copy->coords);",
        "lookback": "    obj->flags = LV_OBJ_FLAG_CLICKABLE;",
        "lookahead": "",
        "label": [
            "base",
            "complex_conflict"
        ],
        "start_line": 6236,
        "end_line": 6265,
        "merge_gen_region": null,
        "confidence": 0.7314401865005493,
        "hesitated": true
    }
]