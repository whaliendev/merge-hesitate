[
    {
        "a_contents": "",
        "b_contents": "/**\n * Draw a rectangle\n * @param coords the coordinates of the rectangle\n * @param mask the rectangle will be drawn only in this mask\n * @param style pointer to a style\n */\nvoid lv_draw_rect(const lv_area_t * coords, const lv_area_t * mask, const lv_style_t * style)\n{\n    if(lv_area_get_height(coords) < 1 || lv_area_get_width(coords) < 1) return;\n\n#if USE_LV_SHADOW && LV_VDB_SIZE\n    if(style->body.shadow.width != 0) {\n        lv_draw_shadow(coords, mask, style);\n    }\n#endif\n    if(style->body.empty == 0) {\n        lv_draw_rect_main_mid(coords, mask, style);\n\n        if(style->body.radius != 0) {\n            lv_draw_rect_main_corner(coords, mask, style);\n        }\n    }\n\n    if(style->body.border.width != 0 && style->body.border.part != LV_BORDER_NONE) {\n        lv_draw_rect_border_straight(coords, mask, style);\n\n        if(style->body.radius != 0) {\n            lv_draw_rect_border_corner(coords, mask, style);\n        }\n    }\n}\n\n#if USE_LV_TRIANGLE != 0\n/**\n *\n * @param points pointer to an array with 3 points\n * @param mask the triangle will be drawn only in this mask\n * @param color color of the triangle\n */\nvoid lv_draw_triangle(const lv_point_t * points, const lv_area_t * mask, lv_color_t color)\n{\n    lv_point_t tri[3];\n\n    memcpy(tri, points, sizeof(tri));\n\n    /*Sort the vertices according to their y coordinate (0: y max, 1: y mid, 2:y min)*/\n    if(tri[1].y < tri[0].y) point_swap(&tri[1], &tri[0]);\n    if(tri[2].y < tri[1].y) point_swap(&tri[2], &tri[1]);\n    if(tri[1].y < tri[0].y) point_swap(&tri[1], &tri[0]);\n\n    /*Return is the triangle is degenerated*/\n    if(tri[0].x == tri[1].x && tri[0].y == tri[1].y) return;\n    if(tri[1].x == tri[2].x && tri[1].y == tri[2].y) return;\n    if(tri[0].x == tri[2].x && tri[0].y == tri[2].y) return;\n\n    if(tri[0].x == tri[1].x && tri[1].x == tri[2].x) return;\n    if(tri[0].y == tri[1].y && tri[1].y == tri[2].y) return;\n\n    /*Draw the triangle*/\n    lv_point_t edge1;\n    lv_coord_t dx1 = LV_MATH_ABS(tri[0].x - tri[1].x);\n    lv_coord_t sx1 = tri[0].x < tri[1].x ? 1 : -1;\n    lv_coord_t dy1 = LV_MATH_ABS(tri[0].y - tri[1].y);\n    lv_coord_t sy1 = tri[0].y < tri[1].y ? 1 : -1;\n    lv_coord_t err1 = (dx1 > dy1 ? dx1 : -dy1) / 2;\n    lv_coord_t err_tmp1;\n\n    lv_point_t edge2;\n    lv_coord_t dx2 = LV_MATH_ABS(tri[0].x - tri[2].x);\n    lv_coord_t sx2 = tri[0].x < tri[2].x ? 1 : -1;\n    lv_coord_t dy2 = LV_MATH_ABS(tri[0].y - tri[2].y);\n    lv_coord_t sy2 = tri[0].y < tri[2].y ? 1 : -1;\n    lv_coord_t err2 = (dx1 > dy2 ? dx2 : -dy2) / 2;\n    lv_coord_t err_tmp2;\n\n    lv_coord_t y1_tmp;\n    lv_coord_t y2_tmp;\n\n    edge1.x = tri[0].x;\n    edge1.y = tri[0].y;\n    edge2.x = tri[0].x;\n    edge2.y = tri[0].y;\n    lv_area_t act_area;\n    lv_area_t draw_area;\n\n    while(1) {\n        act_area.x1 = edge1.x;\n        act_area.x2 = edge2.x ;\n        act_area.y1 = edge1.y;\n        act_area.y2 = edge2.y ;\n\n\n        draw_area.x1 = LV_MATH_MIN(act_area.x1, act_area.x2);\n        draw_area.x2 = LV_MATH_MAX(act_area.x1, act_area.x2);\n        draw_area.y1 = LV_MATH_MIN(act_area.y1, act_area.y2);\n        draw_area.y2 = LV_MATH_MAX(act_area.y1, act_area.y2);\n        draw_area.x2--; /*Do not draw most right pixel because it will be drawn by the adjacent triangle*/\n        fill_fp(&draw_area, mask, color, LV_OPA_50);\n\n        /*Calc. the next point of edge1*/\n        y1_tmp = edge1.y;\n        do {\n            if(edge1.x == tri[1].x && edge1.y == tri[1].y) {\n\n                dx1 = LV_MATH_ABS(tri[1].x - tri[2].x);\n                sx1 = tri[1].x < tri[2].x ? 1 : -1;\n                dy1 = LV_MATH_ABS(tri[1].y - tri[2].y);\n                sy1 = tri[1].y < tri[2].y ? 1 : -1;\n                err1 = (dx1 > dy1 ? dx1 : -dy1) / 2;\n            } else if(edge1.x == tri[2].x && edge1.y == tri[2].y) return;\n            err_tmp1 = err1;\n            if(err_tmp1 > -dx1) {\n                err1 -= dy1;\n                edge1.x += sx1;\n            }\n            if(err_tmp1 < dy1) {\n                err1 += dx1;\n                edge1.y += sy1;\n            }\n        } while(edge1.y == y1_tmp);\n\n        /*Calc. the next point of edge2*/\n        y2_tmp = edge2.y;\n        do {\n            if(edge2.x == tri[2].x && edge2.y == tri[2].y) return;\n            err_tmp2 = err2;\n            if(err_tmp2 > -dx2) {\n                err2 -= dy2;\n                edge2.x += sx2;\n            }\n            if(err_tmp2 < dy2) {\n                err2 += dx2;\n                edge2.y += sy2;\n            }\n        } while(edge2.y == y2_tmp);\n    }\n}\n#endif\n\n/**\n * Write a text\n * @param coords coordinates of the label\n * @param mask the label will be drawn only in this area\n * @param style pointer to a style\n * @param txt 0 terminated text to write\n * @param flag settings for the text from 'txt_flag_t' enum\n * @param offset text offset in x and y direction (NULL if unused)\n *\n */\nvoid lv_draw_label(const lv_area_t * coords, const lv_area_t * mask, const lv_style_t * style,\n                   const char * txt, lv_txt_flag_t flag, lv_point_t * offset)\n{\n\n    const lv_font_t * font = style->text.font;\n    lv_coord_t w;\n    if((flag & LV_TXT_FLAG_EXPAND) == 0) {\n        w = lv_area_get_width(coords);\n    } else {\n        lv_point_t p;\n        lv_txt_get_size(&p, txt, style->text.font, style->text.letter_space, style->text.line_space, LV_COORD_MAX, flag);\n        w = p.x;\n    }\n\n    /*Init variables for the first line*/\n    lv_coord_t line_widht = 0;\n    uint32_t line_start = 0;\n    uint32_t line_end = lv_txt_get_next_line(txt, font, style->text.letter_space, w, flag);\n\n    lv_point_t pos;\n    pos.x = coords->x1;\n    pos.y = coords->y1;\n\n    /*Align the line to middle if enabled*/\n    if(flag & LV_TXT_FLAG_CENTER) {\n        line_widht = lv_txt_get_width(&txt[line_start], line_end - line_start,\n                                       font, style->text.letter_space, flag);\n        /*Trim closing spaces.*/\n        uint16_t i;\n\t\tfor(i = line_end - 1; i > 0; i--) {\n\t\t\tif(txt[i] == ' ' || txt[i] == '\\n' || txt[i] == '\\r') {\n\t\t\t\tline_widht -= lv_font_get_width(font, txt[i]);\n\t\t\t\tline_widht -= style->text.letter_space;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n        pos.x += (w - line_widht) / 2;\n    }\n\n    cmd_state_t cmd_state = CMD_STATE_WAIT;\n    uint32_t i;\n    uint16_t par_start = 0;\n    lv_color_t recolor;\n    lv_coord_t letter_w;\n\n    lv_coord_t x_ofs = 0;\n    lv_coord_t y_ofs = 0;\n    if(offset != NULL) {\n        x_ofs = offset->x;\n        y_ofs = offset->y;\n        pos.y += y_ofs;\n    }\n\n    /*Real draw need a background color for higher bpp letter*/\n#if LV_VDB_SIZE == 0\n    lv_rletter_set_background(style->body.main_color);\n#endif\n\n    /*Write out all lines*/\n    while(txt[line_start] != '\\0') {\n        if(offset != NULL) {\n            pos.x += x_ofs;\n        }\n        /*Write all letter of a line*/\n        cmd_state = CMD_STATE_WAIT;\n        i = line_start;\n        uint32_t letter;\n        while(i < line_end) {\n            letter = lv_txt_utf8_next(txt, &i);\n            /*Handle the re-color command*/\n            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {\n                if(letter == (uint32_t)LV_TXT_COLOR_CMD[0]) {\n                    if(cmd_state == CMD_STATE_WAIT) { /*Start char*/\n                        par_start = i;// + lv_txt_utf8_size(txt[i]);\n                        cmd_state = CMD_STATE_PAR;\n                        continue;\n                    } else if(cmd_state == CMD_STATE_PAR) { /*Other start char in parameter escaped cmd. char */\n                        cmd_state = CMD_STATE_WAIT;\n                    } else if(cmd_state == CMD_STATE_IN) { /*Command end */\n                        cmd_state = CMD_STATE_WAIT;\n                        continue;\n                    }\n                }\n\n                /*Skip the color parameter and wait the space after it*/\n                if(cmd_state == CMD_STATE_PAR) {\n                    if(letter == ' ') {\n                        /*Get the parameter*/\n                        if(i - par_start == LABEL_RECOLOR_PAR_LENGTH + 1) {\n                            char buf[LABEL_RECOLOR_PAR_LENGTH + 1];\n                            memcpy(buf, &txt[par_start], LABEL_RECOLOR_PAR_LENGTH);\n                            buf[LABEL_RECOLOR_PAR_LENGTH] = '\\0';\n                            int r, g, b;\n                            r = (hex_char_to_num(buf[0]) << 4) + hex_char_to_num(buf[1]);\n                            g = (hex_char_to_num(buf[2]) << 4) + hex_char_to_num(buf[3]);\n                            b = (hex_char_to_num(buf[4]) << 4) + hex_char_to_num(buf[5]);\n                            recolor = LV_COLOR_MAKE(r, g, b);\n                        } else {\n                            recolor.full = style->text.color.full;\n                        }\n                        cmd_state = CMD_STATE_IN; /*After the parameter the text is in the command*/\n                    }\n                    continue;\n                }\n            }\n\n            lv_color_t color = style->text.color;\n\n            if(cmd_state == CMD_STATE_IN) color = recolor;\n\n            letter_fp(&pos, mask, font, letter, color, style->text.opa);\n            letter_w = lv_font_get_width(font, letter);\n\n            pos.x += letter_w + style->text.letter_space;\n        }\n        /*Go to next line*/\n        line_start = line_end;\n        line_end += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, w, flag);\n\n        pos.x = coords->x1;\n        /*Align to middle*/\n        if(flag & LV_TXT_FLAG_CENTER) {\n            line_widht = lv_txt_get_width(&txt[line_start], line_end - line_start,\n                                           font, style->text.letter_space, flag);\n            /*Trim closing spaces.*/\n            uint16_t i;\n    \t\tfor(i = line_end - 1; i > line_start; i--) {\n    \t\t\tif(txt[i] == ' ' || txt[i] == '\\n' || txt[i] == '\\r') {\n    \t\t\t\tline_widht -= lv_font_get_width(font, txt[i]);\n    \t\t\t\tline_widht -= style->text.letter_space;\n    \t\t\t} else {\n    \t\t\t\tbreak;\n    \t\t\t}\n    \t\t}\n            pos.x += (w - line_widht) / 2;\n        }\n        /*Go the next line position*/\n        pos.y += lv_font_get_height(font);\n        pos.y += style->text.line_space;\n    }\n}\n\n#if USE_LV_IMG\n/**\n * Draw an image\n * @param coords the coordinates of the image\n * @param mask the image will be drawn only in this area\n * @param map_p pointer to a lv_color_t array which contains the pixels of the image\n * @param opa opacity of the image (0..255)\n */\nvoid lv_draw_img(const lv_area_t * coords, const lv_area_t * mask,\n                 const lv_style_t * style, const void * src)\n{\n\n    if(src == NULL) {\n        lv_draw_rect(coords, mask, &lv_style_plain);\n        lv_draw_label(coords, mask, &lv_style_plain, \"No\\ndata\", LV_TXT_FLAG_NONE, NULL);\n        return;\n    }\n\n    const uint8_t * u8_p = (uint8_t *) src;\n    if(u8_p[0] >= 'A' &&  u8_p[0] <= 'Z') { /*It will be a path of a file*/\n#if USE_LV_FILESYSTEM\n        lv_fs_file_t file;\n        lv_fs_res_t res = lv_fs_open(&file, src, LV_FS_MODE_RD);\n        if(res == LV_FS_RES_OK) {\n            lv_img_t img_data;\n            uint32_t br;\n            res = lv_fs_read(&file, &img_data, sizeof(lv_img_t), &br);\n\n            lv_area_t mask_com;    /*Common area of mask and cords*/\n            bool union_ok;\n            union_ok = lv_area_union(&mask_com, mask, coords);\n            if(union_ok == false) {\n                lv_fs_close(&file);\n                return;\n            }\n\n            uint8_t px_size = 0;\n            switch(img_data.header.format) {\n                case LV_IMG_FORMAT_FILE_RAW_RGB332:\n                    px_size = 1;\n                    break;\n                case LV_IMG_FORMAT_FILE_RAW_RGB565:\n                    px_size = 2;\n                    break;\n                case LV_IMG_FORMAT_FILE_RAW_RGB888:\n                    px_size = 4;\n                    break;\n                default:\n                    return;\n            }\n\n            if(img_data.header.alpha_byte) {    /*Correction with the alpha byte*/\n                px_size++;\n                if(img_data.header.format == LV_IMG_FORMAT_FILE_RAW_RGB888) px_size--; /*Stored in the 4 byte anyway*/\n            }\n\n\n            /* Move the file pointer to the start address according to mask*/\n            uint32_t start_offset = sizeof(img_data.header);\n            start_offset += (lv_area_get_width(coords)) * (mask_com.y1 - coords->y1) * px_size;      /*First row*/\n            start_offset += (mask_com.x1 - coords->x1) * px_size;                                    /*First col*/\n            lv_fs_seek(&file, start_offset);\n\n            uint32_t useful_data = lv_area_get_width(&mask_com) * px_size;\n            uint32_t next_row = lv_area_get_width(coords) * px_size - useful_data;\n\n            lv_area_t line;\n            lv_area_copy(&line, &mask_com);\n            lv_area_set_height(&line, 1);\n\n            lv_coord_t row;\n            uint32_t act_pos;\n#if LV_COMPILER_VLA_SUPPORTED\n            uint8_t buf[lv_area_get_width(&mask_com) * px_size];\n#else\n# if LV_HOR_RES > LV_VER_RES\n            uint8_t buf[LV_HOR_RES * px_size];\n# else\n            uint8_t buf[LV_VER_RES * px_size];\n# endif\n#endif\n            for(row = mask_com.y1; row <= mask_com.y2; row ++) {\n                res = lv_fs_read(&file, buf, useful_data, &br);\n\n                map_fp(&line, &mask_com, (uint8_t *)buf, style->image.opa, img_data.header.chroma_keyed, img_data.header.alpha_byte,\n                       style->image.color, style->image.intense);\n\n                lv_fs_tell(&file, &act_pos);\n                lv_fs_seek(&file, act_pos + next_row);\n                line.y1++;    /*Go down a line*/\n                line.y2++;\n            }\n\n            lv_fs_close(&file);\n\n            if(res != LV_FS_RES_OK) {\n                lv_draw_rect(coords, mask, &lv_style_plain);\n                lv_draw_label(coords, mask, &lv_style_plain, \"No data\", LV_TXT_FLAG_NONE, NULL);\n            }\n        }\n#endif\n    } else {\n        const lv_img_t * img_var = src;\n        lv_area_t mask_com;    /*Common area of mask and coords*/\n        bool union_ok;\n        union_ok = lv_area_union(&mask_com, mask, coords);\n        if(union_ok == false) {\n            return;         /*Out of mask*/\n        }\n\n        map_fp(coords, mask, img_var->pixel_map, style->image.opa, img_var->header.chroma_keyed, img_var->header.alpha_byte, style->image.color, style->image.intense);\n\n    }\n\n}\n#endif\n\n\n/**\n * Draw a line\n * @param p1 first point of the line\n * @param p2 second point of the line\n * @param maskthe line will be drawn only on this area\n * @param lines_p pointer to a line style\n */\nvoid lv_draw_line(const lv_point_t * point1, const lv_point_t * point2, const lv_area_t * mask,\n                  const lv_style_t * style)\n{\n\n    if(style->line.width == 0) return;\n    if(point1->x == point2->x && point1->y == point2->y) return;\n\n    lv_point_t p1;\n    lv_point_t p2;\n\n    /*Be sure always x1 < x2*/\n    if(point1->x < point2->x) {\n        p1.x = point1->x;\n        p1.y = point1->y;\n        p2.x = point2->x;\n        p2.y = point2->y;\n    } else {\n        p1.x = point2->x;\n        p1.y = point2->y;\n        p2.x = point1->x;\n        p2.y = point1->y;\n    }\n\n    lv_coord_t dx = LV_MATH_ABS(p2.x - p1.x);\n    lv_coord_t sx = p1.x < p2.x ? 1 : -1;\n    lv_coord_t dy = LV_MATH_ABS(p2.y - p1.y);\n    lv_coord_t sy = p1.y < p2.y ? 1 : -1;\n    lv_coord_t err = (dx > dy ? dx : -dy) / 2;\n    lv_coord_t e2;\n    bool hor = dx > dy ? true : false;  /*Rather horizontal or vertical*/\n    lv_coord_t last_x = p1.x;\n    lv_coord_t last_y = p1.y;\n    lv_point_t act_point;\n    act_point.x = p1.x;\n    act_point.y = p1.y;\n\n\n    lv_coord_t width;\n    uint16_t wcor;\n    uint16_t width_half = 0;\n    uint16_t width_1 = 0;\n    static const uint8_t width_corr_array[] = {\n        64, 64, 64, 64, 64, 64, 64, 64, 64, 65, 65, 65, 65, 65, 66, 66, 66, 66, 66,\n        67, 67, 67, 68, 68, 68, 69, 69, 69, 70, 70, 71, 71, 72, 72, 72, 73, 73, 74,\n        74, 75, 75, 76, 77, 77, 78, 78, 79, 79, 80, 81, 81, 82, 82, 83, 84, 84, 85,\n        86, 86, 87, 88, 88, 89, 90, 91,\n    };\n\n    if(hor == false) {\n        wcor = (dx * LINE_WIDTH_CORR_BASE) / dy;\n    } else  {\n        wcor = (dy * LINE_WIDTH_CORR_BASE) / dx;\n    }\n\n\n    width = style->line.width - 1;\n\n#if LV_ANTIALIAS != 0\n    bool aa_invert = false;\n    aa_invert = p1.y < p2.y ? false : true;      /*Direction of opacity increase on the edges*/\n    if(p1.x != p2.x && p1.y != p2.y) width--;    /*Because of anti aliasing (no anti aliasing on hor. and ver. lines)*/\n#endif\n\n    /*Make the correction on lie width*/\n    if(width > 0) {\n        width = (width * width_corr_array[wcor]);\n        width = width >> LINE_WIDTH_CORR_SHIFT;\n        width_half = width >> 1;\n        width_1 = width & 0x1 ? 1 : 0;\n    }\n\n    /*Special case draw a horizontal line*/\n    if(p1.y == p2.y) {\n        lv_area_t act_area;\n        act_area.x1 = p1.x;\n        act_area.x2 = p2.x;\n        act_area.y1 = p1.y - width_half - width_1;\n        act_area.y2 = p2.y + width_half ;\n\n        lv_area_t draw_area;\n        draw_area.x1 = LV_MATH_MIN(act_area.x1, act_area.x2);\n        draw_area.x2 = LV_MATH_MAX(act_area.x1, act_area.x2);\n        draw_area.y1 = LV_MATH_MIN(act_area.y1, act_area.y2);\n        draw_area.y2 = LV_MATH_MAX(act_area.y1, act_area.y2);\n        fill_fp(&draw_area, mask, style->line.color, style->line.opa);\n\n        return;\n    }\n\n    /*Special case draw a vertical line*/\n    if(p1.x == p2.x) {\n        lv_area_t act_area;\n        act_area.x1 = p1.x - width_half;\n        act_area.x2 = p2.x + width_half + width_1;\n        act_area.y1 = p1.y;\n        act_area.y2 = p2.y;\n\n        lv_area_t draw_area;\n        draw_area.x1 = LV_MATH_MIN(act_area.x1, act_area.x2);\n        draw_area.x2 = LV_MATH_MAX(act_area.x1, act_area.x2);\n        draw_area.y1 = LV_MATH_MIN(act_area.y1, act_area.y2);\n        draw_area.y2 = LV_MATH_MAX(act_area.y1, act_area.y2);\n        fill_fp(&draw_area, mask, style->line.color, style->line.opa);\n        return;\n    }\n\n\n    while(1) {\n        if(hor == true && last_y != act_point.y) {\n            lv_area_t act_area;\n            lv_area_t draw_area;\n            act_area.x1 = last_x;\n            act_area.x2 = act_point.x - sx;\n            act_area.y1 = last_y - width_half ;\n            act_area.y2 = act_point.y - sy  + width_half + width_1;\n            last_y = act_point.y;\n            last_x = act_point.x;\n            draw_area.x1 = LV_MATH_MIN(act_area.x1, act_area.x2);\n            draw_area.x2 = LV_MATH_MAX(act_area.x1, act_area.x2);\n            draw_area.y1 = LV_MATH_MIN(act_area.y1, act_area.y2);\n            draw_area.y2 = LV_MATH_MAX(act_area.y1, act_area.y2);\n            if(width >= 0) {\n                fill_fp(&draw_area, mask, style->line.color, style->line.opa);\n            }\n\n#if LV_ANTIALIAS != 0\n            lv_coord_t seg_w = lv_area_get_width(&draw_area);  /*Segment width*/\n            lv_point_t aa_p1;\n            lv_point_t aa_p2;\n\n            aa_p1.x = draw_area.x1;\n            aa_p1.y = draw_area.y1 - 1;\n\n            aa_p2.x = draw_area.x1;\n            aa_p2.y = draw_area.y1 + width + 1;\n\n            lv_coord_t i;\n            for(i = 0; i  < seg_w; i++) {\n                lv_opa_t aa_opa = antialias_get_opa(seg_w, i, style->line.opa);\n\n                px_fp(aa_p1.x + i, aa_p1.y, mask, style->line.color, aa_invert ? aa_opa : style->line.opa - aa_opa);\n                px_fp(aa_p2.x + i, aa_p2.y, mask, style->line.color, aa_invert ? style->line.opa - aa_opa :  aa_opa);\n            }\n#endif\n        }\n        if(hor == false && last_x != act_point.x) {\n            lv_area_t act_area;\n            lv_area_t draw_area;\n            act_area.x1 = last_x - width_half;\n            act_area.x2 = act_point.x  - sx + width_half + width_1;\n            act_area.y1 = last_y ;\n            act_area.y2 = act_point.y - sy;\n            last_y = act_point.y;\n            last_x = act_point.x;\n\n            draw_area.x1 = LV_MATH_MIN(act_area.x1, act_area.x2);\n            draw_area.x2 = LV_MATH_MAX(act_area.x1, act_area.x2);\n            draw_area.y1 = LV_MATH_MIN(act_area.y1, act_area.y2);\n            draw_area.y2 = LV_MATH_MAX(act_area.y1, act_area.y2);\n            if(width >= 0) {\n                fill_fp(&draw_area, mask, style->line.color, style->line.opa);\n            }\n\n#if LV_ANTIALIAS != 0\n            lv_coord_t seg_h = lv_area_get_height(&draw_area);  /*Segment height*/\n            lv_point_t aa_p1;\n            lv_point_t aa_p2;\n\n            aa_p1.x = draw_area.x1 - 1;\n            aa_p1.y = draw_area.y1;\n\n            aa_p2.x = draw_area.x1 + width + 1;\n            aa_p2.y = draw_area.y1;\n\n            lv_coord_t i;\n            for(i = 0; i  < seg_h; i++) {\n                lv_opa_t aa_opa = antialias_get_opa(seg_h, i, style->line.opa);\n\n                px_fp(aa_p1.x, aa_p1.y + i, mask, style->line.color, aa_invert ? aa_opa : style->line.opa - aa_opa);\n                px_fp(aa_p2.x, aa_p2.y + i, mask, style->line.color, aa_invert ? style->line.opa - aa_opa :  aa_opa);\n            }\n#endif\n        }\n\n        /*Calc. the next point of the line*/\n        if(act_point.x == p2.x && act_point.y == p2.y) break;\n        e2 = err;\n        if(e2 > -dx) {\n            err -= dy;\n            act_point.x += sx;\n        }\n        if(e2 < dy) {\n            err += dx;\n            act_point.y += sy;\n        }\n    }\n\n    /*Draw the last part of the line*/\n    if(hor == true) {\n        lv_area_t act_area;\n        lv_area_t draw_area;\n        act_area.x1 = last_x;\n        act_area.x2 = act_point.x;\n        act_area.y1 = last_y - width_half ;\n        act_area.y2 = act_point.y + width_half + width_1;\n\n        draw_area.x1 = LV_MATH_MIN(act_area.x1, act_area.x2);\n        draw_area.x2 = LV_MATH_MAX(act_area.x1, act_area.x2);\n        draw_area.y1 = LV_MATH_MIN(act_area.y1, act_area.y2);\n        draw_area.y2 = LV_MATH_MAX(act_area.y1, act_area.y2);\n        if(width >= 0) {\n            fill_fp(&draw_area, mask, style->line.color, style->line.opa);\n        }\n\n#if LV_ANTIALIAS != 0\n        lv_coord_t seg_w = lv_area_get_width(&draw_area);  /*Segment width*/\n        lv_point_t aa_p1;\n        lv_point_t aa_p2;\n\n        aa_p1.x = draw_area.x1;\n        aa_p1.y = draw_area.y1 - 1;\n\n        aa_p2.x = draw_area.x1;\n        aa_p2.y = draw_area.y1 + width + 1;\n\n        lv_coord_t i;\n        for(i = 0; i  < seg_w; i++) {\n            lv_opa_t aa_opa = antialias_get_opa(seg_w, i, style->line.opa);\n\n            px_fp(aa_p1.x + i, aa_p1.y, mask, style->line.color, aa_invert ? aa_opa : style->line.opa - aa_opa);\n            px_fp(aa_p2.x + i, aa_p2.y, mask, style->line.color, aa_invert ? style->line.opa - aa_opa :  aa_opa);\n        }\n#endif\n\n    }\n    if(hor == false) {\n        lv_area_t act_area;\n        lv_area_t draw_area;\n        act_area.x1 = last_x - width_half;\n        act_area.x2 = act_point.x + width_half + width_1;\n        act_area.y1 = last_y;\n        act_area.y2 = act_point.y;\n\n        draw_area.x1 = LV_MATH_MIN(act_area.x1, act_area.x2);\n        draw_area.x2 = LV_MATH_MAX(act_area.x1, act_area.x2);\n        draw_area.y1 = LV_MATH_MIN(act_area.y1, act_area.y2);\n        draw_area.y2 = LV_MATH_MAX(act_area.y1, act_area.y2);\n        if(width >= 0) {\n            fill_fp(&draw_area, mask, style->line.color, style->line.opa);\n        }\n\n#if LV_ANTIALIAS != 0\n        lv_coord_t seg_h = lv_area_get_height(&draw_area);  /*Segment height*/\n        lv_point_t aa_p1;\n        lv_point_t aa_p2;\n\n        aa_p1.x = draw_area.x1 - 1;\n        aa_p1.y = draw_area.y1;\n\n        aa_p2.x = draw_area.x1 + width + 1;\n        aa_p2.y = draw_area.y1;\n\n        lv_coord_t i;\n        for(i = 0; i  < seg_h; i++) {\n            lv_opa_t aa_opa = antialias_get_opa(seg_h, i, style->line.opa);\n\n            px_fp(aa_p1.x, aa_p1.y + i, mask, style->line.color, aa_invert ? aa_opa : style->line.opa - aa_opa);\n            px_fp(aa_p2.x, aa_p2.y + i, mask, style->line.color, aa_invert ? style->line.opa - aa_opa :  aa_opa);\n        }\n#endif\n    }\n}\n\n",
        "base_contents": "/**\n * Draw a rectangle\n * @param coords the coordinates of the rectangle\n * @param mask the rectangle will be drawn only in this mask\n * @param style pointer to a style\n */\nvoid lv_draw_rect(const lv_area_t * coords, const lv_area_t * mask, const lv_style_t * style)\n{\n    if(lv_area_get_height(coords) < 1 || lv_area_get_width(coords) < 1) return;\n\n#if USE_LV_SHADOW && LV_VDB_SIZE\n    if(style->body.shadow.width != 0) {\n        lv_draw_shadow(coords, mask, style);\n    }\n#endif\n    if(style->body.empty == 0) {\n        lv_draw_rect_main_mid(coords, mask, style);\n\n        if(style->body.radius != 0) {\n            lv_draw_rect_main_corner(coords, mask, style);\n        }\n    }\n\n    if(style->body.border.width != 0 && style->body.border.part != LV_BORDER_NONE) {\n        lv_draw_rect_border_straight(coords, mask, style);\n\n        if(style->body.radius != 0) {\n            lv_draw_rect_border_corner(coords, mask, style);\n        }\n    }\n}\n\n#if USE_LV_TRIANGLE != 0\n/**\n *\n * @param points pointer to an array with 3 points\n * @param mask the triangle will be drawn only in this mask\n * @param color color of the triangle\n */\nvoid lv_draw_triangle(const lv_point_t * points, const lv_area_t * mask, lv_color_t color)\n{\n    lv_point_t tri[3];\n\n    memcpy(tri, points, sizeof(tri));\n\n    /*Sort the vertices according to their y coordinate (0: y max, 1: y mid, 2:y min)*/\n    if(tri[1].y < tri[0].y) point_swap(&tri[1], &tri[0]);\n    if(tri[2].y < tri[1].y) point_swap(&tri[2], &tri[1]);\n    if(tri[1].y < tri[0].y) point_swap(&tri[1], &tri[0]);\n\n    /*Return is the triangle is degenerated*/\n    if(tri[0].x == tri[1].x && tri[0].y == tri[1].y) return;\n    if(tri[1].x == tri[2].x && tri[1].y == tri[2].y) return;\n    if(tri[0].x == tri[2].x && tri[0].y == tri[2].y) return;\n\n    if(tri[0].x == tri[1].x && tri[1].x == tri[2].x) return;\n    if(tri[0].y == tri[1].y && tri[1].y == tri[2].y) return;\n\n    /*Draw the triangle*/\n    lv_point_t edge1;\n    lv_coord_t dx1 = LV_MATH_ABS(tri[0].x - tri[1].x);\n    lv_coord_t sx1 = tri[0].x < tri[1].x ? 1 : -1;\n    lv_coord_t dy1 = LV_MATH_ABS(tri[0].y - tri[1].y);\n    lv_coord_t sy1 = tri[0].y < tri[1].y ? 1 : -1;\n    lv_coord_t err1 = (dx1 > dy1 ? dx1 : -dy1) / 2;\n    lv_coord_t err_tmp1;\n\n    lv_point_t edge2;\n    lv_coord_t dx2 = LV_MATH_ABS(tri[0].x - tri[2].x);\n    lv_coord_t sx2 = tri[0].x < tri[2].x ? 1 : -1;\n    lv_coord_t dy2 = LV_MATH_ABS(tri[0].y - tri[2].y);\n    lv_coord_t sy2 = tri[0].y < tri[2].y ? 1 : -1;\n    lv_coord_t err2 = (dx1 > dy2 ? dx2 : -dy2) / 2;\n    lv_coord_t err_tmp2;\n\n    lv_coord_t y1_tmp;\n    lv_coord_t y2_tmp;\n\n    edge1.x = tri[0].x;\n    edge1.y = tri[0].y;\n    edge2.x = tri[0].x;\n    edge2.y = tri[0].y;\n    lv_area_t act_area;\n    lv_area_t draw_area;\n\n    while(1) {\n        act_area.x1 = edge1.x;\n        act_area.x2 = edge2.x ;\n        act_area.y1 = edge1.y;\n        act_area.y2 = edge2.y ;\n\n\n        draw_area.x1 = LV_MATH_MIN(act_area.x1, act_area.x2);\n        draw_area.x2 = LV_MATH_MAX(act_area.x1, act_area.x2);\n        draw_area.y1 = LV_MATH_MIN(act_area.y1, act_area.y2);\n        draw_area.y2 = LV_MATH_MAX(act_area.y1, act_area.y2);\n        draw_area.x2--; /*Do not draw most right pixel because it will be drawn by the adjacent triangle*/\n        fill_fp(&draw_area, mask, color, LV_OPA_50);\n\n        /*Calc. the next point of edge1*/\n        y1_tmp = edge1.y;\n        do {\n            if(edge1.x == tri[1].x && edge1.y == tri[1].y) {\n\n                dx1 = LV_MATH_ABS(tri[1].x - tri[2].x);\n                sx1 = tri[1].x < tri[2].x ? 1 : -1;\n                dy1 = LV_MATH_ABS(tri[1].y - tri[2].y);\n                sy1 = tri[1].y < tri[2].y ? 1 : -1;\n                err1 = (dx1 > dy1 ? dx1 : -dy1) / 2;\n            } else if(edge1.x == tri[2].x && edge1.y == tri[2].y) return;\n            err_tmp1 = err1;\n            if(err_tmp1 > -dx1) {\n                err1 -= dy1;\n                edge1.x += sx1;\n            }\n            if(err_tmp1 < dy1) {\n                err1 += dx1;\n                edge1.y += sy1;\n            }\n        } while(edge1.y == y1_tmp);\n\n        /*Calc. the next point of edge2*/\n        y2_tmp = edge2.y;\n        do {\n            if(edge2.x == tri[2].x && edge2.y == tri[2].y) return;\n            err_tmp2 = err2;\n            if(err_tmp2 > -dx2) {\n                err2 -= dy2;\n                edge2.x += sx2;\n            }\n            if(err_tmp2 < dy2) {\n                err2 += dx2;\n                edge2.y += sy2;\n            }\n        } while(edge2.y == y2_tmp);\n    }\n}\n#endif\n\n/**\n * Write a text\n * @param coords coordinates of the label\n * @param mask the label will be drawn only in this area\n * @param style pointer to a style\n * @param txt 0 terminated text to write\n * @param flag settings for the text from 'txt_flag_t' enum\n * @param offset text offset in x and y direction (NULL if unused)\n *\n */\nvoid lv_draw_label(const lv_area_t * coords, const lv_area_t * mask, const lv_style_t * style,\n                   const char * txt, lv_txt_flag_t flag, lv_point_t * offset)\n{\n\n    const lv_font_t * font = style->text.font;\n    lv_coord_t w;\n    if((flag & LV_TXT_FLAG_EXPAND) == 0) {\n        w = lv_area_get_width(coords);\n    } else {\n        lv_point_t p;\n        lv_txt_get_size(&p, txt, style->text.font, style->text.letter_space, style->text.line_space, LV_COORD_MAX, flag);\n        w = p.x;\n    }\n\n    /*Init variables for the first line*/\n    lv_coord_t line_length = 0;\n    uint32_t line_start = 0;\n    uint32_t line_end = lv_txt_get_next_line(txt, font, style->text.letter_space, w, flag);\n\n    lv_point_t pos;\n    pos.x = coords->x1;\n    pos.y = coords->y1;\n\n    /*Align the line to middle if enabled*/\n    if(flag & LV_TXT_FLAG_CENTER) {\n        line_length = lv_txt_get_width(&txt[line_start], line_end - line_start,\n                                       font, style->text.letter_space, flag);\n        pos.x += (w - line_length) / 2;\n    }\n\n    cmd_state_t cmd_state = CMD_STATE_WAIT;\n    uint32_t i;\n    uint16_t par_start = 0;\n    lv_color_t recolor;\n    lv_coord_t letter_w;\n\n    lv_coord_t x_ofs = 0;\n    lv_coord_t y_ofs = 0;\n    if(offset != NULL) {\n        x_ofs = offset->x;\n        y_ofs = offset->y;\n        pos.y += y_ofs;\n    }\n\n    /*Real draw need a background color for higher bpp letter*/\n#if LV_VDB_SIZE == 0\n    lv_rletter_set_background(style->body.main_color);\n#endif\n\n    /*Write out all lines*/\n    while(txt[line_start] != '\\0') {\n        if(offset != NULL) {\n            pos.x += x_ofs;\n        }\n        /*Write all letter of a line*/\n        cmd_state = CMD_STATE_WAIT;\n        i = line_start;\n        uint32_t letter;\n        while(i < line_end) {\n            letter = lv_txt_utf8_next(txt, &i);\n            /*Handle the re-color command*/\n            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {\n                if(letter == (uint32_t)LV_TXT_COLOR_CMD[0]) {\n                    if(cmd_state == CMD_STATE_WAIT) { /*Start char*/\n                        par_start = i;// + lv_txt_utf8_size(txt[i]);\n                        cmd_state = CMD_STATE_PAR;\n                        continue;\n                    } else if(cmd_state == CMD_STATE_PAR) { /*Other start char in parameter escaped cmd. char */\n                        cmd_state = CMD_STATE_WAIT;\n                    } else if(cmd_state == CMD_STATE_IN) { /*Command end */\n                        cmd_state = CMD_STATE_WAIT;\n                        continue;\n                    }\n                }\n\n                /*Skip the color parameter and wait the space after it*/\n                if(cmd_state == CMD_STATE_PAR) {\n                    if(letter == ' ') {\n                        /*Get the parameter*/\n                        if(i - par_start == LABEL_RECOLOR_PAR_LENGTH + 1) {\n                            char buf[LABEL_RECOLOR_PAR_LENGTH + 1];\n                            memcpy(buf, &txt[par_start], LABEL_RECOLOR_PAR_LENGTH);\n                            buf[LABEL_RECOLOR_PAR_LENGTH] = '\\0';\n                            int r, g, b;\n                            r = (hex_char_to_num(buf[0]) << 4) + hex_char_to_num(buf[1]);\n                            g = (hex_char_to_num(buf[2]) << 4) + hex_char_to_num(buf[3]);\n                            b = (hex_char_to_num(buf[4]) << 4) + hex_char_to_num(buf[5]);\n                            recolor = LV_COLOR_MAKE(r, g, b);\n                        } else {\n                            recolor.full = style->text.color.full;\n                        }\n                        cmd_state = CMD_STATE_IN; /*After the parameter the text is in the command*/\n                    }\n                    continue;\n                }\n            }\n\n            lv_color_t color = style->text.color;\n\n            if(cmd_state == CMD_STATE_IN) color = recolor;\n\n            letter_fp(&pos, mask, font, letter, color, style->text.opa);\n            letter_w = lv_font_get_width(font, letter);\n\n            pos.x += letter_w + style->text.letter_space;\n        }\n        /*Go to next line*/\n        line_start = line_end;\n        line_end += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, w, flag);\n\n        pos.x = coords->x1;\n        /*Align to middle*/\n        if(flag & LV_TXT_FLAG_CENTER) {\n            line_length = lv_txt_get_width(&txt[line_start], line_end - line_start,\n                                           font, style->text.letter_space, flag);\n            pos.x += (w - line_length) / 2;\n        }\n        /*Go the next line position*/\n        pos.y += lv_font_get_height(font);\n        pos.y += style->text.line_space;\n    }\n}\n\n#if USE_LV_IMG\n/**\n * Draw an image\n * @param coords the coordinates of the image\n * @param mask the image will be drawn only in this area\n * @param map_p pointer to a lv_color_t array which contains the pixels of the image\n * @param opa opacity of the image (0..255)\n */\nvoid lv_draw_img(const lv_area_t * coords, const lv_area_t * mask,\n                 const lv_style_t * style, const void * src)\n{\n\n    if(src == NULL) {\n        lv_draw_rect(coords, mask, &lv_style_plain);\n        lv_draw_label(coords, mask, &lv_style_plain, \"No\\ndata\", LV_TXT_FLAG_NONE, NULL);\n        return;\n    }\n\n    const uint8_t * u8_p = (uint8_t *) src;\n    if(u8_p[0] >= 'A' &&  u8_p[0] <= 'Z') { /*It will be a path of a file*/\n#if USE_LV_FILESYSTEM\n        lv_fs_file_t file;\n        lv_fs_res_t res = lv_fs_open(&file, src, LV_FS_MODE_RD);\n        if(res == LV_FS_RES_OK) {\n            lv_img_t img_data;\n            uint32_t br;\n            res = lv_fs_read(&file, &img_data, sizeof(lv_img_t), &br);\n\n            lv_area_t mask_com;    /*Common area of mask and cords*/\n            bool union_ok;\n            union_ok = lv_area_union(&mask_com, mask, coords);\n            if(union_ok == false) {\n                lv_fs_close(&file);\n                return;\n            }\n\n            uint8_t px_size = 0;\n            switch(img_data.header.format) {\n                case LV_IMG_FORMAT_FILE_RAW_RGB332:\n                    px_size = 1;\n                    break;\n                case LV_IMG_FORMAT_FILE_RAW_RGB565:\n                    px_size = 2;\n                    break;\n                case LV_IMG_FORMAT_FILE_RAW_RGB888:\n                    px_size = 4;\n                    break;\n                default:\n                    return;\n            }\n\n            if(img_data.header.alpha_byte) {    /*Correction with the alpha byte*/\n                px_size++;\n                if(img_data.header.format == LV_IMG_FORMAT_FILE_RAW_RGB888) px_size--; /*Stored in the 4 byte anyway*/\n            }\n\n\n            /* Move the file pointer to the start address according to mask*/\n            uint32_t start_offset = sizeof(img_data.header);\n            start_offset += (lv_area_get_width(coords)) * (mask_com.y1 - coords->y1) * px_size;      /*First row*/\n            start_offset += (mask_com.x1 - coords->x1) * px_size;                                    /*First col*/\n            lv_fs_seek(&file, start_offset);\n\n            uint32_t useful_data = lv_area_get_width(&mask_com) * px_size;\n            uint32_t next_row = lv_area_get_width(coords) * px_size - useful_data;\n\n            lv_area_t line;\n            lv_area_copy(&line, &mask_com);\n            lv_area_set_height(&line, 1);\n\n            lv_coord_t row;\n            uint32_t act_pos;\n#if LV_COMPILER_VLA_SUPPORTED\n            uint8_t buf[lv_area_get_width(&mask_com) * px_size];\n#else\n# if LV_HOR_RES > LV_VER_RES\n            uint8_t buf[LV_HOR_RES * px_size];\n# else\n            uint8_t buf[LV_VER_RES * px_size];\n# endif\n#endif\n            for(row = mask_com.y1; row <= mask_com.y2; row ++) {\n                res = lv_fs_read(&file, buf, useful_data, &br);\n\n                map_fp(&line, &mask_com, (uint8_t *)buf, style->image.opa, img_data.header.chroma_keyed, img_data.header.alpha_byte,\n                       style->image.color, style->image.intense);\n\n                lv_fs_tell(&file, &act_pos);\n                lv_fs_seek(&file, act_pos + next_row);\n                line.y1++;    /*Go down a line*/\n                line.y2++;\n            }\n\n            lv_fs_close(&file);\n\n            if(res != LV_FS_RES_OK) {\n                lv_draw_rect(coords, mask, &lv_style_plain);\n                lv_draw_label(coords, mask, &lv_style_plain, \"No data\", LV_TXT_FLAG_NONE, NULL);\n            }\n        }\n#endif\n    } else {\n        const lv_img_t * img_var = src;\n        lv_area_t mask_com;    /*Common area of mask and coords*/\n        bool union_ok;\n        union_ok = lv_area_union(&mask_com, mask, coords);\n        if(union_ok == false) {\n            return;         /*Out of mask*/\n        }\n\n        map_fp(coords, mask, img_var->pixel_map, style->image.opa, img_var->header.chroma_keyed, img_var->header.alpha_byte, style->image.color, style->image.intense);\n\n    }\n\n}\n#endif\n\n\n/**\n * Draw a line\n * @param p1 first point of the line\n * @param p2 second point of the line\n * @param maskthe line will be drawn only on this area\n * @param lines_p pointer to a line style\n */\nvoid lv_draw_line(const lv_point_t * point1, const lv_point_t * point2, const lv_area_t * mask,\n                  const lv_style_t * style)\n{\n\n    if(style->line.width == 0) return;\n    if(point1->x == point2->x && point1->y == point2->y) return;\n\n    lv_point_t p1;\n    lv_point_t p2;\n\n    /*Be sure always x1 < x2*/\n    if(point1->x < point2->x) {\n        p1.x = point1->x;\n        p1.y = point1->y;\n        p2.x = point2->x;\n        p2.y = point2->y;\n    } else {\n        p1.x = point2->x;\n        p1.y = point2->y;\n        p2.x = point1->x;\n        p2.y = point1->y;\n    }\n\n    lv_coord_t dx = LV_MATH_ABS(p2.x - p1.x);\n    lv_coord_t sx = p1.x < p2.x ? 1 : -1;\n    lv_coord_t dy = LV_MATH_ABS(p2.y - p1.y);\n    lv_coord_t sy = p1.y < p2.y ? 1 : -1;\n    lv_coord_t err = (dx > dy ? dx : -dy) / 2;\n    lv_coord_t e2;\n    bool hor = dx > dy ? true : false;  /*Rather horizontal or vertical*/\n    lv_coord_t last_x = p1.x;\n    lv_coord_t last_y = p1.y;\n    lv_point_t act_point;\n    act_point.x = p1.x;\n    act_point.y = p1.y;\n\n\n    lv_coord_t width;\n    uint16_t wcor;\n    uint16_t width_half = 0;\n    uint16_t width_1 = 0;\n    static const uint8_t width_corr_array[] = {\n        64, 64, 64, 64, 64, 64, 64, 64, 64, 65, 65, 65, 65, 65, 66, 66, 66, 66, 66,\n        67, 67, 67, 68, 68, 68, 69, 69, 69, 70, 70, 71, 71, 72, 72, 72, 73, 73, 74,\n        74, 75, 75, 76, 77, 77, 78, 78, 79, 79, 80, 81, 81, 82, 82, 83, 84, 84, 85,\n        86, 86, 87, 88, 88, 89, 90, 91,\n    };\n\n    if(hor == false) {\n        wcor = (dx * LINE_WIDTH_CORR_BASE) / dy;\n    } else  {\n        wcor = (dy * LINE_WIDTH_CORR_BASE) / dx;\n    }\n\n\n    width = style->line.width - 1;\n\n#if LV_ANTIALIAS != 0\n    bool aa_invert = false;\n    aa_invert = p1.y < p2.y ? false : true;      /*Direction of opacity increase on the edges*/\n    if(p1.x != p2.x && p1.y != p2.y) width--;    /*Because of anti aliasing (no anti aliasing on hor. and ver. lines)*/\n#endif\n\n    /*Make the correction on lie width*/\n    if(width > 0) {\n        width = (width * width_corr_array[wcor]);\n        width = width >> LINE_WIDTH_CORR_SHIFT;\n        width_half = width >> 1;\n        width_1 = width & 0x1 ? 1 : 0;\n    }\n\n    /*Special case draw a horizontal line*/\n    if(p1.y == p2.y) {\n        lv_area_t act_area;\n        act_area.x1 = p1.x;\n        act_area.x2 = p2.x;\n        act_area.y1 = p1.y - width_half - width_1;\n        act_area.y2 = p2.y + width_half ;\n\n        lv_area_t draw_area;\n        draw_area.x1 = LV_MATH_MIN(act_area.x1, act_area.x2);\n        draw_area.x2 = LV_MATH_MAX(act_area.x1, act_area.x2);\n        draw_area.y1 = LV_MATH_MIN(act_area.y1, act_area.y2);\n        draw_area.y2 = LV_MATH_MAX(act_area.y1, act_area.y2);\n        fill_fp(&draw_area, mask, style->line.color, style->line.opa);\n\n        return;\n    }\n\n    /*Special case draw a vertical line*/\n    if(p1.x == p2.x) {\n        lv_area_t act_area;\n        act_area.x1 = p1.x - width_half;\n        act_area.x2 = p2.x + width_half + width_1;\n        act_area.y1 = p1.y;\n        act_area.y2 = p2.y;\n\n        lv_area_t draw_area;\n        draw_area.x1 = LV_MATH_MIN(act_area.x1, act_area.x2);\n        draw_area.x2 = LV_MATH_MAX(act_area.x1, act_area.x2);\n        draw_area.y1 = LV_MATH_MIN(act_area.y1, act_area.y2);\n        draw_area.y2 = LV_MATH_MAX(act_area.y1, act_area.y2);\n        fill_fp(&draw_area, mask, style->line.color, style->line.opa);\n        return;\n    }\n\n\n    while(1) {\n        if(hor == true && last_y != act_point.y) {\n            lv_area_t act_area;\n            lv_area_t draw_area;\n            act_area.x1 = last_x;\n            act_area.x2 = act_point.x - sx;\n            act_area.y1 = last_y - width_half ;\n            act_area.y2 = act_point.y - sy  + width_half + width_1;\n            last_y = act_point.y;\n            last_x = act_point.x;\n            draw_area.x1 = LV_MATH_MIN(act_area.x1, act_area.x2);\n            draw_area.x2 = LV_MATH_MAX(act_area.x1, act_area.x2);\n            draw_area.y1 = LV_MATH_MIN(act_area.y1, act_area.y2);\n            draw_area.y2 = LV_MATH_MAX(act_area.y1, act_area.y2);\n            if(width >= 0) {\n                fill_fp(&draw_area, mask, style->line.color, style->line.opa);\n            }\n\n#if LV_ANTIALIAS != 0\n            lv_coord_t seg_w = lv_area_get_width(&draw_area);  /*Segment width*/\n            lv_point_t aa_p1;\n            lv_point_t aa_p2;\n\n            aa_p1.x = draw_area.x1;\n            aa_p1.y = draw_area.y1 - 1;\n\n            aa_p2.x = draw_area.x1;\n            aa_p2.y = draw_area.y1 + width + 1;\n\n            lv_coord_t i;\n            for(i = 0; i  < seg_w; i++) {\n                lv_opa_t aa_opa = antialias_get_opa(seg_w, i, style->line.opa);\n\n                px_fp(aa_p1.x + i, aa_p1.y, mask, style->line.color, aa_invert ? aa_opa : style->line.opa - aa_opa);\n                px_fp(aa_p2.x + i, aa_p2.y, mask, style->line.color, aa_invert ? style->line.opa - aa_opa :  aa_opa);\n            }\n#endif\n        }\n        if(hor == false && last_x != act_point.x) {\n            lv_area_t act_area;\n            lv_area_t draw_area;\n            act_area.x1 = last_x - width_half;\n            act_area.x2 = act_point.x  - sx + width_half + width_1;\n            act_area.y1 = last_y ;\n            act_area.y2 = act_point.y - sy;\n            last_y = act_point.y;\n            last_x = act_point.x;\n\n            draw_area.x1 = LV_MATH_MIN(act_area.x1, act_area.x2);\n            draw_area.x2 = LV_MATH_MAX(act_area.x1, act_area.x2);\n            draw_area.y1 = LV_MATH_MIN(act_area.y1, act_area.y2);\n            draw_area.y2 = LV_MATH_MAX(act_area.y1, act_area.y2);\n            if(width >= 0) {\n                fill_fp(&draw_area, mask, style->line.color, style->line.opa);\n            }\n\n#if LV_ANTIALIAS != 0\n            lv_coord_t seg_h = lv_area_get_height(&draw_area);  /*Segment height*/\n            lv_point_t aa_p1;\n            lv_point_t aa_p2;\n\n            aa_p1.x = draw_area.x1 - 1;\n            aa_p1.y = draw_area.y1;\n\n            aa_p2.x = draw_area.x1 + width + 1;\n            aa_p2.y = draw_area.y1;\n\n            lv_coord_t i;\n            for(i = 0; i  < seg_h; i++) {\n                lv_opa_t aa_opa = antialias_get_opa(seg_h, i, style->line.opa);\n\n                px_fp(aa_p1.x, aa_p1.y + i, mask, style->line.color, aa_invert ? aa_opa : style->line.opa - aa_opa);\n                px_fp(aa_p2.x, aa_p2.y + i, mask, style->line.color, aa_invert ? style->line.opa - aa_opa :  aa_opa);\n            }\n#endif\n        }\n\n        /*Calc. the next point of the line*/\n        if(act_point.x == p2.x && act_point.y == p2.y) break;\n        e2 = err;\n        if(e2 > -dx) {\n            err -= dy;\n            act_point.x += sx;\n        }\n        if(e2 < dy) {\n            err += dx;\n            act_point.y += sy;\n        }\n    }\n\n    /*Draw the last part of the line*/\n    if(hor == true) {\n        lv_area_t act_area;\n        lv_area_t draw_area;\n        act_area.x1 = last_x;\n        act_area.x2 = act_point.x;\n        act_area.y1 = last_y - width_half ;\n        act_area.y2 = act_point.y + width_half + width_1;\n\n        draw_area.x1 = LV_MATH_MIN(act_area.x1, act_area.x2);\n        draw_area.x2 = LV_MATH_MAX(act_area.x1, act_area.x2);\n        draw_area.y1 = LV_MATH_MIN(act_area.y1, act_area.y2);\n        draw_area.y2 = LV_MATH_MAX(act_area.y1, act_area.y2);\n        if(width >= 0) {\n            fill_fp(&draw_area, mask, style->line.color, style->line.opa);\n        }\n\n#if LV_ANTIALIAS != 0\n        lv_coord_t seg_w = lv_area_get_width(&draw_area);  /*Segment width*/\n        lv_point_t aa_p1;\n        lv_point_t aa_p2;\n\n        aa_p1.x = draw_area.x1;\n        aa_p1.y = draw_area.y1 - 1;\n\n        aa_p2.x = draw_area.x1;\n        aa_p2.y = draw_area.y1 + width + 1;\n\n        lv_coord_t i;\n        for(i = 0; i  < seg_w; i++) {\n            lv_opa_t aa_opa = antialias_get_opa(seg_w, i, style->line.opa);\n\n            px_fp(aa_p1.x + i, aa_p1.y, mask, style->line.color, aa_invert ? aa_opa : style->line.opa - aa_opa);\n            px_fp(aa_p2.x + i, aa_p2.y, mask, style->line.color, aa_invert ? style->line.opa - aa_opa :  aa_opa);\n        }\n#endif\n\n    }\n    if(hor == false) {\n        lv_area_t act_area;\n        lv_area_t draw_area;\n        act_area.x1 = last_x - width_half;\n        act_area.x2 = act_point.x + width_half + width_1;\n        act_area.y1 = last_y;\n        act_area.y2 = act_point.y;\n\n        draw_area.x1 = LV_MATH_MIN(act_area.x1, act_area.x2);\n        draw_area.x2 = LV_MATH_MAX(act_area.x1, act_area.x2);\n        draw_area.y1 = LV_MATH_MIN(act_area.y1, act_area.y2);\n        draw_area.y2 = LV_MATH_MAX(act_area.y1, act_area.y2);\n        if(width >= 0) {\n            fill_fp(&draw_area, mask, style->line.color, style->line.opa);\n        }\n\n#if LV_ANTIALIAS != 0\n        lv_coord_t seg_h = lv_area_get_height(&draw_area);  /*Segment height*/\n        lv_point_t aa_p1;\n        lv_point_t aa_p2;\n\n        aa_p1.x = draw_area.x1 - 1;\n        aa_p1.y = draw_area.y1;\n\n        aa_p2.x = draw_area.x1 + width + 1;\n        aa_p2.y = draw_area.y1;\n\n        lv_coord_t i;\n        for(i = 0; i  < seg_h; i++) {\n            lv_opa_t aa_opa = antialias_get_opa(seg_h, i, style->line.opa);\n\n            px_fp(aa_p1.x, aa_p1.y + i, mask, style->line.color, aa_invert ? aa_opa : style->line.opa - aa_opa);\n            px_fp(aa_p2.x, aa_p2.y + i, mask, style->line.color, aa_invert ? style->line.opa - aa_opa :  aa_opa);\n        }\n#endif\n    }\n}\n\n",
        "res_region": "",
        "lookback": "/**********************",
        "lookahead": "/**********************",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 74,
        "end_line": 1439,
        "merge_gen_region": null,
        "confidence": 0.2506462335586548,
        "hesitated": true
    }
]