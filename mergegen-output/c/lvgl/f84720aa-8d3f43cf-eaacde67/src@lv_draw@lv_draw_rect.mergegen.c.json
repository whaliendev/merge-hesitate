[
    {
        "a_contents": "    coords_tmp.x1 = 0;\n    coords_tmp.y1 = 0;\n    coords_tmp.x2 = s.x - 1;\n    coords_tmp.y2 = s.y - 1;",
        "b_contents": "    if(dsc->pattern_repeat) {\n        lv_draw_mask_radius_init(&radius_mask_param, coords, dsc->radius, false);\n        int16_t radius_mask_id = lv_draw_mask_add(&radius_mask_param, NULL);\n\n        /*Align the pattern to the middle*/\n        int32_t ofs_x = (lv_area_get_width(coords) - (lv_area_get_width(coords) / img_w) * img_w) / 2;\n        int32_t ofs_y = (lv_area_get_height(coords) - (lv_area_get_height(coords) / img_h) * img_h) / 2;\n\n        coords_tmp.y1 = coords->y1 - ofs_y;\n        coords_tmp.y2 = coords_tmp.y1 + img_h - 1;\n        for(; coords_tmp.y1 <= coords->y2; coords_tmp.y1 += img_h, coords_tmp.y2 += img_h) {\n            coords_tmp.x1 = coords->x1 - ofs_x;\n            coords_tmp.x2 = coords_tmp.x1 + img_w - 1;\n            for(; coords_tmp.x1 <= coords->x2; coords_tmp.x1 += img_w, coords_tmp.x2 += img_w) {\n                if(src_type == LV_IMG_SRC_SYMBOL)  lv_draw_label(&coords_tmp, clip, &label_dsc, dsc->pattern_image, NULL);\n                else lv_draw_img(&coords_tmp, clip, dsc->pattern_image, &img_dsc);\n            }\n        }\n        lv_draw_mask_remove_id(radius_mask_id);\n    }\n    else {\n        int32_t obj_w = lv_area_get_width(coords);\n        int32_t obj_h = lv_area_get_height(coords);\n        coords_tmp.x1 = coords->x1 + (obj_w - img_w) / 2;\n        coords_tmp.y1 = coords->y1 + (obj_h - img_h) / 2;\n        coords_tmp.x2 = coords_tmp.x1 + img_w - 1;\n        coords_tmp.y2 = coords_tmp.y1 + img_h - 1;\n\n        /* If the (obj_h - img_h) is odd there is a rounding error when divided by 2.\n         * It's better round up in case of symbols because probably there is some extra space in the bottom\n         * due to the base line of font*/\n        if(src_type == LV_IMG_SRC_SYMBOL) {\n            int32_t y_corr = (obj_h - img_h) & 0x1;\n            coords_tmp.y1 += y_corr;\n            coords_tmp.y2 += y_corr;\n        }\n\n        int16_t radius_mask_id = LV_MASK_ID_INV;\n        if(_lv_area_is_in(&coords_tmp, coords, dsc->radius) == false) {\n            lv_draw_mask_radius_init(&radius_mask_param, coords, dsc->radius, false);\n            radius_mask_id = lv_draw_mask_add(&radius_mask_param, NULL);\n        }\n\n        if(src_type == LV_IMG_SRC_SYMBOL)  lv_draw_label(&coords_tmp, clip, &label_dsc, dsc->pattern_image, NULL);\n        else lv_draw_img(&coords_tmp, clip, dsc->pattern_image, &img_dsc);\n\n        lv_draw_mask_remove_id(radius_mask_id);\n    }\n}\n#endif\n\n#if LV_USE_VALUE_STR\nstatic void draw_value_str(const lv_area_t * coords, const lv_area_t * clip, const lv_draw_rect_dsc_t * dsc)\n{\n    if(dsc->value_str == NULL) return;\n    if(dsc->value_opa <= LV_OPA_MIN) return;\n\n#if LV_USE_ARABIC_PERSIAN_CHARS == 0\n    const char * str = dsc->value_str;\n#else\n    uint32_t str_len =  _lv_txt_ap_calc_bytes_cnt(dsc->value_str);\n    char * str = _lv_mem_buf_get(str_len + 1);\n    _lv_txt_ap_proc(dsc->value_str, str);\n#endif\n\n    lv_point_t s;\n    _lv_txt_get_size(&s, str, dsc->value_font, dsc->value_letter_space, dsc->value_line_space, LV_COORD_MAX,\n                     LV_TXT_FLAG_NONE);\n\n    lv_area_t value_area;\n    value_area.x1 = 0;\n    value_area.y1 = 0;\n    value_area.x2 = s.x - 1;\n    value_area.y2 = s.y - 1;",
        "base_contents": "    if(dsc->pattern_repeat) {\n        lv_draw_mask_radius_param_t radius_mask_param;\n        lv_draw_mask_radius_init(&radius_mask_param, coords, dsc->radius, false);\n        int16_t radius_mask_id = lv_draw_mask_add(&radius_mask_param, NULL);\n\n        /*Align the pattern to the middle*/\n        int32_t ofs_x = (lv_area_get_width(coords) - (lv_area_get_width(coords) / img_w) * img_w) / 2;\n        int32_t ofs_y = (lv_area_get_height(coords) - (lv_area_get_height(coords) / img_h) * img_h) / 2;\n\n        coords_tmp.y1 = coords->y1 - ofs_y;\n        coords_tmp.y2 = coords_tmp.y1 + img_h - 1;\n        for(; coords_tmp.y1 <= coords->y2; coords_tmp.y1 += img_h, coords_tmp.y2 += img_h) {\n            coords_tmp.x1 = coords->x1 - ofs_x;\n            coords_tmp.x2 = coords_tmp.x1 + img_w - 1;\n            for(; coords_tmp.x1 <= coords->x2; coords_tmp.x1 += img_w, coords_tmp.x2 += img_w) {\n                if(src_type == LV_IMG_SRC_SYMBOL)  lv_draw_label(&coords_tmp, clip, &label_dsc, dsc->pattern_image, NULL);\n                else lv_draw_img(&coords_tmp, clip, dsc->pattern_image, &img_dsc);\n            }\n        }\n        lv_draw_mask_remove_id(radius_mask_id);\n    }\n    else {\n        int32_t obj_w = lv_area_get_width(coords);\n        int32_t obj_h = lv_area_get_height(coords);\n        coords_tmp.x1 = coords->x1 + (obj_w - img_w) / 2;\n        coords_tmp.y1 = coords->y1 + (obj_h - img_h) / 2;\n        coords_tmp.x2 = coords_tmp.x1 + img_w - 1;\n        coords_tmp.y2 = coords_tmp.y1 + img_h - 1;\n\n        /* If the (obj_h - img_h) is odd there is a rounding error when divided by 2.\n         * It's better round up in case of symbols because probably there is some extra space in the bottom\n         * due to the base line of font*/\n        if(src_type == LV_IMG_SRC_SYMBOL) {\n            int32_t y_corr = (obj_h - img_h) & 0x1;\n            coords_tmp.y1 += y_corr;\n            coords_tmp.y2 += y_corr;\n        }\n\n        int16_t radius_mask_id = LV_MASK_ID_INV;\n        if(_lv_area_is_in(&coords_tmp, coords, dsc->radius) == false) {\n            lv_draw_mask_radius_param_t radius_mask_param;\n            lv_draw_mask_radius_init(&radius_mask_param, coords, dsc->radius, false);\n            radius_mask_id = lv_draw_mask_add(&radius_mask_param, NULL);\n        }\n\n        if(src_type == LV_IMG_SRC_SYMBOL)  lv_draw_label(&coords_tmp, clip, &label_dsc, dsc->pattern_image, NULL);\n        else lv_draw_img(&coords_tmp, clip, dsc->pattern_image, &img_dsc);\n\n        lv_draw_mask_remove_id(radius_mask_id);\n    }\n}\n#endif\n\n\n#if LV_USE_VALUE_STR\nstatic void draw_value_str(const lv_area_t * coords, const lv_area_t * clip, const lv_draw_rect_dsc_t * dsc)\n{\n    if(dsc->value_str == NULL) return;\n    if(dsc->value_opa <= LV_OPA_MIN) return;\n\n#if LV_USE_ARABIC_PERSIAN_CHARS == 0\n    const char * str = dsc->value_str;\n#else\n    uint32_t str_len =  _lv_txt_ap_calc_bytes_cnt(dsc->value_str);\n    char * str = _lv_mem_buf_get(str_len + 1);\n    _lv_txt_ap_proc(dsc->value_str, str);\n#endif\n\n    lv_point_t s;\n    _lv_txt_get_size(&s, str, dsc->value_font, dsc->value_letter_space, dsc->value_line_space, LV_COORD_MAX,\n                     LV_TXT_FLAG_NONE);\n\n    lv_area_t value_area;\n    value_area.x1 = 0;\n    value_area.y1 = 0;\n    value_area.x2 = s.x - 1;\n    value_area.y2 = s.y - 1;",
        "res_region": "    coords_tmp.x1 = 0;\n    coords_tmp.y1 = 0;\n    coords_tmp.x2 = s.x - 1;\n    coords_tmp.y2 = s.y - 1;",
        "lookback": "    coords_tmp.y1 = 0;",
        "lookahead": "",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 1208,
        "end_line": 1366,
        "merge_gen_region": null,
        "confidence": 0.42213305830955505,
        "hesitated": true
    }
]