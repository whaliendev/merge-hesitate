[
    {
        "a_contents": "",
        "b_contents": "/**\n * Handle the dragging of indev_proc_p->types.pointer.act_obj\n * @param indev pointer to a input device state\n */\nstatic void indev_drag(lv_indev_proc_t * proc)\n{\n    lv_obj_t * drag_obj    = get_dragged_obj(proc->types.pointer.act_obj);\n    bool drag_just_started = false;\n\n    if(drag_obj == NULL) return;\n\n    if(lv_obj_get_drag(drag_obj) == false) return;\n\n    lv_drag_dir_t allowed_dirs = lv_obj_get_drag_dir(drag_obj);\n\n    /*Count the movement by drag*/\n    if(proc->types.pointer.drag_limit_out == 0) {\n        proc->types.pointer.drag_sum.x += proc->types.pointer.vect.x;\n        proc->types.pointer.drag_sum.y += proc->types.pointer.vect.y;\n\n        /*Enough move?*/\n        bool hor_en = false;\n        bool ver_en = false;\n        if(allowed_dirs == LV_DRAG_DIR_HOR || allowed_dirs == LV_DRAG_DIR_BOTH) {\n            hor_en = true;\n        }\n\n        if(allowed_dirs == LV_DRAG_DIR_VER || allowed_dirs == LV_DRAG_DIR_BOTH) {\n            ver_en = true;\n        }\n\n        if(allowed_dirs == LV_DRAG_DIR_ONE) {\n            if(LV_MATH_ABS(proc->types.pointer.drag_sum.x) > LV_MATH_ABS(proc->types.pointer.drag_sum.y)) {\n                hor_en = true;\n            }\n            else {\n                ver_en = true;\n            }\n        }\n\n        /*If a move is greater then LV_DRAG_LIMIT then begin the drag*/\n        if((hor_en && LV_MATH_ABS(proc->types.pointer.drag_sum.x) >= indev_act->driver.drag_limit) ||\n           (ver_en && LV_MATH_ABS(proc->types.pointer.drag_sum.y) >= indev_act->driver.drag_limit)) {\n            proc->types.pointer.drag_limit_out = 1;\n            drag_just_started                   = true;\n        }\n    }\n\n    /*If the drag limit is exceeded handle the dragging*/\n    if(proc->types.pointer.drag_limit_out != 0) {\n        /*Set new position if the vector is not zero*/\n        if(proc->types.pointer.vect.x != 0 || proc->types.pointer.vect.y != 0) {\n\n            lv_coord_t prev_x     = drag_obj->coords.x1;\n            lv_coord_t prev_y     = drag_obj->coords.y1;\n            lv_coord_t prev_par_w = lv_obj_get_width(lv_obj_get_parent(drag_obj));\n            lv_coord_t prev_par_h = lv_obj_get_height(lv_obj_get_parent(drag_obj));\n\n            /*Get the coordinates of the object and modify them*/\n            lv_coord_t act_x = lv_obj_get_x(drag_obj);\n            lv_coord_t act_y = lv_obj_get_y(drag_obj);\n\n            if(allowed_dirs == LV_DRAG_DIR_BOTH) {\n                if(drag_just_started) {\n                    proc->types.pointer.drag_dir = LV_DRAG_DIR_BOTH;\n                    act_x += proc->types.pointer.drag_sum.x;\n                    act_y += proc->types.pointer.drag_sum.y;\n                }\n            }\n            else if(allowed_dirs == LV_DRAG_DIR_HOR) {\n                if(drag_just_started) {\n                    proc->types.pointer.drag_dir = LV_DRAG_DIR_HOR;\n                    proc->types.pointer.drag_sum.y = 0;\n                    act_x += proc->types.pointer.drag_sum.x;\n                }\n            }\n            else if(allowed_dirs == LV_DRAG_DIR_VER) {\n                if(drag_just_started) {\n                    proc->types.pointer.drag_dir = LV_DRAG_DIR_VER;\n                    proc->types.pointer.drag_sum.x = 0;\n                    act_y += proc->types.pointer.drag_sum.y;\n                }\n            }\n            else if(allowed_dirs == LV_DRAG_DIR_ONE) {\n                if(drag_just_started) {\n                    if(LV_MATH_ABS(proc->types.pointer.drag_sum.x) > LV_MATH_ABS(proc->types.pointer.drag_sum.y)) {\n                        proc->types.pointer.drag_dir = LV_DRAG_DIR_HOR;\n                        proc->types.pointer.drag_sum.y = 0;\n                        act_x += proc->types.pointer.drag_sum.x;\n                    }\n                    else {\n                        proc->types.pointer.drag_dir = LV_DRAG_DIR_VER;\n                        proc->types.pointer.drag_sum.x = 0;\n                        act_y += proc->types.pointer.drag_sum.y;\n                    }\n                }\n            }\n\n            /*Move the object*/\n            if(allowed_dirs == LV_DRAG_DIR_HOR ||\n               allowed_dirs == LV_DRAG_DIR_BOTH ||\n               (allowed_dirs == LV_DRAG_DIR_ONE &&\n                LV_MATH_ABS(proc->types.pointer.drag_sum.x) > LV_MATH_ABS(proc->types.pointer.drag_sum.y))) {\n                act_x += proc->types.pointer.vect.x;\n            }\n            if(allowed_dirs == LV_DRAG_DIR_VER ||\n               allowed_dirs == LV_DRAG_DIR_BOTH ||\n               (allowed_dirs == LV_DRAG_DIR_ONE &&\n                LV_MATH_ABS(proc->types.pointer.drag_sum.x) < LV_MATH_ABS(proc->types.pointer.drag_sum.y))) {\n                act_y += proc->types.pointer.vect.y;\n            }\n\n            uint16_t inv_buf_size =\n                lv_disp_get_inv_buf_size(indev_act->driver.disp); /*Get the number of currently invalidated areas*/\n\n            lv_obj_set_pos(drag_obj, act_x, act_y);\n            proc->types.pointer.drag_in_prog = 1;\n\n            /*If the object didn't moved then clear the invalidated areas*/\n            if(drag_obj->coords.x1 == prev_x && drag_obj->coords.y1 == prev_y) {\n                /*In a special case if the object is moved on a page and\n                 * the scrollable has fit == true and the object is dragged of the page then\n                 * while its coordinate is not changing only the parent's size is reduced */\n                lv_coord_t act_par_w = lv_obj_get_width(lv_obj_get_parent(drag_obj));\n                lv_coord_t act_par_h = lv_obj_get_height(lv_obj_get_parent(drag_obj));\n                if(act_par_w == prev_par_w && act_par_h == prev_par_h) {\n                    uint16_t new_inv_buf_size = lv_disp_get_inv_buf_size(indev_act->driver.disp);\n                    _lv_disp_pop_from_inv_buf(indev_act->driver.disp, new_inv_buf_size - inv_buf_size);\n                }\n            }\n\n            /*Set the drag in progress flag*/\n            /*Send the drag begin signal on first move*/\n            if(drag_just_started) {\n                drag_obj->signal_cb(drag_obj, LV_SIGNAL_DRAG_BEGIN, indev_act);\n                if(indev_reset_check(proc)) return;\n\n                lv_event_send(drag_obj, LV_EVENT_DRAG_BEGIN, NULL);\n                if(indev_reset_check(proc)) return;\n            }\n\n        }\n    }\n}\n\n/**\n * Handle throwing by drag if the drag is ended\n * @param indev pointer to an input device state\n */\nstatic void indev_drag_throw(lv_indev_proc_t * proc)\n{\n    if(proc->types.pointer.drag_in_prog == 0) return;\n\n    lv_obj_t * drag_obj = get_dragged_obj(proc->types.pointer.last_obj);\n\n    if(drag_obj == NULL) return;\n\n    /*Return if the drag throw is not enabled*/\n    if(lv_obj_get_drag_throw(drag_obj) == false) {\n        proc->types.pointer.drag_in_prog = 0;\n        drag_obj->signal_cb(drag_obj, LV_SIGNAL_DRAG_END, indev_act);\n        if(indev_reset_check(proc)) return;\n\n        lv_event_send(drag_obj, LV_EVENT_DRAG_END, NULL);\n        return;\n    }\n\n    lv_drag_dir_t allowed_dirs = lv_obj_get_drag_dir(drag_obj);\n\n    /*Reduce the vectors*/\n    proc->types.pointer.drag_throw_vect.x =\n        proc->types.pointer.drag_throw_vect.x * (100 - indev_act->driver.drag_throw) / 100;\n    proc->types.pointer.drag_throw_vect.y =\n        proc->types.pointer.drag_throw_vect.y * (100 - indev_act->driver.drag_throw) / 100;\n\n    if(proc->types.pointer.drag_throw_vect.x != 0 || proc->types.pointer.drag_throw_vect.y != 0) {\n        /*Get the coordinates and modify them*/\n        lv_area_t coords_ori;\n        lv_obj_get_coords(drag_obj, &coords_ori);\n        lv_coord_t act_x = lv_obj_get_x(drag_obj) + proc->types.pointer.drag_throw_vect.x;\n        lv_coord_t act_y = lv_obj_get_y(drag_obj) + proc->types.pointer.drag_throw_vect.y;\n\n        if(allowed_dirs == LV_DRAG_DIR_BOTH) lv_obj_set_pos(drag_obj, act_x, act_y);\n        else if(allowed_dirs == LV_DRAG_DIR_HOR) lv_obj_set_x(drag_obj, act_x);\n        else if(allowed_dirs == LV_DRAG_DIR_VER) lv_obj_set_y(drag_obj, act_y);\n        else if(allowed_dirs == LV_DRAG_DIR_ONE) {\n            if(proc->types.pointer.drag_sum.x) lv_obj_set_x(drag_obj, act_x);\n            else lv_obj_set_y(drag_obj, act_y);\n        }\n        lv_area_t coord_new;\n        lv_obj_get_coords(drag_obj, &coord_new);\n\n        /*If non of the coordinates are changed then do not continue throwing*/\n        if((coords_ori.x1 == coord_new.x1 || proc->types.pointer.drag_throw_vect.x == 0) &&\n           (coords_ori.y1 == coord_new.y1 || proc->types.pointer.drag_throw_vect.y == 0)) {\n            proc->types.pointer.drag_in_prog      = 0;\n            proc->types.pointer.vect.x            = 0;\n            proc->types.pointer.vect.y            = 0;\n            proc->types.pointer.drag_throw_vect.x = 0;\n            proc->types.pointer.drag_throw_vect.y = 0;\n            drag_obj->signal_cb(drag_obj, LV_SIGNAL_DRAG_END, indev_act);\n            if(indev_reset_check(proc)) return;\n\n            lv_event_send(drag_obj, LV_EVENT_DRAG_END, NULL);\n            if(indev_reset_check(proc)) return;\n        }\n    }\n    /*If the types.pointer.vectors become 0 -> types.pointer.drag_in_prog = 0 and send a drag end\n       signal*/\n    else {\n        proc->types.pointer.drag_in_prog = 0;\n        drag_obj->signal_cb(drag_obj, LV_SIGNAL_DRAG_END, indev_act);\n        if(indev_reset_check(proc)) return;\n        lv_event_send(drag_obj, LV_EVENT_DRAG_END, NULL);\n        if(indev_reset_check(proc)) return;\n    }\n}\n\n/**\n * Get the really dragged object by taking `drag_parent` into account.\n * @param obj the start object\n * @return the object to really drag\n */\nstatic lv_obj_t * get_dragged_obj(lv_obj_t * obj)\n{\n    if(obj == NULL) return NULL;\n    lv_obj_t * drag_obj = obj;\n    while(lv_obj_get_drag_parent(drag_obj) != false && drag_obj != NULL) {\n        drag_obj = lv_obj_get_parent(drag_obj);\n    }\n\n    return drag_obj;\n}\n",
        "base_contents": "/**\n * Handle the dragging of indev_proc_p->types.pointer.act_obj\n * @param indev pointer to a input device state\n */\nstatic void indev_drag(lv_indev_proc_t * proc)\n{\n    lv_obj_t * drag_obj    = get_dragged_obj(proc->types.pointer.act_obj);\n    bool drag_just_started = false;\n\n    if(drag_obj == NULL) return;\n\n    if(lv_obj_get_drag(drag_obj) == false) return;\n\n\n    lv_drag_dir_t allowed_dirs = lv_obj_get_drag_dir(drag_obj);\n\n    /*Count the movement by drag*/\n    if(proc->types.pointer.drag_limit_out == 0) {\n        proc->types.pointer.drag_sum.x += proc->types.pointer.vect.x;\n        proc->types.pointer.drag_sum.y += proc->types.pointer.vect.y;\n\n        /*Enough move?*/\n        bool hor_en = false;\n        bool ver_en = false;\n        if(allowed_dirs == LV_DRAG_DIR_HOR || allowed_dirs == LV_DRAG_DIR_BOTH) {\n            hor_en = true;\n        }\n\n        if(allowed_dirs == LV_DRAG_DIR_VER || allowed_dirs == LV_DRAG_DIR_BOTH) {\n            ver_en = true;\n        }\n\n        if(allowed_dirs == LV_DRAG_DIR_ONE) {\n            if(LV_MATH_ABS(proc->types.pointer.drag_sum.x) > LV_MATH_ABS(proc->types.pointer.drag_sum.y)) {\n                hor_en = true;\n            }\n            else {\n                ver_en = true;\n            }\n        }\n\n        /*If a move is greater then LV_DRAG_LIMIT then begin the drag*/\n        if((hor_en && LV_MATH_ABS(proc->types.pointer.drag_sum.x) >= indev_act->driver.drag_limit) ||\n           (ver_en && LV_MATH_ABS(proc->types.pointer.drag_sum.y) >= indev_act->driver.drag_limit)) {\n            proc->types.pointer.drag_limit_out = 1;\n            drag_just_started                   = true;\n        }\n    }\n\n    /*If the drag limit is exceeded handle the dragging*/\n    if(proc->types.pointer.drag_limit_out != 0) {\n        /*Set new position if the vector is not zero*/\n        if(proc->types.pointer.vect.x != 0 || proc->types.pointer.vect.y != 0) {\n\n            lv_coord_t prev_x     = drag_obj->coords.x1;\n            lv_coord_t prev_y     = drag_obj->coords.y1;\n            lv_coord_t prev_par_w = lv_obj_get_width(lv_obj_get_parent(drag_obj));\n            lv_coord_t prev_par_h = lv_obj_get_height(lv_obj_get_parent(drag_obj));\n\n            /*Get the coordinates of the object and modify them*/\n            lv_coord_t act_x = lv_obj_get_x(drag_obj);\n            lv_coord_t act_y = lv_obj_get_y(drag_obj);\n\n            if(allowed_dirs == LV_DRAG_DIR_BOTH) {\n                if(drag_just_started) {\n                    proc->types.pointer.drag_dir = LV_DRAG_DIR_BOTH;\n                    act_x += proc->types.pointer.drag_sum.x;\n                    act_y += proc->types.pointer.drag_sum.y;\n                }\n            }\n            else if(allowed_dirs == LV_DRAG_DIR_HOR) {\n                if(drag_just_started) {\n                    proc->types.pointer.drag_dir = LV_DRAG_DIR_HOR;\n                    proc->types.pointer.drag_sum.y = 0;\n                    act_x += proc->types.pointer.drag_sum.x;\n                }\n            }\n            else if(allowed_dirs == LV_DRAG_DIR_VER) {\n                if(drag_just_started) {\n                    proc->types.pointer.drag_dir = LV_DRAG_DIR_VER;\n                    proc->types.pointer.drag_sum.x = 0;\n                    act_y += proc->types.pointer.drag_sum.y;\n                }\n            }\n            else if(allowed_dirs == LV_DRAG_DIR_ONE) {\n                if(drag_just_started) {\n                    if(LV_MATH_ABS(proc->types.pointer.drag_sum.x) > LV_MATH_ABS(proc->types.pointer.drag_sum.y)) {\n                        proc->types.pointer.drag_dir = LV_DRAG_DIR_HOR;\n                        proc->types.pointer.drag_sum.y = 0;\n                        act_x += proc->types.pointer.drag_sum.x;\n                    }\n                    else {\n                        proc->types.pointer.drag_dir = LV_DRAG_DIR_VER;\n                        proc->types.pointer.drag_sum.x = 0;\n                        act_y += proc->types.pointer.drag_sum.y;\n                    }\n                }\n            }\n\n            /*Move the object*/\n            if(allowed_dirs == LV_DRAG_DIR_HOR ||\n               allowed_dirs == LV_DRAG_DIR_BOTH ||\n               (allowed_dirs == LV_DRAG_DIR_ONE &&\n                LV_MATH_ABS(proc->types.pointer.drag_sum.x) > LV_MATH_ABS(proc->types.pointer.drag_sum.y))) {\n                act_x += proc->types.pointer.vect.x;\n            }\n            if(allowed_dirs == LV_DRAG_DIR_VER ||\n               allowed_dirs == LV_DRAG_DIR_BOTH ||\n               (allowed_dirs == LV_DRAG_DIR_ONE &&\n                LV_MATH_ABS(proc->types.pointer.drag_sum.x) < LV_MATH_ABS(proc->types.pointer.drag_sum.y))) {\n                act_y += proc->types.pointer.vect.y;\n            }\n\n            uint16_t inv_buf_size =\n                lv_disp_get_inv_buf_size(indev_act->driver.disp); /*Get the number of currently invalidated areas*/\n\n            lv_obj_set_pos(drag_obj, act_x, act_y);\n            proc->types.pointer.drag_in_prog = 1;\n\n            /*If the object didn't moved then clear the invalidated areas*/\n            if(drag_obj->coords.x1 == prev_x && drag_obj->coords.y1 == prev_y) {\n                /*In a special case if the object is moved on a page and\n                 * the scrollable has fit == true and the object is dragged of the page then\n                 * while its coordinate is not changing only the parent's size is reduced */\n                lv_coord_t act_par_w = lv_obj_get_width(lv_obj_get_parent(drag_obj));\n                lv_coord_t act_par_h = lv_obj_get_height(lv_obj_get_parent(drag_obj));\n                if(act_par_w == prev_par_w && act_par_h == prev_par_h) {\n                    uint16_t new_inv_buf_size = lv_disp_get_inv_buf_size(indev_act->driver.disp);\n                    _lv_disp_pop_from_inv_buf(indev_act->driver.disp, new_inv_buf_size - inv_buf_size);\n                }\n            }\n\n            /*Set the drag in progress flag*/\n            /*Send the drag begin signal on first move*/\n            if(drag_just_started) {\n                drag_obj->signal_cb(drag_obj, LV_SIGNAL_DRAG_BEGIN, indev_act);\n                if(indev_reset_check(proc)) return;\n\n                lv_event_send(drag_obj, LV_EVENT_DRAG_BEGIN, NULL);\n                if(indev_reset_check(proc)) return;\n            }\n\n        }\n    }\n}\n\n/**\n * Handle throwing by drag if the drag is ended\n * @param indev pointer to an input device state\n */\nstatic void indev_drag_throw(lv_indev_proc_t * proc)\n{\n    if(proc->types.pointer.drag_in_prog == 0) return;\n\n    lv_obj_t * drag_obj = get_dragged_obj(proc->types.pointer.last_obj);\n\n    if(drag_obj == NULL) return;\n\n    /*Return if the drag throw is not enabled*/\n    if(lv_obj_get_drag_throw(drag_obj) == false) {\n        proc->types.pointer.drag_in_prog = 0;\n        drag_obj->signal_cb(drag_obj, LV_SIGNAL_DRAG_END, indev_act);\n        if(indev_reset_check(proc)) return;\n\n        lv_event_send(drag_obj, LV_EVENT_DRAG_END, NULL);\n        return;\n    }\n\n    lv_drag_dir_t allowed_dirs = lv_obj_get_drag_dir(drag_obj);\n\n    /*Reduce the vectors*/\n    proc->types.pointer.drag_throw_vect.x =\n        proc->types.pointer.drag_throw_vect.x * (100 - indev_act->driver.drag_throw) / 100;\n    proc->types.pointer.drag_throw_vect.y =\n        proc->types.pointer.drag_throw_vect.y * (100 - indev_act->driver.drag_throw) / 100;\n\n    if(proc->types.pointer.drag_throw_vect.x != 0 || proc->types.pointer.drag_throw_vect.y != 0) {\n        /*Get the coordinates and modify them*/\n        lv_area_t coords_ori;\n        lv_obj_get_coords(drag_obj, &coords_ori);\n        lv_coord_t act_x = lv_obj_get_x(drag_obj) + proc->types.pointer.drag_throw_vect.x;\n        lv_coord_t act_y = lv_obj_get_y(drag_obj) + proc->types.pointer.drag_throw_vect.y;\n\n        if(allowed_dirs == LV_DRAG_DIR_BOTH) lv_obj_set_pos(drag_obj, act_x, act_y);\n        else if(allowed_dirs == LV_DRAG_DIR_HOR) lv_obj_set_x(drag_obj, act_x);\n        else if(allowed_dirs == LV_DRAG_DIR_VER) lv_obj_set_y(drag_obj, act_y);\n        else if(allowed_dirs == LV_DRAG_DIR_ONE) {\n            if(proc->types.pointer.drag_sum.x) lv_obj_set_x(drag_obj, act_x);\n            else lv_obj_set_y(drag_obj, act_y);\n        }\n        lv_area_t coord_new;\n        lv_obj_get_coords(drag_obj, &coord_new);\n\n        /*If non of the coordinates are changed then do not continue throwing*/\n        if((coords_ori.x1 == coord_new.x1 || proc->types.pointer.drag_throw_vect.x == 0) &&\n           (coords_ori.y1 == coord_new.y1 || proc->types.pointer.drag_throw_vect.y == 0)) {\n            proc->types.pointer.drag_in_prog      = 0;\n            proc->types.pointer.vect.x            = 0;\n            proc->types.pointer.vect.y            = 0;\n            proc->types.pointer.drag_throw_vect.x = 0;\n            proc->types.pointer.drag_throw_vect.y = 0;\n            drag_obj->signal_cb(drag_obj, LV_SIGNAL_DRAG_END, indev_act);\n            if(indev_reset_check(proc)) return;\n\n            lv_event_send(drag_obj, LV_EVENT_DRAG_END, NULL);\n            if(indev_reset_check(proc)) return;\n        }\n    }\n    /*If the types.pointer.vectors become 0 -> types.pointer.drag_in_prog = 0 and send a drag end\n       signal*/\n    else {\n        proc->types.pointer.drag_in_prog = 0;\n        drag_obj->signal_cb(drag_obj, LV_SIGNAL_DRAG_END, indev_act);\n        if(indev_reset_check(proc)) return;\n        lv_event_send(drag_obj, LV_EVENT_DRAG_END, NULL);\n        if(indev_reset_check(proc)) return;\n    }\n}\n\n\n/**\n * Get the really dragged object by taking `drag_parent` into account.\n * @param obj the start object\n * @return the object to really drag\n */\nstatic lv_obj_t * get_dragged_obj(lv_obj_t * obj)\n{\n    if(obj == NULL) return NULL;\n    lv_obj_t * drag_obj = obj;\n    while(lv_obj_get_drag_parent(drag_obj) != false && drag_obj != NULL) {\n        drag_obj = lv_obj_get_parent(drag_obj);\n    }\n\n    return drag_obj;\n}\n\n",
        "res_region": "",
        "lookback": "* Handle the gesture of indev_proc_p->types.pointer.act_obj",
        "lookahead": "/**",
        "label": [
            "ours",
            "base_underutilized"
        ],
        "start_line": 1172,
        "end_line": 1647,
        "merge_gen_region": null,
        "confidence": 0.8265568614006042,
        "hesitated": true
    },
    {
        "a_contents": "\n    if((LV_ABS(proc->types.pointer.vect.x) < indev_act->driver.gesture_min_velocity) &&\n       (LV_ABS(proc->types.pointer.vect.y) < indev_act->driver.gesture_min_velocity)) {",
        "b_contents": "    if((LV_MATH_ABS(proc->types.pointer.vect.x) < indev_act->driver.gesture_min_velocity) &&\n       (LV_MATH_ABS(proc->types.pointer.vect.y) < indev_act->driver.gesture_min_velocity)) {",
        "base_contents": "\n    if((LV_MATH_ABS(proc->types.pointer.vect.x) < indev_act->driver.gesture_min_velocity) &&\n       (LV_MATH_ABS(proc->types.pointer.vect.y) < indev_act->driver.gesture_min_velocity)) {",
        "res_region": "    if((LV_ABS(proc->types.pointer.vect.x) < indev_act->driver.gesture_min_velocity) &&\n       (LV_ABS(proc->types.pointer.vect.y) < indev_act->driver.gesture_min_velocity)) {",
        "lookback": "       (LV_ABS(proc->types.pointer.vect.y) < indev_act->driver.gesture_min_velocity)) {",
        "lookahead": "        proc->types.pointer.gesture_sum.x = 0;",
        "label": [
            "ours",
            "base_underutilized"
        ],
        "start_line": 1667,
        "end_line": 1678,
        "merge_gen_region": null,
        "confidence": 0.7609710693359375,
        "hesitated": true
    },
    {
        "a_contents": "\n",
        "b_contents": "",
        "base_contents": "",
        "res_region": "",
        "lookback": " * Checks if the reset_query flag has been set. If so, perform necessary global indev cleanup actions",
        "lookahead": "/**",
        "label": [
            "ours",
            "style_related"
        ],
        "start_line": 1712,
        "end_line": 1718,
        "merge_gen_region": null,
        "confidence": 0.7030057907104492,
        "hesitated": true
    }
]