[
    {
        "a_contents": "#if defined(LV_GC_INCLUDE)\n    #include LV_GC_INCLUDE\n#endif /* LV_ENABLE_GC */\n\n",
        "b_contents": "#if LV_USE_GPU_NXP_PXP && LV_USE_GPU_NXP_PXP_AUTO_INIT\n    #include \"../lv_gpu/lv_gpu_nxp_pxp.h\"\n    #include \"../lv_gpu/lv_gpu_nxp_pxp_osa.h\"\n#endif\n",
        "base_contents": "#if LV_USE_GPU_NXP_PXP && LV_USE_GPU_NXP_PXP_AUTO_INIT\n    #include \"../lv_gpu/lv_gpu_nxp_pxp.h\"\n    #include \"../lv_gpu/lv_gpu_nxp_pxp_osa.h\"\n#endif\n\n#if defined(LV_GC_INCLUDE)\n    #include LV_GC_INCLUDE\n#endif /* LV_ENABLE_GC */\n\n",
        "res_region": "#if defined(LV_GC_INCLUDE)\n    #include LV_GC_INCLUDE\n#endif /* LV_ENABLE_GC */\n\n",
        "lookback": "    #include LV_GC_INCLUDE",
        "lookahead": "#if defined(LV_USER_DATA_FREE_INCLUDE)",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 27,
        "end_line": 50,
        "merge_gen_region": null,
        "confidence": 0.6664330959320068,
        "hesitated": true
    },
    {
        "a_contents": "    return lv_obj_create_from_class(&lv_obj, parent, copy);\n}",
        "b_contents": "    lv_obj_t * new_obj = NULL;\n\n    /*Create a screen*/\n    if(parent == NULL) {\n        LV_LOG_TRACE(\"Screen create started\");\n        lv_disp_t * disp = lv_disp_get_default();\n        if(!disp) {\n            LV_LOG_WARN(\"lv_obj_create: not display created to so far. No place to assign the new screen\");\n            return NULL;\n        }\n\n        new_obj = _lv_ll_ins_head(&disp->scr_ll);\n        LV_ASSERT_MEM(new_obj);\n        if(new_obj == NULL) return NULL;\n\n        _lv_memset_00(new_obj, sizeof(lv_obj_t));\n\n#if LV_USE_BIDI\n        new_obj->base_dir     = LV_BIDI_BASE_DIR_DEF;\n#else\n        new_obj->base_dir     = LV_BIDI_DIR_LTR;\n#endif\n\n        /*Set the callbacks*/\n        new_obj->signal_cb = lv_obj_signal;\n        new_obj->design_cb = lv_obj_design;\n        new_obj->event_cb = NULL;\n\n        /*Set coordinates to full screen size*/\n        new_obj->coords.x1    = 0;\n        new_obj->coords.y1    = 0;\n        new_obj->coords.x2    = lv_disp_get_hor_res(NULL) - 1;\n        new_obj->coords.y2    = lv_disp_get_ver_res(NULL) - 1;\n    }\n    /*Create a normal object*/\n    else {\n        LV_LOG_TRACE(\"Object create started\");\n        LV_ASSERT_OBJ(parent, LV_OBJX_NAME);\n\n        new_obj = _lv_ll_ins_head(&parent->child_ll);\n        LV_ASSERT_MEM(new_obj);\n        if(new_obj == NULL) return NULL;\n\n        _lv_memset_00(new_obj, sizeof(lv_obj_t));\n\n        new_obj->parent = parent;\n\n#if LV_USE_BIDI\n        new_obj->base_dir     = LV_BIDI_DIR_INHERIT;\n#else\n        new_obj->base_dir     = LV_BIDI_DIR_LTR;\n#endif\n\n        /*Set the callbacks (signal:cb is required in `lv_obj_get_base_dir` if `LV_USE_ASSERT_OBJ` is enabled)*/\n        new_obj->signal_cb = lv_obj_signal;\n        new_obj->design_cb = lv_obj_design;\n        new_obj->event_cb = NULL;\n\n        new_obj->coords.y1    = parent->coords.y1;\n        new_obj->coords.y2    = parent->coords.y1 + LV_OBJ_DEF_HEIGHT;\n        if(lv_obj_get_base_dir(new_obj) == LV_BIDI_DIR_RTL) {\n            new_obj->coords.x2    = parent->coords.x2;\n            new_obj->coords.x1    = parent->coords.x2 - LV_OBJ_DEF_WIDTH;\n        }\n        else {\n            new_obj->coords.x1    = parent->coords.x1;\n            new_obj->coords.x2    = parent->coords.x1 + LV_OBJ_DEF_WIDTH;\n        }\n    }\n\n    _lv_ll_init(&(new_obj->child_ll), sizeof(lv_obj_t));\n\n    new_obj->ext_draw_pad = 0;\n\n#if LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_FULL\n    _lv_memset_00(&new_obj->ext_click_pad, sizeof(new_obj->ext_click_pad));\n#elif LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_TINY\n    new_obj->ext_click_pad_hor = 0;\n    new_obj->ext_click_pad_ver = 0;\n#endif\n\n    /*Init realign*/\n#if LV_USE_OBJ_REALIGN\n    new_obj->realign.align        = LV_ALIGN_CENTER;\n    new_obj->realign.xofs         = 0;\n    new_obj->realign.yofs         = 0;\n    new_obj->realign.base         = NULL;\n    new_obj->realign.auto_realign = 0;\n#endif\n\n    /*Init. user date*/\n#if LV_USE_USER_DATA\n    _lv_memset_00(&new_obj->user_data, sizeof(lv_obj_user_data_t));\n#endif\n\n#if LV_USE_GROUP\n    new_obj->group_p = NULL;\n#endif\n\n    /*Set attributes*/\n    new_obj->adv_hittest  = 0;\n    new_obj->click        = 1;\n    new_obj->drag         = 0;\n    new_obj->drag_throw   = 0;\n    new_obj->drag_parent  = 0;\n    new_obj->drag_dir     = LV_DRAG_DIR_BOTH;\n    new_obj->hidden       = 0;\n    new_obj->top          = 0;\n    new_obj->protect      = LV_PROTECT_NONE;\n    new_obj->parent_event = 0;\n    new_obj->gesture_parent = parent ? 1 : 0;\n    new_obj->focus_parent  = 0;\n    new_obj->state = LV_STATE_DEFAULT;\n\n    new_obj->ext_attr = NULL;\n\n    lv_style_list_init(&new_obj->style_list);\n    if(copy == NULL) {\n        if(parent != NULL) lv_theme_apply(new_obj, LV_THEME_OBJ);\n        else lv_theme_apply(new_obj, LV_THEME_SCR);\n    }\n    else {\n        lv_style_list_copy(&new_obj->style_list, &copy->style_list);\n    }\n    /*Copy the attributes if required*/\n    if(copy != NULL) {\n        lv_area_copy(&new_obj->coords, &copy->coords);\n        new_obj->ext_draw_pad = copy->ext_draw_pad;\n\n#if LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_FULL\n        lv_area_copy(&new_obj->ext_click_pad, &copy->ext_click_pad);\n#elif LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_TINY\n        new_obj->ext_click_pad_hor = copy->ext_click_pad_hor;\n        new_obj->ext_click_pad_ver = copy->ext_click_pad_ver;\n#endif",
        "base_contents": "    lv_obj_t * new_obj = NULL;\n\n    /*Create a screen*/\n    if(parent == NULL) {\n        LV_LOG_TRACE(\"Screen create started\");\n        lv_disp_t * disp = lv_disp_get_default();\n        if(!disp) {\n            LV_LOG_WARN(\"lv_obj_create: not display created to so far. No place to assign the new screen\");\n            return NULL;\n        }\n\n        new_obj = _lv_ll_ins_head(&disp->scr_ll);\n        LV_ASSERT_MEM(new_obj);\n        if(new_obj == NULL) return NULL;\n\n        _lv_memset_00(new_obj, sizeof(lv_obj_t));\n\n#if LV_USE_BIDI\n        new_obj->base_dir     = LV_BIDI_BASE_DIR_DEF;\n#else\n        new_obj->base_dir     = LV_BIDI_DIR_LTR;\n#endif\n\n        /*Set the callbacks*/\n        new_obj->signal_cb = lv_obj_signal;\n        new_obj->design_cb = lv_obj_design;\n        new_obj->event_cb = NULL;\n\n        /*Set coordinates to full screen size*/\n        new_obj->coords.x1    = 0;\n        new_obj->coords.y1    = 0;\n        new_obj->coords.x2    = lv_disp_get_hor_res(NULL) - 1;\n        new_obj->coords.y2    = lv_disp_get_ver_res(NULL) - 1;\n    }\n    /*Create a normal object*/\n    else {\n        LV_LOG_TRACE(\"Object create started\");\n        LV_ASSERT_OBJ(parent, LV_OBJX_NAME);\n\n        new_obj = _lv_ll_ins_head(&parent->child_ll);\n        LV_ASSERT_MEM(new_obj);\n        if(new_obj == NULL) return NULL;\n\n        _lv_memset_00(new_obj, sizeof(lv_obj_t));\n\n        new_obj->parent = parent;\n\n#if LV_USE_BIDI\n        new_obj->base_dir     = LV_BIDI_DIR_INHERIT;\n#else\n        new_obj->base_dir     = LV_BIDI_DIR_LTR;\n#endif\n\n        /*Set the callbacks (signal:cb is required in `lv_obj_get_base_dir` if `LV_USE_ASSERT_OBJ` is enabled)*/\n        new_obj->signal_cb = lv_obj_signal;\n        new_obj->design_cb = lv_obj_design;\n        new_obj->event_cb = NULL;\n\n        new_obj->coords.y1    = parent->coords.y1;\n        new_obj->coords.y2    = parent->coords.y1 + LV_OBJ_DEF_HEIGHT;\n        if(lv_obj_get_base_dir(new_obj) == LV_BIDI_DIR_RTL) {\n            new_obj->coords.x2    = parent->coords.x2;\n            new_obj->coords.x1    = parent->coords.x2 - LV_OBJ_DEF_WIDTH;\n        }\n        else {\n            new_obj->coords.x1    = parent->coords.x1;\n            new_obj->coords.x2    = parent->coords.x1 + LV_OBJ_DEF_WIDTH;\n        }\n    }\n\n\n    _lv_ll_init(&(new_obj->child_ll), sizeof(lv_obj_t));\n\n\n    new_obj->ext_draw_pad = 0;\n\n#if LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_FULL\n    _lv_memset_00(&new_obj->ext_click_pad, sizeof(new_obj->ext_click_pad));\n#elif LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_TINY\n    new_obj->ext_click_pad_hor = 0;\n    new_obj->ext_click_pad_ver = 0;\n#endif\n\n    /*Init realign*/\n#if LV_USE_OBJ_REALIGN\n    new_obj->realign.align        = LV_ALIGN_CENTER;\n    new_obj->realign.xofs         = 0;\n    new_obj->realign.yofs         = 0;\n    new_obj->realign.base         = NULL;\n    new_obj->realign.auto_realign = 0;\n#endif\n\n    /*Init. user date*/\n#if LV_USE_USER_DATA\n    _lv_memset_00(&new_obj->user_data, sizeof(lv_obj_user_data_t));\n#endif\n\n\n#if LV_USE_GROUP\n    new_obj->group_p = NULL;\n#endif\n\n    /*Set attributes*/\n    new_obj->adv_hittest  = 0;\n    new_obj->click        = 1;\n    new_obj->drag         = 0;\n    new_obj->drag_throw   = 0;\n    new_obj->drag_parent  = 0;\n    new_obj->drag_dir     = LV_DRAG_DIR_BOTH;\n    new_obj->hidden       = 0;\n    new_obj->top          = 0;\n    new_obj->protect      = LV_PROTECT_NONE;\n    new_obj->parent_event = 0;\n    new_obj->gesture_parent = parent ? 1 : 0;\n    new_obj->focus_parent  = 0;\n    new_obj->state = LV_STATE_DEFAULT;\n\n    new_obj->ext_attr = NULL;\n\n    lv_style_list_init(&new_obj->style_list);\n    if(copy == NULL) {\n        if(parent != NULL) lv_theme_apply(new_obj, LV_THEME_OBJ);\n        else  lv_theme_apply(new_obj, LV_THEME_SCR);\n    }\n    else {\n        lv_style_list_copy(&new_obj->style_list, &copy->style_list);\n    }\n    /*Copy the attributes if required*/\n    if(copy != NULL) {\n        lv_area_copy(&new_obj->coords, &copy->coords);\n        new_obj->ext_draw_pad = copy->ext_draw_pad;\n\n#if LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_FULL\n        lv_area_copy(&new_obj->ext_click_pad, &copy->ext_click_pad);\n#elif LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_TINY\n        new_obj->ext_click_pad_hor = copy->ext_click_pad_hor;\n        new_obj->ext_click_pad_ver = copy->ext_click_pad_ver;\n#endif",
        "res_region": "    return lv_obj_create_from_class(&lv_obj, parent, copy);\n}",
        "lookback": "}",
        "lookahead": "",
        "label": [
            "ours",
            "base_underutilized"
        ],
        "start_line": 240,
        "end_line": 518,
        "merge_gen_region": " lvobjcreatefromclassclassobj parent copy",
        "confidence": 0.9136903882026672,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "    obj->parent = parent;\n",
        "b_contents": "",
        "base_contents": "",
        "res_region": "    obj->parent = parent;\n",
        "lookback": "",
        "lookahead": "    if(new_base_dir != LV_BIDI_DIR_RTL) {",
        "label": [
            "ours",
            "base_underutilized"
        ],
        "start_line": 785,
        "end_line": 791,
        "merge_gen_region": null,
        "confidence": 0.8139100670814514,
        "hesitated": true
    },
    {
        "a_contents": "/*-----------------\n * Attribute set\n *----------------*/\n\n/**\n * Set the base direction of the object\n * @param obj pointer to an object\n * @param dir the new base direction. `LV_BIDI_DIR_LTR/RTL/AUTO/INHERIT`\n */\nvoid lv_obj_set_base_dir(lv_obj_t * obj, lv_bidi_dir_t dir)\n{\n    if(dir != LV_BIDI_DIR_LTR && dir != LV_BIDI_DIR_RTL &&\n       dir != LV_BIDI_DIR_AUTO && dir != LV_BIDI_DIR_INHERIT) {",
        "b_contents": "    /*Calculate and set the movement*/\n    lv_point_t diff;\n    diff.x = x - obj->coords.x1;\n    diff.y = y - obj->coords.y1;",
        "base_contents": "\n    /*Calculate and set the movement*/\n    lv_point_t diff;\n    diff.x = x - obj->coords.x1;\n    diff.y = y - obj->coords.y1;",
        "res_region": "/*-----------------\n * Attribute set\n *----------------*/\n\n/**\n * Set the base direction of the object\n * @param obj pointer to an object\n * @param dir the new base direction. `LV_BIDI_DIR_LTR/RTL/AUTO/INHERIT`\n */\nvoid lv_obj_set_base_dir(lv_obj_t * obj, lv_bidi_dir_t dir)\n{\n    if(dir != LV_BIDI_DIR_LTR && dir != LV_BIDI_DIR_RTL &&\n       dir != LV_BIDI_DIR_AUTO && dir != LV_BIDI_DIR_INHERIT) {",
        "lookback": " * Attribute set",
        "lookahead": "",
        "label": [
            "ours",
            "base_underutilized"
        ],
        "start_line": 908,
        "end_line": 933,
        "merge_gen_region": null,
        "confidence": 0.8330317139625549,
        "hesitated": true
    },
    {
        "a_contents": "    if(obj == NULL) {\n        /*If no obj specified refresh all screen of all displays */\n        lv_disp_t * d = lv_disp_get_next(NULL);\n        while(d) {\n            uint32_t i;\n            for(i = 0; i < d->screen_cnt; i++) {\n                lv_event_send_refresh_recursive(d->screens[i]);",
        "b_contents": "    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    if(base == NULL) base = lv_obj_get_parent(obj);\n\n    LV_ASSERT_OBJ(base, LV_OBJX_NAME);\n\n    obj_align_core(obj, base, align, true, true, x_ofs, y_ofs);\n\n#if LV_USE_OBJ_REALIGN\n    /*Save the last align parameters to use them in `lv_obj_realign`*/\n    obj->realign.align       = align;\n    obj->realign.xofs        = x_ofs;\n    obj->realign.yofs        = y_ofs;\n    obj->realign.base        = base;\n    obj->realign.mid_align = 0;\n#endif\n}\n\n/**\n * Align an object to an other object horizontally.\n * @param obj pointer to an object to align\n * @param base pointer to an object (if NULL the parent is used). 'obj' will be aligned to it.\n * @param align type of alignment (see 'lv_align_t' enum)\n * @param x_ofs x coordinate offset after alignment\n */\nvoid lv_obj_align_x(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t x_ofs)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    if(base == NULL) base = lv_obj_get_parent(obj);\n\n    LV_ASSERT_OBJ(base, LV_OBJX_NAME);\n\n    obj_align_core(obj, base, align, true, false, x_ofs, 0);\n}\n\n/**\n * Align an object to an other object vertically.\n * @param obj pointer to an object to align\n * @param base pointer to an object (if NULL the parent is used). 'obj' will be aligned to it.\n * @param align type of alignment (see 'lv_align_t' enum)\n * @param y_ofs y coordinate offset after alignment\n */\nvoid lv_obj_align_y(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t y_ofs)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    if(base == NULL) base = lv_obj_get_parent(obj);\n\n    LV_ASSERT_OBJ(base, LV_OBJX_NAME);\n\n    obj_align_core(obj, base, align, false, true, 0, y_ofs);\n}\n\n/**\n * Align an object's middle point to an other object.\n * @param obj pointer to an object to align\n * @param base pointer to an object (if NULL the parent is used). 'obj' will be aligned to it.\n * @param align type of alignment (see 'lv_align_t' enum)\n * @param x_ofs x coordinate offset after alignment\n * @param y_ofs y coordinate offset after alignment\n */\nvoid lv_obj_align_mid(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t x_ofs, lv_coord_t y_ofs)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    if(base == NULL) {\n        base = lv_obj_get_parent(obj);\n    }\n\n    LV_ASSERT_OBJ(base, LV_OBJX_NAME);\n\n    obj_align_mid_core(obj, base, align, true, true, x_ofs, y_ofs);\n\n#if LV_USE_OBJ_REALIGN\n    /*Save the last align parameters to use them in `lv_obj_realign`*/\n    obj->realign.align       = align;\n    obj->realign.xofs        = x_ofs;\n    obj->realign.yofs        = y_ofs;\n    obj->realign.base        = base;\n    obj->realign.mid_align = 1;\n#endif\n}\n\n/**\n * Align an object's middle point to an other object horizontally.\n * @param obj pointer to an object to align\n * @param base pointer to an object (if NULL the parent is used). 'obj' will be aligned to it.\n * @param align type of alignment (see 'lv_align_t' enum)\n * @param x_ofs x coordinate offset after alignment\n */\nvoid lv_obj_align_mid_x(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t x_ofs)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    if(base == NULL) {\n        base = lv_obj_get_parent(obj);\n    }\n\n    LV_ASSERT_OBJ(base, LV_OBJX_NAME);\n\n    obj_align_mid_core(obj, base, align, true, false, x_ofs, 0);\n}\n\n/**\n * Align an object's middle point to an other object vertically.\n * @param obj pointer to an object to align\n * @param base pointer to an object (if NULL the parent is used). 'obj' will be aligned to it.\n * @param align type of alignment (see 'lv_align_t' enum)\n * @param y_ofs y coordinate offset after alignment\n */\nvoid lv_obj_align_mid_y(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t y_ofs)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    if(base == NULL) {\n        base = lv_obj_get_parent(obj);\n    }\n\n    LV_ASSERT_OBJ(base, LV_OBJX_NAME);\n\n    obj_align_mid_core(obj, base, align, false, true, 0, y_ofs);\n}\n\n/**\n * Realign the object based on the last `lv_obj_align` parameters.\n * @param obj pointer to an object\n */\nvoid lv_obj_realign(lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_OBJ_REALIGN\n    if(obj->realign.mid_align)\n        lv_obj_align_mid(obj, obj->realign.base, obj->realign.align, obj->realign.xofs, obj->realign.yofs);\n    else\n        lv_obj_align(obj, obj->realign.base, obj->realign.align, obj->realign.xofs, obj->realign.yofs);\n#else\n    (void)obj;\n    LV_LOG_WARN(\"lv_obj_realign: no effect because LV_USE_OBJ_REALIGN = 0\");\n#endif\n}\n\n/**\n * Enable the automatic realign of the object when its size has changed based on the last\n * `lv_obj_align` parameters.\n * @param obj pointer to an object\n * @param en true: enable auto realign; false: disable auto realign\n */\nvoid lv_obj_set_auto_realign(lv_obj_t * obj, bool en)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_OBJ_REALIGN\n    obj->realign.auto_realign = en ? 1 : 0;\n#else\n    (void)obj;\n    (void)en;\n    LV_LOG_WARN(\"lv_obj_set_auto_realign: no effect because LV_USE_OBJ_REALIGN = 0\");\n#endif\n}\n\n/**\n * Set the size of an extended clickable area\n * If TINY mode is used, only the largest of the horizontal and vertical padding\n * values are considered.\n * @param obj pointer to an object\n * @param left extended clickable are on the left [px]\n * @param right extended clickable are on the right [px]\n * @param top extended clickable are on the top [px]\n * @param bottom extended clickable are on the bottom [px]\n */\nvoid lv_obj_set_ext_click_area(lv_obj_t * obj, lv_coord_t left, lv_coord_t right, lv_coord_t top, lv_coord_t bottom)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_FULL\n    obj->ext_click_pad.x1 = left;\n    obj->ext_click_pad.x2 = right;\n    obj->ext_click_pad.y1 = top;\n    obj->ext_click_pad.y2 = bottom;\n#elif LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_TINY\n    obj->ext_click_pad_hor = LV_MATH_MAX(left, right);\n    obj->ext_click_pad_ver = LV_MATH_MAX(top, bottom);\n#else\n    (void)obj;    /*Unused*/\n    (void)left;   /*Unused*/\n    (void)right;  /*Unused*/\n    (void)top;    /*Unused*/\n    (void)bottom; /*Unused*/\n#endif\n}\n\n/*---------------------\n * Appearance set\n *--------------------*/\n\n/**\n * Add a new style to the style list of an object.\n * @param obj pointer to an object\n * @param part the part of the object which style property should be set.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param style pointer to a style to add (Only its pointer will be saved)\n */\nvoid lv_obj_add_style(lv_obj_t * obj, uint8_t part, lv_style_t * style)\n{\n    if(style == NULL) return;\n\n    lv_style_list_t * style_dsc = lv_obj_get_style_list(obj, part);\n    if(style_dsc == NULL) {\n        LV_LOG_WARN(\"Can't find style with part: %d\", part);\n        return;\n    }\n\n    _lv_style_list_add_style(style_dsc, style);\n#if LV_USE_ANIMATION\n    trans_del(obj, part, 0xFF, NULL);\n#endif\n    lv_obj_refresh_style(obj, part, LV_STYLE_PROP_ALL);\n}\n\n/**\n * Remove a style from the style list of an object.\n * @param obj pointer to an object\n * @param part the part of the object which style property should be set.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param style pointer to a style to remove\n */\nvoid lv_obj_remove_style(lv_obj_t * obj, uint8_t part, lv_style_t * style)\n{\n    if(style == NULL) return;\n\n    lv_style_list_t * style_dsc = lv_obj_get_style_list(obj, part);\n    if(style_dsc == NULL) {\n        LV_LOG_WARN(\"Can't find style with part: %d\", part);\n        return;\n    }\n\n    _lv_style_list_remove_style(style_dsc, style);\n#if LV_USE_ANIMATION\n    trans_del(obj, part, 0xFF, NULL);\n#endif\n    lv_obj_refresh_style(obj, part, LV_STYLE_PROP_ALL);\n}\n\n/**\n * Reset a style to the default (empty) state.\n * Release all used memories and cancel pending related transitions.\n * Typically used in `LV_SIGN_CLEAN_UP.\n * @param obj pointer to an object\n * @param part the part of the object which style list should be reset.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n */\nvoid lv_obj_clean_style_list(lv_obj_t * obj, uint8_t part)\n{\n    lv_style_list_t * style_dsc = lv_obj_get_style_list(obj, part);\n    if(style_dsc == NULL) {\n        LV_LOG_WARN(\"lv_obj_clean_style_list: can't find style with `part`\");\n        return;\n    }\n\n    _lv_style_list_reset(style_dsc);\n#if LV_USE_ANIMATION\n    trans_del(obj, part, 0xFF, NULL);\n#endif\n}\n\n/**\n * Reset a style to the default (empty) state.\n * Release all used memories and cancel pending related transitions.\n * Also notifies the object about the style change.\n * @param obj pointer to an object\n * @param part the part of the object which style list should be reset.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n */\nvoid lv_obj_reset_style_list(lv_obj_t * obj, uint8_t part)\n{\n    lv_obj_clean_style_list(obj, part);\n\n    lv_obj_refresh_style(obj, part, LV_STYLE_PROP_ALL);\n}\n\n/**\n * Set a local style property of a part of an object in a given state.\n * @param obj pointer to an object\n * @param part the part of the object which style property should be set.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_BORDER_WIDTH | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @param the value to set\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_opa()`\n * @note for performance reasons it's not checked if the property really has integer type\n */\nvoid _lv_obj_set_style_local_int(lv_obj_t * obj, uint8_t part, lv_style_property_t prop, lv_style_int_t value)\n{\n    lv_style_list_t * style_dsc = lv_obj_get_style_list(obj, part);\n    _lv_style_list_set_local_int(style_dsc, prop, value);\n#if LV_USE_ANIMATION\n    trans_del(obj, part, prop, NULL);\n#endif\n    lv_obj_refresh_style(obj, part, prop & (~LV_STYLE_STATE_MASK));\n}\n\n/**\n * Set a local style property of a part of an object in a given state.\n * @param obj pointer to an object\n * @param part the part of the object which style property should be set.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_BORDER_COLOR | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @param the value to set\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_opa()`\n * @note for performance reasons it's not checked if the property really has color type\n */\nvoid _lv_obj_set_style_local_color(lv_obj_t * obj, uint8_t part, lv_style_property_t prop, lv_color_t color)\n{\n    lv_style_list_t * style_dsc = lv_obj_get_style_list(obj, part);\n    _lv_style_list_set_local_color(style_dsc, prop, color);\n#if LV_USE_ANIMATION\n    trans_del(obj, part, prop, NULL);\n#endif\n    lv_obj_refresh_style(obj, part, prop & (~LV_STYLE_STATE_MASK));\n}\n\n/**\n * Set a local style property of a part of an object in a given state.\n * @param obj pointer to an object\n * @param part the part of the object which style property should be set.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_BORDER_OPA | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @param the value to set\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_opa()`\n * @note for performance reasons it's not checked if the property really has opacity type\n */\nvoid _lv_obj_set_style_local_opa(lv_obj_t * obj, uint8_t part, lv_style_property_t prop, lv_opa_t opa)\n{\n    lv_style_list_t * style_dsc = lv_obj_get_style_list(obj, part);\n    _lv_style_list_set_local_opa(style_dsc, prop, opa);\n#if LV_USE_ANIMATION\n    trans_del(obj, part, prop, NULL);\n#endif\n    lv_obj_refresh_style(obj, part, prop & (~LV_STYLE_STATE_MASK));\n}\n\n/**\n * Set a local style property of a part of an object in a given state.\n * @param obj pointer to an object\n * @param part the part of the object which style property should be set.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_TEXT_FONT | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @param value the value to set\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_opa()`\n * @note for performance reasons it's not checked if the property really has pointer type\n */\nvoid _lv_obj_set_style_local_ptr(lv_obj_t * obj, uint8_t part, lv_style_property_t prop, const void * value)\n{\n    lv_style_list_t * style_dsc = lv_obj_get_style_list(obj, part);\n    _lv_style_list_set_local_ptr(style_dsc, prop, value);\n#if LV_USE_ANIMATION\n    trans_del(obj, part, prop, NULL);\n#endif\n    lv_obj_refresh_style(obj, part, prop & (~LV_STYLE_STATE_MASK));\n}\n\n/**\n * Remove a local style property from a part of an object with a given state.\n * @param obj pointer to an object\n * @param part the part of the object which style property should be removed.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_TEXT_FONT | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @note shouldn't be used directly. Use the specific property remove functions instead.\n *       For example: `lv_obj_style_remove_border_opa()`\n * @return true: the property was found and removed; false: the property was not found\n */\nbool lv_obj_remove_style_local_prop(lv_obj_t * obj, uint8_t part, lv_style_property_t prop)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n    lv_style_t * style = lv_obj_get_local_style(obj, part);\n    if(style) return lv_style_remove_prop(style, prop);\n    else return false;\n}\n\n/**\n * Notify an object (and its children) about its style is modified\n * @param obj pointer to an object\n * @param part the part of the object which style property should be refreshed.\n * @param prop `LV_STYLE_PROP_ALL` or an `LV_STYLE_...` property. It is used to optimize what needs to be refreshed.\n */\nvoid lv_obj_refresh_style(lv_obj_t * obj, uint8_t part, lv_style_property_t prop)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    invalidate_style_cache(obj, part, prop);\n\n    /*If a real style refresh is required*/\n    bool real_refr = false;\n    switch(prop) {\n        case LV_STYLE_PROP_ALL:\n        case LV_STYLE_CLIP_CORNER:\n        case LV_STYLE_SIZE:\n        case LV_STYLE_TRANSFORM_WIDTH:\n        case LV_STYLE_TRANSFORM_HEIGHT:\n        case LV_STYLE_TRANSFORM_ANGLE:\n        case LV_STYLE_TRANSFORM_ZOOM:\n        case LV_STYLE_PAD_TOP:\n        case LV_STYLE_PAD_BOTTOM:\n        case LV_STYLE_PAD_LEFT:\n        case LV_STYLE_PAD_RIGHT:\n        case LV_STYLE_PAD_INNER:\n        case LV_STYLE_MARGIN_TOP:\n        case LV_STYLE_MARGIN_BOTTOM:\n        case LV_STYLE_MARGIN_LEFT:\n        case LV_STYLE_MARGIN_RIGHT:\n        case LV_STYLE_OUTLINE_WIDTH:\n        case LV_STYLE_OUTLINE_PAD:\n        case LV_STYLE_OUTLINE_OPA:\n        case LV_STYLE_SHADOW_WIDTH:\n        case LV_STYLE_SHADOW_OPA:\n        case LV_STYLE_SHADOW_OFS_X:\n        case LV_STYLE_SHADOW_OFS_Y:\n        case LV_STYLE_SHADOW_SPREAD:\n        case LV_STYLE_VALUE_LETTER_SPACE:\n        case LV_STYLE_VALUE_LINE_SPACE:\n        case LV_STYLE_VALUE_OFS_X:\n        case LV_STYLE_VALUE_OFS_Y:\n        case LV_STYLE_VALUE_ALIGN:\n        case LV_STYLE_VALUE_STR:\n        case LV_STYLE_VALUE_FONT:\n        case LV_STYLE_VALUE_OPA:\n        case LV_STYLE_TEXT_LETTER_SPACE:\n        case LV_STYLE_TEXT_LINE_SPACE:\n        case LV_STYLE_TEXT_FONT:\n        case LV_STYLE_LINE_WIDTH:\n            real_refr = true;\n            break;\n        default:\n            real_refr = false;\n    }\n\n    if(real_refr) {\n        lv_obj_invalidate(obj);\n        obj->signal_cb(obj, LV_SIGNAL_STYLE_CHG, NULL);\n\n        switch(prop) {\n            case LV_STYLE_PROP_ALL:\n            case LV_STYLE_MARGIN_TOP:\n            case LV_STYLE_MARGIN_BOTTOM:\n            case LV_STYLE_MARGIN_LEFT:\n            case LV_STYLE_MARGIN_RIGHT:\n                if(obj->parent) obj->parent->signal_cb(obj->parent, LV_SIGNAL_CHILD_CHG, NULL);\n                break;\n        }\n\n        lv_obj_invalidate(obj);\n\n        /*Send style change signals*/\n        if(prop == LV_STYLE_PROP_ALL || (prop & LV_STYLE_INHERIT_MASK)) refresh_children_style(obj);\n    }\n    else {\n        lv_obj_invalidate(obj);\n    }\n}\n\n/**\n * Notify all object if a style is modified\n * @param style pointer to a style. Only the objects with this style will be notified\n *               (NULL to notify all objects)\n */\nvoid lv_obj_report_style_mod(lv_style_t * style)\n{\n    lv_disp_t * d = lv_disp_get_next(NULL);\n\n    while(d) {\n        lv_obj_t * i;\n        _LV_LL_READ(d->scr_ll, i) {\n            report_style_mod_core(style, i);\n        }\n        d = lv_disp_get_next(d);\n    }\n}\n\n/**\n * Enable/disable the use of style cache for an object\n * @param obj pointer to an object\n * @param dis true: disable; false: enable (re-enable)\n */\nvoid _lv_obj_disable_style_caching(lv_obj_t * obj, bool dis)\n{\n    uint8_t part;\n    for(part = 0; part < _LV_OBJ_PART_REAL_FIRST; part++) {\n        lv_style_list_t * list = lv_obj_get_style_list(obj, part);\n        if(list == NULL) break;\n        list->ignore_cache = dis;\n    }\n    for(part = _LV_OBJ_PART_REAL_FIRST; part < 0xFF; part++) {\n        lv_style_list_t * list = lv_obj_get_style_list(obj, part);\n        if(list == NULL) break;\n        list->ignore_cache = dis;\n    }\n}\n\n/*-----------------\n * Attribute set\n *----------------*/\n\n/**\n * Hide an object. It won't be visible and clickable.\n * @param obj pointer to an object\n * @param en true: hide the object\n */\nvoid lv_obj_set_hidden(lv_obj_t * obj, bool en)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    if(!obj->hidden) lv_obj_invalidate(obj); /*Invalidate when not hidden (hidden objects are ignored) */\n\n    obj->hidden = en == false ? 0 : 1;\n\n    if(!obj->hidden) lv_obj_invalidate(obj); /*Invalidate when not hidden (hidden objects are ignored) */\n\n    lv_obj_t * par = lv_obj_get_parent(obj);\n    if(par) par->signal_cb(par, LV_SIGNAL_CHILD_CHG, obj);\n}\n\n/**\n * Set whether advanced hit-testing is enabled on an object\n * @param obj pointer to an object\n * @param en true: advanced hit-testing is enabled\n */\nvoid lv_obj_set_adv_hittest(lv_obj_t * obj, bool en)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->adv_hittest = en == false ? 0 : 1;\n}\n\n/**\n * Enable or disable the clicking of an object\n * @param obj pointer to an object\n * @param en true: make the object clickable\n */\nvoid lv_obj_set_click(lv_obj_t * obj, bool en)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->click = (en == true ? 1 : 0);\n}\n\n/**\n * Enable to bring this object to the foreground if it\n * or any of its children is clicked\n * @param obj pointer to an object\n * @param en true: enable the auto top feature\n */\nvoid lv_obj_set_top(lv_obj_t * obj, bool en)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->top = (en == true ? 1 : 0);\n}\n\n/**\n * Enable the dragging of an object\n * @param obj pointer to an object\n * @param en true: make the object draggable\n */\nvoid lv_obj_set_drag(lv_obj_t * obj, bool en)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    if(en == true) lv_obj_set_click(obj, true); /*Drag is useless without enabled clicking*/\n    obj->drag = (en == true ? 1 : 0);\n}\n\n/**\n * Set the directions an object can be dragged in\n * @param obj pointer to an object\n * @param drag_dir bitwise OR of allowed directions an object can be dragged in\n */\nvoid lv_obj_set_drag_dir(lv_obj_t * obj, lv_drag_dir_t drag_dir)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->drag_dir = drag_dir;\n\n    if(obj->drag_dir != 0) lv_obj_set_drag(obj, true); /*Drag direction requires drag*/\n}\n\n/**\n * Enable the throwing of an object after is is dragged\n * @param obj pointer to an object\n * @param en true: enable the drag throw\n */\nvoid lv_obj_set_drag_throw(lv_obj_t * obj, bool en)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->drag_throw = (en == true ? 1 : 0);\n}\n\n/**\n * Enable to use parent for drag related operations.\n * If trying to drag the object the parent will be moved instead\n * @param obj pointer to an object\n * @param en true: enable the 'drag parent' for the object\n */\nvoid lv_obj_set_drag_parent(lv_obj_t * obj, bool en)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->drag_parent = (en == true ? 1 : 0);\n}\n\n/**\n* Enable to use parent for gesture related operations.\n* If trying to gesture the object the parent will be moved instead\n* @param obj pointer to an object\n* @param en true: enable the 'gesture parent' for the object\n*/\nvoid lv_obj_set_gesture_parent(lv_obj_t * obj, bool en)\n{\n    obj->gesture_parent = (en == true ? 1 : 0);\n}\n\n/**\n* Enable to use parent for focus state.\n* When object is focused the parent will get the state instead (visual only)\n* @param obj pointer to an object\n* @param en true: enable the 'focus parent' for the object\n*/\nvoid lv_obj_set_focus_parent(lv_obj_t * obj, bool en)\n{\n    if(lv_obj_is_focused(obj)) {\n        if(en) {\n            obj->focus_parent = 1;\n            lv_obj_clear_state(obj, LV_STATE_FOCUSED | LV_STATE_EDITED);\n            lv_obj_set_state(lv_obj_get_focused_obj(obj), LV_STATE_FOCUSED);\n        }\n        else {\n            lv_obj_clear_state(lv_obj_get_focused_obj(obj), LV_STATE_FOCUSED | LV_STATE_EDITED);\n            lv_obj_set_state(obj, LV_STATE_FOCUSED);\n            obj->focus_parent = 0;\n        }\n    }\n    else {\n        obj->focus_parent = (en == true ? 1 : 0);\n    }\n}\n\n/**\n * Propagate the events to the parent too\n * @param obj pointer to an object\n * @param en true: enable the event propagation\n */\nvoid lv_obj_set_parent_event(lv_obj_t * obj, bool en)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->parent_event = (en == true ? 1 : 0);\n}\n\n/**\n * Set the base direction of the object.\n * @note This only works if LV_USE_BIDI is enabled.\n * @param obj pointer to an object\n * @param dir the new base direction. `LV_BIDI_DIR_LTR/RTL/AUTO/INHERIT`\n */\nvoid lv_obj_set_base_dir(lv_obj_t * obj, lv_bidi_dir_t dir)\n{\n    if(dir != LV_BIDI_DIR_LTR && dir != LV_BIDI_DIR_RTL &&\n       dir != LV_BIDI_DIR_AUTO && dir != LV_BIDI_DIR_INHERIT) {\n\n        LV_LOG_WARN(\"lv_obj_set_base_dir: invalid base dir\");\n        return;\n    }\n\n    obj->base_dir = dir;\n    lv_signal_send(obj, LV_SIGNAL_BASE_DIR_CHG, NULL);\n\n    /* Notify the children about the parent base dir has changed.\n     * (The children might have `LV_BIDI_DIR_INHERIT`)*/\n    base_dir_refr_children(obj);\n}\n\n/**\n * Set a bit or bits in the protect filed\n * @param obj pointer to an object\n * @param prot 'OR'-ed values from `lv_protect_t`\n */\nvoid lv_obj_add_protect(lv_obj_t * obj, uint8_t prot)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->protect |= prot;\n}\n\n/**\n * Clear a bit or bits in the protect filed\n * @param obj pointer to an object\n * @param prot 'OR'-ed values from `lv_protect_t`\n */\nvoid lv_obj_clear_protect(lv_obj_t * obj, uint8_t prot)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    prot = (~prot) & 0xFF;\n    obj->protect &= prot;\n}\n\n/**\n * Set the state (fully overwrite) of an object.\n * If specified in the styles a transition animation will be started\n * from the previous state to the current\n * @param obj pointer to an object\n * @param state the new state\n */\nvoid lv_obj_set_state(lv_obj_t * obj, lv_state_t new_state)\n{\n    if(obj->state == new_state) return;\n\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_state_t prev_state = obj->state;\n    style_snapshot_res_t cmp_res = STYLE_COMPARE_SAME;\n    uint8_t part;\n    for(part = 0; part < _LV_OBJ_PART_REAL_FIRST; part++) {\n        lv_style_list_t * style_list = lv_obj_get_style_list(obj, part);\n        if(style_list == NULL) break;   /*No more style lists*/\n        obj->state = prev_state;\n        style_snapshot_t shot_pre;\n        style_snapshot(obj, part, &shot_pre);\n        obj->state = new_state;\n        style_snapshot_t shot_post;\n        style_snapshot(obj, part, &shot_post);\n\n        style_snapshot_res_t r = style_snapshot_compare(&shot_pre, &shot_post);\n        if(r == STYLE_COMPARE_DIFF) {\n            cmp_res = STYLE_COMPARE_DIFF;\n            break;\n        }\n        if(r == STYLE_COMPARE_VISUAL_DIFF) {\n            cmp_res = STYLE_COMPARE_VISUAL_DIFF;\n        }\n    }\n\n    obj->state = new_state;\n\n    if(cmp_res == STYLE_COMPARE_SAME) {\n        return;\n    }\n\n#if LV_USE_ANIMATION == 0\n    if(cmp_res == STYLE_COMPARE_DIFF) lv_obj_refresh_style(obj, part, LV_STYLE_PROP_ALL);\n    else if(cmp_res == STYLE_COMPARE_VISUAL_DIFF) lv_obj_refresh_style(obj, LV_OBJ_PART_ALL, LV_STYLE_PROP_ALL);\n#else\n\n    for(part = 0; part < _LV_OBJ_PART_REAL_LAST; part++) {\n        lv_style_list_t * style_list = lv_obj_get_style_list(obj, part);\n        if(style_list == NULL) break;   /*No more style lists*/\n        if(style_list->ignore_trans) continue;\n\n        lv_style_int_t time = lv_obj_get_style_transition_time(obj, part);\n        lv_style_property_t props[LV_STYLE_TRANS_NUM_MAX];\n        lv_style_int_t delay = lv_obj_get_style_transition_delay(obj, part);\n        lv_anim_path_t * path = lv_obj_get_style_transition_path(obj, part);\n        props[0] = lv_obj_get_style_transition_prop_1(obj, part);\n        props[1] = lv_obj_get_style_transition_prop_2(obj, part);\n        props[2] = lv_obj_get_style_transition_prop_3(obj, part);\n        props[3] = lv_obj_get_style_transition_prop_4(obj, part);\n        props[4] = lv_obj_get_style_transition_prop_5(obj, part);\n        props[5] = lv_obj_get_style_transition_prop_6(obj, part);\n\n        uint8_t i;\n        for(i = 0; i < LV_STYLE_TRANS_NUM_MAX; i++) {\n            if(props[i] != 0) {\n                _lv_style_list_add_trans_style(style_list);\n\n                lv_style_trans_t * tr = trans_create(obj, props[i], part, prev_state, new_state);\n\n                /*If there is a pending anim for this property remove it*/\n                if(tr) {\n                    tr->obj = obj;\n                    tr->prop = props[i];\n                    tr->part = part;\n\n                    lv_anim_t a;\n                    lv_anim_init(&a);\n                    lv_anim_set_var(&a, tr);\n                    lv_anim_set_exec_cb(&a, (lv_anim_exec_xcb_t)trans_anim_cb);\n                    lv_anim_set_start_cb(&a, trans_anim_start_cb);\n                    lv_anim_set_ready_cb(&a, trans_anim_ready_cb);\n                    lv_anim_set_values(&a, 0x00, 0xFF);\n                    lv_anim_set_time(&a, time);\n                    lv_anim_set_delay(&a, delay);\n                    lv_anim_set_path(&a, path);\n                    a.early_apply = 0;\n                    lv_anim_start(&a);\n                }\n\n            }\n        }\n        if(cmp_res == STYLE_COMPARE_DIFF) lv_obj_refresh_style(obj, part, LV_STYLE_PROP_ALL);\n\n        if(cmp_res == STYLE_COMPARE_VISUAL_DIFF) {\n            invalidate_style_cache(obj, part, LV_STYLE_PROP_ALL);\n        }\n    }\n\n    if(cmp_res == STYLE_COMPARE_VISUAL_DIFF) {\n        lv_obj_invalidate(obj);\n    }\n\n#endif\n\n}\n\n/**\n * Add a given state or states to the object. The other state bits will remain unchanged.\n * If specified in the styles a transition animation will be started\n * from the previous state to the current\n * @param obj pointer to an object\n * @param state the state bits to add. E.g `LV_STATE_PRESSED | LV_STATE_FOCUSED`\n */\nvoid lv_obj_add_state(lv_obj_t * obj, lv_state_t state)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_state_t new_state = obj->state | state;\n    if(obj->state != new_state) {\n        lv_obj_set_state(obj, new_state);\n    }\n}\n\n/**\n * Remove a given state or states to the object. The other state bits will remain unchanged.\n * If specified in the styles a transition animation will be started\n * from the previous state to the current\n * @param obj pointer to an object\n * @param state the state bits to remove. E.g `LV_STATE_PRESSED | LV_STATE_FOCUSED`\n */\nvoid lv_obj_clear_state(lv_obj_t * obj, lv_state_t state)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_state_t new_state = obj->state & (~state);\n    if(obj->state != new_state) {\n        lv_obj_set_state(obj, new_state);\n    }\n}\n\n#if LV_USE_ANIMATION\n/**\n * Finish all pending transitions on a part of an object\n * @param obj pointer to an object\n * @param part part of the object, e.g `LV_BRN_PART_MAIN` or `LV_OBJ_PART_ALL` for all parts\n */\nvoid lv_obj_finish_transitions(lv_obj_t * obj, uint8_t part)\n{\n    /*Animate all related transition to the end value*/\n    lv_style_trans_t * tr;\n    _LV_LL_READ_BACK(LV_GC_ROOT(_lv_obj_style_trans_ll), tr) {\n        if(tr->obj == obj && (part == tr->part || part == LV_OBJ_PART_ALL)) {\n            trans_anim_cb(tr, 255);\n        }\n    }\n\n    /*Free all related transition data*/\n    trans_del(obj, part, 0xFF, NULL);\n}\n#endif\n\n/**\n * Set a an event handler function for an object.\n * Used by the user to react on event which happens with the object.\n * @param obj pointer to an object\n * @param event_cb the new event function\n */\nvoid lv_obj_set_event_cb(lv_obj_t * obj, lv_event_cb_t event_cb)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->event_cb = event_cb;\n}\n\n/**\n * Send an event to the object\n * @param obj pointer to an object\n * @param event the type of the event from `lv_event_t`\n * @param data arbitrary data depending on the object type and the event. (Usually `NULL`)\n * @return LV_RES_OK: `obj` was not deleted in the event; LV_RES_INV: `obj` was deleted in the event\n */\nlv_res_t lv_event_send(lv_obj_t * obj, lv_event_t event, const void * data)\n{\n    if(obj == NULL) return LV_RES_OK;\n\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_res_t res;\n    res = lv_event_send_func(obj->event_cb, obj, event, data);\n    return res;\n}\n\n/**\n * Send LV_EVENT_REFRESH event to an object\n * @param obj point to an object. (Can NOT be NULL)\n * @return LV_RES_OK: success, LV_RES_INV: to object become invalid (e.g. deleted) due to this event.\n */\nlv_res_t lv_event_send_refresh(lv_obj_t * obj)\n{\n    return lv_event_send(obj, LV_EVENT_REFRESH, NULL);\n}\n\n/**\n * Send LV_EVENT_REFRESH event to an object and all of its children.\n * @param obj pointer to an object or NULL to refresh all objects of all displays\n */\nvoid lv_event_send_refresh_recursive(lv_obj_t * obj)\n{\n    if(obj == NULL) {\n        /*If no obj specified refresh all screen of all displays */\n        lv_disp_t * d = lv_disp_get_next(NULL);\n        while(d) {\n            lv_obj_t * scr = _lv_ll_get_head(&d->scr_ll);\n            while(scr) {\n                lv_event_send_refresh_recursive(scr);\n                scr = _lv_ll_get_next(&d->scr_ll, scr);\n            }\n            lv_event_send_refresh_recursive(d->top_layer);\n            lv_event_send_refresh_recursive(d->sys_layer);\n\n            d = lv_disp_get_next(d);\n        }\n    }\n    else {\n\n        lv_res_t res = lv_event_send_refresh(obj);\n        if(res != LV_RES_OK) return; /*If invalid returned do not check the children*/\n\n        lv_obj_t * child = lv_obj_get_child(obj, NULL);\n        while(child) {\n            lv_event_send_refresh_recursive(child);\n\n            child = lv_obj_get_child(obj, child);\n        }\n    }\n}\n\n/**\n * Call an event function with an object, event, and data.\n * @param event_xcb an event callback function. If `NULL` `LV_RES_OK` will return without any actions.\n *        (the 'x' in the argument name indicates that its not a fully generic function because it not follows\n *         the `func_name(object, callback, ...)` convention)\n * @param obj pointer to an object to associate with the event (can be `NULL` to simply call the `event_cb`)\n * @param event an event\n * @param data pointer to a custom data\n * @return LV_RES_OK: `obj` was not deleted in the event; LV_RES_INV: `obj` was deleted in the event\n */\nlv_res_t lv_event_send_func(lv_event_cb_t event_xcb, lv_obj_t * obj, lv_event_t event, const void * data)\n{\n    if(obj != NULL) {\n        LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n    }\n\n    /* Build a simple linked list from the objects used in the events\n     * It's important to know if an this object was deleted by a nested event\n     * called from this `even_cb`. */\n    lv_event_temp_data_t event_temp_data;\n    event_temp_data.obj     = obj;\n    event_temp_data.deleted = false;\n    event_temp_data.prev    = NULL;\n\n    if(event_temp_data_head) {\n        event_temp_data.prev = event_temp_data_head;\n    }\n    event_temp_data_head = &event_temp_data;\n\n    const void * event_act_data_save = event_act_data;\n    event_act_data                   = data;\n\n    /*Call the input device's feedback callback if set*/\n    lv_indev_t * indev_act = lv_indev_get_act();\n    if(indev_act) {\n        if(indev_act->driver.feedback_cb) indev_act->driver.feedback_cb(&indev_act->driver, event);\n    }\n\n    /*Call the event callback itself*/\n    if(event_xcb) event_xcb(obj, event);\n\n    /*Restore the event data*/\n    event_act_data = event_act_data_save;\n\n    /*Remove this element from the list*/\n    event_temp_data_head = event_temp_data_head->prev;\n\n    if(event_temp_data.deleted) {\n        return LV_RES_INV;\n    }\n\n    if(obj) {\n        if(obj->parent_event && obj->parent) {\n            lv_res_t res = lv_event_send(obj->parent, event, data);\n            if(res != LV_RES_OK) {\n                return LV_RES_INV;\n            }\n        }\n    }\n\n    return LV_RES_OK;\n}\n\n/**\n * Get the `data` parameter of the current event\n * @return the `data` parameter\n */\nconst void * lv_event_get_data(void)\n{\n    return event_act_data;\n}\n\n/**\n * Set the a signal function of an object. Used internally by the library.\n * Always call the previous signal function in the new.\n * @param obj pointer to an object\n * @param cb the new signal function\n */\nvoid lv_obj_set_signal_cb(lv_obj_t * obj, lv_signal_cb_t signal_cb)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->signal_cb = signal_cb;\n}\n\n/**\n * Send an event to the object\n * @param obj pointer to an object\n * @param event the type of the event from `lv_event_t`.\n * @return LV_RES_OK or LV_RES_INV\n */\nlv_res_t lv_signal_send(lv_obj_t * obj, lv_signal_t signal, void * param)\n{\n    if(obj == NULL) return LV_RES_OK;\n\n    lv_res_t res = LV_RES_OK;\n    if(obj->signal_cb) res = obj->signal_cb(obj, signal, param);\n\n    return res;\n}\n\n/**\n * Set a new design function for an object\n * @param obj pointer to an object\n * @param design_cb the new design function\n */\nvoid lv_obj_set_design_cb(lv_obj_t * obj, lv_design_cb_t design_cb)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->design_cb = design_cb;\n}\n\n/*----------------\n * Other set\n *--------------*/\n\n/**\n * Allocate a new ext. data for an object\n * @param obj pointer to an object\n * @param ext_size the size of the new ext. data\n * @return pointer to the allocated ext.\n * If out of memory NULL is returned and the original ext is preserved\n */\nvoid * lv_obj_allocate_ext_attr(lv_obj_t * obj, uint16_t ext_size)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    void * new_ext = lv_mem_realloc(obj->ext_attr, ext_size);\n    if(new_ext == NULL) return NULL;\n\n    obj->ext_attr = new_ext;\n    return (void *)obj->ext_attr;\n}\n\n/**\n * Send a 'LV_SIGNAL_REFR_EXT_SIZE' signal to the object to refresh the extended draw area.\n * he object needs to be invalidated by `lv_obj_invalidate(obj)` manually after this function.\n * @param obj pointer to an object\n */\nvoid lv_obj_refresh_ext_draw_pad(lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->ext_draw_pad = 0;\n    obj->signal_cb(obj, LV_SIGNAL_REFR_EXT_DRAW_PAD, NULL);\n\n}\n\n/*=======================\n * Getter functions\n *======================*/\n\n/**\n * Return with the screen of an object\n * @param obj pointer to an object\n * @return pointer to a screen\n */\nlv_obj_t * lv_obj_get_screen(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    const lv_obj_t * par = obj;\n    const lv_obj_t * act_p;\n\n    do {\n        act_p = par;\n        par   = lv_obj_get_parent(act_p);\n    } while(par != NULL);\n\n    return (lv_obj_t *)act_p;\n}\n\n/**\n * Get the display of an object\n * @param scr pointer to an object\n * @return pointer the object's display\n */\nlv_disp_t * lv_obj_get_disp(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    const lv_obj_t * scr;\n\n    if(obj->parent == NULL)\n        scr = obj; /*`obj` is a screen*/\n    else\n        scr = lv_obj_get_screen(obj); /*get the screen of `obj`*/\n\n    lv_disp_t * d;\n    _LV_LL_READ(LV_GC_ROOT(_lv_disp_ll), d) {\n        lv_obj_t * s;\n        _LV_LL_READ(d->scr_ll, s) {\n            if(s == scr) return d;\n        }\n    }\n\n    LV_LOG_WARN(\"lv_scr_get_disp: screen not found\")\n    return NULL;\n}\n\n/*---------------------\n * Parent/children get\n *--------------------*/\n\n/**\n * Returns with the parent of an object\n * @param obj pointer to an object\n * @return pointer to the parent of  'obj'\n */\nlv_obj_t * lv_obj_get_parent(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return obj->parent;\n}\n\n/**\n * Iterate through the children of an object (start from the \"youngest\")\n * @param obj pointer to an object\n * @param child NULL at first call to get the next children\n *                  and the previous return value later\n * @return the child after 'act_child' or NULL if no more child\n */\nlv_obj_t * lv_obj_get_child(const lv_obj_t * obj, const lv_obj_t * child)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_obj_t * result = NULL;\n\n    if(child == NULL) {\n        result = _lv_ll_get_head(&obj->child_ll);\n    }\n    else {\n        result = _lv_ll_get_next(&obj->child_ll, child);\n    }\n\n    return result;\n}\n\n/**\n * Iterate through the children of an object (start from the \"oldest\")\n * @param obj pointer to an object\n * @param child NULL at first call to get the next children\n *                  and the previous return value later\n * @return the child after 'act_child' or NULL if no more child\n */\nlv_obj_t * lv_obj_get_child_back(const lv_obj_t * obj, const lv_obj_t * child)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_obj_t * result = NULL;\n\n    if(child == NULL) {\n        result = _lv_ll_get_tail(&obj->child_ll);\n    }\n    else {\n        result = _lv_ll_get_prev(&obj->child_ll, child);\n    }\n\n    return result;\n}\n\n/**\n * Count the children of an object (only children directly on 'obj')\n * @param obj pointer to an object\n * @return children number of 'obj'\n */\nuint16_t lv_obj_count_children(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_obj_t * i;\n    uint16_t cnt = 0;\n\n    _LV_LL_READ(obj->child_ll, i) cnt++;\n\n    return cnt;\n}\n\n/** Recursively count the children of an object\n * @param obj pointer to an object\n * @return children number of 'obj'\n */\nuint16_t lv_obj_count_children_recursive(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_obj_t * i;\n    uint16_t cnt = 0;\n\n    _LV_LL_READ(obj->child_ll, i) {\n        cnt++;                                     /*Count the child*/\n        cnt += lv_obj_count_children_recursive(i); /*recursively count children's children*/\n    }\n\n    return cnt;\n}\n\n/*---------------------\n * Coordinate get\n *--------------------*/\n\n/**\n * Copy the coordinates of an object to an area\n * @param obj pointer to an object\n * @param cords_p pointer to an area to store the coordinates\n */\nvoid lv_obj_get_coords(const lv_obj_t * obj, lv_area_t * cords_p)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_area_copy(cords_p, &obj->coords);\n}\n\n/**\n * Reduce area retried by `lv_obj_get_coords()` the get graphically usable area of an object.\n * (Without the size of the border or other extra graphical elements)\n * @param coords_p store the result area here\n */\nvoid lv_obj_get_inner_coords(const lv_obj_t * obj, lv_area_t * coords_p)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_border_side_t part = lv_obj_get_style_border_side(obj, LV_OBJ_PART_MAIN);\n    lv_coord_t w = lv_obj_get_style_border_width(obj, LV_OBJ_PART_MAIN);\n\n    if(part & LV_BORDER_SIDE_LEFT) coords_p->x1 += w;\n\n    if(part & LV_BORDER_SIDE_RIGHT) coords_p->x2 -= w;\n\n    if(part & LV_BORDER_SIDE_TOP) coords_p->y1 += w;\n\n    if(part & LV_BORDER_SIDE_BOTTOM) coords_p->y2 -= w;\n}\n\n/**\n * Get the x coordinate of object\n * @param obj pointer to an object\n * @return distance of 'obj' from the left side of its parent\n */\nlv_coord_t lv_obj_get_x(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_coord_t rel_x;\n    lv_obj_t * parent = lv_obj_get_parent(obj);\n    if(parent) {\n        rel_x             = obj->coords.x1 - parent->coords.x1;\n    }\n    else {\n        rel_x = obj->coords.x1;\n    }\n    return rel_x;\n}\n\n/**\n * Get the y coordinate of object\n * @param obj pointer to an object\n * @return distance of 'obj' from the top of its parent\n */\nlv_coord_t lv_obj_get_y(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_coord_t rel_y;\n    lv_obj_t * parent = lv_obj_get_parent(obj);\n    if(parent) {\n        rel_y             = obj->coords.y1 - parent->coords.y1;\n    }\n    else {\n        rel_y = obj->coords.y1;\n    }\n    return rel_y;\n}\n\n/**\n * Get the width of an object\n * @param obj pointer to an object\n * @return the width\n */\nlv_coord_t lv_obj_get_width(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return lv_area_get_width(&obj->coords);\n}\n\n/**\n * Get the height of an object\n * @param obj pointer to an object\n * @return the height\n */\nlv_coord_t lv_obj_get_height(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return lv_area_get_height(&obj->coords);\n}\n\n/**\n * Get that width reduced by the left and right padding.\n * @param obj pointer to an object\n * @return the width which still fits into the container\n */\nlv_coord_t lv_obj_get_width_fit(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_style_int_t left = lv_obj_get_style_pad_left(obj, LV_OBJ_PART_MAIN);\n    lv_style_int_t right = lv_obj_get_style_pad_right(obj, LV_OBJ_PART_MAIN);\n\n    return lv_obj_get_width(obj) - left - right;\n}\n\n/**\n * Get that height reduced by the top an bottom padding.\n * @param obj pointer to an object\n * @return the height which still fits into the container\n */\nlv_coord_t lv_obj_get_height_fit(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_style_int_t top = lv_obj_get_style_pad_top((lv_obj_t *)obj, LV_OBJ_PART_MAIN);\n    lv_style_int_t bottom =  lv_obj_get_style_pad_bottom((lv_obj_t *)obj, LV_OBJ_PART_MAIN);\n\n    return lv_obj_get_height(obj) - top - bottom;\n}\n\n/**\n * Get the height of an object by taking the top and bottom margin into account.\n * The returned height will be `obj_h + margin_top + margin_bottom`\n * @param obj pointer to an object\n * @return the height including thee margins\n */\nlv_coord_t lv_obj_get_height_margin(lv_obj_t * obj)\n{\n    lv_style_int_t mtop = lv_obj_get_style_margin_top(obj, LV_OBJ_PART_MAIN);\n    lv_style_int_t mbottom = lv_obj_get_style_margin_bottom(obj, LV_OBJ_PART_MAIN);\n\n    return lv_obj_get_height(obj) + mtop + mbottom;\n}\n\n/**\n * Get the width of an object by taking the left and right margin into account.\n * The returned width will be `obj_w + margin_left + margin_right`\n * @param obj pointer to an object\n * @return the height including thee margins\n */\nlv_coord_t lv_obj_get_width_margin(lv_obj_t * obj)\n{\n    lv_style_int_t mleft = lv_obj_get_style_margin_left(obj, LV_OBJ_PART_MAIN);\n    lv_style_int_t mright = lv_obj_get_style_margin_right(obj, LV_OBJ_PART_MAIN);\n\n    return lv_obj_get_width(obj) + mleft + mright;\n}\n\n/**\n * Set that width reduced by the left and right padding of the parent.\n * @param obj pointer to an object\n * @param div indicates how many columns are assumed.\n * If 1 the width will be set the parent's width\n * If 2 only half parent width - inner padding of the parent\n * If 3 only third parent width - 2 * inner padding of the parent\n * @param span how many columns are combined\n * @return the width according to the given parameters\n */\nlv_coord_t lv_obj_get_width_grid(lv_obj_t * obj, uint8_t div, uint8_t span)\n{\n    lv_coord_t obj_w = lv_obj_get_width_fit(obj);\n    lv_style_int_t pinner = lv_obj_get_style_pad_inner(obj, LV_OBJ_PART_MAIN);\n\n    lv_coord_t r = (obj_w - (div - 1) * pinner) / div;\n\n    r = r * span + (span - 1) * pinner;\n    return r;\n}\n\n/**\n * Get that height reduced by the top and bottom padding of the parent.\n * @param obj pointer to an object\n * @param div indicates how many rows are assumed.\n * If 1 the height will be set the parent's height\n * If 2 only half parent height - inner padding of the parent\n * If 3 only third parent height - 2 * inner padding of the parent\n * @param span how many rows are combined\n * @return the height according to the given parameters\n */\nlv_coord_t lv_obj_get_height_grid(lv_obj_t * obj, uint8_t div, uint8_t span)\n{\n    lv_coord_t obj_h = lv_obj_get_height_fit(obj);\n    lv_style_int_t pinner = lv_obj_get_style_pad_inner(obj, LV_OBJ_PART_MAIN);\n\n    lv_coord_t r = (obj_h - (div - 1) * pinner) / div;\n\n    r = r * span + (span - 1) * pinner;\n    return r;\n}\n\n/**\n * Get the automatic realign property of the object.\n * @param obj pointer to an object\n * @return true: auto realign is enabled; false: auto realign is disabled\n */\nbool lv_obj_get_auto_realign(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_OBJ_REALIGN\n    return obj->realign.auto_realign ? true : false;\n#else\n    (void)obj;\n    return false;\n#endif\n}\n\n/**\n * Get the left padding of extended clickable area\n * @param obj pointer to an object\n * @return the extended left padding\n */\nlv_coord_t lv_obj_get_ext_click_pad_left(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_TINY\n    return obj->ext_click_pad_hor;\n#elif LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_FULL\n    return obj->ext_click_pad.x1;\n#else\n    (void)obj;    /*Unused*/\n    return 0;\n#endif\n}\n\n/**\n * Get the right padding of extended clickable area\n * @param obj pointer to an object\n * @return the extended right padding\n */\nlv_coord_t lv_obj_get_ext_click_pad_right(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_TINY\n    return obj->ext_click_pad_hor;\n#elif LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_FULL\n    return obj->ext_click_pad.x2;\n#else\n    (void)obj; /*Unused*/\n    return 0;\n#endif\n}\n\n/**\n * Get the top padding of extended clickable area\n * @param obj pointer to an object\n * @return the extended top padding\n */\nlv_coord_t lv_obj_get_ext_click_pad_top(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_TINY\n    return obj->ext_click_pad_ver;\n#elif LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_FULL\n    return obj->ext_click_pad.y1;\n#else\n    (void)obj; /*Unused*/\n    return 0;\n#endif\n}\n\n/**\n * Get the bottom padding of extended clickable area\n * @param obj pointer to an object\n * @return the extended bottom padding\n */\nlv_coord_t lv_obj_get_ext_click_pad_bottom(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_TINY\n    return obj->ext_click_pad_ver;\n#elif LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_FULL\n    return obj->ext_click_pad.y2;\n#else\n    (void)obj; /*Unused*/\n    return 0;\n#endif\n}\n\n/**\n * Get the extended size attribute of an object\n * @param obj pointer to an object\n * @return the extended size attribute\n */\nlv_coord_t lv_obj_get_ext_draw_pad(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return obj->ext_draw_pad;\n}\n\n/*-----------------\n * Appearance get\n *---------------*/\n\nlv_style_list_t * lv_obj_get_style_list(const lv_obj_t * obj, uint8_t part)\n{\n    if(part == LV_OBJ_PART_MAIN) return &((lv_obj_t *)obj)->style_list;\n\n    lv_get_style_info_t info;\n    info.part = part;\n    info.result = NULL;\n\n    lv_res_t res;\n    res = lv_signal_send((lv_obj_t *)obj, LV_SIGNAL_GET_STYLE, &info);\n\n    if(res != LV_RES_OK) return NULL;\n\n    return info.result;\n}\n\n/**\n * Get a style property of a part of an object in the object's current state.\n * If there is a running transitions it is taken into account\n * @param obj pointer to an object\n * @param part the part of the object which style property should be get.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop the property to get. E.g. `LV_STYLE_BORDER_WIDTH`.\n *  The state of the object will be added internally\n * @return the value of the property of the given part in the current state.\n * If the property is not found a default value will be returned.\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_width()`\n * @note for performance reasons it's not checked if the property really has integer type\n */\nlv_style_int_t _lv_obj_get_style_int(const lv_obj_t * obj, uint8_t part, lv_style_property_t prop)\n{\n    lv_style_property_t prop_ori = prop;\n\n    lv_style_attr_t attr;\n    attr = prop_ori >> 8;\n\n    lv_style_int_t value_act;\n    lv_res_t res = LV_RES_INV;\n    const lv_obj_t * parent = obj;\n    while(parent) {\n        lv_style_list_t * list = lv_obj_get_style_list(parent, part);\n        if(!list->ignore_cache && list->style_cnt > 0) {\n            if(!list->valid_cache) update_style_cache((lv_obj_t *)parent, part, prop  & (~LV_STYLE_STATE_MASK));\n\n            bool def = false;\n            switch(prop  & (~LV_STYLE_STATE_MASK)) {\n                case LV_STYLE_CLIP_CORNER:\n                    if(list->clip_corner_off) def = true;\n                    break;\n                case LV_STYLE_TEXT_LETTER_SPACE:\n                case LV_STYLE_TEXT_LINE_SPACE:\n                    if(list->text_space_zero) def = true;\n                    break;\n                case LV_STYLE_TRANSFORM_ANGLE:\n                case LV_STYLE_TRANSFORM_WIDTH:\n                case LV_STYLE_TRANSFORM_HEIGHT:\n                case LV_STYLE_TRANSFORM_ZOOM:\n                    if(list->transform_all_zero) def = true;\n                    break;\n                case LV_STYLE_BORDER_WIDTH:\n                    if(list->border_width_zero) def = true;\n                    break;\n                case LV_STYLE_BORDER_SIDE:\n                    if(list->border_side_full) def = true;\n                    break;\n                case LV_STYLE_BORDER_POST:\n                    if(list->border_post_off) def = true;\n                    break;\n                case LV_STYLE_OUTLINE_WIDTH:\n                    if(list->outline_width_zero) def = true;\n                    break;\n                case LV_STYLE_RADIUS:\n                    if(list->radius_zero) def = true;\n                    break;\n                case LV_STYLE_SHADOW_WIDTH:\n                    if(list->shadow_width_zero) def = true;\n                    break;\n                case LV_STYLE_PAD_TOP:\n                case LV_STYLE_PAD_BOTTOM:\n                case LV_STYLE_PAD_LEFT:\n                case LV_STYLE_PAD_RIGHT:\n                    if(list->pad_all_zero) def = true;\n                    break;\n                case LV_STYLE_MARGIN_TOP:\n                case LV_STYLE_MARGIN_BOTTOM:\n                case LV_STYLE_MARGIN_LEFT:\n                case LV_STYLE_MARGIN_RIGHT:\n                    if(list->margin_all_zero) def = true;\n                    break;\n                case LV_STYLE_BG_BLEND_MODE:\n                case LV_STYLE_BORDER_BLEND_MODE:\n                case LV_STYLE_IMAGE_BLEND_MODE:\n                case LV_STYLE_LINE_BLEND_MODE:\n                case LV_STYLE_OUTLINE_BLEND_MODE:\n                case LV_STYLE_PATTERN_BLEND_MODE:\n                case LV_STYLE_SHADOW_BLEND_MODE:\n                case LV_STYLE_TEXT_BLEND_MODE:\n                case LV_STYLE_VALUE_BLEND_MODE:\n                    if(list->blend_mode_all_normal) def = true;\n                    break;\n                case LV_STYLE_TEXT_DECOR:\n                    if(list->text_decor_none) def = true;\n                    break;\n            }\n\n            if(def) {\n                break;\n            }\n        }\n\n        lv_state_t state = lv_obj_get_state(parent, part);\n        prop = (uint16_t)prop_ori + ((uint16_t)state << LV_STYLE_STATE_POS);\n\n        res = _lv_style_list_get_int(list, prop, &value_act);\n        if(res == LV_RES_OK) return value_act;\n\n        if(LV_STYLE_ATTR_GET_INHERIT(attr) == 0) break;\n\n        /*If not found, check the `MAIN` style first*/\n        if(part != LV_OBJ_PART_MAIN) {\n            part = LV_OBJ_PART_MAIN;\n            continue;\n        }\n\n        /*Check the parent too.*/\n        parent = lv_obj_get_parent(parent);\n    }\n\n    /*Handle unset values*/\n    prop = prop & (~LV_STYLE_STATE_MASK);\n    switch(prop) {\n        case LV_STYLE_BORDER_SIDE:\n            return LV_BORDER_SIDE_FULL;\n        case LV_STYLE_SIZE:\n            return LV_DPI / 20;\n        case LV_STYLE_SCALE_WIDTH:\n            return LV_DPI / 8;\n        case LV_STYLE_BG_GRAD_STOP:\n            return 255;\n        case LV_STYLE_TRANSFORM_ZOOM:\n            return LV_IMG_ZOOM_NONE;\n    }\n\n    return 0;\n}\n\n/**\n * Get a style property of a part of an object in the object's current state.\n * If there is a running transitions it is taken into account\n * @param obj pointer to an object\n * @param part the part of the object which style property should be get.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop the property to get. E.g. `LV_STYLE_BORDER_COLOR`.\n *  The state of the object will be added internally\n * @return the value of the property of the given part in the current state.\n * If the property is not found a default value will be returned.\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_color()`\n * @note for performance reasons it's not checked if the property really has color type\n */\nlv_color_t _lv_obj_get_style_color(const lv_obj_t * obj, uint8_t part, lv_style_property_t prop)\n{\n    lv_style_property_t prop_ori = prop;\n\n    lv_style_attr_t attr;\n    attr = prop_ori >> 8;\n\n    lv_color_t value_act;\n    lv_res_t res = LV_RES_INV;\n    const lv_obj_t * parent = obj;\n    while(parent) {\n        lv_style_list_t * list = lv_obj_get_style_list(parent, part);\n\n        lv_state_t state = lv_obj_get_state(parent, part);\n        prop = (uint16_t)prop_ori + ((uint16_t)state << LV_STYLE_STATE_POS);\n\n        res = _lv_style_list_get_color(list, prop, &value_act);\n        if(res == LV_RES_OK) return value_act;\n\n        if(LV_STYLE_ATTR_GET_INHERIT(attr) == 0) break;\n\n        /*If not found, check the `MAIN` style first*/\n        if(part != LV_OBJ_PART_MAIN) {\n            part = LV_OBJ_PART_MAIN;\n            continue;\n        }\n\n        /*Check the parent too.*/\n        parent = lv_obj_get_parent(parent);\n    }\n\n    /*Handle unset values*/\n    prop = prop & (~LV_STYLE_STATE_MASK);\n    switch(prop) {\n        case LV_STYLE_BG_COLOR:\n        case LV_STYLE_BG_GRAD_COLOR:\n            return LV_COLOR_WHITE;\n    }\n\n    return LV_COLOR_BLACK;\n}\n\n/**\n * Get a style property of a part of an object in the object's current state.\n * If there is a running transitions it is taken into account\n * @param obj pointer to an object\n * @param part the part of the object which style property should be get.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop the property to get. E.g. `LV_STYLE_BORDER_OPA`.\n *  The state of the object will be added internally\n * @return the value of the property of the given part in the current state.\n * If the property is not found a default value will be returned.\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_opa()`\n * @note for performance reasons it's not checked if the property really has opacity type\n */\nlv_opa_t _lv_obj_get_style_opa(const lv_obj_t * obj, uint8_t part, lv_style_property_t prop)\n{\n    lv_style_property_t prop_ori = prop;\n\n    lv_style_attr_t attr;\n    attr = prop_ori >> 8;\n\n    lv_opa_t value_act;\n    lv_res_t res = LV_RES_INV;\n    const lv_obj_t * parent = obj;\n    while(parent) {\n        lv_style_list_t * list = lv_obj_get_style_list(parent, part);\n\n        if(!list->ignore_cache && list->style_cnt > 0) {\n            if(!list->valid_cache) update_style_cache((lv_obj_t *)parent, part, prop  & (~LV_STYLE_STATE_MASK));\n            bool def = false;\n            switch(prop & (~LV_STYLE_STATE_MASK)) {\n                case LV_STYLE_OPA_SCALE:\n                    if(list->opa_scale_cover) def = true;\n                    break;\n                case LV_STYLE_BG_OPA:\n                    if(list->bg_opa_cover) return LV_OPA_COVER;     /*Special case, not the default value is used*/\n                    if(list->bg_opa_transp) def = true;\n                    break;\n                case LV_STYLE_IMAGE_RECOLOR_OPA:\n                    if(list->img_recolor_opa_transp) def = true;\n                    break;\n            }\n\n            if(def) {\n                break;",
        "base_contents": "    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    if(base == NULL) base = lv_obj_get_parent(obj);\n\n    LV_ASSERT_OBJ(base, LV_OBJX_NAME);\n\n    obj_align_core(obj, base, align, true, true, x_ofs, y_ofs);\n\n#if LV_USE_OBJ_REALIGN\n    /*Save the last align parameters to use them in `lv_obj_realign`*/\n    obj->realign.align       = align;\n    obj->realign.xofs        = x_ofs;\n    obj->realign.yofs        = y_ofs;\n    obj->realign.base        = base;\n    obj->realign.mid_align = 0;\n#endif\n}\n\n/**\n * Align an object to an other object horizontally.\n * @param obj pointer to an object to align\n * @param base pointer to an object (if NULL the parent is used). 'obj' will be aligned to it.\n * @param align type of alignment (see 'lv_align_t' enum)\n * @param x_ofs x coordinate offset after alignment\n */\nvoid lv_obj_align_x(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t x_ofs)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    if(base == NULL) base = lv_obj_get_parent(obj);\n\n    LV_ASSERT_OBJ(base, LV_OBJX_NAME);\n\n    obj_align_core(obj, base, align, true, false, x_ofs, 0);\n}\n\n/**\n * Align an object to an other object vertically.\n * @param obj pointer to an object to align\n * @param base pointer to an object (if NULL the parent is used). 'obj' will be aligned to it.\n * @param align type of alignment (see 'lv_align_t' enum)\n * @param y_ofs y coordinate offset after alignment\n */\nvoid lv_obj_align_y(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t y_ofs)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    if(base == NULL) base = lv_obj_get_parent(obj);\n\n    LV_ASSERT_OBJ(base, LV_OBJX_NAME);\n\n    obj_align_core(obj, base, align, false, true, 0, y_ofs);\n}\n\n/**\n * Align an object's middle point to an other object.\n * @param obj pointer to an object to align\n * @param base pointer to an object (if NULL the parent is used). 'obj' will be aligned to it.\n * @param align type of alignment (see 'lv_align_t' enum)\n * @param x_ofs x coordinate offset after alignment\n * @param y_ofs y coordinate offset after alignment\n */\nvoid lv_obj_align_mid(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t x_ofs, lv_coord_t y_ofs)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    if(base == NULL) {\n        base = lv_obj_get_parent(obj);\n    }\n\n    LV_ASSERT_OBJ(base, LV_OBJX_NAME);\n\n\n    obj_align_mid_core(obj, base, align, true, true, x_ofs, y_ofs);\n\n#if LV_USE_OBJ_REALIGN\n    /*Save the last align parameters to use them in `lv_obj_realign`*/\n    obj->realign.align       = align;\n    obj->realign.xofs        = x_ofs;\n    obj->realign.yofs        = y_ofs;\n    obj->realign.base        = base;\n    obj->realign.mid_align = 1;\n#endif\n}\n\n/**\n * Align an object's middle point to an other object horizontally.\n * @param obj pointer to an object to align\n * @param base pointer to an object (if NULL the parent is used). 'obj' will be aligned to it.\n * @param align type of alignment (see 'lv_align_t' enum)\n * @param x_ofs x coordinate offset after alignment\n */\nvoid lv_obj_align_mid_x(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t x_ofs)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    if(base == NULL) {\n        base = lv_obj_get_parent(obj);\n    }\n\n    LV_ASSERT_OBJ(base, LV_OBJX_NAME);\n\n\n    obj_align_mid_core(obj, base, align, true, false, x_ofs, 0);\n}\n\n\n/**\n * Align an object's middle point to an other object vertically.\n * @param obj pointer to an object to align\n * @param base pointer to an object (if NULL the parent is used). 'obj' will be aligned to it.\n * @param align type of alignment (see 'lv_align_t' enum)\n * @param y_ofs y coordinate offset after alignment\n */\nvoid lv_obj_align_mid_y(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t y_ofs)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    if(base == NULL) {\n        base = lv_obj_get_parent(obj);\n    }\n\n    LV_ASSERT_OBJ(base, LV_OBJX_NAME);\n\n\n    obj_align_mid_core(obj, base, align, false, true, 0, y_ofs);\n}\n\n/**\n * Realign the object based on the last `lv_obj_align` parameters.\n * @param obj pointer to an object\n */\nvoid lv_obj_realign(lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_OBJ_REALIGN\n    if(obj->realign.mid_align)\n        lv_obj_align_mid(obj, obj->realign.base, obj->realign.align, obj->realign.xofs, obj->realign.yofs);\n    else\n        lv_obj_align(obj, obj->realign.base, obj->realign.align, obj->realign.xofs, obj->realign.yofs);\n#else\n    (void)obj;\n    LV_LOG_WARN(\"lv_obj_realign: no effect because LV_USE_OBJ_REALIGN = 0\");\n#endif\n}\n\n/**\n * Enable the automatic realign of the object when its size has changed based on the last\n * `lv_obj_align` parameters.\n * @param obj pointer to an object\n * @param en true: enable auto realign; false: disable auto realign\n */\nvoid lv_obj_set_auto_realign(lv_obj_t * obj, bool en)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_OBJ_REALIGN\n    obj->realign.auto_realign = en ? 1 : 0;\n#else\n    (void)obj;\n    (void)en;\n    LV_LOG_WARN(\"lv_obj_set_auto_realign: no effect because LV_USE_OBJ_REALIGN = 0\");\n#endif\n}\n\n\n/**\n * Set the size of an extended clickable area\n * If TINY mode is used, only the largest of the horizontal and vertical padding\n * values are considered.\n * @param obj pointer to an object\n * @param left extended clickable are on the left [px]\n * @param right extended clickable are on the right [px]\n * @param top extended clickable are on the top [px]\n * @param bottom extended clickable are on the bottom [px]\n */\nvoid lv_obj_set_ext_click_area(lv_obj_t * obj, lv_coord_t left, lv_coord_t right, lv_coord_t top, lv_coord_t bottom)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_FULL\n    obj->ext_click_pad.x1 = left;\n    obj->ext_click_pad.x2 = right;\n    obj->ext_click_pad.y1 = top;\n    obj->ext_click_pad.y2 = bottom;\n#elif LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_TINY\n    obj->ext_click_pad_hor = LV_MATH_MAX(left, right);\n    obj->ext_click_pad_ver = LV_MATH_MAX(top, bottom);\n#else\n    (void)obj;    /*Unused*/\n    (void)left;   /*Unused*/\n    (void)right;  /*Unused*/\n    (void)top;    /*Unused*/\n    (void)bottom; /*Unused*/\n#endif\n}\n\n/*---------------------\n * Appearance set\n *--------------------*/\n\n/**\n * Add a new style to the style list of an object.\n * @param obj pointer to an object\n * @param part the part of the object which style property should be set.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param style pointer to a style to add (Only its pointer will be saved)\n */\nvoid lv_obj_add_style(lv_obj_t * obj, uint8_t part, lv_style_t * style)\n{\n    if(style == NULL) return;\n\n    lv_style_list_t * style_dsc = lv_obj_get_style_list(obj, part);\n    if(style_dsc == NULL) {\n        LV_LOG_WARN(\"Can't find style with part: %d\", part);\n        return;\n    }\n\n    _lv_style_list_add_style(style_dsc, style);\n#if LV_USE_ANIMATION\n    trans_del(obj, part, 0xFF, NULL);\n#endif\n    lv_obj_refresh_style(obj, part, LV_STYLE_PROP_ALL);\n}\n\n/**\n * Remove a style from the style list of an object.\n * @param obj pointer to an object\n * @param part the part of the object which style property should be set.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param style pointer to a style to remove\n */\nvoid lv_obj_remove_style(lv_obj_t * obj, uint8_t part, lv_style_t * style)\n{\n    if(style == NULL) return;\n\n    lv_style_list_t * style_dsc = lv_obj_get_style_list(obj, part);\n    if(style_dsc == NULL) {\n        LV_LOG_WARN(\"Can't find style with part: %d\", part);\n        return;\n    }\n\n    _lv_style_list_remove_style(style_dsc, style);\n#if LV_USE_ANIMATION\n    trans_del(obj, part, 0xFF, NULL);\n#endif\n    lv_obj_refresh_style(obj, part, LV_STYLE_PROP_ALL);\n}\n\n/**\n * Reset a style to the default (empty) state.\n * Release all used memories and cancel pending related transitions.\n * Typically used in `LV_SIGN_CLEAN_UP.\n * @param obj pointer to an object\n * @param part the part of the object which style list should be reseted.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n */\nvoid lv_obj_clean_style_list(lv_obj_t * obj, uint8_t part)\n{\n    lv_style_list_t * style_dsc = lv_obj_get_style_list(obj, part);\n    if(style_dsc == NULL) {\n        LV_LOG_WARN(\"lv_obj_clean_style_list: can't find style with `part`\");\n        return;\n    }\n\n    _lv_style_list_reset(style_dsc);\n#if LV_USE_ANIMATION\n    trans_del(obj, part, 0xFF, NULL);\n#endif\n}\n\n/**\n * Reset a style to the default (empty) state.\n * Release all used memories and cancel pending related transitions.\n * Also notifies the object about the style change.\n * @param obj pointer to an object\n * @param part the part of the object which style list should be reseted.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n */\nvoid lv_obj_reset_style_list(lv_obj_t * obj, uint8_t part)\n{\n    lv_obj_clean_style_list(obj, part);\n\n    lv_obj_refresh_style(obj, part, LV_STYLE_PROP_ALL);\n}\n\n/**\n * Set a local style property of a part of an object in a given state.\n * @param obj pointer to an object\n * @param part the part of the object which style property should be set.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_BORDER_WIDTH | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @param the value to set\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_opa()`\n * @note for performance reasons it's not checked if the property really has integer type\n */\nvoid _lv_obj_set_style_local_int(lv_obj_t * obj, uint8_t part, lv_style_property_t prop, lv_style_int_t value)\n{\n    lv_style_list_t * style_dsc = lv_obj_get_style_list(obj, part);\n    _lv_style_list_set_local_int(style_dsc, prop, value);\n#if LV_USE_ANIMATION\n    trans_del(obj, part, prop, NULL);\n#endif\n    lv_obj_refresh_style(obj, part, prop & (~LV_STYLE_STATE_MASK));\n}\n\n/**\n * Set a local style property of a part of an object in a given state.\n * @param obj pointer to an object\n * @param part the part of the object which style property should be set.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_BORDER_COLOR | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @param the value to set\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_opa()`\n * @note for performance reasons it's not checked if the property really has color type\n */\nvoid _lv_obj_set_style_local_color(lv_obj_t * obj, uint8_t part, lv_style_property_t prop, lv_color_t color)\n{\n    lv_style_list_t * style_dsc = lv_obj_get_style_list(obj, part);\n    _lv_style_list_set_local_color(style_dsc, prop, color);\n#if LV_USE_ANIMATION\n    trans_del(obj, part, prop, NULL);\n#endif\n    lv_obj_refresh_style(obj, part, prop & (~LV_STYLE_STATE_MASK));\n}\n\n/**\n * Set a local style property of a part of an object in a given state.\n * @param obj pointer to an object\n * @param part the part of the object which style property should be set.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_BORDER_OPA | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @param the value to set\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_opa()`\n * @note for performance reasons it's not checked if the property really has opacity type\n */\nvoid _lv_obj_set_style_local_opa(lv_obj_t * obj, uint8_t part, lv_style_property_t prop, lv_opa_t opa)\n{\n    lv_style_list_t * style_dsc = lv_obj_get_style_list(obj, part);\n    _lv_style_list_set_local_opa(style_dsc, prop, opa);\n#if LV_USE_ANIMATION\n    trans_del(obj, part, prop, NULL);\n#endif\n    lv_obj_refresh_style(obj, part, prop & (~LV_STYLE_STATE_MASK));\n}\n\n/**\n * Set a local style property of a part of an object in a given state.\n * @param obj pointer to an object\n * @param part the part of the object which style property should be set.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_TEXT_FONT | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @param value the value to set\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_opa()`\n * @note for performance reasons it's not checked if the property really has pointer type\n */\nvoid _lv_obj_set_style_local_ptr(lv_obj_t * obj, uint8_t part, lv_style_property_t prop, const void * value)\n{\n    lv_style_list_t * style_dsc = lv_obj_get_style_list(obj, part);\n    _lv_style_list_set_local_ptr(style_dsc, prop, value);\n#if LV_USE_ANIMATION\n    trans_del(obj, part, prop, NULL);\n#endif\n    lv_obj_refresh_style(obj, part, prop & (~LV_STYLE_STATE_MASK));\n}\n\n/**\n * Remove a local style property from a part of an object with a given state.\n * @param obj pointer to an object\n * @param part the part of the object which style property should be removed.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_TEXT_FONT | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @note shouldn't be used directly. Use the specific property remove functions instead.\n *       For example: `lv_obj_style_remove_border_opa()`\n * @return true: the property was found and removed; false: the property was not found\n */\nbool lv_obj_remove_style_local_prop(lv_obj_t * obj, uint8_t part, lv_style_property_t prop)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n    lv_style_t * style = lv_obj_get_local_style(obj, part);\n    if(style) return lv_style_remove_prop(style, prop);\n    else return false;\n}\n\n/**\n * Notify an object (and its children) about its style is modified\n * @param obj pointer to an object\n * @param part the part of the object which style property should be refreshed.\n * @param prop `LV_STYLE_PROP_ALL` or an `LV_STYLE_...` property. It is used to optimize what needs to be refreshed.\n */\nvoid lv_obj_refresh_style(lv_obj_t * obj, uint8_t part, lv_style_property_t prop)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    invalidate_style_cache(obj, part, prop);\n\n    /*If a real style refresh is required*/\n    bool real_refr = false;\n    switch(prop) {\n        case LV_STYLE_PROP_ALL:\n        case LV_STYLE_CLIP_CORNER:\n        case LV_STYLE_SIZE:\n        case LV_STYLE_TRANSFORM_WIDTH:\n        case LV_STYLE_TRANSFORM_HEIGHT:\n        case LV_STYLE_TRANSFORM_ANGLE:\n        case LV_STYLE_TRANSFORM_ZOOM:\n        case LV_STYLE_PAD_TOP:\n        case LV_STYLE_PAD_BOTTOM:\n        case LV_STYLE_PAD_LEFT:\n        case LV_STYLE_PAD_RIGHT:\n        case LV_STYLE_PAD_INNER:\n        case LV_STYLE_MARGIN_TOP:\n        case LV_STYLE_MARGIN_BOTTOM:\n        case LV_STYLE_MARGIN_LEFT:\n        case LV_STYLE_MARGIN_RIGHT:\n        case LV_STYLE_OUTLINE_WIDTH:\n        case LV_STYLE_OUTLINE_PAD:\n        case LV_STYLE_OUTLINE_OPA:\n        case LV_STYLE_SHADOW_WIDTH:\n        case LV_STYLE_SHADOW_OPA:\n        case LV_STYLE_SHADOW_OFS_X:\n        case LV_STYLE_SHADOW_OFS_Y:\n        case LV_STYLE_SHADOW_SPREAD:\n        case LV_STYLE_VALUE_LETTER_SPACE:\n        case LV_STYLE_VALUE_LINE_SPACE:\n        case LV_STYLE_VALUE_OFS_X:\n        case LV_STYLE_VALUE_OFS_Y:\n        case LV_STYLE_VALUE_ALIGN:\n        case LV_STYLE_VALUE_STR:\n        case LV_STYLE_VALUE_FONT:\n        case LV_STYLE_VALUE_OPA:\n        case LV_STYLE_TEXT_LETTER_SPACE:\n        case LV_STYLE_TEXT_LINE_SPACE:\n        case LV_STYLE_TEXT_FONT:\n        case LV_STYLE_LINE_WIDTH:\n            real_refr = true;\n            break;\n        default:\n            real_refr = false;\n    }\n\n    if(real_refr) {\n        lv_obj_invalidate(obj);\n        obj->signal_cb(obj, LV_SIGNAL_STYLE_CHG, NULL);\n\n        switch(prop) {\n            case LV_STYLE_PROP_ALL:\n            case LV_STYLE_MARGIN_TOP:\n            case LV_STYLE_MARGIN_BOTTOM:\n            case LV_STYLE_MARGIN_LEFT:\n            case LV_STYLE_MARGIN_RIGHT:\n                if(obj->parent) obj->parent->signal_cb(obj->parent, LV_SIGNAL_CHILD_CHG, NULL);\n                break;\n        }\n\n        lv_obj_invalidate(obj);\n\n        /*Send style change signals*/\n        if(prop == LV_STYLE_PROP_ALL || (prop & LV_STYLE_INHERIT_MASK)) refresh_children_style(obj);\n    }\n    else {\n        lv_obj_invalidate(obj);\n    }\n}\n\n/**\n * Notify all object if a style is modified\n * @param style pointer to a style. Only the objects with this style will be notified\n *               (NULL to notify all objects)\n */\nvoid lv_obj_report_style_mod(lv_style_t * style)\n{\n    lv_disp_t * d = lv_disp_get_next(NULL);\n\n    while(d) {\n        lv_obj_t * i;\n        _LV_LL_READ(d->scr_ll, i) {\n            report_style_mod_core(style, i);\n        }\n        d = lv_disp_get_next(d);\n    }\n}\n\n/**\n * Enable/disable the use of style cache for an object\n * @param obj pointer to an object\n * @param dis true: disable; false: enable (re-enable)\n */\nvoid _lv_obj_disable_style_caching(lv_obj_t * obj, bool dis)\n{\n    uint8_t part;\n    for(part = 0; part < _LV_OBJ_PART_REAL_FIRST; part++) {\n        lv_style_list_t * list = lv_obj_get_style_list(obj, part);\n        if(list == NULL) break;\n        list->ignore_cache = dis;\n    }\n    for(part = _LV_OBJ_PART_REAL_FIRST; part < 0xFF; part++) {\n        lv_style_list_t * list = lv_obj_get_style_list(obj, part);\n        if(list == NULL) break;\n        list->ignore_cache = dis;\n    }\n}\n\n/*-----------------\n * Attribute set\n *----------------*/\n\n/**\n * Hide an object. It won't be visible and clickable.\n * @param obj pointer to an object\n * @param en true: hide the object\n */\nvoid lv_obj_set_hidden(lv_obj_t * obj, bool en)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    if(!obj->hidden) lv_obj_invalidate(obj); /*Invalidate when not hidden (hidden objects are ignored) */\n\n    obj->hidden = en == false ? 0 : 1;\n\n    if(!obj->hidden) lv_obj_invalidate(obj); /*Invalidate when not hidden (hidden objects are ignored) */\n\n    lv_obj_t * par = lv_obj_get_parent(obj);\n    if(par) par->signal_cb(par, LV_SIGNAL_CHILD_CHG, obj);\n}\n\n/**\n * Set whether advanced hit-testing is enabled on an object\n * @param obj pointer to an object\n * @param en true: advanced hit-testing is enabled\n */\nvoid lv_obj_set_adv_hittest(lv_obj_t * obj, bool en)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->adv_hittest = en == false ? 0 : 1;\n}\n\n/**\n * Enable or disable the clicking of an object\n * @param obj pointer to an object\n * @param en true: make the object clickable\n */\nvoid lv_obj_set_click(lv_obj_t * obj, bool en)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->click = (en == true ? 1 : 0);\n}\n\n/**\n * Enable to bring this object to the foreground if it\n * or any of its children is clicked\n * @param obj pointer to an object\n * @param en true: enable the auto top feature\n */\nvoid lv_obj_set_top(lv_obj_t * obj, bool en)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->top = (en == true ? 1 : 0);\n}\n\n/**\n * Enable the dragging of an object\n * @param obj pointer to an object\n * @param en true: make the object draggable\n */\nvoid lv_obj_set_drag(lv_obj_t * obj, bool en)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    if(en == true) lv_obj_set_click(obj, true); /*Drag is useless without enabled clicking*/\n    obj->drag = (en == true ? 1 : 0);\n}\n\n/**\n * Set the directions an object can be dragged in\n * @param obj pointer to an object\n * @param drag_dir bitwise OR of allowed directions an object can be dragged in\n */\nvoid lv_obj_set_drag_dir(lv_obj_t * obj, lv_drag_dir_t drag_dir)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->drag_dir = drag_dir;\n\n    if(obj->drag_dir != 0) lv_obj_set_drag(obj, true); /*Drag direction requires drag*/\n}\n\n/**\n * Enable the throwing of an object after is is dragged\n * @param obj pointer to an object\n * @param en true: enable the drag throw\n */\nvoid lv_obj_set_drag_throw(lv_obj_t * obj, bool en)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->drag_throw = (en == true ? 1 : 0);\n}\n\n/**\n * Enable to use parent for drag related operations.\n * If trying to drag the object the parent will be moved instead\n * @param obj pointer to an object\n * @param en true: enable the 'drag parent' for the object\n */\nvoid lv_obj_set_drag_parent(lv_obj_t * obj, bool en)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->drag_parent = (en == true ? 1 : 0);\n}\n\n/**\n* Enable to use parent for gesture related operations.\n* If trying to gesture the object the parent will be moved instead\n* @param obj pointer to an object\n* @param en true: enable the 'gesture parent' for the object\n*/\nvoid lv_obj_set_gesture_parent(lv_obj_t * obj, bool en)\n{\n    obj->gesture_parent = (en == true ? 1 : 0);\n}\n\n/**\n* Enable to use parent for focus state.\n* When object is focused the parent will get the state instead (visual only)\n* @param obj pointer to an object\n* @param en true: enable the 'focus parent' for the object\n*/\nvoid lv_obj_set_focus_parent(lv_obj_t * obj, bool en)\n{\n    if(lv_obj_is_focused(obj)) {\n        if(en) {\n            obj->focus_parent = 1;\n            lv_obj_clear_state(obj, LV_STATE_FOCUSED | LV_STATE_EDITED);\n            lv_obj_set_state(lv_obj_get_focused_obj(obj), LV_STATE_FOCUSED);\n        }\n        else {\n            lv_obj_clear_state(lv_obj_get_focused_obj(obj), LV_STATE_FOCUSED | LV_STATE_EDITED);\n            lv_obj_set_state(obj, LV_STATE_FOCUSED);\n            obj->focus_parent = 0;\n        }\n    }\n    else {\n        obj->focus_parent = (en == true ? 1 : 0);\n    }\n}\n\n/**\n * Propagate the events to the parent too\n * @param obj pointer to an object\n * @param en true: enable the event propagation\n */\nvoid lv_obj_set_parent_event(lv_obj_t * obj, bool en)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->parent_event = (en == true ? 1 : 0);\n}\n\n/**\n * Set the base direction of the object\n * @param obj pointer to an object\n * @param dir the new base direction. `LV_BIDI_DIR_LTR/RTL/AUTO/INHERIT`\n */\nvoid lv_obj_set_base_dir(lv_obj_t * obj, lv_bidi_dir_t dir)\n{\n    if(dir != LV_BIDI_DIR_LTR && dir != LV_BIDI_DIR_RTL &&\n       dir != LV_BIDI_DIR_AUTO && dir != LV_BIDI_DIR_INHERIT) {\n\n        LV_LOG_WARN(\"lv_obj_set_base_dir: invalid base dir\");\n        return;\n    }\n\n    obj->base_dir = dir;\n    lv_signal_send(obj, LV_SIGNAL_BASE_DIR_CHG, NULL);\n\n    /* Notify the children about the parent base dir has changed.\n     * (The children might have `LV_BIDI_DIR_INHERIT`)*/\n    base_dir_refr_children(obj);\n}\n\n/**\n * Set a bit or bits in the protect filed\n * @param obj pointer to an object\n * @param prot 'OR'-ed values from `lv_protect_t`\n */\nvoid lv_obj_add_protect(lv_obj_t * obj, uint8_t prot)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->protect |= prot;\n}\n\n/**\n * Clear a bit or bits in the protect filed\n * @param obj pointer to an object\n * @param prot 'OR'-ed values from `lv_protect_t`\n */\nvoid lv_obj_clear_protect(lv_obj_t * obj, uint8_t prot)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    prot = (~prot) & 0xFF;\n    obj->protect &= prot;\n}\n\n/**\n * Set the state (fully overwrite) of an object.\n * If specified in the styles a transition animation will be started\n * from the previous state to the current\n * @param obj pointer to an object\n * @param state the new state\n */\nvoid lv_obj_set_state(lv_obj_t * obj, lv_state_t new_state)\n{\n    if(obj->state == new_state) return;\n\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_state_t prev_state = obj->state;\n    style_snapshot_res_t cmp_res = STYLE_COMPARE_SAME;\n    uint8_t part;\n    for(part = 0; part < _LV_OBJ_PART_REAL_FIRST; part++) {\n        lv_style_list_t * style_list = lv_obj_get_style_list(obj, part);\n        if(style_list == NULL) break;   /*No more style lists*/\n        obj->state = prev_state;\n        style_snapshot_t shot_pre;\n        style_snapshot(obj, part, &shot_pre);\n        obj->state = new_state;\n        style_snapshot_t shot_post;\n        style_snapshot(obj, part, &shot_post);\n\n        style_snapshot_res_t r = style_snapshot_compare(&shot_pre, &shot_post);\n        if(r == STYLE_COMPARE_DIFF) {\n            cmp_res = STYLE_COMPARE_DIFF;\n            break;\n        }\n        if(r == STYLE_COMPARE_VISUAL_DIFF) {\n            cmp_res = STYLE_COMPARE_VISUAL_DIFF;\n        }\n    }\n\n    obj->state = new_state;\n\n    if(cmp_res == STYLE_COMPARE_SAME) {\n        return;\n    }\n\n#if LV_USE_ANIMATION == 0\n    if(cmp_res == STYLE_COMPARE_DIFF) lv_obj_refresh_style(obj, part, LV_STYLE_PROP_ALL);\n    else if(cmp_res == STYLE_COMPARE_VISUAL_DIFF) lv_obj_refresh_style(obj, LV_OBJ_PART_ALL, LV_STYLE_PROP_ALL);\n#else\n\n\n    for(part = 0; part < _LV_OBJ_PART_REAL_LAST; part++) {\n        lv_style_list_t * style_list = lv_obj_get_style_list(obj, part);\n        if(style_list == NULL) break;   /*No more style lists*/\n        if(style_list->ignore_trans) continue;\n\n        lv_style_int_t time = lv_obj_get_style_transition_time(obj, part);\n        lv_style_property_t props[LV_STYLE_TRANS_NUM_MAX];\n        lv_style_int_t delay = lv_obj_get_style_transition_delay(obj, part);\n        lv_anim_path_t * path = lv_obj_get_style_transition_path(obj, part);\n        props[0] = lv_obj_get_style_transition_prop_1(obj, part);\n        props[1] = lv_obj_get_style_transition_prop_2(obj, part);\n        props[2] = lv_obj_get_style_transition_prop_3(obj, part);\n        props[3] = lv_obj_get_style_transition_prop_4(obj, part);\n        props[4] = lv_obj_get_style_transition_prop_5(obj, part);\n        props[5] = lv_obj_get_style_transition_prop_6(obj, part);\n\n        uint8_t i;\n        for(i = 0; i < LV_STYLE_TRANS_NUM_MAX; i++) {\n            if(props[i] != 0) {\n                _lv_style_list_add_trans_style(style_list);\n\n                lv_style_trans_t * tr = trans_create(obj, props[i], part, prev_state, new_state);\n\n                /*If there is a pending anim for this property remove it*/\n                if(tr) {\n                    tr->obj = obj;\n                    tr->prop = props[i];\n                    tr->part = part;\n\n                    lv_anim_t a;\n                    lv_anim_init(&a);\n                    lv_anim_set_var(&a, tr);\n                    lv_anim_set_exec_cb(&a, (lv_anim_exec_xcb_t)trans_anim_cb);\n                    lv_anim_set_start_cb(&a, trans_anim_start_cb);\n                    lv_anim_set_ready_cb(&a, trans_anim_ready_cb);\n                    lv_anim_set_values(&a, 0x00, 0xFF);\n                    lv_anim_set_time(&a, time);\n                    lv_anim_set_delay(&a, delay);\n                    lv_anim_set_path(&a, path);\n                    a.early_apply = 0;\n                    lv_anim_start(&a);\n                }\n\n            }\n        }\n        if(cmp_res == STYLE_COMPARE_DIFF) lv_obj_refresh_style(obj, part, LV_STYLE_PROP_ALL);\n\n        if(cmp_res == STYLE_COMPARE_VISUAL_DIFF) {\n            invalidate_style_cache(obj, part, LV_STYLE_PROP_ALL);\n        }\n    }\n\n    if(cmp_res == STYLE_COMPARE_VISUAL_DIFF) {\n        lv_obj_invalidate(obj);\n    }\n\n#endif\n\n}\n\n/**\n * Add a given state or states to the object. The other state bits will remain unchanged.\n * If specified in the styles a transition animation will be started\n * from the previous state to the current\n * @param obj pointer to an object\n * @param state the state bits to add. E.g `LV_STATE_PRESSED | LV_STATE_FOCUSED`\n */\nvoid lv_obj_add_state(lv_obj_t * obj, lv_state_t state)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_state_t new_state = obj->state | state;\n    if(obj->state != new_state) {\n        lv_obj_set_state(obj, new_state);\n    }\n}\n\n/**\n * Remove a given state or states to the object. The other state bits will remain unchanged.\n * If specified in the styles a transition animation will be started\n * from the previous state to the current\n * @param obj pointer to an object\n * @param state the state bits to remove. E.g `LV_STATE_PRESSED | LV_STATE_FOCUSED`\n */\nvoid lv_obj_clear_state(lv_obj_t * obj, lv_state_t state)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_state_t new_state = obj->state & (~state);\n    if(obj->state != new_state) {\n        lv_obj_set_state(obj, new_state);\n    }\n}\n\n#if LV_USE_ANIMATION\n/**\n * Finish all pending transitions on a part of an object\n * @param obj pointer to an object\n * @param part part of the object, e.g `LV_BRN_PART_MAIN` or `LV_OBJ_PART_ALL` for all parts\n */\nvoid lv_obj_finish_transitions(lv_obj_t * obj, uint8_t part)\n{\n    /*Animate all related transition to the end value*/\n    lv_style_trans_t * tr;\n    _LV_LL_READ_BACK(LV_GC_ROOT(_lv_obj_style_trans_ll), tr) {\n        if(tr->obj == obj && (part == tr->part || part == LV_OBJ_PART_ALL)) {\n            trans_anim_cb(tr, 255);\n        }\n    }\n\n    /*Free all related transition data*/\n    trans_del(obj, part, 0xFF, NULL);\n}\n#endif\n\n/**\n * Set a an event handler function for an object.\n * Used by the user to react on event which happens with the object.\n * @param obj pointer to an object\n * @param event_cb the new event function\n */\nvoid lv_obj_set_event_cb(lv_obj_t * obj, lv_event_cb_t event_cb)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->event_cb = event_cb;\n}\n\n/**\n * Send an event to the object\n * @param obj pointer to an object\n * @param event the type of the event from `lv_event_t`\n * @param data arbitrary data depending on the object type and the event. (Usually `NULL`)\n * @return LV_RES_OK: `obj` was not deleted in the event; LV_RES_INV: `obj` was deleted in the event\n */\nlv_res_t lv_event_send(lv_obj_t * obj, lv_event_t event, const void * data)\n{\n    if(obj == NULL) return LV_RES_OK;\n\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_res_t res;\n    res = lv_event_send_func(obj->event_cb, obj, event, data);\n    return res;\n}\n\n/**\n * Send LV_EVENT_REFRESH event to an object\n * @param obj point to an object. (Can NOT be NULL)\n * @return LV_RES_OK: success, LV_RES_INV: to object become invalid (e.g. deleted) due to this event.\n */\nlv_res_t lv_event_send_refresh(lv_obj_t * obj)\n{\n    return lv_event_send(obj, LV_EVENT_REFRESH, NULL);\n}\n\n/**\n * Send LV_EVENT_REFRESH event to an object and all of its children.\n * @param obj pointer to an object or NULL to refresh all objects of all displays\n */\nvoid lv_event_send_refresh_recursive(lv_obj_t * obj)\n{\n    if(obj == NULL) {\n        /*If no obj specified refresh all screen of all displays */\n        lv_disp_t * d = lv_disp_get_next(NULL);\n        while(d) {\n            lv_obj_t * scr = _lv_ll_get_head(&d->scr_ll);\n            while(scr) {\n                lv_event_send_refresh_recursive(scr);\n                scr = _lv_ll_get_next(&d->scr_ll, scr);\n            }\n            lv_event_send_refresh_recursive(d->top_layer);\n            lv_event_send_refresh_recursive(d->sys_layer);\n\n            d = lv_disp_get_next(d);\n        }\n    }\n    else {\n\n        lv_res_t res = lv_event_send_refresh(obj);\n        if(res != LV_RES_OK) return; /*If invalid returned do not check the children*/\n\n        lv_obj_t * child = lv_obj_get_child(obj, NULL);\n        while(child) {\n            lv_event_send_refresh_recursive(child);\n\n            child = lv_obj_get_child(obj, child);\n        }\n    }\n}\n\n\n/**\n * Call an event function with an object, event, and data.\n * @param event_xcb an event callback function. If `NULL` `LV_RES_OK` will return without any actions.\n *        (the 'x' in the argument name indicates that its not a fully generic function because it not follows\n *         the `func_name(object, callback, ...)` convention)\n * @param obj pointer to an object to associate with the event (can be `NULL` to simply call the `event_cb`)\n * @param event an event\n * @param data pointer to a custom data\n * @return LV_RES_OK: `obj` was not deleted in the event; LV_RES_INV: `obj` was deleted in the event\n */\nlv_res_t lv_event_send_func(lv_event_cb_t event_xcb, lv_obj_t * obj, lv_event_t event, const void * data)\n{\n    if(obj != NULL) {\n        LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n    }\n\n    /* Build a simple linked list from the objects used in the events\n     * It's important to know if an this object was deleted by a nested event\n     * called from this `even_cb`. */\n    lv_event_temp_data_t event_temp_data;\n    event_temp_data.obj     = obj;\n    event_temp_data.deleted = false;\n    event_temp_data.prev    = NULL;\n\n    if(event_temp_data_head) {\n        event_temp_data.prev = event_temp_data_head;\n    }\n    event_temp_data_head = &event_temp_data;\n\n    const void * event_act_data_save = event_act_data;\n    event_act_data                   = data;\n\n    /*Call the input device's feedback callback if set*/\n    lv_indev_t * indev_act = lv_indev_get_act();\n    if(indev_act) {\n        if(indev_act->driver.feedback_cb) indev_act->driver.feedback_cb(&indev_act->driver, event);\n    }\n\n    /*Call the event callback itself*/\n    if(event_xcb) event_xcb(obj, event);\n\n    /*Restore the event data*/\n    event_act_data = event_act_data_save;\n\n    /*Remove this element from the list*/\n    event_temp_data_head = event_temp_data_head->prev;\n\n    if(event_temp_data.deleted) {\n        return LV_RES_INV;\n    }\n\n    if(obj) {\n        if(obj->parent_event && obj->parent) {\n            lv_res_t res = lv_event_send(obj->parent, event, data);\n            if(res != LV_RES_OK) {\n                return LV_RES_INV;\n            }\n        }\n    }\n\n    return LV_RES_OK;\n}\n\n/**\n * Get the `data` parameter of the current event\n * @return the `data` parameter\n */\nconst void * lv_event_get_data(void)\n{\n    return event_act_data;\n}\n\n/**\n * Set the a signal function of an object. Used internally by the library.\n * Always call the previous signal function in the new.\n * @param obj pointer to an object\n * @param cb the new signal function\n */\nvoid lv_obj_set_signal_cb(lv_obj_t * obj, lv_signal_cb_t signal_cb)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->signal_cb = signal_cb;\n}\n\n/**\n * Send an event to the object\n * @param obj pointer to an object\n * @param event the type of the event from `lv_event_t`.\n * @return LV_RES_OK or LV_RES_INV\n */\nlv_res_t lv_signal_send(lv_obj_t * obj, lv_signal_t signal, void * param)\n{\n    if(obj == NULL) return LV_RES_OK;\n\n    lv_res_t res = LV_RES_OK;\n    if(obj->signal_cb) res = obj->signal_cb(obj, signal, param);\n\n    return res;\n}\n\n/**\n * Set a new design function for an object\n * @param obj pointer to an object\n * @param design_cb the new design function\n */\nvoid lv_obj_set_design_cb(lv_obj_t * obj, lv_design_cb_t design_cb)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->design_cb = design_cb;\n}\n\n/*----------------\n * Other set\n *--------------*/\n\n/**\n * Allocate a new ext. data for an object\n * @param obj pointer to an object\n * @param ext_size the size of the new ext. data\n * @return pointer to the allocated ext.\n * If out of memory NULL is returned and the original ext is preserved\n */\nvoid * lv_obj_allocate_ext_attr(lv_obj_t * obj, uint16_t ext_size)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    void * new_ext = lv_mem_realloc(obj->ext_attr, ext_size);\n    if(new_ext == NULL) return NULL;\n\n    obj->ext_attr = new_ext;\n    return (void *)obj->ext_attr;\n}\n\n/**\n * Send a 'LV_SIGNAL_REFR_EXT_SIZE' signal to the object to refresh the extended draw area.\n * he object needs to be invalidated by `lv_obj_invalidate(obj)` manually after this function.\n * @param obj pointer to an object\n */\nvoid lv_obj_refresh_ext_draw_pad(lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    obj->ext_draw_pad = 0;\n    obj->signal_cb(obj, LV_SIGNAL_REFR_EXT_DRAW_PAD, NULL);\n\n}\n\n/*=======================\n * Getter functions\n *======================*/\n\n/**\n * Return with the screen of an object\n * @param obj pointer to an object\n * @return pointer to a screen\n */\nlv_obj_t * lv_obj_get_screen(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    const lv_obj_t * par = obj;\n    const lv_obj_t * act_p;\n\n    do {\n        act_p = par;\n        par   = lv_obj_get_parent(act_p);\n    } while(par != NULL);\n\n    return (lv_obj_t *)act_p;\n}\n\n/**\n * Get the display of an object\n * @param scr pointer to an object\n * @return pointer the object's display\n */\nlv_disp_t * lv_obj_get_disp(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    const lv_obj_t * scr;\n\n    if(obj->parent == NULL)\n        scr = obj; /*`obj` is a screen*/\n    else\n        scr = lv_obj_get_screen(obj); /*get the screen of `obj`*/\n\n    lv_disp_t * d;\n    _LV_LL_READ(LV_GC_ROOT(_lv_disp_ll), d) {\n        lv_obj_t * s;\n        _LV_LL_READ(d->scr_ll, s) {\n            if(s == scr) return d;\n        }\n    }\n\n    LV_LOG_WARN(\"lv_scr_get_disp: screen not found\")\n    return NULL;\n}\n\n/*---------------------\n * Parent/children get\n *--------------------*/\n\n/**\n * Returns with the parent of an object\n * @param obj pointer to an object\n * @return pointer to the parent of  'obj'\n */\nlv_obj_t * lv_obj_get_parent(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return obj->parent;\n}\n\n/**\n * Iterate through the children of an object (start from the \"youngest\")\n * @param obj pointer to an object\n * @param child NULL at first call to get the next children\n *                  and the previous return value later\n * @return the child after 'act_child' or NULL if no more child\n */\nlv_obj_t * lv_obj_get_child(const lv_obj_t * obj, const lv_obj_t * child)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_obj_t * result = NULL;\n\n    if(child == NULL) {\n        result = _lv_ll_get_head(&obj->child_ll);\n    }\n    else {\n        result = _lv_ll_get_next(&obj->child_ll, child);\n    }\n\n    return result;\n}\n\n/**\n * Iterate through the children of an object (start from the \"oldest\")\n * @param obj pointer to an object\n * @param child NULL at first call to get the next children\n *                  and the previous return value later\n * @return the child after 'act_child' or NULL if no more child\n */\nlv_obj_t * lv_obj_get_child_back(const lv_obj_t * obj, const lv_obj_t * child)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_obj_t * result = NULL;\n\n    if(child == NULL) {\n        result = _lv_ll_get_tail(&obj->child_ll);\n    }\n    else {\n        result = _lv_ll_get_prev(&obj->child_ll, child);\n    }\n\n    return result;\n}\n\n/**\n * Count the children of an object (only children directly on 'obj')\n * @param obj pointer to an object\n * @return children number of 'obj'\n */\nuint16_t lv_obj_count_children(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_obj_t * i;\n    uint16_t cnt = 0;\n\n    _LV_LL_READ(obj->child_ll, i) cnt++;\n\n    return cnt;\n}\n\n/** Recursively count the children of an object\n * @param obj pointer to an object\n * @return children number of 'obj'\n */\nuint16_t lv_obj_count_children_recursive(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_obj_t * i;\n    uint16_t cnt = 0;\n\n    _LV_LL_READ(obj->child_ll, i) {\n        cnt++;                                     /*Count the child*/\n        cnt += lv_obj_count_children_recursive(i); /*recursively count children's children*/\n    }\n\n    return cnt;\n}\n\n/*---------------------\n * Coordinate get\n *--------------------*/\n\n/**\n * Copy the coordinates of an object to an area\n * @param obj pointer to an object\n * @param cords_p pointer to an area to store the coordinates\n */\nvoid lv_obj_get_coords(const lv_obj_t * obj, lv_area_t * cords_p)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_area_copy(cords_p, &obj->coords);\n}\n\n/**\n * Reduce area retried by `lv_obj_get_coords()` the get graphically usable area of an object.\n * (Without the size of the border or other extra graphical elements)\n * @param coords_p store the result area here\n */\nvoid lv_obj_get_inner_coords(const lv_obj_t * obj, lv_area_t * coords_p)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_border_side_t part = lv_obj_get_style_border_side(obj, LV_OBJ_PART_MAIN);\n    lv_coord_t w = lv_obj_get_style_border_width(obj, LV_OBJ_PART_MAIN);\n\n    if(part & LV_BORDER_SIDE_LEFT) coords_p->x1 += w;\n\n    if(part & LV_BORDER_SIDE_RIGHT) coords_p->x2 -= w;\n\n    if(part & LV_BORDER_SIDE_TOP) coords_p->y1 += w;\n\n    if(part & LV_BORDER_SIDE_BOTTOM) coords_p->y2 -= w;\n}\n\n/**\n * Get the x coordinate of object\n * @param obj pointer to an object\n * @return distance of 'obj' from the left side of its parent\n */\nlv_coord_t lv_obj_get_x(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_coord_t rel_x;\n    lv_obj_t * parent = lv_obj_get_parent(obj);\n    if(parent) {\n        rel_x             = obj->coords.x1 - parent->coords.x1;\n    }\n    else {\n        rel_x = obj->coords.x1;\n    }\n    return rel_x;\n}\n\n/**\n * Get the y coordinate of object\n * @param obj pointer to an object\n * @return distance of 'obj' from the top of its parent\n */\nlv_coord_t lv_obj_get_y(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_coord_t rel_y;\n    lv_obj_t * parent = lv_obj_get_parent(obj);\n    if(parent) {\n        rel_y             = obj->coords.y1 - parent->coords.y1;\n    }\n    else {\n        rel_y = obj->coords.y1;\n    }\n    return rel_y;\n}\n\n/**\n * Get the width of an object\n * @param obj pointer to an object\n * @return the width\n */\nlv_coord_t lv_obj_get_width(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return lv_area_get_width(&obj->coords);\n}\n\n/**\n * Get the height of an object\n * @param obj pointer to an object\n * @return the height\n */\nlv_coord_t lv_obj_get_height(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return lv_area_get_height(&obj->coords);\n}\n\n/**\n * Get that width reduced by the left and right padding.\n * @param obj pointer to an object\n * @return the width which still fits into the container\n */\nlv_coord_t lv_obj_get_width_fit(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_style_int_t left = lv_obj_get_style_pad_left(obj, LV_OBJ_PART_MAIN);\n    lv_style_int_t right = lv_obj_get_style_pad_right(obj, LV_OBJ_PART_MAIN);\n\n    return lv_obj_get_width(obj) - left - right;\n}\n\n/**\n * Get that height reduced by the top an bottom padding.\n * @param obj pointer to an object\n * @return the height which still fits into the container\n */\nlv_coord_t lv_obj_get_height_fit(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_style_int_t top = lv_obj_get_style_pad_top((lv_obj_t *)obj, LV_OBJ_PART_MAIN);\n    lv_style_int_t bottom =  lv_obj_get_style_pad_bottom((lv_obj_t *)obj, LV_OBJ_PART_MAIN);\n\n    return lv_obj_get_height(obj) - top - bottom;\n}\n\n/**\n * Get the height of an object by taking the top and bottom margin into account.\n * The returned height will be `obj_h + margin_top + margin_bottom`\n * @param obj pointer to an object\n * @return the height including thee margins\n */\nlv_coord_t lv_obj_get_height_margin(lv_obj_t * obj)\n{\n    lv_style_int_t mtop = lv_obj_get_style_margin_top(obj, LV_OBJ_PART_MAIN);\n    lv_style_int_t mbottom = lv_obj_get_style_margin_bottom(obj, LV_OBJ_PART_MAIN);\n\n    return lv_obj_get_height(obj) + mtop + mbottom;\n}\n\n/**\n * Get the width of an object by taking the left and right margin into account.\n * The returned width will be `obj_w + margin_left + margin_right`\n * @param obj pointer to an object\n * @return the height including thee margins\n */\nlv_coord_t lv_obj_get_width_margin(lv_obj_t * obj)\n{\n    lv_style_int_t mleft = lv_obj_get_style_margin_left(obj, LV_OBJ_PART_MAIN);\n    lv_style_int_t mright = lv_obj_get_style_margin_right(obj, LV_OBJ_PART_MAIN);\n\n    return lv_obj_get_width(obj) + mleft + mright;\n}\n\n/**\n * Set that width reduced by the left and right padding of the parent.\n * @param obj pointer to an object\n * @param div indicates how many columns are assumed.\n * If 1 the width will be set the the parent's width\n * If 2 only half parent width - inner padding of the parent\n * If 3 only third parent width - 2 * inner padding of the parent\n * @param span how many columns are combined\n * @return the width according to the given parameters\n */\nlv_coord_t lv_obj_get_width_grid(lv_obj_t * obj, uint8_t div, uint8_t span)\n{\n    lv_coord_t obj_w = lv_obj_get_width_fit(obj);\n    lv_style_int_t pinner = lv_obj_get_style_pad_inner(obj, LV_OBJ_PART_MAIN);\n\n    lv_coord_t r = (obj_w - (div - 1) * pinner) / div;\n\n    r = r * span + (span - 1) * pinner;\n    return r;\n}\n\n/**\n * Get that height reduced by the top and bottom padding of the parent.\n * @param obj pointer to an object\n * @param div indicates how many rows are assumed.\n * If 1 the height will be set the the parent's height\n * If 2 only half parent height - inner padding of the parent\n * If 3 only third parent height - 2 * inner padding of the parent\n * @param span how many rows are combined\n * @return the height according to the given parameters\n */\nlv_coord_t lv_obj_get_height_grid(lv_obj_t * obj, uint8_t div, uint8_t span)\n{\n    lv_coord_t obj_h = lv_obj_get_height_fit(obj);\n    lv_style_int_t pinner = lv_obj_get_style_pad_inner(obj, LV_OBJ_PART_MAIN);\n\n    lv_coord_t r = (obj_h - (div - 1) * pinner) / div;\n\n    r = r * span + (span - 1) * pinner;\n    return r;\n}\n\n/**\n * Get the automatic realign property of the object.\n * @param obj pointer to an object\n * @return  true: auto realign is enabled; false: auto realign is disabled\n */\nbool lv_obj_get_auto_realign(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_OBJ_REALIGN\n    return obj->realign.auto_realign ? true : false;\n#else\n    (void)obj;\n    return false;\n#endif\n}\n\n/**\n * Get the left padding of extended clickable area\n * @param obj pointer to an object\n * @return the extended left padding\n */\nlv_coord_t lv_obj_get_ext_click_pad_left(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_TINY\n    return obj->ext_click_pad_hor;\n#elif LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_FULL\n    return obj->ext_click_pad.x1;\n#else\n    (void)obj;    /*Unused*/\n    return 0;\n#endif\n}\n\n/**\n * Get the right padding of extended clickable area\n * @param obj pointer to an object\n * @return the extended right padding\n */\nlv_coord_t lv_obj_get_ext_click_pad_right(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_TINY\n    return obj->ext_click_pad_hor;\n#elif LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_FULL\n    return obj->ext_click_pad.x2;\n#else\n    (void)obj; /*Unused*/\n    return 0;\n#endif\n}\n\n/**\n * Get the top padding of extended clickable area\n * @param obj pointer to an object\n * @return the extended top padding\n */\nlv_coord_t lv_obj_get_ext_click_pad_top(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_TINY\n    return obj->ext_click_pad_ver;\n#elif LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_FULL\n    return obj->ext_click_pad.y1;\n#else\n    (void)obj; /*Unused*/\n    return 0;\n#endif\n}\n\n/**\n * Get the bottom padding of extended clickable area\n * @param obj pointer to an object\n * @return the extended bottom padding\n */\nlv_coord_t lv_obj_get_ext_click_pad_bottom(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n#if LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_TINY\n    return obj->ext_click_pad_ver;\n#elif LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_FULL\n    return obj->ext_click_pad.y2;\n#else\n    (void)obj; /*Unused*/\n    return 0;\n#endif\n}\n\n/**\n * Get the extended size attribute of an object\n * @param obj pointer to an object\n * @return the extended size attribute\n */\nlv_coord_t lv_obj_get_ext_draw_pad(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    return obj->ext_draw_pad;\n}\n\n/*-----------------\n * Appearance get\n *---------------*/\n\nlv_style_list_t * lv_obj_get_style_list(const lv_obj_t * obj, uint8_t part)\n{\n    if(part == LV_OBJ_PART_MAIN) return &((lv_obj_t *)obj)->style_list;\n\n    lv_get_style_info_t info;\n    info.part = part;\n    info.result = NULL;\n\n    lv_res_t res;\n    res = lv_signal_send((lv_obj_t *)obj, LV_SIGNAL_GET_STYLE, &info);\n\n    if(res != LV_RES_OK) return NULL;\n\n    return info.result;\n}\n\n/**\n * Get a style property of a part of an object in the object's current state.\n * If there is a running transitions it is taken into account\n * @param obj pointer to an object\n * @param part the part of the object which style property should be get.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop the property to get. E.g. `LV_STYLE_BORDER_WIDTH`.\n *  The state of the object will be added internally\n * @return the value of the property of the given part in the current state.\n * If the property is not found a default value will be returned.\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_width()`\n * @note for performance reasons it's not checked if the property really has integer type\n */\nlv_style_int_t _lv_obj_get_style_int(const lv_obj_t * obj, uint8_t part, lv_style_property_t prop)\n{\n    lv_style_property_t prop_ori = prop;\n\n    lv_style_attr_t attr;\n    attr = prop_ori >> 8;\n\n    lv_style_int_t value_act;\n    lv_res_t res = LV_RES_INV;\n    const lv_obj_t * parent = obj;\n    while(parent) {\n        lv_style_list_t * list = lv_obj_get_style_list(parent, part);\n        if(!list->ignore_cache && list->style_cnt > 0) {\n            if(!list->valid_cache) update_style_cache((lv_obj_t *)parent, part, prop  & (~LV_STYLE_STATE_MASK));\n\n            bool def = false;\n            switch(prop  & (~LV_STYLE_STATE_MASK)) {\n                case LV_STYLE_CLIP_CORNER:\n                    if(list->clip_corner_off) def = true;\n                    break;\n                case LV_STYLE_TEXT_LETTER_SPACE:\n                case LV_STYLE_TEXT_LINE_SPACE:\n                    if(list->text_space_zero) def = true;\n                    break;\n                case LV_STYLE_TRANSFORM_ANGLE:\n                case LV_STYLE_TRANSFORM_WIDTH:\n                case LV_STYLE_TRANSFORM_HEIGHT:\n                case LV_STYLE_TRANSFORM_ZOOM:\n                    if(list->transform_all_zero) def = true;\n                    break;\n                case LV_STYLE_BORDER_WIDTH:\n                    if(list->border_width_zero) def = true;\n                    break;\n                case LV_STYLE_BORDER_SIDE:\n                    if(list->border_side_full) def = true;\n                    break;\n                case LV_STYLE_BORDER_POST:\n                    if(list->border_post_off) def = true;\n                    break;\n                case LV_STYLE_OUTLINE_WIDTH:\n                    if(list->outline_width_zero) def = true;\n                    break;\n                case LV_STYLE_RADIUS:\n                    if(list->radius_zero) def = true;\n                    break;\n                case LV_STYLE_SHADOW_WIDTH:\n                    if(list->shadow_width_zero) def = true;\n                    break;\n                case LV_STYLE_PAD_TOP:\n                case LV_STYLE_PAD_BOTTOM:\n                case LV_STYLE_PAD_LEFT:\n                case LV_STYLE_PAD_RIGHT:\n                    if(list->pad_all_zero) def = true;\n                    break;\n                case LV_STYLE_MARGIN_TOP:\n                case LV_STYLE_MARGIN_BOTTOM:\n                case LV_STYLE_MARGIN_LEFT:\n                case LV_STYLE_MARGIN_RIGHT:\n                    if(list->margin_all_zero) def = true;\n                    break;\n                case LV_STYLE_BG_BLEND_MODE:\n                case LV_STYLE_BORDER_BLEND_MODE:\n                case LV_STYLE_IMAGE_BLEND_MODE:\n                case LV_STYLE_LINE_BLEND_MODE:\n                case LV_STYLE_OUTLINE_BLEND_MODE:\n                case LV_STYLE_PATTERN_BLEND_MODE:\n                case LV_STYLE_SHADOW_BLEND_MODE:\n                case LV_STYLE_TEXT_BLEND_MODE:\n                case LV_STYLE_VALUE_BLEND_MODE:\n                    if(list->blend_mode_all_normal) def = true;\n                    break;\n                case LV_STYLE_TEXT_DECOR:\n                    if(list->text_decor_none) def = true;\n                    break;\n            }\n\n            if(def) {\n                break;\n            }\n        }\n\n        lv_state_t state = lv_obj_get_state(parent, part);\n        prop = (uint16_t)prop_ori + ((uint16_t)state << LV_STYLE_STATE_POS);\n\n        res = _lv_style_list_get_int(list, prop, &value_act);\n        if(res == LV_RES_OK) return value_act;\n\n        if(LV_STYLE_ATTR_GET_INHERIT(attr) == 0) break;\n\n        /*If not found, check the `MAIN` style first*/\n        if(part != LV_OBJ_PART_MAIN) {\n            part = LV_OBJ_PART_MAIN;\n            continue;\n        }\n\n        /*Check the parent too.*/\n        parent = lv_obj_get_parent(parent);\n    }\n\n    /*Handle unset values*/\n    prop = prop & (~LV_STYLE_STATE_MASK);\n    switch(prop) {\n        case LV_STYLE_BORDER_SIDE:\n            return LV_BORDER_SIDE_FULL;\n        case LV_STYLE_SIZE:\n            return LV_DPI / 20;\n        case LV_STYLE_SCALE_WIDTH:\n            return LV_DPI / 8;\n        case LV_STYLE_BG_GRAD_STOP:\n            return 255;\n        case LV_STYLE_TRANSFORM_ZOOM:\n            return LV_IMG_ZOOM_NONE;\n    }\n\n    return 0;\n}\n\n/**\n * Get a style property of a part of an object in the object's current state.\n * If there is a running transitions it is taken into account\n * @param obj pointer to an object\n * @param part the part of the object which style property should be get.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop the property to get. E.g. `LV_STYLE_BORDER_COLOR`.\n *  The state of the object will be added internally\n * @return the value of the property of the given part in the current state.\n * If the property is not found a default value will be returned.\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_color()`\n * @note for performance reasons it's not checked if the property really has color type\n */\nlv_color_t _lv_obj_get_style_color(const lv_obj_t * obj, uint8_t part, lv_style_property_t prop)\n{\n    lv_style_property_t prop_ori = prop;\n\n    lv_style_attr_t attr;\n    attr = prop_ori >> 8;\n\n    lv_color_t value_act;\n    lv_res_t res = LV_RES_INV;\n    const lv_obj_t * parent = obj;\n    while(parent) {\n        lv_style_list_t * list = lv_obj_get_style_list(parent, part);\n\n        lv_state_t state = lv_obj_get_state(parent, part);\n        prop = (uint16_t)prop_ori + ((uint16_t)state << LV_STYLE_STATE_POS);\n\n        res = _lv_style_list_get_color(list, prop, &value_act);\n        if(res == LV_RES_OK) return value_act;\n\n        if(LV_STYLE_ATTR_GET_INHERIT(attr) == 0) break;\n\n        /*If not found, check the `MAIN` style first*/\n        if(part != LV_OBJ_PART_MAIN) {\n            part = LV_OBJ_PART_MAIN;\n            continue;\n        }\n\n        /*Check the parent too.*/\n        parent = lv_obj_get_parent(parent);\n    }\n\n    /*Handle unset values*/\n    prop = prop & (~LV_STYLE_STATE_MASK);\n    switch(prop) {\n        case LV_STYLE_BG_COLOR:\n        case LV_STYLE_BG_GRAD_COLOR:\n            return LV_COLOR_WHITE;\n    }\n\n    return LV_COLOR_BLACK;\n}\n\n/**\n * Get a style property of a part of an object in the object's current state.\n * If there is a running transitions it is taken into account\n * @param obj pointer to an object\n * @param part the part of the object which style property should be get.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop the property to get. E.g. `LV_STYLE_BORDER_OPA`.\n *  The state of the object will be added internally\n * @return the value of the property of the given part in the current state.\n * If the property is not found a default value will be returned.\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_opa()`\n * @note for performance reasons it's not checked if the property really has opacity type\n */\nlv_opa_t _lv_obj_get_style_opa(const lv_obj_t * obj, uint8_t part, lv_style_property_t prop)\n{\n    lv_style_property_t prop_ori = prop;\n\n    lv_style_attr_t attr;\n    attr = prop_ori >> 8;\n\n    lv_opa_t value_act;\n    lv_res_t res = LV_RES_INV;\n    const lv_obj_t * parent = obj;\n    while(parent) {\n        lv_style_list_t * list = lv_obj_get_style_list(parent, part);\n\n        if(!list->ignore_cache && list->style_cnt > 0) {\n            if(!list->valid_cache) update_style_cache((lv_obj_t *)parent, part, prop  & (~LV_STYLE_STATE_MASK));\n            bool def = false;\n            switch(prop & (~LV_STYLE_STATE_MASK)) {\n                case LV_STYLE_OPA_SCALE:\n                    if(list->opa_scale_cover) def = true;\n                    break;\n                case LV_STYLE_BG_OPA:\n                    if(list->bg_opa_cover) return LV_OPA_COVER;     /*Special case, not the default value is used*/\n                    if(list->bg_opa_transp) def = true;\n                    break;\n                case LV_STYLE_IMAGE_RECOLOR_OPA:\n                    if(list->img_recolor_opa_transp) def = true;\n                    break;\n            }\n\n            if(def) {\n                break;",
        "res_region": "    if(obj == NULL) {\n        /*If no obj specified refresh all screen of all displays */\n        lv_disp_t * d = lv_disp_get_next(NULL);\n        while(d) {\n            uint32_t i;\n            for(i = 0; i < d->screen_cnt; i++) {\n                lv_event_send_refresh_recursive(d->screens[i]);\n            }\n            lv_event_send_refresh_recursive(d->top_layer);\n            lv_event_send_refresh_recursive(d->sys_layer);",
        "lookback": "        /*If no obj specified refresh all screen of all displays */",
        "lookahead": "",
        "label": [
            "interleave",
            "complex_conflict"
        ],
        "start_line": 1135,
        "end_line": 4773,
        "merge_gen_region": null,
        "confidence": 0.5787980556488037,
        "hesitated": true
    },
    {
        "a_contents": "            lv_event_send_refresh_recursive(d->top_layer);\n            lv_event_send_refresh_recursive(d->sys_layer);",
        "b_contents": "        }\n\n        lv_state_t state = lv_obj_get_state(parent, part);\n        prop = (uint16_t)prop_ori + ((uint16_t)state << LV_STYLE_STATE_POS);\n\n        res = _lv_style_list_get_opa(list, prop, &value_act);\n        if(res == LV_RES_OK) return value_act;\n\n        if(LV_STYLE_ATTR_GET_INHERIT(attr) == 0) break;",
        "base_contents": "        }\n\n\n        lv_state_t state = lv_obj_get_state(parent, part);\n        prop = (uint16_t)prop_ori + ((uint16_t)state << LV_STYLE_STATE_POS);\n\n        res = _lv_style_list_get_opa(list, prop, &value_act);\n        if(res == LV_RES_OK) return value_act;\n\n        if(LV_STYLE_ATTR_GET_INHERIT(attr) == 0) break;",
        "res_region": "",
        "lookback": "            d = lv_disp_get_next(d);",
        "lookahead": "",
        "label": [
            "deletion",
            "base_underutilized"
        ],
        "start_line": 4775,
        "end_line": 4799,
        "merge_gen_region": null,
        "confidence": 0.8790609836578369,
        "hesitated": true
    },
    {
        "a_contents": "    if(obj->spec_attr == NULL) {\n        static uint32_t x = 0;\n        x++;\n        obj->spec_attr = lv_mem_alloc(sizeof(lv_obj_spec_attr_t));\n        LV_ASSERT_MEM(obj->spec_attr);\n        if(obj->spec_attr == NULL) return NULL;",
        "b_contents": "    return obj->parent_event == 0 ? false : true;\n}\n\nlv_bidi_dir_t lv_obj_get_base_dir(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);",
        "base_contents": "    return obj->parent_event == 0 ? false : true;\n}\n\n\nlv_bidi_dir_t lv_obj_get_base_dir(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);",
        "res_region": "    if(obj->spec_attr == NULL) {\n        static uint32_t x = 0;\n        x++;\n        obj->spec_attr = lv_mem_alloc(sizeof(lv_obj_spec_attr_t));\n        LV_ASSERT_MEM(obj->spec_attr);\n        if(obj->spec_attr == NULL) return NULL;",
        "lookback": "        static uint32_t x = 0;",
        "lookahead": "",
        "label": [
            "ours",
            "base_underutilized"
        ],
        "start_line": 4914,
        "end_line": 4936,
        "merge_gen_region": "(->__((,ccccccccstatic::cccc",
        "confidence": 0.8878988027572632,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "",
        "b_contents": "/*-------------------\n * OTHER FUNCTIONS\n *------------------*/\n",
        "base_contents": "\n/*-------------------\n * OTHER FUNCTIONS\n *------------------*/\n",
        "res_region": "",
        "lookback": "/**",
        "lookahead": "/**",
        "label": [
            "ours",
            "base_underutilized"
        ],
        "start_line": 5115,
        "end_line": 5128,
        "merge_gen_region": null,
        "confidence": 0.8640682697296143,
        "hesitated": true
    },
    {
        "a_contents": "        return  LV_DRAW_RES_COVER;",
        "b_contents": "        return LV_DESIGN_RES_COVER;",
        "base_contents": "        return  LV_DESIGN_RES_COVER;",
        "res_region": "        return  LV_DRAW_RES_COVER;",
        "lookback": "",
        "lookahead": "",
        "label": [
            "ours",
            "base_underutilized"
        ],
        "start_line": 5567,
        "end_line": 5573,
        "merge_gen_region": null,
        "confidence": 0.6264327764511108,
        "hesitated": true
    },
    {
        "a_contents": "static void base_dir_refr_children(lv_obj_t * obj)",
        "b_contents": "/**\n * Get the really focused object by taking `focus_parent` into account.\n * @param obj the start object\n * @return the object to really focus\n */\nlv_obj_t * lv_obj_get_focused_obj(const lv_obj_t * obj)",
        "base_contents": "\n/**\n * Get the really focused object by taking `focus_parent` into account.\n * @param obj the start object\n * @return the object to really focus\n */\nlv_obj_t * lv_obj_get_focused_obj(const lv_obj_t * obj)",
        "res_region": "static void base_dir_refr_children(lv_obj_t * obj)",
        "lookback": "{",
        "lookahead": "{",
        "label": [
            "ours",
            "base_underutilized"
        ],
        "start_line": 5681,
        "end_line": 5698,
        "merge_gen_region": null,
        "confidence": 0.5379996299743652,
        "hesitated": true
    },
    {
        "a_contents": "    else if(sign == LV_SIGNAL_SCROLL) {\n        res = lv_event_send(obj, LV_EVENT_SCROLL, NULL);\n        if(res != LV_RES_OK) return res;",
        "b_contents": "}\n\nstatic void obj_align_core(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, bool x_set, bool y_set,\n                           lv_coord_t x_ofs, lv_coord_t y_ofs)\n{\n    lv_point_t new_pos;\n    _lv_area_align(&base->coords, &obj->coords, align, &new_pos);\n\n    /*Bring together the coordination system of base and obj*/\n    lv_obj_t * par        = lv_obj_get_parent(obj);\n    lv_coord_t par_abs_x  = par->coords.x1;\n    lv_coord_t par_abs_y  = par->coords.y1;\n    new_pos.x += x_ofs;\n    new_pos.y += y_ofs;\n    new_pos.x -= par_abs_x;\n    new_pos.y -= par_abs_y;\n\n    if(x_set && y_set) lv_obj_set_pos(obj, new_pos.x, new_pos.y);\n    else if(x_set) lv_obj_set_x(obj, new_pos.x);\n    else if(y_set) lv_obj_set_y(obj, new_pos.y);\n}\n\nstatic void obj_align_mid_core(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align,  bool x_set, bool y_set,\n                               lv_coord_t x_ofs, lv_coord_t y_ofs)\n{\n    lv_coord_t new_x = lv_obj_get_x(obj);\n    lv_coord_t new_y = lv_obj_get_y(obj);\n\n    lv_coord_t obj_w_half = lv_obj_get_width(obj) / 2;\n    lv_coord_t obj_h_half = lv_obj_get_height(obj) / 2;\n\n    switch(align) {\n        case LV_ALIGN_CENTER:\n            new_x = lv_obj_get_width(base) / 2 - obj_w_half;\n            new_y = lv_obj_get_height(base) / 2 - obj_h_half;\n            break;\n\n        case LV_ALIGN_IN_TOP_LEFT:\n            new_x = -obj_w_half;\n            new_y = -obj_h_half;\n            break;\n        case LV_ALIGN_IN_TOP_MID:\n            new_x = lv_obj_get_width(base) / 2 - obj_w_half;\n            new_y = -obj_h_half;\n            break;\n\n        case LV_ALIGN_IN_TOP_RIGHT:\n            new_x = lv_obj_get_width(base) - obj_w_half;\n            new_y = -obj_h_half;\n            break;\n\n        case LV_ALIGN_IN_BOTTOM_LEFT:\n            new_x = -obj_w_half;\n            new_y = lv_obj_get_height(base) - obj_h_half;\n            break;\n        case LV_ALIGN_IN_BOTTOM_MID:\n            new_x = lv_obj_get_width(base) / 2 - obj_w_half;\n            new_y = lv_obj_get_height(base) - obj_h_half;\n            break;\n\n        case LV_ALIGN_IN_BOTTOM_RIGHT:\n            new_x = lv_obj_get_width(base) - obj_w_half;\n            new_y = lv_obj_get_height(base) - obj_h_half;\n            break;\n\n        case LV_ALIGN_IN_LEFT_MID:\n            new_x = -obj_w_half;\n            new_y = lv_obj_get_height(base) / 2 - obj_h_half;\n            break;\n\n        case LV_ALIGN_IN_RIGHT_MID:\n            new_x = lv_obj_get_width(base) - obj_w_half;\n            new_y = lv_obj_get_height(base) / 2 - obj_h_half;\n            break;\n\n        case LV_ALIGN_OUT_TOP_LEFT:\n            new_x = -obj_w_half;\n            new_y = -obj_h_half;\n            break;\n\n        case LV_ALIGN_OUT_TOP_MID:\n            new_x = lv_obj_get_width(base) / 2 - obj_w_half;\n            new_y = -obj_h_half;\n            break;\n\n        case LV_ALIGN_OUT_TOP_RIGHT:\n            new_x = lv_obj_get_width(base) - obj_w_half;\n            new_y = -obj_h_half;\n            break;\n\n        case LV_ALIGN_OUT_BOTTOM_LEFT:\n            new_x = -obj_w_half;\n            new_y = lv_obj_get_height(base) - obj_h_half;\n            break;\n\n        case LV_ALIGN_OUT_BOTTOM_MID:\n            new_x = lv_obj_get_width(base) / 2 - obj_w_half;\n            new_y = lv_obj_get_height(base) - obj_h_half;\n            break;\n\n        case LV_ALIGN_OUT_BOTTOM_RIGHT:\n            new_x = lv_obj_get_width(base) - obj_w_half;\n            new_y = lv_obj_get_height(base) - obj_h_half;\n            break;\n\n        case LV_ALIGN_OUT_LEFT_TOP:\n            new_x = -obj_w_half;\n            new_y = -obj_h_half;\n            break;\n\n        case LV_ALIGN_OUT_LEFT_MID:\n            new_x = -obj_w_half;\n            new_y = lv_obj_get_height(base) / 2 - obj_h_half;\n            break;\n\n        case LV_ALIGN_OUT_LEFT_BOTTOM:\n            new_x = -obj_w_half;\n            new_y = lv_obj_get_height(base) - obj_h_half;\n            break;\n\n        case LV_ALIGN_OUT_RIGHT_TOP:\n            new_x = lv_obj_get_width(base) - obj_w_half;\n            new_y = -obj_h_half;\n            break;\n\n        case LV_ALIGN_OUT_RIGHT_MID:\n            new_x = lv_obj_get_width(base) - obj_w_half;\n            new_y = lv_obj_get_height(base) / 2 - obj_h_half;\n            break;\n\n        case LV_ALIGN_OUT_RIGHT_BOTTOM:\n            new_x = lv_obj_get_width(base) - obj_w_half;\n            new_y = lv_obj_get_height(base) - obj_h_half;\n            break;",
        "base_contents": "}\n\nstatic void obj_align_core(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, bool x_set, bool y_set,\n                           lv_coord_t x_ofs, lv_coord_t y_ofs)\n{\n    lv_point_t new_pos;\n    _lv_area_align(&base->coords, &obj->coords, align, &new_pos);\n\n    /*Bring together the coordination system of base and obj*/\n    lv_obj_t * par        = lv_obj_get_parent(obj);\n    lv_coord_t par_abs_x  = par->coords.x1;\n    lv_coord_t par_abs_y  = par->coords.y1;\n    new_pos.x += x_ofs;\n    new_pos.y += y_ofs;\n    new_pos.x -= par_abs_x;\n    new_pos.y -= par_abs_y;\n\n    if(x_set && y_set) lv_obj_set_pos(obj, new_pos.x, new_pos.y);\n    else if(x_set) lv_obj_set_x(obj, new_pos.x);\n    else if(y_set) lv_obj_set_y(obj, new_pos.y);\n}\n\nstatic void obj_align_mid_core(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align,  bool x_set, bool y_set,\n                               lv_coord_t x_ofs, lv_coord_t y_ofs)\n{\n    lv_coord_t new_x = lv_obj_get_x(obj);\n    lv_coord_t new_y = lv_obj_get_y(obj);\n\n    lv_coord_t obj_w_half = lv_obj_get_width(obj) / 2;\n    lv_coord_t obj_h_half = lv_obj_get_height(obj) / 2;\n\n\n    switch(align) {\n        case LV_ALIGN_CENTER:\n            new_x = lv_obj_get_width(base) / 2 - obj_w_half;\n            new_y = lv_obj_get_height(base) / 2 - obj_h_half;\n            break;\n\n        case LV_ALIGN_IN_TOP_LEFT:\n            new_x = -obj_w_half;\n            new_y = -obj_h_half;\n            break;\n        case LV_ALIGN_IN_TOP_MID:\n            new_x = lv_obj_get_width(base) / 2 - obj_w_half;\n            new_y = -obj_h_half;\n            break;\n\n        case LV_ALIGN_IN_TOP_RIGHT:\n            new_x = lv_obj_get_width(base) - obj_w_half;\n            new_y = -obj_h_half;\n            break;\n\n        case LV_ALIGN_IN_BOTTOM_LEFT:\n            new_x = -obj_w_half;\n            new_y = lv_obj_get_height(base) - obj_h_half;\n            break;\n        case LV_ALIGN_IN_BOTTOM_MID:\n            new_x = lv_obj_get_width(base) / 2 - obj_w_half;\n            new_y = lv_obj_get_height(base) - obj_h_half;\n            break;\n\n        case LV_ALIGN_IN_BOTTOM_RIGHT:\n            new_x = lv_obj_get_width(base) - obj_w_half;\n            new_y = lv_obj_get_height(base) - obj_h_half;\n            break;\n\n        case LV_ALIGN_IN_LEFT_MID:\n            new_x = -obj_w_half;\n            new_y = lv_obj_get_height(base) / 2 - obj_h_half;\n            break;\n\n        case LV_ALIGN_IN_RIGHT_MID:\n            new_x = lv_obj_get_width(base) - obj_w_half;\n            new_y = lv_obj_get_height(base) / 2 - obj_h_half;\n            break;\n\n        case LV_ALIGN_OUT_TOP_LEFT:\n            new_x = -obj_w_half;\n            new_y = -obj_h_half;\n            break;\n\n        case LV_ALIGN_OUT_TOP_MID:\n            new_x = lv_obj_get_width(base) / 2 - obj_w_half;\n            new_y = -obj_h_half;\n            break;\n\n        case LV_ALIGN_OUT_TOP_RIGHT:\n            new_x = lv_obj_get_width(base) - obj_w_half;\n            new_y = -obj_h_half;\n            break;\n\n        case LV_ALIGN_OUT_BOTTOM_LEFT:\n            new_x = -obj_w_half;\n            new_y = lv_obj_get_height(base) - obj_h_half;\n            break;\n\n        case LV_ALIGN_OUT_BOTTOM_MID:\n            new_x = lv_obj_get_width(base) / 2 - obj_w_half;\n            new_y = lv_obj_get_height(base) - obj_h_half;\n            break;\n\n        case LV_ALIGN_OUT_BOTTOM_RIGHT:\n            new_x = lv_obj_get_width(base) - obj_w_half;\n            new_y = lv_obj_get_height(base) - obj_h_half;\n            break;\n\n        case LV_ALIGN_OUT_LEFT_TOP:\n            new_x = -obj_w_half;\n            new_y = -obj_h_half;\n            break;\n\n        case LV_ALIGN_OUT_LEFT_MID:\n            new_x = -obj_w_half;\n            new_y = lv_obj_get_height(base) / 2 - obj_h_half;\n            break;\n\n        case LV_ALIGN_OUT_LEFT_BOTTOM:\n            new_x = -obj_w_half;\n            new_y = lv_obj_get_height(base) - obj_h_half;\n            break;\n\n        case LV_ALIGN_OUT_RIGHT_TOP:\n            new_x = lv_obj_get_width(base) - obj_w_half;\n            new_y = -obj_h_half;\n            break;\n\n        case LV_ALIGN_OUT_RIGHT_MID:\n            new_x = lv_obj_get_width(base) - obj_w_half;\n            new_y = lv_obj_get_height(base) / 2 - obj_h_half;\n            break;\n\n        case LV_ALIGN_OUT_RIGHT_BOTTOM:\n            new_x = lv_obj_get_width(base) - obj_w_half;\n            new_y = lv_obj_get_height(base) - obj_h_half;\n            break;",
        "res_region": "    else if(sign == LV_SIGNAL_SCROLL) {\n        res = lv_event_send(obj, LV_EVENT_SCROLL, NULL);\n        if(res != LV_RES_OK) return res;",
        "lookback": "        res = lv_event_send(obj, LV_EVENT_SCROLL, NULL);",
        "lookahead": "    }",
        "label": [
            "ours",
            "base_underutilized"
        ],
        "start_line": 5835,
        "end_line": 6110,
        "merge_gen_region": " =___(obj LVEVENTSCROLL NULL",
        "confidence": 0.8888923525810242,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "    else if(sign == LV_SIGNAL_SCROLL_END) {\n        if(lv_obj_get_scrollbar_mode(obj) == LV_SCROLLBAR_MODE_ACTIVE) {\n            lv_obj_invalidate(obj);",
        "b_contents": "\n    /*Bring together the coordination system of base and obj*/\n    lv_obj_t * par        = lv_obj_get_parent(obj);\n    lv_coord_t base_abs_x = base->coords.x1;\n    lv_coord_t base_abs_y = base->coords.y1;\n    lv_coord_t par_abs_x  = par->coords.x1;\n    lv_coord_t par_abs_y  = par->coords.y1;\n    new_x += x_ofs + base_abs_x;\n    new_y += y_ofs + base_abs_y;\n    new_x -= par_abs_x;\n    new_y -= par_abs_y;\n    if(x_set && y_set) lv_obj_set_pos(obj, new_x, new_y);\n    else if(x_set) lv_obj_set_x(obj, new_x);\n    else if(y_set) lv_obj_set_y(obj, new_y);\n\n}\n\n#if LV_USE_ANIMATION\n\n/**\n * Allocate and initialize a transition for a property of an object if the properties value is different in the new state.\n * It allocates `lv_style_trans_t` in `_lv_obj_style_trans_ll` and set only `start/end_values`. No animation will be created here.\n * @param obj and object to add the transition\n * @param prop the property to apply the transaction\n * @param part the part of the object to apply the transaction\n * @param prev_state the previous state of the objects\n * @param new_state the new state of the object\n * @return pointer to the allocated `the transaction` variable or `NULL` if no transition created\n */\nstatic lv_style_trans_t * trans_create(lv_obj_t * obj, lv_style_property_t prop, uint8_t part, lv_state_t prev_state,\n                                       lv_state_t new_state)\n{\n    lv_style_trans_t * tr;\n    lv_style_list_t * style_list = lv_obj_get_style_list(obj, part);\n    lv_style_t * style_trans = _lv_style_list_get_transition_style(style_list);\n\n    bool cache_ori = style_list->ignore_cache;\n\n    /*Get the previous and current values*/\n    if((prop & 0xF) < LV_STYLE_ID_COLOR) { /*Int*/\n        style_list->skip_trans = 1;\n        style_list->ignore_cache = 1;\n        obj->state = prev_state;\n        lv_style_int_t int1 = _lv_obj_get_style_int(obj, part, prop);\n        obj->state = new_state;\n        lv_style_int_t int2 =  _lv_obj_get_style_int(obj, part, prop);\n        style_list->skip_trans = 0;\n        style_list->ignore_cache = cache_ori;\n\n        if(int1 == int2)  return NULL;\n        obj->state = prev_state;\n        int1 = _lv_obj_get_style_int(obj, part, prop);\n        obj->state = new_state;\n        _lv_style_set_int(style_trans, prop, int1);   /*Be sure `trans_style` has a valid value */\n\n        if(prop == LV_STYLE_RADIUS) {\n            if(int1 == LV_RADIUS_CIRCLE || int2 == LV_RADIUS_CIRCLE) {\n                lv_coord_t whalf = lv_obj_get_width(obj) / 2;\n                lv_coord_t hhalf = lv_obj_get_width(obj) / 2;\n                if(int1 == LV_RADIUS_CIRCLE) int1 = LV_MATH_MIN(whalf + 1, hhalf + 1);\n                if(int2 == LV_RADIUS_CIRCLE) int2 = LV_MATH_MIN(whalf + 1, hhalf + 1);\n            }",
        "base_contents": "\n    /*Bring together the coordination system of base and obj*/\n    lv_obj_t * par        = lv_obj_get_parent(obj);\n    lv_coord_t base_abs_x = base->coords.x1;\n    lv_coord_t base_abs_y = base->coords.y1;\n    lv_coord_t par_abs_x  = par->coords.x1;\n    lv_coord_t par_abs_y  = par->coords.y1;\n    new_x += x_ofs + base_abs_x;\n    new_y += y_ofs + base_abs_y;\n    new_x -= par_abs_x;\n    new_y -= par_abs_y;\n    if(x_set && y_set) lv_obj_set_pos(obj, new_x, new_y);\n    else if(x_set) lv_obj_set_x(obj, new_x);\n    else if(y_set) lv_obj_set_y(obj, new_y);\n\n}\n\n\n\n#if LV_USE_ANIMATION\n\n/**\n * Allocate and initialize a transition for a property of an object if the properties value is different in the new state.\n * It allocates `lv_style_trans_t` in `_lv_obj_style_trans_ll` and set only `start/end_values`. No animation will be created here.\n * @param obj and object to add the transition\n * @param prop the property to apply the transaction\n * @param part the part of the object to apply the transaction\n * @param prev_state the previous state of the objects\n * @param new_state the new state of the object\n * @return pointer to the allocated `the transaction` variable or `NULL` if no transition created\n */\nstatic lv_style_trans_t * trans_create(lv_obj_t * obj, lv_style_property_t prop, uint8_t part, lv_state_t prev_state,\n                                       lv_state_t new_state)\n{\n    lv_style_trans_t * tr;\n    lv_style_list_t * style_list = lv_obj_get_style_list(obj, part);\n    lv_style_t * style_trans = _lv_style_list_get_transition_style(style_list);\n\n    bool cache_ori = style_list->ignore_cache;\n\n    /*Get the previous and current values*/\n    if((prop & 0xF) < LV_STYLE_ID_COLOR) { /*Int*/\n        style_list->skip_trans = 1;\n        style_list->ignore_cache = 1;\n        obj->state = prev_state;\n        lv_style_int_t int1 = _lv_obj_get_style_int(obj, part, prop);\n        obj->state = new_state;\n        lv_style_int_t int2 =  _lv_obj_get_style_int(obj, part, prop);\n        style_list->skip_trans = 0;\n        style_list->ignore_cache = cache_ori;\n\n        if(int1 == int2)  return NULL;\n        obj->state = prev_state;\n        int1 = _lv_obj_get_style_int(obj, part, prop);\n        obj->state = new_state;\n        _lv_style_set_int(style_trans, prop, int1);   /*Be sure `trans_style` has a valid value */\n\n        if(prop == LV_STYLE_RADIUS) {\n            if(int1 == LV_RADIUS_CIRCLE || int2 == LV_RADIUS_CIRCLE) {\n                lv_coord_t whalf = lv_obj_get_width(obj) / 2;\n                lv_coord_t hhalf = lv_obj_get_width(obj) / 2;\n                if(int1 == LV_RADIUS_CIRCLE) int1 = LV_MATH_MIN(whalf + 1, hhalf + 1);\n                if(int2 == LV_RADIUS_CIRCLE) int2 = LV_MATH_MIN(whalf + 1, hhalf + 1);\n            }",
        "res_region": "    else if(sign == LV_SIGNAL_SCROLL_END) {\n        if(lv_obj_get_scrollbar_mode(obj) == LV_SCROLLBAR_MODE_ACTIVE) {\n            lv_obj_invalidate(obj);",
        "lookback": "        if(lv_obj_get_scrollbar_mode(obj) == LV_SCROLLBAR_MODE_ACTIVE) {",
        "lookahead": "        }",
        "label": [
            "ours",
            "base_underutilized"
        ],
        "start_line": 6112,
        "end_line": 6244,
        "merge_gen_region": null,
        "confidence": 0.8328678011894226,
        "hesitated": true
    },
    {
        "a_contents": "",
        "b_contents": "\nstatic bool style_prop_is_cacheble(lv_style_property_t prop)\n{\n\n    switch(prop) {\n        case LV_STYLE_PROP_ALL:\n        case LV_STYLE_CLIP_CORNER:\n        case LV_STYLE_TEXT_LETTER_SPACE:\n        case LV_STYLE_TEXT_LINE_SPACE:\n        case LV_STYLE_TEXT_FONT:\n        case LV_STYLE_TRANSFORM_ANGLE:\n        case LV_STYLE_TRANSFORM_WIDTH:\n        case LV_STYLE_TRANSFORM_HEIGHT:\n        case LV_STYLE_TRANSFORM_ZOOM:\n        case LV_STYLE_BORDER_WIDTH:\n        case LV_STYLE_OUTLINE_WIDTH:\n        case LV_STYLE_RADIUS:\n        case LV_STYLE_SHADOW_WIDTH:\n        case LV_STYLE_OPA_SCALE:\n        case LV_STYLE_BG_OPA:\n        case LV_STYLE_BORDER_SIDE:\n        case LV_STYLE_BORDER_POST:\n        case LV_STYLE_IMAGE_RECOLOR_OPA:\n        case LV_STYLE_VALUE_STR:\n        case LV_STYLE_PATTERN_IMAGE:\n        case LV_STYLE_PAD_TOP:\n        case LV_STYLE_PAD_BOTTOM:\n        case LV_STYLE_PAD_LEFT:\n        case LV_STYLE_PAD_RIGHT:\n        case LV_STYLE_MARGIN_TOP:\n        case LV_STYLE_MARGIN_BOTTOM:\n        case LV_STYLE_MARGIN_LEFT:\n        case LV_STYLE_MARGIN_RIGHT:\n        case LV_STYLE_BG_BLEND_MODE:\n        case LV_STYLE_BORDER_BLEND_MODE:\n        case LV_STYLE_IMAGE_BLEND_MODE:\n        case LV_STYLE_LINE_BLEND_MODE:\n        case LV_STYLE_OUTLINE_BLEND_MODE:\n        case LV_STYLE_PATTERN_BLEND_MODE:\n        case LV_STYLE_SHADOW_BLEND_MODE:\n        case LV_STYLE_TEXT_BLEND_MODE:\n        case LV_STYLE_VALUE_BLEND_MODE:\n            return true;\n            break;\n        default:\n            return false;\n    }\n}\n\n/**\n * Update the cache of style list\n * @param obj pointer to an object\n * @param part the part of the object\n * @param prop the property which triggered the update\n */\nstatic void update_style_cache(lv_obj_t * obj, uint8_t part, uint16_t prop)\n{\n    if(style_prop_is_cacheble(prop) == false) return;\n\n    lv_style_list_t * list = lv_obj_get_style_list(obj, part);\n\n    bool ignore_cache_ori = list->ignore_cache;\n    list->ignore_cache = 1;\n\n#if LV_USE_OPA_SCALE\n    list->opa_scale_cover    = lv_obj_get_style_opa_scale(obj, part) == LV_OPA_COVER ? 1 : 0;\n#else\n    list->opa_scale_cover    = 1;\n#endif\n    list->text_decor_none    = lv_obj_get_style_text_decor(obj, part) == LV_TEXT_DECOR_NONE ? 1 : 0;\n    list->text_font_normal    = lv_obj_get_style_text_font(obj, part) == LV_THEME_DEFAULT_FONT_NORMAL ? 1 : 0;\n\n    list->text_space_zero = 1;\n    if(lv_obj_get_style_text_letter_space(obj, part) != 0 ||\n       lv_obj_get_style_text_line_space(obj, part) != 0) {\n        list->text_space_zero = 0;\n    }\n\n    lv_opa_t bg_opa = lv_obj_get_style_bg_opa(obj, part);\n    list->bg_opa_transp    = bg_opa == LV_OPA_TRANSP ? 1 : 0;\n    list->bg_opa_cover     = bg_opa == LV_OPA_COVER ? 1 : 0;\n\n    list->border_width_zero = lv_obj_get_style_border_width(obj, part) == 0 ? 1 : 0;\n    list->border_side_full = lv_obj_get_style_border_side(obj, part) == LV_BORDER_SIDE_FULL ? 1 : 0;\n    list->border_post_off = lv_obj_get_style_border_post(obj, part) == 0 ? 1 : 0;\n    list->clip_corner_off   = lv_obj_get_style_clip_corner(obj, part) == false ? 1 : 0;\n    list->img_recolor_opa_transp    = lv_obj_get_style_image_recolor_opa(obj, part) == LV_OPA_TRANSP ? 1 : 0;\n    list->outline_width_zero    = lv_obj_get_style_outline_width(obj, part) == 0 ? 1 : 0;\n    list->pattern_img_null    = lv_obj_get_style_pattern_image(obj, part) == NULL ? 1 : 0;\n    list->radius_zero    = lv_obj_get_style_radius(obj, part) == 0 ? 1 : 0;\n    list->shadow_width_zero    = lv_obj_get_style_shadow_width(obj, part) == 0 ? 1 : 0;\n    list->value_txt_str    = lv_obj_get_style_value_str(obj, part) == NULL ? 1 : 0;\n\n    list->transform_all_zero  = 1;\n    if(lv_obj_get_style_transform_angle(obj, part) != 0 ||\n       lv_obj_get_style_transform_width(obj, part) != 0 ||\n       lv_obj_get_style_transform_height(obj, part) != 0 ||\n       lv_obj_get_style_transform_zoom(obj, part) != LV_IMG_ZOOM_NONE) {\n        list->transform_all_zero  = 0;\n    }\n\n    list->pad_all_zero  = 1;\n    if(lv_obj_get_style_pad_top(obj, part) != 0 ||\n       lv_obj_get_style_pad_bottom(obj, part) != 0 ||\n       lv_obj_get_style_pad_left(obj, part) != 0 ||\n       lv_obj_get_style_pad_right(obj, part) != 0) {\n        list->pad_all_zero  = 0;\n    }\n\n    list->margin_all_zero  = 1;\n    if(lv_obj_get_style_margin_top(obj, part) != 0 ||\n       lv_obj_get_style_margin_bottom(obj, part) != 0 ||\n       lv_obj_get_style_margin_left(obj, part) != 0 ||\n       lv_obj_get_style_margin_right(obj, part) != 0) {\n        list->margin_all_zero  = 0;\n    }\n\n    list->blend_mode_all_normal = 1;\n#if LV_USE_BLEND_MODES\n    if(lv_obj_get_style_bg_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||\n       lv_obj_get_style_border_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||\n       lv_obj_get_style_pattern_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||\n       lv_obj_get_style_outline_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||\n       lv_obj_get_style_value_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||\n       lv_obj_get_style_text_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||\n       lv_obj_get_style_line_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||\n       lv_obj_get_style_image_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||\n       lv_obj_get_style_shadow_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL) {\n        list->blend_mode_all_normal = 0;\n    }\n#endif\n    list->ignore_cache = ignore_cache_ori;\n    list->valid_cache = 1;\n}\n\n/**\n * Update the cache of style list\n * @param obj pointer to an object\n * @param part the part of the object\n */\nstatic void update_style_cache_children(lv_obj_t * obj)\n{\n    uint8_t part;\n    for(part = 0; part != _LV_OBJ_PART_REAL_LAST; part++) {\n        lv_style_list_t * list = lv_obj_get_style_list(obj, part);\n        if(list == NULL) break;\n\n        bool ignore_cache_ori = list->ignore_cache;\n        list->ignore_cache = 1;\n\n        list->opa_scale_cover    = lv_obj_get_style_opa_scale(obj, part) == LV_OPA_COVER ? 1 : 0;\n        list->text_decor_none    = lv_obj_get_style_text_decor(obj, part) == LV_TEXT_DECOR_NONE ? 1 : 0;\n        list->text_font_normal    = lv_obj_get_style_text_font(obj, part) == lv_theme_get_font_normal() ? 1 : 0;\n        list->img_recolor_opa_transp    = lv_obj_get_style_image_recolor_opa(obj, part) == LV_OPA_TRANSP ? 1 : 0;\n\n        list->text_space_zero = 1;\n        if(lv_obj_get_style_text_letter_space(obj, part) != 0 ||\n           lv_obj_get_style_text_line_space(obj, part) != 0) {\n            list->text_space_zero = 0;\n        }\n\n        list->ignore_cache = ignore_cache_ori;\n    }\n\n    lv_obj_t * child = lv_obj_get_child(obj, NULL);\n    while(child) {\n        update_style_cache_children(child);\n        child = lv_obj_get_child(obj, child);\n    }\n\n}\n\n/**\n * Mark the object and all of it's children's style lists as invalid.\n * The cache will be updated when a cached property asked nest time\n * @param obj pointer to an object\n */\nstatic void invalidate_style_cache(lv_obj_t * obj, uint8_t part, lv_style_property_t prop)\n{\n    if(style_prop_is_cacheble(prop) == false) return;\n\n    for(part = 0; part < _LV_OBJ_PART_REAL_FIRST; part++) {\n        lv_style_list_t * list = lv_obj_get_style_list(obj, part);\n        if(list == NULL) break;\n        list->valid_cache = 0;\n    }\n\n    for(part = _LV_OBJ_PART_REAL_FIRST; part < 0xFF; part++) {\n        lv_style_list_t * list = lv_obj_get_style_list(obj, part);\n        if(list == NULL) break;\n        list->valid_cache = 0;\n    }\n\n    lv_obj_t * child = lv_obj_get_child(obj, NULL);\n    while(child) {\n        update_style_cache_children(child);\n        child = lv_obj_get_child(obj, child);\n    }\n}\n\nstatic void style_snapshot(lv_obj_t * obj, uint8_t part, style_snapshot_t * shot)\n{\n    _lv_obj_disable_style_caching(obj, true);\n    _lv_memset_00(shot, sizeof(style_snapshot_t));\n    lv_draw_rect_dsc_init(&shot->rect);\n    lv_draw_label_dsc_init(&shot->label);\n    lv_draw_img_dsc_init(&shot->img);\n    lv_draw_line_dsc_init(&shot->line);\n\n    lv_style_list_t * list = lv_obj_get_style_list(obj, part);\n    bool trans_ori = list->skip_trans;\n    list->skip_trans = 1;\n\n    lv_obj_init_draw_rect_dsc(obj, part, &shot->rect);\n    lv_obj_init_draw_label_dsc(obj, part, &shot->label);\n    lv_obj_init_draw_img_dsc(obj, part, &shot->img);\n    lv_obj_init_draw_line_dsc(obj, part, &shot->line);\n\n    shot->pad_top = lv_obj_get_style_pad_top(obj, part);\n    shot->pad_bottom = lv_obj_get_style_pad_bottom(obj, part);\n    shot->pad_right = lv_obj_get_style_pad_right(obj, part);\n    shot->pad_left = lv_obj_get_style_pad_left(obj, part);\n    shot->pad_inner = lv_obj_get_style_pad_inner(obj, part);\n    shot->margin_top = lv_obj_get_style_margin_top(obj, part);\n    shot->margin_bottom = lv_obj_get_style_margin_bottom(obj, part);\n    shot->margin_left = lv_obj_get_style_margin_left(obj, part);\n    shot->margin_right = lv_obj_get_style_margin_right(obj, part);\n    shot->size = lv_obj_get_style_size(obj, part);\n    shot->transform_width = lv_obj_get_style_transform_width(obj, part);\n    shot->transform_height = lv_obj_get_style_transform_height(obj, part);\n    shot->transform_angle = lv_obj_get_style_transform_angle(obj, part);\n    shot->transform_zoom = lv_obj_get_style_transform_zoom(obj, part);\n    shot->scale_width = lv_obj_get_style_scale_width(obj, part);\n    shot->scale_border_width = lv_obj_get_style_scale_border_width(obj, part);\n    shot->scale_end_border_width = lv_obj_get_style_scale_end_border_width(obj, part);\n    shot->scale_end_line_width = lv_obj_get_style_scale_end_line_width(obj, part);\n    shot->scale_grad_color = lv_obj_get_style_scale_grad_color(obj, part);\n    shot->scale_end_color = lv_obj_get_style_scale_end_color(obj, part);\n    shot->opa_scale = lv_obj_get_style_opa_scale(obj, part);\n    shot->clip_corner = lv_obj_get_style_clip_corner(obj, part);\n    shot->border_post  = lv_obj_get_style_border_post(obj, part);\n\n    _lv_obj_disable_style_caching(obj, false);\n    list->skip_trans = trans_ori;\n}\n\nstatic style_snapshot_res_t style_snapshot_compare(style_snapshot_t * shot1, style_snapshot_t * shot2)\n{\n    if(memcmp(shot1, shot2, sizeof(style_snapshot_t)) == 0) return STYLE_COMPARE_SAME;\n\n    if(shot1->pad_top != shot2->pad_top) return STYLE_COMPARE_DIFF;\n    if(shot1->pad_bottom != shot2->pad_bottom) return STYLE_COMPARE_DIFF;\n    if(shot1->pad_left != shot2->pad_right) return STYLE_COMPARE_DIFF;\n    if(shot1->pad_right != shot2->pad_right) return STYLE_COMPARE_DIFF;\n    if(shot1->pad_top != shot2->pad_top) return STYLE_COMPARE_DIFF;\n    if(shot1->pad_inner != shot2->pad_inner) return STYLE_COMPARE_DIFF;\n    if(shot1->margin_top != shot2->margin_top) return STYLE_COMPARE_DIFF;\n    if(shot1->margin_bottom != shot2->margin_bottom) return STYLE_COMPARE_DIFF;\n    if(shot1->margin_left != shot2->margin_right) return STYLE_COMPARE_DIFF;\n    if(shot1->margin_right != shot2->margin_right) return STYLE_COMPARE_DIFF;\n    if(shot1->margin_top != shot2->margin_top) return STYLE_COMPARE_DIFF;\n    if(shot1->transform_width != shot2->transform_width) return STYLE_COMPARE_DIFF;\n    if(shot1->transform_height != shot2->transform_height) return STYLE_COMPARE_DIFF;\n    if(shot1->transform_angle != shot2->transform_angle) return STYLE_COMPARE_DIFF;\n    if(shot1->transform_zoom != shot2->transform_zoom) return STYLE_COMPARE_DIFF;\n    if(shot1->rect.outline_width != shot2->rect.outline_width) return STYLE_COMPARE_DIFF;\n    if(shot1->rect.outline_pad != shot2->rect.outline_pad) return STYLE_COMPARE_DIFF;\n    if(shot1->rect.value_font != shot2->rect.value_font) return STYLE_COMPARE_DIFF;\n    if(shot1->rect.value_align != shot2->rect.value_align) return STYLE_COMPARE_DIFF;\n    if(shot1->rect.value_font != shot2->rect.value_font) return STYLE_COMPARE_DIFF;\n    if(shot1->rect.shadow_spread != shot2->rect.shadow_spread) return STYLE_COMPARE_DIFF;\n    if(shot1->rect.shadow_width != shot2->rect.shadow_width) return STYLE_COMPARE_DIFF;\n    if(shot1->rect.shadow_ofs_x != shot2->rect.shadow_ofs_x) return STYLE_COMPARE_DIFF;\n    if(shot1->rect.shadow_ofs_y != shot2->rect.shadow_ofs_y) return STYLE_COMPARE_DIFF;\n\n    /*If not returned earlier its just a visual difference, a simple redraw is enough*/\n    return STYLE_COMPARE_VISUAL_DIFF;\n}",
        "base_contents": "\nstatic bool style_prop_is_cacheble(lv_style_property_t prop)\n{\n\n    switch(prop) {\n        case LV_STYLE_PROP_ALL:\n        case LV_STYLE_CLIP_CORNER:\n        case LV_STYLE_TEXT_LETTER_SPACE:\n        case LV_STYLE_TEXT_LINE_SPACE:\n        case LV_STYLE_TEXT_FONT:\n        case LV_STYLE_TRANSFORM_ANGLE:\n        case LV_STYLE_TRANSFORM_WIDTH:\n        case LV_STYLE_TRANSFORM_HEIGHT:\n        case LV_STYLE_TRANSFORM_ZOOM:\n        case LV_STYLE_BORDER_WIDTH:\n        case LV_STYLE_OUTLINE_WIDTH:\n        case LV_STYLE_RADIUS:\n        case LV_STYLE_SHADOW_WIDTH:\n        case LV_STYLE_OPA_SCALE:\n        case LV_STYLE_BG_OPA:\n        case LV_STYLE_BORDER_SIDE:\n        case LV_STYLE_BORDER_POST:\n        case LV_STYLE_IMAGE_RECOLOR_OPA:\n        case LV_STYLE_VALUE_STR:\n        case LV_STYLE_PATTERN_IMAGE:\n        case LV_STYLE_PAD_TOP:\n        case LV_STYLE_PAD_BOTTOM:\n        case LV_STYLE_PAD_LEFT:\n        case LV_STYLE_PAD_RIGHT:\n        case LV_STYLE_MARGIN_TOP:\n        case LV_STYLE_MARGIN_BOTTOM:\n        case LV_STYLE_MARGIN_LEFT:\n        case LV_STYLE_MARGIN_RIGHT:\n        case LV_STYLE_BG_BLEND_MODE:\n        case LV_STYLE_BORDER_BLEND_MODE:\n        case LV_STYLE_IMAGE_BLEND_MODE:\n        case LV_STYLE_LINE_BLEND_MODE:\n        case LV_STYLE_OUTLINE_BLEND_MODE:\n        case LV_STYLE_PATTERN_BLEND_MODE:\n        case LV_STYLE_SHADOW_BLEND_MODE:\n        case LV_STYLE_TEXT_BLEND_MODE:\n        case LV_STYLE_VALUE_BLEND_MODE:\n            return true;\n            break;\n        default:\n            return false;\n    }\n}\n\n/**\n * Update the cache of style list\n * @param obj pointer to an object\n * @param part the part of the object\n * @param prop the property which triggered the update\n */\nstatic void update_style_cache(lv_obj_t * obj, uint8_t part, uint16_t prop)\n{\n    if(style_prop_is_cacheble(prop) == false) return;\n\n    lv_style_list_t * list = lv_obj_get_style_list(obj, part);\n\n    bool ignore_cache_ori = list->ignore_cache;\n    list->ignore_cache = 1;\n\n#if LV_USE_OPA_SCALE\n    list->opa_scale_cover    = lv_obj_get_style_opa_scale(obj, part) == LV_OPA_COVER ? 1 : 0;\n#else\n    list->opa_scale_cover    = 1;\n#endif\n    list->text_decor_none    = lv_obj_get_style_text_decor(obj, part) == LV_TEXT_DECOR_NONE ? 1 : 0;\n    list->text_font_normal    = lv_obj_get_style_text_font(obj, part) == LV_THEME_DEFAULT_FONT_NORMAL ? 1 : 0;\n\n    list->text_space_zero = 1;\n    if(lv_obj_get_style_text_letter_space(obj, part) != 0 ||\n       lv_obj_get_style_text_line_space(obj, part) != 0) {\n        list->text_space_zero = 0;\n    }\n\n\n    lv_opa_t bg_opa = lv_obj_get_style_bg_opa(obj, part);\n    list->bg_opa_transp    = bg_opa == LV_OPA_TRANSP ? 1 : 0;\n    list->bg_opa_cover     = bg_opa == LV_OPA_COVER ? 1 : 0;\n\n    list->border_width_zero = lv_obj_get_style_border_width(obj, part) == 0 ? 1 : 0;\n    list->border_side_full = lv_obj_get_style_border_side(obj, part) == LV_BORDER_SIDE_FULL ? 1 : 0;\n    list->border_post_off = lv_obj_get_style_border_post(obj, part) == 0 ? 1 : 0;\n    list->clip_corner_off   = lv_obj_get_style_clip_corner(obj, part) == false ? 1 : 0;\n    list->img_recolor_opa_transp    = lv_obj_get_style_image_recolor_opa(obj, part) == LV_OPA_TRANSP ? 1 : 0;\n    list->outline_width_zero    = lv_obj_get_style_outline_width(obj, part) == 0 ? 1 : 0;\n    list->pattern_img_null    = lv_obj_get_style_pattern_image(obj, part) == NULL ? 1 : 0;\n    list->radius_zero    = lv_obj_get_style_radius(obj, part) == 0 ? 1 : 0;\n    list->shadow_width_zero    = lv_obj_get_style_shadow_width(obj, part) == 0 ? 1 : 0;\n    list->value_txt_str    = lv_obj_get_style_value_str(obj, part) == NULL ? 1 : 0;\n\n\n    list->transform_all_zero  = 1;\n    if(lv_obj_get_style_transform_angle(obj, part) != 0 ||\n       lv_obj_get_style_transform_width(obj, part) != 0 ||\n       lv_obj_get_style_transform_height(obj, part) != 0 ||\n       lv_obj_get_style_transform_zoom(obj, part) != LV_IMG_ZOOM_NONE) {\n        list->transform_all_zero  = 0;\n    }\n\n    list->pad_all_zero  = 1;\n    if(lv_obj_get_style_pad_top(obj, part) != 0 ||\n       lv_obj_get_style_pad_bottom(obj, part) != 0 ||\n       lv_obj_get_style_pad_left(obj, part) != 0 ||\n       lv_obj_get_style_pad_right(obj, part) != 0) {\n        list->pad_all_zero  = 0;\n    }\n\n    list->margin_all_zero  = 1;\n    if(lv_obj_get_style_margin_top(obj, part) != 0 ||\n       lv_obj_get_style_margin_bottom(obj, part) != 0 ||\n       lv_obj_get_style_margin_left(obj, part) != 0 ||\n       lv_obj_get_style_margin_right(obj, part) != 0) {\n        list->margin_all_zero  = 0;\n    }\n\n    list->blend_mode_all_normal = 1;\n#if LV_USE_BLEND_MODES\n    if(lv_obj_get_style_bg_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||\n       lv_obj_get_style_border_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||\n       lv_obj_get_style_pattern_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||\n       lv_obj_get_style_outline_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||\n       lv_obj_get_style_value_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||\n       lv_obj_get_style_text_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||\n       lv_obj_get_style_line_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||\n       lv_obj_get_style_image_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||\n       lv_obj_get_style_shadow_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL) {\n        list->blend_mode_all_normal = 0;\n    }\n#endif\n    list->ignore_cache = ignore_cache_ori;\n    list->valid_cache = 1;\n}\n\n/**\n * Update the cache of style list\n * @param obj pointer to an object\n * @param part the part of the object\n */\nstatic void update_style_cache_children(lv_obj_t * obj)\n{\n    uint8_t part;\n    for(part = 0; part != _LV_OBJ_PART_REAL_LAST; part++) {\n        lv_style_list_t * list = lv_obj_get_style_list(obj, part);\n        if(list == NULL) break;\n\n        bool ignore_cache_ori = list->ignore_cache;\n        list->ignore_cache = 1;\n\n        list->opa_scale_cover    = lv_obj_get_style_opa_scale(obj, part) == LV_OPA_COVER ? 1 : 0;\n        list->text_decor_none    = lv_obj_get_style_text_decor(obj, part) == LV_TEXT_DECOR_NONE ? 1 : 0;\n        list->text_font_normal    = lv_obj_get_style_text_font(obj, part) == lv_theme_get_font_normal() ? 1 : 0;\n        list->img_recolor_opa_transp    = lv_obj_get_style_image_recolor_opa(obj, part) == LV_OPA_TRANSP ? 1 : 0;\n\n        list->text_space_zero = 1;\n        if(lv_obj_get_style_text_letter_space(obj, part) != 0 ||\n           lv_obj_get_style_text_line_space(obj, part) != 0) {\n            list->text_space_zero = 0;\n        }\n\n        list->ignore_cache = ignore_cache_ori;\n    }\n\n    lv_obj_t * child = lv_obj_get_child(obj, NULL);\n    while(child) {\n        update_style_cache_children(child);\n        child = lv_obj_get_child(obj, child);\n    }\n\n}\n\n/**\n * Mark the object and all of it's children's style lists as invalid.\n * The cache will be updated when a cached property asked nest time\n * @param obj pointer to an object\n */\nstatic void invalidate_style_cache(lv_obj_t * obj, uint8_t part, lv_style_property_t prop)\n{\n    if(style_prop_is_cacheble(prop) == false) return;\n\n    for(part = 0; part < _LV_OBJ_PART_REAL_FIRST; part++) {\n        lv_style_list_t * list = lv_obj_get_style_list(obj, part);\n        if(list == NULL) break;\n        list->valid_cache = 0;\n    }\n\n    for(part = _LV_OBJ_PART_REAL_FIRST; part < 0xFF; part++) {\n        lv_style_list_t * list = lv_obj_get_style_list(obj, part);\n        if(list == NULL) break;\n        list->valid_cache = 0;\n    }\n\n\n    lv_obj_t * child = lv_obj_get_child(obj, NULL);\n    while(child) {\n        update_style_cache_children(child);\n        child = lv_obj_get_child(obj, child);\n    }\n}\n\nstatic void style_snapshot(lv_obj_t * obj, uint8_t part, style_snapshot_t * shot)\n{\n    _lv_obj_disable_style_caching(obj, true);\n    _lv_memset_00(shot, sizeof(style_snapshot_t));\n    lv_draw_rect_dsc_init(&shot->rect);\n    lv_draw_label_dsc_init(&shot->label);\n    lv_draw_img_dsc_init(&shot->img);\n    lv_draw_line_dsc_init(&shot->line);\n\n    lv_style_list_t * list = lv_obj_get_style_list(obj, part);\n    bool trans_ori = list->skip_trans;\n    list->skip_trans = 1;\n\n    lv_obj_init_draw_rect_dsc(obj, part, &shot->rect);\n    lv_obj_init_draw_label_dsc(obj, part, &shot->label);\n    lv_obj_init_draw_img_dsc(obj, part, &shot->img);\n    lv_obj_init_draw_line_dsc(obj, part, &shot->line);\n\n\n    shot->pad_top = lv_obj_get_style_pad_top(obj, part);\n    shot->pad_bottom = lv_obj_get_style_pad_bottom(obj, part);\n    shot->pad_right = lv_obj_get_style_pad_right(obj, part);\n    shot->pad_left = lv_obj_get_style_pad_left(obj, part);\n    shot->pad_inner = lv_obj_get_style_pad_inner(obj, part);\n    shot->margin_top = lv_obj_get_style_margin_top(obj, part);\n    shot->margin_bottom = lv_obj_get_style_margin_bottom(obj, part);\n    shot->margin_left = lv_obj_get_style_margin_left(obj, part);\n    shot->margin_right = lv_obj_get_style_margin_right(obj, part);\n    shot->size = lv_obj_get_style_size(obj, part);\n    shot->transform_width = lv_obj_get_style_transform_width(obj, part);\n    shot->transform_height = lv_obj_get_style_transform_height(obj, part);\n    shot->transform_angle = lv_obj_get_style_transform_angle(obj, part);\n    shot->transform_zoom = lv_obj_get_style_transform_zoom(obj, part);\n    shot->scale_width = lv_obj_get_style_scale_width(obj, part);\n    shot->scale_border_width = lv_obj_get_style_scale_border_width(obj, part);\n    shot->scale_end_border_width = lv_obj_get_style_scale_end_border_width(obj, part);\n    shot->scale_end_line_width = lv_obj_get_style_scale_end_line_width(obj, part);\n    shot->scale_grad_color = lv_obj_get_style_scale_grad_color(obj, part);\n    shot->scale_end_color = lv_obj_get_style_scale_end_color(obj, part);\n    shot->opa_scale = lv_obj_get_style_opa_scale(obj, part);\n    shot->clip_corner = lv_obj_get_style_clip_corner(obj, part);\n    shot->border_post  = lv_obj_get_style_border_post(obj, part);\n\n    _lv_obj_disable_style_caching(obj, false);\n    list->skip_trans = trans_ori;\n}\n\nstatic style_snapshot_res_t style_snapshot_compare(style_snapshot_t * shot1, style_snapshot_t * shot2)\n{\n    if(memcmp(shot1, shot2, sizeof(style_snapshot_t)) == 0) return STYLE_COMPARE_SAME;\n\n\n    if(shot1->pad_top != shot2->pad_top) return STYLE_COMPARE_DIFF;\n    if(shot1->pad_bottom != shot2->pad_bottom) return STYLE_COMPARE_DIFF;\n    if(shot1->pad_left != shot2->pad_right) return STYLE_COMPARE_DIFF;\n    if(shot1->pad_right != shot2->pad_right) return STYLE_COMPARE_DIFF;\n    if(shot1->pad_top != shot2->pad_top) return STYLE_COMPARE_DIFF;\n    if(shot1->pad_inner != shot2->pad_inner) return STYLE_COMPARE_DIFF;\n    if(shot1->margin_top != shot2->margin_top) return STYLE_COMPARE_DIFF;\n    if(shot1->margin_bottom != shot2->margin_bottom) return STYLE_COMPARE_DIFF;\n    if(shot1->margin_left != shot2->margin_right) return STYLE_COMPARE_DIFF;\n    if(shot1->margin_right != shot2->margin_right) return STYLE_COMPARE_DIFF;\n    if(shot1->margin_top != shot2->margin_top) return STYLE_COMPARE_DIFF;\n    if(shot1->transform_width != shot2->transform_width) return STYLE_COMPARE_DIFF;\n    if(shot1->transform_height != shot2->transform_height) return STYLE_COMPARE_DIFF;\n    if(shot1->transform_angle != shot2->transform_angle) return STYLE_COMPARE_DIFF;\n    if(shot1->transform_zoom != shot2->transform_zoom) return STYLE_COMPARE_DIFF;\n    if(shot1->rect.outline_width != shot2->rect.outline_width) return STYLE_COMPARE_DIFF;\n    if(shot1->rect.outline_pad != shot2->rect.outline_pad) return STYLE_COMPARE_DIFF;\n    if(shot1->rect.value_font != shot2->rect.value_font) return STYLE_COMPARE_DIFF;\n    if(shot1->rect.value_align != shot2->rect.value_align) return STYLE_COMPARE_DIFF;\n    if(shot1->rect.value_font != shot2->rect.value_font) return STYLE_COMPARE_DIFF;\n    if(shot1->rect.shadow_spread != shot2->rect.shadow_spread) return STYLE_COMPARE_DIFF;\n    if(shot1->rect.shadow_width != shot2->rect.shadow_width) return STYLE_COMPARE_DIFF;\n    if(shot1->rect.shadow_ofs_x != shot2->rect.shadow_ofs_x) return STYLE_COMPARE_DIFF;\n    if(shot1->rect.shadow_ofs_y != shot2->rect.shadow_ofs_y) return STYLE_COMPARE_DIFF;\n\n    /*If not returned earlier its just a visual difference, a simple redraw is enough*/\n    return STYLE_COMPARE_VISUAL_DIFF;\n}",
        "res_region": "",
        "lookback": "",
        "lookahead": "",
        "label": [
            "ours",
            "base_underutilized"
        ],
        "start_line": 6299,
        "end_line": 6863,
        "merge_gen_region": null,
        "confidence": 0.5450648069381714,
        "hesitated": true
    }
]