[
    {
        "a_contents": "        return false;",
        "b_contents": "    }\n\n    return false;\n}\n\n/**\n * Initialize a style list\n * @param list a style list to initialize\n */\nvoid lv_style_list_init(lv_style_list_t * list)\n{\n    _lv_memset_00(list, sizeof(lv_style_list_t));\n#if LV_USE_ASSERT_STYLE\n    list->sentinel = LV_DEBUG_STYLE_LIST_SENTINEL_VALUE;\n#endif\n}\n\n/**\n * Copy a style list with all its styles and local style properties\n * @param list_dest pointer to the destination style list. (should be initialized with `lv_style_list_init()`)\n * @param list_src pointer to the source (to copy) style list.\n */\nvoid lv_style_list_copy(lv_style_list_t * list_dest, const lv_style_list_t * list_src)\n{\n    LV_ASSERT_STYLE_LIST(list_dest);\n    LV_ASSERT_STYLE_LIST(list_src);\n\n    _lv_style_list_reset(list_dest);\n\n    if(list_src->style_list == NULL) return;\n\n    /*Copy the styles but skip the transitions*/\n    if(list_src->has_local == 0) {\n        if(list_src->has_trans) {\n            list_dest->style_list = lv_mem_alloc((list_src->style_cnt - 1) * sizeof(lv_style_t *));\n            _lv_memcpy(list_dest->style_list, list_src->style_list + 1, (list_src->style_cnt - 1) * sizeof(lv_style_t *));\n            list_dest->style_cnt = list_src->style_cnt - 1;\n        }\n        else {\n            list_dest->style_list = lv_mem_alloc(list_src->style_cnt * sizeof(lv_style_t *));\n            _lv_memcpy(list_dest->style_list, list_src->style_list, list_src->style_cnt * sizeof(lv_style_t *));\n            list_dest->style_cnt = list_src->style_cnt;\n        }\n    }\n    else {\n        if(list_src->has_trans) {\n            list_dest->style_list = lv_mem_alloc((list_src->style_cnt - 2) * sizeof(lv_style_t *));\n            _lv_memcpy(list_dest->style_list, list_src->style_list + 2, (list_src->style_cnt - 2) * sizeof(lv_style_t *));\n            list_dest->style_cnt = list_src->style_cnt - 2;\n        }\n        else {\n            list_dest->style_list = lv_mem_alloc((list_src->style_cnt - 1) * sizeof(lv_style_t *));\n            _lv_memcpy(list_dest->style_list, list_src->style_list + 1, (list_src->style_cnt - 1) * sizeof(lv_style_t *));\n            list_dest->style_cnt = list_src->style_cnt - 1;\n        }\n\n        lv_style_t * local_style = get_alloc_local_style(list_dest);\n        lv_style_copy(local_style, get_alloc_local_style((lv_style_list_t *)list_src));\n    }\n}\n\n/**\n * Add a style to a style list.\n * Only the style pointer will be saved so the shouldn't be a local variable.\n * (It should be static, global or dynamically allocated)\n * @param list pointer to a style list\n * @param style pointer to a style to add\n */\nvoid _lv_style_list_add_style(lv_style_list_t * list, lv_style_t * style)\n{\n    LV_ASSERT_STYLE_LIST(list);\n    LV_ASSERT_STYLE(style);\n\n    if(list == NULL) return;\n\n    /*Remove the style first if already exists*/\n    _lv_style_list_remove_style(list, style);\n\n    lv_style_t ** new_classes;\n    if(list->style_cnt == 0) new_classes = lv_mem_alloc(sizeof(lv_style_t *));\n    else new_classes = lv_mem_realloc(list->style_list, sizeof(lv_style_t *) * (list->style_cnt + 1));\n    LV_ASSERT_MEM(new_classes);\n    if(new_classes == NULL) {\n        LV_LOG_WARN(\"lv_style_list_add_style: couldn't add the class\");\n        return;\n    }\n\n    /*Make space for the new style at the beginning. Leave local and trans style if exists*/\n    uint8_t i;\n    uint8_t first_style = 0;\n    if(list->has_trans) first_style++;\n    if(list->has_local) first_style++;\n    for(i = list->style_cnt; i > first_style; i--) {\n        new_classes[i] = new_classes[i - 1];\n    }\n\n    new_classes[first_style] = style;\n    list->style_cnt++;\n    list->style_list = new_classes;\n}\n\n/**\n * Remove a style from a style list\n * @param style_list pointer to a style list\n * @param style pointer to a style to remove\n */\nvoid _lv_style_list_remove_style(lv_style_list_t * list, lv_style_t * style)\n{\n    LV_ASSERT_STYLE_LIST(list);\n    LV_ASSERT_STYLE(style);\n\n    if(list->style_cnt == 0) return;\n\n    /*Check if the style really exists here*/\n    uint8_t i;\n    bool found = false;\n    for(i = 0; i < list->style_cnt; i++) {\n        if(list->style_list[i] == style) {\n            found = true;\n            break;\n        }\n    }\n    if(found == false) return;\n\n    if(list->style_cnt == 1) {\n        lv_mem_free(list->style_list);\n        list->style_list = NULL;\n        list->style_cnt = 0;\n        list->has_local = 0;\n        return;\n    }",
        "base_contents": "    }\n\n    return false;\n}\n\n/**\n * Initialize a style list\n * @param list a style list to initialize\n */\nvoid lv_style_list_init(lv_style_list_t * list)\n{\n    _lv_memset_00(list, sizeof(lv_style_list_t));\n#if LV_USE_ASSERT_STYLE\n    list->sentinel = LV_DEBUG_STYLE_LIST_SENTINEL_VALUE;\n#endif\n}\n\n/**\n * Copy a style list with all its styles and local style properties\n * @param list_dest pointer to the destination style list. (should be initialized with `lv_style_list_init()`)\n * @param list_src pointer to the source (to copy) style list.\n */\nvoid lv_style_list_copy(lv_style_list_t * list_dest, const lv_style_list_t * list_src)\n{\n    LV_ASSERT_STYLE_LIST(list_dest);\n    LV_ASSERT_STYLE_LIST(list_src);\n\n    _lv_style_list_reset(list_dest);\n\n    if(list_src->style_list == NULL) return;\n\n    /*Copy the styles but skip the transitions*/\n    if(list_src->has_local == 0) {\n        if(list_src->has_trans) {\n            list_dest->style_list = lv_mem_alloc((list_src->style_cnt - 1) * sizeof(lv_style_t *));\n            _lv_memcpy(list_dest->style_list, list_src->style_list + 1, (list_src->style_cnt - 1) * sizeof(lv_style_t *));\n            list_dest->style_cnt = list_src->style_cnt - 1;\n        }\n        else {\n            list_dest->style_list = lv_mem_alloc(list_src->style_cnt * sizeof(lv_style_t *));\n            _lv_memcpy(list_dest->style_list, list_src->style_list, list_src->style_cnt * sizeof(lv_style_t *));\n            list_dest->style_cnt = list_src->style_cnt;\n        }\n    }\n    else {\n        if(list_src->has_trans) {\n            list_dest->style_list = lv_mem_alloc((list_src->style_cnt - 2) * sizeof(lv_style_t *));\n            _lv_memcpy(list_dest->style_list, list_src->style_list + 2, (list_src->style_cnt - 2) * sizeof(lv_style_t *));\n            list_dest->style_cnt = list_src->style_cnt - 2;\n        }\n        else {\n            list_dest->style_list = lv_mem_alloc((list_src->style_cnt - 1) * sizeof(lv_style_t *));\n            _lv_memcpy(list_dest->style_list, list_src->style_list + 1, (list_src->style_cnt - 1) * sizeof(lv_style_t *));\n            list_dest->style_cnt = list_src->style_cnt - 1;\n        }\n\n        lv_style_t * local_style = get_alloc_local_style(list_dest);\n        lv_style_copy(local_style, get_alloc_local_style((lv_style_list_t *)list_src));\n    }\n}\n\n/**\n * Add a style to a style list.\n * Only the the style pointer will be saved so the shouldn't be a local variable.\n * (It should be static, global or dynamically allocated)\n * @param list pointer to a style list\n * @param style pointer to a style to add\n */\nvoid _lv_style_list_add_style(lv_style_list_t * list, lv_style_t * style)\n{\n    LV_ASSERT_STYLE_LIST(list);\n    LV_ASSERT_STYLE(style);\n\n    if(list == NULL) return;\n\n    /*Remove the style first if already exists*/\n    _lv_style_list_remove_style(list, style);\n\n    lv_style_t ** new_classes;\n    if(list->style_cnt == 0) new_classes = lv_mem_alloc(sizeof(lv_style_t *));\n    else new_classes = lv_mem_realloc(list->style_list, sizeof(lv_style_t *) * (list->style_cnt + 1));\n    LV_ASSERT_MEM(new_classes);\n    if(new_classes == NULL) {\n        LV_LOG_WARN(\"lv_style_list_add_style: couldn't add the class\");\n        return;\n    }\n\n    /*Make space for the new style at the beginning. Leave local and trans style if exists*/\n    uint8_t i;\n    uint8_t first_style = 0;\n    if(list->has_trans) first_style++;\n    if(list->has_local) first_style++;\n    for(i = list->style_cnt; i > first_style; i--) {\n        new_classes[i] = new_classes[i - 1];\n    }\n\n    new_classes[first_style] = style;\n    list->style_cnt++;\n    list->style_list = new_classes;\n}\n\n/**\n * Remove a style from a style list\n * @param style_list pointer to a style list\n * @param style pointer to a style to remove\n */\nvoid _lv_style_list_remove_style(lv_style_list_t * list, lv_style_t * style)\n{\n    LV_ASSERT_STYLE_LIST(list);\n    LV_ASSERT_STYLE(style);\n\n    if(list->style_cnt == 0) return;\n\n    /*Check if the style really exists here*/\n    uint8_t i;\n    bool found = false;\n    for(i = 0; i < list->style_cnt; i++) {\n        if(list->style_list[i] == style) {\n            found = true;\n            break;\n        }\n    }\n    if(found == false) return;\n\n    if(list->style_cnt == 1) {\n        lv_mem_free(list->style_list);\n        list->style_list = NULL;\n        list->style_cnt = 0;\n        list->has_local = 0;\n        return;\n    }",
        "res_region": "        return false;",
        "lookback": "",
        "lookahead": "",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 82,
        "end_line": 348,
        "merge_gen_region": null,
        "confidence": 0.559791088104248,
        "hesitated": true
    },
    {
        "a_contents": "        style->prop_cnt++;\n        size_t size = style->prop_cnt * (sizeof(lv_style_value_t) + sizeof(uint16_t));\n        uint8_t * props_and_values = lv_mem_alloc(size);\n        uint8_t * tmp = props_and_values + (style->prop_cnt) * sizeof(lv_style_value_t);\n        uint16_t * props = (uint16_t *) tmp;\n        lv_style_value_t * values = (lv_style_value_t *)props_and_values;\n        props[0] = style->prop1;\n        props[1] = prop;\n        values[0] = style->value1;\n        values[1] = value;\n\n        style->props_and_values = props_and_values;\n\n        style->allocated = 1;\n    } else if (style->prop_cnt == 0) {\n        style->prop_cnt++;\n        style->prop1 = prop;\n        style->value1 = value;\n    }\n}\n\nbool lv_style_get_prop(lv_style_t * style, lv_style_prop_t prop, lv_style_value_t * value)\n{\n    if(style->allocated) {\n        uint8_t * tmp = style->props_and_values + style->prop_cnt * sizeof(lv_style_value_t);\n        uint16_t * props = (uint16_t *) tmp;\n        uint32_t i;\n        for(i = 0; i < style->prop_cnt; i++) {\n            if(props[i] == prop) {\n                lv_style_value_t * values = (lv_style_value_t *)style->props_and_values;\n                *value = values[i];\n                return true;\n            }",
        "b_contents": "    }\n\n    /*Add new property if not exists yet*/\n    uint8_t new_prop_size = (sizeof(lv_style_property_t) + sizeof(const void *));\n    lv_style_property_t end_mark = _LV_STYLE_CLOSING_PROP;\n    uint8_t end_mark_size = sizeof(end_mark);\n\n    uint16_t size = _lv_style_get_mem_size(style);\n    if(size == 0) size += end_mark_size;\n\n    size += sizeof(lv_style_property_t) + sizeof(const void *);\n    style_resize(style, size);\n    LV_ASSERT_MEM(style->map);\n    if(style == NULL) return;\n\n    _lv_memcpy_small(style->map + size - new_prop_size - end_mark_size, &prop, sizeof(lv_style_property_t));\n    _lv_memcpy_small(style->map + size - sizeof(const void *) - end_mark_size, &p, sizeof(const void *));\n    _lv_memcpy_small(style->map + size - end_mark_size, &end_mark, sizeof(end_mark));\n}\n\n/**\n * Get the a property from a style.\n * Take into account the style state and return the property which matches the best.\n * @param style pointer to a style where to search\n * @param prop the property, might contain ORed style states too\n * @param res buffer to store the result\n * @return the weight of the found property (how well it fits to the style state).\n *         Higher number is means better fit\n *         -1 if the not found (`res` will be undefined)\n */\nint16_t _lv_style_get_int(const lv_style_t * style, lv_style_property_t prop, void * v_res)\n{\n    lv_style_int_t * res = (lv_style_int_t *)v_res;\n    LV_ASSERT_STYLE(style);\n\n    if(style == NULL) return -1;\n    if(style->map == NULL) return -1;\n\n    int32_t id = get_property_index(style, prop);\n    if(id < 0) {\n        return -1;\n    }\n    else {\n        _lv_memcpy_small(res, &style->map[id + sizeof(lv_style_property_t)], sizeof(lv_style_int_t));\n        lv_style_attr_t attr_act;\n        attr_act = get_style_prop_attr(style, id);\n\n        lv_style_attr_t attr_goal;\n        attr_goal = (prop >> 8) & 0xFF;\n\n        return LV_STYLE_ATTR_GET_STATE(attr_act) & LV_STYLE_ATTR_GET_STATE(attr_goal);\n    }\n}\n\n/**\n * Get an opacity typed property from a style.\n * @param style pointer to a style from where the property should be get\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_BORDER_OPA | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @param res pointer to a buffer to store the result value\n * @return -1: the property wasn't found in the style.\n *         The matching state bits of the desired state (in `prop`) and the best matching property's state\n *         Higher value means match in higher precedence state.\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_style_get_border_opa()`\n * @note for performance reasons it's not checked if the property really has opacity type\n */\nint16_t _lv_style_get_opa(const lv_style_t * style, lv_style_property_t prop, void * v_res)\n{\n    lv_opa_t * res = (lv_opa_t *)v_res;\n    LV_ASSERT_STYLE(style);\n\n    if(style == NULL) return -1;\n    if(style->map == NULL) return -1;\n\n    int32_t id = get_property_index(style, prop);\n    if(id < 0) {\n        return -1;\n    }\n    else {\n        _lv_memcpy_small(res, &style->map[id + sizeof(lv_style_property_t)], sizeof(lv_opa_t));\n        lv_style_attr_t attr_act;\n        attr_act = get_style_prop_attr(style, id);\n\n        lv_style_attr_t attr_goal;\n        attr_goal = (prop >> 8) & 0xFF;\n\n        return LV_STYLE_ATTR_GET_STATE(attr_act) & LV_STYLE_ATTR_GET_STATE(attr_goal);\n    }\n}\n\n/**\n * Get a color typed property from a style.\n * @param style pointer to a style from where the property should be get\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_BORDER_COLOR | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @param res pointer to a buffer to store the result value\n * @return -1: the property wasn't found in the style.\n *         The matching state bits of the desired state (in `prop`) and the best matching property's state\n *         Higher value means match in higher precedence state.\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_style_get_border_color()`\n * @note for performance reasons it's not checked if the property really has color type\n */\nint16_t _lv_style_get_color(const lv_style_t * style, lv_style_property_t prop, void * v_res)\n{\n    lv_color_t * res = (lv_color_t *)v_res;\n    if(style == NULL) return -1;\n    if(style->map == NULL) return -1;\n    int32_t id = get_property_index(style, prop);\n    if(id < 0) {\n        return -1;\n    }\n    else {\n        _lv_memcpy_small(res, &style->map[id + sizeof(lv_style_property_t)], sizeof(lv_color_t));\n        lv_style_attr_t attr_act;\n        attr_act = get_style_prop_attr(style, id);\n\n        lv_style_attr_t attr_goal;\n        attr_goal = (prop >> 8) & 0xFF;\n\n        return LV_STYLE_ATTR_GET_STATE(attr_act) & LV_STYLE_ATTR_GET_STATE(attr_goal);\n    }\n}\n\n/**\n * Get a pointer typed property from a style.\n * @param style pointer to a style from where the property should be get\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_TEXT_FONT | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @param res pointer to a buffer to store the result value\n * @return -1: the property wasn't found in the style.\n *         The matching state bits of the desired state (in `prop`) and the best matching property's state\n *         Higher value means match in higher precedence state.\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_style_get_text_font()`\n * @note for performance reasons it's not checked if the property really has pointer type\n */\nint16_t _lv_style_get_ptr(const lv_style_t * style, lv_style_property_t prop, void * v_res)\n{\n    const void ** res = (const void **)v_res;\n    if(style == NULL) return -1;\n    if(style->map == NULL) return -1;\n\n    int32_t id = get_property_index(style, prop);\n    if(id < 0) {\n        return -1;\n    }\n    else {\n        _lv_memcpy_small(res, &style->map[id + sizeof(lv_style_property_t)], sizeof(const void *));\n        lv_style_attr_t attr_act;\n        attr_act = get_style_prop_attr(style, id);\n\n        lv_style_attr_t attr_goal;\n        attr_goal = (prop >> 8) & 0xFF;\n\n        return LV_STYLE_ATTR_GET_STATE(attr_act) & LV_STYLE_ATTR_GET_STATE(attr_goal);\n    }\n}\n\n/**\n * Get the local style of a style list\n * @param list pointer to a style list where the local property should be set\n * @return pointer to the local style if exists else `NULL`.\n */\nlv_style_t * lv_style_list_get_local_style(lv_style_list_t * list)\n{\n    LV_ASSERT_STYLE_LIST(list);\n\n    if(!list->has_local) return NULL;\n    if(list->has_trans) return list->style_list[1];\n    else return list->style_list[0];\n}\n\n/**\n * Get the transition style of a style list\n * @param list pointer to a style list where the local property should be set\n * @return pointer to the transition style if exists else `NULL`.\n */\nlv_style_t * _lv_style_list_get_transition_style(lv_style_list_t * list)\n{\n    LV_ASSERT_STYLE_LIST(list);\n\n    if(!list->has_trans) return NULL;\n    return list->style_list[0];\n}\n\n/**\n * Allocate the transition style in a style list. If already exists simply return it.\n * @param list pointer to a style list\n * @return the transition style of a style list\n */\nlv_style_t * _lv_style_list_add_trans_style(lv_style_list_t * list)\n{\n    LV_ASSERT_STYLE_LIST(list);\n    if(list->has_trans) return _lv_style_list_get_transition_style(list);\n\n    lv_style_t * trans_style = lv_mem_alloc(sizeof(lv_style_t));\n    LV_ASSERT_MEM(trans_style);\n    if(trans_style == NULL) {\n        LV_LOG_WARN(\"lv_style_list_add_trans_style: couldn't create transition style\");\n        return NULL;\n    }\n\n    lv_style_init(trans_style);\n\n    _lv_style_list_add_style(list, trans_style);\n    list->has_trans = 1;\n\n    /*If the list has local style trans was added after it. But trans should be the first so swap them*/\n    if(list->has_local) {\n        lv_style_t * tmp = list->style_list[0];\n        list->style_list[0] = list->style_list[1];\n        list->style_list[1] = tmp;\n    }\n    return trans_style;\n}\n\n/**\n * Set a local integer typed property in a style list.\n * @param list pointer to a style list where the local property should be set\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_BORDER_WIDTH | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @param value the value to set\n * @note for performance reasons it's not checked if the property really has integer type\n */\nvoid _lv_style_list_set_local_int(lv_style_list_t * list, lv_style_property_t prop, lv_style_int_t value)\n{\n    LV_ASSERT_STYLE_LIST(list);\n\n    lv_style_t * local = get_alloc_local_style(list);\n    _lv_style_set_int(local, prop, value);\n}\n\n/**\n * Set a local opacity typed property in a style list.\n * @param list pointer to a style list where the local property should be set\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_BORDER_OPA | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @param value the value to set\n * @note for performance reasons it's not checked if the property really has opacity type\n */\nvoid _lv_style_list_set_local_opa(lv_style_list_t * list, lv_style_property_t prop, lv_opa_t value)\n{\n    LV_ASSERT_STYLE_LIST(list);\n\n    lv_style_t * local = get_alloc_local_style(list);\n    _lv_style_set_opa(local, prop, value);\n}\n\n/**\n * Set a local color typed property in a style list.\n * @param list pointer to a style list where the local property should be set\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_BORDER_COLOR | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @param value the value to set\n * @note for performance reasons it's not checked if the property really has color type\n */\nvoid _lv_style_list_set_local_color(lv_style_list_t * list, lv_style_property_t prop, lv_color_t value)\n{\n    LV_ASSERT_STYLE_LIST(list);\n\n    lv_style_t * local = get_alloc_local_style(list);\n    _lv_style_set_color(local, prop, value);\n}\n\n/**\n * Set a local pointer typed property in a style list.\n * @param list pointer to a style list where the local property should be set\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_TEXT_FONT | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @param value the value to set\n * @note for performance reasons it's not checked if the property really has pointer type\n */\nvoid _lv_style_list_set_local_ptr(lv_style_list_t * list, lv_style_property_t prop, const void * value)\n{\n    LV_ASSERT_STYLE_LIST(list);\n\n    lv_style_t * local = get_alloc_local_style(list);\n    _lv_style_set_ptr(local, prop, value);\n}\n\n/**\n * Get an integer typed property from a style list.\n * It will return the property which match best with given state.\n * @param list pointer to a style list from where the property should be get\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_BORDER_WIDTH | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @param res pointer to a buffer to store the result\n * @return LV_RES_OK: there was a matching property in the list\n *         LV_RES_INV: there was NO matching property in the list\n * @note for performance reasons it's not checked if the property really has integer type\n */\nlv_res_t _lv_style_list_get_int(lv_style_list_t * list, lv_style_property_t prop, lv_style_int_t * res)\n{\n    LV_ASSERT_STYLE_LIST(list);\n\n    if(list == NULL) return LV_RES_INV;\n    if(list->style_list == NULL) return LV_RES_INV;\n\n    lv_style_attr_t attr;\n    attr = prop >> 8;\n    int16_t weight_goal = attr;\n\n    int16_t weight = -1;\n\n    lv_style_int_t value_act = 0;\n\n    int16_t ci;\n    for(ci = 0; ci < list->style_cnt; ci++) {\n        /* changed class to _class to allow compilation as c++ */\n        lv_style_t * _class = lv_style_list_get_style(list, ci);\n        int16_t weight_act = _lv_style_get_int(_class, prop, &value_act);\n\n        /*On perfect match return the value immediately*/\n        if(weight_act == weight_goal) {\n            *res = value_act;\n            return LV_RES_OK;\n        }\n        else if(list->has_trans && weight_act >= 0 && ci == 0 && !list->skip_trans) {\n            *res = value_act;\n            return LV_RES_OK;",
        "base_contents": "    }\n\n    /*Add new property if not exists yet*/\n    uint8_t new_prop_size = (sizeof(lv_style_property_t) + sizeof(const void *));\n    lv_style_property_t end_mark = _LV_STYLE_CLOSING_PROP;\n    uint8_t end_mark_size = sizeof(end_mark);\n\n    uint16_t size = _lv_style_get_mem_size(style);\n    if(size == 0) size += end_mark_size;\n\n    size += sizeof(lv_style_property_t) + sizeof(const void *);\n    style_resize(style, size);\n    LV_ASSERT_MEM(style->map);\n    if(style == NULL) return;\n\n    _lv_memcpy_small(style->map + size - new_prop_size - end_mark_size, &prop, sizeof(lv_style_property_t));\n    _lv_memcpy_small(style->map + size - sizeof(const void *) - end_mark_size, &p, sizeof(const void *));\n    _lv_memcpy_small(style->map + size - end_mark_size, &end_mark, sizeof(end_mark));\n}\n\n/**\n * Get the a property from a style.\n * Take into account the style state and return the property which matches the best.\n * @param style pointer to a style where to search\n * @param prop the property, might contain ORed style states too\n * @param res buffer to store the result\n * @return the weight of the found property (how well it fits to the style state).\n *         Higher number is means better fit\n *         -1 if the not found (`res` will be undefined)\n */\nint16_t _lv_style_get_int(const lv_style_t * style, lv_style_property_t prop, void * v_res)\n{\n    lv_style_int_t * res = (lv_style_int_t *)v_res;\n    LV_ASSERT_STYLE(style);\n\n    if(style == NULL) return -1;\n    if(style->map == NULL) return -1;\n\n    int32_t id = get_property_index(style, prop);\n    if(id < 0) {\n        return -1;\n    }\n    else {\n        _lv_memcpy_small(res, &style->map[id + sizeof(lv_style_property_t)], sizeof(lv_style_int_t));\n        lv_style_attr_t attr_act;\n        attr_act = get_style_prop_attr(style, id);\n\n        lv_style_attr_t attr_goal;\n        attr_goal = (prop >> 8) & 0xFF;\n\n        return LV_STYLE_ATTR_GET_STATE(attr_act) & LV_STYLE_ATTR_GET_STATE(attr_goal);\n    }\n}\n\n/**\n * Get an opacity typed property from a style.\n * @param style pointer to a style from where the property should be get\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_BORDER_OPA | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @param res pointer to a buffer to store the result value\n * @return -1: the property wasn't found in the style.\n *         The matching state bits of the desired state (in `prop`) and the best matching property's state\n *         Higher value means match in higher precedence state.\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_style_get_border_opa()`\n * @note for performance reasons it's not checked if the property really has opacity type\n */\nint16_t _lv_style_get_opa(const lv_style_t * style, lv_style_property_t prop, void * v_res)\n{\n    lv_opa_t * res = (lv_opa_t *)v_res;\n    LV_ASSERT_STYLE(style);\n\n    if(style == NULL) return -1;\n    if(style->map == NULL) return -1;\n\n    int32_t id = get_property_index(style, prop);\n    if(id < 0) {\n        return -1;\n    }\n    else {\n        _lv_memcpy_small(res, &style->map[id + sizeof(lv_style_property_t)], sizeof(lv_opa_t));\n        lv_style_attr_t attr_act;\n        attr_act = get_style_prop_attr(style, id);\n\n        lv_style_attr_t attr_goal;\n        attr_goal = (prop >> 8) & 0xFF;\n\n        return LV_STYLE_ATTR_GET_STATE(attr_act) & LV_STYLE_ATTR_GET_STATE(attr_goal);\n    }\n}\n\n/**\n * Get a color typed property from a style.\n * @param style pointer to a style from where the property should be get\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_BORDER_COLOR | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @param res pointer to a buffer to store the result value\n * @return -1: the property wasn't found in the style.\n *         The matching state bits of the desired state (in `prop`) and the best matching property's state\n *         Higher value means match in higher precedence state.\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_style_get_border_color()`\n * @note for performance reasons it's not checked if the property really has color type\n */\nint16_t _lv_style_get_color(const lv_style_t * style, lv_style_property_t prop, void * v_res)\n{\n    lv_color_t * res = (lv_color_t *)v_res;\n    if(style == NULL) return -1;\n    if(style->map == NULL) return -1;\n    int32_t id = get_property_index(style, prop);\n    if(id < 0) {\n        return -1;\n    }\n    else {\n        _lv_memcpy_small(res, &style->map[id + sizeof(lv_style_property_t)], sizeof(lv_color_t));\n        lv_style_attr_t attr_act;\n        attr_act = get_style_prop_attr(style, id);\n\n        lv_style_attr_t attr_goal;\n        attr_goal = (prop >> 8) & 0xFF;\n\n        return LV_STYLE_ATTR_GET_STATE(attr_act) & LV_STYLE_ATTR_GET_STATE(attr_goal);\n    }\n}\n\n/**\n * Get a pointer typed property from a style.\n * @param style pointer to a style from where the property should be get\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_TEXT_FONT | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @param res pointer to a buffer to store the result value\n * @return -1: the property wasn't found in the style.\n *         The matching state bits of the desired state (in `prop`) and the best matching property's state\n *         Higher value means match in higher precedence state.\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_style_get_text_font()`\n * @note for performance reasons it's not checked if the property really has pointer type\n */\nint16_t _lv_style_get_ptr(const lv_style_t * style, lv_style_property_t prop, void * v_res)\n{\n    const void ** res = (const void **)v_res;\n    if(style == NULL) return -1;\n    if(style->map == NULL) return -1;\n\n    int32_t id = get_property_index(style, prop);\n    if(id < 0) {\n        return -1;\n    }\n    else {\n        _lv_memcpy_small(res, &style->map[id + sizeof(lv_style_property_t)], sizeof(const void *));\n        lv_style_attr_t attr_act;\n        attr_act = get_style_prop_attr(style, id);\n\n        lv_style_attr_t attr_goal;\n        attr_goal = (prop >> 8) & 0xFF;\n\n        return LV_STYLE_ATTR_GET_STATE(attr_act) & LV_STYLE_ATTR_GET_STATE(attr_goal);\n    }\n}\n\n/**\n * Get the local style of a style list\n * @param list pointer to a style list where the local property should be set\n * @return pointer to the local style if exists else `NULL`.\n */\nlv_style_t * lv_style_list_get_local_style(lv_style_list_t * list)\n{\n    LV_ASSERT_STYLE_LIST(list);\n\n    if(!list->has_local) return NULL;\n    if(list->has_trans) return list->style_list[1];\n    else return list->style_list[0];\n}\n\n/**\n * Get the transition style of a style list\n * @param list pointer to a style list where the local property should be set\n * @return pointer to the transition style if exists else `NULL`.\n */\nlv_style_t * _lv_style_list_get_transition_style(lv_style_list_t * list)\n{\n    LV_ASSERT_STYLE_LIST(list);\n\n    if(!list->has_trans) return NULL;\n    return list->style_list[0];\n}\n\n/**\n * Allocate the transition style in a style list. If already exists simply return it.\n * @param list pointer to a style list\n * @return the transition style of a style list\n */\nlv_style_t * _lv_style_list_add_trans_style(lv_style_list_t * list)\n{\n    LV_ASSERT_STYLE_LIST(list);\n    if(list->has_trans) return _lv_style_list_get_transition_style(list);\n\n    lv_style_t * trans_style = lv_mem_alloc(sizeof(lv_style_t));\n    LV_ASSERT_MEM(trans_style);\n    if(trans_style == NULL) {\n        LV_LOG_WARN(\"lv_style_list_add_trans_style: couldn't create transition style\");\n        return NULL;\n    }\n\n    lv_style_init(trans_style);\n\n    _lv_style_list_add_style(list, trans_style);\n    list->has_trans = 1;\n\n    /*If the list has local style trans was added after it. But trans should be the first so swap them*/\n    if(list->has_local) {\n        lv_style_t * tmp = list->style_list[0];\n        list->style_list[0] = list->style_list[1];\n        list->style_list[1] = tmp;\n    }\n    return trans_style;\n}\n\n\n/**\n * Set a local integer typed property in a style list.\n * @param list pointer to a style list where the local property should be set\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_BORDER_WIDTH | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @param value the value to set\n * @note for performance reasons it's not checked if the property really has integer type\n */\nvoid _lv_style_list_set_local_int(lv_style_list_t * list, lv_style_property_t prop, lv_style_int_t value)\n{\n    LV_ASSERT_STYLE_LIST(list);\n\n    lv_style_t * local = get_alloc_local_style(list);\n    _lv_style_set_int(local, prop, value);\n}\n\n/**\n * Set a local opacity typed property in a style list.\n * @param list pointer to a style list where the local property should be set\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_BORDER_OPA | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @param value the value to set\n * @note for performance reasons it's not checked if the property really has opacity type\n */\nvoid _lv_style_list_set_local_opa(lv_style_list_t * list, lv_style_property_t prop, lv_opa_t value)\n{\n    LV_ASSERT_STYLE_LIST(list);\n\n    lv_style_t * local = get_alloc_local_style(list);\n    _lv_style_set_opa(local, prop, value);\n}\n\n/**\n * Set a local color typed property in a style list.\n * @param list pointer to a style list where the local property should be set\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_BORDER_COLOR | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @param value the value to set\n * @note for performance reasons it's not checked if the property really has color type\n */\nvoid _lv_style_list_set_local_color(lv_style_list_t * list, lv_style_property_t prop, lv_color_t value)\n{\n    LV_ASSERT_STYLE_LIST(list);\n\n    lv_style_t * local = get_alloc_local_style(list);\n    _lv_style_set_color(local, prop, value);\n}\n\n/**\n * Set a local pointer typed property in a style list.\n * @param list pointer to a style list where the local property should be set\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_TEXT_FONT | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @param value the value to set\n * @note for performance reasons it's not checked if the property really has pointer type\n */\nvoid _lv_style_list_set_local_ptr(lv_style_list_t * list, lv_style_property_t prop, const void * value)\n{\n    LV_ASSERT_STYLE_LIST(list);\n\n    lv_style_t * local = get_alloc_local_style(list);\n    _lv_style_set_ptr(local, prop, value);\n}\n\n\n\n/**\n * Get an integer typed property from a style list.\n * It will return the property which match best with given state.\n * @param list pointer to a style list from where the property should be get\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_BORDER_WIDTH | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @param res pointer to a buffer to store the result\n * @return LV_RES_OK: there was a matching property in the list\n *         LV_RES_INV: there was NO matching property in the list\n * @note for performance reasons it's not checked if the property really has integer type\n */\nlv_res_t _lv_style_list_get_int(lv_style_list_t * list, lv_style_property_t prop, lv_style_int_t * res)\n{\n    LV_ASSERT_STYLE_LIST(list);\n\n    if(list == NULL) return LV_RES_INV;\n    if(list->style_list == NULL) return LV_RES_INV;\n\n    lv_style_attr_t attr;\n    attr = prop >> 8;\n    int16_t weight_goal = attr;\n\n    int16_t weight = -1;\n\n    lv_style_int_t value_act = 0;\n\n    int16_t ci;\n    for(ci = 0; ci < list->style_cnt; ci++) {\n        /* changed class to _class to allow compilation as c++ */\n        lv_style_t * _class = lv_style_list_get_style(list, ci);\n        int16_t weight_act = _lv_style_get_int(_class, prop, &value_act);\n\n        /*On perfect match return the value immediately*/\n        if(weight_act == weight_goal) {\n            *res = value_act;\n            return LV_RES_OK;\n        }\n        else if(list->has_trans && weight_act >= 0 && ci == 0 && !list->skip_trans) {\n            *res = value_act;\n            return LV_RES_OK;",
        "res_region": "        style->prop_cnt++;\n        size_t size = style->prop_cnt * (sizeof(lv_style_value_t) + sizeof(uint16_t));\n        uint8_t * props_and_values = lv_mem_alloc(size);\n        uint8_t * tmp = props_and_values + (style->prop_cnt) * sizeof(lv_style_value_t);\n        uint16_t * props = (uint16_t *) tmp;\n        lv_style_value_t * values = (lv_style_value_t *)props_and_values;\n        props[0] = style->prop1;\n        props[1] = prop;\n        values[0] = style->value1;\n        values[1] = value;\n\n        style->props_and_values = props_and_values;\n\n        style->allocated = 1;\n    } else if (style->prop_cnt == 0) {\n        style->prop_cnt++;\n        style->prop1 = prop;\n        style->value1 = value;\n    }\n}\n\nbool lv_style_get_prop(lv_style_t * style, lv_style_prop_t prop, lv_style_value_t * value)\n{\n    if(style->allocated) {\n        uint8_t * tmp = style->props_and_values + style->prop_cnt * sizeof(lv_style_value_t);\n        uint16_t * props = (uint16_t *) tmp;\n        uint32_t i;\n        for(i = 0; i < style->prop_cnt; i++) {\n            if(props[i] == prop) {\n                lv_style_value_t * values = (lv_style_value_t *)style->props_and_values;\n                *value = values[i];\n                return true;\n            }",
        "lookback": "        size_t size = style->prop_cnt * (sizeof(lv_style_value_t) + sizeof(uint16_t));",
        "lookahead": "        }",
        "label": [
            "ours",
            "base_underutilized"
        ],
        "start_line": 434,
        "end_line": 1117,
        "merge_gen_region": "__ size stylepropcnt ((_____) sizeofuint_));->_++; sizet =->___ sizeofuint_));8t propsandvalues lvmemallocsize uint_ * =___();8t tmp propsandvalues (->_) sizeoflvstylevaluet uint_ * = %__ *);__ *;__; voidstylepropcnt 0 { stylepropcnt styleprop =1 prop stylevalue =; void;__ *; void___(__ *,_,_ *,_); void__ * *,_); void__ * *,_); void__ * *,_); void__ * *,_); void__ * *,_); void_ * *,_); void_ * *,_); void_ * *,_); void__ *); void__ * *,_); void_ *); void__ * *,_); void__ *,_); void__ * *); void stylepropcnt sizeofuint_ *); uint_ i;(.] prop {___ * =; <->_; < capture; < capture;;",
        "confidence": 0.9072725176811218,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "/**********************\n *   STATIC FUNCTIONS\n **********************/",
        "b_contents": "/**\n * Get style property id in index.\n * @param style pointer to style.\n * @param idx index of the style in style->map\n * @return id of property in style->map + idx\n */\nstatic inline uint8_t get_style_prop_id(const lv_style_t * style, size_t idx)\n{\n    return get_style_prop(style, idx) & 0xFF;\n}\n\n/**\n * Get style property attributes for index.\n * @param style pointer to style.\n * @param idx index of the style in style->map\n * @return attribute of property in style->map + idx\n */\nstatic inline uint8_t get_style_prop_attr(const lv_style_t * style, size_t idx)\n{\n    return ((get_style_prop(style, idx) >> 8) & 0xFFU);\n}\n\n/**\n * Get property size.\n * @param prop_id property id.\n * @param idx index of the style in style->map\n * @return attribute of property in style->map + idx\n */\nstatic inline size_t get_prop_size(uint8_t prop_id)\n{\n    prop_id &= 0xF;\n    size_t size = sizeof(lv_style_property_t);\n    if(prop_id < LV_STYLE_ID_COLOR) size += sizeof(lv_style_int_t);\n    else if(prop_id < LV_STYLE_ID_OPA) size += sizeof(lv_color_t);\n    else if(prop_id < LV_STYLE_ID_PTR) size += sizeof(lv_opa_t);\n    else size += sizeof(const void *);\n    return size;\n}\n\n/**\n * Get next property index, given current property and index.\n * @param prop_id property id.\n * @param idx index of the style in style->map\n * @return index of next property in style->map\n */\nstatic inline size_t get_next_prop_index(uint8_t prop_id, size_t idx)\n{\n    return idx + get_prop_size(prop_id);\n}",
        "base_contents": "/**\n * Get style property id in index.\n * @param style pointer to style.\n * @param idx index of the style in style->map\n * @return id of property in style->map + idx\n */\nstatic inline uint8_t get_style_prop_id(const lv_style_t * style, size_t idx)\n{\n    return get_style_prop(style, idx) & 0xFF;\n}\n\n/**\n * Get style property attributes for index.\n * @param style pointer to style.\n * @param idx index of the style in style->map\n * @return attribute of property in style->map + idx\n */\nstatic inline uint8_t get_style_prop_attr(const lv_style_t * style, size_t idx)\n{\n    return ((get_style_prop(style, idx) >> 8) & 0xFFU);\n}\n\n\n/**\n * Get property size.\n * @param prop_id property id.\n * @param idx index of the style in style->map\n * @return attribute of property in style->map + idx\n */\nstatic inline size_t get_prop_size(uint8_t prop_id)\n{\n    prop_id &= 0xF;\n    size_t size = sizeof(lv_style_property_t);\n    if(prop_id < LV_STYLE_ID_COLOR) size += sizeof(lv_style_int_t);\n    else if(prop_id < LV_STYLE_ID_OPA) size += sizeof(lv_color_t);\n    else if(prop_id < LV_STYLE_ID_PTR) size += sizeof(lv_opa_t);\n    else size += sizeof(const void *);\n    return size;\n}\n\n/**\n * Get next property index, given current property and index.\n * @param prop_id property id.\n * @param idx index of the style in style->map\n * @return index of next property in style->map\n */\nstatic inline size_t get_next_prop_index(uint8_t prop_id, size_t idx)\n{\n    return idx + get_prop_size(prop_id);\n}",
        "res_region": "/**********************\n *   STATIC FUNCTIONS\n **********************/",
        "lookback": " *   STATIC FUNCTIONS",
        "lookahead": "",
        "label": [
            "ours",
            "base_underutilized"
        ],
        "start_line": 1213,
        "end_line": 1318,
        "merge_gen_region": null,
        "confidence": 0.8393275737762451,
        "hesitated": true
    }
]