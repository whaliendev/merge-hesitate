[
    {
        "a_contents": "",
        "b_contents": "/** Design modes */\nenum {\n    LV_DESIGN_DRAW_MAIN, /**< Draw the main portion of the object */\n    LV_DESIGN_DRAW_POST, /**< Draw extras on the object */\n    LV_DESIGN_COVER_CHK, /**< Check if the object fully covers the 'mask_p' area */\n};\ntypedef uint8_t lv_design_mode_t;\n\n/** Design results */\nenum {\n    LV_DESIGN_RES_OK,          /**< Draw ready */\n    LV_DESIGN_RES_COVER,       /**< Returned on `LV_DESIGN_COVER_CHK` if the areas is fully covered*/\n    LV_DESIGN_RES_NOT_COVER,   /**< Returned on `LV_DESIGN_COVER_CHK` if the areas is not covered*/\n    LV_DESIGN_RES_MASKED,      /**< Returned on `LV_DESIGN_COVER_CHK` if the areas is masked out (children also not cover)*/\n};\ntypedef uint8_t lv_design_res_t;\n\n/**\n * The design callback is used to draw the object on the screen.\n * It accepts the object, a mask area, and the mode in which to draw the object.\n */\ntypedef lv_design_res_t (*lv_design_cb_t)(struct _lv_obj_t * obj, const lv_area_t * clip_area, lv_design_mode_t mode);\n",
        "base_contents": "\n/** Design modes */\nenum {\n    LV_DESIGN_DRAW_MAIN, /**< Draw the main portion of the object */\n    LV_DESIGN_DRAW_POST, /**< Draw extras on the object */\n    LV_DESIGN_COVER_CHK, /**< Check if the object fully covers the 'mask_p' area */\n};\ntypedef uint8_t lv_design_mode_t;\n\n\n/** Design results */\nenum {\n    LV_DESIGN_RES_OK,          /**< Draw ready */\n    LV_DESIGN_RES_COVER,       /**< Returned on `LV_DESIGN_COVER_CHK` if the areas is fully covered*/\n    LV_DESIGN_RES_NOT_COVER,   /**< Returned on `LV_DESIGN_COVER_CHK` if the areas is not covered*/\n    LV_DESIGN_RES_MASKED,      /**< Returned on `LV_DESIGN_COVER_CHK` if the areas is masked out (children also not cover)*/\n};\ntypedef uint8_t lv_design_res_t;\n\n/**\n * The design callback is used to draw the object on the screen.\n * It accepts the object, a mask area, and the mode in which to draw the object.\n */\ntypedef lv_design_res_t (*lv_design_cb_t)(struct _lv_obj_t * obj, const lv_area_t * clip_area, lv_design_mode_t mode);\n",
        "res_region": "",
        "lookback": "enum {",
        "lookahead": "enum {",
        "label": [
            "ours",
            "base_underutilized"
        ],
        "start_line": 59,
        "end_line": 111,
        "merge_gen_region": "",
        "confidence": 0.9631249308586121,
        "hesitated": false,
        "resolved": true
    },
    {
        "a_contents": "    lv_point_t scroll; /**< The current X/Y scroll offset*/\n    lv_coord_t ext_draw_pad; /**< EXTend the size in every direction for drawing. */",
        "b_contents": "    void * ext_attr;            /**< Object type specific extended data*/\n    lv_style_list_t style_list;",
        "base_contents": "    void * ext_attr;            /**< Object type specific extended data*/\n    lv_style_list_t  style_list;",
        "res_region": "    lv_point_t scroll; /**< The current X/Y scroll offset*/\n    lv_coord_t ext_draw_pad; /**< EXTend the size in every direction for drawing. */",
        "lookback": "    lv_coord_t ext_draw_pad; /**< EXTend the size in every direction for drawing. */",
        "lookahead": "",
        "label": [
            "ours",
            "base_underutilized"
        ],
        "start_line": 257,
        "end_line": 266,
        "merge_gen_region": null,
        "confidence": 0.6907831430435181,
        "hesitated": true
    },
    {
        "a_contents": "",
        "b_contents": " * Set relative the position of an object (relative to the parent)\n * @param obj pointer to an object\n * @param x new distance from the left side of the parent\n * @param y new distance from the top of the parent\n */\nvoid lv_obj_set_pos(lv_obj_t * obj, lv_coord_t x, lv_coord_t y);\n\n/**\n * Set the x coordinate of a object\n * @param obj pointer to an object\n * @param x new distance from the left side from the parent\n */\nvoid lv_obj_set_x(lv_obj_t * obj, lv_coord_t x);\n\n/**\n * Set the y coordinate of a object\n * @param obj pointer to an object\n * @param y new distance from the top of the parent\n */\nvoid lv_obj_set_y(lv_obj_t * obj, lv_coord_t y);\n\n/**\n * Set the size of an object\n * @param obj pointer to an object\n * @param w new width\n * @param h new height\n */\nvoid lv_obj_set_size(lv_obj_t * obj, lv_coord_t w, lv_coord_t h);\n\n/**\n * Set the width of an object\n * @param obj pointer to an object\n * @param w new width\n */\nvoid lv_obj_set_width(lv_obj_t * obj, lv_coord_t w);\n\n/**\n * Set the height of an object\n * @param obj pointer to an object\n * @param h new height\n */\nvoid lv_obj_set_height(lv_obj_t * obj, lv_coord_t h);\n\n/**\n * Set the width reduced by the left and right padding.\n * @param obj pointer to an object\n * @param w the width without paddings\n */\nvoid lv_obj_set_width_fit(lv_obj_t * obj, lv_coord_t w);\n\n/**\n * Set the height reduced by the top and bottom padding.\n * @param obj pointer to an object\n * @param h the height without paddings\n */\nvoid lv_obj_set_height_fit(lv_obj_t * obj, lv_coord_t h);\n\n/**\n * Set the width of an object by taking the left and right margin into account.\n * The object width will be `obj_w = w - margin_left - margin_right`\n * @param obj pointer to an object\n * @param w new height including margins\n */\nvoid lv_obj_set_width_margin(lv_obj_t * obj, lv_coord_t w);\n\n/**\n * Set the height of an object by taking the top and bottom margin into account.\n * The object height will be `obj_h = h - margin_top - margin_bottom`\n * @param obj pointer to an object\n * @param h new height including margins\n */\nvoid lv_obj_set_height_margin(lv_obj_t * obj, lv_coord_t h);\n\n/**\n * Align an object to an other object.\n * @param obj pointer to an object to align\n * @param base pointer to an object (if NULL the parent is used). 'obj' will be aligned to it.\n * @param align type of alignment (see 'lv_align_t' enum)\n * @param x_ofs x coordinate offset after alignment\n * @param y_ofs y coordinate offset after alignment\n */\nvoid lv_obj_align(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t x_ofs, lv_coord_t y_ofs);\n\n/**\n * Align an object to an other object horizontally.\n * @param obj pointer to an object to align\n * @param base pointer to an object (if NULL the parent is used). 'obj' will be aligned to it.\n * @param align type of alignment (see 'lv_align_t' enum)\n * @param x_ofs x coordinate offset after alignment\n */\nvoid lv_obj_align_x(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t x_ofs);\n\n/**\n * Align an object to an other object vertically.\n * @param obj pointer to an object to align\n * @param base pointer to an object (if NULL the parent is used). 'obj' will be aligned to it.\n * @param align type of alignment (see 'lv_align_t' enum)\n * @param y_ofs y coordinate offset after alignment\n */\nvoid lv_obj_align_y(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t y_ofs);\n\n/**\n * Align an object to an other object.\n * @param obj pointer to an object to align\n * @param base pointer to an object (if NULL the parent is used). 'obj' will be aligned to it.\n * @param align type of alignment (see 'lv_align_t' enum)\n * @param x_ofs x coordinate offset after alignment\n * @param y_ofs y coordinate offset after alignment\n */\nvoid lv_obj_align_mid(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t x_ofs, lv_coord_t y_ofs);\n\n/**\n * Align an object's middle point to an other object horizontally.\n * @param obj pointer to an object to align\n * @param base pointer to an object (if NULL the parent is used). 'obj' will be aligned to it.\n * @param align type of alignment (see 'lv_align_t' enum)\n * @param x_ofs x coordinate offset after alignment\n */\nvoid lv_obj_align_mid_x(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t x_ofs);\n\n/**\n * Align an object's middle point to an other object vertically.\n * @param obj pointer to an object to align\n * @param base pointer to an object (if NULL the parent is used). 'obj' will be aligned to it.\n * @param align type of alignment (see 'lv_align_t' enum)\n * @param y_ofs y coordinate offset after alignment\n */\nvoid lv_obj_align_mid_y(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t y_ofs);\n\n/**\n * Realign the object based on the last `lv_obj_align` parameters.\n * @param obj pointer to an object\n */\nvoid lv_obj_realign(lv_obj_t * obj);\n\n/**\n * Enable the automatic realign of the object when its size has changed based on the last\n * `lv_obj_align` parameters.\n * @param obj pointer to an object\n * @param en true: enable auto realign; false: disable auto realign\n */\nvoid lv_obj_set_auto_realign(lv_obj_t * obj, bool en);\n\n/**",
        "base_contents": " * Set relative the position of an object (relative to the parent)\n * @param obj pointer to an object\n * @param x new distance from the left side of the parent\n * @param y new distance from the top of the parent\n */\nvoid lv_obj_set_pos(lv_obj_t * obj, lv_coord_t x, lv_coord_t y);\n\n/**\n * Set the x coordinate of a object\n * @param obj pointer to an object\n * @param x new distance from the left side from the parent\n */\nvoid lv_obj_set_x(lv_obj_t * obj, lv_coord_t x);\n\n/**\n * Set the y coordinate of a object\n * @param obj pointer to an object\n * @param y new distance from the top of the parent\n */\nvoid lv_obj_set_y(lv_obj_t * obj, lv_coord_t y);\n\n/**\n * Set the size of an object\n * @param obj pointer to an object\n * @param w new width\n * @param h new height\n */\nvoid lv_obj_set_size(lv_obj_t * obj, lv_coord_t w, lv_coord_t h);\n\n/**\n * Set the width of an object\n * @param obj pointer to an object\n * @param w new width\n */\nvoid lv_obj_set_width(lv_obj_t * obj, lv_coord_t w);\n\n/**\n * Set the height of an object\n * @param obj pointer to an object\n * @param h new height\n */\nvoid lv_obj_set_height(lv_obj_t * obj, lv_coord_t h);\n\n/**\n * Set the width reduced by the left and right padding.\n * @param obj pointer to an object\n * @param w the width without paddings\n */\nvoid lv_obj_set_width_fit(lv_obj_t * obj, lv_coord_t w);\n\n/**\n * Set the height reduced by the top and bottom padding.\n * @param obj pointer to an object\n * @param h the height without paddings\n */\nvoid lv_obj_set_height_fit(lv_obj_t * obj, lv_coord_t h);\n\n/**\n * Set the width of an object by taking the left and right margin into account.\n * The object width will be `obj_w = w - margin_left - margin_right`\n * @param obj pointer to an object\n * @param w new height including margins\n */\nvoid lv_obj_set_width_margin(lv_obj_t * obj, lv_coord_t w);\n\n/**\n * Set the height of an object by taking the top and bottom margin into account.\n * The object height will be `obj_h = h - margin_top - margin_bottom`\n * @param obj pointer to an object\n * @param h new height including margins\n */\nvoid lv_obj_set_height_margin(lv_obj_t * obj, lv_coord_t h);\n\n/**\n * Align an object to an other object.\n * @param obj pointer to an object to align\n * @param base pointer to an object (if NULL the parent is used). 'obj' will be aligned to it.\n * @param align type of alignment (see 'lv_align_t' enum)\n * @param x_ofs x coordinate offset after alignment\n * @param y_ofs y coordinate offset after alignment\n */\nvoid lv_obj_align(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t x_ofs, lv_coord_t y_ofs);\n\n/**\n * Align an object to an other object horizontally.\n * @param obj pointer to an object to align\n * @param base pointer to an object (if NULL the parent is used). 'obj' will be aligned to it.\n * @param align type of alignment (see 'lv_align_t' enum)\n * @param x_ofs x coordinate offset after alignment\n */\nvoid lv_obj_align_x(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t x_ofs);\n\n/**\n * Align an object to an other object vertically.\n * @param obj pointer to an object to align\n * @param base pointer to an object (if NULL the parent is used). 'obj' will be aligned to it.\n * @param align type of alignment (see 'lv_align_t' enum)\n * @param y_ofs y coordinate offset after alignment\n */\nvoid lv_obj_align_y(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t y_ofs);\n\n/**\n * Align an object to an other object.\n * @param obj pointer to an object to align\n * @param base pointer to an object (if NULL the parent is used). 'obj' will be aligned to it.\n * @param align type of alignment (see 'lv_align_t' enum)\n * @param x_ofs x coordinate offset after alignment\n * @param y_ofs y coordinate offset after alignment\n */\nvoid lv_obj_align_mid(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t x_ofs, lv_coord_t y_ofs);\n\n\n/**\n * Align an object's middle point to an other object horizontally.\n * @param obj pointer to an object to align\n * @param base pointer to an object (if NULL the parent is used). 'obj' will be aligned to it.\n * @param align type of alignment (see 'lv_align_t' enum)\n * @param x_ofs x coordinate offset after alignment\n */\nvoid lv_obj_align_mid_x(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t x_ofs);\n\n/**\n * Align an object's middle point to an other object vertically.\n * @param obj pointer to an object to align\n * @param base pointer to an object (if NULL the parent is used). 'obj' will be aligned to it.\n * @param align type of alignment (see 'lv_align_t' enum)\n * @param y_ofs y coordinate offset after alignment\n */\nvoid lv_obj_align_mid_y(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t y_ofs);\n\n/**\n * Realign the object based on the last `lv_obj_align` parameters.\n * @param obj pointer to an object\n */\nvoid lv_obj_realign(lv_obj_t * obj);\n\n/**\n * Enable the automatic realign of the object when its size has changed based on the last\n * `lv_obj_align` parameters.\n * @param obj pointer to an object\n * @param en true: enable auto realign; false: disable auto realign\n */\nvoid lv_obj_set_auto_realign(lv_obj_t * obj, bool en);\n\n/**",
        "res_region": "",
        "lookback": " * @param obj pointer to an object",
        "lookahead": " * Set the size of an extended clickable area",
        "label": [
            "ours",
            "base_underutilized"
        ],
        "start_line": 453,
        "end_line": 745,
        "merge_gen_region": null,
        "confidence": 0.6174854040145874,
        "hesitated": true
    },
    {
        "a_contents": " * @return the size extended draw area around the real coordinates",
        "b_contents": " * @param part the part of the object which style list should be reset.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`",
        "base_contents": " * @param part the part of the object which style list should be reseted.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`",
        "res_region": " * @return the size extended draw area around the real coordinates",
        "lookback": " */",
        "lookahead": " */",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 758,
        "end_line": 766,
        "merge_gen_region": null,
        "confidence": 0.5567463040351868,
        "hesitated": true
    },
    {
        "a_contents": "/*---------------------\n * Appearance set\n *--------------------*/",
        "b_contents": "/**\n * Reset a style to the default (empty) state.\n * Release all used memories and cancel pending related transitions.\n * Also notifies the object about the style change.\n * @param obj pointer to an object\n * @param part the part of the object which style list should be reset.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n */\nvoid lv_obj_reset_style_list(lv_obj_t * obj, uint8_t part);\n\n/**\n * Notify an object (and its children) about its style is modified\n * @param obj pointer to an object\n * @param prop `LV_STYLE_PROP_ALL` or an `LV_STYLE_...` property. It is used to optimize what needs to be refreshed.\n */\nvoid lv_obj_refresh_style(lv_obj_t * obj, uint8_t part, lv_style_property_t prop);\n\n/**\n * Notify all object if a style is modified\n * @param style pointer to a style. Only the objects with this style will be notified\n *               (NULL to notify all objects)\n */\nvoid lv_obj_report_style_mod(lv_style_t * style);\n\n/**\n * Set a local style property of a part of an object in a given state.\n * @param obj pointer to an object\n * @param part the part of the object which style property should be set.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_BORDER_COLOR | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @param the value to set\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_opa()`\n * @note for performance reasons it's not checked if the property really has color type\n */\nvoid _lv_obj_set_style_local_color(lv_obj_t * obj, uint8_t type, lv_style_property_t prop, lv_color_t color);\n\n/**\n * Set a local style property of a part of an object in a given state.\n * @param obj pointer to an object\n * @param part the part of the object which style property should be set.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_BORDER_WIDTH | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @param the value to set\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_opa()`\n * @note for performance reasons it's not checked if the property really has integer type\n */\nvoid _lv_obj_set_style_local_int(lv_obj_t * obj, uint8_t type, lv_style_property_t prop, lv_style_int_t value);\n\n/**\n * Set a local style property of a part of an object in a given state.\n * @param obj pointer to an object\n * @param part the part of the object which style property should be set.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_BORDER_OPA | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @param the value to set\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_opa()`\n * @note for performance reasons it's not checked if the property really has opacity type\n */\nvoid _lv_obj_set_style_local_opa(lv_obj_t * obj, uint8_t type, lv_style_property_t prop, lv_opa_t opa);\n\n/**\n * Set a local style property of a part of an object in a given state.\n * @param obj pointer to an object\n * @param part the part of the object which style property should be set.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_TEXT_FONT | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @param the value to set\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_opa()`\n * @note for performance reasons it's not checked if the property really has pointer type\n */\nvoid _lv_obj_set_style_local_ptr(lv_obj_t * obj, uint8_t type, lv_style_property_t prop, const void * value);\n\n/**\n * Remove a local style property from a part of an object with a given state.\n * @param obj pointer to an object\n * @param part the part of the object which style property should be removed.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_TEXT_FONT | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @note shouldn't be used directly. Use the specific property remove functions instead.\n *       For example: `lv_obj_style_remove_border_opa()`\n * @return true: the property was found and removed; false: the property was not found\n */\nbool lv_obj_remove_style_local_prop(lv_obj_t * obj, uint8_t part, lv_style_property_t prop);\n\n/**\n * Enable/disable the use of style cache for an object\n * @param obj pointer to an object\n * @param dis true: disable; false: enable (re-enable)\n */\nvoid _lv_obj_disable_style_caching(lv_obj_t * obj, bool dis);",
        "base_contents": "/**\n * Reset a style to the default (empty) state.\n * Release all used memories and cancel pending related transitions.\n * Also notifies the object about the style change.\n * @param obj pointer to an object\n * @param part the part of the object which style list should be reseted.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n */\nvoid lv_obj_reset_style_list(lv_obj_t * obj, uint8_t part);\n\n/**\n * Notify an object (and its children) about its style is modified\n * @param obj pointer to an object\n * @param prop `LV_STYLE_PROP_ALL` or an `LV_STYLE_...` property. It is used to optimize what needs to be refreshed.\n */\nvoid lv_obj_refresh_style(lv_obj_t * obj, uint8_t part, lv_style_property_t prop);\n\n/**\n * Notify all object if a style is modified\n * @param style pointer to a style. Only the objects with this style will be notified\n *               (NULL to notify all objects)\n */\nvoid lv_obj_report_style_mod(lv_style_t * style);\n\n/**\n * Set a local style property of a part of an object in a given state.\n * @param obj pointer to an object\n * @param part the part of the object which style property should be set.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_BORDER_COLOR | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @param the value to set\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_opa()`\n * @note for performance reasons it's not checked if the property really has color type\n */\nvoid _lv_obj_set_style_local_color(lv_obj_t * obj, uint8_t type, lv_style_property_t prop, lv_color_t color);\n\n/**\n * Set a local style property of a part of an object in a given state.\n * @param obj pointer to an object\n * @param part the part of the object which style property should be set.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_BORDER_WIDTH | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @param the value to set\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_opa()`\n * @note for performance reasons it's not checked if the property really has integer type\n */\nvoid _lv_obj_set_style_local_int(lv_obj_t * obj, uint8_t type, lv_style_property_t prop, lv_style_int_t value);\n\n/**\n * Set a local style property of a part of an object in a given state.\n * @param obj pointer to an object\n * @param part the part of the object which style property should be set.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_BORDER_OPA | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @param the value to set\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_opa()`\n * @note for performance reasons it's not checked if the property really has opacity type\n */\nvoid _lv_obj_set_style_local_opa(lv_obj_t * obj, uint8_t type, lv_style_property_t prop, lv_opa_t opa);\n\n/**\n * Set a local style property of a part of an object in a given state.\n * @param obj pointer to an object\n * @param part the part of the object which style property should be set.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_TEXT_FONT | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @param the value to set\n * @note shouldn't be used directly. Use the specific property get functions instead.\n *       For example: `lv_obj_style_get_border_opa()`\n * @note for performance reasons it's not checked if the property really has pointer type\n */\nvoid _lv_obj_set_style_local_ptr(lv_obj_t * obj, uint8_t type, lv_style_property_t prop, const void * value);\n\n/**\n * Remove a local style property from a part of an object with a given state.\n * @param obj pointer to an object\n * @param part the part of the object which style property should be removed.\n * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`\n * @param prop a style property ORed with a state.\n * E.g. `LV_STYLE_TEXT_FONT | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`\n * @note shouldn't be used directly. Use the specific property remove functions instead.\n *       For example: `lv_obj_style_remove_border_opa()`\n * @return true: the property was found and removed; false: the property was not found\n */\nbool lv_obj_remove_style_local_prop(lv_obj_t * obj, uint8_t part, lv_style_property_t prop);\n\n/**\n * Enable/disable the use of style cahche for an object\n * @param obj pointer to an object\n * @param dis true: disable; false: enable (re-enable)\n */\nvoid _lv_obj_disable_style_caching(lv_obj_t * obj, bool dis);",
        "res_region": "/*---------------------\n * Appearance set\n *--------------------*/",
        "lookback": " * Appearance set",
        "lookahead": "",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 770,
        "end_line": 974,
        "merge_gen_region": null,
        "confidence": 0.800261914730072,
        "hesitated": true
    },
    {
        "a_contents": "void * lv_event_get_data(void);\n",
        "b_contents": "const void * lv_event_get_data(void);\n\n/**\n * Set the a signal function of an object. Used internally by the library.\n * Always call the previous signal function in the new.\n * @param obj pointer to an object\n * @param signal_cb the new signal function\n */\nvoid lv_obj_set_signal_cb(lv_obj_t * obj, lv_signal_cb_t signal_cb);\n",
        "base_contents": "const void * lv_event_get_data(void);\n\n/**\n * Set the a signal function of an object. Used internally by the library.\n * Always call the previous signal function in the new.\n * @param obj pointer to an object\n * @param signal_cb the new signal function\n */\nvoid lv_obj_set_signal_cb(lv_obj_t * obj, lv_signal_cb_t signal_cb);\n\n",
        "res_region": "void * lv_event_get_data(void);\n",
        "lookback": "",
        "lookahead": "/**",
        "label": [
            "ours",
            "base_underutilized"
        ],
        "start_line": 1066,
        "end_line": 1092,
        "merge_gen_region": null,
        "confidence": 0.7073107361793518,
        "hesitated": true
    },
    {
        "a_contents": " * Get the extended extended clickable area in a direction",
        "b_contents": " * Copy the coordinates of an object to an area\n * @param obj pointer to an object\n * @param cords_p pointer to an area to store the coordinates\n */\nvoid lv_obj_get_coords(const lv_obj_t * obj, lv_area_t * cords_p);\n\n/**\n * Reduce area retried by `lv_obj_get_coords()` the get graphically usable area of an object.\n * (Without the size of the border or other extra graphical elements)\n * @param coords_p store the result area here\n */\nvoid lv_obj_get_inner_coords(const lv_obj_t * obj, lv_area_t * coords_p);\n\n/**\n * Get the x coordinate of object\n * @param obj pointer to an object\n * @return distance of 'obj' from the left side of its parent\n */\nlv_coord_t lv_obj_get_x(const lv_obj_t * obj);\n\n/**\n * Get the y coordinate of object\n * @param obj pointer to an object\n * @return distance of 'obj' from the top of its parent\n */\nlv_coord_t lv_obj_get_y(const lv_obj_t * obj);\n\n/**\n * Get the width of an object\n * @param obj pointer to an object\n * @return the width\n */\nlv_coord_t lv_obj_get_width(const lv_obj_t * obj);\n\n/**\n * Get the height of an object\n * @param obj pointer to an object\n * @return the height\n */\nlv_coord_t lv_obj_get_height(const lv_obj_t * obj);\n\n/**\n * Get that width reduced by the left and right padding.\n * @param obj pointer to an object\n * @return the width which still fits into the container\n */\nlv_coord_t lv_obj_get_width_fit(const lv_obj_t * obj);\n\n/**\n * Get that height reduced by the top an bottom padding.\n * @param obj pointer to an object\n * @return the height which still fits into the container\n */\nlv_coord_t lv_obj_get_height_fit(const lv_obj_t * obj);\n\n/**\n * Get the height of an object by taking the top and bottom margin into account.\n * The returned height will be `obj_h + margin_top + margin_bottom`\n * @param obj pointer to an object\n * @return the height including thee margins\n */\nlv_coord_t lv_obj_get_height_margin(lv_obj_t * obj);\n\n/**\n * Get the width of an object by taking the left and right margin into account.\n * The returned width will be `obj_w + margin_left + margin_right`\n * @param obj pointer to an object\n * @return the height including thee margins\n */\nlv_coord_t lv_obj_get_width_margin(lv_obj_t * obj);\n\n/**\n * Divide the width of the object and get the width of a given number of columns.\n * Take paddings into account.\n * @param obj pointer to an object\n * @param div indicates how many columns are assumed.\n * If 1 the width will be set the parent's width\n * If 2 only half parent width - inner padding of the parent\n * If 3 only third parent width - 2 * inner padding of the parent\n * @param span how many columns are combined\n * @return the width according to the given parameters\n */\nlv_coord_t lv_obj_get_width_grid(lv_obj_t * obj, uint8_t div, uint8_t span);\n\n/**\n * Divide the height of the object and get the width of a given number of columns.\n * Take paddings into account.\n * @param obj pointer to an object\n * @param div indicates how many rows are assumed.\n * If 1 the height will be set the parent's height\n * If 2 only half parent height - inner padding of the parent\n * If 3 only third parent height - 2 * inner padding of the parent\n * @param span how many rows are combined\n * @return the height according to the given parameters\n */\nlv_coord_t lv_obj_get_height_grid(lv_obj_t * obj, uint8_t div, uint8_t span);\n\n/**\n * Get the automatic realign property of the object.\n * @param obj pointer to an object\n * @return true: auto realign is enabled; false: auto realign is disabled\n */\nbool lv_obj_get_auto_realign(const lv_obj_t * obj);\n\n/**\n * Get the left padding of extended clickable area",
        "base_contents": " * Copy the coordinates of an object to an area\n * @param obj pointer to an object\n * @param cords_p pointer to an area to store the coordinates\n */\nvoid lv_obj_get_coords(const lv_obj_t * obj, lv_area_t * cords_p);\n\n/**\n * Reduce area retried by `lv_obj_get_coords()` the get graphically usable area of an object.\n * (Without the size of the border or other extra graphical elements)\n * @param coords_p store the result area here\n */\nvoid lv_obj_get_inner_coords(const lv_obj_t * obj, lv_area_t * coords_p);\n\n/**\n * Get the x coordinate of object\n * @param obj pointer to an object\n * @return distance of 'obj' from the left side of its parent\n */\nlv_coord_t lv_obj_get_x(const lv_obj_t * obj);\n\n/**\n * Get the y coordinate of object\n * @param obj pointer to an object\n * @return distance of 'obj' from the top of its parent\n */\nlv_coord_t lv_obj_get_y(const lv_obj_t * obj);\n\n/**\n * Get the width of an object\n * @param obj pointer to an object\n * @return the width\n */\nlv_coord_t lv_obj_get_width(const lv_obj_t * obj);\n\n/**\n * Get the height of an object\n * @param obj pointer to an object\n * @return the height\n */\nlv_coord_t lv_obj_get_height(const lv_obj_t * obj);\n\n/**\n * Get that width reduced by the left and right padding.\n * @param obj pointer to an object\n * @return the width which still fits into the container\n */\nlv_coord_t lv_obj_get_width_fit(const lv_obj_t * obj);\n\n/**\n * Get that height reduced by the top an bottom padding.\n * @param obj pointer to an object\n * @return the height which still fits into the container\n */\nlv_coord_t lv_obj_get_height_fit(const lv_obj_t * obj);\n\n/**\n * Get the height of an object by taking the top and bottom margin into account.\n * The returned height will be `obj_h + margin_top + margin_bottom`\n * @param obj pointer to an object\n * @return the height including thee margins\n */\nlv_coord_t lv_obj_get_height_margin(lv_obj_t * obj);\n\n/**\n * Get the width of an object by taking the left and right margin into account.\n * The returned width will be `obj_w + margin_left + margin_right`\n * @param obj pointer to an object\n * @return the height including thee margins\n */\nlv_coord_t lv_obj_get_width_margin(lv_obj_t * obj);\n\n/**\n * Divide the width of the object and get the width of a given number of columns.\n * Take paddings into account.\n * @param obj pointer to an object\n * @param div indicates how many columns are assumed.\n * If 1 the width will be set the the parent's width\n * If 2 only half parent width - inner padding of the parent\n * If 3 only third parent width - 2 * inner padding of the parent\n * @param span how many columns are combined\n * @return the width according to the given parameters\n */\nlv_coord_t lv_obj_get_width_grid(lv_obj_t * obj, uint8_t div, uint8_t span);\n\n/**\n * Divide the height of the object and get the width of a given number of columns.\n * Take paddings into account.\n * @param obj pointer to an object\n * @param div indicates how many rows are assumed.\n * If 1 the height will be set the the parent's height\n * If 2 only half parent height - inner padding of the parent\n * If 3 only third parent height - 2 * inner padding of the parent\n * @param span how many rows are combined\n * @return the height according to the given parameters\n */\nlv_coord_t lv_obj_get_height_grid(lv_obj_t * obj, uint8_t div, uint8_t span);\n\n/**\n * Get the automatic realign property of the object.\n * @param obj pointer to an object\n * @return  true: auto realign is enabled; false: auto realign is disabled\n */\nbool lv_obj_get_auto_realign(const lv_obj_t * obj);\n\n/**\n * Get the left padding of extended clickable area",
        "res_region": " * Get the extended extended clickable area in a direction",
        "lookback": " * @param obj pointer to an object",
        "lookahead": " * @param obj pointer to an object",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 1179,
        "end_line": 1395,
        "merge_gen_region": "",
        "confidence": 0.9449042677879333,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "bool lv_obj_hit_test(lv_obj_t * obj, lv_point_t * point);",
        "b_contents": "lv_style_t * lv_obj_get_local_style(lv_obj_t * obj, uint8_t part);\n\n#include \"lv_obj_style_dec.h\"",
        "base_contents": "lv_style_t * lv_obj_get_local_style(lv_obj_t * obj, uint8_t part);\n\n\n#include \"lv_obj_style_dec.h\"",
        "res_region": "bool lv_obj_hit_test(lv_obj_t * obj, lv_point_t * point);",
        "lookback": "",
        "lookahead": "",
        "label": [
            "ours",
            "base_underutilized"
        ],
        "start_line": 1418,
        "end_line": 1429,
        "merge_gen_region": null,
        "confidence": 0.7441793084144592,
        "hesitated": true
    },
    {
        "a_contents": "bool lv_obj_has_flag(const lv_obj_t * obj, lv_obj_flag_t f);",
        "b_contents": "/**\n * Get the hidden attribute of an object\n * @param obj pointer to an object\n * @return true: the object is hidden\n */\nbool lv_obj_get_hidden(const lv_obj_t * obj);\n\n/**\n * Get whether advanced hit-testing is enabled on an object\n * @param obj pointer to an object\n * @return true: advanced hit-testing is enabled\n */\nbool lv_obj_get_adv_hittest(const lv_obj_t * obj);\n\n/**\n * Get the click enable attribute of an object\n * @param obj pointer to an object\n * @return true: the object is clickable\n */\nbool lv_obj_get_click(const lv_obj_t * obj);\n\n/**\n * Get the top enable attribute of an object\n * @param obj pointer to an object\n * @return true: the auto top feature is enabled\n */\nbool lv_obj_get_top(const lv_obj_t * obj);\n\n/**\n * Get the drag enable attribute of an object\n * @param obj pointer to an object\n * @return true: the object is draggable\n */\nbool lv_obj_get_drag(const lv_obj_t * obj);\n\n/**\n * Get the directions an object can be dragged\n * @param obj pointer to an object\n * @return bitwise OR of allowed directions an object can be dragged in\n */\nlv_drag_dir_t lv_obj_get_drag_dir(const lv_obj_t * obj);\n\n/**\n * Get the drag throw enable attribute of an object\n * @param obj pointer to an object\n * @return true: drag throw is enabled\n */\nbool lv_obj_get_drag_throw(const lv_obj_t * obj);\n\n/**\n * Get the drag parent attribute of an object\n * @param obj pointer to an object\n * @return true: drag parent is enabled\n */\nbool lv_obj_get_drag_parent(const lv_obj_t * obj);\n\n/**\n* Get the focus parent attribute of an object\n* @param obj pointer to an object\n* @return true: focus parent is enabled\n*/\nbool lv_obj_get_focus_parent(const lv_obj_t * obj);\n\n/**\n * Get the drag parent attribute of an object\n * @param obj pointer to an object\n * @return true: drag parent is enabled\n */\nbool lv_obj_get_parent_event(const lv_obj_t * obj);\n\n/**\n* Get the gesture parent attribute of an object\n* @param obj pointer to an object\n* @return true: gesture parent is enabled\n*/\nbool lv_obj_get_gesture_parent(const lv_obj_t * obj);",
        "base_contents": "/**\n * Get the hidden attribute of an object\n * @param obj pointer to an object\n * @return true: the object is hidden\n */\nbool lv_obj_get_hidden(const lv_obj_t * obj);\n\n/**\n * Get whether advanced hit-testing is enabled on an object\n * @param obj pointer to an object\n * @return true: advanced hit-testing is enabled\n */\nbool lv_obj_get_adv_hittest(const lv_obj_t * obj);\n\n/**\n * Get the click enable attribute of an object\n * @param obj pointer to an object\n * @return true: the object is clickable\n */\nbool lv_obj_get_click(const lv_obj_t * obj);\n\n/**\n * Get the top enable attribute of an object\n * @param obj pointer to an object\n * @return true: the auto top feature is enabled\n */\nbool lv_obj_get_top(const lv_obj_t * obj);\n\n/**\n * Get the drag enable attribute of an object\n * @param obj pointer to an object\n * @return true: the object is draggable\n */\nbool lv_obj_get_drag(const lv_obj_t * obj);\n\n/**\n * Get the directions an object can be dragged\n * @param obj pointer to an object\n * @return bitwise OR of allowed directions an object can be dragged in\n */\nlv_drag_dir_t lv_obj_get_drag_dir(const lv_obj_t * obj);\n\n/**\n * Get the drag throw enable attribute of an object\n * @param obj pointer to an object\n * @return true: drag throw is enabled\n */\nbool lv_obj_get_drag_throw(const lv_obj_t * obj);\n\n/**\n * Get the drag parent attribute of an object\n * @param obj pointer to an object\n * @return true: drag parent is enabled\n */\nbool lv_obj_get_drag_parent(const lv_obj_t * obj);\n\n\n/**\n* Get the focus parent attribute of an object\n* @param obj pointer to an object\n* @return true: focus parent is enabled\n*/\nbool lv_obj_get_focus_parent(const lv_obj_t * obj);\n\n\n/**\n * Get the drag parent attribute of an object\n * @param obj pointer to an object\n * @return true: drag parent is enabled\n */\nbool lv_obj_get_parent_event(const lv_obj_t * obj);\n\n/**\n* Get the gesture parent attribute of an object\n* @param obj pointer to an object\n* @return true: gesture parent is enabled\n*/\nbool lv_obj_get_gesture_parent(const lv_obj_t * obj);",
        "res_region": "bool lv_obj_has_flag(const lv_obj_t * obj, lv_obj_flag_t f);",
        "lookback": "",
        "lookahead": "",
        "label": [
            "ours",
            "base_underutilized"
        ],
        "start_line": 1435,
        "end_line": 1593,
        "merge_gen_region": null,
        "confidence": 0.6884591579437256,
        "hesitated": true
    },
    {
        "a_contents": "lv_state_t lv_obj_get_state(const lv_obj_t * obj);",
        "b_contents": "/**\n * Get the protect field of an object\n * @param obj pointer to an object\n * @return protect field ('OR'ed values of `lv_protect_t`)\n */\nuint8_t lv_obj_get_protect(const lv_obj_t * obj);\n\n/**\n * Check at least one bit of a given protect bitfield is set\n * @param obj pointer to an object\n * @param prot protect bits to test ('OR'ed values of `lv_protect_t`)\n * @return false: none of the given bits are set, true: at least one bit is set\n */\nbool lv_obj_is_protected(const lv_obj_t * obj, uint8_t prot);\n\nlv_state_t lv_obj_get_state(const lv_obj_t * obj, uint8_t part);",
        "base_contents": "/**\n * Get the protect field of an object\n * @param obj pointer to an object\n * @return protect field ('OR'ed values of `lv_protect_t`)\n */\nuint8_t lv_obj_get_protect(const lv_obj_t * obj);\n\n/**\n * Check at least one bit of a given protect bitfield is set\n * @param obj pointer to an object\n * @param prot protect bits to test ('OR'ed values of `lv_protect_t`)\n * @return false: none of the given bits are set, true: at least one bit is set\n */\nbool lv_obj_is_protected(const lv_obj_t * obj, uint8_t prot);\n\n\nlv_state_t lv_obj_get_state(const lv_obj_t * obj, uint8_t part);",
        "res_region": "lv_state_t lv_obj_get_state(const lv_obj_t * obj);",
        "lookback": "",
        "lookahead": "",
        "label": [
            "ours",
            "base_underutilized"
        ],
        "start_line": 1597,
        "end_line": 1634,
        "merge_gen_region": null,
        "confidence": 0.5075357556343079,
        "hesitated": true
    },
    {
        "a_contents": "bool _lv_debug_check_obj_valid(const lv_obj_t * obj);\n",
        "b_contents": "bool lv_debug_check_obj_valid(const lv_obj_t * obj);\n",
        "base_contents": "bool lv_debug_check_obj_valid(const lv_obj_t * obj);\n\n",
        "res_region": "bool _lv_debug_check_obj_valid(const lv_obj_t * obj);\n",
        "lookback": "",
        "lookahead": "/**********************",
        "label": [
            "ours",
            "base_underutilized"
        ],
        "start_line": 1744,
        "end_line": 1754,
        "merge_gen_region": null,
        "confidence": 0.604857325553894,
        "hesitated": true
    }
]