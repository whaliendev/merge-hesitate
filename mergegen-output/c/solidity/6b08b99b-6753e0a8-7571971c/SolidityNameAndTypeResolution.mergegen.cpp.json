[
    {
        "a_contents": "BOOST_AUTO_TEST_CASE(overloaded_function_cannot_resolve)\n{\n\tchar const* sourceCode = R\"(\n\t\tcontract test {\n\t\t\tfunction f() returns(uint) { return 1; }\n\t\t\tfunction f(uint a) returns(uint) { return a; }\n\t\t\tfunction g() returns(uint) { return f(3, 5); }\n\t\t}\n\t)\";\n\tBOOST_CHECK_THROW(parseTextAndResolveNames(sourceCode), TypeError);\n}\n\nBOOST_AUTO_TEST_CASE(ambiguous_overloaded_function)\n{\n\t// literal 1 can be both converted to uint and uint8, so the call is ambiguous.\n\tchar const* sourceCode = R\"(\n\t\tcontract test {\n\t\t\tfunction f(uint8 a) returns(uint) { return a; }\n\t\t\tfunction f(uint a) returns(uint) { return 2*a; }\n\t\t\tfunction g() returns(uint) { return f(1); }\n\t\t}\n\t)\";\n\tBOOST_CHECK_THROW(parseTextAndResolveNames(sourceCode), TypeError);\n}\n\nBOOST_AUTO_TEST_CASE(assignment_of_nonoverloaded_function)\n{\n\tchar const* sourceCode = R\"(\n\t\tcontract test {\n\t\t\tfunction f(uint a) returns(uint) { return 2 * a; }\n\t\t\tfunction g() returns(uint) { var x = f; return x(7); }\n\t\t}\n\t)\";\n\tETH_TEST_REQUIRE_NO_THROW(parseTextAndResolveNames(sourceCode), \"Type resolving failed\");\n}\n\nBOOST_AUTO_TEST_CASE(assignment_of_overloaded_function)\n{\n\tchar const* sourceCode = R\"(\n\t\tcontract test {\n\t\t\tfunction f() returns(uint) { return 1; }\n\t\t\tfunction f(uint a) returns(uint) { return 2 * a; }\n\t\t\tfunction g() returns(uint) { var x = f; return x(7); }\n\t\t}\n\t)\";\n\tBOOST_CHECK_THROW(parseTextAndResolveNames(sourceCode), TypeError);\n}\n\nBOOST_AUTO_TEST_CASE(external_types_clash)\n{\n\tchar const* sourceCode = R\"(\n\t\tcontract base {\n\t\t\tenum a { X }\n\t\t\tfunction f(a) { }\n\t\t}\n\t\tcontract test is base {\n\t\t\tfunction f(uint8 a) { }\n\t\t}\n\t)\";\n\tBOOST_CHECK_THROW(parseTextAndResolveNames(sourceCode), TypeError);\n}\n\nBOOST_AUTO_TEST_CASE(override_changes_return_types)\n{\n\tchar const* sourceCode = R\"(\n\t\tcontract base {\n\t\t\tfunction f(uint a) returns (uint) { }\n\t\t}\n\t\tcontract test is base {\n\t\t\tfunction f(uint a) returns (uint8) { }\n\t\t}\n\t)\";\n\tBOOST_CHECK_THROW(parseTextAndResolveNames(sourceCode), TypeError);\n}\n\nBOOST_AUTO_TEST_CASE(multiple_constructors)\n{\n\tchar const* sourceCode = R\"(\n\t\tcontract test {\n\t\t\tfunction test(uint a) { }\n\t\t\tfunction test() {}\n\t\t}\n\t)\";\n\tBOOST_CHECK_THROW(parseTextAndResolveNames(sourceCode), DeclarationError);\n}\n\nBOOST_AUTO_TEST_CASE(equal_overload)\n{\n\tchar const* sourceCode = R\"(\n\t\tcontract test {\n\t\t\tfunction test(uint a) returns (uint b) { }\n\t\t\tfunction test(uint a) external {}\n\t\t}\n\t)\";\n\tBOOST_CHECK_THROW(parseTextAndResolveNames(sourceCode), DeclarationError);\n}\n",
        "b_contents": "BOOST_AUTO_TEST_CASE(uninitialized_var)\n{\n\tchar const* sourceCode = R\"(\n\t\tcontract C {\n\t\t\tfunction f() returns (uint) { var x; return 2; }\n\t\t}\n\t)\";\n\tBOOST_CHECK_THROW(parseTextAndResolveNames(sourceCode), TypeError);\n}\n",
        "base_contents": "",
        "res_region": "BOOST_AUTO_TEST_CASE(overloaded_function_cannot_resolve)\n{\n\tchar const* sourceCode = R\"(\n\t\tcontract test {\n\t\t\tfunction f() returns(uint) { return 1; }\n\t\t\tfunction f(uint a) returns(uint) { return a; }\n\t\t\tfunction g() returns(uint) { return f(3, 5); }\n\t\t}\n\t)\";\n\tBOOST_CHECK_THROW(parseTextAndResolveNames(sourceCode), TypeError);\n}\n\nBOOST_AUTO_TEST_CASE(ambiguous_overloaded_function)\n{\n\t// literal 1 can be both converted to uint and uint8, so the call is ambiguous.\n\tchar const* sourceCode = R\"(\n\t\tcontract test {\n\t\t\tfunction f(uint8 a) returns(uint) { return a; }\n\t\t\tfunction f(uint a) returns(uint) { return 2*a; }\n\t\t\tfunction g() returns(uint) { return f(1); }\n\t\t}\n\t)\";\n\tBOOST_CHECK_THROW(parseTextAndResolveNames(sourceCode), TypeError);\n}\n\nBOOST_AUTO_TEST_CASE(assignment_of_nonoverloaded_function)\n{\n\tchar const* sourceCode = R\"(\n\t\tcontract test {\n\t\t\tfunction f(uint a) returns(uint) { return 2 * a; }\n\t\t\tfunction g() returns(uint) { var x = f; return x(7); }\n\t\t}\n\t)\";\n\tETH_TEST_REQUIRE_NO_THROW(parseTextAndResolveNames(sourceCode), \"Type resolving failed\");\n}\n\nBOOST_AUTO_TEST_CASE(assignment_of_overloaded_function)\n{\n\tchar const* sourceCode = R\"(\n\t\tcontract test {\n\t\t\tfunction f() returns(uint) { return 1; }\n\t\t\tfunction f(uint a) returns(uint) { return 2 * a; }\n\t\t\tfunction g() returns(uint) { var x = f; return x(7); }\n\t\t}\n\t)\";\n\tBOOST_CHECK_THROW(parseTextAndResolveNames(sourceCode), TypeError);\n}\n\nBOOST_AUTO_TEST_CASE(external_types_clash)\n{\n\tchar const* sourceCode = R\"(\n\t\tcontract base {\n\t\t\tenum a { X }\n\t\t\tfunction f(a) { }\n\t\t}\n\t\tcontract test is base {\n\t\t\tfunction f(uint8 a) { }\n\t\t}\n\t)\";\n\tBOOST_CHECK_THROW(parseTextAndResolveNames(sourceCode), TypeError);\n}\n\nBOOST_AUTO_TEST_CASE(override_changes_return_types)\n{\n\tchar const* sourceCode = R\"(\n\t\tcontract base {\n\t\t\tfunction f(uint a) returns (uint) { }\n\t\t}\n\t\tcontract test is base {\n\t\t\tfunction f(uint a) returns (uint8) { }\n\t\t}\n\t)\";\n\tBOOST_CHECK_THROW(parseTextAndResolveNames(sourceCode), TypeError);\n}\n\nBOOST_AUTO_TEST_CASE(multiple_constructors)\n{\n\tchar const* sourceCode = R\"(\n\t\tcontract test {\n\t\t\tfunction test(uint a) { }\n\t\t\tfunction test() {}\n\t\t}\n\t)\";\n\tBOOST_CHECK_THROW(parseTextAndResolveNames(sourceCode), DeclarationError);\n}\n\nBOOST_AUTO_TEST_CASE(equal_overload)\n{\n\tchar const* sourceCode = R\"(\n\t\tcontract test {\n\t\t\tfunction test(uint a) returns (uint b) { }\n\t\t\tfunction test(uint a) external {}\n\t\t}\n\t)\";\n\tBOOST_CHECK_THROW(parseTextAndResolveNames(sourceCode), DeclarationError);\n}\n\nBOOST_AUTO_TEST_CASE(uninitialized_var)\n{\n\tchar const* sourceCode = R\"(\n\t\tcontract C {\n\t\t\tfunction f() returns (uint) { var x; return 2; }\n\t\t}\n\t)\";\n\tBOOST_CHECK_THROW(parseTextAndResolveNames(sourceCode), TypeError);\n}\n",
        "lookback": "{",
        "lookahead": "BOOST_AUTO_TEST_SUITE_END()",
        "label": [
            "interleave",
            "one_side_deletion"
        ],
        "start_line": 1625,
        "end_line": 1735,
        "merge_gen_region": null,
        "confidence": 0.556900680065155,
        "hesitated": true
    }
]