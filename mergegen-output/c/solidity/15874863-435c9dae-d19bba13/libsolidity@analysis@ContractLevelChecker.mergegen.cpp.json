[
    {
        "a_contents": "",
        "b_contents": "void ContractLevelChecker::checkIllegalOverrides(ContractDefinition const& _contract)\n{\n\t// TODO unify this at a later point. for this we need to put the constness and the access specifier\n\t// into the types\n\tmap<string, vector<FunctionDefinition const*>> functions;\n\tmap<string, ModifierDefinition const*> modifiers;\n\n\t// We search from derived to base, so the stored item causes the error.\n\tfor (ContractDefinition const* contract: _contract.annotation().linearizedBaseContracts)\n\t{\n\t\tfor (FunctionDefinition const* function: contract->definedFunctions())\n\t\t{\n\t\t\tif (function->isConstructor())\n\t\t\t\tcontinue; // constructors can neither be overridden nor override anything\n\t\t\tstring const& name = function->name();\n\t\t\tif (modifiers.count(name))\n\t\t\t\tm_errorReporter.typeError(modifiers[name]->location(), \"Override changes function to modifier.\");\n\n\t\t\tfor (FunctionDefinition const* overriding: functions[name])\n\t\t\t\tcheckFunctionOverride(*overriding, *function);\n\n\t\t\tfunctions[name].push_back(function);\n\t\t}\n\t\tfor (ModifierDefinition const* modifier: contract->functionModifiers())\n\t\t{\n\t\t\tstring const& name = modifier->name();\n\t\t\tModifierDefinition const*& override = modifiers[name];\n\t\t\tif (!override)\n\t\t\t\toverride = modifier;\n\t\t\telse if (ModifierType(*override) != ModifierType(*modifier))\n\t\t\t\tm_errorReporter.typeError(override->location(), \"Override changes modifier signature.\");\n\t\t\tif (!functions[name].empty())\n\t\t\t\tm_errorReporter.typeError(override->location(), \"Override changes modifier to function.\");\n\t\t}\n\t}\n}\n\nvoid ContractLevelChecker::checkFunctionOverride(FunctionDefinition const& _function, FunctionDefinition const& _super)\n{\n\tFunctionTypePointer functionType = FunctionType(_function).asCallableFunction(false);\n\tFunctionTypePointer superType = FunctionType(_super).asCallableFunction(false);\n\n\tif (!functionType->hasEqualParameterTypes(*superType))\n\t\treturn;\n\tif (!functionType->hasEqualReturnTypes(*superType))\n\t\toverrideError(_function, _super, \"Overriding function return types differ.\");\n\n\tif (!_function.annotation().superFunction)\n\t\t_function.annotation().superFunction = &_super;\n\n\tif (_function.visibility() != _super.visibility())\n\t{\n\t\t// Visibility change from external to public is fine.\n\t\t// Any other change is disallowed.\n\t\tif (!(\n\t\t\t_super.visibility() == FunctionDefinition::Visibility::External &&\n\t\t\t_function.visibility() == FunctionDefinition::Visibility::Public\n\t\t))\n\t\t\toverrideError(_function, _super, \"Overriding function visibility differs.\");\n\t}\n\tif (_function.stateMutability() != _super.stateMutability())\n\t\toverrideError(\n\t\t\t_function,\n\t\t\t_super,\n\t\t\t\"Overriding function changes state mutability from \\\"\" +\n\t\t\tstateMutabilityToString(_super.stateMutability()) +\n\t\t\t\"\\\" to \\\"\" +\n\t\t\tstateMutabilityToString(_function.stateMutability()) +\n\t\t\t\"\\\".\"\n\t\t);\n\tif (_super.visibility() == Declaration::Visibility::Private)\n\t\toverrideError(_function, _super, \"Private functions cannot be overridden.\");\n\n}\n\nvoid ContractLevelChecker::overrideError(FunctionDefinition const& function, FunctionDefinition const& super, string message)\n{\n\tm_errorReporter.typeError(\n\t\tfunction.location(),\n\t\tSecondarySourceLocation().append(\"Overridden function is here:\", super.location()),\n\t\tmessage\n\t);\n}\n",
        "base_contents": "void ContractLevelChecker::checkIllegalOverrides(ContractDefinition const& _contract)\n{\n\t// TODO unify this at a later point. for this we need to put the constness and the access specifier\n\t// into the types\n\tmap<string, vector<FunctionDefinition const*>> functions;\n\tmap<string, ModifierDefinition const*> modifiers;\n\n\t// We search from derived to base, so the stored item causes the error.\n\tfor (ContractDefinition const* contract: _contract.annotation().linearizedBaseContracts)\n\t{\n\t\tfor (FunctionDefinition const* function: contract->definedFunctions())\n\t\t{\n\t\t\tif (function->isConstructor())\n\t\t\t\tcontinue; // constructors can neither be overridden nor override anything\n\t\t\tstring const& name = function->name();\n\t\t\tif (modifiers.count(name))\n\t\t\t\tm_errorReporter.typeError(modifiers[name]->location(), \"Override changes function to modifier.\");\n\n\t\t\tfor (FunctionDefinition const* overriding: functions[name])\n\t\t\t\tcheckFunctionOverride(*overriding, *function);\n\n\t\t\tfunctions[name].push_back(function);\n\t\t}\n\t\tfor (ModifierDefinition const* modifier: contract->functionModifiers())\n\t\t{\n\t\t\tstring const& name = modifier->name();\n\t\t\tModifierDefinition const*& override = modifiers[name];\n\t\t\tif (!override)\n\t\t\t\toverride = modifier;\n\t\t\telse if (ModifierType(*override) != ModifierType(*modifier))\n\t\t\t\tm_errorReporter.typeError(override->location(), \"Override changes modifier signature.\");\n\t\t\tif (!functions[name].empty())\n\t\t\t\tm_errorReporter.typeError(override->location(), \"Override changes modifier to function.\");\n\t\t}\n\t}\n}\n\nvoid ContractLevelChecker::checkFunctionOverride(FunctionDefinition const& _function, FunctionDefinition const& _super)\n{\n\tFunctionTypePointer functionType = FunctionType(_function).asCallableFunction(false);\n\tFunctionTypePointer superType = FunctionType(_super).asCallableFunction(false);\n\n\tif (!functionType->hasEqualParameterTypes(*superType))\n\t\treturn;\n\tif (!functionType->hasEqualReturnTypes(*superType))\n\t\toverrideError(_function, _super, \"Overriding function return types differ.\");\n\n\tif (!_function.annotation().superFunction)\n\t\t_function.annotation().superFunction = &_super;\n\n\tif (_function.visibility() != _super.visibility())\n\t{\n\t\t// Visibility change from external to public is fine.\n\t\t// Any other change is disallowed.\n\t\tif (!(\n\t\t\t_super.visibility() == FunctionDefinition::Visibility::External &&\n\t\t\t_function.visibility() == FunctionDefinition::Visibility::Public\n\t\t))\n\t\t\toverrideError(_function, _super, \"Overriding function visibility differs.\");\n\t}\n\tif (_function.stateMutability() != _super.stateMutability())\n\t\toverrideError(\n\t\t\t_function,\n\t\t\t_super,\n\t\t\t\"Overriding function changes state mutability from \\\"\" +\n\t\t\tstateMutabilityToString(_super.stateMutability()) +\n\t\t\t\"\\\" to \\\"\" +\n\t\t\tstateMutabilityToString(_function.stateMutability()) +\n\t\t\t\"\\\".\"\n\t\t);\n}\n\nvoid ContractLevelChecker::overrideError(FunctionDefinition const& function, FunctionDefinition const& super, string message)\n{\n\tm_errorReporter.typeError(\n\t\tfunction.location(),\n\t\tSecondarySourceLocation().append(\"Overridden function is here:\", super.location()),\n\t\tmessage\n\t);\n}\n",
        "res_region": "",
        "lookback": "{",
        "lookahead": "void ContractLevelChecker::checkAbstractFunctions(ContractDefinition const& _contract)",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 158,
        "end_line": 326,
        "merge_gen_region": null,
        "confidence": 0.4169895052909851,
        "hesitated": true
    }
]