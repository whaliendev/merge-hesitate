[
    {
        "a_contents": "/*\n\tThis file is part of cpp-ethereum.\n\n\tcpp-ethereum is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tcpp-ethereum is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License\n\talong with cpp-ethereum.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @author Christian <c@ethdev.com>\n * @date 2014\n * Solidity compiler.\n */\n\n#include <algorithm>\n#include <libsolidity/AST.h>\n#include <libsolidity/Compiler.h>\n#include <libsolidity/ExpressionCompiler.h>\n\nusing namespace std;\n\nnamespace dev {\nnamespace solidity {\n\nbytes Compiler::compile(ContractDefinition& _contract)\n{\n\tCompiler compiler;\n\tcompiler.compileContract(_contract);\n\treturn compiler.m_context.getAssembledBytecode();\n}\n\nvoid Compiler::compileContract(ContractDefinition& _contract)\n{\n\tm_context = CompilerContext(); // clear it just in case\n\n\t//@todo constructor\n\t//@todo register state variables\n\n\tfor (ASTPointer<FunctionDefinition> const& function: _contract.getDefinedFunctions())\n\t\tm_context.addFunction(*function);\n\n\tappendFunctionSelector(_contract.getDefinedFunctions());\n\tfor (ASTPointer<FunctionDefinition> const& function: _contract.getDefinedFunctions())\n\t\tfunction->accept(*this);\n\n\tpackIntoContractCreator();\n}\n\nvoid Compiler::packIntoContractCreator()\n{\n\tCompilerContext creatorContext;\n\teth::AssemblyItem sub = creatorContext.addSubroutine(m_context.getAssembly());\n\t// stack contains sub size\n\tcreatorContext << eth::Instruction::DUP1 << sub << u256(0) << eth::Instruction::CODECOPY;\n\tcreatorContext << u256(0) << eth::Instruction::RETURN;\n\tswap(m_context, creatorContext);\n}\n\nvoid Compiler::appendFunctionSelector(vector<ASTPointer<FunctionDefinition>> const& _functions)\n{\n\t// sort all public functions and store them together with a tag for their argument decoding section\n\tmap<string, pair<FunctionDefinition const*, eth::AssemblyItem>> publicFunctions;\n\tfor (ASTPointer<FunctionDefinition> const& f: _functions)\n\t\tif (f->isPublic())\n\t\t\tpublicFunctions.insert(make_pair(f->getName(), make_pair(f.get(), m_context.newTag())));\n\n\t//@todo remove constructor\n\n\tif (publicFunctions.size() > 255)\n\t\tBOOST_THROW_EXCEPTION(CompilerError() << errinfo_comment(\"More than 255 public functions for contract.\"));\n\n\t//@todo check for calldatasize?\n\t// retrieve the first byte of the call data\n\tm_context << u256(0) << eth::Instruction::CALLDATALOAD << u256(0) << eth::Instruction::BYTE;\n\t// check that it is not too large\n\tm_context << eth::Instruction::DUP1 << u256(publicFunctions.size() - 1) << eth::Instruction::LT;\n\teth::AssemblyItem returnTag = m_context.appendConditionalJump();\n\n\t// otherwise, jump inside jump table (each entry of the table has size 4)\n\tm_context << u256(4) << eth::Instruction::MUL;\n\teth::AssemblyItem jumpTableStart = m_context.pushNewTag();\n\tm_context << eth::Instruction::ADD << eth::Instruction::JUMP;\n\n\t// jump table @todo it could be that the optimizer destroys this\n\tm_context << jumpTableStart;\n\tfor (pair<string, pair<FunctionDefinition const*, eth::AssemblyItem>> const& f: publicFunctions)\n\t\tm_context.appendJumpTo(f.second.second) << eth::Instruction::JUMPDEST;\n\n\tm_context << returnTag << eth::Instruction::RETURN;\n\n\tfor (pair<string, pair<FunctionDefinition const*, eth::AssemblyItem>> const& f: publicFunctions)\n\t{\n\t\tm_context << f.second.second;\n\t\tappendFunctionCallSection(*f.second.first);\n\t}\n}\n\nvoid Compiler::appendFunctionCallSection(FunctionDefinition const& _function)\n{\n\teth::AssemblyItem returnTag = m_context.pushNewTag();\n\n\tappendCalldataUnpacker(_function);\n\n\tm_context.appendJumpTo(m_context.getFunctionEntryLabel(_function));\n\tm_context << returnTag;\n\n\tappendReturnValuePacker(_function);\n}\n\nvoid Compiler::appendCalldataUnpacker(FunctionDefinition const& _function)\n{\n\t// We do not check the calldata size, everything is zero-padded.\n\tunsigned dataOffset = 1;\n\n\t//@todo this can be done more efficiently, saving some CALLDATALOAD calls\n\tfor (ASTPointer<VariableDeclaration> const& var: _function.getParameters())\n\t{\n\t\tunsigned const numBytes = var->getType()->getCalldataEncodedSize();\n\t\tif (numBytes == 0)\n\t\t\tBOOST_THROW_EXCEPTION(CompilerError()\n\t\t\t\t\t\t\t\t  << errinfo_sourceLocation(var->getLocation())\n\t\t\t\t\t\t\t\t  << errinfo_comment(\"Type not yet supported.\"));\n\t\tif (numBytes == 32)\n\t\t\tm_context << u256(dataOffset) << eth::Instruction::CALLDATALOAD;\n\t\telse\n\t\t\tm_context << (u256(1) << ((32 - numBytes) * 8)) << u256(dataOffset)\n\t\t\t\t\t  << eth::Instruction::CALLDATALOAD << eth::Instruction::DIV;\n\t\tdataOffset += numBytes;\n\t}\n}\n\nvoid Compiler::appendReturnValuePacker(FunctionDefinition const& _function)\n{\n\t//@todo this can be also done more efficiently\n\tunsigned dataOffset = 0;\n\tvector<ASTPointer<VariableDeclaration>> const& parameters = _function.getReturnParameters();\n\tfor (unsigned i = 0 ; i < parameters.size(); ++i)\n\t{\n\t\tunsigned numBytes = parameters[i]->getType()->getCalldataEncodedSize();\n\t\tif (numBytes == 0)\n\t\t\tBOOST_THROW_EXCEPTION(CompilerError()\n\t\t\t\t\t\t\t\t  << errinfo_sourceLocation(parameters[i]->getLocation())\n\t\t\t\t\t\t\t\t  << errinfo_comment(\"Type not yet supported.\"));\n\t\tm_context << eth::dupInstruction(parameters.size() - i);\n\t\tif (numBytes == 32)\n\t\t\tm_context << u256(dataOffset) << eth::Instruction::MSTORE;\n\t\telse\n\t\t\tm_context << u256(dataOffset) << (u256(1) << ((32 - numBytes) * 8))\n\t\t\t\t\t  << eth::Instruction::MUL << eth::Instruction::MSTORE;\n\t\tdataOffset += numBytes;\n\t}\n\t// note that the stack is not cleaned up here\n\tm_context << u256(dataOffset) << u256(0) << eth::Instruction::RETURN;\n}\n\nbool Compiler::visit(FunctionDefinition& _function)\n{\n\t//@todo to simplify this, the calling convention could by changed such that\n\t// caller puts: [retarg0] ... [retargm] [return address] [arg0] ... [argn]\n\t// although note that this reduces the size of the visible stack\n\n\tm_context.startNewFunction();\n\tm_returnTag = m_context.newTag();\n\tm_breakTags.clear();\n\tm_continueTags.clear();\n\n\tm_context << m_context.getFunctionEntryLabel(_function);\n\n\t// stack upon entry: [return address] [arg0] [arg1] ... [argn]\n\t// reserve additional slots: [retarg0] ... [retargm] [localvar0] ... [localvarp]\n\n\tunsigned const numArguments = _function.getParameters().size();\n\tunsigned const numReturnValues = _function.getReturnParameters().size();\n\tunsigned const numLocalVariables = _function.getLocalVariables().size();\n\n\tfor (ASTPointer<VariableDeclaration> const& variable: _function.getParameters() + _function.getReturnParameters())\n\t\tm_context.addVariable(*variable);\n\tfor (VariableDeclaration const* localVariable: _function.getLocalVariables())\n\t\tm_context.addVariable(*localVariable);\n\tm_context.initializeLocalVariables(numReturnValues + numLocalVariables);\n\n\t_function.getBody().accept(*this);\n\n\tm_context << m_returnTag;\n\n\t// Now we need to re-shuffle the stack. For this we keep a record of the stack layout\n\t// that shows the target positions of the elements, where \"-1\" denotes that this element needs\n\t// to be removed from the stack.\n\t// Note that the fact that the return arguments are of increasing index is vital for this\n\t// algorithm to work.\n\n\tvector<int> stackLayout;\n\tstackLayout.push_back(numReturnValues); // target of return address\n\tstackLayout += vector<int>(numArguments, -1); // discard all arguments\n\tfor (unsigned i = 0; i < numReturnValues; ++i)\n\t\tstackLayout.push_back(i);\n\tstackLayout += vector<int>(numLocalVariables, -1);\n\n\twhile (stackLayout.back() != int(stackLayout.size() - 1))\n\t\tif (stackLayout.back() < 0)\n\t\t{\n\t\t\tm_context << eth::Instruction::POP;\n\t\t\tstackLayout.pop_back();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_context << eth::swapInstruction(stackLayout.size() - stackLayout.back() - 1);\n\t\t\tswap(stackLayout[stackLayout.back()], stackLayout.back());\n\t\t}\n\n\tm_context << eth::Instruction::JUMP;\n\n\treturn false;\n}\n\nbool Compiler::visit(IfStatement& _ifStatement)\n{\n\tExpressionCompiler::compileExpression(m_context, _ifStatement.getCondition());\n\teth::AssemblyItem trueTag = m_context.appendConditionalJump();\n\tif (_ifStatement.getFalseStatement())\n\t\t_ifStatement.getFalseStatement()->accept(*this);\n\teth::AssemblyItem endTag = m_context.appendJump();\n\tm_context << trueTag;\n\t_ifStatement.getTrueStatement().accept(*this);\n\tm_context << endTag;\n\treturn false;\n}\n\nbool Compiler::visit(WhileStatement& _whileStatement)\n{\n\teth::AssemblyItem loopStart = m_context.newTag();\n\teth::AssemblyItem loopEnd = m_context.newTag();\n\tm_continueTags.push_back(loopStart);\n\tm_breakTags.push_back(loopEnd);\n\n\tm_context << loopStart;\n\tExpressionCompiler::compileExpression(m_context, _whileStatement.getCondition());\n\tm_context << eth::Instruction::NOT;\n\tm_context.appendConditionalJumpTo(loopEnd);\n\n\t_whileStatement.getBody().accept(*this);\n\n\tm_context.appendJumpTo(loopStart);\n\tm_context << loopEnd;\n\n\tm_continueTags.pop_back();\n\tm_breakTags.pop_back();\n\treturn false;\n}\n\nbool Compiler::visit(Continue&)\n{\n\tassert(!m_continueTags.empty());\n\tm_context.appendJumpTo(m_continueTags.back());\n\treturn false;\n}\n\nbool Compiler::visit(Break&)\n{\n\tassert(!m_breakTags.empty());\n\tm_context.appendJumpTo(m_breakTags.back());\n\treturn false;\n}\n\nbool Compiler::visit(Return& _return)\n{\n\t//@todo modifications are needed to make this work with functions returning multiple values\n\tif (Expression* expression = _return.getExpression())\n\t{\n\t\tExpressionCompiler::compileExpression(m_context, *expression);\n\t\tVariableDeclaration const& firstVariable = *_return.getFunctionReturnParameters().getParameters().front();\n\t\tExpressionCompiler::cleanHigherOrderBitsIfNeeded(*expression->getType(), *firstVariable.getType());\n\t\tint stackPosition = m_context.getStackPositionOfVariable(firstVariable);\n\t\tm_context << eth::swapInstruction(stackPosition) << eth::Instruction::POP;\n\t}\n\tm_context.appendJumpTo(m_returnTag);\n\treturn false;\n}\n\nbool Compiler::visit(VariableDefinition& _variableDefinition)\n{\n\tif (Expression* expression = _variableDefinition.getExpression())\n\t{\n\t\tExpressionCompiler::compileExpression(m_context, *expression);\n\t\tExpressionCompiler::cleanHigherOrderBitsIfNeeded(*expression->getType(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t *_variableDefinition.getDeclaration().getType());\n\t\tint stackPosition = m_context.getStackPositionOfVariable(_variableDefinition.getDeclaration());\n\t\tm_context << eth::swapInstruction(stackPosition) << eth::Instruction::POP;\n\t}\n\treturn false;\n}\n\nbool Compiler::visit(ExpressionStatement& _expressionStatement)\n{\n\tExpression& expression = _expressionStatement.getExpression();\n\tExpressionCompiler::compileExpression(m_context, expression);\n\tif (expression.getType()->getCategory() != Type::Category::VOID)\n\t\tm_context << eth::Instruction::POP;\n\treturn false;\n}\n\n}\n}",
        "b_contents": "/*\n\tThis file is part of cpp-ethereum.\n\n\tcpp-ethereum is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tcpp-ethereum is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License\n\talong with cpp-ethereum.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @author Christian <c@ethdev.com>\n * @date 2014\n * Solidity AST to EVM bytecode compiler.\n */\n\n#include <cassert>\n#include <utility>\n#include <libsolidity/AST.h>\n#include <libsolidity/Compiler.h>\n\nnamespace dev {\nnamespace solidity {\n\nvoid CompilerContext::setLabelPosition(uint32_t _label, uint32_t _position)\n{\n\tassert(m_labelPositions.find(_label) == m_labelPositions.end());\n\tm_labelPositions[_label] = _position;\n}\n\nuint32_t CompilerContext::getLabelPosition(uint32_t _label) const\n{\n\tauto iter = m_labelPositions.find(_label);\n\tassert(iter != m_labelPositions.end());\n\treturn iter->second;\n}\n\nvoid ExpressionCompiler::compile(Expression& _expression)\n{\n\tm_assemblyItems.clear();\n\t_expression.accept(*this);\n}\n\nbytes ExpressionCompiler::getAssembledBytecode() const\n{\n\tbytes assembled;\n\tassembled.reserve(m_assemblyItems.size());\n\n\t// resolve label references\n\tfor (uint32_t pos = 0; pos < m_assemblyItems.size(); ++pos)\n\t{\n\t\tAssemblyItem const& item = m_assemblyItems[pos];\n\t\tif (item.getType() == AssemblyItem::Type::LABEL)\n\t\t\tm_context.setLabelPosition(item.getLabel(), pos + 1);\n\t}\n\n\tfor (AssemblyItem const& item: m_assemblyItems)\n\t\tif (item.getType() == AssemblyItem::Type::LABELREF)\n\t\t\tassembled.push_back(m_context.getLabelPosition(item.getLabel()));\n\t\telse\n\t\t\tassembled.push_back(item.getData());\n\n\treturn assembled;\n}\n\nAssemblyItems ExpressionCompiler::compileExpression(CompilerContext& _context,\n\t\t\t\t\t\t\t\t\t\t\t\t\tExpression& _expression)\n{\n\tExpressionCompiler compiler(_context);\n\tcompiler.compile(_expression);\n\treturn compiler.getAssemblyItems();\n}\n\nvoid ExpressionCompiler::endVisit(Assignment& _assignment)\n{\n\tExpression& rightHandSide = _assignment.getRightHandSide();\n\tToken::Value op = _assignment.getAssignmentOperator();\n\tif (op != Token::ASSIGN)\n\t{\n\t\t// compound assignment\n\t\t// @todo retrieve lvalue value\n\t\trightHandSide.accept(*this);\n\t\tType const& resultType = *_assignment.getType();\n\t\tcleanHigherOrderBitsIfNeeded(*rightHandSide.getType(), resultType);\n\t\tappendOrdinaryBinaryOperatorCode(Token::AssignmentToBinaryOp(op), resultType);\n\t}\n\telse\n\t\trightHandSide.accept(*this);\n\t// @todo store value\n}\n\nvoid ExpressionCompiler::endVisit(UnaryOperation& _unaryOperation)\n{\n\t//@todo type checking and creating code for an operator should be in the same place:\n\t// the operator should know how to convert itself and to which types it applies, so\n\t// put this code together with \"Type::acceptsBinary/UnaryOperator\" into a class that\n\t// represents the operator\n\tswitch (_unaryOperation.getOperator())\n\t{\n\tcase Token::NOT: // !\n\t\tappend(eth::Instruction::ISZERO);\n\t\tbreak;\n\tcase Token::BIT_NOT: // ~\n\t\tappend(eth::Instruction::NOT);\n\t\tbreak;\n\tcase Token::DELETE: // delete\n\t\t// a -> a xor a (= 0).\n\t\t// @todo this should also be an assignment\n\t\t// @todo semantics change for complex types\n\t\tappend(eth::Instruction::DUP1);\n\t\tappend(eth::Instruction::XOR);\n\t\tbreak;\n\tcase Token::INC: // ++ (pre- or postfix)\n\t\t// @todo this should also be an assignment\n\t\tif (_unaryOperation.isPrefixOperation())\n\t\t{\n\t\t\tappend(eth::Instruction::PUSH1);\n\t\t\tappend(1);\n\t\t\tappend(eth::Instruction::ADD);\n\t\t}\n\t\tbreak;\n\tcase Token::DEC: // -- (pre- or postfix)\n\t\t// @todo this should also be an assignment\n\t\tif (_unaryOperation.isPrefixOperation())\n\t\t{\n\t\t\tappend(eth::Instruction::PUSH1);\n\t\t\tappend(1);\n\t\t\tappend(eth::Instruction::SWAP1); //@todo avoid this\n\t\t\tappend(eth::Instruction::SUB);\n\t\t}\n\t\tbreak;\n\tcase Token::ADD: // +\n\t\t// unary add, so basically no-op\n\t\tbreak;\n\tcase Token::SUB: // -\n\t\t// unary -x translates into \"0-x\"\n\t\tappend(eth::Instruction::PUSH1);\n\t\tappend(0);\n\t\tappend(eth::Instruction::SUB);\n\t\tbreak;\n\tdefault:\n\t\tassert(false); // invalid operation\n\t}\n}\n\nbool ExpressionCompiler::visit(BinaryOperation& _binaryOperation)\n{\n\tExpression& leftExpression = _binaryOperation.getLeftExpression();\n\tExpression& rightExpression = _binaryOperation.getRightExpression();\n\tType const& resultType = *_binaryOperation.getType();\n\tToken::Value const op = _binaryOperation.getOperator();\n\n\tif (op == Token::AND || op == Token::OR)\n\t{\n\t\t// special case: short-circuiting\n\t\tappendAndOrOperatorCode(_binaryOperation);\n\t}\n\telse if (Token::isCompareOp(op))\n\t{\n\t\tleftExpression.accept(*this);\n\t\trightExpression.accept(*this);\n\n\t\t// the types to compare have to be the same, but the resulting type is always bool\n\t\tassert(*leftExpression.getType() == *rightExpression.getType());\n\t\tappendCompareOperatorCode(op, *leftExpression.getType());\n\t}\n\telse\n\t{\n\t\tleftExpression.accept(*this);\n\t\tcleanHigherOrderBitsIfNeeded(*leftExpression.getType(), resultType);\n\t\trightExpression.accept(*this);\n\t\tcleanHigherOrderBitsIfNeeded(*rightExpression.getType(), resultType);\n\t\tappendOrdinaryBinaryOperatorCode(op, resultType);\n\t}\n\n\t// do not visit the child nodes, we already did that explicitly\n\treturn false;\n}\n\nvoid ExpressionCompiler::endVisit(FunctionCall& _functionCall)\n{\n\tif (_functionCall.isTypeConversion())\n\t{\n\t\t//@todo binary representation for all supported types (bool and int) is the same, so no-op\n\t\t// here for now.\n\t}\n\telse\n\t{\n\t\t//@todo\n\t}\n}\n\nvoid ExpressionCompiler::endVisit(MemberAccess&)\n{\n\n}\n\nvoid ExpressionCompiler::endVisit(IndexAccess&)\n{\n\n}\n\nvoid ExpressionCompiler::endVisit(Identifier&)\n{\n\n}\n\nvoid ExpressionCompiler::endVisit(Literal& _literal)\n{\n\tswitch (_literal.getType()->getCategory())\n\t{\n\tcase Type::Category::INTEGER:\n\tcase Type::Category::BOOL:\n\t{\n\t\tbytes value = _literal.getType()->literalToBigEndian(_literal);\n\t\tassert(value.size() <= 32);\n\t\tassert(!value.empty());\n\t\tappend(static_cast<byte>(eth::Instruction::PUSH1) + static_cast<byte>(value.size() - 1));\n\t\tappend(value);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tassert(false); // @todo\n\t}\n}\n\nvoid ExpressionCompiler::cleanHigherOrderBitsIfNeeded(Type const& _typeOnStack, Type const& _targetType)\n{\n\t// If the type of one of the operands is extended, we need to remove all\n\t// higher-order bits that we might have ignored in previous operations.\n\t// @todo: store in the AST whether the operand might have \"dirty\" higher\n\t// order bits\n\n\tif (_typeOnStack == _targetType)\n\t\treturn;\n\tif (_typeOnStack.getCategory() == Type::Category::INTEGER &&\n\t\t\t_targetType.getCategory() == Type::Category::INTEGER)\n\t{\n\t\t//@todo\n\t}\n\telse\n\t{\n\t\t// If we get here, there is either an implementation missing to clean higher oder bits\n\t\t// for non-integer types that are explicitly convertible or we got here in error.\n\t\tassert(!_typeOnStack.isExplicitlyConvertibleTo(_targetType));\n\t\tassert(false); // these types should not be convertible.\n\t}\n}\n\nvoid ExpressionCompiler::appendAndOrOperatorCode(BinaryOperation& _binaryOperation)\n{\n\tToken::Value const op = _binaryOperation.getOperator();\n\tassert(op == Token::OR || op == Token::AND);\n\n\t_binaryOperation.getLeftExpression().accept(*this);\n\tappend(eth::Instruction::DUP1);\n\tif (op == Token::AND)\n\t\tappend(eth::Instruction::NOT);\n\tuint32_t endLabel = appendConditionalJump();\n\t_binaryOperation.getRightExpression().accept(*this);\n\tappendLabel(endLabel);\n}\n\nvoid ExpressionCompiler::appendCompareOperatorCode(Token::Value _operator, Type const& _type)\n{\n\tif (_operator == Token::EQ || _operator == Token::NE)\n\t{\n\t\tappend(eth::Instruction::EQ);\n\t\tif (_operator == Token::NE)\n\t\t\tappend(eth::Instruction::NOT);\n\t}\n\telse\n\t{\n\t\tIntegerType const* type = dynamic_cast<IntegerType const*>(&_type);\n\t\tassert(type);\n\t\tbool const isSigned = type->isSigned();\n\n\t\t// note that EVM opcodes compare like \"stack[0] < stack[1]\",\n\t\t// but our left value is at stack[1], so everyhing is reversed.\n\t\tswitch (_operator)\n\t\t{\n\t\tcase Token::GTE:\n\t\t\tappend(isSigned ? eth::Instruction::SGT : eth::Instruction::GT);\n\t\t\tappend(eth::Instruction::NOT);\n\t\t\tbreak;\n\t\tcase Token::LTE:\n\t\t\tappend(isSigned ? eth::Instruction::SLT : eth::Instruction::LT);\n\t\t\tappend(eth::Instruction::NOT);\n\t\t\tbreak;\n\t\tcase Token::GT:\n\t\t\tappend(isSigned ? eth::Instruction::SLT : eth::Instruction::LT);\n\t\t\tbreak;\n\t\tcase Token::LT:\n\t\t\tappend(isSigned ? eth::Instruction::SGT : eth::Instruction::GT);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(false);\n\t\t}\n\t}\n}\n\nvoid ExpressionCompiler::appendOrdinaryBinaryOperatorCode(Token::Value _operator, Type const& _type)\n{\n\tif (Token::isArithmeticOp(_operator))\n\t\tappendArithmeticOperatorCode(_operator, _type);\n\telse if (Token::isBitOp(_operator))\n\t\tappendBitOperatorCode(_operator);\n\telse if (Token::isShiftOp(_operator))\n\t\tappendShiftOperatorCode(_operator);\n\telse\n\t\tassert(false); // unknown binary operator\n}\n\nvoid ExpressionCompiler::appendArithmeticOperatorCode(Token::Value _operator, Type const& _type)\n{\n\tIntegerType const* type = dynamic_cast<IntegerType const*>(&_type);\n\tassert(type);\n\tbool const isSigned = type->isSigned();\n\n\tswitch (_operator)\n\t{\n\tcase Token::ADD:\n\t\tappend(eth::Instruction::ADD);\n\t\tbreak;\n\tcase Token::SUB:\n\t\tappend(eth::Instruction::SWAP1);\n\t\tappend(eth::Instruction::SUB);\n\t\tbreak;\n\tcase Token::MUL:\n\t\tappend(eth::Instruction::MUL);\n\t\tbreak;\n\tcase Token::DIV:\n\t\tappend(isSigned ? eth::Instruction::SDIV : eth::Instruction::DIV);\n\t\tbreak;\n\tcase Token::MOD:\n\t\tappend(isSigned ? eth::Instruction::SMOD : eth::Instruction::MOD);\n\t\tbreak;\n\tdefault:\n\t\tassert(false);\n\t}\n}\n\nvoid ExpressionCompiler::appendBitOperatorCode(Token::Value _operator)\n{\n\tswitch (_operator)\n\t{\n\tcase Token::BIT_OR:\n\t\tappend(eth::Instruction::OR);\n\t\tbreak;\n\tcase Token::BIT_AND:\n\t\tappend(eth::Instruction::AND);\n\t\tbreak;\n\tcase Token::BIT_XOR:\n\t\tappend(eth::Instruction::XOR);\n\t\tbreak;\n\tdefault:\n\t\tassert(false);\n\t}\n}\n\nvoid ExpressionCompiler::appendShiftOperatorCode(Token::Value _operator)\n{\n\tswitch (_operator)\n\t{\n\tcase Token::SHL:\n\t\tassert(false); //@todo\n\t\tbreak;\n\tcase Token::SAR:\n\t\tassert(false); //@todo\n\t\tbreak;\n\tdefault:\n\t\tassert(false);\n\t}\n}\n\nuint32_t ExpressionCompiler::appendConditionalJump()\n{\n\tuint32_t label = m_context.dispenseNewLabel();\n\tappend(eth::Instruction::PUSH1);\n\tappendLabelref(label);\n\tappend(eth::Instruction::JUMPI);\n\treturn label;\n}\n\nvoid ExpressionCompiler::append(bytes const& _data)\n{\n\tm_assemblyItems.reserve(m_assemblyItems.size() + _data.size());\n\tfor (byte b: _data)\n\t\tappend(b);\n}\n\n\n\n}\n}",
        "base_contents": "",
        "res_region": "/*\n\tThis file is part of cpp-ethereum.\n\n\tcpp-ethereum is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tcpp-ethereum is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License\n\talong with cpp-ethereum.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @author Christian <c@ethdev.com>\n * @date 2014\n * Solidity compiler.\n */\n\n#include <algorithm>\n#include <libsolidity/AST.h>\n#include <libsolidity/Compiler.h>\n#include <libsolidity/ExpressionCompiler.h>\n\nusing namespace std;\n\nnamespace dev {\nnamespace solidity {\n\nbytes Compiler::compile(ContractDefinition& _contract)\n{\n\tCompiler compiler;\n\tcompiler.compileContract(_contract);\n\treturn compiler.m_context.getAssembledBytecode();\n}\n\nvoid Compiler::compileContract(ContractDefinition& _contract)\n{\n\tm_context = CompilerContext(); // clear it just in case\n\n\t//@todo constructor\n\t//@todo register state variables\n\n\tfor (ASTPointer<FunctionDefinition> const& function: _contract.getDefinedFunctions())\n\t\tm_context.addFunction(*function);\n\n\tappendFunctionSelector(_contract.getDefinedFunctions());\n\tfor (ASTPointer<FunctionDefinition> const& function: _contract.getDefinedFunctions())\n\t\tfunction->accept(*this);\n\n\tpackIntoContractCreator();\n}\n\nvoid Compiler::packIntoContractCreator()\n{\n\tCompilerContext creatorContext;\n\teth::AssemblyItem sub = creatorContext.addSubroutine(m_context.getAssembly());\n\t// stack contains sub size\n\tcreatorContext << eth::Instruction::DUP1 << sub << u256(0) << eth::Instruction::CODECOPY;\n\tcreatorContext << u256(0) << eth::Instruction::RETURN;\n\tswap(m_context, creatorContext);\n}\n\nvoid Compiler::appendFunctionSelector(vector<ASTPointer<FunctionDefinition>> const& _functions)\n{\n\t// sort all public functions and store them together with a tag for their argument decoding section\n\tmap<string, pair<FunctionDefinition const*, eth::AssemblyItem>> publicFunctions;\n\tfor (ASTPointer<FunctionDefinition> const& f: _functions)\n\t\tif (f->isPublic())\n\t\t\tpublicFunctions.insert(make_pair(f->getName(), make_pair(f.get(), m_context.newTag())));\n\n\t//@todo remove constructor\n\n\tif (publicFunctions.size() > 255)\n\t\tBOOST_THROW_EXCEPTION(CompilerError() << errinfo_comment(\"More than 255 public functions for contract.\"));\n\n\t//@todo check for calldatasize?\n\t// retrieve the first byte of the call data\n\tm_context << u256(0) << eth::Instruction::CALLDATALOAD << u256(0) << eth::Instruction::BYTE;\n\t// check that it is not too large\n\tm_context << eth::Instruction::DUP1 << u256(publicFunctions.size() - 1) << eth::Instruction::LT;\n\teth::AssemblyItem returnTag = m_context.appendConditionalJump();\n\n\t// otherwise, jump inside jump table (each entry of the table has size 4)\n\tm_context << u256(4) << eth::Instruction::MUL;\n\teth::AssemblyItem jumpTableStart = m_context.pushNewTag();\n\tm_context << eth::Instruction::ADD << eth::Instruction::JUMP;\n\n\t// jump table @todo it could be that the optimizer destroys this\n\tm_context << jumpTableStart;\n\tfor (pair<string, pair<FunctionDefinition const*, eth::AssemblyItem>> const& f: publicFunctions)\n\t\tm_context.appendJumpTo(f.second.second) << eth::Instruction::JUMPDEST;\n\n\tm_context << returnTag << eth::Instruction::RETURN;\n\n\tfor (pair<string, pair<FunctionDefinition const*, eth::AssemblyItem>> const& f: publicFunctions)\n\t{\n\t\tm_context << f.second.second;\n\t\tappendFunctionCallSection(*f.second.first);\n\t}\n}\n\nvoid Compiler::appendFunctionCallSection(FunctionDefinition const& _function)\n{\n\teth::AssemblyItem returnTag = m_context.pushNewTag();\n\n\tappendCalldataUnpacker(_function);\n\n\tm_context.appendJumpTo(m_context.getFunctionEntryLabel(_function));\n\tm_context << returnTag;\n\n\tappendReturnValuePacker(_function);\n}\n\nvoid Compiler::appendCalldataUnpacker(FunctionDefinition const& _function)\n{\n\t// We do not check the calldata size, everything is zero-padded.\n\tunsigned dataOffset = 1;\n\n\t//@todo this can be done more efficiently, saving some CALLDATALOAD calls\n\tfor (ASTPointer<VariableDeclaration> const& var: _function.getParameters())\n\t{\n\t\tunsigned const numBytes = var->getType()->getCalldataEncodedSize();\n\t\tif (numBytes == 0)\n\t\t\tBOOST_THROW_EXCEPTION(CompilerError()\n\t\t\t\t\t\t\t\t  << errinfo_sourceLocation(var->getLocation())\n\t\t\t\t\t\t\t\t  << errinfo_comment(\"Type not yet supported.\"));\n\t\tif (numBytes == 32)\n\t\t\tm_context << u256(dataOffset) << eth::Instruction::CALLDATALOAD;\n\t\telse\n\t\t\tm_context << (u256(1) << ((32 - numBytes) * 8)) << u256(dataOffset)\n\t\t\t\t\t  << eth::Instruction::CALLDATALOAD << eth::Instruction::DIV;\n\t\tdataOffset += numBytes;\n\t}\n}\n\nvoid Compiler::appendReturnValuePacker(FunctionDefinition const& _function)\n{\n\t//@todo this can be also done more efficiently\n\tunsigned dataOffset = 0;\n\tvector<ASTPointer<VariableDeclaration>> const& parameters = _function.getReturnParameters();\n\tfor (unsigned i = 0 ; i < parameters.size(); ++i)\n\t{\n\t\tunsigned numBytes = parameters[i]->getType()->getCalldataEncodedSize();\n\t\tif (numBytes == 0)\n\t\t\tBOOST_THROW_EXCEPTION(CompilerError()\n\t\t\t\t\t\t\t\t  << errinfo_sourceLocation(parameters[i]->getLocation())\n\t\t\t\t\t\t\t\t  << errinfo_comment(\"Type not yet supported.\"));\n\t\tm_context << eth::dupInstruction(parameters.size() - i);\n\t\tif (numBytes == 32)\n\t\t\tm_context << u256(dataOffset) << eth::Instruction::MSTORE;\n\t\telse\n\t\t\tm_context << u256(dataOffset) << (u256(1) << ((32 - numBytes) * 8))\n\t\t\t\t\t  << eth::Instruction::MUL << eth::Instruction::MSTORE;\n\t\tdataOffset += numBytes;\n\t}\n\t// note that the stack is not cleaned up here\n\tm_context << u256(dataOffset) << u256(0) << eth::Instruction::RETURN;\n}\n\nbool Compiler::visit(FunctionDefinition& _function)\n{\n\t//@todo to simplify this, the calling convention could by changed such that\n\t// caller puts: [retarg0] ... [retargm] [return address] [arg0] ... [argn]\n\t// although note that this reduces the size of the visible stack\n\n\tm_context.startNewFunction();\n\tm_returnTag = m_context.newTag();\n\tm_breakTags.clear();\n\tm_continueTags.clear();\n\n\tm_context << m_context.getFunctionEntryLabel(_function);\n\n\t// stack upon entry: [return address] [arg0] [arg1] ... [argn]\n\t// reserve additional slots: [retarg0] ... [retargm] [localvar0] ... [localvarp]\n\n\tunsigned const numArguments = _function.getParameters().size();\n\tunsigned const numReturnValues = _function.getReturnParameters().size();\n\tunsigned const numLocalVariables = _function.getLocalVariables().size();\n\n\tfor (ASTPointer<VariableDeclaration> const& variable: _function.getParameters() + _function.getReturnParameters())\n\t\tm_context.addVariable(*variable);\n\tfor (VariableDeclaration const* localVariable: _function.getLocalVariables())\n\t\tm_context.addVariable(*localVariable);\n\tm_context.initializeLocalVariables(numReturnValues + numLocalVariables);\n\n\t_function.getBody().accept(*this);\n\n\tm_context << m_returnTag;\n\n\t// Now we need to re-shuffle the stack. For this we keep a record of the stack layout\n\t// that shows the target positions of the elements, where \"-1\" denotes that this element needs\n\t// to be removed from the stack.\n\t// Note that the fact that the return arguments are of increasing index is vital for this\n\t// algorithm to work.\n\n\tvector<int> stackLayout;\n\tstackLayout.push_back(numReturnValues); // target of return address\n\tstackLayout += vector<int>(numArguments, -1); // discard all arguments\n\tfor (unsigned i = 0; i < numReturnValues; ++i)\n\t\tstackLayout.push_back(i);\n\tstackLayout += vector<int>(numLocalVariables, -1);\n\n\twhile (stackLayout.back() != int(stackLayout.size() - 1))\n\t\tif (stackLayout.back() < 0)\n\t\t{\n\t\t\tm_context << eth::Instruction::POP;\n\t\t\tstackLayout.pop_back();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_context << eth::swapInstruction(stackLayout.size() - stackLayout.back() - 1);\n\t\t\tswap(stackLayout[stackLayout.back()], stackLayout.back());\n\t\t}\n\n\tm_context << eth::Instruction::JUMP;\n\n\treturn false;\n}\n\nbool Compiler::visit(IfStatement& _ifStatement)\n{\n\tExpressionCompiler::compileExpression(m_context, _ifStatement.getCondition());\n\teth::AssemblyItem trueTag = m_context.appendConditionalJump();\n\tif (_ifStatement.getFalseStatement())\n\t\t_ifStatement.getFalseStatement()->accept(*this);\n\teth::AssemblyItem endTag = m_context.appendJump();\n\tm_context << trueTag;\n\t_ifStatement.getTrueStatement().accept(*this);\n\tm_context << endTag;\n\treturn false;\n}\n\nbool Compiler::visit(WhileStatement& _whileStatement)\n{\n\teth::AssemblyItem loopStart = m_context.newTag();\n\teth::AssemblyItem loopEnd = m_context.newTag();\n\tm_continueTags.push_back(loopStart);\n\tm_breakTags.push_back(loopEnd);\n\n\tm_context << loopStart;\n\tExpressionCompiler::compileExpression(m_context, _whileStatement.getCondition());\n\tm_context << eth::Instruction::ISZERO;\n\tm_context.appendConditionalJumpTo(loopEnd);\n\n\t_whileStatement.getBody().accept(*this);\n\n\tm_context.appendJumpTo(loopStart);\n\tm_context << loopEnd;\n\n\tm_continueTags.pop_back();\n\tm_breakTags.pop_back();\n\treturn false;\n}\n\nbool Compiler::visit(Continue&)\n{\n\tassert(!m_continueTags.empty());\n\tm_context.appendJumpTo(m_continueTags.back());\n\treturn false;\n}\n\nbool Compiler::visit(Break&)\n{\n\tassert(!m_breakTags.empty());\n\tm_context.appendJumpTo(m_breakTags.back());\n\treturn false;\n}\n\nbool Compiler::visit(Return& _return)\n{\n\t//@todo modifications are needed to make this work with functions returning multiple values\n\tif (Expression* expression = _return.getExpression())\n\t{\n\t\tExpressionCompiler::compileExpression(m_context, *expression);\n\t\tVariableDeclaration const& firstVariable = *_return.getFunctionReturnParameters().getParameters().front();\n\t\tExpressionCompiler::cleanHigherOrderBitsIfNeeded(*expression->getType(), *firstVariable.getType());\n\t\tint stackPosition = m_context.getStackPositionOfVariable(firstVariable);\n\t\tm_context << eth::swapInstruction(stackPosition) << eth::Instruction::POP;\n\t}\n\tm_context.appendJumpTo(m_returnTag);\n\treturn false;\n}\n\nbool Compiler::visit(VariableDefinition& _variableDefinition)\n{\n\tif (Expression* expression = _variableDefinition.getExpression())\n\t{\n\t\tExpressionCompiler::compileExpression(m_context, *expression);\n\t\tExpressionCompiler::cleanHigherOrderBitsIfNeeded(*expression->getType(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t *_variableDefinition.getDeclaration().getType());\n\t\tint stackPosition = m_context.getStackPositionOfVariable(_variableDefinition.getDeclaration());\n\t\tm_context << eth::swapInstruction(stackPosition) << eth::Instruction::POP;\n\t}\n\treturn false;\n}\n\nbool Compiler::visit(ExpressionStatement& _expressionStatement)\n{\n\tExpression& expression = _expressionStatement.getExpression();\n\tExpressionCompiler::compileExpression(m_context, expression);\n\tif (expression.getType()->getCategory() != Type::Category::VOID)\n\t\tm_context << eth::Instruction::POP;\n\treturn false;\n}\n\n}\n}",
        "lookback": "\tThis file is part of cpp-ethereum.",
        "lookahead": "",
        "label": [
            "newcode",
            "one_side_deletion"
        ],
        "start_line": 0,
        "end_line": 715,
        "merge_gen_region": " file part cppethum/* file part cppethum cppethum free: you redistribute and/ modify under terms the GNU Public as by Free Foundation either 3 the License orat option any version cppethum is in hope it it be, WITHOUT WARRANTY without the warranty MERCHANTABILITY FITNESS FOR PARTICULAR PURPOSE See GNU General License for details You have received copy the GNU Public along cppethum If, seehttpwwwgnuorglicenses */ *authorrist <@eth.> the warranty MERCHANTABILITY FITNESS FOR PARTICULAR PURPOSE See GNU Public for details You have received copy the GNU Public along cppethum If, seehttpwwwgnuorglicenses */ *authorrist <@eth.> *date *idity. # <>includelibityASThh # <solid/.>includelibityCompilerh # <libityExpression.> namespace; dev namespaceity { CompilercompileCon(_); compilermcontextgetAsledecode } CompilercompileCon(tract&contract { compiler compiler compilercompiletractcontract return._.sembByt(); void::Con(tract&contract {_ =Context // it in just case@ constructor@ register variables (AST<Definition const function _.DefinedFunctions mcontextadd(*);Function(_.DefinedFunctions forAST<Definition const function _.Defined",
        "confidence": 0.8975682258605957,
        "hesitated": false,
        "resolved": false
    }
]