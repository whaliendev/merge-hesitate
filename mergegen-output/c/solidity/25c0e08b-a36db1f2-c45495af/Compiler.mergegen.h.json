[
    {
        "a_contents": "/*\n\tThis file is part of cpp-ethereum.\n\n\tcpp-ethereum is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tcpp-ethereum is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License\n\talong with cpp-ethereum.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @author Christian <c@ethdev.com>\n * @date 2014\n * Solidity AST to EVM bytecode compiler.\n */\n\n#include <ostream>\n#include <libsolidity/ASTVisitor.h>\n#include <libsolidity/CompilerContext.h>\n\nnamespace dev {\nnamespace solidity {\n\nclass Compiler: private ASTVisitor\n{\npublic:\n\tCompiler(): m_returnTag(m_context.newTag()) {}\n\n\tvoid compileContract(ContractDefinition& _contract);\n\tbytes getAssembledBytecode() { return m_context.getAssembledBytecode(); }\n\tvoid streamAssembly(std::ostream& _stream) const { m_context.streamAssembly(_stream); }\n\n\t/// Compile the given contract and return the EVM bytecode.\n\tstatic bytes compile(ContractDefinition& _contract);\n\nprivate:\n\t/// Creates a new compiler context / assembly and packs the current code into the data part.\n\tvoid packIntoContractCreator();\n\tvoid appendFunctionSelector(std::vector<ASTPointer<FunctionDefinition> > const& _functions);\n\tvoid appendFunctionCallSection(FunctionDefinition const& _function);\n\tvoid appendCalldataUnpacker(FunctionDefinition const& _function);\n\tvoid appendReturnValuePacker(FunctionDefinition const& _function);\n\n\tvirtual bool visit(FunctionDefinition& _function) override;\n\tvirtual bool visit(IfStatement& _ifStatement) override;\n\tvirtual bool visit(WhileStatement& _whileStatement) override;\n\tvirtual bool visit(Continue& _continue) override;\n\tvirtual bool visit(Break& _break) override;\n\tvirtual bool visit(Return& _return) override;\n\tvirtual bool visit(VariableDefinition& _variableDefinition) override;\n\tvirtual bool visit(ExpressionStatement& _expressionStatement) override;\n\n\n\tCompilerContext m_context;\n\tstd::vector<eth::AssemblyItem> m_breakTags; ///< tag to jump to for a \"break\" statement\n\tstd::vector<eth::AssemblyItem> m_continueTags; ///< tag to jump to for a \"continue\" statement\n\teth::AssemblyItem m_returnTag; ///< tag to jump to for a \"return\" statement\n};\n\n}\n}",
        "b_contents": "/*\n\tThis file is part of cpp-ethereum.\n\n\tcpp-ethereum is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tcpp-ethereum is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License\n\talong with cpp-ethereum.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @author Christian <c@ethdev.com>\n * @date 2014\n * Solidity AST to EVM bytecode compiler.\n */\n\n#include <libevmface/Instruction.h>\n#include <libsolidity/ASTVisitor.h>\n#include <libsolidity/Types.h>\n#include <libsolidity/Token.h>\n\nnamespace dev {\nnamespace solidity {\n\n/**\n * A single item of compiled code that can be assembled to a single byte value in the final\n * bytecode. Its main purpose is to inject jump labels and label references into the opcode stream,\n * which can be resolved in the final step.\n */\nclass AssemblyItem\n{\npublic:\n\tenum class Type\n\t{\n\t\tCODE,    ///< m_data is opcode, m_label is empty.\n\t\tDATA,    ///< m_data is actual data, m_label is empty\n\t\tLABEL,   ///< m_data is JUMPDEST opcode, m_label is id of label\n\t\tLABELREF ///< m_data is empty, m_label is id of label\n\t};\n\n\texplicit AssemblyItem(eth::Instruction _instruction) : m_type(Type::CODE), m_data(byte(_instruction)) {}\n\texplicit AssemblyItem(byte _data): m_type(Type::DATA), m_data(_data) {}\n\n\t/// Factory functions\n\tstatic AssemblyItem labelRef(uint32_t _label) { return AssemblyItem(Type::LABELREF, 0, _label); }\n\tstatic AssemblyItem label(uint32_t _label) { return AssemblyItem(Type::LABEL, byte(eth::Instruction::JUMPDEST), _label); }\n\n\tType getType() const { return m_type; }\n\tbyte getData() const { return m_data; }\n\tuint32_t getLabel() const { return m_label; }\n\nprivate:\n\tAssemblyItem(Type _type, byte _data, uint32_t _label): m_type(_type), m_data(_data), m_label(_label) {}\n\n\tType m_type;\n\tbyte m_data; ///< data to be written to the bytecode stream (or filled by a label if this is a LABELREF)\n\tuint32_t m_label; ///< the id of a label either referenced or defined by this item\n};\n\nusing AssemblyItems = std::vector<AssemblyItem>;\n\n\n/**\n * Context to be shared by all units that compile the same contract. Its current usage only\n * concerns dispensing unique jump label IDs and storing their actual positions in the bytecode\n * stream.\n */\nclass CompilerContext\n{\npublic:\n\tCompilerContext(): m_nextLabel(0) {}\n\tuint32_t dispenseNewLabel() { return m_nextLabel++; }\n\tvoid setLabelPosition(uint32_t _label, uint32_t _position);\n\tuint32_t getLabelPosition(uint32_t _label) const;\n\nprivate:\n\tuint32_t m_nextLabel;\n\n\tstd::map<uint32_t, uint32_t> m_labelPositions;\n};\n\n/**\n * Compiler for expressions, i.e. converts an AST tree whose root is an Expression into a stream\n * of EVM instructions. It needs a compiler context that is the same for the whole compilation\n * unit.\n */\nclass ExpressionCompiler: public ASTVisitor\n{\npublic:\n\tExpressionCompiler(CompilerContext& _compilerContext): m_context(_compilerContext) {}\n\n\t/// Compile the given expression and (re-)populate the assembly item list.\n\tvoid compile(Expression& _expression);\n\tAssemblyItems const& getAssemblyItems() const { return m_assemblyItems; }\n\tbytes getAssembledBytecode() const;\n\n\t/// Compile the given expression and return the assembly items right away.\n\tstatic AssemblyItems compileExpression(CompilerContext& _context, Expression& _expression);\n\nprivate:\n\tvirtual void endVisit(Assignment& _assignment) override;\n\tvirtual void endVisit(UnaryOperation& _unaryOperation) override;\n\tvirtual bool visit(BinaryOperation& _binaryOperation) override;\n\tvirtual void endVisit(FunctionCall& _functionCall) override;\n\tvirtual void endVisit(MemberAccess& _memberAccess) override;\n\tvirtual void endVisit(IndexAccess& _indexAccess) override;\n\tvirtual void endVisit(Identifier& _identifier) override;\n\tvirtual void endVisit(Literal& _literal) override;\n\n\t/// Appends code to remove dirty higher order bits in case of an implicit promotion to a wider type.\n\tvoid cleanHigherOrderBitsIfNeeded(Type const& _typeOnStack, Type const& _targetType);\n\n\t///@{\n\t///@name Append code for various operator types\n\tvoid appendAndOrOperatorCode(BinaryOperation& _binaryOperation);\n\tvoid appendCompareOperatorCode(Token::Value _operator, Type const& _type);\n\tvoid appendOrdinaryBinaryOperatorCode(Token::Value _operator, Type const& _type);\n\n\tvoid appendArithmeticOperatorCode(Token::Value _operator, Type const& _type);\n\tvoid appendBitOperatorCode(Token::Value _operator);\n\tvoid appendShiftOperatorCode(Token::Value _operator);\n\t/// @}\n\n\t/// Appends a JUMPI instruction to a new label and returns the label\n\tuint32_t appendConditionalJump();\n\n\t/// Append elements to the current instruction list.\n\tvoid append(eth::Instruction const& _instruction) { m_assemblyItems.push_back(AssemblyItem(_instruction)); }\n\tvoid append(byte _value) { m_assemblyItems.push_back(AssemblyItem(_value)); }\n\tvoid append(bytes const& _data);\n\tvoid appendLabelref(byte _label) { m_assemblyItems.push_back(AssemblyItem::labelRef(_label)); }\n\tvoid appendLabel(byte _label) { m_assemblyItems.push_back(AssemblyItem::label(_label)); }\n\n\tAssemblyItems m_assemblyItems;\n\tCompilerContext& m_context;\n};\n\n\n}\n}",
        "base_contents": "",
        "res_region": "/*\n\tThis file is part of cpp-ethereum.\n\n\tcpp-ethereum is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tcpp-ethereum is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License\n\talong with cpp-ethereum.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @author Christian <c@ethdev.com>\n * @date 2014\n * Solidity AST to EVM bytecode compiler.\n */\n\n#include <ostream>\n#include <libsolidity/ASTVisitor.h>\n#include <libsolidity/CompilerContext.h>\n\nnamespace dev {\nnamespace solidity {\n\nclass Compiler: private ASTVisitor\n{\npublic:\n\tCompiler(): m_returnTag(m_context.newTag()) {}\n\n\tvoid compileContract(ContractDefinition& _contract);\n\tbytes getAssembledBytecode() { return m_context.getAssembledBytecode(); }\n\tvoid streamAssembly(std::ostream& _stream) const { m_context.streamAssembly(_stream); }\n\n\t/// Compile the given contract and return the EVM bytecode.\n\tstatic bytes compile(ContractDefinition& _contract);\n\nprivate:\n\t/// Creates a new compiler context / assembly and packs the current code into the data part.\n\tvoid packIntoContractCreator();\n\tvoid appendFunctionSelector(std::vector<ASTPointer<FunctionDefinition> > const& _functions);\n\tvoid appendFunctionCallSection(FunctionDefinition const& _function);\n\tvoid appendCalldataUnpacker(FunctionDefinition const& _function);\n\tvoid appendReturnValuePacker(FunctionDefinition const& _function);\n\n\tvirtual bool visit(FunctionDefinition& _function) override;\n\tvirtual bool visit(IfStatement& _ifStatement) override;\n\tvirtual bool visit(WhileStatement& _whileStatement) override;\n\tvirtual bool visit(Continue& _continue) override;\n\tvirtual bool visit(Break& _break) override;\n\tvirtual bool visit(Return& _return) override;\n\tvirtual bool visit(VariableDefinition& _variableDefinition) override;\n\tvirtual bool visit(ExpressionStatement& _expressionStatement) override;\n\n\n\tCompilerContext m_context;\n\tstd::vector<eth::AssemblyItem> m_breakTags; ///< tag to jump to for a \"break\" statement\n\tstd::vector<eth::AssemblyItem> m_continueTags; ///< tag to jump to for a \"continue\" statement\n\teth::AssemblyItem m_returnTag; ///< tag to jump to for a \"return\" statement\n};\n\n}\n}",
        "lookback": "\tThis file is part of cpp-ethereum.",
        "lookahead": "",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 0,
        "end_line": 216,
        "merge_gen_region": null,
        "confidence": 0.8417178988456726,
        "hesitated": true
    }
]