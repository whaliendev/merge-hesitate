[
    {
        "a_contents": "  // If xds_routing is not configured, only look at the last one in the route\n  // list (the default route)\n  size_t start_index = xds_routing_enabled ? 0 : size - 1;\n  for (size_t i = start_index; i < size; ++i) {\n    const envoy_api_v2_route_Route* route = routes[i];\n    const envoy_api_v2_route_RouteMatch* match =\n        envoy_api_v2_route_Route_match(route);\n    XdsApi::RdsRoute rds_route;\n    if (envoy_api_v2_route_RouteMatch_has_prefix(match)) {\n      upb_strview prefix = envoy_api_v2_route_RouteMatch_prefix(match);\n      if (prefix.size > 0) {\n        if (prefix.data[0] != '/') {\n          return GRPC_ERROR_CREATE_FROM_STATIC_STRING(\n              \"Prefix is not starting with a /\");\n        }\n        std::vector<absl::string_view> prefix_elements = absl::StrSplit(\n            absl::string_view(prefix.data, prefix.size).substr(1), '/');\n        if (prefix_elements.size() != 2) {\n          return GRPC_ERROR_CREATE_FROM_STATIC_STRING(\n              \"Prefix not in the required format of /service/\");\n        } else if (!prefix_elements[1].empty()) {\n          return GRPC_ERROR_CREATE_FROM_STATIC_STRING(\n              \"Prefix is not ending with a /\");\n        } else if (prefix_elements[0].empty()) {\n          return GRPC_ERROR_CREATE_FROM_STATIC_STRING(\"Prefix cannot be empty\");\n        }\n        rds_route.service = std::string(prefix_elements[0]);\n      }\n    } else if (envoy_api_v2_route_RouteMatch_has_path(match)) {\n      upb_strview path = envoy_api_v2_route_RouteMatch_path(match);\n      if (path.size == 0) {\n        return GRPC_ERROR_CREATE_FROM_STATIC_STRING(\n            \"Path if set cannot be empty\");\n      }\n      if (path.data[0] != '/') {\n        return GRPC_ERROR_CREATE_FROM_STATIC_STRING(\n            \"Path is not starting with a /\");\n      }\n      std::vector<absl::string_view> path_elements = absl::StrSplit(\n          absl::string_view(path.data, path.size).substr(1), '/');\n      if (path_elements.size() != 2) {\n        return GRPC_ERROR_CREATE_FROM_STATIC_STRING(\n            \"Path not in the required format of /service/method\");\n      } else if (path_elements[0].empty()) {\n        return GRPC_ERROR_CREATE_FROM_STATIC_STRING(\n            \"Path service name cannot be empty\");\n      } else if (path_elements[1].empty()) {\n        return GRPC_ERROR_CREATE_FROM_STATIC_STRING(\n            \"Path method name cannot be empty\");\n      }\n      rds_route.service = std::string(path_elements[0]);\n      rds_route.method = std::string(path_elements[1]);\n    } else {\n      // TODO(donnadionne): We may change this behavior once we decide how to\n      // handle unsupported fields.\n      continue;\n    }\n    if (!envoy_api_v2_route_Route_has_route(route)) {\n      return GRPC_ERROR_CREATE_FROM_STATIC_STRING(\n          \"No RouteAction found in route.\");\n    }\n    const envoy_api_v2_route_RouteAction* route_action =\n        envoy_api_v2_route_Route_route(route);\n    // Get the cluster in the RouteAction.\n    if (!envoy_api_v2_route_RouteAction_has_cluster(route_action)) {\n      return GRPC_ERROR_CREATE_FROM_STATIC_STRING(\n          \"No cluster found in RouteAction.\");\n    }\n    const upb_strview action =\n        envoy_api_v2_route_RouteAction_cluster(route_action);\n    if (action.size == 0) {\n      return GRPC_ERROR_CREATE_FROM_STATIC_STRING(\n          \"RouteAction has empty cluster.\");\n    }\n    rds_route.cluster_name = std::string(action.data, action.size);\n    rds_update->routes.emplace_back(std::move(rds_route));",
        "b_contents": "  // Only look at the last one in the route list (the default route),\n  const envoy_api_v2_route_Route* route = routes[size - 1];\n  // Validate that the match field must have a prefix field which is an empty\n  // string.\n  const envoy_api_v2_route_RouteMatch* match =\n      envoy_api_v2_route_Route_match(route);\n  if (!envoy_api_v2_route_RouteMatch_has_prefix(match)) {\n    return GRPC_ERROR_CREATE_FROM_STATIC_STRING(\n        \"No prefix field found in RouteMatch.\");\n  }\n  const upb_strview prefix = envoy_api_v2_route_RouteMatch_prefix(match);\n  if (!upb_strview_eql(prefix, upb_strview_makez(\"\")) &&\n      !upb_strview_eql(prefix, upb_strview_makez(\"/\"))) {\n    return GRPC_ERROR_CREATE_FROM_STATIC_STRING(\"Prefix is not \\\"\\\" or \\\"/\\\".\");\n  }\n  if (!envoy_api_v2_route_Route_has_route(route)) {\n    return GRPC_ERROR_CREATE_FROM_STATIC_STRING(\n        \"No RouteAction found in route.\");",
        "base_contents": "  // Only look at the last one in the route list (the default route),\n  const envoy_api_v2_route_Route* route = routes[size - 1];\n  // Validate that the match field must have a prefix field which is an empty\n  // string.\n  const envoy_api_v2_route_RouteMatch* match =\n      envoy_api_v2_route_Route_match(route);\n  if (!envoy_api_v2_route_RouteMatch_has_prefix(match)) {\n    return GRPC_ERROR_CREATE_FROM_STATIC_STRING(\n        \"No prefix field found in RouteMatch.\");\n  }\n  const upb_strview prefix = envoy_api_v2_route_RouteMatch_prefix(match);\n  if (!upb_strview_eql(prefix, upb_strview_makez(\"\"))) {\n    return GRPC_ERROR_CREATE_FROM_STATIC_STRING(\"Prefix is not empty string.\");\n  }\n  if (!envoy_api_v2_route_Route_has_route(route)) {\n    return GRPC_ERROR_CREATE_FROM_STATIC_STRING(\n        \"No RouteAction found in route.\");",
        "res_region": "  // If xds_routing is not configured, only look at the last one in the route\n  // list (the default route)\n  size_t start_index = xds_routing_enabled ? 0 : size - 1;\n  for (size_t i = start_index; i < size; ++i) {\n    const envoy_api_v2_route_Route* route = routes[i];\n    const envoy_api_v2_route_RouteMatch* match =\n        envoy_api_v2_route_Route_match(route);\n    XdsApi::RdsRoute rds_route;\n    if (envoy_api_v2_route_RouteMatch_has_prefix(match)) {\n      upb_strview prefix = envoy_api_v2_route_RouteMatch_prefix(match);\n      // Empty prefix \"\" is accepted.\n      if (prefix.size == 1) {\n        //Prefix \"/\" is accepted.\n        if (prefix.data[0] != '/') {\n          return GRPC_ERROR_CREATE_FROM_STATIC_STRING(\n              \"Prefix is not empty and does starting with a /\");\n        }\n      } else if (prefix.size > 1) {\n        if (prefix.data[0] != '/') {\n          return GRPC_ERROR_CREATE_FROM_STATIC_STRING(\n              \"Prefix is not starting with a /\");\n        }\n        std::vector<absl::string_view> prefix_elements = absl::StrSplit(\n            absl::string_view(prefix.data, prefix.size).substr(1), '/');\n        if (prefix_elements.size() != 2) {\n          return GRPC_ERROR_CREATE_FROM_STATIC_STRING(\n              \"Prefix not in the required format of /service/\");\n        } else if (!prefix_elements[1].empty()) {\n          return GRPC_ERROR_CREATE_FROM_STATIC_STRING(\n              \"Prefix is not ending with a /\");\n        } else if (prefix_elements[0].empty()) {\n          return GRPC_ERROR_CREATE_FROM_STATIC_STRING(\"Prefix cannot be empty\");\n        }\n        rds_route.service = std::string(prefix_elements[0]);\n      }\n    } else if (envoy_api_v2_route_RouteMatch_has_path(match)) {\n      upb_strview path = envoy_api_v2_route_RouteMatch_path(match);\n      if (path.size == 0) {\n        return GRPC_ERROR_CREATE_FROM_STATIC_STRING(\n            \"Path if set cannot be empty\");\n      }\n      if (path.data[0] != '/') {\n        return GRPC_ERROR_CREATE_FROM_STATIC_STRING(\n            \"Path is not starting with a /\");\n      }\n      std::vector<absl::string_view> path_elements = absl::StrSplit(\n          absl::string_view(path.data, path.size).substr(1), '/');\n      if (path_elements.size() != 2) {\n        return GRPC_ERROR_CREATE_FROM_STATIC_STRING(\n            \"Path not in the required format of /service/method\");\n      } else if (path_elements[0].empty()) {\n        return GRPC_ERROR_CREATE_FROM_STATIC_STRING(\n            \"Path service name cannot be empty\");\n      } else if (path_elements[1].empty()) {\n        return GRPC_ERROR_CREATE_FROM_STATIC_STRING(\n            \"Path method name cannot be empty\");\n      }\n      rds_route.service = std::string(path_elements[0]);\n      rds_route.method = std::string(path_elements[1]);\n    } else {\n      // TODO(donnadionne): We may change this behavior once we decide how to\n      // handle unsupported fields.\n      continue;\n    }\n    if (!envoy_api_v2_route_Route_has_route(route)) {\n      return GRPC_ERROR_CREATE_FROM_STATIC_STRING(\n          \"No RouteAction found in route.\");\n    }\n    const envoy_api_v2_route_RouteAction* route_action =\n        envoy_api_v2_route_Route_route(route);\n    // Get the cluster in the RouteAction.\n    if (!envoy_api_v2_route_RouteAction_has_cluster(route_action)) {\n      return GRPC_ERROR_CREATE_FROM_STATIC_STRING(\n          \"No cluster found in RouteAction.\");\n    }\n    const upb_strview action =\n        envoy_api_v2_route_RouteAction_cluster(route_action);\n    if (action.size == 0) {\n      return GRPC_ERROR_CREATE_FROM_STATIC_STRING(\n          \"RouteAction has empty cluster.\");\n    }\n    rds_route.cluster_name = std::string(action.data, action.size);\n    rds_update->routes.emplace_back(std::move(rds_route));",
        "lookback": "  // list (the default route)",
        "lookahead": "  }",
        "label": [
            "newcode",
            "complex_conflict"
        ],
        "start_line": 1015,
        "end_line": 1129,
        "merge_gen_region": null,
        "confidence": 0.8662803769111633,
        "hesitated": true
    }
]