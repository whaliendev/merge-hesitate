[
    {
        "a_contents": "",
        "b_contents": "const char* kXdsLocalityNameAttributeKey = \"xds_locality_name\";\n\n// TODO (donnadionne): Check to see if circuit breaking is enabled, this will be\n// removed once circuit breaking feature is fully integrated and enabled by\n// default.\nbool XdsCircuitBreakingEnabled() {\n  char* value = gpr_getenv(\"GRPC_XDS_EXPERIMENTAL_CIRCUIT_BREAKING\");\n  bool parsed_value;\n  bool parse_succeeded = gpr_parse_bool_value(value, &parsed_value);\n  gpr_free(value);\n  return parse_succeeded && parsed_value;\n}\n",
        "base_contents": "const char* kXdsLocalityNameAttributeKey = \"xds_locality_name\";\n",
        "res_region": "",
        "lookback": "class EdsLbConfig : public LoadBalancingPolicy::Config {",
        "lookahead": "// Config for EDS LB policy.",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 58,
        "end_line": 76,
        "merge_gen_region": null,
        "confidence": 0.6080145835876465,
        "hesitated": true
    },
    {
        "a_contents": "",
        "b_contents": "  // A simple wrapper for ref-counting a picker from the child policy.\n  class ChildPickerWrapper : public RefCounted<ChildPickerWrapper> {\n   public:\n    explicit ChildPickerWrapper(std::unique_ptr<SubchannelPicker> picker)\n        : picker_(std::move(picker)) {}\n    PickResult Pick(PickArgs args) { return picker_->Pick(args); }\n\n   private:\n    std::unique_ptr<SubchannelPicker> picker_;\n  };\n\n  // A picker that handles drops.\n  class EdsPicker : public SubchannelPicker {\n   public:\n    explicit EdsPicker(RefCountedPtr<EdsLb> eds_policy);\n\n    PickResult Pick(PickArgs args) override;\n\n   private:\n    RefCountedPtr<EdsLb> eds_policy_;\n    RefCountedPtr<XdsApi::EdsUpdate::DropConfig> drop_config_;\n    RefCountedPtr<XdsClusterDropStats> drop_stats_;\n    RefCountedPtr<ChildPickerWrapper> child_picker_;\n    bool xds_circuit_breaking_enabled_;\n    uint32_t max_concurrent_requests_;\n  };\n",
        "base_contents": "  // A simple wrapper for ref-counting a picker from the child policy.\n  class ChildPickerWrapper : public RefCounted<ChildPickerWrapper> {\n   public:\n    explicit ChildPickerWrapper(std::unique_ptr<SubchannelPicker> picker)\n        : picker_(std::move(picker)) {}\n    PickResult Pick(PickArgs args) { return picker_->Pick(args); }\n\n   private:\n    std::unique_ptr<SubchannelPicker> picker_;\n  };\n\n  // A picker that handles drops.\n  class EdsPicker : public SubchannelPicker {\n   public:\n    explicit EdsPicker(RefCountedPtr<EdsLb> eds_policy);\n\n    PickResult Pick(PickArgs args) override;\n\n   private:\n    RefCountedPtr<EdsLb> eds_policy_;\n    RefCountedPtr<XdsApi::EdsUpdate::DropConfig> drop_config_;\n    RefCountedPtr<XdsClusterDropStats> drop_stats_;\n    RefCountedPtr<ChildPickerWrapper> child_picker_;\n    uint32_t max_concurrent_requests_;\n  };\n",
        "res_region": "",
        "lookback": "   public:",
        "lookahead": "  class Helper : public ChannelControlHelper {",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 161,
        "end_line": 217,
        "merge_gen_region": " Helper publicControl",
        "confidence": 0.8988938927650452,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "",
        "b_contents": "// EdsLb::EdsPicker\n//\n\nEdsLb::EdsPicker::EdsPicker(RefCountedPtr<EdsLb> eds_policy)\n    : eds_policy_(std::move(eds_policy)),\n      drop_stats_(eds_policy_->drop_stats_),\n      child_picker_(eds_policy_->child_picker_),\n      xds_circuit_breaking_enabled_(XdsCircuitBreakingEnabled()),\n      max_concurrent_requests_(\n          eds_policy_->config_->max_concurrent_requests()) {\n  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_eds_trace)) {\n    gpr_log(GPR_INFO, \"[edslb %p] constructed new drop picker %p\",\n            eds_policy_.get(), this);\n  }\n}\n\nEdsLb::PickResult EdsLb::EdsPicker::Pick(PickArgs args) {\n  uint32_t current = eds_policy_->concurrent_requests_.FetchAdd(1);\n  if (xds_circuit_breaking_enabled_) {\n    // Check and see if we exceeded the max concurrent requests count.\n    if (current >= max_concurrent_requests_) {\n      eds_policy_->concurrent_requests_.FetchSub(1);\n      if (drop_stats_ != nullptr) {\n        drop_stats_->AddUncategorizedDrops();\n      }\n      PickResult result;\n      result.type = PickResult::PICK_COMPLETE;\n      return result;\n    }\n  }\n  // If we're not dropping the call, we should always have a child picker.\n  if (child_picker_ == nullptr) {  // Should never happen.\n    PickResult result;\n    result.type = PickResult::PICK_FAILED;\n    result.error =\n        grpc_error_set_int(GRPC_ERROR_CREATE_FROM_STATIC_STRING(\n                               \"eds drop picker not given any child picker\"),\n                           GRPC_ERROR_INT_GRPC_STATUS, GRPC_STATUS_INTERNAL);\n    eds_policy_->concurrent_requests_.FetchSub(1);\n    return result;\n  }\n  // Not dropping, so delegate to child's picker.\n  PickResult result = child_picker_->Pick(args);\n  if (result.type == result.PICK_COMPLETE && result.subchannel != nullptr) {\n    XdsClusterLocalityStats* locality_stats = nullptr;\n    if (drop_stats_ != nullptr) {  // If load reporting is enabled.\n      auto* subchannel_wrapper =\n          static_cast<StatsSubchannelWrapper*>(result.subchannel.get());\n      // Handle load reporting.\n      locality_stats = subchannel_wrapper->locality_stats()->Ref().release();\n      // Record a call started.\n      locality_stats->AddCallStarted();\n      // Unwrap subchannel to pass back up the stack.\n      result.subchannel = subchannel_wrapper->wrapped_subchannel();\n    }\n    // Intercept the recv_trailing_metadata op to record call completion.\n    EdsLb* eds_policy = static_cast<EdsLb*>(\n        eds_policy_->Ref(DEBUG_LOCATION, \"DropPickPicker+call\").release());\n    auto original_recv_trailing_metadata_ready =\n        result.recv_trailing_metadata_ready;\n    result.recv_trailing_metadata_ready =\n        // Note: This callback does not run in either the control plane\n        // work serializer or in the data plane mutex.\n        [locality_stats, original_recv_trailing_metadata_ready, eds_policy](\n            grpc_error* error, MetadataInterface* metadata,\n            CallState* call_state) {\n          // Record call completion for load reporting.\n          if (locality_stats != nullptr) {\n            const bool call_failed = error != GRPC_ERROR_NONE;\n            locality_stats->AddCallFinished(call_failed);\n            locality_stats->Unref(DEBUG_LOCATION, \"LocalityStats+call\");\n          }\n          // Decrement number of calls in flight.\n          eds_policy->concurrent_requests_.FetchSub(1);\n          eds_policy->Unref(DEBUG_LOCATION, \"DropPickPicker+call\");\n          // Invoke the original recv_trailing_metadata_ready callback, if any.\n          if (original_recv_trailing_metadata_ready != nullptr) {\n            original_recv_trailing_metadata_ready(error, metadata, call_state);\n          }\n        };\n  } else {\n    // TODO(roth): We should ideally also record call failures here in the case\n    // where a pick fails.  This is challenging, because we don't know which\n    // picks are for wait_for_ready RPCs or how many times we'll return a\n    // failure for the same wait_for_ready RPC.\n    eds_policy_->concurrent_requests_.FetchSub(1);\n  }\n  return result;\n}\n\n//",
        "base_contents": "// EdsLb::EdsPicker\n//\n\nEdsLb::EdsPicker::EdsPicker(RefCountedPtr<EdsLb> eds_policy)\n    : eds_policy_(std::move(eds_policy)),\n      drop_stats_(eds_policy_->drop_stats_),\n      child_picker_(eds_policy_->child_picker_),\n      max_concurrent_requests_(\n          eds_policy_->config_->max_concurrent_requests()) {\n  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_eds_trace)) {\n    gpr_log(GPR_INFO, \"[edslb %p] constructed new drop picker %p\",\n            eds_policy_.get(), this);\n  }\n}\n\nEdsLb::PickResult EdsLb::EdsPicker::Pick(PickArgs args) {\n  // Check and see if we exceeded the max concurrent requests count.\n  uint32_t current = eds_policy_->concurrent_requests_.FetchAdd(1);\n  if (current >= max_concurrent_requests_) {\n    eds_policy_->concurrent_requests_.FetchSub(1);\n    if (drop_stats_ != nullptr) {\n      drop_stats_->AddUncategorizedDrops();\n    }\n    PickResult result;\n    result.type = PickResult::PICK_COMPLETE;\n    return result;\n  }\n  // If we're not dropping the call, we should always have a child picker.\n  if (child_picker_ == nullptr) {  // Should never happen.\n    PickResult result;\n    result.type = PickResult::PICK_FAILED;\n    result.error =\n        grpc_error_set_int(GRPC_ERROR_CREATE_FROM_STATIC_STRING(\n                               \"eds drop picker not given any child picker\"),\n                           GRPC_ERROR_INT_GRPC_STATUS, GRPC_STATUS_INTERNAL);\n    eds_policy_->concurrent_requests_.FetchSub(1);\n    return result;\n  }\n  // Not dropping, so delegate to child's picker.\n  PickResult result = child_picker_->Pick(args);\n  if (result.type == result.PICK_COMPLETE && result.subchannel != nullptr) {\n    XdsClusterLocalityStats* locality_stats = nullptr;\n    if (drop_stats_ != nullptr) {  // If load reporting is enabled.\n      auto* subchannel_wrapper =\n          static_cast<StatsSubchannelWrapper*>(result.subchannel.get());\n      // Handle load reporting.\n      locality_stats = subchannel_wrapper->locality_stats()->Ref().release();\n      // Record a call started.\n      locality_stats->AddCallStarted();\n      // Unwrap subchannel to pass back up the stack.\n      result.subchannel = subchannel_wrapper->wrapped_subchannel();\n    }\n    // Intercept the recv_trailing_metadata op to record call completion.\n    EdsLb* eds_policy = static_cast<EdsLb*>(\n        eds_policy_->Ref(DEBUG_LOCATION, \"DropPickPicker+call\").release());\n    auto original_recv_trailing_metadata_ready =\n        result.recv_trailing_metadata_ready;\n    result.recv_trailing_metadata_ready =\n        // Note: This callback does not run in either the control plane\n        // work serializer or in the data plane mutex.\n        [locality_stats, original_recv_trailing_metadata_ready, eds_policy](\n            grpc_error* error, MetadataInterface* metadata,\n            CallState* call_state) {\n          // Record call completion for load reporting.\n          if (locality_stats != nullptr) {\n            const bool call_failed = error != GRPC_ERROR_NONE;\n            locality_stats->AddCallFinished(call_failed);\n            locality_stats->Unref(DEBUG_LOCATION, \"LocalityStats+call\");\n          }\n          // Decrement number of calls in flight.\n          eds_policy->concurrent_requests_.FetchSub(1);\n          eds_policy->Unref(DEBUG_LOCATION, \"DropPickPicker+call\");\n          // Invoke the original recv_trailing_metadata_ready callback, if any.\n          if (original_recv_trailing_metadata_ready != nullptr) {\n            original_recv_trailing_metadata_ready(error, metadata, call_state);\n          }\n        };\n  } else {\n    // TODO(roth): We should ideally also record call failures here in the case\n    // where a pick fails.  This is challenging, because we don't know which\n    // picks are for wait_for_ready RPCs or how many times we'll return a\n    // failure for the same wait_for_ready RPC.\n    eds_policy_->concurrent_requests_.FetchSub(1);\n  }\n  return result;\n}\n\n//",
        "res_region": "",
        "lookback": "//",
        "lookahead": "// EdsLb::Helper",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 302,
        "end_line": 484,
        "merge_gen_region": " EL::ResultdsbEdPickerPickPickPick args {",
        "confidence": 0.9111670255661011,
        "hesitated": false,
        "resolved": false
    }
]