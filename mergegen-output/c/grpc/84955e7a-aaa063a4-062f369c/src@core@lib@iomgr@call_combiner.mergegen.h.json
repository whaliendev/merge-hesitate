[
    {
        "a_contents": "namespace grpc_core {\n\n// Helper for running a list of closures in a call combiner.\n//\n// Each callback running in the call combiner will eventually be\n// returned to the surface, at which point the surface will yield the\n// call combiner.  So when we are running in the call combiner and have\n// more than one callback to return to the surface, we need to re-enter\n// the call combiner for all but one of those callbacks.\nclass CallCombinerClosureList {\n public:\n  CallCombinerClosureList() {}\n\n  // Adds a closure to the list.  The closure must eventually result in\n  // the call combiner being yielded.\n  void Add(grpc_closure* closure, grpc_error* error, const char* reason) {\n    closures_.emplace_back(closure, error, reason);\n  }\n\n  // Runs all closures in the call combiner and yields the call combiner.\n  //\n  // All but one of the closures in the list will be scheduled via\n  // GRPC_CALL_COMBINER_START(), and the remaining closure will be\n  // scheduled via GRPC_CLOSURE_SCHED(), which will eventually result in\n  // yielding the call combiner.  If the list is empty, then the call\n  // combiner will be yielded immediately.\n  void RunClosures(grpc_call_combiner* call_combiner) {\n    if (closures_.empty()) {\n      GRPC_CALL_COMBINER_STOP(call_combiner, \"no closures to schedule\");\n      return;\n    }\n    for (size_t i = 1; i < closures_.size(); ++i) {\n      auto& closure = closures_[i];\n      GRPC_CALL_COMBINER_START(call_combiner, closure.closure, closure.error,\n                               closure.reason);\n    }\n    if (grpc_call_combiner_trace.enabled()) {\n      gpr_log(GPR_INFO,\n              \"CallCombinerClosureList executing closure while already \"\n              \"holding call_combiner %p: closure=%p error=%s reason=%s\",\n              call_combiner, closures_[0].closure,\n              grpc_error_string(closures_[0].error), closures_[0].reason);\n    }\n    // This will release the call combiner.\n    GRPC_CLOSURE_SCHED(closures_[0].closure, closures_[0].error);\n    closures_.clear();\n  }\n\n  // Runs all closures in the call combiner, but does NOT yield the call\n  // combiner.  All closures will be scheduled via GRPC_CALL_COMBINER_START().\n  void RunClosuresWithoutYielding(grpc_call_combiner* call_combiner) {\n    for (size_t i = 0; i < closures_.size(); ++i) {\n      auto& closure = closures_[i];\n      GRPC_CALL_COMBINER_START(call_combiner, closure.closure, closure.error,\n                               closure.reason);\n    }\n    closures_.clear();\n  }\n\n  size_t size() const { return closures_.size(); }\n\n private:\n  struct CallCombinerClosure {\n    grpc_closure* closure;\n    grpc_error* error;\n    const char* reason;\n\n    CallCombinerClosure(grpc_closure* closure, grpc_error* error,\n                        const char* reason)\n        : closure(closure), error(error), reason(reason) {}\n  };\n\n  // There are generally a maximum of 6 closures to run in the call\n  // combiner, one for each pending op.\n  InlinedVector<CallCombinerClosure, 6> closures_;\n};\n\n}  // namespace grpc_core\n",
        "b_contents": "",
        "base_contents": "namespace grpc_core {\n\n// Helper for running a list of closures in a call combiner.\n//\n// Each callback running in the call combiner will eventually be\n// returned to the surface, at which point the surface will yield the\n// call combiner.  So when we are running in the call combiner and have\n// more than one callback to return to the surface, we need to re-enter\n// the call combiner for all but one of those callbacks.\nclass CallCombinerClosureList {\n public:\n  CallCombinerClosureList() {}\n\n  // Adds a closure to the list.  The closure must eventually result in\n  // the call combiner being yielded.\n  void Add(grpc_closure* closure, grpc_error* error, const char* reason) {\n    closures_.emplace_back(closure, error, reason);\n  }\n\n  // Runs all closures in the call combiner and yields the call combiner.\n  //\n  // All but one of the closures in the list will be scheduled via\n  // GRPC_CALL_COMBINER_START(), and the remaining closure will be\n  // scheduled via GRPC_CLOSURE_SCHED(), which will eventually result in\n  // yielding the call combiner.  If the list is empty, then the call\n  // combiner will be yielded immediately.\n  void RunClosures(grpc_call_combiner* call_combiner) {\n    for (size_t i = 1; i < closures_.size(); ++i) {\n      auto& closure = closures_[i];\n      GRPC_CALL_COMBINER_START(call_combiner, closure.closure, closure.error,\n                               closure.reason);\n    }\n    if (closures_.size() > 0) {\n      if (grpc_call_combiner_trace.enabled()) {\n        gpr_log(GPR_INFO,\n                \"CallCombinerClosureList executing closure while already \"\n                \"holding call_combiner %p: closure=%p error=%s reason=%s\",\n                call_combiner, closures_[0].closure,\n                grpc_error_string(closures_[0].error), closures_[0].reason);\n      }\n      // This will release the call combiner.\n      GRPC_CLOSURE_SCHED(closures_[0].closure, closures_[0].error);\n    } else {\n      GRPC_CALL_COMBINER_STOP(call_combiner, \"no closures to schedule\");\n    }\n    closures_.clear();\n  }\n\n  // Runs all closures in the call combiner, but does NOT yield the call\n  // combiner.  All closures will be scheduled via GRPC_CALL_COMBINER_START().\n  void RunClosuresWithoutYielding(grpc_call_combiner* call_combiner) {\n    for (size_t i = 0; i < closures_.size(); ++i) {\n      auto& closure = closures_[i];\n      GRPC_CALL_COMBINER_START(call_combiner, closure.closure, closure.error,\n                               closure.reason);\n    }\n    closures_.clear();\n  }\n\n  size_t size() const { return closures_.size(); }\n\n private:\n  struct CallCombinerClosure {\n    grpc_closure* closure;\n    grpc_error* error;\n    const char* reason;\n\n    CallCombinerClosure(grpc_closure* closure, grpc_error* error,\n                        const char* reason)\n        : closure(closure), error(error), reason(reason) {}\n  };\n\n  // There are generally a maximum of 6 closures to run in the call\n  // combiner, one for each pending op.\n  InlinedVector<CallCombinerClosure, 6> closures_;\n};\n\n}  // namespace grpc_core\n",
        "res_region": "namespace grpc_core {\n\n// Helper for running a list of closures in a call combiner.\n//\n// Each callback running in the call combiner will eventually be\n// returned to the surface, at which point the surface will yield the\n// call combiner.  So when we are running in the call combiner and have\n// more than one callback to return to the surface, we need to re-enter\n// the call combiner for all but one of those callbacks.\nclass CallCombinerClosureList {\n public:\n  CallCombinerClosureList() {}\n\n  // Adds a closure to the list.  The closure must eventually result in\n  // the call combiner being yielded.\n  void Add(grpc_closure* closure, grpc_error* error, const char* reason) {\n    closures_.emplace_back(closure, error, reason);\n  }\n\n  // Runs all closures in the call combiner and yields the call combiner.\n  //\n  // All but one of the closures in the list will be scheduled via\n  // GRPC_CALL_COMBINER_START(), and the remaining closure will be\n  // scheduled via GRPC_CLOSURE_SCHED(), which will eventually result in\n  // yielding the call combiner.  If the list is empty, then the call\n  // combiner will be yielded immediately.\n  void RunClosures(grpc_call_combiner* call_combiner) {\n    if (closures_.empty()) {\n      GRPC_CALL_COMBINER_STOP(call_combiner, \"no closures to schedule\");\n      return;\n    }\n    for (size_t i = 1; i < closures_.size(); ++i) {\n      auto& closure = closures_[i];\n      GRPC_CALL_COMBINER_START(call_combiner, closure.closure, closure.error,\n                               closure.reason);\n    }\n    if (grpc_call_combiner_trace.enabled()) {\n      gpr_log(GPR_INFO,\n              \"CallCombinerClosureList executing closure while already \"\n              \"holding call_combiner %p: closure=%p error=%s reason=%s\",\n              call_combiner, closures_[0].closure,\n              grpc_error_string(closures_[0].error), closures_[0].reason);\n    }\n    // This will release the call combiner.\n    GRPC_CLOSURE_SCHED(closures_[0].closure, closures_[0].error);\n    closures_.clear();\n  }\n\n  // Runs all closures in the call combiner, but does NOT yield the call\n  // combiner.  All closures will be scheduled via GRPC_CALL_COMBINER_START().\n  void RunClosuresWithoutYielding(grpc_call_combiner* call_combiner) {\n    for (size_t i = 0; i < closures_.size(); ++i) {\n      auto& closure = closures_[i];\n      GRPC_CALL_COMBINER_START(call_combiner, closure.closure, closure.error,\n                               closure.reason);\n    }\n    closures_.clear();\n  }\n\n  size_t size() const { return closures_.size(); }\n\n private:\n  struct CallCombinerClosure {\n    grpc_closure* closure;\n    grpc_error* error;\n    const char* reason;\n\n    CallCombinerClosure(grpc_closure* closure, grpc_error* error,\n                        const char* reason)\n        : closure(closure), error(error), reason(reason) {}\n  };\n\n  // There are generally a maximum of 6 closures to run in the call\n  // combiner, one for each pending op.\n  InlinedVector<CallCombinerClosure, 6> closures_;\n};\n\n}  // namespace grpc_core\n",
        "lookback": "",
        "lookahead": "#endif /* GRPC_CORE_LIB_IOMGR_CALL_COMBINER_H */",
        "label": [
            "ours",
            "base_empty"
        ],
        "start_line": 111,
        "end_line": 272,
        "merge_gen_region": null,
        "confidence": 0.6393851041793823,
        "hesitated": true
    }
]