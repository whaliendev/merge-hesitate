[
    {
        "a_contents": "  grpc_closure recv_trailing_metadata_ready;",
        "b_contents": "  // For intercepting on_complete.\n  grpc_closure on_complete;\n} subchannel_batch_data;\n\n// Retry state associated with a subchannel call.\n// Stored in the parent_data of the subchannel call object.\ntypedef struct {\n  // subchannel_batch_data.batch.payload points to this.\n  grpc_transport_stream_op_batch_payload batch_payload;",
        "base_contents": "  grpc_closure recv_trailing_metadata_ready;\n  // For intercepting on_complete.\n  grpc_closure on_complete;\n} subchannel_batch_data;\n\n// Retry state associated with a subchannel call.\n// Stored in the parent_data of the subchannel call object.\ntypedef struct {\n  // subchannel_batch_data.batch.payload points to this.\n  grpc_transport_stream_op_batch_payload batch_payload;",
        "res_region": "  grpc_closure recv_trailing_metadata_ready;",
        "lookback": "  // These fields indicate which ops have been started and completed on",
        "lookahead": "  // These fields indicate which ops have been started and completed on",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 828,
        "end_line": 851,
        "merge_gen_region": null,
        "confidence": 0.4783478379249573,
        "hesitated": true
    },
    {
        "a_contents": "  // the recv_trailing_metadata_ready callback, then defer propagating this\n  // callback back to the surface.  We can evaluate whether to retry when\n  // recv_trailing_metadata comes back.\n  if (GPR_UNLIKELY((retry_state->trailing_metadata_available ||",
        "b_contents": "  // the recv_trailing_metadata on_complete callback, then defer\n  // propagating this callback back to the surface.  We can evaluate whether\n  // to retry when recv_trailing_metadata comes back.\n  if (GPR_UNLIKELY((batch_data->trailing_metadata_available ||",
        "base_contents": "  // the recv_trailing_metadata_ready callback, then defer propagating this\n  // callback back to the surface.  We can evaluate whether to retry when\n  // recv_trailing_metadata comes back.\n  if (GPR_UNLIKELY((batch_data->trailing_metadata_available ||",
        "res_region": "  // the recv_trailing_metadata_ready callback, then defer propagating this\n  // callback back to the surface.  We can evaluate whether to retry when\n  // recv_trailing_metadata comes back.\n  if (GPR_UNLIKELY((retry_state->trailing_metadata_available ||",
        "lookback": "  // callback back to the surface.  We can evaluate whether to retry when",
        "lookahead": "                    error != GRPC_ERROR_NONE) &&",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 1696,
        "end_line": 1711,
        "merge_gen_region": null,
        "confidence": 0.8008094429969788,
        "hesitated": true
    },
    {
        "a_contents": "// Sets *status and *server_pushback_md based on batch_data and error.\nstatic void get_call_status(subchannel_batch_data* batch_data,\n                            grpc_error* error, grpc_status_code* status,\n                            grpc_mdelem** server_pushback_md) {\n  grpc_call_element* elem = batch_data->elem;\n  call_data* calld = static_cast<call_data*>(elem->call_data);\n  if (error != GRPC_ERROR_NONE) {\n    grpc_error_get_status(error, calld->deadline, status, nullptr, nullptr,\n                          nullptr);\n  } else {\n    grpc_metadata_batch* md_batch =\n        batch_data->batch.payload->recv_trailing_metadata\n            .recv_trailing_metadata;\n    GPR_ASSERT(md_batch->idx.named.grpc_status != nullptr);\n    *status =\n        grpc_get_status_code_from_metadata(md_batch->idx.named.grpc_status->md);\n    if (md_batch->idx.named.grpc_retry_pushback_ms != nullptr) {\n      *server_pushback_md = &md_batch->idx.named.grpc_retry_pushback_ms->md;\n    }\n  }\n  GRPC_ERROR_UNREF(error);\n}\n\n// Adds recv_trailing_metadata_ready closure to closures.\nstatic void add_closure_for_recv_trailing_metadata_ready(\n    grpc_call_element* elem, subchannel_batch_data* batch_data,\n    grpc_error* error, grpc_core::CallCombinerClosureList* closures) {\n  // Find pending batch.\n  pending_batch* pending = pending_batch_find(\n      elem, \"invoking recv_trailing_metadata for\",\n      [](grpc_transport_stream_op_batch* batch) {\n        return batch->recv_trailing_metadata &&\n               batch->payload->recv_trailing_metadata\n                       .recv_trailing_metadata_ready != nullptr;\n      });\n  // If we generated the recv_trailing_metadata op internally via\n  // start_internal_recv_trailing_metadata(), then there will be no\n  // pending batch.\n  if (pending == nullptr) {\n    GRPC_ERROR_UNREF(error);\n    return;",
        "b_contents": "// Represents a closure that needs to run in the call combiner as part of\n// starting or completing a batch.\ntypedef struct {\n  grpc_closure* closure;\n  grpc_error* error;\n  const char* reason;\n  bool free_reason = false;\n} closure_to_execute;\n\nstatic void execute_closures_in_call_combiner(grpc_call_element* elem,\n                                              const char* caller,\n                                              closure_to_execute* closures,\n                                              size_t num_closures) {\n  channel_data* chand = static_cast<channel_data*>(elem->channel_data);\n  call_data* calld = static_cast<call_data*>(elem->call_data);\n  // Note that the call combiner will be yielded for each closure that\n  // we schedule.  We're already running in the call combiner, so one of\n  // the closures can be scheduled directly, but the others will\n  // have to re-enter the call combiner.\n  if (num_closures > 0) {\n    if (grpc_client_channel_trace.enabled()) {\n      gpr_log(GPR_INFO, \"chand=%p calld=%p: %s starting closure: %s\", chand,\n              calld, caller, closures[0].reason);\n    }\n    GRPC_CLOSURE_SCHED(closures[0].closure, closures[0].error);\n    if (closures[0].free_reason) {\n      gpr_free(const_cast<char*>(closures[0].reason));\n    }\n    for (size_t i = 1; i < num_closures; ++i) {\n      if (grpc_client_channel_trace.enabled()) {\n        gpr_log(GPR_INFO,\n                \"chand=%p calld=%p: %s starting closure in call combiner: %s\",\n                chand, calld, caller, closures[i].reason);\n      }\n      GRPC_CALL_COMBINER_START(calld->call_combiner, closures[i].closure,\n                               closures[i].error, closures[i].reason);\n      if (closures[i].free_reason) {\n        gpr_free(const_cast<char*>(closures[i].reason));\n      }\n    }\n  } else {\n    if (grpc_client_channel_trace.enabled()) {\n      gpr_log(GPR_INFO, \"chand=%p calld=%p: no closures to run for %s\", chand,\n              calld, caller);\n    }\n    GRPC_CALL_COMBINER_STOP(calld->call_combiner, \"no closures to run\");\n  }\n}\n\n//\n// on_complete callback handling\n//\n\n// Updates retry_state to reflect the ops completed in batch_data.\nstatic void update_retry_state_for_completed_batch(\n    subchannel_batch_data* batch_data,\n    subchannel_call_retry_state* retry_state) {\n  if (batch_data->batch.send_initial_metadata) {\n    retry_state->completed_send_initial_metadata = true;\n  }\n  if (batch_data->batch.send_message) {\n    ++retry_state->completed_send_message_count;\n  }\n  if (batch_data->batch.send_trailing_metadata) {\n    retry_state->completed_send_trailing_metadata = true;\n  }\n  if (batch_data->batch.recv_initial_metadata) {\n    retry_state->completed_recv_initial_metadata = true;\n  }\n  if (batch_data->batch.recv_message) {\n    ++retry_state->completed_recv_message_count;\n  }\n  if (batch_data->batch.recv_trailing_metadata) {\n    retry_state->completed_recv_trailing_metadata = true;",
        "base_contents": "// Adds recv_trailing_metadata_ready closure to closures.\nstatic void add_closure_for_recv_trailing_metadata_ready(\n    grpc_call_element* elem, subchannel_batch_data* batch_data,\n    grpc_error* error, grpc_core::CallCombinerClosureList* closures) {\n  // Find pending batch.\n  pending_batch* pending = pending_batch_find(\n      elem, \"invoking recv_trailing_metadata for\",\n      [](grpc_transport_stream_op_batch* batch) {\n        return batch->recv_trailing_metadata &&\n               batch->payload->recv_trailing_metadata\n                       .recv_trailing_metadata_ready != nullptr;\n      });\n  // If we generated the recv_trailing_metadata op internally via\n  // start_internal_recv_trailing_metadata(), then there will be no\n  // pending batch.\n  if (pending == nullptr) {\n    GRPC_ERROR_UNREF(error);\n    return;",
        "res_region": "// Sets *status and *server_pushback_md based on batch_data and error.\nstatic void get_call_status(subchannel_batch_data* batch_data,\n                            grpc_error* error, grpc_status_code* status,\n                            grpc_mdelem** server_pushback_md) {\n  grpc_call_element* elem = batch_data->elem;\n  call_data* calld = static_cast<call_data*>(elem->call_data);\n  if (error != GRPC_ERROR_NONE) {\n    grpc_error_get_status(error, calld->deadline, status, nullptr, nullptr,\n                          nullptr);\n  } else {\n    grpc_metadata_batch* md_batch =\n        batch_data->batch.payload->recv_trailing_metadata\n            .recv_trailing_metadata;\n    GPR_ASSERT(md_batch->idx.named.grpc_status != nullptr);\n    *status =\n        grpc_get_status_code_from_metadata(md_batch->idx.named.grpc_status->md);\n    if (md_batch->idx.named.grpc_retry_pushback_ms != nullptr) {\n      *server_pushback_md = &md_batch->idx.named.grpc_retry_pushback_ms->md;\n    }\n  }\n  GRPC_ERROR_UNREF(error);\n}\n\n// Adds recv_trailing_metadata_ready closure to closures.\nstatic void add_closure_for_recv_trailing_metadata_ready(\n    grpc_call_element* elem, subchannel_batch_data* batch_data,\n    grpc_error* error, grpc_core::CallCombinerClosureList* closures) {\n  // Find pending batch.\n  pending_batch* pending = pending_batch_find(\n      elem, \"invoking recv_trailing_metadata for\",\n      [](grpc_transport_stream_op_batch* batch) {\n        return batch->recv_trailing_metadata &&\n               batch->payload->recv_trailing_metadata\n                       .recv_trailing_metadata_ready != nullptr;\n      });\n  // If we generated the recv_trailing_metadata op internally via\n  // start_internal_recv_trailing_metadata(), then there will be no\n  // pending batch.\n  if (pending == nullptr) {\n    GRPC_ERROR_UNREF(error);\n    return;\n  }",
        "lookback": "static void get_call_status(subchannel_batch_data* batch_data,",
        "lookahead": "  // Return metadata.",
        "label": [
            "interleave",
            "complex_conflict"
        ],
        "start_line": 1836,
        "end_line": 1972,
        "merge_gen_region": null,
        "confidence": 0.6387541890144348,
        "hesitated": true
    },
    {
        "a_contents": "  // Return metadata.\n  subchannel_call_retry_state* retry_state =\n      static_cast<subchannel_call_retry_state*>(\n          grpc_connected_subchannel_call_get_parent_data(\n              batch_data->subchannel_call));\n  grpc_metadata_batch_move(\n      &retry_state->recv_trailing_metadata,\n      pending->batch->payload->recv_trailing_metadata.recv_trailing_metadata);\n  // Add closure.\n  closures->Add(pending->batch->payload->recv_trailing_metadata\n                    .recv_trailing_metadata_ready,\n                error, \"recv_trailing_metadata_ready for pending batch\");\n  // Update bookkeeping.\n  pending->batch->payload->recv_trailing_metadata.recv_trailing_metadata_ready =\n      nullptr;\n  maybe_clear_pending_batch(elem, pending);",
        "b_contents": "",
        "base_contents": "  // Return metadata.\n  grpc_metadata_batch_move(\n      &batch_data->recv_trailing_metadata,\n      pending->batch->payload->recv_trailing_metadata.recv_trailing_metadata);\n  // Add closure.\n  closures->Add(pending->batch->payload->recv_trailing_metadata\n                    .recv_trailing_metadata_ready,\n                error, \"recv_trailing_metadata_ready for pending batch\");\n  // Update bookkeeping.\n  pending->batch->payload->recv_trailing_metadata.recv_trailing_metadata_ready =\n      nullptr;\n  maybe_clear_pending_batch(elem, pending);",
        "res_region": "  // Return metadata.\n  subchannel_call_retry_state* retry_state =\n      static_cast<subchannel_call_retry_state*>(\n          grpc_connected_subchannel_call_get_parent_data(\n              batch_data->subchannel_call));\n  grpc_metadata_batch_move(\n      &retry_state->recv_trailing_metadata,\n      pending->batch->payload->recv_trailing_metadata.recv_trailing_metadata);\n  // Add closure.\n  closures->Add(pending->batch->payload->recv_trailing_metadata\n                    .recv_trailing_metadata_ready,\n                error, \"recv_trailing_metadata_ready for pending batch\");\n  // Update bookkeeping.\n  pending->batch->payload->recv_trailing_metadata.recv_trailing_metadata_ready =\n      nullptr;\n  maybe_clear_pending_batch(elem, pending);",
        "lookback": "  subchannel_call_retry_state* retry_state =",
        "lookahead": "}",
        "label": [
            "ours",
            "base_empty"
        ],
        "start_line": 1974,
        "end_line": 2005,
        "merge_gen_region": null,
        "confidence": 0.4222687780857086,
        "hesitated": true
    },
    {
        "a_contents": "      GRPC_CLOSURE_INIT(&retry_state->recv_initial_metadata_ready,\n                        invoke_recv_initial_metadata_callback,\n                        retry_state->recv_initial_metadata_ready_deferred_batch,\n                        grpc_schedule_on_exec_ctx);\n      closures->Add(&retry_state->recv_initial_metadata_ready,\n                    retry_state->recv_initial_metadata_error,\n                    \"resuming recv_initial_metadata_ready\");",
        "b_contents": "      closure_to_execute* closure = &closures[(*num_closures)++];\n      closure->closure = GRPC_CLOSURE_INIT(\n          &batch_data->recv_initial_metadata_ready,\n          invoke_recv_initial_metadata_callback,\n          retry_state->recv_initial_metadata_ready_deferred_batch,\n          grpc_schedule_on_exec_ctx);\n      closure->error = retry_state->recv_initial_metadata_error;\n      closure->reason = \"resuming recv_initial_metadata_ready\";",
        "base_contents": "      GRPC_CLOSURE_INIT(&batch_data->recv_initial_metadata_ready,\n                        invoke_recv_initial_metadata_callback,\n                        retry_state->recv_initial_metadata_ready_deferred_batch,\n                        grpc_schedule_on_exec_ctx);\n      closures->Add(&batch_data->recv_initial_metadata_ready,\n                    retry_state->recv_initial_metadata_error,\n                    \"resuming recv_initial_metadata_ready\");",
        "res_region": "      GRPC_CLOSURE_INIT(&retry_state->recv_initial_metadata_ready,\n                        invoke_recv_initial_metadata_callback,\n                        retry_state->recv_initial_metadata_ready_deferred_batch,\n                        grpc_schedule_on_exec_ctx);\n      closures->Add(&retry_state->recv_initial_metadata_ready,\n                    retry_state->recv_initial_metadata_error,\n                    \"resuming recv_initial_metadata_ready\");",
        "lookback": "                        invoke_recv_initial_metadata_callback,",
        "lookahead": "      retry_state->recv_initial_metadata_ready_deferred_batch = nullptr;",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 2017,
        "end_line": 2042,
        "merge_gen_region": null,
        "confidence": 0.8748328685760498,
        "hesitated": true
    },
    {
        "a_contents": "      GRPC_CLOSURE_INIT(&retry_state->recv_message_ready,\n                        invoke_recv_message_callback,\n                        retry_state->recv_message_ready_deferred_batch,\n                        grpc_schedule_on_exec_ctx);\n      closures->Add(&retry_state->recv_message_ready,\n                    retry_state->recv_message_error,\n                    \"resuming recv_message_ready\");",
        "b_contents": "      closure_to_execute* closure = &closures[(*num_closures)++];\n      closure->closure = GRPC_CLOSURE_INIT(\n          &batch_data->recv_message_ready, invoke_recv_message_callback,\n          retry_state->recv_message_ready_deferred_batch,\n          grpc_schedule_on_exec_ctx);\n      closure->error = retry_state->recv_message_error;\n      closure->reason = \"resuming recv_message_ready\";",
        "base_contents": "      GRPC_CLOSURE_INIT(&batch_data->recv_message_ready,\n                        invoke_recv_message_callback,\n                        retry_state->recv_message_ready_deferred_batch,\n                        grpc_schedule_on_exec_ctx);\n      closures->Add(&batch_data->recv_message_ready,\n                    retry_state->recv_message_error,\n                    \"resuming recv_message_ready\");",
        "res_region": "      GRPC_CLOSURE_INIT(&retry_state->recv_message_ready,\n                        invoke_recv_message_callback,\n                        retry_state->recv_message_ready_deferred_batch,\n                        grpc_schedule_on_exec_ctx);\n      closures->Add(&retry_state->recv_message_ready,\n                    retry_state->recv_message_error,\n                    \"resuming recv_message_ready\");",
        "lookback": "                        invoke_recv_message_callback,",
        "lookahead": "      retry_state->recv_message_ready_deferred_batch = nullptr;",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 2048,
        "end_line": 2072,
        "merge_gen_region": null,
        "confidence": 0.8572450876235962,
        "hesitated": true
    },
    {
        "a_contents": "// Returns true if any op in the batch was not yet started.\n// Only looks at send ops, since recv ops are always started immediately.\nstatic bool pending_batch_is_unstarted(\n    pending_batch* pending, call_data* calld,\n    subchannel_call_retry_state* retry_state) {\n  if (pending->batch == nullptr || pending->batch->on_complete == nullptr) {\n    return false;\n  }\n  if (pending->batch->send_initial_metadata &&\n      !retry_state->started_send_initial_metadata) {\n    return true;\n  }\n  if (pending->batch->send_message &&\n      retry_state->started_send_message_count < calld->send_messages->size()) {\n    return true;\n  }\n  if (pending->batch->send_trailing_metadata &&\n      !retry_state->started_send_trailing_metadata) {\n    return true;\n  }\n  return false;\n}\n\n// For any pending batch containing an op that has not yet been started,\n// adds the pending batch's completion closures to closures.\nstatic void add_closures_to_fail_unstarted_pending_batches(\n    grpc_call_element* elem, subchannel_call_retry_state* retry_state,\n    grpc_error* error, grpc_core::CallCombinerClosureList* closures) {\n  channel_data* chand = static_cast<channel_data*>(elem->channel_data);\n  call_data* calld = static_cast<call_data*>(elem->call_data);\n  for (size_t i = 0; i < GPR_ARRAY_SIZE(calld->pending_batches); ++i) {\n    pending_batch* pending = &calld->pending_batches[i];\n    if (pending_batch_is_unstarted(pending, calld, retry_state)) {\n      if (grpc_client_channel_trace.enabled()) {\n        gpr_log(GPR_INFO,\n                \"chand=%p calld=%p: failing unstarted pending batch at index \"\n                \"%\" PRIuPTR,\n                chand, calld, i);\n      }\n      closures->Add(pending->batch->on_complete, GRPC_ERROR_REF(error),\n                    \"failing on_complete for pending batch\");\n      pending->batch->on_complete = nullptr;\n      maybe_clear_pending_batch(elem, pending);\n    }\n  }\n  GRPC_ERROR_UNREF(error);\n}\n\n// Runs necessary closures upon completion of a call attempt.\nstatic void run_closures_for_completed_call(subchannel_batch_data* batch_data,\n                                            grpc_error* error) {\n  grpc_call_element* elem = batch_data->elem;\n  call_data* calld = static_cast<call_data*>(elem->call_data);\n  subchannel_call_retry_state* retry_state =\n      static_cast<subchannel_call_retry_state*>(\n          grpc_connected_subchannel_call_get_parent_data(\n              batch_data->subchannel_call));\n  // Construct list of closures to execute.\n  grpc_core::CallCombinerClosureList closures;\n  // First, add closure for recv_trailing_metadata_ready.\n  add_closure_for_recv_trailing_metadata_ready(\n      elem, batch_data, GRPC_ERROR_REF(error), &closures);\n  // If there are deferred recv_initial_metadata_ready or recv_message_ready\n  // callbacks, add them to closures.\n  add_closures_for_deferred_recv_callbacks(batch_data, retry_state, &closures);\n  // Add closures to fail any pending batches that have not yet been started.\n  add_closures_to_fail_unstarted_pending_batches(\n      elem, retry_state, GRPC_ERROR_REF(error), &closures);\n  // Don't need batch_data anymore.\n  batch_data_unref(batch_data);\n  // Schedule all of the closures identified above.\n  // Note: This will release the call combiner.\n  closures.RunClosures(calld->call_combiner);\n  GRPC_ERROR_UNREF(error);\n}\n\n// Intercepts recv_trailing_metadata_ready callback for retries.\n// Commits the call and returns the trailing metadata up the stack.\nstatic void recv_trailing_metadata_ready(void* arg, grpc_error* error) {\n  subchannel_batch_data* batch_data = static_cast<subchannel_batch_data*>(arg);\n  grpc_call_element* elem = batch_data->elem;\n  channel_data* chand = static_cast<channel_data*>(elem->channel_data);\n  call_data* calld = static_cast<call_data*>(elem->call_data);\n  if (grpc_client_channel_trace.enabled()) {\n    gpr_log(GPR_INFO,\n            \"chand=%p calld=%p: got recv_trailing_metadata_ready, error=%s\",\n            chand, calld, grpc_error_string(error));\n  }\n  subchannel_call_retry_state* retry_state =\n      static_cast<subchannel_call_retry_state*>(\n          grpc_connected_subchannel_call_get_parent_data(\n              batch_data->subchannel_call));\n  retry_state->completed_recv_trailing_metadata = true;\n  // Get the call's status and check for server pushback metadata.\n  grpc_status_code status = GRPC_STATUS_OK;\n  grpc_mdelem* server_pushback_md = nullptr;\n  get_call_status(batch_data, GRPC_ERROR_REF(error), &status,\n                  &server_pushback_md);\n  if (grpc_client_channel_trace.enabled()) {\n    gpr_log(GPR_INFO, \"chand=%p calld=%p: call finished, status=%s\", chand,\n            calld, grpc_status_code_to_string(status));\n  }\n  // Check if we should retry.\n  if (maybe_retry(elem, batch_data, status, server_pushback_md)) {\n    // Unref batch_data for deferred recv_initial_metadata_ready or\n    // recv_message_ready callbacks, if any.\n    if (retry_state->recv_initial_metadata_ready_deferred_batch != nullptr) {\n      batch_data_unref(batch_data);\n      GRPC_ERROR_UNREF(retry_state->recv_initial_metadata_error);\n    }\n    if (retry_state->recv_message_ready_deferred_batch != nullptr) {\n      batch_data_unref(batch_data);\n      GRPC_ERROR_UNREF(retry_state->recv_message_error);\n    }\n    batch_data_unref(batch_data);\n    return;\n  }\n  // Not retrying, so commit the call.\n  retry_commit(elem, retry_state);\n  // Run any necessary closures.\n  run_closures_for_completed_call(batch_data, GRPC_ERROR_REF(error));\n}\n\n//\n// on_complete callback handling\n//\n\n// Adds the on_complete closure for the pending batch completed in\n// batch_data to closures.\nstatic void add_closure_for_completed_pending_batch(\n    grpc_call_element* elem, subchannel_batch_data* batch_data,\n    subchannel_call_retry_state* retry_state, grpc_error* error,\n    grpc_core::CallCombinerClosureList* closures) {\n  pending_batch* pending = pending_batch_find(\n      elem, \"completed\", [batch_data](grpc_transport_stream_op_batch* batch) {\n        // Match the pending batch with the same set of send ops as the\n        // subchannel batch we've just completed.\n        return batch->on_complete != nullptr &&\n               batch_data->batch.send_initial_metadata ==\n                   batch->send_initial_metadata &&\n               batch_data->batch.send_message == batch->send_message &&\n               batch_data->batch.send_trailing_metadata ==\n                   batch->send_trailing_metadata;\n      });\n  // If batch_data is a replay batch, then there will be no pending\n  // batch to complete.\n  if (pending == nullptr) {\n    GRPC_ERROR_UNREF(error);\n    return;\n  }\n  // Add closure.\n  closures->Add(pending->batch->on_complete, error,\n                \"on_complete for pending batch\");\n  pending->batch->on_complete = nullptr;\n  maybe_clear_pending_batch(elem, pending);\n}\n",
        "b_contents": "",
        "base_contents": "// Returns true if any op in the batch was not yet started.\n// Only looks at send ops, since recv ops are always started immediately.\nstatic bool pending_batch_is_unstarted(\n    pending_batch* pending, call_data* calld,\n    subchannel_call_retry_state* retry_state) {\n  if (pending->batch == nullptr || pending->batch->on_complete == nullptr) {\n    return false;\n  }\n  if (pending->batch->send_initial_metadata &&\n      !retry_state->started_send_initial_metadata) {\n    return true;\n  }\n  if (pending->batch->send_message &&\n      retry_state->started_send_message_count < calld->send_messages->size()) {\n    return true;\n  }\n  if (pending->batch->send_trailing_metadata &&\n      !retry_state->started_send_trailing_metadata) {\n    return true;\n  }\n  return false;\n}\n\n// For any pending batch containing an op that has not yet been started,\n// adds the pending batch's completion closures to closures.\nstatic void add_closures_to_fail_unstarted_pending_batches(\n    grpc_call_element* elem, subchannel_call_retry_state* retry_state,\n    grpc_error* error, grpc_core::CallCombinerClosureList* closures) {\n  channel_data* chand = static_cast<channel_data*>(elem->channel_data);\n  call_data* calld = static_cast<call_data*>(elem->call_data);\n  for (size_t i = 0; i < GPR_ARRAY_SIZE(calld->pending_batches); ++i) {\n    pending_batch* pending = &calld->pending_batches[i];\n    if (pending_batch_is_unstarted(pending, calld, retry_state)) {\n      if (grpc_client_channel_trace.enabled()) {\n        gpr_log(GPR_INFO,\n                \"chand=%p calld=%p: failing unstarted pending batch at index \"\n                \"%\" PRIuPTR,\n                chand, calld, i);\n      }\n      closures->Add(pending->batch->on_complete, GRPC_ERROR_REF(error),\n                    \"failing on_complete for pending batch\");\n      pending->batch->on_complete = nullptr;\n      maybe_clear_pending_batch(elem, pending);\n    }\n  }\n  GRPC_ERROR_UNREF(error);\n}\n\n// Intercepts recv_trailing_metadata_ready callback for retries.\n// Commits the call and returns the trailing metadata up the stack.\nstatic void recv_trailing_metadata_ready(void* arg, grpc_error* error) {\n  subchannel_batch_data* batch_data = static_cast<subchannel_batch_data*>(arg);\n  grpc_call_element* elem = batch_data->elem;\n  channel_data* chand = static_cast<channel_data*>(elem->channel_data);\n  call_data* calld = static_cast<call_data*>(elem->call_data);\n  if (grpc_client_channel_trace.enabled()) {\n    gpr_log(GPR_INFO,\n            \"chand=%p calld=%p: got recv_trailing_metadata_ready, error=%s\",\n            chand, calld, grpc_error_string(error));\n  }\n  subchannel_call_retry_state* retry_state =\n      static_cast<subchannel_call_retry_state*>(\n          grpc_connected_subchannel_call_get_parent_data(\n              batch_data->subchannel_call));\n  retry_state->completed_recv_trailing_metadata = true;\n  // Get the call's status and check for server pushback metadata.\n  grpc_status_code status = GRPC_STATUS_OK;\n  grpc_mdelem* server_pushback_md = nullptr;\n  if (error != GRPC_ERROR_NONE) {\n    grpc_error_get_status(error, calld->deadline, &status, nullptr, nullptr,\n                          nullptr);\n  } else {\n    grpc_metadata_batch* md_batch =\n        batch_data->batch.payload->recv_trailing_metadata\n            .recv_trailing_metadata;\n    GPR_ASSERT(md_batch->idx.named.grpc_status != nullptr);\n    status =\n        grpc_get_status_code_from_metadata(md_batch->idx.named.grpc_status->md);\n    if (md_batch->idx.named.grpc_retry_pushback_ms != nullptr) {\n      server_pushback_md = &md_batch->idx.named.grpc_retry_pushback_ms->md;\n    }\n  }\n  if (grpc_client_channel_trace.enabled()) {\n    gpr_log(GPR_INFO, \"chand=%p calld=%p: call finished, status=%s\", chand,\n            calld, grpc_status_code_to_string(status));\n  }\n  // Check if we should retry.\n  if (maybe_retry(elem, batch_data, status, server_pushback_md)) {\n    // Unref batch_data for deferred recv_initial_metadata_ready or\n    // recv_message_ready callbacks, if any.\n    if (retry_state->recv_initial_metadata_ready_deferred_batch != nullptr) {\n      batch_data_unref(batch_data);\n      GRPC_ERROR_UNREF(retry_state->recv_initial_metadata_error);\n    }\n    if (retry_state->recv_message_ready_deferred_batch != nullptr) {\n      batch_data_unref(batch_data);\n      GRPC_ERROR_UNREF(retry_state->recv_message_error);\n    }\n    batch_data_unref(batch_data);\n    return;\n  }\n  // Not retrying, so commit the call.\n  retry_commit(elem, retry_state);\n  // Construct list of closures to execute.\n  grpc_core::CallCombinerClosureList closures;\n  // First, add closure for recv_trailing_metadata_ready.\n  add_closure_for_recv_trailing_metadata_ready(\n      elem, batch_data, GRPC_ERROR_REF(error), &closures);\n  // If there are deferred recv_initial_metadata_ready or recv_message_ready\n  // callbacks, add them to closures.\n  add_closures_for_deferred_recv_callbacks(batch_data, retry_state, &closures);\n  // Add closures to fail any pending batches that have not yet been started.\n  add_closures_to_fail_unstarted_pending_batches(\n      elem, retry_state, GRPC_ERROR_REF(error), &closures);\n  // Don't need batch_data anymore.\n  batch_data_unref(batch_data);\n  // Schedule all of the closures identified above.\n  // Note: This will release the call combiner.\n  closures.RunClosures(calld->call_combiner);\n}\n\n//\n// on_complete callback handling\n//\n\n// For any pending batch completed in batch_data, adds the necessary\n// completion closures to closures.\nstatic void add_closure_for_completed_pending_batch(\n    grpc_call_element* elem, subchannel_batch_data* batch_data,\n    subchannel_call_retry_state* retry_state, grpc_error* error,\n    grpc_core::CallCombinerClosureList* closures) {\n  pending_batch* pending = pending_batch_find(\n      elem, \"completed\", [batch_data](grpc_transport_stream_op_batch* batch) {\n        return batch->on_complete != nullptr &&\n               batch_data->batch.send_initial_metadata ==\n                   batch->send_initial_metadata &&\n               batch_data->batch.send_message == batch->send_message &&\n               batch_data->batch.send_trailing_metadata ==\n                   batch->send_trailing_metadata;\n      });\n  // If batch_data is a replay batch, then there will be no pending\n  // batch to complete.\n  if (pending == nullptr) {\n    GRPC_ERROR_UNREF(error);\n    return;\n  }\n  // Add closure.\n  closures->Add(pending->batch->on_complete, error,\n                \"on_complete for pending batch\");\n  pending->batch->on_complete = nullptr;\n  maybe_clear_pending_batch(elem, pending);\n}\n",
        "res_region": "// Returns true if any op in the batch was not yet started.\n// Only looks at send ops, since recv ops are always started immediately.\nstatic bool pending_batch_is_unstarted(\n    pending_batch* pending, call_data* calld,\n    subchannel_call_retry_state* retry_state) {\n  if (pending->batch == nullptr || pending->batch->on_complete == nullptr) {\n    return false;\n  }\n  if (pending->batch->send_initial_metadata &&\n      !retry_state->started_send_initial_metadata) {\n    return true;\n  }\n  if (pending->batch->send_message &&\n      retry_state->started_send_message_count < calld->send_messages->size()) {\n    return true;\n  }\n  if (pending->batch->send_trailing_metadata &&\n      !retry_state->started_send_trailing_metadata) {\n    return true;\n  }\n  return false;\n}\n\n// For any pending batch containing an op that has not yet been started,\n// adds the pending batch's completion closures to closures.\nstatic void add_closures_to_fail_unstarted_pending_batches(\n    grpc_call_element* elem, subchannel_call_retry_state* retry_state,\n    grpc_error* error, grpc_core::CallCombinerClosureList* closures) {\n  channel_data* chand = static_cast<channel_data*>(elem->channel_data);\n  call_data* calld = static_cast<call_data*>(elem->call_data);\n  for (size_t i = 0; i < GPR_ARRAY_SIZE(calld->pending_batches); ++i) {\n    pending_batch* pending = &calld->pending_batches[i];\n    if (pending_batch_is_unstarted(pending, calld, retry_state)) {\n      if (grpc_client_channel_trace.enabled()) {\n        gpr_log(GPR_INFO,\n                \"chand=%p calld=%p: failing unstarted pending batch at index \"\n                \"%\" PRIuPTR,\n                chand, calld, i);\n      }\n      closures->Add(pending->batch->on_complete, GRPC_ERROR_REF(error),\n                    \"failing on_complete for pending batch\");\n      pending->batch->on_complete = nullptr;\n      maybe_clear_pending_batch(elem, pending);\n    }\n  }\n  GRPC_ERROR_UNREF(error);\n}\n\n// Runs necessary closures upon completion of a call attempt.\nstatic void run_closures_for_completed_call(subchannel_batch_data* batch_data,\n                                            grpc_error* error) {\n  grpc_call_element* elem = batch_data->elem;\n  call_data* calld = static_cast<call_data*>(elem->call_data);\n  subchannel_call_retry_state* retry_state =\n      static_cast<subchannel_call_retry_state*>(\n          grpc_connected_subchannel_call_get_parent_data(\n              batch_data->subchannel_call));\n  // Construct list of closures to execute.\n  grpc_core::CallCombinerClosureList closures;\n  // First, add closure for recv_trailing_metadata_ready.\n  add_closure_for_recv_trailing_metadata_ready(\n      elem, batch_data, GRPC_ERROR_REF(error), &closures);\n  // If there are deferred recv_initial_metadata_ready or recv_message_ready\n  // callbacks, add them to closures.\n  add_closures_for_deferred_recv_callbacks(batch_data, retry_state, &closures);\n  // Add closures to fail any pending batches that have not yet been started.\n  add_closures_to_fail_unstarted_pending_batches(\n      elem, retry_state, GRPC_ERROR_REF(error), &closures);\n  // Don't need batch_data anymore.\n  batch_data_unref(batch_data);\n  // Schedule all of the closures identified above.\n  // Note: This will release the call combiner.\n  closures.RunClosures(calld->call_combiner);\n  GRPC_ERROR_UNREF(error);\n}\n\n// Intercepts recv_trailing_metadata_ready callback for retries.\n// Commits the call and returns the trailing metadata up the stack.\nstatic void recv_trailing_metadata_ready(void* arg, grpc_error* error) {\n  subchannel_batch_data* batch_data = static_cast<subchannel_batch_data*>(arg);\n  grpc_call_element* elem = batch_data->elem;\n  channel_data* chand = static_cast<channel_data*>(elem->channel_data);\n  call_data* calld = static_cast<call_data*>(elem->call_data);\n  if (grpc_client_channel_trace.enabled()) {\n    gpr_log(GPR_INFO,\n            \"chand=%p calld=%p: got recv_trailing_metadata_ready, error=%s\",\n            chand, calld, grpc_error_string(error));\n  }\n  subchannel_call_retry_state* retry_state =\n      static_cast<subchannel_call_retry_state*>(\n          grpc_connected_subchannel_call_get_parent_data(\n              batch_data->subchannel_call));\n  retry_state->completed_recv_trailing_metadata = true;\n  // Get the call's status and check for server pushback metadata.\n  grpc_status_code status = GRPC_STATUS_OK;\n  grpc_mdelem* server_pushback_md = nullptr;\n  get_call_status(batch_data, GRPC_ERROR_REF(error), &status,\n                  &server_pushback_md);\n  if (grpc_client_channel_trace.enabled()) {\n    gpr_log(GPR_INFO, \"chand=%p calld=%p: call finished, status=%s\", chand,\n            calld, grpc_status_code_to_string(status));\n  }\n  // Check if we should retry.\n  if (maybe_retry(elem, batch_data, status, server_pushback_md)) {\n    // Unref batch_data for deferred recv_initial_metadata_ready or\n    // recv_message_ready callbacks, if any.\n    if (retry_state->recv_initial_metadata_ready_deferred_batch != nullptr) {\n      batch_data_unref(batch_data);\n      GRPC_ERROR_UNREF(retry_state->recv_initial_metadata_error);\n    }\n    if (retry_state->recv_message_ready_deferred_batch != nullptr) {\n      batch_data_unref(batch_data);\n      GRPC_ERROR_UNREF(retry_state->recv_message_error);\n    }\n    batch_data_unref(batch_data);\n    return;\n  }\n  // Not retrying, so commit the call.\n  retry_commit(elem, retry_state);\n  // Run any necessary closures.\n  run_closures_for_completed_call(batch_data, GRPC_ERROR_REF(error));\n}\n\n//\n// on_complete callback handling\n//\n\n// Adds the on_complete closure for the pending batch completed in\n// batch_data to closures.\nstatic void add_closure_for_completed_pending_batch(\n    grpc_call_element* elem, subchannel_batch_data* batch_data,\n    subchannel_call_retry_state* retry_state, grpc_error* error,\n    grpc_core::CallCombinerClosureList* closures) {\n  pending_batch* pending = pending_batch_find(\n      elem, \"completed\", [batch_data](grpc_transport_stream_op_batch* batch) {\n        // Match the pending batch with the same set of send ops as the\n        // subchannel batch we've just completed.\n        return batch->on_complete != nullptr &&\n               batch_data->batch.send_initial_metadata ==\n                   batch->send_initial_metadata &&\n               batch_data->batch.send_message == batch->send_message &&\n               batch_data->batch.send_trailing_metadata ==\n                   batch->send_trailing_metadata;\n      });\n  // If batch_data is a replay batch, then there will be no pending\n  // batch to complete.\n  if (pending == nullptr) {\n    GRPC_ERROR_UNREF(error);\n    return;\n  }\n  // Add closure.\n  closures->Add(pending->batch->on_complete, error,\n                \"on_complete for pending batch\");\n  pending->batch->on_complete = nullptr;\n  maybe_clear_pending_batch(elem, pending);\n}\n",
        "lookback": "// Only looks at send ops, since recv ops are always started immediately.",
        "lookahead": "// If there are any cached ops to replay or pending ops to start on the",
        "label": [
            "ours",
            "base_empty"
        ],
        "start_line": 2078,
        "end_line": 2391,
        "merge_gen_region": null,
        "confidence": 0.7332267165184021,
        "hesitated": true
    },
    {
        "a_contents": "  grpc_core::CallCombinerClosureList closures;\n  // If a retry was already dispatched, that means we saw\n  // recv_trailing_metadata before this, so we do nothing here.\n  // Otherwise, invoke the callback to return the result to the surface.\n  if (!retry_state->retry_dispatched) {\n    // Add closure for the completed pending batch, if any.\n    add_closure_for_completed_pending_batch(elem, batch_data, retry_state,\n                                            GRPC_ERROR_REF(error), &closures);\n    // If needed, add a callback to start any replay or pending send ops on\n    // the subchannel call.\n    if (!retry_state->completed_recv_trailing_metadata) {\n      add_closures_for_replay_or_pending_send_ops(elem, batch_data, retry_state,\n                                                  &closures);\n    }",
        "b_contents": "  // Max number of closures is number of pending batches plus one for\n  // each of:\n  // - recv_initial_metadata_ready (either deferred or unstarted)\n  // - recv_message_ready (either deferred or unstarted)\n  // - starting a new batch for pending send ops\n  closure_to_execute closures[GPR_ARRAY_SIZE(calld->pending_batches) + 3];\n  size_t num_closures = 0;\n  // If there are deferred recv_initial_metadata_ready or recv_message_ready\n  // callbacks, add them to closures.\n  add_closures_for_deferred_recv_callbacks(batch_data, retry_state, closures,\n                                           &num_closures);\n  // Find pending batches whose ops are now complete and add their\n  // on_complete callbacks to closures.\n  add_closures_for_completed_pending_batches(elem, batch_data, retry_state,\n                                             GRPC_ERROR_REF(error), closures,\n                                             &num_closures);\n  // Add closures to handle any pending batches that have not yet been started.\n  // If the call is finished, we fail these batches; otherwise, we add a\n  // callback to start_retriable_subchannel_batches() to start them on\n  // the subchannel call.\n  if (call_finished) {\n    add_closures_to_fail_unstarted_pending_batches(\n        elem, retry_state, GRPC_ERROR_REF(error), closures, &num_closures);\n  } else {\n    add_closures_for_replay_or_pending_send_ops(elem, batch_data, retry_state,\n                                                closures, &num_closures);",
        "base_contents": "  grpc_core::CallCombinerClosureList closures;\n  // If a retry was already dispatched, that means we saw\n  // recv_trailing_metadata before this, so we do nothing here.\n  // Otherwise, invoke the callback to return the result to the surface.\n  if (!retry_state->retry_dispatched) {\n    // Add closure for the completed pending batch, if any.\n    add_closure_for_completed_pending_batch(elem, batch_data, retry_state,\n                                            GRPC_ERROR_REF(error), &closures);\n    // If needed, add a callback to start_retriable_subchannel_batches() to\n    // start any replay or pending send ops on the subchannel call.\n    if (!retry_state->completed_recv_trailing_metadata) {\n      add_closures_for_replay_or_pending_send_ops(elem, batch_data, retry_state,\n                                                  &closures);\n    }",
        "res_region": "  grpc_core::CallCombinerClosureList closures;\n  // If a retry was already dispatched, that means we saw\n  // recv_trailing_metadata before this, so we do nothing here.\n  // Otherwise, invoke the callback to return the result to the surface.\n  if (!retry_state->retry_dispatched) {\n    // Add closure for the completed pending batch, if any.\n    add_closure_for_completed_pending_batch(elem, batch_data, retry_state,\n                                            GRPC_ERROR_REF(error), &closures);\n    // If needed, add a callback to start any replay or pending send ops on\n    // the subchannel call.\n    if (!retry_state->completed_recv_trailing_metadata) {\n      add_closures_for_replay_or_pending_send_ops(elem, batch_data, retry_state,\n                                                  &closures);\n    }",
        "lookback": "  // If a retry was already dispatched, that means we saw",
        "lookahead": "  }",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 2615,
        "end_line": 2672,
        "merge_gen_region": " If a was alreadypat, means s // number cloures number pendingches one // each: -_____ ( deferred un) -__ ( deferred un) - a batch pending ops closuretoexecutes[_(dpendingbat) 3 sizet_ numcloures 0 // there deferred___ or___ //, them cloures addclouresfordeferredrecvcallbacksbatchdata retrystate cloures &_s); Find bat whose are complete add //_ callbacks cloures._suresforcompletedpendingbat(,,_,_,_,_,__,__,__(),s,numcloures // cloures handle pendingches have yet started // the is, we these bat;, add // callback start on thechannel. (_) addclourestofailun_startedpendingbat( elem retrystate GRPCERRORREFerror cloures &_s); else addclouresforreplayorpendingsendopselem batchdata retrystate cloures &_s);",
        "confidence": 0.8989620804786682,
        "hesitated": false,
        "resolved": false
    },
    {
        "a_contents": "  --calld->num_pending_retriable_subchannel_send_batches;\n  const bool last_send_batch_complete =\n      calld->num_pending_retriable_subchannel_send_batches == 0;",
        "b_contents": "  bool last_callback_complete = false;\n  if (batch_data->batch.send_initial_metadata ||\n      batch_data->batch.send_message ||\n      batch_data->batch.send_trailing_metadata) {\n    --calld->num_pending_retriable_subchannel_send_batches;\n    last_callback_complete =\n        calld->num_pending_retriable_subchannel_send_batches == 0;\n  }",
        "base_contents": "  --calld->num_pending_retriable_subchannel_send_batches;\n  const bool last_callback_complete =\n      calld->num_pending_retriable_subchannel_send_batches == 0;",
        "res_region": "  --calld->num_pending_retriable_subchannel_send_batches;\n  const bool last_send_batch_complete =\n      calld->num_pending_retriable_subchannel_send_batches == 0;",
        "lookback": "  const bool last_send_batch_complete =",
        "lookahead": "  // Don't need batch_data anymore.",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 2676,
        "end_line": 2693,
        "merge_gen_region": null,
        "confidence": 0.8656400442123413,
        "hesitated": true
    },
    {
        "a_contents": "  closures.RunClosures(calld->call_combiner);\n  // If this was the last subchannel send batch, unref the call stack.\n  if (last_send_batch_complete) {",
        "b_contents": "  execute_closures_in_call_combiner(elem, \"on_complete\", closures,\n                                    num_closures);\n  // If we just completed the last subchannel send batch, unref the call stack.\n  if (last_callback_complete) {",
        "base_contents": "  closures.RunClosures(calld->call_combiner);\n  // If this was the last subchannel send batch, unref the call stack.\n  if (last_callback_complete) {",
        "res_region": "  closures.RunClosures(calld->call_combiner);\n  // If this was the last subchannel send batch, unref the call stack.\n  if (last_send_batch_complete) {",
        "lookback": "  // If this was the last subchannel send batch, unref the call stack.",
        "lookahead": "    GRPC_CALL_STACK_UNREF(calld->owning_call, \"subchannel_send_batches\");",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 2698,
        "end_line": 2711,
        "merge_gen_region": null,
        "confidence": 0.8421931266784668,
        "hesitated": true
    },
    {
        "a_contents": "      &retry_state->recv_trailing_metadata;\n  batch_data->batch.payload->recv_trailing_metadata.collect_stats =\n      &retry_state->collect_stats;\n  GRPC_CLOSURE_INIT(&retry_state->recv_trailing_metadata_ready,\n                    recv_trailing_metadata_ready, batch_data,\n                    grpc_schedule_on_exec_ctx);\n  batch_data->batch.payload->recv_trailing_metadata\n      .recv_trailing_metadata_ready =\n      &retry_state->recv_trailing_metadata_ready;",
        "b_contents": "      &batch_data->recv_trailing_metadata;\n  batch_data->batch.collect_stats = true;\n  batch_data->batch.payload->collect_stats.collect_stats =\n      &batch_data->collect_stats;",
        "base_contents": "      &batch_data->recv_trailing_metadata;\n  batch_data->batch.payload->recv_trailing_metadata.collect_stats =\n      &batch_data->collect_stats;\n  GRPC_CLOSURE_INIT(&batch_data->recv_trailing_metadata_ready,\n                    recv_trailing_metadata_ready, batch_data,\n                    grpc_schedule_on_exec_ctx);\n  batch_data->batch.payload->recv_trailing_metadata\n      .recv_trailing_metadata_ready = &batch_data->recv_trailing_metadata_ready;",
        "res_region": "      &retry_state->recv_trailing_metadata;\n  batch_data->batch.payload->recv_trailing_metadata.collect_stats =\n      &retry_state->collect_stats;\n  GRPC_CLOSURE_INIT(&retry_state->recv_trailing_metadata_ready,\n                    recv_trailing_metadata_ready, batch_data,\n                    grpc_schedule_on_exec_ctx);\n  batch_data->batch.payload->recv_trailing_metadata\n      .recv_trailing_metadata_ready =\n      &retry_state->recv_trailing_metadata_ready;",
        "lookback": "  batch_data->batch.payload->recv_trailing_metadata.collect_stats =",
        "lookahead": "}",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 2887,
        "end_line": 2911,
        "merge_gen_region": null,
        "confidence": 0.7392320036888123,
        "hesitated": true
    },
    {
        "a_contents": "",
        "b_contents": "          subchannel_batch_data* batch_data =\n              retry_state->recv_trailing_metadata_internal_batch;\n          closure_to_execute* closure = &closures[(*num_closures)++];\n          closure->closure = &batch_data->on_complete;",
        "base_contents": "          subchannel_batch_data* batch_data =\n              retry_state->recv_trailing_metadata_internal_batch;",
        "res_region": "",
        "lookback": "          closures->Add(",
        "lookahead": "          // Batches containing recv_trailing_metadata always succeed.",
        "label": [
            "ours",
            "one_side_deletion"
        ],
        "start_line": 3061,
        "end_line": 3070,
        "merge_gen_region": null,
        "confidence": 0.4329437017440796,
        "hesitated": true
    },
    {
        "a_contents": "          closures->Add(\n              &retry_state->recv_trailing_metadata_ready, GRPC_ERROR_NONE,\n              \"re-executing recv_trailing_metadata_ready to propagate \"\n              \"internally triggered result\");",
        "b_contents": "          closure->error = GRPC_ERROR_NONE;\n          closure->reason =\n              \"re-executing on_complete for recv_trailing_metadata \"\n              \"to propagate internally triggered result\";",
        "base_contents": "          closures->Add(\n              &batch_data->recv_trailing_metadata_ready, GRPC_ERROR_NONE,\n              \"re-executing recv_trailing_metadata_ready to propagate \"\n              \"internally triggered result\");",
        "res_region": "          closures->Add(\n              &retry_state->recv_trailing_metadata_ready, GRPC_ERROR_NONE,\n              \"re-executing recv_trailing_metadata_ready to propagate \"\n              \"internally triggered result\");",
        "lookback": "              &retry_state->recv_trailing_metadata_ready, GRPC_ERROR_NONE,",
        "lookahead": "        } else {",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 3072,
        "end_line": 3087,
        "merge_gen_region": null,
        "confidence": 0.773655891418457,
        "hesitated": true
    }
]