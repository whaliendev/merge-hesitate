[
    {
        "a_contents": "int cmp_cache_name_compare(const void *a_, const void *b_);",
        "b_contents": "/*\n * Return an abbreviated sha1 unique within this repository's object database.\n * The result will be at least `len` characters long, and will be NUL\n * terminated.\n *\n * The non-`_r` version returns a static buffer which remains valid until 4\n * more calls to find_unique_abbrev are made.\n *\n * The `_r` variant writes to a buffer supplied by the caller, which must be at\n * least `GIT_MAX_HEXSZ + 1` bytes. The return value is the number of bytes\n * written (excluding the NUL terminator).\n *\n * Note that while this version avoids the static buffer, it is not fully\n * reentrant, as it calls into other non-reentrant git code.\n */\nconst char *repo_find_unique_abbrev(struct repository *r, const struct object_id *oid, int len);\n#define find_unique_abbrev(oid, len) repo_find_unique_abbrev(the_repository, oid, len)\nint repo_find_unique_abbrev_r(struct repository *r, char *hex, const struct object_id *oid, int len);\n#define find_unique_abbrev_r(hex, oid, len) repo_find_unique_abbrev_r(the_repository, hex, oid, len)\n\n/* set default permissions by passing mode arguments to open(2) */\nint git_mkstemps_mode(char *pattern, int suffix_len, int mode);\nint git_mkstemp_mode(char *pattern, int mode);\n\n/*\n * NOTE NOTE NOTE!!\n *\n * PERM_UMASK, OLD_PERM_GROUP and OLD_PERM_EVERYBODY enumerations must\n * not be changed. Old repositories have core.sharedrepository written in\n * numeric format, and therefore these values are preserved for compatibility\n * reasons.\n */\nenum sharedrepo {\n\tPERM_UMASK          = 0,\n\tOLD_PERM_GROUP      = 1,\n\tOLD_PERM_EVERYBODY  = 2,\n\tPERM_GROUP          = 0660,\n\tPERM_EVERYBODY      = 0664\n};\nint git_config_perm(const char *var, const char *value);\nint adjust_shared_perm(const char *path);\n\n/*\n * Create the directory containing the named path, using care to be\n * somewhat safe against races. Return one of the scld_error values to\n * indicate success/failure. On error, set errno to describe the\n * problem.\n *\n * SCLD_VANISHED indicates that one of the ancestor directories of the\n * path existed at one point during the function call and then\n * suddenly vanished, probably because another process pruned the\n * directory while we were working.  To be robust against this kind of\n * race, callers might want to try invoking the function again when it\n * returns SCLD_VANISHED.\n *\n * safe_create_leading_directories() temporarily changes path while it\n * is working but restores it before returning.\n * safe_create_leading_directories_const() doesn't modify path, even\n * temporarily. Both these variants adjust the permissions of the\n * created directories to honor core.sharedRepository, so they are best\n * suited for files inside the git dir. For working tree files, use\n * safe_create_leading_directories_no_share() instead, as it ignores\n * the core.sharedRepository setting.\n */\nenum scld_error {\n\tSCLD_OK = 0,\n\tSCLD_FAILED = -1,\n\tSCLD_PERMS = -2,\n\tSCLD_EXISTS = -3,\n\tSCLD_VANISHED = -4\n};\nenum scld_error safe_create_leading_directories(char *path);\nenum scld_error safe_create_leading_directories_const(const char *path);\nenum scld_error safe_create_leading_directories_no_share(char *path);\n\nint mkdir_in_gitdir(const char *path);\nchar *interpolate_path(const char *path, int real_home);\n/* NEEDSWORK: remove this synonym once in-flight topics have migrated */\n#define expand_user_path interpolate_path\nconst char *enter_repo(const char *path, int strict);\nstatic inline int is_absolute_path(const char *path)\n{\n\treturn is_dir_sep(path[0]) || has_dos_drive_prefix(path);\n}\nint is_directory(const char *);\nchar *strbuf_realpath(struct strbuf *resolved, const char *path,\n\t\t      int die_on_error);\nchar *strbuf_realpath_forgiving(struct strbuf *resolved, const char *path,\n\t\t\t\tint die_on_error);\nchar *real_pathdup(const char *path, int die_on_error);\nconst char *absolute_path(const char *path);\nchar *absolute_pathdup(const char *path);\nconst char *remove_leading_path(const char *in, const char *prefix);\nconst char *relative_path(const char *in, const char *prefix, struct strbuf *sb);\nint normalize_path_copy_len(char *dst, const char *src, int *prefix_len);\nint normalize_path_copy(char *dst, const char *src);\nint longest_ancestor_length(const char *path, struct string_list *prefixes);\nchar *strip_path_suffix(const char *path, const char *suffix);\nint daemon_avoid_alias(const char *path);\n\n/*\n * These functions match their is_hfs_dotgit() counterparts; see utf8.h for\n * details.\n */\nint is_ntfs_dotgit(const char *name);\nint is_ntfs_dotgitmodules(const char *name);\nint is_ntfs_dotgitignore(const char *name);\nint is_ntfs_dotgitattributes(const char *name);\nint is_ntfs_dotmailmap(const char *name);\n\n/*\n * Returns true iff \"str\" could be confused as a command-line option when\n * passed to a sub-program like \"ssh\". Note that this has nothing to do with\n * shell-quoting, which should be handled separately; we're assuming here that\n * the string makes it verbatim to the sub-program.\n */\nint looks_like_command_line_option(const char *str);\n\n/**\n * Return a newly allocated string with the evaluation of\n * \"$XDG_CONFIG_HOME/$subdir/$filename\" if $XDG_CONFIG_HOME is non-empty, otherwise\n * \"$HOME/.config/$subdir/$filename\". Return NULL upon error.\n */\nchar *xdg_config_home_for(const char *subdir, const char *filename);\n\n/**\n * Return a newly allocated string with the evaluation of\n * \"$XDG_CONFIG_HOME/git/$filename\" if $XDG_CONFIG_HOME is non-empty, otherwise\n * \"$HOME/.config/git/$filename\". Return NULL upon error.\n */\nchar *xdg_config_home(const char *filename);\n\n/**\n * Return a newly allocated string with the evaluation of\n * \"$XDG_CACHE_HOME/git/$filename\" if $XDG_CACHE_HOME is non-empty, otherwise\n * \"$HOME/.cache/git/$filename\". Return NULL upon error.\n */\nchar *xdg_cache_home(const char *filename);\n\nint git_open_cloexec(const char *name, int flags);\n#define git_open(name) git_open_cloexec(name, O_RDONLY)\n\n/**\n * unpack_loose_header() initializes the data stream needed to unpack\n * a loose object header.\n *\n * Returns:\n *\n * - ULHR_OK on success\n * - ULHR_BAD on error\n * - ULHR_TOO_LONG if the header was too long\n *\n * It will only parse up to MAX_HEADER_LEN bytes unless an optional\n * \"hdrbuf\" argument is non-NULL. This is intended for use with\n * OBJECT_INFO_ALLOW_UNKNOWN_TYPE to extract the bad type for (error)\n * reporting. The full header will be extracted to \"hdrbuf\" for use\n * with parse_loose_header(), ULHR_TOO_LONG will still be returned\n * from this function to indicate that the header was too long.\n */\nenum unpack_loose_header_result {\n\tULHR_OK,\n\tULHR_BAD,\n\tULHR_TOO_LONG,\n};\nenum unpack_loose_header_result unpack_loose_header(git_zstream *stream,\n\t\t\t\t\t\t    unsigned char *map,\n\t\t\t\t\t\t    unsigned long mapsize,\n\t\t\t\t\t\t    void *buffer,\n\t\t\t\t\t\t    unsigned long bufsiz,\n\t\t\t\t\t\t    struct strbuf *hdrbuf);\n\n/**\n * parse_loose_header() parses the starting \"<type> <len>\\0\" of an\n * object. If it doesn't follow that format -1 is returned. To check\n * the validity of the <type> populate the \"typep\" in the \"struct\n * object_info\". It will be OBJ_BAD if the object type is unknown. The\n * parsed <len> can be retrieved via \"oi->sizep\", and from there\n * passed to unpack_loose_rest().\n */\nstruct object_info;\nint parse_loose_header(const char *hdr, struct object_info *oi);\n\n/**\n * With in-core object data in \"buf\", rehash it to make sure the\n * object name actually matches \"oid\" to detect object corruption.\n *\n * A negative value indicates an error, usually that the OID is not\n * what we expected, but it might also indicate another error.\n */\nint check_object_signature(struct repository *r, const struct object_id *oid,\n\t\t\t   void *map, unsigned long size,\n\t\t\t   enum object_type type);\n\n/**\n * A streaming version of check_object_signature().\n * Try reading the object named with \"oid\" using\n * the streaming interface and rehash it to do the same.\n */\nint stream_object_signature(struct repository *r, const struct object_id *oid);\n\nint finalize_object_file(const char *tmpfile, const char *filename);\n\n/* Helper to check and \"touch\" a file */\nint check_and_freshen_file(const char *fn, int freshen);\n\nextern const signed char hexval_table[256];\nstatic inline unsigned int hexval(unsigned char c)\n{\n\treturn hexval_table[c];\n}\n\n/*\n * Convert two consecutive hexadecimal digits into a char.  Return a\n * negative value on error.  Don't run over the end of short strings.\n */\nstatic inline int hex2chr(const char *s)\n{\n\tunsigned int val = hexval(s[0]);\n\treturn (val & ~0xf) ? val : (val << 4) | hexval(s[1]);\n}\n\n/* Convert to/from hex/sha1 representation */\n#define MINIMUM_ABBREV minimum_abbrev\n#define DEFAULT_ABBREV default_abbrev\n\n/* used when the code does not know or care what the default abbrev is */\n#define FALLBACK_DEFAULT_ABBREV 7\n\nstruct object_context {\n\tunsigned short mode;\n\t/*\n\t * symlink_path is only used by get_tree_entry_follow_symlinks,\n\t * and only for symlinks that point outside the repository.\n\t */\n\tstruct strbuf symlink_path;\n\t/*\n\t * If GET_OID_RECORD_PATH is set, this will record path (if any)\n\t * found when resolving the name. The caller is responsible for\n\t * releasing the memory.\n\t */\n\tchar *path;\n};\n\n#define GET_OID_QUIETLY           01\n#define GET_OID_COMMIT            02\n#define GET_OID_COMMITTISH        04\n#define GET_OID_TREE             010\n#define GET_OID_TREEISH          020\n#define GET_OID_BLOB             040\n#define GET_OID_FOLLOW_SYMLINKS 0100\n#define GET_OID_RECORD_PATH     0200\n#define GET_OID_ONLY_TO_DIE    04000\n#define GET_OID_REQUIRE_PATH  010000\n\n#define GET_OID_DISAMBIGUATORS \\\n\t(GET_OID_COMMIT | GET_OID_COMMITTISH | \\\n\tGET_OID_TREE | GET_OID_TREEISH | \\\n\tGET_OID_BLOB)\n\nenum get_oid_result {\n\tFOUND = 0,\n\tMISSING_OBJECT = -1, /* The requested object is missing */\n\tSHORT_NAME_AMBIGUOUS = -2,\n\t/* The following only apply when symlinks are followed */\n\tDANGLING_SYMLINK = -4, /*\n\t\t\t\t* The initial symlink is there, but\n\t\t\t\t* (transitively) points to a missing\n\t\t\t\t* in-tree file\n\t\t\t\t*/\n\tSYMLINK_LOOP = -5,\n\tNOT_DIR = -6, /*\n\t\t       * Somewhere along the symlink chain, a path is\n\t\t       * requested which contains a file as a\n\t\t       * non-final element.\n\t\t       */\n};\n\nint repo_get_oid(struct repository *r, const char *str, struct object_id *oid);\n__attribute__((format (printf, 2, 3)))\nint get_oidf(struct object_id *oid, const char *fmt, ...);\nint repo_get_oid_commit(struct repository *r, const char *str, struct object_id *oid);\nint repo_get_oid_committish(struct repository *r, const char *str, struct object_id *oid);\nint repo_get_oid_tree(struct repository *r, const char *str, struct object_id *oid);\nint repo_get_oid_treeish(struct repository *r, const char *str, struct object_id *oid);\nint repo_get_oid_blob(struct repository *r, const char *str, struct object_id *oid);\nint repo_get_oid_mb(struct repository *r, const char *str, struct object_id *oid);\nvoid maybe_die_on_misspelt_object_name(struct repository *repo,\n\t\t\t\t       const char *name,\n\t\t\t\t       const char *prefix);\nenum get_oid_result get_oid_with_context(struct repository *repo, const char *str,\n\t\t\t\t\t unsigned flags, struct object_id *oid,\n\t\t\t\t\t struct object_context *oc);\n\n#define get_oid(str, oid)\t\trepo_get_oid(the_repository, str, oid)\n#define get_oid_commit(str, oid)\trepo_get_oid_commit(the_repository, str, oid)\n#define get_oid_committish(str, oid)\trepo_get_oid_committish(the_repository, str, oid)\n#define get_oid_tree(str, oid)\t\trepo_get_oid_tree(the_repository, str, oid)\n#define get_oid_treeish(str, oid)\trepo_get_oid_treeish(the_repository, str, oid)\n#define get_oid_blob(str, oid)\t\trepo_get_oid_blob(the_repository, str, oid)\n#define get_oid_mb(str, oid) \t\trepo_get_oid_mb(the_repository, str, oid)\n\ntypedef int each_abbrev_fn(const struct object_id *oid, void *);\nint repo_for_each_abbrev(struct repository *r, const char *prefix, each_abbrev_fn, void *);\n#define for_each_abbrev(prefix, fn, data) repo_for_each_abbrev(the_repository, prefix, fn, data)\n\nint set_disambiguate_hint_config(const char *var, const char *value);\n\n/*\n * Try to read a SHA1 in hexadecimal format from the 40 characters\n * starting at hex.  Write the 20-byte result to sha1 in binary form.\n * Return 0 on success.  Reading stops if a NUL is encountered in the\n * input, so it is safe to pass this function an arbitrary\n * null-terminated string.\n */\nint get_sha1_hex(const char *hex, unsigned char *sha1);\nint get_oid_hex(const char *hex, struct object_id *sha1);\n\n/* Like get_oid_hex, but for an arbitrary hash algorithm. */\nint get_oid_hex_algop(const char *hex, struct object_id *oid, const struct git_hash_algo *algop);\n\n/*\n * Read `len` pairs of hexadecimal digits from `hex` and write the\n * values to `binary` as `len` bytes. Return 0 on success, or -1 if\n * the input does not consist of hex digits).\n */\nint hex_to_bytes(unsigned char *binary, const char *hex, size_t len);\n\n/*\n * Convert a binary hash in \"unsigned char []\" or an object name in\n * \"struct object_id *\" to its hex equivalent. The `_r` variant is reentrant,\n * and writes the NUL-terminated output to the buffer `out`, which must be at\n * least `GIT_MAX_HEXSZ + 1` bytes, and returns a pointer to out for\n * convenience.\n *\n * The non-`_r` variant returns a static buffer, but uses a ring of 4\n * buffers, making it safe to make multiple calls for a single statement, like:\n *\n *   printf(\"%s -> %s\", hash_to_hex(one), hash_to_hex(two));\n *   printf(\"%s -> %s\", oid_to_hex(one), oid_to_hex(two));\n */\nchar *hash_to_hex_algop_r(char *buffer, const unsigned char *hash, const struct git_hash_algo *);\nchar *oid_to_hex_r(char *out, const struct object_id *oid);\nchar *hash_to_hex_algop(const unsigned char *hash, const struct git_hash_algo *);\t/* static buffer result! */\nchar *hash_to_hex(const unsigned char *hash);\t\t\t\t\t\t/* same static buffer */\nchar *oid_to_hex(const struct object_id *oid);\t\t\t\t\t\t/* same static buffer */\n\n/*\n * Parse a 40-character hexadecimal object ID starting from hex, updating the\n * pointer specified by end when parsing stops.  The resulting object ID is\n * stored in oid.  Returns 0 on success.  Parsing will stop on the first NUL or\n * other invalid character.  end is only updated on success; otherwise, it is\n * unmodified.\n */\nint parse_oid_hex(const char *hex, struct object_id *oid, const char **end);\n\n/* Like parse_oid_hex, but for an arbitrary hash algorithm. */\nint parse_oid_hex_algop(const char *hex, struct object_id *oid, const char **end,\n\t\t\tconst struct git_hash_algo *algo);\n\n\n/*\n * These functions work like get_oid_hex and parse_oid_hex, but they will parse\n * a hex value for any algorithm. The algorithm is detected based on the length\n * and the algorithm in use is returned. If this is not a hex object ID in any\n * algorithm, returns GIT_HASH_UNKNOWN.\n */\nint get_oid_hex_any(const char *hex, struct object_id *oid);\nint parse_oid_hex_any(const char *hex, struct object_id *oid, const char **end);\n\n/*\n * This reads short-hand syntax that not only evaluates to a commit\n * object name, but also can act as if the end user spelled the name\n * of the branch from the command line.\n *\n * - \"@{-N}\" finds the name of the Nth previous branch we were on, and\n *   places the name of the branch in the given buf and returns the\n *   number of characters parsed if successful.\n *\n * - \"<branch>@{upstream}\" finds the name of the other ref that\n *   <branch> is configured to merge with (missing <branch> defaults\n *   to the current branch), and places the name of the branch in the\n *   given buf and returns the number of characters parsed if\n *   successful.\n *\n * If the input is not of the accepted format, it returns a negative\n * number to signal an error.\n *\n * If the input was ok but there are not N branch switches in the\n * reflog, it returns 0.\n */\n#define INTERPRET_BRANCH_LOCAL (1<<0)\n#define INTERPRET_BRANCH_REMOTE (1<<1)\n#define INTERPRET_BRANCH_HEAD (1<<2)\nstruct interpret_branch_name_options {\n\t/*\n\t * If \"allowed\" is non-zero, it is a treated as a bitfield of allowable\n\t * expansions: local branches (\"refs/heads/\"), remote branches\n\t * (\"refs/remotes/\"), or \"HEAD\". If no \"allowed\" bits are set, any expansion is\n\t * allowed, even ones to refs outside of those namespaces.\n\t */\n\tunsigned allowed;\n\n\t/*\n\t * If ^{upstream} or ^{push} (or equivalent) is requested, and the\n\t * branch in question does not have such a reference, return -1 instead\n\t * of die()-ing.\n\t */\n\tunsigned nonfatal_dangling_mark : 1;\n};\nint repo_interpret_branch_name(struct repository *r,\n\t\t\t       const char *str, int len,\n\t\t\t       struct strbuf *buf,\n\t\t\t       const struct interpret_branch_name_options *options);\n#define interpret_branch_name(str, len, buf, options) \\\n\trepo_interpret_branch_name(the_repository, str, len, buf, options)\n\nint validate_headref(const char *ref);\n\nint base_name_compare(const char *name1, size_t len1, int mode1,\n\t\t      const char *name2, size_t len2, int mode2);\nint df_name_compare(const char *name1, size_t len1, int mode1,\n\t\t    const char *name2, size_t len2, int mode2);\nint name_compare(const char *name1, size_t len1, const char *name2, size_t len2);\nint cache_name_stage_compare(const char *name1, int len1, int stage1, const char *name2, int len2, int stage2);\n\nvoid *read_object_with_reference(struct repository *r,\n\t\t\t\t const struct object_id *oid,\n\t\t\t\t enum object_type required_type,\n\t\t\t\t unsigned long *size,\n\t\t\t\t struct object_id *oid_ret);\n\nstruct object *repo_peel_to_type(struct repository *r,\n\t\t\t\t const char *name, int namelen,\n\t\t\t\t struct object *o, enum object_type);\n#define peel_to_type(name, namelen, obj, type) \\\n\trepo_peel_to_type(the_repository, name, namelen, obj, type)\n\n#define IDENT_STRICT\t       1\n#define IDENT_NO_DATE\t       2\n#define IDENT_NO_NAME\t       4\n\nenum want_ident {\n\tWANT_BLANK_IDENT,\n\tWANT_AUTHOR_IDENT,\n\tWANT_COMMITTER_IDENT\n};\n\nconst char *git_author_info(int);\nconst char *git_committer_info(int);\nconst char *fmt_ident(const char *name, const char *email,\n\t\t      enum want_ident whose_ident,\n\t\t      const char *date_str, int);\nconst char *fmt_name(enum want_ident);\nconst char *ident_default_name(void);\nconst char *ident_default_email(void);\nconst char *git_editor(void);\nconst char *git_sequence_editor(void);\nconst char *git_pager(int stdout_is_tty);\nint is_terminal_dumb(void);\nint git_ident_config(const char *, const char *, void *);\n/*\n * Prepare an ident to fall back on if the user didn't configure it.\n */\nvoid prepare_fallback_ident(const char *name, const char *email);\nvoid reset_ident_date(void);\n\nstruct ident_split {\n\tconst char *name_begin;\n\tconst char *name_end;\n\tconst char *mail_begin;\n\tconst char *mail_end;\n\tconst char *date_begin;\n\tconst char *date_end;\n\tconst char *tz_begin;\n\tconst char *tz_end;\n};\n/*\n * Signals an success with 0, but time part of the result may be NULL\n * if the input lacks timestamp and zone\n */\nint split_ident_line(struct ident_split *, const char *, int);\n\n/*\n * Given a commit or tag object buffer and the commit or tag headers, replaces\n * the idents in the headers with their canonical versions using the mailmap mechanism.\n */\nvoid apply_mailmap_to_header(struct strbuf *, const char **, struct string_list *);\n\n/*\n * Compare split idents for equality or strict ordering. Note that we\n * compare only the ident part of the line, ignoring any timestamp.\n *\n * Because there are two fields, we must choose one as the primary key; we\n * currently arbitrarily pick the email.\n */\nint ident_cmp(const struct ident_split *, const struct ident_split *);\n\nstruct cache_def {\n\tstruct strbuf path;\n\tint flags;\n\tint track_flags;\n\tint prefix_len_stat_func;\n};\n#define CACHE_DEF_INIT { \\\n\t.path = STRBUF_INIT, \\\n}\nstatic inline void cache_def_clear(struct cache_def *cache)\n{\n\tstrbuf_release(&cache->path);\n}\n\nint has_symlink_leading_path(const char *name, int len);\nint threaded_has_symlink_leading_path(struct cache_def *, const char *, int);\nint check_leading_path(const char *name, int len, int warn_on_lstat_err);\nint has_dirs_only_path(const char *name, int len, int prefix_len);\nvoid invalidate_lstat_cache(void);\nvoid schedule_dir_for_removal(const char *name, int len);\nvoid remove_scheduled_dirs(void);\n\nstruct pack_window {\n\tstruct pack_window *next;\n\tunsigned char *base;\n\toff_t offset;\n\tsize_t len;\n\tunsigned int last_used;\n\tunsigned int inuse_cnt;\n};\n\nstruct pack_entry {\n\toff_t offset;\n\tstruct packed_git *p;\n};\n\n/*\n * Create a temporary file rooted in the object database directory, or\n * die on failure. The filename is taken from \"pattern\", which should have the\n * usual \"XXXXXX\" trailer, and the resulting filename is written into the\n * \"template\" buffer. Returns the open descriptor.\n */\nint odb_mkstemp(struct strbuf *temp_filename, const char *pattern);\n\n/*\n * Create a pack .keep file named \"name\" (which should generally be the output\n * of odb_pack_name). Returns a file descriptor opened for writing, or -1 on\n * error.\n */\nint odb_pack_keep(const char *name);\n\n/*\n * Set this to 0 to prevent oid_object_info_extended() from fetching missing\n * blobs. This has a difference only if extensions.partialClone is set.\n *\n * Its default value is 1.\n */\nextern int fetch_if_missing;\n\n/* Dumb servers support */\nint update_server_info(int);\n\nconst char *get_log_output_encoding(void);\nconst char *get_commit_output_encoding(void);\n\nint committer_ident_sufficiently_given(void);\nint author_ident_sufficiently_given(void);\n\nextern const char *git_commit_encoding;\nextern const char *git_log_output_encoding;\nextern const char *git_mailmap_file;\nextern const char *git_mailmap_blob;\n\n/* IO helper functions */\nvoid maybe_flush_or_die(FILE *, const char *);\n__attribute__((format (printf, 2, 3)))\nvoid fprintf_or_die(FILE *, const char *fmt, ...);\nvoid fwrite_or_die(FILE *f, const void *buf, size_t count);\nvoid fflush_or_die(FILE *f);\n\n#define COPY_READ_ERROR (-2)\n#define COPY_WRITE_ERROR (-3)\nint copy_fd(int ifd, int ofd);\nint copy_file(const char *dst, const char *src, int mode);\nint copy_file_with_time(const char *dst, const char *src, int mode);\n\nvoid write_or_die(int fd, const void *buf, size_t count);\nvoid fsync_or_die(int fd, const char *);\nint fsync_component(enum fsync_component component, int fd);\nvoid fsync_component_or_die(enum fsync_component component, int fd, const char *msg);\n\nstatic inline int batch_fsync_enabled(enum fsync_component component)\n{\n\treturn (fsync_components & component) && (fsync_method == FSYNC_METHOD_BATCH);\n}\n\nssize_t read_in_full(int fd, void *buf, size_t count);\nssize_t write_in_full(int fd, const void *buf, size_t count);\nssize_t pread_in_full(int fd, void *buf, size_t count, off_t offset);\n\nstatic inline ssize_t write_str_in_full(int fd, const char *str)\n{\n\treturn write_in_full(fd, str, strlen(str));\n}\n\n/**\n * Open (and truncate) the file at path, write the contents of buf to it,\n * and close it. Dies if any errors are encountered.\n */\nvoid write_file_buf(const char *path, const char *buf, size_t len);\n\n/**\n * Like write_file_buf(), but format the contents into a buffer first.\n * Additionally, write_file() will append a newline if one is not already\n * present, making it convenient to write text files:\n *\n *   write_file(path, \"counter: %d\", ctr);\n */\n__attribute__((format (printf, 2, 3)))\nvoid write_file(const char *path, const char *fmt, ...);\n\n/* pager.c */\nvoid setup_pager(void);\nint pager_in_use(void);\nextern int pager_use_color;\nint term_columns(void);\nvoid term_clear_line(void);\nint decimal_width(uintmax_t);\nint check_pager_config(const char *cmd);\nvoid prepare_pager_args(struct child_process *, const char *pager);\n\nextern const char *editor_program;\nextern const char *askpass_program;\nextern const char *excludes_file;\n\n/* base85 */\nint decode_85(char *dst, const char *line, int linelen);\nvoid encode_85(char *buf, const unsigned char *data, int bytes);\n\n/* pkt-line.c */\nvoid packet_trace_identity(const char *prog);",
        "base_contents": "/*\n * Return an abbreviated sha1 unique within this repository's object database.\n * The result will be at least `len` characters long, and will be NUL\n * terminated.\n *\n * The non-`_r` version returns a static buffer which remains valid until 4\n * more calls to find_unique_abbrev are made.\n *\n * The `_r` variant writes to a buffer supplied by the caller, which must be at\n * least `GIT_MAX_HEXSZ + 1` bytes. The return value is the number of bytes\n * written (excluding the NUL terminator).\n *\n * Note that while this version avoids the static buffer, it is not fully\n * reentrant, as it calls into other non-reentrant git code.\n */\nconst char *repo_find_unique_abbrev(struct repository *r, const struct object_id *oid, int len);\n#define find_unique_abbrev(oid, len) repo_find_unique_abbrev(the_repository, oid, len)\nint repo_find_unique_abbrev_r(struct repository *r, char *hex, const struct object_id *oid, int len);\n#define find_unique_abbrev_r(hex, oid, len) repo_find_unique_abbrev_r(the_repository, hex, oid, len)\n\n/* set default permissions by passing mode arguments to open(2) */\nint git_mkstemps_mode(char *pattern, int suffix_len, int mode);\nint git_mkstemp_mode(char *pattern, int mode);\n\n/*\n * NOTE NOTE NOTE!!\n *\n * PERM_UMASK, OLD_PERM_GROUP and OLD_PERM_EVERYBODY enumerations must\n * not be changed. Old repositories have core.sharedrepository written in\n * numeric format, and therefore these values are preserved for compatibility\n * reasons.\n */\nenum sharedrepo {\n\tPERM_UMASK          = 0,\n\tOLD_PERM_GROUP      = 1,\n\tOLD_PERM_EVERYBODY  = 2,\n\tPERM_GROUP          = 0660,\n\tPERM_EVERYBODY      = 0664\n};\nint git_config_perm(const char *var, const char *value);\nint adjust_shared_perm(const char *path);\n\n/*\n * Create the directory containing the named path, using care to be\n * somewhat safe against races. Return one of the scld_error values to\n * indicate success/failure. On error, set errno to describe the\n * problem.\n *\n * SCLD_VANISHED indicates that one of the ancestor directories of the\n * path existed at one point during the function call and then\n * suddenly vanished, probably because another process pruned the\n * directory while we were working.  To be robust against this kind of\n * race, callers might want to try invoking the function again when it\n * returns SCLD_VANISHED.\n *\n * safe_create_leading_directories() temporarily changes path while it\n * is working but restores it before returning.\n * safe_create_leading_directories_const() doesn't modify path, even\n * temporarily. Both these variants adjust the permissions of the\n * created directories to honor core.sharedRepository, so they are best\n * suited for files inside the git dir. For working tree files, use\n * safe_create_leading_directories_no_share() instead, as it ignores\n * the core.sharedRepository setting.\n */\nenum scld_error {\n\tSCLD_OK = 0,\n\tSCLD_FAILED = -1,\n\tSCLD_PERMS = -2,\n\tSCLD_EXISTS = -3,\n\tSCLD_VANISHED = -4\n};\nenum scld_error safe_create_leading_directories(char *path);\nenum scld_error safe_create_leading_directories_const(const char *path);\nenum scld_error safe_create_leading_directories_no_share(char *path);\n\nint mkdir_in_gitdir(const char *path);\nchar *interpolate_path(const char *path, int real_home);\n/* NEEDSWORK: remove this synonym once in-flight topics have migrated */\n#define expand_user_path interpolate_path\nconst char *enter_repo(const char *path, int strict);\nstatic inline int is_absolute_path(const char *path)\n{\n\treturn is_dir_sep(path[0]) || has_dos_drive_prefix(path);\n}\nint is_directory(const char *);\nchar *strbuf_realpath(struct strbuf *resolved, const char *path,\n\t\t      int die_on_error);\nchar *strbuf_realpath_forgiving(struct strbuf *resolved, const char *path,\n\t\t\t\tint die_on_error);\nchar *real_pathdup(const char *path, int die_on_error);\nconst char *absolute_path(const char *path);\nchar *absolute_pathdup(const char *path);\nconst char *remove_leading_path(const char *in, const char *prefix);\nconst char *relative_path(const char *in, const char *prefix, struct strbuf *sb);\nint normalize_path_copy_len(char *dst, const char *src, int *prefix_len);\nint normalize_path_copy(char *dst, const char *src);\nint longest_ancestor_length(const char *path, struct string_list *prefixes);\nchar *strip_path_suffix(const char *path, const char *suffix);\nint daemon_avoid_alias(const char *path);\n\n/*\n * These functions match their is_hfs_dotgit() counterparts; see utf8.h for\n * details.\n */\nint is_ntfs_dotgit(const char *name);\nint is_ntfs_dotgitmodules(const char *name);\nint is_ntfs_dotgitignore(const char *name);\nint is_ntfs_dotgitattributes(const char *name);\nint is_ntfs_dotmailmap(const char *name);\n\n/*\n * Returns true iff \"str\" could be confused as a command-line option when\n * passed to a sub-program like \"ssh\". Note that this has nothing to do with\n * shell-quoting, which should be handled separately; we're assuming here that\n * the string makes it verbatim to the sub-program.\n */\nint looks_like_command_line_option(const char *str);\n\n/**\n * Return a newly allocated string with the evaluation of\n * \"$XDG_CONFIG_HOME/$subdir/$filename\" if $XDG_CONFIG_HOME is non-empty, otherwise\n * \"$HOME/.config/$subdir/$filename\". Return NULL upon error.\n */\nchar *xdg_config_home_for(const char *subdir, const char *filename);\n\n/**\n * Return a newly allocated string with the evaluation of\n * \"$XDG_CONFIG_HOME/git/$filename\" if $XDG_CONFIG_HOME is non-empty, otherwise\n * \"$HOME/.config/git/$filename\". Return NULL upon error.\n */\nchar *xdg_config_home(const char *filename);\n\n/**\n * Return a newly allocated string with the evaluation of\n * \"$XDG_CACHE_HOME/git/$filename\" if $XDG_CACHE_HOME is non-empty, otherwise\n * \"$HOME/.cache/git/$filename\". Return NULL upon error.\n */\nchar *xdg_cache_home(const char *filename);\n\nint git_open_cloexec(const char *name, int flags);\n#define git_open(name) git_open_cloexec(name, O_RDONLY)\n\n/**\n * unpack_loose_header() initializes the data stream needed to unpack\n * a loose object header.\n *\n * Returns:\n *\n * - ULHR_OK on success\n * - ULHR_BAD on error\n * - ULHR_TOO_LONG if the header was too long\n *\n * It will only parse up to MAX_HEADER_LEN bytes unless an optional\n * \"hdrbuf\" argument is non-NULL. This is intended for use with\n * OBJECT_INFO_ALLOW_UNKNOWN_TYPE to extract the bad type for (error)\n * reporting. The full header will be extracted to \"hdrbuf\" for use\n * with parse_loose_header(), ULHR_TOO_LONG will still be returned\n * from this function to indicate that the header was too long.\n */\nenum unpack_loose_header_result {\n\tULHR_OK,\n\tULHR_BAD,\n\tULHR_TOO_LONG,\n};\nenum unpack_loose_header_result unpack_loose_header(git_zstream *stream,\n\t\t\t\t\t\t    unsigned char *map,\n\t\t\t\t\t\t    unsigned long mapsize,\n\t\t\t\t\t\t    void *buffer,\n\t\t\t\t\t\t    unsigned long bufsiz,\n\t\t\t\t\t\t    struct strbuf *hdrbuf);\n\n/**\n * parse_loose_header() parses the starting \"<type> <len>\\0\" of an\n * object. If it doesn't follow that format -1 is returned. To check\n * the validity of the <type> populate the \"typep\" in the \"struct\n * object_info\". It will be OBJ_BAD if the object type is unknown. The\n * parsed <len> can be retrieved via \"oi->sizep\", and from there\n * passed to unpack_loose_rest().\n */\nstruct object_info;\nint parse_loose_header(const char *hdr, struct object_info *oi);\n\n/**\n * With in-core object data in \"buf\", rehash it to make sure the\n * object name actually matches \"oid\" to detect object corruption.\n *\n * A negative value indicates an error, usually that the OID is not\n * what we expected, but it might also indicate another error.\n */\nint check_object_signature(struct repository *r, const struct object_id *oid,\n\t\t\t   void *map, unsigned long size,\n\t\t\t   enum object_type type);\n\n/**\n * A streaming version of check_object_signature().\n * Try reading the object named with \"oid\" using\n * the streaming interface and rehash it to do the same.\n */\nint stream_object_signature(struct repository *r, const struct object_id *oid);\n\nint finalize_object_file(const char *tmpfile, const char *filename);\n\n/* Helper to check and \"touch\" a file */\nint check_and_freshen_file(const char *fn, int freshen);\n\nextern const signed char hexval_table[256];\nstatic inline unsigned int hexval(unsigned char c)\n{\n\treturn hexval_table[c];\n}\n\n/*\n * Convert two consecutive hexadecimal digits into a char.  Return a\n * negative value on error.  Don't run over the end of short strings.\n */\nstatic inline int hex2chr(const char *s)\n{\n\tunsigned int val = hexval(s[0]);\n\treturn (val & ~0xf) ? val : (val << 4) | hexval(s[1]);\n}\n\n/* Convert to/from hex/sha1 representation */\n#define MINIMUM_ABBREV minimum_abbrev\n#define DEFAULT_ABBREV default_abbrev\n\n/* used when the code does not know or care what the default abbrev is */\n#define FALLBACK_DEFAULT_ABBREV 7\n\nstruct object_context {\n\tunsigned short mode;\n\t/*\n\t * symlink_path is only used by get_tree_entry_follow_symlinks,\n\t * and only for symlinks that point outside the repository.\n\t */\n\tstruct strbuf symlink_path;\n\t/*\n\t * If GET_OID_RECORD_PATH is set, this will record path (if any)\n\t * found when resolving the name. The caller is responsible for\n\t * releasing the memory.\n\t */\n\tchar *path;\n};\n\n#define GET_OID_QUIETLY           01\n#define GET_OID_COMMIT            02\n#define GET_OID_COMMITTISH        04\n#define GET_OID_TREE             010\n#define GET_OID_TREEISH          020\n#define GET_OID_BLOB             040\n#define GET_OID_FOLLOW_SYMLINKS 0100\n#define GET_OID_RECORD_PATH     0200\n#define GET_OID_ONLY_TO_DIE    04000\n#define GET_OID_REQUIRE_PATH  010000\n\n#define GET_OID_DISAMBIGUATORS \\\n\t(GET_OID_COMMIT | GET_OID_COMMITTISH | \\\n\tGET_OID_TREE | GET_OID_TREEISH | \\\n\tGET_OID_BLOB)\n\nenum get_oid_result {\n\tFOUND = 0,\n\tMISSING_OBJECT = -1, /* The requested object is missing */\n\tSHORT_NAME_AMBIGUOUS = -2,\n\t/* The following only apply when symlinks are followed */\n\tDANGLING_SYMLINK = -4, /*\n\t\t\t\t* The initial symlink is there, but\n\t\t\t\t* (transitively) points to a missing\n\t\t\t\t* in-tree file\n\t\t\t\t*/\n\tSYMLINK_LOOP = -5,\n\tNOT_DIR = -6, /*\n\t\t       * Somewhere along the symlink chain, a path is\n\t\t       * requested which contains a file as a\n\t\t       * non-final element.\n\t\t       */\n};\n\nint repo_get_oid(struct repository *r, const char *str, struct object_id *oid);\n__attribute__((format (printf, 2, 3)))\nint get_oidf(struct object_id *oid, const char *fmt, ...);\nint repo_get_oid_commit(struct repository *r, const char *str, struct object_id *oid);\nint repo_get_oid_committish(struct repository *r, const char *str, struct object_id *oid);\nint repo_get_oid_tree(struct repository *r, const char *str, struct object_id *oid);\nint repo_get_oid_treeish(struct repository *r, const char *str, struct object_id *oid);\nint repo_get_oid_blob(struct repository *r, const char *str, struct object_id *oid);\nint repo_get_oid_mb(struct repository *r, const char *str, struct object_id *oid);\nvoid maybe_die_on_misspelt_object_name(struct repository *repo,\n\t\t\t\t       const char *name,\n\t\t\t\t       const char *prefix);\nenum get_oid_result get_oid_with_context(struct repository *repo, const char *str,\n\t\t\t\t\t unsigned flags, struct object_id *oid,\n\t\t\t\t\t struct object_context *oc);\n\n#define get_oid(str, oid)\t\trepo_get_oid(the_repository, str, oid)\n#define get_oid_commit(str, oid)\trepo_get_oid_commit(the_repository, str, oid)\n#define get_oid_committish(str, oid)\trepo_get_oid_committish(the_repository, str, oid)\n#define get_oid_tree(str, oid)\t\trepo_get_oid_tree(the_repository, str, oid)\n#define get_oid_treeish(str, oid)\trepo_get_oid_treeish(the_repository, str, oid)\n#define get_oid_blob(str, oid)\t\trepo_get_oid_blob(the_repository, str, oid)\n#define get_oid_mb(str, oid) \t\trepo_get_oid_mb(the_repository, str, oid)\n\ntypedef int each_abbrev_fn(const struct object_id *oid, void *);\nint repo_for_each_abbrev(struct repository *r, const char *prefix, each_abbrev_fn, void *);\n#define for_each_abbrev(prefix, fn, data) repo_for_each_abbrev(the_repository, prefix, fn, data)\n\nint set_disambiguate_hint_config(const char *var, const char *value);\n\n/*\n * Try to read a SHA1 in hexadecimal format from the 40 characters\n * starting at hex.  Write the 20-byte result to sha1 in binary form.\n * Return 0 on success.  Reading stops if a NUL is encountered in the\n * input, so it is safe to pass this function an arbitrary\n * null-terminated string.\n */\nint get_sha1_hex(const char *hex, unsigned char *sha1);\nint get_oid_hex(const char *hex, struct object_id *sha1);\n\n/* Like get_oid_hex, but for an arbitrary hash algorithm. */\nint get_oid_hex_algop(const char *hex, struct object_id *oid, const struct git_hash_algo *algop);\n\n/*\n * Read `len` pairs of hexadecimal digits from `hex` and write the\n * values to `binary` as `len` bytes. Return 0 on success, or -1 if\n * the input does not consist of hex digits).\n */\nint hex_to_bytes(unsigned char *binary, const char *hex, size_t len);\n\n/*\n * Convert a binary hash in \"unsigned char []\" or an object name in\n * \"struct object_id *\" to its hex equivalent. The `_r` variant is reentrant,\n * and writes the NUL-terminated output to the buffer `out`, which must be at\n * least `GIT_MAX_HEXSZ + 1` bytes, and returns a pointer to out for\n * convenience.\n *\n * The non-`_r` variant returns a static buffer, but uses a ring of 4\n * buffers, making it safe to make multiple calls for a single statement, like:\n *\n *   printf(\"%s -> %s\", hash_to_hex(one), hash_to_hex(two));\n *   printf(\"%s -> %s\", oid_to_hex(one), oid_to_hex(two));\n */\nchar *hash_to_hex_algop_r(char *buffer, const unsigned char *hash, const struct git_hash_algo *);\nchar *oid_to_hex_r(char *out, const struct object_id *oid);\nchar *hash_to_hex_algop(const unsigned char *hash, const struct git_hash_algo *);\t/* static buffer result! */\nchar *hash_to_hex(const unsigned char *hash);\t\t\t\t\t\t/* same static buffer */\nchar *oid_to_hex(const struct object_id *oid);\t\t\t\t\t\t/* same static buffer */\n\n/*\n * Parse a 40-character hexadecimal object ID starting from hex, updating the\n * pointer specified by end when parsing stops.  The resulting object ID is\n * stored in oid.  Returns 0 on success.  Parsing will stop on the first NUL or\n * other invalid character.  end is only updated on success; otherwise, it is\n * unmodified.\n */\nint parse_oid_hex(const char *hex, struct object_id *oid, const char **end);\n\n/* Like parse_oid_hex, but for an arbitrary hash algorithm. */\nint parse_oid_hex_algop(const char *hex, struct object_id *oid, const char **end,\n\t\t\tconst struct git_hash_algo *algo);\n\n\n/*\n * These functions work like get_oid_hex and parse_oid_hex, but they will parse\n * a hex value for any algorithm. The algorithm is detected based on the length\n * and the algorithm in use is returned. If this is not a hex object ID in any\n * algorithm, returns GIT_HASH_UNKNOWN.\n */\nint get_oid_hex_any(const char *hex, struct object_id *oid);\nint parse_oid_hex_any(const char *hex, struct object_id *oid, const char **end);\n\n/*\n * This reads short-hand syntax that not only evaluates to a commit\n * object name, but also can act as if the end user spelled the name\n * of the branch from the command line.\n *\n * - \"@{-N}\" finds the name of the Nth previous branch we were on, and\n *   places the name of the branch in the given buf and returns the\n *   number of characters parsed if successful.\n *\n * - \"<branch>@{upstream}\" finds the name of the other ref that\n *   <branch> is configured to merge with (missing <branch> defaults\n *   to the current branch), and places the name of the branch in the\n *   given buf and returns the number of characters parsed if\n *   successful.\n *\n * If the input is not of the accepted format, it returns a negative\n * number to signal an error.\n *\n * If the input was ok but there are not N branch switches in the\n * reflog, it returns 0.\n */\n#define INTERPRET_BRANCH_LOCAL (1<<0)\n#define INTERPRET_BRANCH_REMOTE (1<<1)\n#define INTERPRET_BRANCH_HEAD (1<<2)\nstruct interpret_branch_name_options {\n\t/*\n\t * If \"allowed\" is non-zero, it is a treated as a bitfield of allowable\n\t * expansions: local branches (\"refs/heads/\"), remote branches\n\t * (\"refs/remotes/\"), or \"HEAD\". If no \"allowed\" bits are set, any expansion is\n\t * allowed, even ones to refs outside of those namespaces.\n\t */\n\tunsigned allowed;\n\n\t/*\n\t * If ^{upstream} or ^{push} (or equivalent) is requested, and the\n\t * branch in question does not have such a reference, return -1 instead\n\t * of die()-ing.\n\t */\n\tunsigned nonfatal_dangling_mark : 1;\n};\nint repo_interpret_branch_name(struct repository *r,\n\t\t\t       const char *str, int len,\n\t\t\t       struct strbuf *buf,\n\t\t\t       const struct interpret_branch_name_options *options);\n#define interpret_branch_name(str, len, buf, options) \\\n\trepo_interpret_branch_name(the_repository, str, len, buf, options)\n\nint validate_headref(const char *ref);\n\nint base_name_compare(const char *name1, size_t len1, int mode1,\n\t\t      const char *name2, size_t len2, int mode2);\nint df_name_compare(const char *name1, size_t len1, int mode1,\n\t\t    const char *name2, size_t len2, int mode2);\nint name_compare(const char *name1, size_t len1, const char *name2, size_t len2);\nint cache_name_stage_compare(const char *name1, int len1, int stage1, const char *name2, int len2, int stage2);\n\nvoid *read_object_with_reference(struct repository *r,\n\t\t\t\t const struct object_id *oid,\n\t\t\t\t enum object_type required_type,\n\t\t\t\t unsigned long *size,\n\t\t\t\t struct object_id *oid_ret);\n\nstruct object *repo_peel_to_type(struct repository *r,\n\t\t\t\t const char *name, int namelen,\n\t\t\t\t struct object *o, enum object_type);\n#define peel_to_type(name, namelen, obj, type) \\\n\trepo_peel_to_type(the_repository, name, namelen, obj, type)\n\n#define IDENT_STRICT\t       1\n#define IDENT_NO_DATE\t       2\n#define IDENT_NO_NAME\t       4\n\nenum want_ident {\n\tWANT_BLANK_IDENT,\n\tWANT_AUTHOR_IDENT,\n\tWANT_COMMITTER_IDENT\n};\n\nconst char *git_author_info(int);\nconst char *git_committer_info(int);\nconst char *fmt_ident(const char *name, const char *email,\n\t\t      enum want_ident whose_ident,\n\t\t      const char *date_str, int);\nconst char *fmt_name(enum want_ident);\nconst char *ident_default_name(void);\nconst char *ident_default_email(void);\nconst char *git_editor(void);\nconst char *git_sequence_editor(void);\nconst char *git_pager(int stdout_is_tty);\nint is_terminal_dumb(void);\nint git_ident_config(const char *, const char *, void *);\n/*\n * Prepare an ident to fall back on if the user didn't configure it.\n */\nvoid prepare_fallback_ident(const char *name, const char *email);\nvoid reset_ident_date(void);\n\nstruct ident_split {\n\tconst char *name_begin;\n\tconst char *name_end;\n\tconst char *mail_begin;\n\tconst char *mail_end;\n\tconst char *date_begin;\n\tconst char *date_end;\n\tconst char *tz_begin;\n\tconst char *tz_end;\n};\n/*\n * Signals an success with 0, but time part of the result may be NULL\n * if the input lacks timestamp and zone\n */\nint split_ident_line(struct ident_split *, const char *, int);\n\n/*\n * Given a commit or tag object buffer and the commit or tag headers, replaces\n * the idents in the headers with their canonical versions using the mailmap mechanism.\n */\nvoid apply_mailmap_to_header(struct strbuf *, const char **, struct string_list *);\n\n/*\n * Compare split idents for equality or strict ordering. Note that we\n * compare only the ident part of the line, ignoring any timestamp.\n *\n * Because there are two fields, we must choose one as the primary key; we\n * currently arbitrarily pick the email.\n */\nint ident_cmp(const struct ident_split *, const struct ident_split *);\n\nstruct cache_def {\n\tstruct strbuf path;\n\tint flags;\n\tint track_flags;\n\tint prefix_len_stat_func;\n};\n#define CACHE_DEF_INIT { \\\n\t.path = STRBUF_INIT, \\\n}\nstatic inline void cache_def_clear(struct cache_def *cache)\n{\n\tstrbuf_release(&cache->path);\n}\n\nint has_symlink_leading_path(const char *name, int len);\nint threaded_has_symlink_leading_path(struct cache_def *, const char *, int);\nint check_leading_path(const char *name, int len, int warn_on_lstat_err);\nint has_dirs_only_path(const char *name, int len, int prefix_len);\nvoid invalidate_lstat_cache(void);\nvoid schedule_dir_for_removal(const char *name, int len);\nvoid remove_scheduled_dirs(void);\n\nstruct pack_window {\n\tstruct pack_window *next;\n\tunsigned char *base;\n\toff_t offset;\n\tsize_t len;\n\tunsigned int last_used;\n\tunsigned int inuse_cnt;\n};\n\nstruct pack_entry {\n\toff_t offset;\n\tstruct packed_git *p;\n};\n\n/*\n * Create a temporary file rooted in the object database directory, or\n * die on failure. The filename is taken from \"pattern\", which should have the\n * usual \"XXXXXX\" trailer, and the resulting filename is written into the\n * \"template\" buffer. Returns the open descriptor.\n */\nint odb_mkstemp(struct strbuf *temp_filename, const char *pattern);\n\n/*\n * Create a pack .keep file named \"name\" (which should generally be the output\n * of odb_pack_name). Returns a file descriptor opened for writing, or -1 on\n * error.\n */\nint odb_pack_keep(const char *name);\n\n/*\n * Set this to 0 to prevent oid_object_info_extended() from fetching missing\n * blobs. This has a difference only if extensions.partialClone is set.\n *\n * Its default value is 1.\n */\nextern int fetch_if_missing;\n\n/* Dumb servers support */\nint update_server_info(int);\n\nconst char *get_log_output_encoding(void);\nconst char *get_commit_output_encoding(void);\n\nint committer_ident_sufficiently_given(void);\nint author_ident_sufficiently_given(void);\n\nextern const char *git_commit_encoding;\nextern const char *git_log_output_encoding;\nextern const char *git_mailmap_file;\nextern const char *git_mailmap_blob;\n\n/* IO helper functions */\nvoid maybe_flush_or_die(FILE *, const char *);\n__attribute__((format (printf, 2, 3)))\nvoid fprintf_or_die(FILE *, const char *fmt, ...);\nvoid fwrite_or_die(FILE *f, const void *buf, size_t count);\nvoid fflush_or_die(FILE *f);\n\n#define COPY_READ_ERROR (-2)\n#define COPY_WRITE_ERROR (-3)\nint copy_fd(int ifd, int ofd);\nint copy_file(const char *dst, const char *src, int mode);\nint copy_file_with_time(const char *dst, const char *src, int mode);\n\n/*\n * Compare the file mode and contents of two given files.\n *\n * If both files are actually symbolic links, the function returns 1 if the link\n * targets are identical or 0 if they are not.\n *\n * If any of the two files cannot be accessed or in case of read failures, this\n * function returns 0.\n *\n * If the file modes and contents are identical, the function returns 1,\n * otherwise it returns 0.\n */\nint do_files_match(const char *path1, const char *path2);\n\nvoid write_or_die(int fd, const void *buf, size_t count);\nvoid fsync_or_die(int fd, const char *);\nint fsync_component(enum fsync_component component, int fd);\nvoid fsync_component_or_die(enum fsync_component component, int fd, const char *msg);\n\nstatic inline int batch_fsync_enabled(enum fsync_component component)\n{\n\treturn (fsync_components & component) && (fsync_method == FSYNC_METHOD_BATCH);\n}\n\nssize_t read_in_full(int fd, void *buf, size_t count);\nssize_t write_in_full(int fd, const void *buf, size_t count);\nssize_t pread_in_full(int fd, void *buf, size_t count, off_t offset);\n\nstatic inline ssize_t write_str_in_full(int fd, const char *str)\n{\n\treturn write_in_full(fd, str, strlen(str));\n}\n\n/**\n * Open (and truncate) the file at path, write the contents of buf to it,\n * and close it. Dies if any errors are encountered.\n */\nvoid write_file_buf(const char *path, const char *buf, size_t len);\n\n/**\n * Like write_file_buf(), but format the contents into a buffer first.\n * Additionally, write_file() will append a newline if one is not already\n * present, making it convenient to write text files:\n *\n *   write_file(path, \"counter: %d\", ctr);\n */\n__attribute__((format (printf, 2, 3)))\nvoid write_file(const char *path, const char *fmt, ...);\n\n/* pager.c */\nvoid setup_pager(void);\nint pager_in_use(void);\nextern int pager_use_color;\nint term_columns(void);\nvoid term_clear_line(void);\nint decimal_width(uintmax_t);\nint check_pager_config(const char *cmd);\nvoid prepare_pager_args(struct child_process *, const char *pager);\n\nextern const char *editor_program;\nextern const char *askpass_program;\nextern const char *excludes_file;\n\n/* base85 */\nint decode_85(char *dst, const char *line, int linelen);\nvoid encode_85(char *buf, const unsigned char *data, int bytes);\n\n/* pkt-line.c */\nvoid packet_trace_identity(const char *prog);",
        "res_region": "int cmp_cache_name_compare(const void *a_, const void *b_);",
        "lookback": "",
        "lookahead": "",
        "label": [
            "ours",
            "complex_conflict"
        ],
        "start_line": 557,
        "end_line": 1851,
        "merge_gen_region": null,
        "confidence": 0.09532997012138367,
        "hesitated": true
    }
]