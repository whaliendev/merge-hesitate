[
    {
        "a_contents": "struct config_reader {\n\t/*\n\t * These members record the \"current\" config source, which can be\n\t * accessed by parsing callbacks.\n\t *\n\t * The \"source\" variable will be non-NULL only when we are actually\n\t * parsing a real config source (file, blob, cmdline, etc).\n\t *\n\t * The \"config_kvi\" variable will be non-NULL only when we are feeding\n\t * cached config from a configset into a callback.\n\t *\n\t * They cannot be non-NULL at the same time. If they are both NULL, then\n\t * we aren't parsing anything (and depending on the function looking at\n\t * the variables, it's either a bug for it to be called in the first\n\t * place, or it's a function which can be reused for non-config\n\t * purposes, and should fall back to some sane behavior).\n\t */\n\tstruct config_source *source;\n\tstruct key_value_info *config_kvi;\n\t/*\n\t * The \"scope\" of the current config source being parsed (repo, global,\n\t * etc). Like \"source\", this is only set when parsing a config source.\n\t * It's not part of \"source\" because it transcends a single file (i.e.,\n\t * a file included from .git/config is still in \"repo\" scope).\n\t *\n\t * When iterating through a configset, the equivalent value is\n\t * \"config_kvi.scope\" (see above).\n\t */\n\tenum config_scope parsing_scope;\n};\n/*\n * Where possible, prefer to accept \"struct config_reader\" as an arg than to use\n * \"the_reader\". \"the_reader\" should only be used if that is infeasible, e.g. in\n * a public function.\n */\nstatic struct config_reader the_reader;\n\nstatic inline void config_reader_push_source(struct config_reader *reader,\n\t\t\t\t\t     struct config_source *top)\n{\n\ttop->prev = reader->source;\n\treader->source = top;\n}\n\nstatic inline struct config_source *config_reader_pop_source(struct config_reader *reader)\n{\n\tstruct config_source *ret;\n\tif (!reader->source)\n\t\tBUG(\"tried to pop config source, but we weren't reading config\");\n\tret = reader->source;\n\treader->source = reader->source->prev;\n\treturn ret;\n}\n\nstatic inline void config_reader_set_kvi(struct config_reader *reader,\n\t\t\t\t\t struct key_value_info *kvi)\n{\n\treader->config_kvi = kvi;\n}\n\nstatic inline void config_reader_set_scope(struct config_reader *reader,\n\t\t\t\t\t   enum config_scope scope)\n{\n\treader->parsing_scope = scope;\n}\n",
        "b_contents": "",
        "base_contents": "struct config_reader {\n\t/*\n\t * These members record the \"current\" config source, which can be\n\t * accessed by parsing callbacks.\n\t *\n\t * The \"source\" variable will be non-NULL only when we are actually\n\t * parsing a real config source (file, blob, cmdline, etc).\n\t *\n\t * The \"config_kvi\" variable will be non-NULL only when we are feeding\n\t * cached config from a configset into a callback.\n\t *\n\t * They cannot be non-NULL at the same time. If they are both NULL, then\n\t * we aren't parsing anything (and depending on the function looking at\n\t * the variables, it's either a bug for it to be called in the first\n\t * place, or it's a function which can be reused for non-config\n\t * purposes, and should fall back to some sane behavior).\n\t */\n\tstruct config_source *source;\n\tstruct key_value_info *config_kvi;\n\t/*\n\t * The \"scope\" of the current config source being parsed (repo, global,\n\t * etc). Like \"source\", this is only set when parsing a config source.\n\t * It's not part of \"source\" because it transcends a single file (i.e.,\n\t * a file included from .git/config is still in \"repo\" scope).\n\t *\n\t * When iterating through a configset, the equivalent value is\n\t * \"config_kvi.scope\" (see above).\n\t */\n\tenum config_scope parsing_scope;\n};\n/*\n * Where possible, prefer to accept \"struct config_reader\" as an arg than to use\n * \"the_reader\". \"the_reader\" should only be used if that is infeasible, e.g. in\n * a public function.\n */\nstatic struct config_reader the_reader;\n\nstatic inline void config_reader_push_source(struct config_reader *reader,\n\t\t\t\t\t     struct config_source *top)\n{\n\tif (reader->config_kvi)\n\t\tBUG(\"source should not be set while iterating a config set\");\n\ttop->prev = reader->source;\n\treader->source = top;\n}\n\nstatic inline struct config_source *config_reader_pop_source(struct config_reader *reader)\n{\n\tstruct config_source *ret;\n\tif (!reader->source)\n\t\tBUG(\"tried to pop config source, but we weren't reading config\");\n\tret = reader->source;\n\treader->source = reader->source->prev;\n\treturn ret;\n}\n\nstatic inline void config_reader_set_kvi(struct config_reader *reader,\n\t\t\t\t\t struct key_value_info *kvi)\n{\n\tif (kvi && (reader->source || reader->parsing_scope))\n\t\tBUG(\"kvi should not be set while parsing a config source\");\n\treader->config_kvi = kvi;\n}\n\nstatic inline void config_reader_set_scope(struct config_reader *reader,\n\t\t\t\t\t   enum config_scope scope)\n{\n\tif (scope && reader->config_kvi)\n\t\tBUG(\"scope should only be set when iterating through a config source\");\n\treader->parsing_scope = scope;\n}\n",
        "res_region": "",
        "lookback": "static int zlib_compression_seen;",
        "lookahead": "static int pack_compression_seen;",
        "label": [
            "base",
            "base_empty"
        ],
        "start_line": 71,
        "end_line": 212,
        "merge_gen_region": null,
        "confidence": 0.7831318378448486,
        "hesitated": true
    }
]